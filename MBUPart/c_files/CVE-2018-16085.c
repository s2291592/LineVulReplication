void CoordinatorImpl::PerformNextQueuedGlobalMemoryDump() {
DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
QueuedRequest* request = GetCurrentRequest();

if (request == nullptr)
return;

std::vector<QueuedRequestDispatcher::ClientInfo> clients;
for (const auto& kv : clients_) {
auto client_identity = kv.second->identity;
const base::ProcessId pid = GetProcessIdForClientIdentity(client_identity);
if (pid == base::kNullProcessId) {
VLOG(1) << "Couldn't find a PID for client \"" << client_identity.name()
<< "." << client_identity.instance() << "\"";
continue;
}
clients.emplace_back(kv.second->client.get(), pid, kv.second->process_type);
}

  auto chrome_callback = base::Bind(
      &CoordinatorImpl::OnChromeMemoryDumpResponse, base::Unretained(this));
  auto os_callback = base::Bind(&CoordinatorImpl::OnOSMemoryDumpResponse,
                                base::Unretained(this), request->dump_guid);
QueuedRequestDispatcher::SetUpAndDispatch(request, clients, chrome_callback,
os_callback);

base::SequencedTaskRunnerHandle::Get()->PostDelayedTask(
FROM_HERE,
base::BindOnce(&CoordinatorImpl::OnQueuedRequestTimedOut,
                     base::Unretained(this), request->dump_guid),
client_process_timeout_);

if (request->args.add_to_trace && heap_profiler_) {
request->heap_dump_in_progress = true;

// |IsArgumentFilterEnabled| is the round-about way of asking to anonymize
// the trace. The only way that PII gets leaked is if the full path is
// emitted for mapped files. Passing |strip_path_from_mapped_files|
// is all that is necessary to anonymize the trace.
bool strip_path_from_mapped_files =
base::trace_event::TraceLog::GetInstance()
->GetCurrentTraceConfig()
.IsArgumentFilterEnabled();
heap_profiler_->DumpProcessesForTracing(
strip_path_from_mapped_files,
            base::BindRepeating(&CoordinatorImpl::OnDumpProcessesForTracing,
                           base::Unretained(this), request->dump_guid));

base::SequencedTaskRunnerHandle::Get()->PostDelayedTask(
FROM_HERE,
base::BindOnce(&CoordinatorImpl::OnHeapDumpTimeOut,
                       base::Unretained(this), request->dump_guid),
kHeapDumpTimeout);
}

// Run the callback in case there are no client processes registered.
FinalizeGlobalMemoryDumpIfAllManagersReplied();
}

void CoordinatorImpl::GetVmRegionsForHeapProfiler(
const std::vector<base::ProcessId>& pids,
GetVmRegionsForHeapProfilerCallback callback) {
DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
uint64_t dump_guid = ++next_dump_id_;
std::unique_ptr<QueuedVmRegionRequest> request =
std::make_unique<QueuedVmRegionRequest>(dump_guid, std::move(callback));
in_progress_vm_region_requests_[dump_guid] = std::move(request);

std::vector<QueuedRequestDispatcher::ClientInfo> clients;
for (const auto& kv : clients_) {
auto client_identity = kv.second->identity;
const base::ProcessId pid = GetProcessIdForClientIdentity(client_identity);
clients.emplace_back(kv.second->client.get(), pid, kv.second->process_type);
}

QueuedVmRegionRequest* request_ptr =
in_progress_vm_region_requests_[dump_guid].get();
auto os_callback =
base::BindRepeating(&CoordinatorImpl::OnOSMemoryDumpForVMRegions,
                          base::Unretained(this), dump_guid);
QueuedRequestDispatcher::SetUpAndDispatchVmRegionRequest(request_ptr, clients,
pids, os_callback);
FinalizeVmRegionDumpIfAllManagersReplied(dump_guid);
}

void CoordinatorImpl::RequestGlobalMemoryDumpInternal(
    const QueuedRequest::Args& args,
    RequestGlobalMemoryDumpInternalCallback callback) {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);

  UMA_HISTOGRAM_COUNTS_1000("Memory.Experimental.Debug.GlobalDumpQueueLength",
                            queued_memory_dump_requests_.size());

  bool another_dump_is_queued = !queued_memory_dump_requests_.empty();

  if (another_dump_is_queued &&
      args.dump_type == MemoryDumpType::PERIODIC_INTERVAL) {
    for (const auto& request : queued_memory_dump_requests_) {
      if (request.args.level_of_detail == args.level_of_detail) {
        VLOG(1) << "RequestGlobalMemoryDump("
                << base::trace_event::MemoryDumpTypeToString(args.dump_type)
                << ") skipped because another dump request with the same "
                   "level of detail ("
                << base::trace_event::MemoryDumpLevelOfDetailToString(
                       args.level_of_detail)
                << ") is already in the queue";
        std::move(callback).Run(false /* success */, 0 /* dump_guid */,
                                nullptr /* global_memory_dump */);
        return;
      }
    }
  }

  queued_memory_dump_requests_.emplace_back(args, ++next_dump_id_,
                                            std::move(callback));

  if (another_dump_is_queued)
    return;

  PerformNextQueuedGlobalMemoryDump();
}

void CoordinatorImpl::OnDumpProcessesForTracing(
    uint64_t dump_guid,
    std::vector<mojom::SharedBufferWithSizePtr> buffers) {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
  QueuedRequest* request = GetCurrentRequest();
  if (!request || request->dump_guid != dump_guid) {
    return;
  }

  request->heap_dump_in_progress = false;

  for (auto& buffer_ptr : buffers) {
    mojo::ScopedSharedBufferHandle& buffer = buffer_ptr->buffer;
    uint32_t size = buffer_ptr->size;

    if (!buffer->is_valid())
      continue;

    mojo::ScopedSharedBufferMapping mapping = buffer->Map(size);
    if (!mapping) {
      DLOG(ERROR) << "Failed to map buffer";
      continue;
    }

    const char* char_buffer = static_cast<const char*>(mapping.get());
    std::string json(char_buffer, char_buffer + size);

    const int kTraceEventNumArgs = 1;
    const char* const kTraceEventArgNames[] = {"dumps"};
    const unsigned char kTraceEventArgTypes[] = {TRACE_VALUE_TYPE_CONVERTABLE};
    std::unique_ptr<base::trace_event::ConvertableToTraceFormat> wrapper(
        new StringWrapper(std::move(json)));

    TRACE_EVENT_API_ADD_TRACE_EVENT_WITH_PROCESS_ID(
        TRACE_EVENT_PHASE_MEMORY_DUMP,
        base::trace_event::TraceLog::GetCategoryGroupEnabled(
            base::trace_event::MemoryDumpManager::kTraceCategory),
        "periodic_interval", trace_event_internal::kGlobalScope, dump_guid,
        buffer_ptr->pid, kTraceEventNumArgs, kTraceEventArgNames,
        kTraceEventArgTypes, nullptr /* arg_values */, &wrapper,
        TRACE_EVENT_FLAG_HAS_ID);
  }

  FinalizeGlobalMemoryDumpIfAllManagersReplied();
}

CoordinatorImpl::CoordinatorImpl(service_manager::Connector* connector)
: next_dump_id_(0),
      client_process_timeout_(base::TimeDelta::FromSeconds(15)) {
process_map_ = std::make_unique<ProcessMap>(connector);
DCHECK(!g_coordinator_impl);
g_coordinator_impl = this;
base::trace_event::MemoryDumpManager::GetInstance()->set_tracing_process_id(
mojom::kServiceTracingProcessId);

tracing_observer_ = std::make_unique<TracingObserver>(
base::trace_event::TraceLog::GetInstance(), nullptr);
}

void CoordinatorImpl::OnHeapDumpTimeOut(uint64_t dump_guid) {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
  QueuedRequest* request = GetCurrentRequest();


  if (!request || request->dump_guid != dump_guid)
    return;

  if (request->heap_dump_in_progress) {
    request->heap_dump_in_progress = false;
    FinalizeGlobalMemoryDumpIfAllManagersReplied();
  }
}

void CoordinatorImpl::RegisterHeapProfiler(
    mojom::HeapProfilerPtr heap_profiler) {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
  heap_profiler_ = std::move(heap_profiler);
}

void CoordinatorImpl::BindCoordinatorRequest(
    mojom::CoordinatorRequest request,
    const service_manager::BindSourceInfo& source_info) {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
  bindings_.AddBinding(this, std::move(request), source_info.identity);
}

void CoordinatorImpl::RequestGlobalMemoryDumpForPid(
    base::ProcessId pid,
    const std::vector<std::string>& allocator_dump_names,
    RequestGlobalMemoryDumpForPidCallback callback) {
  if (pid == base::kNullProcessId) {
    std::move(callback).Run(false, nullptr);
    return;
  }

  auto adapter = [](RequestGlobalMemoryDumpForPidCallback callback,
                    bool success, uint64_t,
                    mojom::GlobalMemoryDumpPtr global_memory_dump) {
    std::move(callback).Run(success, std::move(global_memory_dump));
  };

  QueuedRequest::Args args(
      base::trace_event::MemoryDumpType::SUMMARY_ONLY,
      base::trace_event::MemoryDumpLevelOfDetail::BACKGROUND,
      allocator_dump_names, false /* add_to_trace */, pid,
      /*memory_footprint_only=*/false);
  RequestGlobalMemoryDumpInternal(args,
                                  base::BindOnce(adapter, std::move(callback)));
}

void CoordinatorImpl::FinalizeGlobalMemoryDumpIfAllManagersReplied() {
TRACE_EVENT0(base::trace_event::MemoryDumpManager::kTraceCategory,
"GlobalMemoryDump.Computation");
DCHECK(!queued_memory_dump_requests_.empty());

QueuedRequest* request = &queued_memory_dump_requests_.front();
if (!request->dump_in_progress || request->pending_responses.size() > 0 ||
request->heap_dump_in_progress) {
return;
}

QueuedRequestDispatcher::Finalize(request, tracing_observer_.get());

queued_memory_dump_requests_.pop_front();
request = nullptr;

// Schedule the next queued dump (if applicable).
if (!queued_memory_dump_requests_.empty()) {
base::SequencedTaskRunnerHandle::Get()->PostTask(
FROM_HERE,
base::BindOnce(&CoordinatorImpl::PerformNextQueuedGlobalMemoryDump,
                       base::Unretained(this)));
}
}

void CoordinatorImpl::BindHeapProfilerHelperRequest(
    mojom::HeapProfilerHelperRequest request,
    const service_manager::BindSourceInfo& source_info) {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
  bindings_heap_profiler_helper_.AddBinding(this, std::move(request),
                                            source_info.identity);
}

void CoordinatorImpl::OnOSMemoryDumpForVMRegions(uint64_t dump_guid,
                                                 mojom::ClientProcess* client,
                                                 bool success,
                                                 OSMemDumpMap os_dumps) {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
  auto request_it = in_progress_vm_region_requests_.find(dump_guid);
  DCHECK(request_it != in_progress_vm_region_requests_.end());

  QueuedVmRegionRequest* request = request_it->second.get();
  auto it = request->pending_responses.find(client);
  DCHECK(it != request->pending_responses.end());
  request->pending_responses.erase(it);
  request->responses[client].os_dumps = std::move(os_dumps);

  FinalizeVmRegionDumpIfAllManagersReplied(request->dump_guid);
}

void CoordinatorImpl::RequestGlobalMemoryDumpAndAppendToTrace(
    MemoryDumpType dump_type,
    MemoryDumpLevelOfDetail level_of_detail,
    RequestGlobalMemoryDumpAndAppendToTraceCallback callback) {
  auto adapter = [](RequestGlobalMemoryDumpAndAppendToTraceCallback callback,
                    bool success, uint64_t dump_guid,
                    mojom::GlobalMemoryDumpPtr) {
    std::move(callback).Run(success, dump_guid);
  };

  QueuedRequest::Args args(dump_type, level_of_detail, {},
                           true /* add_to_trace */, base::kNullProcessId,
                           /*memory_footprint_only=*/false);
  RequestGlobalMemoryDumpInternal(args,
                                  base::BindOnce(adapter, std::move(callback)));
}

void CoordinatorImpl::RequestGlobalMemoryDump(
    MemoryDumpType dump_type,
    MemoryDumpLevelOfDetail level_of_detail,
    const std::vector<std::string>& allocator_dump_names,
    RequestGlobalMemoryDumpCallback callback) {
  auto adapter = [](RequestGlobalMemoryDumpCallback callback, bool success,
                    uint64_t, mojom::GlobalMemoryDumpPtr global_memory_dump) {
    std::move(callback).Run(success, std::move(global_memory_dump));
  };

  QueuedRequest::Args args(dump_type, level_of_detail, allocator_dump_names,
                           false /* add_to_trace */, base::kNullProcessId,
                           /*memory_footprint_only=*/false);
  RequestGlobalMemoryDumpInternal(args,
                                  base::BindOnce(adapter, std::move(callback)));
}

void CoordinatorImpl::RegisterClientProcess(
mojom::ClientProcessPtr client_process_ptr,
mojom::ProcessType process_type) {
DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
mojom::ClientProcess* client_process = client_process_ptr.get();
client_process_ptr.set_connection_error_handler(
base::BindOnce(&CoordinatorImpl::UnregisterClientProcess,
                     base::Unretained(this), client_process));
auto identity = GetClientIdentityForCurrentRequest();
auto client_info = std::make_unique<ClientInfo>(
std::move(identity), std::move(client_process_ptr), process_type);
auto iterator_and_inserted =
clients_.emplace(client_process, std::move(client_info));
DCHECK(iterator_and_inserted.second);
}
