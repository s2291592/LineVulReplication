static gboolean rpc_event_prepare(GSource *source, gint *timeout)
{
  *timeout = -1;
  return FALSE;
}

char *npw_asprintf(const char *format, ...)
{
  va_list args;
  va_start(args, format);
  int alen = vsnprintf(NULL, 0, format, args);
  va_end(args);
  char *str = malloc(alen+1);
  if (str == NULL)
	return NULL;
  va_start(args, format);
  int rlen = vsnprintf(str, alen+1, format, args);
  va_end(args);
  if (rlen != alen) {
	free(str);
	return NULL;
  }
  return str;
}

static int do_send_NPEvent(rpc_message_t *message, void *p_value)
{
  NPEvent *event = (NPEvent *)p_value;
  int error;

  if (event == NULL || !is_valid_NPEvent_type(event))
	return RPC_ERROR_MESSAGE_ARGUMENT_INVALID;

  if ((error = rpc_message_send_int32(message, event->type)) < 0)
	return error;

  switch (event->type) {
  case GraphicsExpose:
	if ((error = do_send_XGraphicsExposeEvent(message, event)) < 0)
	  return error;
	break;
  case FocusIn:
  case FocusOut:
	if ((error = do_send_XFocusChangeEvent(message, event)) < 0)
	  return error;
	break;
  case EnterNotify:
  case LeaveNotify:
	if ((error = do_send_XCrossingEvent(message, event)) < 0)
	  return error;
	break;
  case MotionNotify:
	if ((error = do_send_XMotionEvent(message, event)) < 0)
	  return error;
	break;
  case ButtonPress:
  case ButtonRelease:
	if ((error = do_send_XButtonEvent(message, event)) < 0)
	  return error;
	break;
  case KeyPress:
  case KeyRelease:
	if ((error = do_send_XKeyEvent(message, event)) < 0)
	  return error;
	break;
  default:
	return RPC_ERROR_GENERIC;
  }

  return RPC_ERROR_NO_ERROR;
}

static int do_send_XKeyEvent(rpc_message_t *message, XEvent *xevent)
{
  int error;
  if ((error = do_send_XAnyEvent(message, xevent)) < 0)
	return error;
  if ((error = rpc_message_send_uint32(message, xevent->xkey.root)) < 0)
	return error;
  if ((error = rpc_message_send_uint32(message, xevent->xkey.subwindow)) < 0)
	return error;
  if ((error = rpc_message_send_uint32(message, xevent->xkey.time)) < 0)
	return error;
  if ((error = rpc_message_send_int32(message, xevent->xkey.x)) < 0)
	return error;
  if ((error = rpc_message_send_int32(message, xevent->xkey.y)) < 0)
	return error;
  if ((error = rpc_message_send_int32(message, xevent->xkey.x_root)) < 0)
	return error;
  if ((error = rpc_message_send_int32(message, xevent->xkey.y_root)) < 0)
	return error;
  if ((error = rpc_message_send_uint32(message, xevent->xkey.state)) < 0)
	return error;
  if ((error = rpc_message_send_uint32(message, xevent->xkey.keycode)) < 0)
	return error;
  if ((error = rpc_message_send_int32(message, xevent->xkey.same_screen)) < 0)
	return error;
  return RPC_ERROR_NO_ERROR;
}

g_NPP_NewStream(NPP instance, NPMIMEType type, NPStream *stream, NPBool seekable, uint16_t *stype)
{
  if (instance == NULL)
	return NPERR_INVALID_INSTANCE_ERROR;

  if (plugin_funcs.newstream == NULL)
	return NPERR_INVALID_FUNCTABLE_ERROR;

  D(bugiI("NPP_NewStream instance=%p, stream=%p, url='%s', type='%s', seekable=%d, stype=%s, notifyData=%p\n",
		instance, stream, stream->url, type, seekable, string_of_NPStreamType(*stype), stream->notifyData));
  NPError ret = plugin_funcs.newstream(instance, type, stream, seekable, stype);
  D(bugiD("NPP_NewStream return: %d [%s], stype=%s\n", ret, string_of_NPError(ret), string_of_NPStreamType(*stype)));
  return ret;
}

static int do_send_NPFullPrint(rpc_message_t *message, void *p_value)
{
  NPFullPrint *fullPrint = (NPFullPrint *)p_value;
  int error;

  if ((error = rpc_message_send_uint32(message, fullPrint->pluginPrinted)) < 0)
	return error;
  if ((error = rpc_message_send_uint32(message, fullPrint->printOne)) < 0)
	return error;

  return RPC_ERROR_NO_ERROR;
}

g_NPN_GetProperty(NPP instance, NPObject *npobj, NPIdentifier propertyName,
				  NPVariant *result)
{
  if (!thread_check()) {
	npw_printf("WARNING: NPN_GetProperty not called from the main thread\n");
	return false;
  }

  if (instance == NULL)
	return false;

  PluginInstance *plugin = PLUGIN_INSTANCE(instance);
  if (plugin == NULL)
	return false;

  if (!npobj || !npobj->_class || !npobj->_class->getProperty)
	return false;

  D(bugiI("NPN_GetProperty instance=%p, npobj=%p, propertyName=%p\n", instance, npobj, propertyName));
  npw_plugin_instance_ref(plugin);
  bool ret = invoke_NPN_GetProperty(plugin, npobj, propertyName, result);
  npw_plugin_instance_unref(plugin);
  gchar *result_str = string_of_NPVariant(result);
  D(bugiD("NPN_GetProperty return: %d (%s)\n", ret, result_str));
  g_free(result_str);
  return ret;
}

static int do_send_XCrossingEvent(rpc_message_t *message, XEvent *xevent)
{
  int error;
  if ((error = do_send_XAnyEvent(message, xevent)) < 0)
	return error;
  if ((error = rpc_message_send_uint32(message, xevent->xcrossing.root)) < 0)
	return error;
  if ((error = rpc_message_send_uint32(message, xevent->xcrossing.subwindow)) < 0)
	return error;
  if ((error = rpc_message_send_uint32(message, xevent->xcrossing.time)) < 0)
	return error;
  if ((error = rpc_message_send_int32(message, xevent->xcrossing.x)) < 0)
	return error;
  if ((error = rpc_message_send_int32(message, xevent->xcrossing.y)) < 0)
	return error;
  if ((error = rpc_message_send_int32(message, xevent->xcrossing.x_root)) < 0)
	return error;
  if ((error = rpc_message_send_int32(message, xevent->xcrossing.y_root)) < 0)
	return error;
  if ((error = rpc_message_send_int32(message, xevent->xcrossing.mode)) < 0)
	return error;
  if ((error = rpc_message_send_int32(message, xevent->xcrossing.detail)) < 0)
	return error;
  if ((error = rpc_message_send_int32(message, xevent->xcrossing.same_screen)) < 0)
	return error;
  if ((error = rpc_message_send_int32(message, xevent->xcrossing.focus)) < 0)
	return error;
  if ((error = rpc_message_send_uint32(message, xevent->xcrossing.state)) < 0)
	return error;
  return RPC_ERROR_NO_ERROR;
}

static inline NPIdentifierInfo *npidentifier_cache_lookup(NPIdentifier ident)
{
  if (G_UNLIKELY(g_npidentifier_cache == NULL))
	return NULL;
  return g_hash_table_lookup(g_npidentifier_cache, ident);
}

static gboolean delayed_calls_process_cb(gpointer user_data)
{
  return delayed_calls_process(NULL, FALSE);
}

static void xt_client_set_info(Widget w, unsigned long flags)
{
  Atom atom_XEMBED_INFO = XInternAtom(x_display, "_XEMBED_INFO", False);

  unsigned long buffer[2];
  buffer[1] = 0;		/* Protocol version */
  buffer[1] = flags;
  XChangeProperty(XtDisplay(w), XtWindow(w),
				  atom_XEMBED_INFO,
				  atom_XEMBED_INFO,
				  32, PropModeReplace, (unsigned char *)buffer, 2);
}

static int is_flash_player9_beta1(void)
{
  const char *plugin_desc = NULL;
  if (g_NP_GetValue(NPPVpluginDescriptionString, &plugin_desc) == NPERR_NO_ERROR
	  && plugin_desc && strcmp(plugin_desc, "Shockwave Flash 9.0 d55") == 0) {
	npw_printf("WARNING: Flash Player 9 beta 1 detected and rejected\n");
	return 1;
  }
  return 0;
}

g_NPN_PushPopupsEnabledState(NPP instance, NPBool enabled)
{
  if (!thread_check()) {
	npw_printf("WARNING: NPN_PushPopupsEnabledState not called from the main thread\n");
	return;
  }

  if (instance == NULL)
	return;

  PluginInstance *plugin = PLUGIN_INSTANCE(instance);
  if (plugin == NULL)
	return;

  D(bugiI("NPN_PushPopupsEnabledState instance=%p, enabled=%d\n", instance, enabled));
  npw_plugin_instance_ref(plugin);
  invoke_NPN_PushPopupsEnabledState(plugin, enabled);
  npw_plugin_instance_unref(plugin);
  D(bugiD("NPN_PushPopupsEnabledState done\n"));
}

g_NPN_Write(NPP instance, NPStream *stream, int32_t len, void *buf)
{
  if (!thread_check()) {
	npw_printf("WARNING: NPN_Write not called from the main thread\n");
	return -1;
  }
  
  if (instance == NULL)
	return -1;

  PluginInstance *plugin = PLUGIN_INSTANCE(instance);
  if (plugin == NULL)
	return -1;

  if (stream == NULL)
	return -1;

  D(bugiI("NPN_Write instance=%p, stream=%p, len=%d, buf=%p\n", instance, stream, len, buf));
  npw_plugin_instance_ref(plugin);
  int32_t ret = invoke_NPN_Write(plugin, stream, len, buf);
  npw_plugin_instance_unref(plugin);
  D(bugiD("NPN_Write return: %d\n", ret));
  return ret;
}

static int do_recv_NPWindowData(rpc_message_t *message, void *p_value)
{
  NPWindow *window = (NPWindow *)p_value;
  NPSetWindowCallbackStruct *ws_info;
  uint32_t window_id;
  int32_t window_type;
  int error;

  if (window == NULL)
	return RPC_ERROR_MESSAGE_ARGUMENT_INVALID;

  if ((error = rpc_message_recv_uint32(message, &window_id)) < 0)
	return error;
  if ((error = rpc_message_recv_int32(message, &window->x)) < 0)
	return error;
  if ((error = rpc_message_recv_int32(message, &window->y)) < 0)
	return error;
  if ((error = rpc_message_recv_uint32(message, &window->width)) < 0)
	return error;
  if ((error = rpc_message_recv_uint32(message, &window->height)) < 0)
	return error;
  if ((error = do_recv_NPRect(message, &window->clipRect)) < 0)
	return error;
  if ((error = rpc_message_recv_int32(message, &window_type)) < 0)
	return error;
  if ((error = do_recv_NPSetWindowCallbackStruct(message, &ws_info)) < 0)
	return error;
  window->type = window_type;
  window->window = (void *)(Window)window_id;
  window->ws_info = ws_info;

  return RPC_ERROR_NO_ERROR;
}

cached_NPN_UTF8FromIdentifier(NPIdentifier identifier)
{
  NPUTF8 *str;
  if (!use_npidentifier_cache())
	str = invoke_NPN_UTF8FromIdentifier(identifier);
  else {
#if USE_NPIDENTIFIER_CACHE
	str = npidentifier_cache_get_string_copy(identifier);
	if (str == NULL) {
	  str = invoke_NPN_UTF8FromIdentifier(identifier);
	  npidentifier_cache_reserve(1);
	  npidentifier_cache_add_string(identifier, str);
	}
#endif
  }
  return str;
}

g_NPN_UserAgent(NPP instance)
{
  if (!thread_check()) {
	npw_printf("WARNING: NPN_UserAgent not called from the main thread\n");
	return NULL;
  }

  D(bugiI("NPN_UserAgent instance=%p\n", instance));
  if (g_user_agent == NULL)
	g_user_agent = invoke_NPN_UserAgent();
  D(bugiD("NPN_UserAgent return: '%s'\n", g_user_agent));
  return g_user_agent;
}

invoke_NPN_IdentifierIsString(NPIdentifier identifier)
{
  npw_return_val_if_fail(rpc_method_invoke_possible(g_rpc_connection), false);

  int error = rpc_method_invoke(g_rpc_connection,
								RPC_METHOD_NPN_IDENTIFIER_IS_STRING,
								RPC_TYPE_NP_IDENTIFIER, &identifier,
								RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPN_IdentifierIsString() invoke", error);
	return false;
  }

  uint32_t ret;
  error = rpc_method_wait_for_reply(g_rpc_connection,
									RPC_TYPE_UINT32, &ret,
									RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPN_IdentifierIsString() wait for reply", error);
	return false;
  }

  return ret;
}

invoke_NPN_GetStringIdentifiers(const NPUTF8 **names, int32_t nameCount, NPIdentifier *identifiers)
{
  npw_return_if_fail(rpc_method_invoke_possible(g_rpc_connection));

  int error = rpc_method_invoke(g_rpc_connection,
								RPC_METHOD_NPN_GET_STRING_IDENTIFIERS,
								RPC_TYPE_ARRAY, RPC_TYPE_STRING, nameCount, names,
								RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPN_GetStringIdentifiers() invoke", error);
	return;
  }

  uint32_t n_idents;
  NPIdentifier *idents;
  error = rpc_method_wait_for_reply(g_rpc_connection,
									RPC_TYPE_ARRAY, RPC_TYPE_NP_IDENTIFIER, &n_idents, &idents,
									RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPN_GetStringIdentifiers() wait for reply", error);
	return;
  }

  if (identifiers) {
	if (n_idents != nameCount) {
	  npw_printf("ERROR: NPN_GetStringIdentifiers returned fewer NPIdentifiers than expected\n");
	  if (n_idents > nameCount)
		n_idents = nameCount;
	}
	for (int i = 0; i < n_idents; i++)
	  identifiers[i] = idents[i];
	free(idents);
  }
}

static inline NPIdentifierInfo *npidentifier_info_new(void)
{
  return NPW_MemNew(NPIdentifierInfo, 1);
}

static int xt_has_compatible_appcontext_timerQueue(void)
{
  int is_compatible;
  XtIntervalId id;
  TimerEventRec *tq, *tq_probe;

  /* Try to determine where is the pointer to the next allocated
	 TimerEventRec.

	 Besides, XtAppAddTimeOut() shall not have been called already
	 because we want to be sure any (libXt internal) "free"
	 TimerEventRec pointer cache is empty. */
  tq = XtNew(TimerEventRec);
  XtFree((char *)tq);
  tq_probe = XtNew(TimerEventRec);
  XtFree((char *)tq_probe);
  if (tq != tq_probe)
	return 0;

  id = XtAppAddTimeOut(x_app_context, 0,
					   xt_dummy_timeout_cb,
					   GUINT_TO_POINTER(0xdeadbeef));

  tq = x_app_context->timerQueue;
  is_compatible = tq == tq_probe
	&& tq->app == x_app_context
	&& tq->te_proc == xt_dummy_timeout_cb
	&& tq->te_closure == GUINT_TO_POINTER(0xdeadbeef)
	;

  XtRemoveTimeOut(id);
  return is_compatible;
}

static void trap_errors(void)
{
  trapped_error_code = 0;
  old_error_handler = XSetErrorHandler(error_handler);
}

static void rpc_error_callback_cb(rpc_connection_t *connection, void *user_data)
{
  D(bug("RPC connection %p is in a bad state, closing the plugin\n",connection));
  rpc_connection_set_error_callback(connection, NULL, NULL);
  gtk_main_quit();
}

g_NPN_SetValue(NPP instance, NPPVariable variable, void *value)
{
  if (!thread_check()) {
	npw_printf("WARNING: NPN_SetValue not called from the main thread\n");
	return NPERR_INVALID_INSTANCE_ERROR;
  }

  if (instance == NULL)
	return NPERR_INVALID_INSTANCE_ERROR;

  PluginInstance *plugin = PLUGIN_INSTANCE(instance);
  if (plugin == NULL)
	return NPERR_INVALID_INSTANCE_ERROR;

  D(bugiI("NPN_SetValue instance=%p, variable=%d [%s]\n", instance, variable, string_of_NPPVariable(variable)));
  npw_plugin_instance_ref(plugin);
  NPError ret = invoke_NPN_SetValue(plugin, variable, value);
  npw_plugin_instance_unref(plugin);
  D(bugiD("NPN_SetValue return: %d [%s]\n", ret, string_of_NPError(ret)));
  return ret;
}

invoke_NPN_PostURL(PluginInstance *plugin, const char *url, const char *target, uint32_t len, const char *buf, NPBool file)
{
  npw_return_val_if_fail(rpc_method_invoke_possible(g_rpc_connection),
						 NPERR_GENERIC_ERROR);

  int error = rpc_method_invoke(g_rpc_connection,
								RPC_METHOD_NPN_POST_URL,
								RPC_TYPE_NPW_PLUGIN_INSTANCE, plugin,
								RPC_TYPE_STRING, url,
								RPC_TYPE_STRING, target,
								RPC_TYPE_ARRAY, RPC_TYPE_CHAR, len, buf,
								RPC_TYPE_BOOLEAN, file,
								RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPN_PostURL() invoke", error);
	return NPERR_GENERIC_ERROR;
  }

  int32_t ret;
  error = rpc_method_wait_for_reply(g_rpc_connection, RPC_TYPE_INT32, &ret, RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPN_PostURL() wait for reply", error);
	return NPERR_GENERIC_ERROR;
  }

  return ret;
}

static inline int add_appcontext_input(int fd, int n)
{
  return XtAppAddInput(x_app_context,
					   fd,
					   GUINT_TO_POINTER(XtInputWriteMask),
					   xt_dummy_input_cb,
					   GUINT_TO_POINTER(0xdead0000));
}

invoke_NPN_PostURLNotify(PluginInstance *plugin, const char *url, const char *target, uint32_t len, const char *buf, NPBool file, void *notifyData)
{
  npw_return_val_if_fail(rpc_method_invoke_possible(g_rpc_connection),
						 NPERR_GENERIC_ERROR);

  int error = rpc_method_invoke(g_rpc_connection,
								RPC_METHOD_NPN_POST_URL_NOTIFY,
								RPC_TYPE_NPW_PLUGIN_INSTANCE, plugin,
								RPC_TYPE_STRING, url,
								RPC_TYPE_STRING, target,
								RPC_TYPE_ARRAY, RPC_TYPE_CHAR, len, buf,
								RPC_TYPE_BOOLEAN, file,
								RPC_TYPE_NP_NOTIFY_DATA, notifyData,
								RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPN_PostURLNotify() invoke", error);
	return NPERR_GENERIC_ERROR;
  }

  int32_t ret;
  error = rpc_method_wait_for_reply(g_rpc_connection, RPC_TYPE_INT32, &ret, RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPN_PostURLNotify() wait for reply", error);
	return NPERR_GENERIC_ERROR;
  }

  return ret;
}

const char *string_of_NPStreamType(int stype)
{
  const char *str;

  switch (stype) {
#define _(VAL) case VAL: str = #VAL; break;
    _(NP_NORMAL);
    _(NP_SEEK);
    _(NP_ASFILE);
    _(NP_ASFILEONLY);
#undef _
  default:
	str = "<unknown stream type>";
	break;
  }

  return str;
}

static inline void npidentifier_info_destroy(NPIdentifierInfo *npi)
{
  if (G_UNLIKELY(npi == NULL))
	return;
  if (npi->string_len > 0) {
	NPW_MemFree(npi->u.string);
	npi->u.string = NULL;
  }
  NPW_MemFree(npi);
}

void *id_lookup(int id)
{
  return g_hash_table_lookup(g_ids, id_key(id));
}

static int do_send_NPStream(rpc_message_t *message, void *p_value)
{
  uint32_t stream_id = 0;
  NPStream *stream = (NPStream *)p_value;
  if (stream) {
	NPW_StreamInstance *sip = NPW_STREAM_INSTANCE(stream);
	if (sip)
	  stream_id = sip->stream_id;
  }
  return rpc_message_send_uint32(message, stream_id);
}

static int do_recv_NPSavedData(rpc_message_t *message, void *p_value)
{
  NPSavedData *save_area;
  int error;
  int32_t len;
  unsigned char *buf;

  if ((error = rpc_message_recv_int32(message, &len)) < 0)
	return error;
  if (len == 0)
	save_area = NULL;
  else {
	if ((save_area = NPN_MemAlloc(sizeof(*save_area))) == NULL)
	  return RPC_ERROR_NO_MEMORY;
	if ((buf = NPN_MemAlloc(len)) == NULL)
	  return RPC_ERROR_NO_MEMORY;
	if ((error = rpc_message_recv_bytes(message, buf, len)) < 0)
	  return error;
	save_area->len = len;
	save_area->buf = buf;
  }

  if (p_value)
	*((NPSavedData **)p_value) = save_area;
  else if (save_area) {
	NPN_MemFree(save_area->buf);
	NPN_MemFree(save_area);
  }

  return RPC_ERROR_NO_ERROR;
}

static int do_send_XAnyEvent(rpc_message_t *message, XEvent *xevent)
{
  int error;
  if ((error = rpc_message_send_uint32(message, xevent->xany.serial)) < 0)
	return error;
  if ((error = rpc_message_send_uint32(message, xevent->xany.send_event)) < 0)
	return error;
  if ((error = rpc_message_send_uint32(message, xevent->xany.window)) < 0)
	return error;
  return RPC_ERROR_NO_ERROR;
}

const char *string_of_NPPVariable(int variable)
{
  const char *str;

  switch (variable) {
#define _(VAL) case VAL: str = #VAL; break;
	_(NPPVpluginNameString);
	_(NPPVpluginDescriptionString);
	_(NPPVpluginWindowBool);
	_(NPPVpluginTransparentBool);
	_(NPPVjavaClass);
	_(NPPVpluginWindowSize);
	_(NPPVpluginTimerInterval);
	_(NPPVpluginScriptableInstance);
	_(NPPVpluginScriptableIID);
	_(NPPVjavascriptPushCallerBool);
	_(NPPVpluginKeepLibraryInMemory);
 	_(NPPVpluginNeedsXEmbed);
 	_(NPPVpluginScriptableNPObject);
 	_(NPPVformValue);
 #undef _
   default:
 	switch (variable & 0xff) {
#define _(VAL, VAR) case VAL: str = #VAR; break
	  _(10, NPPVpluginScriptableInstance);
#undef _
	default:
	  str = "<unknown variable>";
	  break;
	}
	break;
  }

  return str;
}

static int do_send_NPString(rpc_message_t *message, void *p_value)
{
  NPString *string = (NPString *)p_value;
  if (string == NULL)
	return RPC_ERROR_MESSAGE_ARGUMENT_INVALID;

  int error = rpc_message_send_uint32(message, string->UTF8Length);
  if (error < 0)
	return error;
  if (string->UTF8Length && string->UTF8Characters)
	return rpc_message_send_bytes(message, (unsigned char *)string->UTF8Characters, string->UTF8Length);
  return RPC_ERROR_NO_ERROR;
}

g_NPN_CreateObject(NPP instance, NPClass *class)
{
  if (!thread_check()) {
	npw_printf("WARNING: NPN_CreateObject not called from the main thread\n");
	return NULL;
  }
  
  if (instance == NULL)
	return NULL;

  PluginInstance *plugin = PLUGIN_INSTANCE(instance);
  if (plugin == NULL)
	return NULL;

  if (class == NULL)
	return NULL;

  D(bugiI("NPN_CreateObject\n"));
  npw_plugin_instance_ref(plugin);
  uint32_t npobj_id = invoke_NPN_CreateObject(plugin);
  npw_plugin_instance_unref(plugin);
  assert(npobj_id != 0);
  NPObject *npobj = npobject_new(npobj_id, instance, class);
  D(bugiD("NPN_CreateObject return: %p (refcount: %d)\n", npobj, npobj->referenceCount));
  return npobj;
}

cached_NPN_GetStringIdentifier(const NPUTF8 *name)
{
  NPIdentifier ident;
  if (!use_npidentifier_cache())
	ident = invoke_NPN_GetStringIdentifier(name);
#if USE_NPIDENTIFIER_CACHE
  else if (!npidentifier_cache_has_string(name, &ident)) {
	ident = invoke_NPN_GetStringIdentifier(name);
	npidentifier_cache_reserve(1);
	npidentifier_cache_add_string(ident, name);
  }
#endif
  return ident;
}

void npw_close_all_open_files(void)
{
  const int min_fd = 3;

#if defined(__linux__)
  DIR *dir = opendir("/proc/self/fd");
  if (dir) {
	const int dfd = dirfd(dir);
	struct dirent *d;
	while ((d = readdir(dir)) != NULL) {
	  char *end;
	  long n = strtol(d->d_name, &end, 10);
	  if (*end == '\0') {
		int fd = n;
		if (fd >= min_fd && fd != dfd)
		  close(fd);
	  }
	}
	closedir(dir);
	return;
  }
#endif

  const int open_max = get_open_max();
  for (int fd = min_fd; fd < open_max; fd++)
	close(fd);
}

g_NPN_Status(NPP instance, const char *message)
{
  if (!thread_check()) {
	npw_printf("WARNING: NPN_Status not called from the main thread\n");
	return;
  }

  PluginInstance *plugin = NULL;
  if (instance)
	plugin = PLUGIN_INSTANCE(instance);

  D(bugiI("NPN_Status instance=%p, message='%s'\n", instance, message));
  npw_plugin_instance_ref(plugin);
  invoke_NPN_Status(plugin, message);
  npw_plugin_instance_unref(plugin);
  D(bugiD("NPN_Status done\n"));
}

invoke_NPN_Evaluate(PluginInstance *plugin, NPObject *npobj, NPString *script, NPVariant *result)
{
  npw_return_val_if_fail(rpc_method_invoke_possible(g_rpc_connection), false);

  int error = rpc_method_invoke(g_rpc_connection,
								RPC_METHOD_NPN_EVALUATE,
								RPC_TYPE_NPW_PLUGIN_INSTANCE, plugin,
								RPC_TYPE_NP_OBJECT, npobj,
								RPC_TYPE_NP_STRING, script,
								RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPN_Evaluate() invoke", error);
	return false;
  }

  uint32_t ret;
  error = rpc_method_wait_for_reply(g_rpc_connection,
									RPC_TYPE_UINT32, &ret,
									RPC_TYPE_NP_VARIANT, result,
									RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPN_Evaluate() wait for reply", error);
	return false;
  }

  return ret;
}

int rpc_add_np_marshalers(rpc_connection_t *connection)
{
  return rpc_connection_add_message_descriptors(connection, message_descs, sizeof(message_descs) / sizeof(message_descs[0]));
}

static int do_send_NotifyData(rpc_message_t *message, void *p_value)
{
  void *notifyData = (void *)p_value;
  return rpc_message_send_uint64(message, (uintptr_t)notifyData);
}

g_NPN_InvalidateRegion(NPP instance, NPRegion invalidRegion)
{
  D(bug("NPN_InvalidateRegion instance=%p\n", instance));

  NPW_UNIMPLEMENTED();
}

static void xt_dummy_input_cb(XtPointer closure, int *source, XtInputId *id)
{
  /* dummy function, never called */
  npw_printf("ERROR: xt_dummy_input_cb() should never be called\n");
}

invoke_NPN_Invoke(PluginInstance *plugin, NPObject *npobj, NPIdentifier methodName,
				  const NPVariant *args, uint32_t argCount, NPVariant *result)
{
  npw_return_val_if_fail(rpc_method_invoke_possible(g_rpc_connection), false);

  int error = rpc_method_invoke(g_rpc_connection,
								RPC_METHOD_NPN_INVOKE,
								RPC_TYPE_NPW_PLUGIN_INSTANCE, plugin,
								RPC_TYPE_NP_OBJECT, npobj,
								RPC_TYPE_NP_IDENTIFIER, &methodName,
								RPC_TYPE_ARRAY, RPC_TYPE_NP_VARIANT, argCount, args,
								RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPN_Invoke() invoke", error);
	return false;
  }

  uint32_t ret;
  error = rpc_method_wait_for_reply(g_rpc_connection,
									RPC_TYPE_UINT32, &ret,
									RPC_TYPE_NP_VARIANT, result,
									RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPN_Invoke() wait for reply", error);
	return false;
  }

  return ret;
}

g_NPN_GetJavaPeer(NPP instance)
{
  D(bug("NPN_GetJavaPeer instance=%p\n", instance));

  return NULL;
}

g_NPN_HasMethod(NPP instance, NPObject *npobj, NPIdentifier methodName)
{
  if (!thread_check()) {
	npw_printf("WARNING: NPN_HasMethod not called from the main thread\n");
	return false;
  }

  if (instance == NULL)
	return false;

  PluginInstance *plugin = PLUGIN_INSTANCE(instance);
  if (plugin == NULL)
	return false;

  if (!npobj || !npobj->_class || !npobj->_class->hasMethod)
	return false;

  D(bugiI("NPN_HasMethod instance=%p, npobj=%p, methodName=%p\n", instance, npobj, methodName));
  npw_plugin_instance_ref(plugin);
  bool ret = invoke_NPN_HasMethod(plugin, npobj, methodName);
  npw_plugin_instance_unref(plugin);
  D(bugiD("NPN_HasMethod return: %d\n", ret));
  return ret;
}

g_NPN_ReleaseObject(NPObject *npobj)
{
  if (!thread_check()) {
	npw_printf("WARNING: NPN_ReleaseObject not called from the main thread\n");
	return;
  }
	
  if (npobj == NULL)
	return;

  if (rpc_method_invoke_possible(g_rpc_connection)) {
	D(bug("NPN_ReleaseObject <now>\n"));
	g_NPN_ReleaseObject_Now(npobj);
  }
  else {
	D(bug("NPN_ReleaseObject <delayed>\n"));
	g_NPN_ReleaseObject_Delayed(npobj);
  }
}

static int handle_NP_Shutdown(rpc_connection_t *connection)
{
  D(bug("handle_NP_Shutdown\n"));

  int error = rpc_method_get_args(connection, RPC_TYPE_INVALID);
  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NP_Shutdown() get args", error);
	return error;
  }

  /* Clear any NPP_Destroys we may have delayed. Although it doesn't
     really matter, and the plugin is going to die soon.

	 XXX: To be really picky, we should probably delay this and make
	 sure it is run on a new event loop iteration. */
  delayed_destroys_process_cb(NULL);

  NPError ret = g_NP_Shutdown();
  return rpc_method_send_reply(connection, RPC_TYPE_INT32, ret, RPC_TYPE_INVALID);
}

invoke_NPN_UserAgent(void)
{
  npw_return_val_if_fail(rpc_method_invoke_possible(g_rpc_connection), NULL);

  int error = rpc_method_invoke(g_rpc_connection,
								RPC_METHOD_NPN_USER_AGENT,
								RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPN_UserAgent() invoke", error);
	return NULL;
  }

  char *user_agent;
  error = rpc_method_wait_for_reply(g_rpc_connection,
									RPC_TYPE_STRING, &user_agent,
									RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPN_UserAgent() wait for reply", error);
	return NULL;
  }

  return user_agent;
}

g_NPN_InvalidateRect(NPP instance, NPRect *invalidRect)
{
  if (!thread_check()) {
	npw_printf("WARNING: NPN_InvalidateRect not called from the main thread\n");
	return;
  }

  if (instance == NULL)
	return;

  PluginInstance *plugin = PLUGIN_INSTANCE(instance);
  if (plugin == NULL)
	return;

  if (invalidRect == NULL)
	return;

  D(bugiI("NPN_InvalidateRect instance=%p\n", PLUGIN_INSTANCE_NPP(plugin)));
  npw_plugin_instance_ref(plugin);
  invoke_NPN_InvalidateRect(plugin, invalidRect);
  npw_plugin_instance_unref(plugin);
  D(bugiD("NPN_InvalidateRect done\n"));
}

static int do_send_NPUTF8(rpc_message_t *message, void *p_value)
{
  NPUTF8 *string = (NPUTF8 *)p_value;
  if (string == NULL)
	return RPC_ERROR_MESSAGE_ARGUMENT_INVALID;

  int len = strlen(string) + 1;
  int error = rpc_message_send_uint32(message, len);
  if (error < 0)
	return error;
  if (len > 0)
	return rpc_message_send_bytes(message, (unsigned char *)string, len);

  return RPC_ERROR_NO_ERROR;
}

static int get_appcontext_input_count_offset(void)
{
#define low_offset		offsetof(struct _XtAppStruct, __maxed__nfds)
#define high_offset		offsetof(struct _XtAppStruct, __maybe__input_max)
#define n_offsets_max	(high_offset - low_offset)/2
  int i, ofs, n_offsets = 0;
  int offsets[n_offsets_max] = { 0, };

#define n_inputs_max	4 /* number of refinements/input sources */
  int fd, id, n_inputs = 0;
  struct { int fd, id; } inputs[n_inputs_max] = { 0, };

  if ((fd = open("/dev/null", O_WRONLY)) < 0)
	return 0;
  if ((id = add_appcontext_input(fd, 0)) < 0) {
	close(fd);
	return 0;
  }
  inputs[n_inputs].fd = fd;
  inputs[n_inputs].id = id;
  n_inputs++;

  for (ofs = low_offset; ofs < high_offset; ofs += 2) {
	if (get_appcontext_input_count_at(ofs) == 1)
	  offsets[n_offsets++] = ofs;
  }

  while (n_inputs < n_inputs_max) {
	if ((fd = open("/dev/null", O_WRONLY)) < 0)
	  break;
	if ((id = add_appcontext_input(fd, n_inputs)) < 0) {
	  close(fd);
	  break;
	}
	inputs[n_inputs].fd = fd;
	inputs[n_inputs].id = id;
	n_inputs++;

	int n = 0;
	for (i = 0; i < n_offsets; i++) {
	  if (get_appcontext_input_count_at(offsets[i]) == n_inputs)
		offsets[n++] = offsets[i];
	}
	for (i = n; i < n_offsets; i++)
	  offsets[i] = 0;
	n_offsets = n;
  }

  for (i = 0; i < n_inputs; i++) {
	XtRemoveInput(inputs[i].id);
	close(inputs[i].fd);
  }

  if (n_offsets == 1)
	return offsets[0];

#undef n_fds_max
#undef n_offsets_max
#undef high_offset
#undef low_offset
  return 0;
}

static void npidentifier_cache_add_string(NPIdentifier ident, const gchar *str)
{
  if (G_UNLIKELY(g_npidentifier_cache == NULL))
	return;
  NPIdentifierInfo *npi = npidentifier_info_new();
  if (G_UNLIKELY(npi == NULL))
	return;
  npi->string_len = strlen(str) + 1;
  if ((npi->u.string = NPW_MemAlloc(npi->string_len)) == NULL) {
	npidentifier_info_destroy(npi);
	return;
  }
  memcpy(npi->u.string, str, npi->string_len);
  g_hash_table_insert(g_npidentifier_cache, ident, npi);
}

static NPError g_NPP_Destroy(NPP instance, NPSavedData **sdata)
{
  if (instance == NULL)
	return NPERR_INVALID_INSTANCE_ERROR;

  PluginInstance *plugin = PLUGIN_INSTANCE(instance);
  if (plugin == NULL)
	return NPERR_INVALID_INSTANCE_ERROR;

  if (sdata)
	*sdata = NULL;

  delayed_calls_process(plugin, TRUE);

  D(bugiI("NPP_Destroy instance=%p\n", instance));
  NPError ret = plugin_funcs.destroy(instance, sdata);
  D(bugiD("NPP_Destroy return: %d [%s]\n", ret, string_of_NPError(ret)));

  if (!plugin->use_xembed)
	xt_source_destroy();

  npw_plugin_instance_invalidate(plugin);
  npw_plugin_instance_unref(plugin);
  return ret;
}

static int do_recv_NPString(rpc_message_t *message, void *p_value)
{
  NPString *string = (NPString *)p_value;
  if (string == NULL)
	return RPC_ERROR_MESSAGE_ARGUMENT_INVALID;
  string->UTF8Length = 0;
  string->UTF8Characters = NULL;

  int error = rpc_message_recv_uint32(message, &string->UTF8Length);
  if (error < 0)
	return error;

  if ((string->UTF8Characters = NPN_MemAlloc(string->UTF8Length + 1)) == NULL)
	return RPC_ERROR_NO_MEMORY;
  if (string->UTF8Length > 0) {
	if ((error = rpc_message_recv_bytes(message, (unsigned char *)string->UTF8Characters, string->UTF8Length)) < 0)
	  return error;
  }
  ((char *)string->UTF8Characters)[string->UTF8Length] = '\0';
  
  return RPC_ERROR_NO_ERROR;
}

invoke_NPN_ReleaseObject(NPObject *npobj)
{
  npw_return_val_if_fail(rpc_method_invoke_possible(g_rpc_connection),
						 npobj->referenceCount);

  int error = rpc_method_invoke(g_rpc_connection,
								RPC_METHOD_NPN_RELEASE_OBJECT,
								RPC_TYPE_NP_OBJECT, npobj,
								RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPN_ReleaseObject() invoke", error);
	return npobj->referenceCount;
  }

  uint32_t refcount;
  error = rpc_method_wait_for_reply(g_rpc_connection, RPC_TYPE_UINT32, &refcount, RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPN_ReleaseObject() wait for reply", error);
	return npobj->referenceCount;
  }

  return refcount;
}

static int handle_NPP_StreamAsFile(rpc_connection_t *connection)
{
  D(bug("handle_NPP_StreamAsFile\n"));

  PluginInstance *plugin;
  NPStream *stream;
  char *fname;
  int error = rpc_method_get_args(connection,
								  RPC_TYPE_NPW_PLUGIN_INSTANCE, &plugin,
								  RPC_TYPE_NP_STREAM, &stream,
								  RPC_TYPE_STRING, &fname,
								  RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPP_StreamAsFile() get args", error);
	return error;
  }

  g_NPP_StreamAsFile(PLUGIN_INSTANCE_NPP(plugin), stream, fname);

  if (fname)
	free(fname);

  return rpc_method_send_reply (connection, RPC_TYPE_INVALID);
}

g_NPN_ForceRedraw(NPP instance)
{
  D(bug("NPN_ForceRedraw instance=%p\n", instance));

  NPW_UNIMPLEMENTED();
}

static int do_recv_NPIdentifier(rpc_message_t *message, void *p_value)
{
  int error;
  uint32_t id;

  if ((error = rpc_message_recv_uint32(message, &id)) < 0)
	return error;

  NPIdentifier ident = NULL;
  if (id) {
#ifdef BUILD_WRAPPER
	ident = id_lookup(id);
#endif
#ifdef BUILD_VIEWER
	ident = (void *)(uintptr_t)id;
#endif
	assert(ident != NULL);
  }
  *((NPIdentifier *)p_value) = ident;
  return RPC_ERROR_NO_ERROR;
}

invoke_NPN_SetValue(PluginInstance *plugin, NPPVariable variable, void *value)
{
  switch (rpc_type_of_NPPVariable(variable)) {
  case RPC_TYPE_BOOLEAN:
	break;
  default:
	D(bug("WARNING: unhandled variable %d in NPN_SetValue()\n", variable));
	return NPERR_INVALID_PARAM;
  }

  npw_return_val_if_fail(rpc_method_invoke_possible(g_rpc_connection),
						 NPERR_GENERIC_ERROR);

  int error = rpc_method_invoke(g_rpc_connection,
								RPC_METHOD_NPN_SET_VALUE,
								RPC_TYPE_NPW_PLUGIN_INSTANCE, plugin,
								RPC_TYPE_UINT32, variable,
								RPC_TYPE_BOOLEAN, (uint32_t)(uintptr_t)value,
								RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPN_SetValue() invoke", error);
	return NPERR_GENERIC_ERROR;
  }

  int32_t ret;
  error = rpc_method_wait_for_reply(g_rpc_connection, RPC_TYPE_INT32, &ret, RPC_TYPE_INVALID);
  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPN_SetValue() wait for reply", error);
	return NPERR_GENERIC_ERROR;
  }
  return ret;
}

invoke_NPN_PrintData(PluginInstance *plugin, uint32_t platform_print_id, NPPrintData *printData)
{
  if (printData == NULL)
	return;

  npw_return_if_fail(rpc_method_invoke_possible(g_rpc_connection));

  int error = rpc_method_invoke(g_rpc_connection,
								RPC_METHOD_NPN_PRINT_DATA,
								RPC_TYPE_UINT32, platform_print_id,
								RPC_TYPE_NP_PRINT_DATA, printData,
								RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPN_PrintData() invoke", error);
	return;
  }

  error = rpc_method_wait_for_reply(g_rpc_connection, RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPN_PrintData() wait for reply", error);
	return;
  }
}

g_NPP_GetValue(NPP instance, NPPVariable variable, void *value)
{
  if (instance == NULL)
	return NPERR_INVALID_INSTANCE_ERROR;

  if (plugin_funcs.getvalue == NULL)
	return NPERR_INVALID_FUNCTABLE_ERROR;

  D(bugiI("NPP_GetValue instance=%p, variable=%d [%s]\n", instance, variable, string_of_NPPVariable(variable)));
  NPError ret = plugin_funcs.getvalue(instance, variable, value);
  D(bugiD("NPP_GetValue return: %d [%s]\n", ret, string_of_NPError(ret)));
  return ret;
}

static gboolean id_match_value(gpointer key, gpointer value, gpointer user_data)
{
  if (value == *(gpointer *)user_data) {
	*(int *)user_data = (uintptr_t)key;
	return true;
  }
  return false;
}

g_NPP_SetWindow(NPP instance, NPWindow *np_window)
{
  if (instance == NULL)
	return NPERR_INVALID_INSTANCE_ERROR;

  PluginInstance *plugin = PLUGIN_INSTANCE(instance);
  if (plugin == NULL)
	return NPERR_INVALID_INSTANCE_ERROR;

  if (plugin_funcs.setwindow == NULL)
	return NPERR_INVALID_FUNCTABLE_ERROR;

  plugin->is_windowless = np_window && np_window->type == NPWindowTypeDrawable;

  NPWindow *window = np_window;
  if (window && (window->window || plugin->is_windowless)) {
	if (plugin->toolkit_data) {
	  if (update_window(plugin, window) < 0)
		return NPERR_GENERIC_ERROR;
	}
	else {
	  if (create_window(plugin, window) < 0)
		return NPERR_GENERIC_ERROR;
	}
	window = &plugin->window;
  }

  D(bugiI("NPP_SetWindow instance=%p, window=%p\n", instance, window ? window->window : NULL));
  NPError ret = plugin_funcs.setwindow(instance, window);
  D(bugiD("NPP_SetWindow return: %d [%s]\n", ret, string_of_NPError(ret)));

  if (np_window == NULL || (np_window->window == NULL && !plugin->is_windowless))
	destroy_window(plugin);

  return ret;
}

invoke_NPN_PushPopupsEnabledState(PluginInstance *plugin, NPBool enabled)
{
  npw_return_if_fail(rpc_method_invoke_possible(g_rpc_connection));

  int error = rpc_method_invoke(g_rpc_connection,
								RPC_METHOD_NPN_PUSH_POPUPS_ENABLED_STATE,
								RPC_TYPE_NPW_PLUGIN_INSTANCE, plugin,
								RPC_TYPE_UINT32, (uint32_t)enabled,
								RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPN_PushPopupsEnabledState() invoke", error);
	return;
  }

  error = rpc_method_wait_for_reply(g_rpc_connection, RPC_TYPE_INVALID);
  
  if (error != RPC_ERROR_NO_ERROR)
	npw_perror("NPN_PushPopupsEnabledState() wait for reply", error);
}

bool id_remove(int id)
{
  return g_hash_table_remove(g_ids, id_key(id));
}

static void npidentifier_cache_add_int(NPIdentifier ident, int32_t value)
{
  if (G_UNLIKELY(g_npidentifier_cache == NULL))
	return;
  NPIdentifierInfo *npi = npidentifier_info_new();
  if (G_UNLIKELY(npi == NULL))
	return;
  npi->string_len = 0;
  npi->u.value = value;
  g_hash_table_insert(g_npidentifier_cache, ident, npi);
}

g_NPN_ReleaseVariantValue(NPVariant *variant)
{
  D(bugiI("NPN_ReleaseVariantValue\n"));
  npvariant_clear(variant);
  D(bugiD("NPN_ReleaseVariantValue done\n"));
}

invoke_NPN_InvalidateRect(PluginInstance *plugin, NPRect *invalidRect)
{
  npw_return_if_fail(rpc_method_invoke_possible(g_rpc_connection));

  int error = rpc_method_invoke(g_rpc_connection,
								RPC_METHOD_NPN_INVALIDATE_RECT,
								RPC_TYPE_NPW_PLUGIN_INSTANCE, plugin,
								RPC_TYPE_NP_RECT, invalidRect,
								RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPN_InvalidateRect() invoke", error);
	return;
  }

  error = rpc_method_wait_for_reply(g_rpc_connection, RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPN_InvalidateRect() wait for reply", error);
	return;
  }
}

static int handle_NPP_DestroyStream(rpc_connection_t *connection)
{
  D(bug("handle_NPP_DestroyStream\n"));

  PluginInstance *plugin;
  NPStream *stream;
  int32_t reason;
  int error = rpc_method_get_args(connection,
								  RPC_TYPE_NPW_PLUGIN_INSTANCE, &plugin,
								  RPC_TYPE_NP_STREAM, &stream,
								  RPC_TYPE_INT32, &reason,
								  RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPP_DestroyStream() get args", error);
	return error;
  }

  NPError ret = g_NPP_DestroyStream(PLUGIN_INSTANCE_NPP(plugin), stream, reason);
  return rpc_method_send_reply(connection, RPC_TYPE_INT32, ret, RPC_TYPE_INVALID);
}

static int handle_NPP_Write(rpc_connection_t *connection)
{
  D(bug("handle_NPP_Write\n"));

  PluginInstance *plugin;
  NPStream *stream;
  unsigned char *buf;
  int32_t offset, len;
  int error = rpc_method_get_args(connection,
								  RPC_TYPE_NPW_PLUGIN_INSTANCE, &plugin,
								  RPC_TYPE_NP_STREAM, &stream,
								  RPC_TYPE_INT32, &offset,
								  RPC_TYPE_ARRAY, RPC_TYPE_CHAR, &len, &buf,
								  RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPP_Write() get args", error);
	return error;
  }

  int32_t ret = g_NPP_Write(PLUGIN_INSTANCE_NPP(plugin), stream, offset, len, buf);

  if (buf)
	free(buf);

  return rpc_method_send_reply(connection, RPC_TYPE_INT32, ret, RPC_TYPE_INVALID);
}

static void npidentifier_cache_invalidate(void)
{
#if defined(HAVE_G_HASH_TABLE_REMOVE_ALL) && !defined(BUILD_GENERIC)
  if (g_npidentifier_cache)
	g_hash_table_remove_all(g_npidentifier_cache);
#else
  npidentifier_cache_destroy();
  npidentifier_cache_create();
#endif
}

static int do_recv_NPEmbedPrint(rpc_message_t *message, void *p_value)
{
  NPEmbedPrint *embedPrint = (NPEmbedPrint *)p_value;
  int error;

  if ((error = do_recv_NPWindowData(message, &embedPrint->window)) < 0)
	return error;

  embedPrint->platformPrint = NULL; // to be filled in by the plugin
  return RPC_ERROR_NO_ERROR;
}

static int do_recv_NPObject(rpc_message_t *message, void *p_value)
{
  int error;
  uint32_t npobj_id;

  if ((error = rpc_message_recv_uint32(message, &npobj_id)) < 0)
	return error;

  NPObject *npobj = NULL;
  if (npobj_id) {
	npobj = npobject_lookup(npobj_id);
#ifdef BUILD_VIEWER
	if (npobj == NULL) {
	  if ((npobj = npobject_new(npobj_id, NULL, NULL)) == NULL)
		return RPC_ERROR_NO_MEMORY;
	}
#endif
	assert(npobj != NULL);

#ifdef BUILD_VIEWER
	uint32_t referenceCount;
	if ((error = rpc_message_recv_uint32(message, &referenceCount)) < 0)
	  return error;
	if (npobj->referenceCount != referenceCount) {
	  D(bug("synchronize NPObject::referenceCount (%d -> %d)\n",
			npobj->referenceCount, referenceCount));
	  npobj->referenceCount = referenceCount;
	}
#endif
  }

  *((NPObject **)p_value) = npobj;
  return RPC_ERROR_NO_ERROR;
}

static int handle_NP_Initialize(rpc_connection_t *connection)
{
  D(bug("handle_NP_Initialize\n"));

  uint32_t version;
  int error = rpc_method_get_args(connection,
								  RPC_TYPE_UINT32, &version,
								  RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NP_Initialize() get args", error);
	return error;
  }

  NPError ret = g_NP_Initialize(version);
  return rpc_method_send_reply(connection, RPC_TYPE_INT32, ret, RPC_TYPE_INVALID);
}

g_NPN_GetValue_real(NPP instance, NPNVariable variable, void *value)
{
  PluginInstance *plugin = NULL;
  if (instance)
	plugin = PLUGIN_INSTANCE(instance);

  npw_plugin_instance_ref(plugin);
  NPError ret = invoke_NPN_GetValue(plugin, variable, value);
  npw_plugin_instance_unref(plugin);
  return ret;
}

g_NPN_Evaluate(NPP instance, NPObject *npobj, NPString *script, NPVariant *result)
{
  if (!thread_check()) {
	npw_printf("WARNING: NPN_Evaluate not called from the main thread\n");
	return false;
  }

  if (instance == NULL)
	return false;

  PluginInstance *plugin = PLUGIN_INSTANCE(instance);
  if (plugin == NULL)
	return false;

  if (!npobj)
	return false;

  if (!script || !script->UTF8Length || !script->UTF8Characters)
	return true; // nothing to evaluate

  D(bugiI("NPN_Evaluate instance=%p, npobj=%p\n", instance, npobj));
  npw_plugin_instance_ref(plugin);
  bool ret = invoke_NPN_Evaluate(plugin, npobj, script, result);
  npw_plugin_instance_unref(plugin);
  gchar *result_str = string_of_NPVariant(result);
  D(bugiD("NPN_Evaluate return: %d (%s)\n", ret, result_str));
  g_free(result_str);
  return ret;
}

invoke_NPN_NewStream(PluginInstance *plugin, NPMIMEType type, const char *target, NPStream **pstream)
{
  npw_return_val_if_fail(rpc_method_invoke_possible(g_rpc_connection),
						 NPERR_GENERIC_ERROR);

  int error = rpc_method_invoke(g_rpc_connection,
								RPC_METHOD_NPN_NEW_STREAM,
								RPC_TYPE_NPW_PLUGIN_INSTANCE, plugin,
								RPC_TYPE_STRING, type,
								RPC_TYPE_STRING, target,
								RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPN_NewStream() invoke", error);
	return NPERR_OUT_OF_MEMORY_ERROR;
  }

  int32_t ret;
  uint32_t stream_id;
  char *url;
  uint32_t end;
  uint32_t lastmodified;
  void *notifyData;
  char *headers;
  error = rpc_method_wait_for_reply(g_rpc_connection,
									RPC_TYPE_INT32, &ret,
									RPC_TYPE_UINT32, &stream_id,
									RPC_TYPE_STRING, &url,
									RPC_TYPE_UINT32, &end,
									RPC_TYPE_UINT32, &lastmodified,
									RPC_TYPE_NP_NOTIFY_DATA, &notifyData,
									RPC_TYPE_STRING, &headers,
									RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPN_NewStream() wait for reply", error);
	return NPERR_GENERIC_ERROR;
  }

  NPStream *stream = NULL;
  if (ret == NPERR_NO_ERROR) {
	if ((stream = malloc(sizeof(*stream))) == NULL)
	  return NPERR_OUT_OF_MEMORY_ERROR;
	memset(stream, 0, sizeof(*stream));

	StreamInstance *stream_ndata;
	if ((stream_ndata = malloc(sizeof(*stream_ndata))) == NULL) {
	  free(stream);
	  return NPERR_OUT_OF_MEMORY_ERROR;
	}
	stream->ndata = stream_ndata;
	stream->url = url;
	stream->end = end;
	stream->lastmodified = lastmodified;
	stream->notifyData = notifyData;
	stream->headers = headers;
	memset(stream_ndata, 0, sizeof(*stream_ndata));
	stream_ndata->stream_id = stream_id;
	id_link(stream_id, stream_ndata);
	stream_ndata->stream = stream;
	stream_ndata->is_plugin_stream = 1;
  }
  else {
	if (url)
	  free(url);
	if (headers)
	  free(headers);
  }
  *pstream = stream;

  return ret;
}

static gboolean rpc_event_check(GSource *source)
{
  return rpc_wait_dispatch(g_rpc_connection, 0) > 0;
}

g_NPN_MemFree(void *ptr)
{
  D(bugiI("NPN_MemFree ptr=%p\n", ptr));
  NPW_MemFree(ptr);
  D(bugiD("NPN_MemFree done\n"));
}

g_NPN_PostURL(NPP instance, const char *url, const char *target, uint32_t len, const char *buf, NPBool file)
{
  if (!thread_check()) {
	npw_printf("WARNING: NPN_PostURL not called from the main thread\n");
	return NPERR_INVALID_INSTANCE_ERROR;
  }

  if (instance == NULL)
	return NPERR_INVALID_INSTANCE_ERROR;

  PluginInstance *plugin = PLUGIN_INSTANCE(instance);
  if (plugin == NULL)
	return NPERR_INVALID_INSTANCE_ERROR;

  D(bugiI("NPN_PostURL instance=%p\n", instance));
  npw_plugin_instance_ref(plugin);
  NPError ret = invoke_NPN_PostURL(plugin, url, target, len, buf, file);
  npw_plugin_instance_unref(plugin);
  D(bugiD("NPN_PostURL return: %d [%s]\n", ret, string_of_NPError(ret)));
  return ret;
}

const char *string_of_NPError(int error)
{
  const char *str;

  switch ((NPError)error) {
#define _(VAL) case VAL: str = #VAL; break;
	_(NPERR_NO_ERROR);
	_(NPERR_GENERIC_ERROR);
	_(NPERR_INVALID_INSTANCE_ERROR);
	_(NPERR_INVALID_FUNCTABLE_ERROR);
	_(NPERR_MODULE_LOAD_FAILED_ERROR);
	_(NPERR_OUT_OF_MEMORY_ERROR);
	_(NPERR_INVALID_PLUGIN_ERROR);
	_(NPERR_INVALID_PLUGIN_DIR_ERROR);
	_(NPERR_INCOMPATIBLE_VERSION_ERROR);
	_(NPERR_INVALID_PARAM);
	_(NPERR_INVALID_URL);
	_(NPERR_FILE_NOT_FOUND);
	_(NPERR_NO_DATA);
	_(NPERR_STREAM_NOT_SEEKABLE);
#undef _
  default:
	str = "<unknown error>";
	break;
  }

  return str;
}

g_NPP_Write(NPP instance, NPStream *stream, int32_t offset, int32_t len, void *buf)
{
  if (instance == NULL)
	return -1;

  if (plugin_funcs.write == NULL)
	return -1;

  if (stream == NULL)
	return -1;

  D(bugiI("NPP_Write instance=%p, stream=%p, offset=%d, len=%d, buf=%p\n", instance, stream, offset, len, buf));
  int32_t ret = plugin_funcs.write(instance, stream, offset, len, buf);
  D(bugiD("NPP_Write return: %d\n", ret));
  return ret;
}

invoke_NPN_HasProperty(PluginInstance *plugin, NPObject *npobj, NPIdentifier propertyName)
{
  npw_return_val_if_fail(rpc_method_invoke_possible(g_rpc_connection), false);

  int error = rpc_method_invoke(g_rpc_connection,
								RPC_METHOD_NPN_HAS_PROPERTY,
								RPC_TYPE_NPW_PLUGIN_INSTANCE, plugin,
								RPC_TYPE_NP_OBJECT, npobj,
								RPC_TYPE_NP_IDENTIFIER, &propertyName,
								RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPN_HasProperty() invoke", error);
	return false;
  }

  uint32_t ret;
  error = rpc_method_wait_for_reply(g_rpc_connection,
									RPC_TYPE_UINT32, &ret,
									RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPN_HasProperty() wait for reply", error);
	return false;
  }

  return ret;
}

static gboolean delayed_calls_process(PluginInstance *plugin, gboolean is_in_NPP_Destroy)
{
  while (g_delayed_calls != NULL) {

	if (!is_in_NPP_Destroy) {
	  /* Continue later if there is incoming RPC */
	  if (rpc_wait_dispatch(g_rpc_connection, 0) > 0)
		return TRUE;
	}

	DelayedCall *dcall = (DelayedCall *)g_delayed_calls->data;
	/* XXX: Remove the link first; this function /must/ be
	 * re-entrant. We may be called again while processing the
	 * delayed call. */
	g_delayed_calls = g_list_delete_link(g_delayed_calls, g_delayed_calls);
	switch (dcall->type) {
	case RPC_DELAYED_NPN_RELEASE_OBJECT:
	  {
		NPObject *npobj = (NPObject *)dcall->data;
		g_NPN_ReleaseObject_Now(npobj);
		break;
	  }
	}
	NPW_MemFree(dcall);
  }

  if (g_delayed_calls)
	return TRUE;

  if (g_delayed_calls_id) {
	g_source_remove(g_delayed_calls_id);
	g_delayed_calls_id = 0;
  }
  return FALSE;
}

static int handle_NPP_Print(rpc_connection_t *connection)
{
  D(bug("handle_NPP_Print\n"));

  PluginInstance *plugin;
  NPPrint printInfo;
  uint32_t platform_print_id;
  int error = rpc_method_get_args(connection,
								  RPC_TYPE_NPW_PLUGIN_INSTANCE, &plugin,
								  RPC_TYPE_UINT32, &platform_print_id,
								  RPC_TYPE_NP_PRINT, &printInfo,
								  RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPP_Print() get args", error);
	return error;
  }

  NPPrintCallbackStruct printer;
  printer.type = NP_PRINT;
  printer.fp = platform_print_id ? tmpfile() : NULL;
  switch (printInfo.mode) {
  case NP_FULL:
	printInfo.print.fullPrint.platformPrint = &printer;
	break;
  case NP_EMBED:
	printInfo.print.embedPrint.platformPrint = &printer;
	create_window_attributes(printInfo.print.embedPrint.window.ws_info);
	break;
  }

  g_NPP_Print(PLUGIN_INSTANCE_NPP(plugin), &printInfo);

  if (printer.fp) {
	long file_size = ftell(printer.fp);
	D(bug(" writeback data [%d bytes]\n", file_size));
	rewind(printer.fp);
	if (file_size > 0) {
	  NPPrintData printData;
	  const int printDataMaxSize = sizeof(printData.data);
	  int n = file_size / printDataMaxSize;
	  while (--n >= 0) {
		printData.size = printDataMaxSize;
		if (fread(&printData.data, sizeof(printData.data), 1, printer.fp) != 1) {
		  npw_printf("ERROR: unexpected end-of-file or error condition in NPP_Print\n");
		  break;
		}
		npw_plugin_instance_ref(plugin);
		invoke_NPN_PrintData(plugin, platform_print_id, &printData);
		npw_plugin_instance_unref(plugin);
	  }
	  printData.size = file_size % printDataMaxSize;
	  if (fread(&printData.data, printData.size, 1, printer.fp) != 1)
		npw_printf("ERROR: unexpected end-of-file or error condition in NPP_Print\n");
	  npw_plugin_instance_ref(plugin);
	  invoke_NPN_PrintData(plugin, platform_print_id, &printData);
	  npw_plugin_instance_unref(plugin);
	}
	fclose(printer.fp);
  }

  if (printInfo.mode == NP_EMBED) {
	NPWindow *window = &printInfo.print.embedPrint.window;
	if (window->ws_info) {
	  destroy_window_attributes(window->ws_info);
	  window->ws_info = NULL;
	}
  }

  uint32_t plugin_printed = FALSE;
  if (printInfo.mode == NP_FULL)
	plugin_printed = printInfo.print.fullPrint.pluginPrinted;
  return rpc_method_send_reply(connection, RPC_TYPE_BOOLEAN, plugin_printed, RPC_TYPE_INVALID);
}

g_NPP_StreamAsFile(NPP instance, NPStream *stream, const char *fname)
{
  if (instance == NULL)
	return;

  if (plugin_funcs.asfile == NULL)
	return;

  if (stream == NULL)
	return;

  D(bugiI("NPP_StreamAsFile instance=%p, stream=%p, fname='%s'\n", instance, stream, fname));
  plugin_funcs.asfile(instance, stream, fname);
  D(bugiD("NPP_StreamAsFile done\n"));
}

static int do_recv_NPSetWindowCallbackStruct(rpc_message_t *message, void *p_value)
{
  NPSetWindowCallbackStruct **ws_info_p = (NPSetWindowCallbackStruct **)p_value;
  NPSetWindowCallbackStruct *ws_info;
  int32_t type;
  uint32_t has_ws_info, visual_id, colormap, depth;
  int error;

  if (ws_info_p)
	*ws_info_p = NULL;

  if ((error = rpc_message_recv_uint32(message, &has_ws_info)) < 0)
	return error;

  if (has_ws_info) {
	if ((error = rpc_message_recv_int32(message, &type)) < 0)
	  return error;
	if ((error = rpc_message_recv_uint32(message, &visual_id)) < 0)
	  return error;
	if ((error = rpc_message_recv_uint32(message, &colormap)) < 0)
	  return error;
	if ((error = rpc_message_recv_uint32(message, &depth)) < 0)
	  return error;

	if (ws_info_p) {
	  if ((ws_info = calloc(1, sizeof(*ws_info))) == NULL)
		return RPC_ERROR_NO_MEMORY;
	  ws_info->type = type;
	  ws_info->visual = (void *)(uintptr_t)visual_id;
	  ws_info->colormap = colormap;
	  ws_info->depth = depth;
	  *ws_info_p = ws_info;
	}
  }

  return RPC_ERROR_NO_ERROR;
}

void id_kill(void)
{
  if (g_ids) {
	g_hash_table_destroy(g_ids);
	g_ids = NULL;
  }
}

static int handle_NPP_NewStream(rpc_connection_t *connection)
{
  D(bug("handle_NPP_NewStream\n"));

  int error;
  PluginInstance *plugin;
  uint32_t stream_id;
  uint32_t seekable;
  NPMIMEType type;

  NPStream *stream;
  if ((stream = malloc(sizeof(*stream))) == NULL)
	return RPC_ERROR_NO_MEMORY;
  memset(stream, 0, sizeof(*stream));

  error = rpc_method_get_args(connection,
							  RPC_TYPE_NPW_PLUGIN_INSTANCE, &plugin,
							  RPC_TYPE_STRING, &type,
							  RPC_TYPE_UINT32, &stream_id,
							  RPC_TYPE_STRING, &stream->url,
							  RPC_TYPE_UINT32, &stream->end,
							  RPC_TYPE_UINT32, &stream->lastmodified,
							  RPC_TYPE_NP_NOTIFY_DATA, &stream->notifyData,
							  RPC_TYPE_STRING, &stream->headers,
							  RPC_TYPE_BOOLEAN, &seekable,
							  RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPP_NewStream() get args", error);
	return error;
  }

  StreamInstance *stream_ndata;
  if ((stream_ndata = malloc(sizeof(*stream_ndata))) == NULL)
	return RPC_ERROR_NO_MEMORY;
  stream->ndata = stream_ndata;
  memset(stream_ndata, 0, sizeof(*stream_ndata));
  stream_ndata->stream_id = stream_id;
  id_link(stream_id, stream_ndata);
  stream_ndata->stream = stream;
  stream_ndata->is_plugin_stream = 0;

  uint16_t stype = NP_NORMAL;
  NPError ret = g_NPP_NewStream(PLUGIN_INSTANCE_NPP(plugin), type, stream, seekable, &stype);

  if (type)
	free(type);

  return rpc_method_send_reply(connection,
							   RPC_TYPE_INT32, ret,
							   RPC_TYPE_UINT32, (uint32_t)stype,
							   RPC_TYPE_NP_NOTIFY_DATA, stream->notifyData,
							   RPC_TYPE_INVALID);
}

g_NPN_GetJavaEnv(void)
{
  D(bug("NPN_GetJavaEnv\n"));

  return NULL;
}

const char *npw_strerror(int error)
{
  if (error > -1100 && error <= -1000)	// RPC errors
	return rpc_strerror(error);

  switch (error) {
  case 0:	return "No error";
  }

  return "Unknown error";
}

g_NPP_HandleEvent(NPP instance, NPEvent *event)
{
  if (instance == NULL)
	return false;

  if (plugin_funcs.event == NULL)
	return false;

  if (event == NULL)
	return false;

  D(bugiI("NPP_HandleEvent instance=%p, event=%p [%s]\n", instance, event, string_of_NPEvent_type(event->type)));
  int16_t ret = plugin_funcs.event(instance, event);
  D(bugiD("NPP_HandleEvent return: %d\n", ret));

  /* XXX: let's have a chance to commit the pixmap before it's gone */
  if (event->type == GraphicsExpose)
	gdk_flush();

  return ret;
}

static void npidentifier_cache_reserve(int n_entries)
{
  if (G_UNLIKELY(g_npidentifier_cache == NULL))
	npidentifier_cache_create();
  if (g_hash_table_size(g_npidentifier_cache) + n_entries > NPIDENTIFIER_CACHE_SIZE)
	npidentifier_cache_invalidate();
}

static int do_recv_XAnyEvent(rpc_message_t *message, XEvent *xevent)
{
  uint32_t serial, send_event, window;
  int error;
  if ((error = rpc_message_recv_uint32(message, &serial)) < 0)
	return error;
  if ((error = rpc_message_recv_uint32(message, &send_event)) < 0)
	return error;
  if ((error = rpc_message_recv_uint32(message, &window)) < 0)
	return error;
  xevent->xany.serial = serial;
  xevent->xany.send_event = send_event;
  xevent->xany.window = window;
  return RPC_ERROR_NO_ERROR;
}

invoke_NPN_GetStringIdentifier(const NPUTF8 *name)
{
  npw_return_val_if_fail(rpc_method_invoke_possible(g_rpc_connection), NULL);

  int error = rpc_method_invoke(g_rpc_connection,
								RPC_METHOD_NPN_GET_STRING_IDENTIFIER,
								RPC_TYPE_STRING, name,
								RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPN_GetStringIdentifier() invoke", error);
	return NULL;
  }

  NPIdentifier ident;
  error = rpc_method_wait_for_reply(g_rpc_connection,
									RPC_TYPE_NP_IDENTIFIER, &ident,
									RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPN_GetStringIdentifier() wait for reply", error);
	return NULL;
  }

  return ident;
}

cached_NPN_IdentifierIsString(NPIdentifier ident)
{
#if USE_NPIDENTIFIER_CACHE
  if (use_npidentifier_cache()) {
	NPIdentifierInfo *npi = npidentifier_cache_lookup(ident);
	if (npi)
	  return npi->string_len > 0;
  }
#endif
  /* cache update is postponed to actual NPN_UTF8FromIdentifier() or
	 NPN_IntFromIdentifier() */
  return invoke_NPN_IdentifierIsString(ident);
}

g_NP_Shutdown(void)
{
  if (g_plugin_NP_Shutdown == NULL)
	return NPERR_INVALID_FUNCTABLE_ERROR;

  D(bugiI("NP_Shutdown\n"));
  NPError ret = g_plugin_NP_Shutdown();
  D(bugiD("NP_Shutdown done\n"));

  if (NPN_HAS_FEATURE(NPRUNTIME_SCRIPTING))
	npobject_bridge_destroy();

  gtk_main_quit();

  return ret;
}

static int do_recv_NPStream(rpc_message_t *message, void *p_value)
{
  int error;
  uint32_t stream_id;

  if ((error = rpc_message_recv_uint32(message, &stream_id)) < 0)
	return error;

  NPW_StreamInstance *stream = id_lookup(stream_id);
  *((NPStream **)p_value) = stream ? stream->stream : NULL;
  return RPC_ERROR_NO_ERROR;
}

static int do_send_NPWindowData(rpc_message_t *message, void *p_value)
{
  NPWindow *window = (NPWindow *)p_value;
  int error;

  if (window == NULL)
	return RPC_ERROR_MESSAGE_ARGUMENT_INVALID;

  if ((error = rpc_message_send_uint32(message, (Window)window->window)) < 0)
	return error;
  if ((error = rpc_message_send_int32(message, window->x)) < 0)
	return error;
  if ((error = rpc_message_send_int32(message, window->y)) < 0)
	return error;
  if ((error = rpc_message_send_uint32(message, window->width)) < 0)
	return error;
  if ((error = rpc_message_send_uint32(message, window->height)) < 0)
	return error;
  if ((error = do_send_NPRect(message, &window->clipRect)) < 0)
	return error;
  if ((error = rpc_message_send_int32(message, window->type)) < 0)
	return error;
  if ((error = do_send_NPSetWindowCallbackStruct(message, window->ws_info)) < 0)
	return 0;

  return RPC_ERROR_NO_ERROR;
}

static gboolean xt_event_dispatch(GSource *source, GSourceFunc callback, gpointer user_data)
{
  int i;
  for (i = 0; i < XT_MAX_DISPATCH_EVENTS; i++) {
	int mask = XtAppPending(x_app_context);
	if (mask == 0)
	  break;
	XtAppProcessEvent(x_app_context, XtIMAll);
  }
  return TRUE;
}

static int do_send_NPSetWindowCallbackStruct(rpc_message_t *message, void *p_value)
{
  NPSetWindowCallbackStruct *ws_info = (NPSetWindowCallbackStruct *)p_value;
  int error;

  if (ws_info) {
	if ((error = rpc_message_send_uint32(message, 1)) < 0)
	  return error;
	if ((error = rpc_message_send_int32(message, ws_info->type)) < 0)
	  return error;
	if ((error = rpc_message_send_uint32(message, ws_info->visual ? XVisualIDFromVisual(ws_info->visual) : 0)) < 0)
	  return error;
	if ((error = rpc_message_send_uint32(message, ws_info->colormap)) < 0)
	  return error;
	if ((error = rpc_message_send_uint32(message, ws_info->depth)) < 0)
	  return error;
  }
  else {
	if ((error = rpc_message_send_uint32(message, 0)) < 0)
	  return error;
  }

  return RPC_ERROR_NO_ERROR;
}

g_NPN_PopPopupsEnabledState(NPP instance)
{
  if (!thread_check()) {
	npw_printf("WARNING: NPN_PophPopupsEnabledState not called from the main thread\n");
	return;
  }

  if (instance == NULL)
	return;

  PluginInstance *plugin = PLUGIN_INSTANCE(instance);
  if (plugin == NULL)
	return;

  D(bugiI("NPN_PopPopupsEnabledState instance=%p\n", instance));
  npw_plugin_instance_ref(plugin);
  invoke_NPN_PopPopupsEnabledState(plugin);
  npw_plugin_instance_unref(plugin);
  D(bugiD("NPN_PopPopupsEnabledState done\n"));
}

invoke_NPN_RequestRead(NPStream *stream, NPByteRange *rangeList)
{
  npw_return_val_if_fail(rpc_method_invoke_possible(g_rpc_connection),
						 NPERR_GENERIC_ERROR);

  int error = rpc_method_invoke(g_rpc_connection,
								RPC_METHOD_NPN_REQUEST_READ,
								RPC_TYPE_NP_STREAM, stream,
								RPC_TYPE_NP_BYTE_RANGE, rangeList,
								RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPN_RequestRead() invoke", error);
	return NPERR_GENERIC_ERROR;
  }

  int32_t ret;
  error = rpc_method_wait_for_reply(g_rpc_connection, RPC_TYPE_INT32, &ret, RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPN_RequestRead() wait for reply", error);
	return NPERR_GENERIC_ERROR;
  }

  return ret;
}

invoke_NPN_GetURLNotify(PluginInstance *plugin, const char *url, const char *target, void *notifyData)
{
  npw_return_val_if_fail(rpc_method_invoke_possible(g_rpc_connection),
						 NPERR_GENERIC_ERROR);

  int error = rpc_method_invoke(g_rpc_connection,
								RPC_METHOD_NPN_GET_URL_NOTIFY,
								RPC_TYPE_NPW_PLUGIN_INSTANCE, plugin,
								RPC_TYPE_STRING, url,
								RPC_TYPE_STRING, target,
								RPC_TYPE_NP_NOTIFY_DATA, notifyData,
								RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPN_GetURLNotify() invoke", error);
	return NPERR_GENERIC_ERROR;
  }

  int32_t ret;
  error = rpc_method_wait_for_reply(g_rpc_connection, RPC_TYPE_INT32, &ret, RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPN_GetURLNotify() wait for reply", error);
	return NPERR_GENERIC_ERROR;
  }

  return ret;
}

static int do_send_NPSavedData(rpc_message_t *message, void *p_value)
{
  NPSavedData *save_area = (NPSavedData *)p_value;
  int error;

  if (save_area == NULL) {
	if ((error = rpc_message_send_int32(message, 0)) < 0)
	  return error;
  }
  else {
	if ((error = rpc_message_send_int32(message, save_area->len)) < 0)
	  return error;
	if ((error = rpc_message_send_bytes(message, save_area->buf, save_area->len)) < 0)
	  return error;
  }

  return RPC_ERROR_NO_ERROR;
}

invoke_NPN_IntFromIdentifier(NPIdentifier identifier)
{
  npw_return_val_if_fail(rpc_method_invoke_possible(g_rpc_connection), -1);

  int error = rpc_method_invoke(g_rpc_connection,
								RPC_METHOD_NPN_INT_FROM_IDENTIFIER,
								RPC_TYPE_NP_IDENTIFIER, &identifier,
								RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPN_IntFromIdentifier() invoke", error);
	return -1;
  }

  int32_t ret;
  error = rpc_method_wait_for_reply(g_rpc_connection,
									RPC_TYPE_INT32, &ret,
									RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPN_IntFromIdentifier() wait for reply", error);
	return -1;
  }

  return ret;
}

static int do_recv_NPRect(rpc_message_t *message, void *p_value)
{
  NPRect *rect = (NPRect *)p_value;
  uint32_t top, left, bottom, right;
  int error;

  if ((error = rpc_message_recv_uint32(message, &top)) < 0)
	return error;
  if ((error = rpc_message_recv_uint32(message, &left)) < 0)
	return error;
  if ((error = rpc_message_recv_uint32(message, &bottom)) < 0)
	return error;
  if ((error = rpc_message_recv_uint32(message, &right)) < 0)
	return error;

  rect->top = top;
  rect->left = left;
  rect->bottom = bottom;
  rect->right = right;
  return RPC_ERROR_NO_ERROR;
}

static int do_send_NPPrint(rpc_message_t *message, void *p_value)
{
  NPPrint *printInfo = (NPPrint *)p_value;
  int error;

  if ((error = rpc_message_send_uint32(message, printInfo->mode)) < 0)
	return error;
  switch (printInfo->mode) {
  case NP_FULL:
	if ((error = do_send_NPFullPrint(message, &printInfo->print.fullPrint)) < 0)
	  return error;
	break;
  case NP_EMBED:
	if ((error = do_send_NPEmbedPrint(message, &printInfo->print.embedPrint)) < 0)
	  return error;
	break;
  default:
	return RPC_ERROR_GENERIC;
  }

  return RPC_ERROR_NO_ERROR;
}

void npw_perror(const char *prefix, int error)
{
  if (prefix && *prefix)
	npw_printf("ERROR: %s: %s\n", prefix, npw_strerror(error));
  else
	npw_printf("ERROR: %s\n", npw_strerror(error));
}

g_NPN_ReleaseObject_Now(NPObject *npobj)
{
  D(bugiI("NPN_ReleaseObject npobj=%p\n", npobj));
  uint32_t refcount = invoke_NPN_ReleaseObject(npobj);
  D(bugiD("NPN_ReleaseObject done (refcount: %d)\n", refcount));

  if ((npobj->referenceCount = refcount) == 0)
	npobject_destroy(npobj);
}

invoke_NPN_UTF8FromIdentifier(NPIdentifier identifier)
{
  npw_return_val_if_fail(rpc_method_invoke_possible(g_rpc_connection), NULL);

  int error = rpc_method_invoke(g_rpc_connection,
								RPC_METHOD_NPN_UTF8_FROM_IDENTIFIER,
								RPC_TYPE_NP_IDENTIFIER, &identifier,
								RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPN_UTF8FromIdentifier() invoke", error);
	return NULL;
  }

  NPUTF8 *str;
  error = rpc_method_wait_for_reply(g_rpc_connection,
									RPC_TYPE_NP_UTF8, &str,
									RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPN_UTF8FromIdentifier() wait for reply", error);
	return NULL;
  }

  return str;
}

static int do_info(void)
{
  if (do_test() != 0)
	return 1;
  const char *plugin_name = NULL;
  if (g_NP_GetValue(NPPVpluginNameString, &plugin_name) == NPERR_NO_ERROR && plugin_name)
	printf("PLUGIN_NAME %zd\n%s\n", strlen(plugin_name), plugin_name);
  const char *plugin_desc = NULL;
  if (g_NP_GetValue(NPPVpluginDescriptionString, &plugin_desc) == NPERR_NO_ERROR && plugin_desc)
	printf("PLUGIN_DESC %zd\n%s\n", strlen(plugin_desc), plugin_desc);
  const char *mime_info = g_NP_GetMIMEDescription();
  if (mime_info)
	printf("PLUGIN_MIME %zd\n%s\n", strlen(mime_info), mime_info);
  return 0;
}

static gboolean npidentifier_cache_find_info(gpointer key, gpointer value, gpointer user_data)
{
  NPIdentifier *ident = (NPIdentifier)key;
  NPIdentifierInfo *npi = (NPIdentifierInfo *)value;
  NPIdentifierFindArgs *args = (NPIdentifierFindArgs *)user_data;
#if !defined(HAVE_G_HASH_TABLE_FIND) || defined(BUILD_GENERIC)
  if (args->ident)
	return FALSE;
#endif
  if (npi->string_len != args->info.string_len)
	return FALSE;
  if (args->info.string_len > 0) {		/* a string */
	if (memcmp(args->info.u.string, npi->u.string, args->info.string_len) == 0) {
	  args->ident = ident;
	  return TRUE;
	}
  }
  else {								/* an integer */
	if (args->info.u.value == npi->u.value) {
	  args->ident = ident;
	  return TRUE;
	}
  }
  return FALSE;
}

static inline bool npidentifier_cache_has_string(const gchar *str, NPIdentifier *pident)
{
  if (G_UNLIKELY(g_npidentifier_cache == NULL))
	return false;

  NPIdentifierFindArgs args;
  args.info.string_len = strlen(str) + 1;
  args.info.u.string = (gchar *)str;
  return npidentifier_cache_find(&args, pident);
}

invoke_NPN_HasMethod(PluginInstance *plugin, NPObject *npobj, NPIdentifier methodName)
{
  npw_return_val_if_fail(rpc_method_invoke_possible(g_rpc_connection), false);

  int error = rpc_method_invoke(g_rpc_connection,
								RPC_METHOD_NPN_HAS_METHOD,
								RPC_TYPE_NPW_PLUGIN_INSTANCE, plugin,
								RPC_TYPE_NP_OBJECT, npobj,
								RPC_TYPE_NP_IDENTIFIER, &methodName,
								RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPN_HasMethod() invoke", error);
	return false;
  }

  uint32_t ret;
  error = rpc_method_wait_for_reply(g_rpc_connection,
									RPC_TYPE_UINT32, &ret,
									RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPN_HasMethod() wait for reply", error);
	return false;
  }

  return ret;
}

g_NPN_GetURL(NPP instance, const char *url, const char *target)
{
  if (!thread_check()) {
	npw_printf("WARNING: NPN_GetURL not called from the main thread\n");
	return NPERR_INVALID_INSTANCE_ERROR;
  }

  if (instance == NULL)
	return NPERR_INVALID_INSTANCE_ERROR;

  PluginInstance *plugin = PLUGIN_INSTANCE(instance);
  if (plugin == NULL)
	return NPERR_INVALID_INSTANCE_ERROR;

  D(bugiI("NPN_GetURL instance=%p\n", instance));
  npw_plugin_instance_ref(plugin);
  NPError ret = invoke_NPN_GetURL(plugin, url, target);
  npw_plugin_instance_unref(plugin);
  D(bugiD("NPN_GetURL return: %d [%s]\n", ret, string_of_NPError(ret)));
  return ret;
}

invoke_NPN_GetValue(PluginInstance *plugin, NPNVariable variable, void *value)
{
  npw_return_val_if_fail(rpc_method_invoke_possible(g_rpc_connection),
						 NPERR_GENERIC_ERROR);

  int error = rpc_method_invoke(g_rpc_connection,
								RPC_METHOD_NPN_GET_VALUE,
								RPC_TYPE_NPW_PLUGIN_INSTANCE, plugin,
								RPC_TYPE_UINT32, variable,
								RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPN_GetValue() invoke", error);
	return NPERR_GENERIC_ERROR;
  }

  int32_t ret;
  switch (rpc_type_of_NPNVariable(variable)) {
  case RPC_TYPE_UINT32:
	{
	  uint32_t n = 0;
	  error = rpc_method_wait_for_reply(g_rpc_connection, RPC_TYPE_INT32, &ret, RPC_TYPE_UINT32, &n, RPC_TYPE_INVALID);
	  if (error != RPC_ERROR_NO_ERROR) {
		npw_perror("NPN_GetValue() wait for reply", error);
		ret = NPERR_GENERIC_ERROR;
	  }
	  D(bug("-> value: %u\n", n));
	  *((unsigned int *)value) = n;
	  break;
	}
  case RPC_TYPE_BOOLEAN:
	{
	  uint32_t b = 0;
	  error = rpc_method_wait_for_reply(g_rpc_connection, RPC_TYPE_INT32, &ret, RPC_TYPE_BOOLEAN, &b, RPC_TYPE_INVALID);
	  if (error != RPC_ERROR_NO_ERROR) {
		npw_perror("NPN_GetValue() wait for reply", error);
		ret = NPERR_GENERIC_ERROR;
	  }
	  D(bug("-> value: %s\n", b ? "true" : "false"));
	  *((NPBool *)value) = b ? TRUE : FALSE;
	  break;
	}
  case RPC_TYPE_NP_OBJECT:
	{
	  NPObject *npobj = NULL;
	  error = rpc_method_wait_for_reply(g_rpc_connection, RPC_TYPE_INT32, &ret, RPC_TYPE_NP_OBJECT, &npobj, RPC_TYPE_INVALID);
	  if (error != RPC_ERROR_NO_ERROR) {
		npw_perror("NPN_GetValue() wait for reply", error);
		ret = NPERR_GENERIC_ERROR;
	  }
	  D(bug("-> value: <object %p>\n", npobj));
	  *((NPObject **)value) = npobj;
	  break;
	}
  }

  return ret;
}

static int do_recv_NPUTF8(rpc_message_t *message, void *p_value)
{
  NPUTF8 **string_p = (NPUTF8 **)p_value;
  NPUTF8 *string = NULL;

  uint32_t len;
  int error = rpc_message_recv_uint32(message, &len);
  if (error < 0)
	return error;
  if ((string = NPN_MemAlloc(len)) == NULL)
	return RPC_ERROR_NO_MEMORY;
  if (len > 0) {
	if ((error = rpc_message_recv_bytes(message, (unsigned char *)string, len)) < 0)
	  return error;
  }

  if (string_p)
	*string_p = string;
  else if (string)
	NPN_MemFree(string);
  return RPC_ERROR_NO_ERROR;
}

static void plugin_instance_invalidate(PluginInstance *plugin)
{
  destroy_window(plugin);

  /* NPP instance is no longer valid beyond this point. Drop the link
	 to the PluginInstance now so that future RPC with this
	 PluginInstance will actually emit a NULL instance, which the
	 other side will deal as a no-op for all functions but
	 NPN_GetValue().

	 However, don't free() the NPP instance yet as it could be used
	 later, e.g. in some NPObject::Invalidate()... Note: this also
	 means we forbid that function to call into the browser in an NPP
	 instance. */
  if (plugin->instance_id) {
	id_remove(plugin->instance_id);
	plugin->instance_id = 0;
  }
}

static gboolean xt_event_prepare(GSource *source, gint *timeout)
{
  int mask = XtAppPending(x_app_context);
  if (mask)
	return TRUE;
  /* XXX: create new GPollFD for input sources? */
  return (*timeout = xt_get_next_timeout(source)) == 0;
}

static void xt_source_destroy(void)
{
  if (--xt_source_count < 1 && xt_source) {
	g_source_destroy(xt_source);
	xt_source = NULL;
  }
}

static void destroy_window_attributes(NPSetWindowCallbackStruct *ws_info)
{
  if (ws_info == NULL)
	return;
  NPW_MemFree(ws_info);
}

g_NPN_GetIntIdentifier(int32_t intid)
{
  if (!thread_check()) {
	npw_printf("WARNING: NPN_GetIntIdentifier not called from the main thread\n");
	return NULL;
  }

  D(bugiI("NPN_GetIntIdentifier intid=%d\n", intid));
  NPIdentifier ret = cached_NPN_GetIntIdentifier(intid);
  D(bugiD("NPN_GetIntIdentifier return: %p\n", ret));
  return ret;
}

g_NPN_UTF8FromIdentifier(NPIdentifier identifier)
{
  if (!thread_check()) {
	npw_printf("WARNING: NPN_UTF8FromIdentifier not called from the main thread\n");
	return NULL;
  }

  D(bugiI("NPN_UTF8FromIdentifier identifier=%p\n", identifier));
  NPUTF8 *ret = cached_NPN_UTF8FromIdentifier(identifier);
  D(bugiD("NPN_UTF8FromIdentifier return: '%s'\n", ret));
  return ret;
}

static int handle_NPP_GetValue(rpc_connection_t *connection)
{
  D(bug("handle_NPP_GetValue\n"));

  int error;
  PluginInstance *plugin;
  int32_t variable;

  error = rpc_method_get_args(connection,
							  RPC_TYPE_NPW_PLUGIN_INSTANCE, &plugin,
							  RPC_TYPE_INT32, &variable,
							  RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_printf("ERROR: could not get NPP_GetValue variable\n");
	return error;
  }

  NPError ret = NPERR_GENERIC_ERROR;
  int variable_type = rpc_type_of_NPPVariable(variable);

  switch (variable_type) {
  case RPC_TYPE_STRING:
	{
	  char *str = NULL;
	  ret = g_NPP_GetValue(PLUGIN_INSTANCE_NPP(plugin), variable, (void *)&str);
	  return rpc_method_send_reply(connection, RPC_TYPE_INT32, ret, RPC_TYPE_STRING, str, RPC_TYPE_INVALID);
	}
  case RPC_TYPE_INT32:
	{
	  uint32_t n = 0;
	  ret = g_NPP_GetValue(PLUGIN_INSTANCE_NPP(plugin), variable, (void *)&n);
	  return rpc_method_send_reply(connection, RPC_TYPE_INT32, ret, RPC_TYPE_INT32, n, RPC_TYPE_INVALID);
	}
  case RPC_TYPE_BOOLEAN:
	{
	  NPBool b = FALSE;
	  ret = g_NPP_GetValue(PLUGIN_INSTANCE_NPP(plugin), variable, (void *)&b);
	  return rpc_method_send_reply(connection, RPC_TYPE_INT32, ret, RPC_TYPE_BOOLEAN, b, RPC_TYPE_INVALID);
	}
  case RPC_TYPE_NP_OBJECT:
	{
	  NPObject *npobj = NULL;
	  ret = g_NPP_GetValue(PLUGIN_INSTANCE_NPP(plugin), variable, (void *)&npobj);
	  return rpc_method_send_reply(connection, RPC_TYPE_INT32, ret, RPC_TYPE_NP_OBJECT, npobj, RPC_TYPE_INVALID);
	}
  }

  abort();
}

static int do_send_NPWindow(rpc_message_t *message, void *p_value)
{
  NPWindow *window = (NPWindow *)p_value;
  int error;

  if (window == NULL) {
	if ((error = rpc_message_send_uint32(message, 0)) < 0)
	  return error;
  }
  else {
	if ((error = rpc_message_send_uint32(message, 1)) < 0)
	  return error;
	if ((error = do_send_NPWindowData(message, window)) < 0)
	  return error;
  }

  return RPC_ERROR_NO_ERROR;
}

static int do_recv_XKeyEvent(rpc_message_t *message, XEvent *xevent)
{
  int32_t x, y, x_root, y_root, same_screen;
  uint32_t root, subwindow, time, state, keycode;
  int error;
  if ((error = do_recv_XAnyEvent(message, xevent)) < 0)
	return error;
  if ((error = rpc_message_recv_uint32(message, &root)) < 0)
	return error;
  if ((error = rpc_message_recv_uint32(message, &subwindow)) < 0)
	return error;
  if ((error = rpc_message_recv_uint32(message, &time)) < 0)
	return error;
  if ((error = rpc_message_recv_int32(message, &x)) < 0)
	return error;
  if ((error = rpc_message_recv_int32(message, &y)) < 0)
	return error;
  if ((error = rpc_message_recv_int32(message, &x_root)) < 0)
	return error;
  if ((error = rpc_message_recv_int32(message, &y_root)) < 0)
	return error;
  if ((error = rpc_message_recv_uint32(message, &state)) < 0)
	return error; 
  if ((error = rpc_message_recv_uint32(message, &keycode)) < 0)
	return error;
  if ((error = rpc_message_recv_int32(message, &same_screen)) < 0)
	return error;
  xevent->xkey.root = root;
  xevent->xkey.subwindow = subwindow;
  xevent->xkey.time = time;
  xevent->xkey.x = x;
  xevent->xkey.y = y;
  xevent->xkey.x_root = x_root;
  xevent->xkey.y_root = y_root;
  xevent->xkey.state = state;
  xevent->xkey.keycode = keycode;
  xevent->xkey.same_screen = same_screen;
  return RPC_ERROR_NO_ERROR;
}

g_NPN_PostURLNotify(NPP instance, const char *url, const char *target, uint32_t len, const char *buf, NPBool file, void *notifyData)
{
  if (!thread_check()) {
	npw_printf("WARNING: NPN_PostURLNotify not called from the main thread\n");
	return NPERR_INVALID_INSTANCE_ERROR;
  }
	
  if (instance == NULL)
	return NPERR_INVALID_INSTANCE_ERROR;

  PluginInstance *plugin = PLUGIN_INSTANCE(instance);
  if (plugin == NULL)
	return NPERR_INVALID_INSTANCE_ERROR;

  D(bugiI("NPN_PostURLNotify instance=%p\n", instance));
  npw_plugin_instance_ref(plugin);
  NPError ret = invoke_NPN_PostURLNotify(plugin, url, target, len, buf, file, notifyData);
  npw_plugin_instance_unref(plugin);
  D(bugiD("NPN_PostURLNotify return: %d [%s]\n", ret, string_of_NPError(ret)));
  return ret;
}

static int get_open_max(void)
{
  int open_max = -1;
  /* SCO OpenServer has an fcntl() to retrieve the highest *currently
	 open* file descriptor.  */
#ifdef F_GETHFDO
  if ((open_max = fcntl(-1, F_GETHFDO, 0)) >= 0)
	return open_max + 1;
#endif
  /* IEEE Std 1003.1-2001/Cor 1-2002 clarified the fact that return
	 value of sysconf(_SC_OPEN_MAX) may change if setrlimit() was
	 called to set RLIMIT_NOFILE. So, we should be on the safe side to
	 call getrlimit() first to get the soft limit.

	 Note: dgettablesize() was a possibility but (i) it's equivalent
	 to getrlimit(), and (ii) it is not recommended for new code.  */
  struct rlimit ru;
  if (getrlimit(RLIMIT_NOFILE, &ru) == 0)
	return ru.rlim_cur;
  if ((open_max = sysconf(_SC_OPEN_MAX)) >= 0)
	return open_max;
  /* XXX: simply guess something reasonable.  */
  return 256;
}

static int handle_NPP_WriteReady(rpc_connection_t *connection)
{
  D(bug("handle_NPP_WriteReady\n"));

  PluginInstance *plugin;
  NPStream *stream;
  int error = rpc_method_get_args(connection,
								  RPC_TYPE_NPW_PLUGIN_INSTANCE, &plugin,
								  RPC_TYPE_NP_STREAM, &stream,
								  RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPP_WriteReady() get args", error);
	return error;
  }

  int32_t ret = g_NPP_WriteReady(PLUGIN_INSTANCE_NPP(plugin), stream);

  return rpc_method_send_reply(connection, RPC_TYPE_INT32, ret, RPC_TYPE_INVALID);
}

static int untrap_errors(void)
{
  XSetErrorHandler(old_error_handler);
  return trapped_error_code;
}

g_NPN_Invoke(NPP instance, NPObject *npobj, NPIdentifier methodName,
			 const NPVariant *args, uint32_t argCount, NPVariant *result)
{
  if (!thread_check()) {
	npw_printf("WARNING: NPN_Invoke not called from the main thread\n");
	return false;
  }

  if (instance == NULL)
	return false;

  PluginInstance *plugin = PLUGIN_INSTANCE(instance);
  if (plugin == NULL)
	return false;
	
  if (!npobj || !npobj->_class || !npobj->_class->invoke)
	return false;

  D(bugiI("NPN_Invoke instance=%p, npobj=%p, methodName=%p\n", instance, npobj, methodName));
  print_npvariant_args(args, argCount);
  npw_plugin_instance_ref(plugin);
  bool ret = invoke_NPN_Invoke(plugin, npobj, methodName, args, argCount, result);
  npw_plugin_instance_unref(plugin);
  gchar *result_str = string_of_NPVariant(result);
  D(bugiD("NPN_Invoke return: %d (%s)\n", ret, result_str));
  g_free(result_str);
  return ret;
}

static int do_recv_XMotionEvent(rpc_message_t *message, XEvent *xevent)
{
  char is_hint;
  int32_t x, y, x_root, y_root, same_screen;
  uint32_t root, subwindow, time, state;
  int error;
  if ((error = do_recv_XAnyEvent(message, xevent)) < 0)
	return error;
  if ((error = rpc_message_recv_uint32(message, &root)) < 0)
	return error;
  if ((error = rpc_message_recv_uint32(message, &subwindow)) < 0)
	return error;
  if ((error = rpc_message_recv_uint32(message, &time)) < 0)
	return error;
  if ((error = rpc_message_recv_int32(message, &x)) < 0)
	return error;
  if ((error = rpc_message_recv_int32(message, &y)) < 0)
	return error;
  if ((error = rpc_message_recv_int32(message, &x_root)) < 0)
	return error;
  if ((error = rpc_message_recv_int32(message, &y_root)) < 0)
	return error;
  if ((error = rpc_message_recv_uint32(message, &state)) < 0)
	return error;
  if ((error = rpc_message_recv_char(message, &is_hint)) < 0)
	return error;
  if ((error = rpc_message_recv_int32(message, &same_screen)) < 0)
	return error;
  xevent->xmotion.root = root;
  xevent->xmotion.subwindow = subwindow;
  xevent->xmotion.time = time;
  xevent->xmotion.x = x;
  xevent->xmotion.y = y;
  xevent->xmotion.x_root = x_root;
  xevent->xmotion.y_root = y_root;
  xevent->xmotion.state = state;
  xevent->xmotion.is_hint = is_hint;
  xevent->xmotion.same_screen = same_screen;
  return RPC_ERROR_NO_ERROR;
}

static void xt_dummy_timeout_cb(XtPointer closure, XtIntervalId *id)
{
  /* dummy function, never called */
  npw_printf("ERROR: xt_dummy_timeout_cb() should never be called\n");
}

g_NP_Initialize(uint32_t version)
{
  if (g_plugin_NP_Initialize == NULL)
	return NPERR_INVALID_FUNCTABLE_ERROR;

  memset(&plugin_funcs, 0, sizeof(plugin_funcs));
  plugin_funcs.size = sizeof(plugin_funcs);

  memset(&mozilla_funcs, 0, sizeof(mozilla_funcs));
  mozilla_funcs.size = sizeof(mozilla_funcs);
  mozilla_funcs.version = version;
  mozilla_funcs.geturl = g_NPN_GetURL;
  mozilla_funcs.posturl = g_NPN_PostURL;
  mozilla_funcs.requestread = g_NPN_RequestRead;
  mozilla_funcs.newstream = g_NPN_NewStream;
  mozilla_funcs.write = g_NPN_Write;
  mozilla_funcs.destroystream = g_NPN_DestroyStream;
  mozilla_funcs.status = g_NPN_Status;
  mozilla_funcs.uagent = g_NPN_UserAgent;
  mozilla_funcs.memalloc = g_NPN_MemAlloc;
  mozilla_funcs.memfree = g_NPN_MemFree;
  mozilla_funcs.memflush = g_NPN_MemFlush;
  mozilla_funcs.reloadplugins = g_NPN_ReloadPlugins;
  mozilla_funcs.getJavaEnv = g_NPN_GetJavaEnv;
  mozilla_funcs.getJavaPeer = g_NPN_GetJavaPeer;
  mozilla_funcs.geturlnotify = g_NPN_GetURLNotify;
  mozilla_funcs.posturlnotify = g_NPN_PostURLNotify;
  mozilla_funcs.getvalue = g_NPN_GetValue;
  mozilla_funcs.setvalue = g_NPN_SetValue;
  mozilla_funcs.invalidaterect = g_NPN_InvalidateRect;
  mozilla_funcs.invalidateregion = g_NPN_InvalidateRegion;
  mozilla_funcs.forceredraw = g_NPN_ForceRedraw;
  mozilla_funcs.pushpopupsenabledstate = g_NPN_PushPopupsEnabledState;
  mozilla_funcs.poppopupsenabledstate = g_NPN_PopPopupsEnabledState;

  if (NPN_HAS_FEATURE(NPRUNTIME_SCRIPTING)) {
	D(bug(" browser supports scripting through npruntime\n"));
	mozilla_funcs.getstringidentifier = g_NPN_GetStringIdentifier;
	mozilla_funcs.getstringidentifiers = g_NPN_GetStringIdentifiers;
	mozilla_funcs.getintidentifier = g_NPN_GetIntIdentifier;
	mozilla_funcs.identifierisstring = g_NPN_IdentifierIsString;
	mozilla_funcs.utf8fromidentifier = g_NPN_UTF8FromIdentifier;
	mozilla_funcs.intfromidentifier = g_NPN_IntFromIdentifier;
	mozilla_funcs.createobject = g_NPN_CreateObject;
	mozilla_funcs.retainobject = g_NPN_RetainObject;
	mozilla_funcs.releaseobject = g_NPN_ReleaseObject;
	mozilla_funcs.invoke = g_NPN_Invoke;
	mozilla_funcs.invokeDefault = g_NPN_InvokeDefault;
	mozilla_funcs.evaluate = g_NPN_Evaluate;
	mozilla_funcs.getproperty = g_NPN_GetProperty;
	mozilla_funcs.setproperty = g_NPN_SetProperty;
	mozilla_funcs.removeproperty = g_NPN_RemoveProperty;
	mozilla_funcs.hasproperty = g_NPN_HasProperty;
	mozilla_funcs.hasmethod = g_NPN_HasMethod;
	mozilla_funcs.releasevariantvalue = g_NPN_ReleaseVariantValue;
	mozilla_funcs.setexception = g_NPN_SetException;

	if (!npobject_bridge_new())
	  return NPERR_OUT_OF_MEMORY_ERROR;
  }

  NPW_InitializeFuncs(&mozilla_funcs, &plugin_funcs);

  D(bugiI("NP_Initialize\n"));
  NPError ret = g_plugin_NP_Initialize(&mozilla_funcs, &plugin_funcs);
  D(bugiD("NP_Initialize return: %d\n", ret));
  return ret;
}

static int do_send_NPP(rpc_message_t *message, void *p_value)
{
  NPP instance = (NPP)p_value;
  NPW_PluginInstance *plugin = NULL;
  if (instance)
	plugin = NPW_PLUGIN_INSTANCE(instance);
  return do_send_NPW_PluginInstance(message, plugin);
}

g_NPN_HasProperty(NPP instance, NPObject *npobj, NPIdentifier propertyName)
{
  if (!thread_check()) {
	npw_printf("WARNING: NPN_HasProperty not called from the main thread\n");
	return false;
  }

  if (instance == NULL)
	return false;

  PluginInstance *plugin = PLUGIN_INSTANCE(instance);
  if (plugin == NULL)
	return false;

  if (!npobj || !npobj->_class || !npobj->_class->hasProperty)
	return false;

  D(bugiI("NPN_HasProperty instance=%p, npobj=%p, propertyName=%p\n", instance, npobj, propertyName));
  npw_plugin_instance_ref(plugin);
  bool ret = invoke_NPN_HasProperty(plugin, npobj, propertyName);
  npw_plugin_instance_unref(plugin);
  D(bugiD("NPN_HasProperty return: %d\n", ret));
  return ret;
}

g_NPP_DestroyStream(NPP instance, NPStream *stream, NPReason reason)
{
  if (instance == NULL)
	return NPERR_INVALID_INSTANCE_ERROR;

  if (plugin_funcs.destroystream == NULL)
	return NPERR_INVALID_FUNCTABLE_ERROR;

  if (stream == NULL)
	return NPERR_INVALID_PARAM;

  D(bugiI("NPP_DestroyStream instance=%p, stream=%p, reason=%s\n",
		instance, stream, string_of_NPReason(reason)));
  NPError ret = plugin_funcs.destroystream(instance, stream, reason);
  D(bugiD("NPP_DestroyStream return: %d [%s]\n", ret, string_of_NPError(ret)));

  StreamInstance *stream_ndata = stream->ndata;
  if (stream_ndata) {
	id_remove(stream_ndata->stream_id);
	free(stream_ndata);
  }
  free((char *)stream->url);
  free((char *)stream->headers);
  free(stream);

  return ret;
}

g_NPP_URLNotify(NPP instance, const char *url, NPReason reason, void *notifyData)
{
  if (instance == NULL)
	return;

  if (plugin_funcs.urlnotify == NULL)
	return;

  D(bugiI("NPP_URLNotify instance=%p, url='%s', reason=%s, notifyData=%p\n",
		instance, url, string_of_NPReason(reason), notifyData));
  plugin_funcs.urlnotify(instance, url, reason, notifyData);
  D(bugiD("NPP_URLNotify done\n"));
}

g_NP_GetMIMEDescription(void)
{
  if (g_plugin_NP_GetMIMEDescription == NULL)
	return NULL;

  D(bugiI("NP_GetMIMEDescription\n"));
  char *str = g_plugin_NP_GetMIMEDescription();
  D(bugiD("NP_GetMIMEDescription return: %s\n", str ? str : "<empty>"));
  return str;
}

static int do_send_NPObject(rpc_message_t *message, void *p_value)
{
  uint32_t npobj_id = 0;
  NPObject *npobj = (NPObject *)p_value;
  if (npobj) {
	NPObjectInfo *npobj_info = npobject_info_lookup(npobj);
	if (npobj_info)
	  npobj_id = npobj_info->npobj_id;
#ifdef BUILD_WRAPPER
	else {
	  if ((npobj_info = npobject_info_new(npobj)) == NULL)
		return RPC_ERROR_NO_MEMORY;
	  npobj_id = npobj_info->npobj_id;
	  npobject_associate(npobj, npobj_info);
	}
#endif
	assert(npobj_id != 0);
  }
  int error = rpc_message_send_uint32(message, npobj_id);
  if (error < 0)
	return error;

#ifdef BUILD_WRAPPER
  if (npobj) {
	if ((error = rpc_message_send_uint32(message, npobj->referenceCount)) < 0)
	  return error;
  }
#endif

  return RPC_ERROR_NO_ERROR;
}

static int do_send_NPEmbedPrint(rpc_message_t *message, void *p_value)
{
  NPEmbedPrint *embedPrint = (NPEmbedPrint *)p_value;
  int error;

  if ((error = do_send_NPWindowData(message, &embedPrint->window)) < 0)
	return error;

  return RPC_ERROR_NO_ERROR;
}

static void send_xembed_message(Display *display,
								Window   window,
								long     message,
								long     detail,
								long     data1,
								long     data2)
{
  XEvent xevent;
  memset(&xevent, 0, sizeof(xevent));
  xevent.xclient.window = window;
  xevent.xclient.type = ClientMessage;
  xevent.xclient.message_type = XInternAtom(display, "_XEMBED", False);
  xevent.xclient.format = 32;
  xevent.xclient.data.l[0] = CurrentTime; // XXX: evil?
  xevent.xclient.data.l[1] = message;
  xevent.xclient.data.l[2] = detail;
  xevent.xclient.data.l[3] = data1;
  xevent.xclient.data.l[4] = data2;

  trap_errors();
  XSendEvent(display, xevent.xclient.window, False, NoEventMask, &xevent);
  XSync(display, False);
  untrap_errors();
}

static int do_recv_NPEvent(rpc_message_t *message, void *p_value)
{
  NPEvent *event = (NPEvent *)p_value;
  int32_t event_type;
  int error;

  if ((error = rpc_message_recv_int32(message, &event_type)) < 0)
	return error;
  memset(event, 0, sizeof(*event));
  event->type = event_type;

  switch (event->type) {
  case GraphicsExpose:
	if ((error = do_recv_XGraphicsExposeEvent(message, event)) < 0)
	  return error;
	break;
  case FocusIn:
  case FocusOut:
	if ((error = do_recv_XFocusChangeEvent(message, event)) < 0)
	  return error;
	break;
  case EnterNotify:
  case LeaveNotify:
	if ((error = do_recv_XCrossingEvent(message, event)) < 0)
	  return error;
	break;
  case MotionNotify:
	if ((error = do_recv_XMotionEvent(message, event)) < 0)
	  return error;
	break;
  case ButtonPress:
  case ButtonRelease:
	if ((error = do_recv_XButtonEvent(message, event)) < 0)
	  return error;
	break;
  case KeyPress:
  case KeyRelease:
	if ((error = do_recv_XKeyEvent(message, event)) < 0)
	  return error;
	break;
  default:
	return RPC_ERROR_GENERIC;
  }

  return RPC_ERROR_NO_ERROR;
}

invoke_NPN_SetException(NPObject *npobj, const NPUTF8 *message)
{
  npw_return_if_fail(rpc_method_invoke_possible(g_rpc_connection));

  int error = rpc_method_invoke(g_rpc_connection,
								RPC_METHOD_NPN_SET_EXCEPTION,
								RPC_TYPE_NP_OBJECT, npobj,
								RPC_TYPE_STRING, message,
								RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPN_SetException() invoke", error);
	return;
  }

  error = rpc_method_wait_for_reply(g_rpc_connection, RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPN_SetException() wait for reply", error);
	return;
  }
}

invoke_NPN_CreateObject(PluginInstance *plugin)
{
  npw_return_val_if_fail(rpc_method_invoke_possible(g_rpc_connection), 0);

  int error = rpc_method_invoke(g_rpc_connection,
								RPC_METHOD_NPN_CREATE_OBJECT,
								RPC_TYPE_NPW_PLUGIN_INSTANCE, plugin,
								RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPN_CreateObject() invoke", error);
	return 0;
  }

  uint32_t npobj_id = 0;
  error = rpc_method_wait_for_reply(g_rpc_connection,
									RPC_TYPE_UINT32, &npobj_id,
									RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPN_CreateObject() wait for reply", error);
	return 0;
  }

  return npobj_id;
}

invoke_NPN_SetProperty(PluginInstance *plugin, NPObject *npobj, NPIdentifier propertyName,
					   const NPVariant *value)
{
  npw_return_val_if_fail(rpc_method_invoke_possible(g_rpc_connection), false);

  int error = rpc_method_invoke(g_rpc_connection,
								RPC_METHOD_NPN_SET_PROPERTY,
								RPC_TYPE_NPW_PLUGIN_INSTANCE, plugin,
								RPC_TYPE_NP_OBJECT, npobj,
								RPC_TYPE_NP_IDENTIFIER, &propertyName,
								RPC_TYPE_NP_VARIANT, value,
								RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPN_SetProperty() invoke", error);
	return false;
  }

  uint32_t ret;
  error = rpc_method_wait_for_reply(g_rpc_connection,
									RPC_TYPE_UINT32, &ret,
									RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPN_SetProperty() wait for reply", error);
	return false;
  }

  return ret;
}

static gboolean delayed_destroys_process_cb(gpointer user_data)
{
  while (g_delayed_destroys != NULL) {
	PluginInstance *plugin = (PluginInstance *)g_delayed_destroys->data;
	g_delayed_destroys = g_list_delete_link(g_delayed_destroys,
											g_delayed_destroys);
	g_NPP_Destroy_Now(plugin, NULL);
  }

  if (g_delayed_destroys)
	return TRUE;

  if (g_delayed_destroys_id) {
	g_source_remove(g_delayed_destroys_id);
	g_delayed_destroys_id = 0;
  }
  return FALSE;
}

static int do_main(int argc, char **argv, const char *connection_path)
{
  if (do_test() != 0)
	return 1;
  if (connection_path == NULL) {
	npw_printf("ERROR: missing connection path argument\n");
	return 1;
  }
  D(bug("  Plugin connection: %s\n", connection_path));
  D(bug("  Plugin viewer pid: %d\n", getpid()));

  thread_check_init();
  D(bug("  Plugin main thread: %p\n", g_main_thread));

#if defined(__linux__)
  if (getenv("LD_PRELOAD"))
	unsetenv("LD_PRELOAD");
#endif

  XtToolkitInitialize();
  x_app_context = XtCreateApplicationContext();
  x_display = XtOpenDisplay(x_app_context, NULL, "npw-viewer", "npw-viewer", NULL, 0, &argc, argv);
  g_thread_init(NULL);
  gtk_init(&argc, &argv);

  if ((g_rpc_connection = rpc_init_server(connection_path)) == NULL) {
	npw_printf("ERROR: failed to initialize plugin-side RPC server connection\n");
	return 1;
  }
  if (rpc_add_np_marshalers(g_rpc_connection) < 0) {
	npw_printf("ERROR: failed to initialize plugin-side marshalers\n");
	return 1;
  }
  static const rpc_method_descriptor_t vtable[] = {
	{ RPC_METHOD_NP_GET_MIME_DESCRIPTION,		handle_NP_GetMIMEDescription },
	{ RPC_METHOD_NP_GET_VALUE,					handle_NP_GetValue },
	{ RPC_METHOD_NP_INITIALIZE,					handle_NP_Initialize },
	{ RPC_METHOD_NP_SHUTDOWN,					handle_NP_Shutdown },
	{ RPC_METHOD_NPP_NEW,						handle_NPP_New },
	{ RPC_METHOD_NPP_DESTROY,					handle_NPP_Destroy },
	{ RPC_METHOD_NPP_GET_VALUE,					handle_NPP_GetValue },
	{ RPC_METHOD_NPP_SET_WINDOW,				handle_NPP_SetWindow },
	{ RPC_METHOD_NPP_URL_NOTIFY,				handle_NPP_URLNotify },
	{ RPC_METHOD_NPP_NEW_STREAM,				handle_NPP_NewStream },
	{ RPC_METHOD_NPP_DESTROY_STREAM,			handle_NPP_DestroyStream },
	{ RPC_METHOD_NPP_WRITE_READY,				handle_NPP_WriteReady },
	{ RPC_METHOD_NPP_WRITE,						handle_NPP_Write },
	{ RPC_METHOD_NPP_STREAM_AS_FILE,			handle_NPP_StreamAsFile },
	{ RPC_METHOD_NPP_PRINT,						handle_NPP_Print },
	{ RPC_METHOD_NPP_HANDLE_EVENT,				handle_NPP_HandleEvent },
	{ RPC_METHOD_NPCLASS_INVALIDATE,			npclass_handle_Invalidate },
	{ RPC_METHOD_NPCLASS_HAS_METHOD,			npclass_handle_HasMethod },
	{ RPC_METHOD_NPCLASS_INVOKE,				npclass_handle_Invoke },
	{ RPC_METHOD_NPCLASS_INVOKE_DEFAULT,		npclass_handle_InvokeDefault },
	{ RPC_METHOD_NPCLASS_HAS_PROPERTY,			npclass_handle_HasProperty },
	{ RPC_METHOD_NPCLASS_GET_PROPERTY,			npclass_handle_GetProperty },
	{ RPC_METHOD_NPCLASS_SET_PROPERTY,			npclass_handle_SetProperty },
	{ RPC_METHOD_NPCLASS_REMOVE_PROPERTY,		npclass_handle_RemoveProperty },
  };
  if (rpc_connection_add_method_descriptors(g_rpc_connection, vtable, sizeof(vtable) / sizeof(vtable[0])) < 0) {
	npw_printf("ERROR: failed to setup NPP method callbacks\n");
	return 1;
  }

  id_init();

  GSource *rpc_source = g_source_new(&rpc_event_funcs, sizeof(GSource));
  if (rpc_source == NULL) {
	npw_printf("ERROR: failed to initialize plugin-side RPC events listener\n");
	return 1;
  }
  g_source_set_priority(rpc_source, G_PRIORITY_LOW);
  g_source_attach(rpc_source, NULL);
  rpc_event_poll_fd.fd = rpc_listen_socket(g_rpc_connection);
  rpc_event_poll_fd.events = G_IO_IN;
  rpc_event_poll_fd.revents = 0;
  g_source_set_callback(rpc_source, (GSourceFunc)rpc_dispatch, g_rpc_connection, NULL);
  g_source_add_poll(rpc_source, &rpc_event_poll_fd);

  rpc_connection_set_error_callback(g_rpc_connection, rpc_error_callback_cb, NULL);
 
  gtk_main();
  D(bug("--- EXIT ---\n"));

#if USE_NPIDENTIFIER_CACHE
  npidentifier_cache_destroy();
#endif

  g_source_destroy(rpc_source);
  if (xt_source)
	g_source_destroy(xt_source);

  if (g_user_agent)
	free(g_user_agent);
  if (g_rpc_connection)
	rpc_connection_unref(g_rpc_connection);

  id_kill();
  return 0;
}

static int do_recv_XGraphicsExposeEvent(rpc_message_t *message, XEvent *xevent)
{
  int32_t x, y;
  uint32_t width, height;
  int error;
  if ((error = do_recv_XAnyEvent(message, xevent)) < 0)
	return error;
  if ((error = rpc_message_recv_int32(message, &x)) < 0)
	return error;
  if ((error = rpc_message_recv_int32(message, &y)) < 0)
	return error;
  if ((error = rpc_message_recv_uint32(message, &width)) < 0)
	return error;
  if ((error = rpc_message_recv_uint32(message, &height)) < 0)
	return error;
  xevent->xgraphicsexpose.x = x;
  xevent->xgraphicsexpose.y = y;
  xevent->xgraphicsexpose.width = width;
  xevent->xgraphicsexpose.height = height;
  return RPC_ERROR_NO_ERROR;
}

invoke_NPN_GetURL(PluginInstance *plugin, const char *url, const char *target)
{
  npw_return_val_if_fail(rpc_method_invoke_possible(g_rpc_connection),
						 NPERR_GENERIC_ERROR);

  int error = rpc_method_invoke(g_rpc_connection,
								RPC_METHOD_NPN_GET_URL,
								RPC_TYPE_NPW_PLUGIN_INSTANCE, plugin,
								RPC_TYPE_STRING, url,
								RPC_TYPE_STRING, target,
								RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPN_GetURL() invoke", error);
	return NPERR_GENERIC_ERROR;
  }

  int32_t ret;
  error = rpc_method_wait_for_reply(g_rpc_connection, RPC_TYPE_INT32, &ret, RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPN_GetURL() wait for reply", error);
	return NPERR_GENERIC_ERROR;
  }

  return ret;
}

static int do_recv_NPP(rpc_message_t *message, void *p_value)
{
  int error;
  NPW_PluginInstance *plugin;

  if ((error = do_recv_NPW_PluginInstance(message, &plugin)) < 0)
	return error;

  *((NPP *)p_value) = plugin ? plugin->instance : NULL;
  return RPC_ERROR_NO_ERROR;
}

static int do_send_NPW_PluginInstance(rpc_message_t *message, void *p_value)
{
  NPW_PluginInstance *plugin = (NPW_PluginInstance *)p_value;
  uint32_t instance_id = 0;
  if (plugin)
	instance_id = plugin->instance_id;
  return rpc_message_send_uint32(message, instance_id);
}

static inline int get_appcontext_input_count_at(int offset)
{
  return *((short *)((char *)x_app_context + offset));
}

g_NPN_InvokeDefault(NPP instance, NPObject *npobj,
					const NPVariant *args, uint32_t argCount, NPVariant *result)
{
  if (!thread_check()) {
	npw_printf("WARNING: NPN_InvokeDefault not called from the main thread\n");
	return false;
  }

  if (instance == NULL)
	return false;

  PluginInstance *plugin = PLUGIN_INSTANCE(instance);
  if (plugin == NULL)
	return false;

  if (!npobj || !npobj->_class || !npobj->_class->invokeDefault)
	return false;

  D(bugiI("NPN_InvokeDefault instance=%p, npobj=%p\n", instance, npobj));
  print_npvariant_args(args, argCount);
  npw_plugin_instance_ref(plugin);
  bool ret = invoke_NPN_InvokeDefault(plugin, npobj, args, argCount, result);
  npw_plugin_instance_unref(plugin);
  gchar *result_str = string_of_NPVariant(result);
  D(bugiD("NPN_InvokeDefault return: %d (%s)\n", ret, result_str));
  g_free(result_str);
  return ret;
}

static inline bool is_thread_check_enabled(void)
{
  static int thread_check = -1;
  if (thread_check < 0)
    thread_check = is_thread_check_enabled_1();
  return thread_check;
}

invoke_NPN_RetainObject(NPObject *npobj)
{
  npw_return_val_if_fail(rpc_method_invoke_possible(g_rpc_connection),
						 npobj->referenceCount);

  int error = rpc_method_invoke(g_rpc_connection,
								RPC_METHOD_NPN_RETAIN_OBJECT,
								RPC_TYPE_NP_OBJECT, npobj,
								RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPN_RetainObject() invoke", error);
	return npobj->referenceCount;
  }

  uint32_t refcount;
  error = rpc_method_wait_for_reply(g_rpc_connection, RPC_TYPE_UINT32, &refcount, RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPN_RetainObject() wait for reply", error);
	return npobj->referenceCount;
  }

  return refcount;
}

static int do_recv_NPPrintData(rpc_message_t *message, void *p_value)
{
  NPPrintData *printData = (NPPrintData *)p_value;
  int error;

  if ((error = rpc_message_recv_uint32(message, &printData->size)) < 0)
	return error;
  if ((error = rpc_message_recv_bytes(message, printData->data, printData->size)) < 0)
	return error;

  return RPC_ERROR_NO_ERROR;
}

int main(void)
{
  char *str;
  int i, id;

  id_init();

#define N_CELLS_PER_SLOT 8
#define N_STRINGS ((2 * N_CELLS_PER_SLOT) + 3)
  char *strings[N_STRINGS];
  int ids[N_STRINGS];

  for (i = 0; i < N_STRINGS; i++) {
	str = malloc(10);
	sprintf(str, "%d", i);
	strings[i] = str;
	id = id_create(str);
	if (id < 0) {
	  fprintf(stderr, "ERROR: failed to allocate ID for '%s'\n", str);
	  return 1;
	}
	ids[i] = id;
  }

  id = ids[N_CELLS_PER_SLOT / 2];
  str = id_lookup(id);
  printf("str(%d) : '%s'\n", id, str);

  id = ids[N_CELLS_PER_SLOT];
  if (id_remove(id) < 0) {
	fprintf(stderr, "ERROR: failed to unlink ID %d\n", id);
	return 1;
  }
  ids[N_CELLS_PER_SLOT] = 0;

  for (i = 0; i < N_CELLS_PER_SLOT; i++) {
	id = ids[N_CELLS_PER_SLOT + i];
	if (id && id_remove(id) < 0) {
	  fprintf(stderr, "ERROR: failed to unlink ID %d from slot 1\n", id);
	  return 1;
	}
	ids[N_CELLS_PER_SLOT + i] = 0;
  }

  id = ids[2 * N_CELLS_PER_SLOT];
  str = id_lookup(id);
  printf("str(%d) : '%s'\n", id, str);

  for (i = 0; i < N_STRINGS; i++) {
	id = ids[i];
	if (id && id_remove(id) < 0) {
	  fprintf(stderr, "ERROR: failed to unlink ID %d for final cleanup\n", id);
	  return 1;
	}
  }

  for (i = 0; i < N_STRINGS; i++)
	free(strings[i]);

  id_kill();
  return 0;
}

cached_NPN_IntFromIdentifier(NPIdentifier identifier)
{
  int32_t value;
  if (!use_npidentifier_cache())
	value = invoke_NPN_IntFromIdentifier(identifier);
  else {
#if USE_NPIDENTIFIER_CACHE
	NPIdentifierInfo *npi = npidentifier_cache_lookup(identifier);
	if (npi) {
	  assert(npi->string_len == 0);
	  value = npi->u.value;
	}
	else {
	  value = invoke_NPN_IntFromIdentifier(identifier);
	  npidentifier_cache_reserve(1);
	  npidentifier_cache_add_int(identifier, value);
	}
#endif
  }
  return value;
}

static int handle_NPP_URLNotify(rpc_connection_t *connection)
{
  D(bug("handle_NPP_URLNotify\n"));

  int error;
  PluginInstance *plugin;
  char *url;
  int32_t reason;
  void *notifyData;

  error = rpc_method_get_args(connection,
							  RPC_TYPE_NPW_PLUGIN_INSTANCE, &plugin,
							  RPC_TYPE_STRING, &url,
							  RPC_TYPE_INT32, &reason,
							  RPC_TYPE_NP_NOTIFY_DATA, &notifyData,
							  RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPP_URLNotify() get args", error);
	return error;
  }

  g_NPP_URLNotify(PLUGIN_INSTANCE_NPP(plugin), url, reason, notifyData);

  if (url)
	free(url);

  return rpc_method_send_reply (connection, RPC_TYPE_INVALID);
}

static inline bool npidentifier_cache_find(NPIdentifierFindArgs *args, NPIdentifier *pident)
{
  args->ident = NULL;
#if defined(HAVE_G_HASH_TABLE_FIND) && !defined(BUILD_GENERIC)
  if (!g_hash_table_find(g_npidentifier_cache, npidentifier_cache_find_info, args))
	return false;
#else
  g_hash_table_foreach(g_npidentifier_cache, (GHFunc)npidentifier_cache_find_info, args);
  if (args->ident == NULL)
	return false;
#endif

  if (pident)
	*pident = args->ident;
  return true;
}

bool id_init(void)
{
  if (g_ids == NULL)
	g_ids = g_hash_table_new(NULL, NULL);
  return g_ids != NULL;
}

static bool is_thread_check_enabled_1(void)
{
  const char *thread_check_str;
  if ((thread_check_str =  getenv("NPW_THREAD_CHECK")) != NULL)
    return ((strcmp(thread_check_str, "yes") == 0) ||
			(strcmp(thread_check_str, "1") == 0));

  /* enable main-thread checks by default for all builds from snapshots */
  return NPW_SNAPSHOT > 0;
}

static int do_send_XGraphicsExposeEvent(rpc_message_t *message, XEvent *xevent)
{
  int error;
  if ((error = do_send_XAnyEvent(message, xevent)) < 0)
	return error;
  if ((error = rpc_message_send_int32(message, xevent->xgraphicsexpose.x)) < 0)
	return error;
  if ((error = rpc_message_send_int32(message, xevent->xgraphicsexpose.y)) < 0)
	return error;
  if ((error = rpc_message_send_uint32(message, xevent->xgraphicsexpose.width)) < 0)
	return error;
  if ((error = rpc_message_send_uint32(message, xevent->xgraphicsexpose.height)) < 0)
	return error;
  return RPC_ERROR_NO_ERROR;
}

static int handle_NP_GetMIMEDescription(rpc_connection_t *connection)
{
  D(bug("handle_NP_GetMIMEDescription\n"));

  int error = rpc_method_get_args(connection, RPC_TYPE_INVALID);
  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NP_GetMIMEDescription() get args", error);
	return error;
  }

  char *str = g_NP_GetMIMEDescription();
  return rpc_method_send_reply(connection, RPC_TYPE_STRING, str, RPC_TYPE_INVALID);
}

static int do_recv_NPFullPrint(rpc_message_t *message, void *p_value)
{
  NPFullPrint *fullPrint = (NPFullPrint *)p_value;
  uint32_t pluginPrinted, printOne;
  int error;

  if ((error = rpc_message_recv_uint32(message, &pluginPrinted)) < 0)
	return error;
  if ((error = rpc_message_recv_uint32(message, &printOne)) < 0)
	return error;

  fullPrint->pluginPrinted = pluginPrinted;
  fullPrint->printOne = printOne;
  fullPrint->platformPrint = NULL; // to be filled in by the plugin
  return RPC_ERROR_NO_ERROR;
}

bool thread_check(void)
{
#ifdef ENABLE_THREAD_CHECK
  if (is_thread_check_enabled())
	return (g_main_thread == pthread_self());
#endif
  return true;
}

invoke_NPN_InvokeDefault(PluginInstance *plugin, NPObject *npobj,
						 const NPVariant *args, uint32_t argCount, NPVariant *result)
{
  npw_return_val_if_fail(rpc_method_invoke_possible(g_rpc_connection), false);

  int error = rpc_method_invoke(g_rpc_connection,
								RPC_METHOD_NPN_INVOKE_DEFAULT,
								RPC_TYPE_NPW_PLUGIN_INSTANCE, plugin,
								RPC_TYPE_NP_OBJECT, npobj,
								RPC_TYPE_ARRAY, RPC_TYPE_NP_VARIANT, argCount, args,
								RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPN_InvokeDefault() invoke", error);
	return false;
  }

  uint32_t ret;
  error = rpc_method_wait_for_reply(g_rpc_connection,
									RPC_TYPE_UINT32, &ret,
									RPC_TYPE_NP_VARIANT, result,
									RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPN_InvokeDefault() wait for reply", error);
	return false;
  }

  return ret;
}

static int xt_source_create(void)
{
  if (++xt_source_count > 1 && xt_source != NULL)
	return 0;

  if ((xt_source = g_source_new(&xt_event_funcs, sizeof(GSource))) == NULL) {
	npw_printf("ERROR: failed to initialize Xt events listener\n");
	return -1;
  }
  g_source_set_priority(xt_source, GDK_PRIORITY_EVENTS);
  g_source_set_can_recurse(xt_source, TRUE);
  g_source_attach(xt_source, NULL);
  xt_event_poll_fd.fd = ConnectionNumber(x_display);
  xt_event_poll_fd.events = G_IO_IN;
  xt_event_poll_fd.revents = 0;
  g_source_add_poll(xt_source, &xt_event_poll_fd);
  return 0;
}

g_NPP_Print(NPP instance, NPPrint *printInfo)
{
  if (plugin_funcs.print == NULL)
	return;

  if (printInfo == NULL)
	return;

  D(bugiI("NPP_Print instance=%p, printInfo->mode=%d\n", instance, printInfo->mode));
  plugin_funcs.print(instance, printInfo);
  D(bugiD("NPP_Print done\n"));
}

static int do_recv_NPWindow(rpc_message_t *message, void *p_value)
{
  NPWindow **window_p = (NPWindow **)p_value;
  NPWindow *window;
  uint32_t window_valid;
  int error;

  if (window_p)
	*window_p = NULL;
  if ((error = rpc_message_recv_uint32(message, &window_valid)) < 0)
	return error;
  if (window_valid) {
	if ((window = malloc(sizeof(NPWindow))) == NULL)
	  return RPC_ERROR_NO_MEMORY;
	if ((error = do_recv_NPWindowData(message, window)) < 0) {
	  free(window);
	  return error;
	}
	if (window_p)
	  *window_p = window;
  }

  return RPC_ERROR_NO_ERROR;
}

static int do_recv_NPVariant(rpc_message_t *message, void *p_value)
{
  NPVariant *variant = (NPVariant *)p_value;
  if (variant)
	VOID_TO_NPVARIANT(*variant);

  uint32_t type;
  int error = rpc_message_recv_uint32(message, &type);
  if (error < 0)
	return error;

  NPVariant result;
  VOID_TO_NPVARIANT(result);
  switch (type) {
  case NPVariantType_Void:
	VOID_TO_NPVARIANT(result);
	break;
  case NPVariantType_Null:
	NULL_TO_NPVARIANT(result);
	break;
  case NPVariantType_Bool: {
	uint32_t value;
	if ((error = rpc_message_recv_uint32(message, &value)) < 0)
	  return error;
	result.value.boolValue = value;
	break;
  }
  case NPVariantType_Int32:
	if ((error = rpc_message_recv_int32(message, &result.value.intValue)) < 0)
	  return error;
	break;
  case NPVariantType_Double:
	if ((error = rpc_message_recv_double(message, &result.value.doubleValue)) < 0)
	  return error;
	break;
  case NPVariantType_String:
	if ((error = do_recv_NPString(message, &result.value.stringValue)) < 0)
	  return error;
	break;
  case NPVariantType_Object:
	if ((error = do_recv_NPObject(message, &result.value.objectValue)) < 0)
	  return error;
	if (NPW_IS_BROWSER) {
	  /* Note: it's not necessary to propagate the refcount back to
		 the plugin-side since the object will be unref'ed through
		 NPN_ReleaseVariantValue() once we are done with processing
		 the RPC args. */
	  NPN_RetainObject(result.value.objectValue);
	}
	break;
  }

  if (variant) {
	*variant = result;
	variant->type = type;
  }
  
  return RPC_ERROR_NO_ERROR;
}

static int update_window(PluginInstance *plugin, NPWindow *window)
{
  if (plugin->is_windowless) {
	npw_printf("ERROR: update_window() called for windowless plugin\n");
	return -1;
  }

  if (window->ws_info == NULL) {
	npw_printf("ERROR: no window attributes for window %p\n", window->window);
	return -1;
  }

  NPSetWindowCallbackStruct *ws_info = plugin->window.ws_info;
  memcpy(ws_info, window->ws_info, sizeof(*ws_info));
  create_window_attributes(ws_info);

  memcpy(&plugin->window.clipRect, &window->clipRect, sizeof(window->clipRect));;

  if (plugin->window.x != window->x || plugin->window.y != window->y) {
	plugin->window.x = window->x;
	plugin->window.y = window->y;
  }

  if (plugin->window.width != window->width || plugin->window.height != window->height) {
	plugin->window.width = window->width;
	plugin->window.height = window->height;
	if (plugin->toolkit_data) {
	  if (plugin->use_xembed) {
	  }
	  else {
		XtData *toolkit = (XtData *)plugin->toolkit_data;
		if (toolkit->form)
		  XtResizeWidget(toolkit->form, plugin->window.width, plugin->window.height, 0);
		if (toolkit->top_widget)
		  XtResizeWidget(toolkit->top_widget, plugin->window.width, plugin->window.height, 0);
	  }
	}
  }
  return 0;
}

static void fixup_size_hints(PluginInstance *plugin)
{
  NPWindow *window = &plugin->window;

  if (window->width == 0 || window->height == 0) {
	if (plugin->width && plugin->height) {
	  window->width = plugin->width;
	  window->height = plugin->height;
	  return;
	}
  }

  if (window->window && (window->width == 0 || window->height == 0)) {
	XWindowAttributes win_attr;
	if (XGetWindowAttributes(x_display, (Window)window->window, &win_attr)) {
	  plugin->width = window->width = win_attr.width;
	  plugin->height = window->height = win_attr.height;
	  return;
	}
  }

  if (window->width == 0 || window->height == 0)
	npw_printf("WARNING: grmpf, despite much effort, I could not determine the actual plugin area size...\n");
}

invoke_NPN_GetProperty(PluginInstance *plugin, NPObject *npobj, NPIdentifier propertyName,
					   NPVariant *result)
{
  npw_return_val_if_fail(rpc_method_invoke_possible(g_rpc_connection), false);

  int error = rpc_method_invoke(g_rpc_connection,
								RPC_METHOD_NPN_GET_PROPERTY,
								RPC_TYPE_NPW_PLUGIN_INSTANCE, plugin,
								RPC_TYPE_NP_OBJECT, npobj,
								RPC_TYPE_NP_IDENTIFIER, &propertyName,
								RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPN_GetProperty() invoke", error);
	return false;
  }

  uint32_t ret;
  error = rpc_method_wait_for_reply(g_rpc_connection,
									RPC_TYPE_UINT32, &ret,
									RPC_TYPE_NP_VARIANT, result,
									RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPN_GetProperty() wait for reply", error);
	return false;
  }

  return ret;
}

g_NPN_MemAlloc(uint32_t size)
{
  D(bugiI("NPN_MemAlloc size=%d\n", size));

  void *ptr = NPW_MemAlloc(size);
  D(bugiD("NPN_MemAlloc return: %p\n", ptr));
  return ptr;
}

const char *string_of_NPEvent_type(int type)
{
  const char *str;

  switch (type) {
#define _(VAL) case VAL: str = #VAL; break;
#ifdef MOZ_X11
    _(KeyPress);
    _(KeyRelease);
    _(ButtonPress);
    _(ButtonRelease);
    _(MotionNotify);
    _(EnterNotify);
    _(LeaveNotify);
    _(FocusIn);
    _(FocusOut);
    _(KeymapNotify);
    _(Expose);
    _(GraphicsExpose);
    _(NoExpose);
    _(VisibilityNotify);
    _(CreateNotify);
    _(DestroyNotify);
    _(UnmapNotify);
    _(MapNotify);
    _(MapRequest);
    _(ReparentNotify);
    _(ConfigureNotify);
    _(ConfigureRequest);
    _(GravityNotify);
    _(ResizeRequest);
    _(CirculateNotify);
    _(CirculateRequest);
    _(PropertyNotify);
    _(SelectionClear);
    _(SelectionRequest);
    _(SelectionNotify);
    _(ColormapNotify);
    _(ClientMessage);
    _(MappingNotify);
#endif
#undef _
  default:
	str = "<unknown type>";
	break;
  }

  return str;
}

g_NPN_NewStream(NPP instance, NPMIMEType type, const char *target, NPStream **stream)
{
  if (!thread_check()) {
	npw_printf("WARNING: NPN_NewStream not called from the main thread\n");
	return NPERR_INVALID_INSTANCE_ERROR;
  }

  if (instance == NULL)
	return NPERR_INVALID_INSTANCE_ERROR;

  PluginInstance *plugin = PLUGIN_INSTANCE(instance);
  if (plugin == NULL)
	return NPERR_INVALID_INSTANCE_ERROR;

  if (stream == NULL)
	return NPERR_INVALID_PARAM;
  *stream = NULL;

  D(bugiI("NPN_NewStream instance=%p\n", instance));
  npw_plugin_instance_ref(plugin);
  NPError ret = invoke_NPN_NewStream(plugin, type, target, stream);
  npw_plugin_instance_unref(plugin);
  D(bugiD("NPN_NewStream return: %d [%s]\n", ret, string_of_NPError(ret)));
  return ret;
}

g_NPN_SetException(NPObject *npobj, const NPUTF8 *message)
{
  if (!thread_check()) {
	npw_printf("WARNING: NPN_SetException not called from the main thread\n");
	return;
  }

  D(bugiI("NPN_SetException npobj=%p, message='%s'\n", npobj, message));
  invoke_NPN_SetException(npobj, message);
  D(bugiD("NPN_SetException done\n"));
}

static NPError g_NPP_New(NPMIMEType plugin_type, uint32_t instance_id,
						 uint16_t mode, int16_t argc, char *argn[], char *argv[],
						 NPSavedData *saved)
{
  PluginInstance *plugin = npw_plugin_instance_new(&PluginInstanceClass);
  if (plugin == NULL)
	return NPERR_OUT_OF_MEMORY_ERROR;
  plugin->instance_id = instance_id;
  id_link(instance_id, plugin);

  NPP instance = malloc(sizeof(*instance));
  if (instance == NULL)
	return NPERR_OUT_OF_MEMORY_ERROR;
  memset(instance, 0, sizeof(*instance));
  instance->ndata = plugin;
  plugin->instance = instance;

  for (int i = 0; i < argc; i++) {
	if (argn[i] == NULL)
	  continue;
	if (strcasecmp(argn[i], "width") == 0) {
	  if (i < argc && argv[i])
		plugin->width = atoi(argv[i]);
	}
	else if (strcasecmp(argn[i], "height") == 0) {
	  if (i < argc && argv[i])
		plugin->height = atoi(argv[i]);
	}
  }

  D(bugiI("NPP_New instance=%p\n", instance));
  NPError ret = plugin_funcs.newp(plugin_type, instance, mode, argc, argn, argv, saved);
  D(bugiD("NPP_New return: %d [%s]\n", ret, string_of_NPError(ret)));

  long supports_XEmbed = FALSE;
  if (mozilla_funcs.getvalue) {
	NPError error = mozilla_funcs.getvalue(NULL, NPNVSupportsXEmbedBool, (void *)&supports_XEmbed);
	if (error == NPERR_NO_ERROR && plugin_funcs.getvalue) {
	  long needs_XEmbed = FALSE;
	  error = plugin_funcs.getvalue(instance, NPPVpluginNeedsXEmbed, (void *)&needs_XEmbed);
	  if (error == NPERR_NO_ERROR)
		plugin->use_xembed = supports_XEmbed && needs_XEmbed;
	}
  }

  if (!plugin->use_xembed) {
	if (xt_source_create() < 0)
	  return NPERR_GENERIC_ERROR;
  }

  return ret;
}

static int handle_NPP_Destroy(rpc_connection_t *connection)
{
  D(bug("handle_NPP_Destroy\n"));

  int error;
  PluginInstance *plugin;
  error = rpc_method_get_args(connection,
							  RPC_TYPE_NPW_PLUGIN_INSTANCE, &plugin,
							  RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPP_Destroy() get args", error);
	return error;
  }

  NPSavedData *save_area = NULL;
  NPError ret = NPERR_NO_ERROR;
  /* Take a ref for the rpc_method_send_reply; otherwise the
   * rpc_connection_unref in g_NPP_Destroy_Now may cause a slight
   * nuisance. */
  rpc_connection_ref(connection);
  if (!rpc_method_in_invoke(connection)) {
	/* The plugin is not on the stack; it's safe to call this. */
	D(bug("NPP_Destroy is fine.\n"));
	ret = g_NPP_Destroy_Now(plugin, &save_area);
  } else {
	/* It is not safe to call NPP_Destroy right now. Delay it until we
	 * return to the event loop.
	 *
	 * NOTE: This means that the browser never sees the real return
	 * value of NPP_Destroy; the NPSavedData will be discarded, and any
	 * error code will be ignored. */
    D(bug("NPP_Destroy raced; delaying it to get a clean stack.\n"));
	delayed_destroys_add(plugin);
  }

  error = rpc_method_send_reply(connection,
								RPC_TYPE_INT32, ret,
								RPC_TYPE_NP_SAVED_DATA, save_area,
								RPC_TYPE_INVALID);
  if (save_area) {
    if (save_area->buf)
      NPN_MemFree(save_area->buf);
    NPN_MemFree(save_area);
  }

  rpc_connection_unref(connection);
  return error;
}

static int do_recv_NPW_PluginInstance(rpc_message_t *message, void *p_value)
{
  int error;
  uint32_t instance_id;

  if ((error = rpc_message_recv_uint32(message, &instance_id)) < 0)
	return error;

  NPW_PluginInstance *plugin = id_lookup(instance_id);
  if (instance_id && plugin == NULL)
	npw_printf("ERROR: no valid NPP -> PluginInstance mapping found\n");
  else if (plugin && plugin->instance == NULL)
	npw_printf("ERROR: no valid PluginInstance -> NPP mapping found\n");
  else if (plugin && !npw_plugin_instance_is_valid(plugin))
	npw_printf("ERROR: received PluginInstance was invalidated earlier\n");
  *((NPW_PluginInstance **)p_value) = plugin;
  return RPC_ERROR_NO_ERROR;
}

static int do_send_NPVariant(rpc_message_t *message, void *p_value)
{
  NPVariant *variant = (NPVariant *)p_value;
  if (variant == NULL)
	return RPC_ERROR_MESSAGE_ARGUMENT_INVALID;

  int error = rpc_message_send_uint32(message, variant->type);
  if (error < 0)
	return error;

  switch (variant->type) {
  case NPVariantType_Void:
  case NPVariantType_Null:
	break;
  case NPVariantType_Bool:
	if ((error = rpc_message_send_uint32(message, variant->value.boolValue)) < 0)
	  return error;
	break;
  case NPVariantType_Int32:
	if ((error = rpc_message_send_int32(message, variant->value.intValue)) < 0)
	  return error;
	break;
  case NPVariantType_Double:
	if ((error = rpc_message_send_double(message, variant->value.doubleValue)) < 0)
	  return error;
	break;
  case NPVariantType_String:
	if ((error = do_send_NPString(message, &variant->value.stringValue)) < 0)
	  return error;
	break;
  case NPVariantType_Object:
	if (NPW_IS_BROWSER) {
	  /* Note: when we pass an NPObject to the plugin, it's supposed
		 to be released once it's done with processing the RPC args.
		 i.e. NPN_ReleaseVariantValue() is called for any NPVariant we
		 received through rpc_method_get_args(). */
	  NPN_RetainObject(variant->value.objectValue);
	}
	if ((error = do_send_NPObject(message, variant->value.objectValue)) < 0)
	  return error;
	break;
  }

  return RPC_ERROR_NO_ERROR;
}

static int get_appcontext_input_count(void)
{
  static int input_count_offset = -1;
  if (input_count_offset < 0)
	input_count_offset = get_appcontext_input_count_offset();
  if (input_count_offset == 0)
	return 1; /* fake we have input to trigger timeout */
  return get_appcontext_input_count_at(input_count_offset);
}

static int error_handler(Display *display, XErrorEvent *error)
{
  trapped_error_code = error->error_code;
  return 0;
}

static void *plugin_instance_allocate(void)
{
  return NPW_MemNew0(PluginInstance, 1);
}

static int do_recv_XCrossingEvent(rpc_message_t *message, XEvent *xevent)
{
  int32_t x, y, x_root, y_root, mode, detail, same_screen, focus;
  uint32_t root, subwindow, time, state;
  int error;
  if ((error = do_recv_XAnyEvent(message, xevent)) < 0)
	return error;
  if ((error = rpc_message_recv_uint32(message, &root)) < 0)
	return error;
  if ((error = rpc_message_recv_uint32(message, &subwindow)) < 0)
	return error;
  if ((error = rpc_message_recv_uint32(message, &time)) < 0)
	return error;
  if ((error = rpc_message_recv_int32(message, &x)) < 0)
	return error;
  if ((error = rpc_message_recv_int32(message, &y)) < 0)
	return error;
  if ((error = rpc_message_recv_int32(message, &x_root)) < 0)
	return error;
  if ((error = rpc_message_recv_int32(message, &y_root)) < 0)
	return error;
  if ((error = rpc_message_recv_int32(message, &mode)) < 0)
	return error;
  if ((error = rpc_message_recv_int32(message, &detail)) < 0)
	return error;
  if ((error = rpc_message_recv_int32(message, &same_screen)) < 0)
	return error;
  if ((error = rpc_message_recv_int32(message, &focus)) < 0)
	return error;
  if ((error = rpc_message_recv_uint32(message, &state)) < 0)
	return error;
  xevent->xcrossing.root = root;
  xevent->xcrossing.subwindow = subwindow;
  xevent->xcrossing.time = time;
  xevent->xcrossing.x = x;
  xevent->xcrossing.y = y;
  xevent->xcrossing.x_root = x_root;
  xevent->xcrossing.y_root = y_root;
  xevent->xcrossing.mode = mode;
  xevent->xcrossing.detail = detail;
  xevent->xcrossing.same_screen = same_screen;
  xevent->xcrossing.focus = focus;
  xevent->xcrossing.state = state;
  return RPC_ERROR_NO_ERROR;
}

g_NPN_IntFromIdentifier(NPIdentifier identifier)
{
  if (!thread_check()) {
	npw_printf("WARNING: NPN_IntFromIdentifier not called from the main thread\n");
	return 0;
  }
  
  D(bugiI("NPN_IntFromIdentifier identifier=%p\n", identifier));
  int32_t ret = cached_NPN_IntFromIdentifier(identifier);
  D(bugiD("NPN_IntFromIdentifier return: %d\n", ret));
  return ret;
}

invoke_NPN_Write(PluginInstance *plugin, NPStream *stream, int32_t len, void *buf)
{
  npw_return_val_if_fail(rpc_method_invoke_possible(g_rpc_connection), -1);

  int error = rpc_method_invoke(g_rpc_connection,
								RPC_METHOD_NPN_WRITE,
								RPC_TYPE_NPW_PLUGIN_INSTANCE, plugin,
								RPC_TYPE_NP_STREAM, stream,
								RPC_TYPE_ARRAY, RPC_TYPE_CHAR, len, buf,
								RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPN_Write() invoke", error);
	return -1;
  }

  int32_t ret;
  error = rpc_method_wait_for_reply(g_rpc_connection,
									RPC_TYPE_INT32, &ret,
									RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPN_Write() wait for reply", error);
	return -1;
  }

  return ret;
}

int rpc_type_of_NPNVariable(int variable)
{
  int type;
  switch (variable) {
  case NPNVjavascriptEnabledBool:
  case NPNVasdEnabledBool:
   case NPNVisOfflineBool:
   case NPNVSupportsXEmbedBool:
   case NPNVSupportsWindowless:
 	type = RPC_TYPE_BOOLEAN;
 	break;
   case NPNVToolkit:
  case NPNVnetscapeWindow:
	type = RPC_TYPE_UINT32;
	break;
  case NPNVWindowNPObject:
  case NPNVPluginElementNPObject:
	type = RPC_TYPE_NP_OBJECT;
	break;
  default:
	type = RPC_ERROR_GENERIC;
	break;
  }
  return type;
}

g_NPN_ReloadPlugins(NPBool reloadPages)
{
  D(bug("NPN_ReloadPlugins reloadPages=%d\n", reloadPages));

  NPW_UNIMPLEMENTED();
}

g_NPN_SetProperty(NPP instance, NPObject *npobj, NPIdentifier propertyName,
				  const NPVariant *value)
{
  if (!thread_check()) {
	npw_printf("WARNING: NPN_SetProperty not called from the main thread\n");
	return false;
  }

  if (instance == NULL)
	return false;

  PluginInstance *plugin = PLUGIN_INSTANCE(instance);
  if (plugin == NULL)
	return false;

  if (!npobj || !npobj->_class || !npobj->_class->setProperty)
	return false;

  D(bugiI("NPN_SetProperty instance=%p, npobj=%p, propertyName=%p\n", instance, npobj, propertyName));
  npw_plugin_instance_ref(plugin);
  bool ret = invoke_NPN_SetProperty(plugin, npobj, propertyName, value);
  npw_plugin_instance_unref(plugin);
  D(bugiD("NPN_SetProperty return: %d\n", ret));
  return ret;
}

g_NPN_GetValue(NPP instance, NPNVariable variable, void *value)
{
  D(bug("NPN_GetValue instance=%p, variable=%d [%s]\n", instance, variable, string_of_NPNVariable(variable)));

  if (!thread_check()) {
	npw_printf("WARNING: NPN_GetValue not called from the main thread\n");
	return NPERR_INVALID_INSTANCE_ERROR;
  }

  PluginInstance *plugin = NULL;
  if (instance)
	plugin = PLUGIN_INSTANCE(instance);

  switch (variable) {
  case NPNVxDisplay:
	*(void **)value = x_display;
	break;
  case NPNVxtAppContext:
	*(void **)value = XtDisplayToApplicationContext(x_display);
	break;
  case NPNVToolkit:
	*(NPNToolkitType *)value = NPW_TOOLKIT;
	break;
#if USE_XPCOM
  case NPNVserviceManager: {
	nsIServiceManager *sm;
	int ret = NS_GetServiceManager(&sm);
	if (NS_FAILED(ret)) {
	  npw_printf("WARNING: NS_GetServiceManager failed\n");
	  return NPERR_GENERIC_ERROR;
	}
	*(nsIServiceManager **)value = sm;
	break;
  }
  case NPNVDOMWindow:
  case NPNVDOMElement:
	npw_printf("WARNING: %s is not supported by NPN_GetValue()\n", string_of_NPNVariable(variable));
	return NPERR_INVALID_PARAM;
#endif
  case NPNVnetscapeWindow:
	if (plugin == NULL) {
	  npw_printf("ERROR: NPNVnetscapeWindow requires a non NULL instance\n");
	  return NPERR_INVALID_INSTANCE_ERROR;
	}
	if (plugin->browser_toplevel == NULL) {
	  GdkNativeWindow netscape_xid = None;
	  NPError error = g_NPN_GetValue_real(instance, variable, &netscape_xid);
	  if (error != NPERR_NO_ERROR)
		return error;
	  if (netscape_xid == None)
		return NPERR_GENERIC_ERROR;
	  plugin->browser_toplevel = gdk_window_foreign_new(netscape_xid);
	  if (plugin->browser_toplevel == NULL)
		return NPERR_GENERIC_ERROR;
	}
	*((GdkNativeWindow *)value) = GDK_WINDOW_XWINDOW(plugin->browser_toplevel);
	break;
#if ALLOW_WINDOWLESS_PLUGINS
  case NPNVSupportsWindowless:
#endif
   case NPNVSupportsXEmbedBool:
   case NPNVWindowNPObject:
   case NPNVPluginElementNPObject:
 	return g_NPN_GetValue_real(instance, variable, value);
   default:
 	switch (variable & 0xff) {
	case 13: /* NPNVToolkit */
	  if (NPW_TOOLKIT == NPNVGtk2) {
		*(NPNToolkitType *)value = NPW_TOOLKIT;
		return NPERR_NO_ERROR;
	  }
	  break;
	}
	D(bug("WARNING: unhandled variable %d (%s) in NPN_GetValue()\n", variable, string_of_NPNVariable(variable)));
	return NPERR_INVALID_PARAM;
  }

  return NPERR_NO_ERROR;
}

static int handle_NPP_HandleEvent(rpc_connection_t *connection)
{
  D(bug("handle_NPP_HandleEvent\n"));

  PluginInstance *plugin;
  NPEvent event;
  int error = rpc_method_get_args(connection,
								  RPC_TYPE_NPW_PLUGIN_INSTANCE, &plugin,
								  RPC_TYPE_NP_EVENT, &event,
								  RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPP_HandleEvent() get args", error);
	return error;
  }

  event.xany.display = x_display;
  int16_t ret = g_NPP_HandleEvent(PLUGIN_INSTANCE_NPP(plugin), &event);

  return rpc_method_send_reply(connection, RPC_TYPE_INT32, ret, RPC_TYPE_INVALID);
}

int main(int argc, char **argv)
{
  const char *plugin_path = NULL;
  const char *connection_path = NULL;

  enum {
	CMD_RUN,
	CMD_TEST,
	CMD_INFO,
	CMD_HELP
  };
  int cmd = CMD_RUN;

  for (int i = 0; i < argc; i++) {
	const char *arg = argv[i];
	if (strcmp(arg, "-h") == 0 || strcmp(arg, "--help") == 0) {
	  argv[i] = NULL;
	  cmd = CMD_HELP;
	}
	else if (strcmp(arg, "-t") == 0 || strcmp(arg, "--test") == 0) {
	  argv[i] = NULL;
	  cmd = CMD_TEST;
	}
	else if (strcmp(arg, "-i") == 0 || strcmp(arg, "--info") == 0) {
	  argv[i] = NULL;
	  cmd = CMD_INFO;
	}
	else if (strcmp(arg, "-p") == 0 || strcmp(arg, "--plugin") == 0) {
	  argv[i] = NULL;
	  if (++i < argc) {
		plugin_path = argv[i];
		argv[i] = NULL;
	  }
	}
	else if (strcmp(arg, "-c") == 0 || strcmp(arg, "--connection") == 0) {
	  argv[i] = NULL;
	  if (++i < argc) {
		connection_path = argv[i];
		argv[i] = NULL;
	  }
	}
  }

  for (int i = 1, j = 1, n = argc; i < n; i++) {
	if (argv[i])
	  argv[j++] = argv[i];
	else
	  --argc;
  }

  void *handles[10] = { NULL, };
  int n_handles = 0;
  if (plugin_path == NULL)
	cmd = CMD_HELP;
  else {
	void *handle;
	const char *error;
#if defined(__sun)
	/* XXX: check for Flash Player only? */
	const char SunStudio_libCrun[] = "libCrun.so.1";
	D(bug("  trying to open SunStudio C++ runtime '%s'\n", SunStudio_libCrun));
	if ((handle = dlopen(SunStudio_libCrun, RTLD_LAZY|RTLD_GLOBAL)) == NULL) {
	  npw_printf("ERROR: %s\n", dlerror());
	  return 1;
	}
	handles[n_handles++] = handle;
	dlerror();
#endif
	D(bug("  %s\n", plugin_path));
	if ((handle = dlopen(plugin_path, RTLD_LAZY)) == NULL) {
	  npw_printf("ERROR: %s\n", dlerror());
	  return 1;
	}
	handles[n_handles++] = handle;
	dlerror();
	g_plugin_NP_GetMIMEDescription = (NP_GetMIMEDescriptionUPP)dlsym(handle, "NP_GetMIMEDescription");
	if ((error = dlerror()) != NULL) {
	  npw_printf("ERROR: %s\n", error);
	  return 1;
	}
	g_plugin_NP_Initialize = (NP_InitializeUPP)dlsym(handle, "NP_Initialize");
	if ((error = dlerror()) != NULL) {
	  npw_printf("ERROR: %s\n", error);
	  return 1;
	}
	g_plugin_NP_Shutdown = (NP_ShutdownUPP)dlsym(handle, "NP_Shutdown");
	if ((error = dlerror()) != NULL) {
	  npw_printf("ERROR: %s\n", error);
	  return 1;
	}
	g_plugin_NP_GetValue = (NP_GetValueUPP)dlsym(handle, "NP_GetValue");
  }

  int ret = 1;
  switch (cmd) {
  case CMD_RUN:
	ret = do_main(argc, argv, connection_path);
	break;
  case CMD_TEST:
	ret = do_test();
	break;
  case CMD_INFO:
	ret = do_info();
	break;
  case CMD_HELP:
	ret = do_help(argv[0]);
	break;
  }

  while (--n_handles >= 0) {
	void * const handle = handles[n_handles];
	if (handle)
	  dlclose(handle);
  }
  return ret;
}

g_NPN_RemoveProperty(NPP instance, NPObject *npobj, NPIdentifier propertyName)
{
  if (!thread_check()) {
	npw_printf("WARNING: NPN_RemoveProperty not called from the main thread\n");
	return false;
  }

  if (instance == NULL)
	return false;

  PluginInstance *plugin = PLUGIN_INSTANCE(instance);
  if (plugin == NULL)
	return false;

  if (!npobj || !npobj->_class || !npobj->_class->removeProperty)
	return false;

  D(bugiI("NPN_RemoveProperty instance=%p, npobj=%p, propertyName=%p\n", instance, npobj, propertyName));
  npw_plugin_instance_ref(plugin);
  bool ret = invoke_NPN_RemoveProperty(plugin, npobj, propertyName);
  npw_plugin_instance_unref(plugin);
  D(bugiD("NPN_RemoveProperty return: %d\n", ret));
  return ret;
}

g_NPN_GetURLNotify(NPP instance, const char *url, const char *target, void *notifyData)
{
  if (!thread_check()) {
	npw_printf("WARNING: NPN_GetURLNotify not called from the main thread\n");
	return NPERR_INVALID_INSTANCE_ERROR;
  }
	
  if (instance == NULL)
	return NPERR_INVALID_INSTANCE_ERROR;

  PluginInstance *plugin = PLUGIN_INSTANCE(instance);
  if (plugin == NULL)
	return NPERR_INVALID_INSTANCE_ERROR;

  D(bugiI("NPN_GetURLNotify instance=%p\n", instance));
  npw_plugin_instance_ref(plugin);
  NPError ret = invoke_NPN_GetURLNotify(plugin, url, target, notifyData);
  npw_plugin_instance_unref(plugin);
  D(bugiD("NPN_GetURLNotify return: %d [%s]\n", ret, string_of_NPError(ret)));
  return ret;
}

static int do_recv_XFocusChangeEvent(rpc_message_t *message, XEvent *xevent)
{
  return RPC_ERROR_NO_ERROR;
}

g_NPN_ReleaseObject_Delayed(NPObject *npobj)
{
  delayed_calls_add(RPC_DELAYED_NPN_RELEASE_OBJECT, npobj);
}

cached_NPN_GetIntIdentifier(int32_t intid)
{
  NPIdentifier ident;
  if (!use_npidentifier_cache())
	ident = invoke_NPN_GetIntIdentifier(intid);
#if USE_NPIDENTIFIER_CACHE
  else if (!npidentifier_cache_has_int(intid, &ident)) {
	ident = invoke_NPN_GetIntIdentifier(intid);
	npidentifier_cache_reserve(1);
	npidentifier_cache_add_int(ident, intid);
  }
#endif
  return ident;
}

static int xt_get_next_timeout(GSource *source)
{
  static int has_compatible_appcontext = -1;
  if (has_compatible_appcontext < 0) {
	if ((has_compatible_appcontext = xt_has_compatible_appcontext()) == 0)
	  npw_printf("WARNING: xt_get_next_timeout() is not optimizable\n");
  }
  int timeout = XT_DEFAULT_TIMEOUT;
  if (has_compatible_appcontext) {
	int input_timeout, timer_timeout;
	/* Check there is any input source to process */
	if (get_appcontext_input_count() > 0)
	  input_timeout = XT_DEFAULT_TIMEOUT;
	else
	  input_timeout = -1;
	/* Check there is any timer to process */
	if (x_app_context->timerQueue == NULL)
	  timer_timeout = -1;
	else {
	  /* Determine delay to next timeout. Zero means timeout already expired */
	  struct timeval *next = &x_app_context->timerQueue->te_timer_value;
	  GTimeVal now;
	  int64_t diff;
	  g_source_get_current_time(source, &now);
	  if ((diff = (int64_t)next->tv_sec - (int64_t)now.tv_sec) < 0)
		timer_timeout = 0;
	  else if ((diff = diff*1000 + ((int64_t)next->tv_usec - (int64_t)now.tv_usec)/1000) <= 0)
		timer_timeout = 0;
	  else
		timer_timeout = diff;
	}
	if (input_timeout < 0)
	  timeout = timer_timeout;
	else if (timer_timeout < 0)
	  timeout = input_timeout;
	else
	  timeout = MIN(input_timeout, timer_timeout);
  }
  return timeout;
}

static gboolean xt_event_check(GSource *source)
{
  if (xt_event_poll_fd.revents & G_IO_IN) {
	int mask = XtAppPending(x_app_context);
	if (mask)
	  return TRUE;
  }
  return FALSE;
}

invoke_NPN_PopPopupsEnabledState(PluginInstance *plugin)
{
  npw_return_if_fail(rpc_method_invoke_possible(g_rpc_connection));

  int error = rpc_method_invoke(g_rpc_connection,
								RPC_METHOD_NPN_POP_POPUPS_ENABLED_STATE,
								RPC_TYPE_NPW_PLUGIN_INSTANCE, plugin,
								RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPN_PopPopupsEnabledState() invoke", error);
	return;
  }

  error = rpc_method_wait_for_reply(g_rpc_connection, RPC_TYPE_INVALID);
  
  if (error != RPC_ERROR_NO_ERROR)
	npw_perror("NPN_PopPopupsEnabledState() wait for reply", error);
}

static inline bool npidentifier_cache_has_int(int32_t value, NPIdentifier *pident)
{
  if (G_UNLIKELY(g_npidentifier_cache == NULL))
	return false;

  NPIdentifierFindArgs args;
  args.info.string_len = 0;
  args.info.u.value = value;
  return npidentifier_cache_find(&args, pident);
}

g_NPN_DestroyStream(NPP instance, NPStream *stream, NPError reason)
{
  if (!thread_check()) {
	npw_printf("WARNING: NPN_DestroyStream not called from the main thread\n");
	return NPERR_INVALID_INSTANCE_ERROR;
  }
  
  if (instance == NULL)
	return NPERR_INVALID_INSTANCE_ERROR;

  PluginInstance *plugin = PLUGIN_INSTANCE(instance);
  if (plugin == NULL)
	return NPERR_INVALID_INSTANCE_ERROR;

  if (stream == NULL)
	return NPERR_INVALID_PARAM;

  D(bugiI("NPN_DestroyStream instance=%p, stream=%p, reason=%s\n",
		instance, stream, string_of_NPReason(reason)));
  npw_plugin_instance_ref(plugin);
  NPError ret = invoke_NPN_DestroyStream(plugin, stream, reason);
  npw_plugin_instance_unref(plugin);
  D(bugiD("NPN_DestroyStream return: %d [%s]\n", ret, string_of_NPError(ret)));

  StreamInstance *stream_ndata = stream->ndata;
  if (stream_ndata && stream_ndata->is_plugin_stream) {
	id_remove(stream_ndata->stream_id);
	free(stream_ndata);
	free((char *)stream->url);
	free((char *)stream->headers);
	free(stream);
  }

  return ret;
}

int rpc_type_of_NPPVariable(int variable)
{
  int type;
  switch (variable) {
   case NPPVpluginNameString:
   case NPPVpluginDescriptionString:
   case NPPVformValue: // byte values of 0 does not appear in the UTF-8 encoding but for U+0000
 	type = RPC_TYPE_STRING;
 	break;
   case NPPVpluginWindowSize:
  case NPPVpluginTimerInterval:
	type = RPC_TYPE_INT32;
	break;
  case NPPVpluginNeedsXEmbed:
  case NPPVpluginWindowBool:
   case NPPVpluginTransparentBool:
   case NPPVjavascriptPushCallerBool:
   case NPPVpluginKeepLibraryInMemory:
 	type = RPC_TYPE_BOOLEAN;
 	break;
   case NPPVpluginScriptableNPObject:
	type = RPC_TYPE_NP_OBJECT;
	break;
  default:
	type = RPC_ERROR_GENERIC;
	break;
  }
  return type;
}
