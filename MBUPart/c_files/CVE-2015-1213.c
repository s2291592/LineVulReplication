ScriptPromise HTMLMediaElement::playForBindings(ScriptState* scriptState) {
  ScriptPromiseResolver* resolver = ScriptPromiseResolver::create(scriptState);
  ScriptPromise promise = resolver->promise();
  m_playPromiseResolvers.push_back(resolver);

  Nullable<ExceptionCode> code = play();
  if (!code.isNull()) {
    DCHECK(!m_playPromiseResolvers.isEmpty());
    m_playPromiseResolvers.pop_back();

    String message;
    switch (code.get()) {
      case NotAllowedError:
        message = "play() can only be initiated by a user gesture.";
        break;
      case NotSupportedError:
        message = "The element has no supported sources.";
        break;
      default:
        NOTREACHED();
    }
    resolver->reject(DOMException::create(code.get(), message));
    return promise;
  }

  return promise;
}

bool HTMLMediaElement::couldPlayIfEnoughData() const {
  return !paused() && !endedPlayback() && !stoppedDueToErrors();
}

String urlForLoggingMedia(const KURL& url) {
  static const unsigned maximumURLLengthForLogging = 128;

  if (url.getString().length() < maximumURLLengthForLogging)
    return url.getString();
  return url.getString().substring(0, maximumURLLengthForLogging) + "...";
}

bool HTMLMediaElement::isLockedPendingUserGesture() const {
  return m_lockedPendingUserGesture;
}

void HTMLMediaElement::setSrc(const AtomicString& url) {
  setAttribute(srcAttr, url);
}

double HTMLMediaElement::officialPlaybackPosition() const {
  bool waitingForData = m_readyState <= kHaveCurrentData;
  if (m_officialPlaybackPositionNeedsUpdate && !m_paused && !waitingForData) {
    setOfficialPlaybackPosition(currentPlaybackPosition());
  }

#if LOG_OFFICIAL_TIME_STATUS
  static const double minCachedDeltaForWarning = 0.01;
  double delta =
      std::abs(m_officialPlaybackPosition - currentPlaybackPosition());
  if (delta > minCachedDeltaForWarning) {
    BLINK_MEDIA_LOG << "currentTime(" << (void*)this
                    << ") - WARNING, cached time is " << delta
                    << "seconds off of media time when paused/waiting";
  }
#endif

  return m_officialPlaybackPosition;
}

void HTMLMediaElement::activateViewportIntersectionMonitoring(bool activate) {
  if (activate && !m_checkViewportIntersectionTimer.isActive()) {
    m_checkViewportIntersectionTimer.startRepeating(
        kCheckViewportIntersectionIntervalSeconds, BLINK_FROM_HERE);
  } else if (!activate) {
    m_checkViewportIntersectionTimer.stop();
  }
}

void HTMLMediaElement::scheduleNotifyPlaying() {
  scheduleEvent(EventTypeNames::playing);
  scheduleResolvePlayPromises();
}

void HTMLMediaElement::invokeLoadAlgorithm() {
  BLINK_MEDIA_LOG << "invokeLoadAlgorithm(" << (void*)this << ")";

  stopPeriodicTimers();
  m_loadTimer.stop();
  cancelDeferredLoad();
  m_pendingActionFlags &= ~LoadMediaResource;
  m_sentStalledEvent = false;
  m_haveFiredLoadedData = false;
  m_displayMode = Unknown;

  m_loadState = WaitingForSource;
  m_currentSourceNode = nullptr;

  if (m_playPromiseResolveTaskHandle.isActive() &&
      !ScriptForbiddenScope::isScriptForbidden()) {
    m_playPromiseResolveTaskHandle.cancel();
    resolveScheduledPlayPromises();
  }
  if (m_playPromiseRejectTaskHandle.isActive() &&
      !ScriptForbiddenScope::isScriptForbidden()) {
    m_playPromiseRejectTaskHandle.cancel();
    rejectScheduledPlayPromises();
  }

  cancelPendingEventsAndCallbacks();

  if (m_networkState == kNetworkLoading || m_networkState == kNetworkIdle)
    scheduleEvent(EventTypeNames::abort);

  resetMediaPlayerAndMediaSource();

  if (m_networkState != kNetworkEmpty) {
    scheduleEvent(EventTypeNames::emptied);

    setNetworkState(kNetworkEmpty);

    forgetResourceSpecificTracks();

    m_readyState = kHaveNothing;
    m_readyStateMaximum = kHaveNothing;

    DCHECK(!m_paused || m_playPromiseResolvers.isEmpty());

    if (!m_paused) {
      m_paused = true;

      if (!ScriptForbiddenScope::isScriptForbidden()) {
        rejectPlayPromises(
            AbortError,
            "The play() request was interrupted by a new load request.");
      }
    }

    m_seeking = false;

    setOfficialPlaybackPosition(0);
    scheduleTimeupdateEvent(false);


    cueTimeline().updateActiveCues(0);
  } else if (!m_paused) {
    UseCounter::count(document(),
                      UseCounter::HTMLMediaElementLoadNetworkEmptyNotPaused);
  }

  setPlaybackRate(defaultPlaybackRate());

  m_error = nullptr;
  m_autoplaying = true;

  invokeResourceSelectionAlgorithm();

}

bool HTMLMediaElement::isGestureNeededForPlayback() const {
  if (!m_lockedPendingUserGesture)
    return false;

  return isGestureNeededForPlaybackIfPendingUserGestureIsLocked();
}

bool HTMLMediaElement::havePotentialSourceChild() {
  HTMLSourceElement* currentSourceNode = m_currentSourceNode;
  Node* nextNode = m_nextChildNodeToConsider;

  KURL nextURL = selectNextSourceChild(0, DoNothing);

  m_currentSourceNode = currentSourceNode;
  m_nextChildNodeToConsider = nextNode;

  return nextURL.isValid();
}

void HTMLMediaElement::deferLoad() {
  DCHECK(!m_deferredLoadTimer.isActive());
  DCHECK_EQ(m_deferredLoadState, NotDeferred);
  changeNetworkStateFromLoadingToIdle();
  m_deferredLoadTimer.startOneShot(0, BLINK_FROM_HERE);
  m_deferredLoadState = WaitingForStopDelayingLoadEventTask;
}

TimeRanges* HTMLMediaElement::buffered() const {
  if (m_mediaSource)
    return m_mediaSource->buffered();

  if (!webMediaPlayer())
    return TimeRanges::create();

  return TimeRanges::create(webMediaPlayer()->buffered());
}

double HTMLMediaElement::playbackRate() const {
  return m_playbackRate;
}

HTMLMediaElement::HTMLMediaElement(const QualifiedName& tagName,
                                   Document& document)
    : HTMLElement(tagName, document),
      SuspendableObject(&document),
      m_loadTimer(TaskRunnerHelper::get(TaskType::Unthrottled, &document),
                  this,
                  &HTMLMediaElement::loadTimerFired),
      m_progressEventTimer(
          TaskRunnerHelper::get(TaskType::Unthrottled, &document),
          this,
          &HTMLMediaElement::progressEventTimerFired),
      m_playbackProgressTimer(
          TaskRunnerHelper::get(TaskType::Unthrottled, &document),
          this,
          &HTMLMediaElement::playbackProgressTimerFired),
      m_audioTracksTimer(
          TaskRunnerHelper::get(TaskType::Unthrottled, &document),
          this,
          &HTMLMediaElement::audioTracksTimerFired),
      m_viewportFillDebouncerTimer(
          TaskRunnerHelper::get(TaskType::Unthrottled, &document),
          this,
          &HTMLMediaElement::viewportFillDebouncerTimerFired),
      m_checkViewportIntersectionTimer(
          TaskRunnerHelper::get(TaskType::Unthrottled, &document),
          this,
          &HTMLMediaElement::checkViewportIntersectionTimerFired),
      m_playedTimeRanges(),
      m_asyncEventQueue(GenericEventQueue::create(this)),
      m_playbackRate(1.0f),
      m_defaultPlaybackRate(1.0f),
      m_networkState(kNetworkEmpty),
      m_readyState(kHaveNothing),
      m_readyStateMaximum(kHaveNothing),
      m_volume(1.0f),
      m_lastSeekTime(0),
      m_previousProgressTime(std::numeric_limits<double>::max()),
      m_duration(std::numeric_limits<double>::quiet_NaN()),
      m_lastTimeUpdateEventWallTime(0),
      m_lastTimeUpdateEventMediaTime(std::numeric_limits<double>::quiet_NaN()),
      m_defaultPlaybackStartPosition(0),
      m_loadState(WaitingForSource),
      m_deferredLoadState(NotDeferred),
      m_deferredLoadTimer(this, &HTMLMediaElement::deferredLoadTimerFired),
      m_webLayer(nullptr),
      m_displayMode(Unknown),
      m_officialPlaybackPosition(0),
      m_officialPlaybackPositionNeedsUpdate(true),
      m_fragmentEndTime(std::numeric_limits<double>::quiet_NaN()),
      m_pendingActionFlags(0),
      m_lockedPendingUserGesture(false),
      m_lockedPendingUserGestureIfCrossOriginExperimentEnabled(true),
      m_playing(false),
      m_shouldDelayLoadEvent(false),
      m_haveFiredLoadedData(false),
      m_autoplaying(true),
      m_muted(false),
      m_paused(true),
      m_seeking(false),
      m_sentStalledEvent(false),
      m_ignorePreloadNone(false),
      m_textTracksVisible(false),
      m_shouldPerformAutomaticTrackSelection(true),
      m_tracksAreReady(true),
      m_processingPreferenceChange(false),
      m_playingRemotely(false),
      m_inOverlayFullscreenVideo(false),
      m_mostlyFillingViewport(false),
      m_audioTracks(this, AudioTrackList::create(*this)),
      m_videoTracks(this, VideoTrackList::create(*this)),
      m_textTracks(this, nullptr),
      m_audioSourceNode(nullptr),
      m_autoplayUmaHelper(AutoplayUmaHelper::create(this)),
      m_remotePlaybackClient(nullptr),
      m_autoplayVisibilityObserver(nullptr),
      m_mediaControls(nullptr) {
  BLINK_MEDIA_LOG << "HTMLMediaElement(" << (void*)this << ")";

  m_lockedPendingUserGesture = computeLockedPendingUserGesture(document);
  m_lockedPendingUserGestureIfCrossOriginExperimentEnabled =
      isDocumentCrossOrigin(document);

  LocalFrame* frame = document.frame();
  if (frame) {
    m_remotePlaybackClient =
        frame->loader().client()->createWebRemotePlaybackClient(*this);
  }

  setHasCustomStyleCallbacks();
  addElementToDocumentMap(this, &document);

  UseCounter::count(document, UseCounter::HTMLMediaElement);
}

KURL HTMLMediaElement::selectNextSourceChild(ContentType* contentType,
                                             InvalidURLAction actionIfInvalid) {
  bool shouldLog = actionIfInvalid != DoNothing;
  if (shouldLog)
    BLINK_MEDIA_LOG << "selectNextSourceChild(" << (void*)this << ")";

  if (!m_nextChildNodeToConsider) {
    if (shouldLog)
      BLINK_MEDIA_LOG << "selectNextSourceChild(" << (void*)this
                      << ") -> 0x0000, \"\"";
    return KURL();
  }

  KURL mediaURL;
  Node* node;
  HTMLSourceElement* source = 0;
  String type;
  bool lookingForStartNode = m_nextChildNodeToConsider;
  bool canUseSourceElement = false;

  NodeVector potentialSourceNodes;
  getChildNodes(*this, potentialSourceNodes);

  for (unsigned i = 0; !canUseSourceElement && i < potentialSourceNodes.size();
       ++i) {
    node = potentialSourceNodes[i].get();
    if (lookingForStartNode && m_nextChildNodeToConsider != node)
      continue;
    lookingForStartNode = false;

    if (!isHTMLSourceElement(*node))
      continue;
    if (node->parentNode() != this)
      continue;

    source = toHTMLSourceElement(node);

    const AtomicString& srcValue = source->fastGetAttribute(srcAttr);
    if (shouldLog)
      BLINK_MEDIA_LOG << "selectNextSourceChild(" << (void*)this
                      << ") - 'src' is " << urlForLoggingMedia(mediaURL);
    if (srcValue.isEmpty())
      goto checkAgain;

    mediaURL = source->document().completeURL(srcValue);

    if (!isSafeToLoadURL(mediaURL, actionIfInvalid))
      goto checkAgain;

    type = source->type();
    if (type.isEmpty() && mediaURL.protocolIsData())
      type = mimeTypeFromDataURL(mediaURL);
    if (!type.isEmpty()) {
      if (shouldLog)
        BLINK_MEDIA_LOG << "selectNextSourceChild(" << (void*)this
                        << ") - 'type' is '" << type << "'";
      if (!supportsType(ContentType(type)))
        goto checkAgain;
    }

    canUseSourceElement = true;

  checkAgain:
    if (!canUseSourceElement && actionIfInvalid == Complain && source)
      source->scheduleErrorEvent();
  }

  if (canUseSourceElement) {
    if (contentType)
      *contentType = ContentType(type);
    m_currentSourceNode = source;
    m_nextChildNodeToConsider = source->nextSibling();
  } else {
    m_currentSourceNode = nullptr;
    m_nextChildNodeToConsider = nullptr;
  }

  if (shouldLog)
    BLINK_MEDIA_LOG << "selectNextSourceChild(" << (void*)this << ") -> "
                    << m_currentSourceNode.get() << ", "
                    << (canUseSourceElement ? urlForLoggingMedia(mediaURL)
                                            : "");
  return canUseSourceElement ? mediaURL : KURL();
}

void HTMLMediaElement::addPlayedRange(double start, double end) {
  BLINK_MEDIA_LOG << "addPlayedRange(" << (void*)this << ", " << start << ", "
                  << end << ")";
  if (!m_playedTimeRanges)
    m_playedTimeRanges = TimeRanges::create();
  m_playedTimeRanges->add(start, end);
}

String preloadTypeToString(WebMediaPlayer::Preload preloadType) {
  switch (preloadType) {
    case WebMediaPlayer::PreloadNone:
      return "none";
    case WebMediaPlayer::PreloadMetaData:
      return "metadata";
    case WebMediaPlayer::PreloadAuto:
      return "auto";
  }

  NOTREACHED();
  return String();
}

void HTMLMediaElement::selectInitialTracksIfNecessary() {
  if (!mediaTracksEnabledInternally())
    return;

  if (audioTracks().length() > 0 && !audioTracks().hasEnabledTrack())
    audioTracks().anonymousIndexedGetter(0)->setEnabled(true);

  if (videoTracks().length() > 0 && videoTracks().selectedIndex() == -1)
    videoTracks().anonymousIndexedGetter(0)->setSelected(true);
}

bool HTMLMediaElement::supportsSave() const {
  return webMediaPlayer() && webMediaPlayer()->supportsSave();
}

void HTMLMediaElement::repaint() {
  if (m_webLayer)
    m_webLayer->invalidate();

  updateDisplayState();
  if (layoutObject())
    layoutObject()->setShouldDoFullPaintInvalidation();
}

bool HTMLMediaElement::hasAudio() const {
  return webMediaPlayer() && webMediaPlayer()->hasAudio();
}

void HTMLMediaElement::markCaptionAndSubtitleTracksAsUnconfigured() {
  if (!m_textTracks)
    return;

  for (unsigned i = 0; i < m_textTracks->length(); ++i) {
    TextTrack* textTrack = m_textTracks->anonymousIndexedGetter(i);
    if (textTrack->isVisualKind())
      textTrack->setHasBeenConfigured(false);
  }
}

String HTMLMediaElement::canPlayType(const String& mimeType) const {
  MIMETypeRegistry::SupportsType support = supportsType(ContentType(mimeType));
  String canPlay;

  switch (support) {
    case MIMETypeRegistry::IsNotSupported:
      canPlay = emptyString;
      break;
    case MIMETypeRegistry::MayBeSupported:
      canPlay = "maybe";
      break;
    case MIMETypeRegistry::IsSupported:
      canPlay = "probably";
      break;
  }

  BLINK_MEDIA_LOG << "canPlayType(" << (void*)this << ", " << mimeType
                  << ") -> " << canPlay;

  return canPlay;
}

WebMediaPlayer::Preload HTMLMediaElement::preloadType() const {
  const AtomicString& preload = fastGetAttribute(preloadAttr);
  if (equalIgnoringCase(preload, "none")) {
    UseCounter::count(document(), UseCounter::HTMLMediaElementPreloadNone);
    return WebMediaPlayer::PreloadNone;
  }

  if (document().settings() &&
      (document().settings()->getDataSaverEnabled() ||
       document().settings()->getForcePreloadNoneForMediaElements()) &&
      (m_currentSrc.protocol() != "blob" && m_currentSrc.protocol() != "data" &&
       m_currentSrc.protocol() != "file")) {
    UseCounter::count(document(),
                      UseCounter::HTMLMediaElementPreloadForcedNone);
    return WebMediaPlayer::PreloadNone;
  }

  if (equalIgnoringCase(preload, "metadata")) {
    UseCounter::count(document(), UseCounter::HTMLMediaElementPreloadMetadata);
    return WebMediaPlayer::PreloadMetaData;
  }

  if (networkStateNotifier().isCellularConnectionType()) {
    UseCounter::count(document(),
                      UseCounter::HTMLMediaElementPreloadForcedMetadata);
    return WebMediaPlayer::PreloadMetaData;
  }

  if (equalIgnoringCase(preload, "auto")) {
    UseCounter::count(document(), UseCounter::HTMLMediaElementPreloadAuto);
    return WebMediaPlayer::PreloadAuto;
  }



  UseCounter::count(document(), UseCounter::HTMLMediaElementPreloadDefault);
  return WebMediaPlayer::PreloadAuto;
}

static void assertShadowRootChildren(ShadowRoot& shadowRoot) {
#if DCHECK_IS_ON()
  unsigned numberOfChildren = shadowRoot.countChildren();
  DCHECK_LE(numberOfChildren, 2u);
  Node* firstChild = shadowRoot.firstChild();
  Node* lastChild = shadowRoot.lastChild();
  if (numberOfChildren == 1) {
    DCHECK(firstChild->isTextTrackContainer() || firstChild->isMediaControls());
  } else if (numberOfChildren == 2) {
    DCHECK(firstChild->isTextTrackContainer());
    DCHECK(lastChild->isMediaControls());
  }
#endif
}

void HTMLMediaElement::dispose() {
  closeMediaSource();

  clearMediaPlayerAndAudioSourceProviderClientWithoutLocking();
}

bool HTMLMediaElement::isGestureNeededForPlaybackIfPendingUserGestureIsLocked()
    const {
  if (loadType() == WebMediaPlayer::LoadTypeMediaStream)
    return false;

  if (isHTMLVideoElement() && muted() &&
      RuntimeEnabledFeatures::autoplayMutedVideosEnabled() &&
      !(document().settings() &&
        document().settings()->getDataSaverEnabled()) &&
      !(document().settings() &&
        document().settings()->getForcePreloadNoneForMediaElements()) &&
      isAutoplayAllowedPerSettings()) {
    return false;
  }

  return true;
}

bool HTMLMediaElement::textTracksAreReady() const {
  for (const auto& textTrack : m_textTracksWhenResourceSelectionBegan) {
    if (textTrack->getReadinessState() == TextTrack::Loading ||
        textTrack->getReadinessState() == TextTrack::NotLoaded)
      return false;
  }

  return true;
}

void HTMLMediaElement::didExitFullscreen() {
  updateControlsVisibility();

  if (webMediaPlayer())
    webMediaPlayer()->exitedFullscreen();
  if (m_inOverlayFullscreenVideo)
    document().layoutViewItem().compositor()->setNeedsCompositingUpdate(
        CompositingUpdateRebuildTree);
  m_inOverlayFullscreenVideo = false;
}

MockContentSettingsClient::~MockContentSettingsClient() {}

void HTMLMediaElement::setMediaStreamRegistry(URLRegistry* registry) {
  DCHECK(!s_mediaStreamRegistry);
  s_mediaStreamRegistry = registry;
}

void HTMLMediaElement::loadResource(const WebMediaPlayerSource& source,
                                    const ContentType& contentType) {
  DCHECK(isMainThread());
  KURL url;
  if (source.isURL()) {
    url = source.getAsURL();
    DCHECK(isSafeToLoadURL(url, Complain));
    BLINK_MEDIA_LOG << "loadResource(" << (void*)this << ", "
                    << urlForLoggingMedia(url) << ", " << contentType.raw()
                    << ")";
  }

  LocalFrame* frame = document().frame();
  if (!frame) {
    mediaLoadingFailed(WebMediaPlayer::NetworkStateFormatError);
    return;
  }

  setNetworkState(kNetworkLoading);

  m_currentSrc = url;

  if (m_audioSourceNode)
    m_audioSourceNode->onCurrentSrcChanged(m_currentSrc);

  BLINK_MEDIA_LOG << "loadResource(" << (void*)this << ") - m_currentSrc -> "
                  << urlForLoggingMedia(m_currentSrc);

  startProgressEventTimer();

  setDisplayMode(Unknown);

  setPlayerPreload();

  if (fastHasAttribute(mutedAttr))
    m_muted = true;

  DCHECK(!m_mediaSource);

  bool attemptLoad = true;

  m_mediaSource = HTMLMediaSource::lookup(url.getString());
  if (m_mediaSource && !m_mediaSource->attachToElement(this)) {
    m_mediaSource = nullptr;
    attemptLoad = false;
  }

  bool canLoadResource = source.isMediaStream() || canLoadURL(url, contentType);
  if (attemptLoad && canLoadResource) {
    DCHECK(!webMediaPlayer());

    if (!source.isMediaStream() && !url.protocolIs("blob") &&
        effectivePreloadType() == WebMediaPlayer::PreloadNone) {
      BLINK_MEDIA_LOG << "loadResource(" << (void*)this
                      << ") : Delaying load because preload == 'none'";
      deferLoad();
    } else {
      startPlayerLoad();
    }
  } else {
    mediaLoadingFailed(WebMediaPlayer::NetworkStateFormatError);
  }

  updateDisplayState();

  if (layoutObject())
    layoutObject()->updateFromElement();
}

    isGestureNeededForPlaybackIfCrossOriginExperimentEnabled() const {
  if (!m_lockedPendingUserGestureIfCrossOriginExperimentEnabled)
    return false;

  return isGestureNeededForPlaybackIfPendingUserGestureIsLocked();
}

void HTMLMediaElement::stopPeriodicTimers() {
  m_progressEventTimer.stop();
  m_playbackProgressTimer.stop();
  m_checkViewportIntersectionTimer.stop();
}

void HTMLMediaElement::loadNextSourceChild() {
  ContentType contentType((String()));
  KURL mediaURL = selectNextSourceChild(&contentType, Complain);
  if (!mediaURL.isValid()) {
    waitForSourceChange();
    return;
  }

  resetMediaPlayerAndMediaSource();

  m_loadState = LoadingFromSourceElement;
  loadResource(WebMediaPlayerSource(WebURL(mediaURL)), contentType);
}

void HTMLMediaElement::remoteRouteAvailabilityChanged(
    WebRemotePlaybackAvailability availability) {
  if (remotePlaybackClient())
    remotePlaybackClient()->availabilityChanged(availability);

  if (mediaControls())
    mediaControls()->onRemotePlaybackAvailabilityChanged();
}

unsigned HTMLMediaElement::webkitAudioDecodedByteCount() const {
  if (!webMediaPlayer())
    return 0;
  return webMediaPlayer()->audioDecodedByteCount();
}

double HTMLMediaElement::volume() const {
  return m_volume;
}

bool HTMLMediaElement::shouldAutoplay() {
  if (document().isSandboxed(SandboxAutomaticFeatures))
    return false;
  return m_autoplaying && m_paused && autoplay();
}

void HTMLMediaElement::mediaSourceOpened(WebMediaSource* webMediaSource) {
  setShouldDelayLoadEvent(false);
  m_mediaSource->setWebMediaSourceAndOpen(WTF::wrapUnique(webMediaSource));
}

bool MockContentSettingsClient::allowAutoplay(bool default_value) {
  return default_value || flags_->autoplay_allowed();
}

void HTMLMediaElement::didRecalcStyle() {
  if (layoutObject())
    layoutObject()->updateFromElement();
}

TextTrackList* HTMLMediaElement::textTracks() {
  if (!m_textTracks)
    m_textTracks = TextTrackList::create(this);

  return m_textTracks.get();
}

void HTMLMediaElement::executeDeferredLoad() {
  DCHECK_GE(m_deferredLoadState, WaitingForTrigger);


  cancelDeferredLoad();
  setShouldDelayLoadEvent(true);
  setNetworkState(kNetworkLoading);

  startProgressEventTimer();

  startPlayerLoad();
}

void HTMLMediaElement::readyStateChanged() {
  setReadyState(static_cast<ReadyState>(webMediaPlayer()->getReadyState()));
}

void HTMLMediaElement::scheduleTimeupdateEvent(bool periodicEvent) {
  double mediaTime = currentPlaybackPosition();
  double now = WTF::currentTime();

  bool haveNotRecentlyFiredTimeupdate =
      (now - m_lastTimeUpdateEventWallTime) >= maxTimeupdateEventFrequency;
  bool mediaTimeHasProgressed = mediaTime != m_lastTimeUpdateEventMediaTime;

  if (!periodicEvent ||
      (haveNotRecentlyFiredTimeupdate && mediaTimeHasProgressed)) {
    scheduleEvent(EventTypeNames::timeupdate);
    m_lastTimeUpdateEventWallTime = now;
    m_lastTimeUpdateEventMediaTime = mediaTime;
  }
}

void HTMLMediaElement::mediaLoadingFailed(WebMediaPlayer::NetworkState error) {
  stopPeriodicTimers();

  if (m_readyState < kHaveMetadata && m_loadState == LoadingFromSourceElement) {
    if (m_currentSourceNode)
      m_currentSourceNode->scheduleErrorEvent();
    else
      BLINK_MEDIA_LOG << "mediaLoadingFailed(" << (void*)this
                      << ") - error event not sent, <source> was removed";


    forgetResourceSpecificTracks();

    if (havePotentialSourceChild()) {
      BLINK_MEDIA_LOG << "mediaLoadingFailed(" << (void*)this
                      << ") - scheduling next <source>";
      scheduleNextSourceChild();
    } else {
      BLINK_MEDIA_LOG << "mediaLoadingFailed(" << (void*)this
                      << ") - no more <source> elements, waiting";
      waitForSourceChange();
    }

    return;
  }

  if (error == WebMediaPlayer::NetworkStateNetworkError &&
      m_readyState >= kHaveMetadata) {
    mediaEngineError(MediaError::create(MediaError::kMediaErrNetwork));
  } else if (error == WebMediaPlayer::NetworkStateDecodeError) {
    mediaEngineError(MediaError::create(MediaError::kMediaErrDecode));
  } else if ((error == WebMediaPlayer::NetworkStateFormatError ||
              error == WebMediaPlayer::NetworkStateNetworkError) &&
             m_loadState == LoadingFromSrcAttr) {
    noneSupported();
  }

  updateDisplayState();
}

WebMediaPlayer::Preload HTMLMediaElement::effectivePreloadType() const {
  if (autoplay() && !isGestureNeededForPlayback())
    return WebMediaPlayer::PreloadAuto;

  WebMediaPlayer::Preload preload = preloadType();
  if (m_ignorePreloadNone && preload == WebMediaPlayer::PreloadNone)
    return WebMediaPlayer::PreloadMetaData;

  return preload;
}

void addElementToDocumentMap(HTMLMediaElement* element, Document* document) {
  DocumentElementSetMap& map = documentToElementSetMap();
  WeakMediaElementSet* set = nullptr;
  auto it = map.find(document);
  if (it == map.end()) {
    set = new WeakMediaElementSet;
    map.insert(document, set);
  } else {
    set = it->value;
  }
  set->insert(element);
}

  AudioSourceProviderClientLockScope(HTMLMediaElement& element)
      : m_client(element.audioSourceNode()) {
    if (m_client)
      m_client->lock();
  }

bool HTMLMediaElement::autoplay() const {
  return fastHasAttribute(autoplayAttr);
}

void HTMLMediaElement::setTextTrackKindUserPreferenceForAllMediaElements(
    Document* document) {
  auto it = documentToElementSetMap().find(document);
  if (it == documentToElementSetMap().end())
    return;
  DCHECK(it->value);
  WeakMediaElementSet& elements = *it->value;
  for (const auto& element : elements)
    element->automaticTrackSelectionForUpdatedUserPreference();
}

void HTMLMediaElement::durationChanged(double duration, bool requestSeek) {
  BLINK_MEDIA_LOG << "durationChanged(" << (void*)this << ", " << duration
                  << ", " << boolString(requestSeek) << ")";

  if (m_duration == duration)
    return;

  BLINK_MEDIA_LOG << "durationChanged(" << (void*)this << ") : " << m_duration
                  << " -> " << duration;
  m_duration = duration;
  scheduleEvent(EventTypeNames::durationchange);

  if (layoutObject())
    layoutObject()->updateFromElement();

  if (requestSeek)
    seek(duration);
}

MockContentSettingsClient::MockContentSettingsClient(
    LayoutTestRuntimeFlags* layout_test_runtime_flags)
    : delegate_(nullptr), flags_(layout_test_runtime_flags) {}

MediaError* HTMLMediaElement::error() const {
  return m_error;
}

void HTMLMediaElement::setOfficialPlaybackPosition(double position) const {
#if LOG_OFFICIAL_TIME_STATUS
  BLINK_MEDIA_LOG << "setOfficialPlaybackPosition(" << (void*)this
                  << ") was:" << m_officialPlaybackPosition
                  << " now:" << position;
#endif

  m_officialPlaybackPosition =
      std::isnan(duration()) ? position : std::min(duration(), position);

  if (m_officialPlaybackPosition != position) {
    BLINK_MEDIA_LOG << "setOfficialPlaybackPosition(" << (void*)this
                    << ") position:" << position
                    << " truncated to duration:" << m_officialPlaybackPosition;
  }

  m_officialPlaybackPositionNeedsUpdate = false;
  Microtask::enqueueMicrotask(
      WTF::bind(&HTMLMediaElement::requireOfficialPlaybackPositionUpdate,
                wrapWeakPersistent(this)));
}

TimeRanges* HTMLMediaElement::seekable() const {
  if (!webMediaPlayer())
    return TimeRanges::create();

  if (m_mediaSource)
    return m_mediaSource->seekable();

  return TimeRanges::create(webMediaPlayer()->seekable());
}

void HTMLMediaElement::unlockUserGesture() {
  m_lockedPendingUserGesture = false;
  m_lockedPendingUserGestureIfCrossOriginExperimentEnabled = false;
}

void HTMLMediaElement::resetMediaPlayerAndMediaSource() {
  closeMediaSource();

  {
    AudioSourceProviderClientLockScope scope(*this);
    clearMediaPlayerAndAudioSourceProviderClientWithoutLocking();
  }

  m_playingRemotely = false;
  remoteRouteAvailabilityChanged(WebRemotePlaybackAvailability::Unknown);

  if (m_audioSourceNode)
    getAudioSourceProvider().setClient(m_audioSourceNode);
}

void HTMLMediaElement::requestReload(const WebURL& newUrl) {
  DCHECK(webMediaPlayer());
  DCHECK(!m_srcObject);
  DCHECK(newUrl.isValid());
  DCHECK(isSafeToLoadURL(newUrl, Complain));
  resetMediaPlayerAndMediaSource();
  startPlayerLoad(newUrl);
}

void HTMLMediaElement::setCurrentTime(double time) {
  if (m_readyState == kHaveNothing) {
    m_defaultPlaybackStartPosition = time;
    return;
  }

  seek(time);
}

void HTMLMediaElement::requestRemotePlaybackStop() {
  if (webMediaPlayer())
    webMediaPlayer()->requestRemotePlaybackStop();
}

void HTMLMediaElement::resolveScheduledPlayPromises() {
  for (auto& resolver : m_playPromiseResolveList)
    resolver->resolve();

  m_playPromiseResolveList.clear();
}

void HTMLMediaElement::createPlaceholderTracksIfNecessary() {
  if (!mediaTracksEnabledInternally())
    return;

  if (hasAudio() && !audioTracks().length()) {
    addAudioTrack("audio", WebMediaPlayerClient::AudioTrackKindMain,
                  "Audio Track", "", false);
  }

  if (hasVideo() && !videoTracks().length()) {
    addVideoTrack("video", WebMediaPlayerClient::VideoTrackKindMain,
                  "Video Track", "", false);
  }
}

double HTMLMediaElement::defaultPlaybackRate() const {
  return m_defaultPlaybackRate;
}

MIMETypeRegistry::SupportsType HTMLMediaElement::supportsType(
    const ContentType& contentType) {
  DEFINE_STATIC_LOCAL(const String, codecs, ("codecs"));

  String type = contentType.type().lower();
  String typeCodecs = contentType.parameter(codecs);

  if (type.isEmpty())
    return MIMETypeRegistry::IsNotSupported;

  if (type == "application/octet-stream")
    return MIMETypeRegistry::IsNotSupported;

  return MIMETypeRegistry::supportsMediaMIMEType(type, typeCodecs);
}

bool HTMLMediaElement::isURLAttribute(const Attribute& attribute) const {
  return attribute.name() == srcAttr || HTMLElement::isURLAttribute(attribute);
}

void HTMLMediaElement::textTrackReadyStateChanged(TextTrack* track) {
  if (webMediaPlayer() &&
      m_textTracksWhenResourceSelectionBegan.contains(track)) {
    if (track->getReadinessState() != TextTrack::Loading)
      setReadyState(static_cast<ReadyState>(webMediaPlayer()->getReadyState()));
  } else {
    if (mediaControls() &&
        track->getReadinessState() == TextTrack::FailedToLoad) {
      mediaControls()->onTrackElementFailedToLoad();
    }
  }
}

void HTMLMediaElement::requestRemotePlayback() {
  if (webMediaPlayer())
    webMediaPlayer()->requestRemotePlayback();
}

void HTMLMediaElement::sizeChanged() {
  BLINK_MEDIA_LOG << "sizeChanged(" << (void*)this << ")";

  DCHECK(hasVideo());  // "resize" makes no sense in absence of video.
  if (m_readyState > kHaveNothing && isHTMLVideoElement())
    scheduleEvent(EventTypeNames::resize);

  if (layoutObject())
    layoutObject()->updateFromElement();
}

TextTrack* HTMLMediaElement::addTextTrack(const AtomicString& kind,
                                          const AtomicString& label,
                                          const AtomicString& language,
                                          ExceptionState& exceptionState) {


  TextTrack* textTrack = TextTrack::create(kind, label, language);
  textTrack->setReadinessState(TextTrack::Loaded);

  textTracks()->append(textTrack);


  textTrack->setMode(TextTrack::hiddenKeyword());

  return textTrack;
}

bool HTMLMediaElement::ended() const {
  return endedPlayback() && getDirectionOfPlayback() == Forward;
}

void HTMLMediaElement::setWebLayer(WebLayer* webLayer) {
  if (webLayer == m_webLayer)
    return;

  if (!m_webLayer || !webLayer)
    setNeedsCompositingUpdate();

  if (m_webLayer)
    GraphicsLayer::unregisterContentsLayer(m_webLayer);
  m_webLayer = webLayer;
  if (m_webLayer)
    GraphicsLayer::registerContentsLayer(m_webLayer);
}

void HTMLMediaElement::clearMediaPlayer() {
  forgetResourceSpecificTracks();

  closeMediaSource();

  cancelDeferredLoad();

  {
    AudioSourceProviderClientLockScope scope(*this);
    clearMediaPlayerAndAudioSourceProviderClientWithoutLocking();
  }

  stopPeriodicTimers();
  m_loadTimer.stop();

  m_pendingActionFlags = 0;
  m_loadState = WaitingForSource;

  m_playingRemotely = false;
  remoteRouteAvailabilityChanged(WebRemotePlaybackAvailability::Unknown);

  if (layoutObject())
    layoutObject()->setShouldDoFullPaintInvalidation();
}

bool HTMLMediaElement::hasClosedCaptions() const {
  if (!m_textTracks)
    return false;

  for (unsigned i = 0; i < m_textTracks->length(); ++i) {
    if (m_textTracks->anonymousIndexedGetter(i)->canBeRendered())
      return true;
  }

  return false;
}

bool HTMLMediaElement::isAutoplayingMuted() {
  if (!isHTMLVideoElement() ||
      !RuntimeEnabledFeatures::autoplayMutedVideosEnabled()) {
    return false;
  }

  return !paused() && muted() && isLockedPendingUserGesture();
}

bool computeLockedPendingUserGesture(Document& document) {
  if (!document.settings())
    return false;

  if (document.settings()->getCrossOriginMediaPlaybackRequiresUserGesture() &&
      isDocumentCrossOrigin(document)) {
    return true;
  }

  return document.settings()->getMediaPlaybackRequiresUserGesture();
}

bool HTMLMediaElement::hasRemoteRoutes() const {
  return remotePlaybackClient() &&
         remotePlaybackClient()->remotePlaybackAvailable();
}

const AtomicString& AudioKindToString(
    WebMediaPlayerClient::AudioTrackKind kind) {
  switch (kind) {
    case WebMediaPlayerClient::AudioTrackKindNone:
      return emptyAtom;
    case WebMediaPlayerClient::AudioTrackKindAlternative:
      return AudioTrack::alternativeKeyword();
    case WebMediaPlayerClient::AudioTrackKindDescriptions:
      return AudioTrack::descriptionsKeyword();
    case WebMediaPlayerClient::AudioTrackKindMain:
      return AudioTrack::mainKeyword();
    case WebMediaPlayerClient::AudioTrackKindMainDescriptions:
      return AudioTrack::mainDescriptionsKeyword();
    case WebMediaPlayerClient::AudioTrackKindTranslation:
      return AudioTrack::translationKeyword();
    case WebMediaPlayerClient::AudioTrackKindCommentary:
      return AudioTrack::commentaryKeyword();
  }

  NOTREACHED();
  return emptyAtom;
}

bool HTMLMediaElement::isFullscreen() const {
  return Fullscreen::isCurrentFullScreenElement(*this);
}

bool HTMLMediaElement::supportsFocus() const {
  if (ownerDocument()->isMediaDocument())
    return false;

  return shouldShowControls() || HTMLElement::supportsFocus();
}

void HTMLMediaElement::timeChanged() {
  BLINK_MEDIA_LOG << "timeChanged(" << (void*)this << ")";

  cueTimeline().updateActiveCues(currentTime());

  if (m_seeking && m_readyState >= kHaveCurrentData &&
      !webMediaPlayer()->seeking())
    finishSeek();

  scheduleTimeupdateEvent(false);

  double now = currentPlaybackPosition();
  double dur = duration();

  if (!std::isnan(dur) && dur && now >= dur &&
      getDirectionOfPlayback() == Forward) {
    if (loop()) {
      seek(earliestPossiblePosition());
    } else {
      if (!m_paused) {
        m_paused = true;
        scheduleEvent(EventTypeNames::pause);
        scheduleRejectPlayPromises(AbortError);
      }
      scheduleEvent(EventTypeNames::ended);
    }
  }
  updatePlayState();
}

DEFINE_TRACE_WRAPPERS(HTMLMediaElement) {
  visitor->traceWrappers(m_videoTracks);
  visitor->traceWrappers(m_audioTracks);
  visitor->traceWrappers(m_textTracks);
  HTMLElement::traceWrappers(visitor);
}

bool MockContentSettingsClient::allowStorage(bool enabled_per_settings) {
  return flags_->storage_allowed();
}

WebMediaPlayer::LoadType HTMLMediaElement::loadType() const {
  if (m_mediaSource)
    return WebMediaPlayer::LoadTypeMediaSource;

  if (m_srcObject ||
      (!m_currentSrc.isNull() && isMediaStreamURL(m_currentSrc.getString())))
    return WebMediaPlayer::LoadTypeMediaStream;

  return WebMediaPlayer::LoadTypeURL;
}

double HTMLMediaElement::currentTime() const {
  if (m_defaultPlaybackStartPosition)
    return m_defaultPlaybackStartPosition;

  if (m_seeking) {
    BLINK_MEDIA_LOG << "currentTime(" << (void*)this
                    << ") - seeking, returning " << m_lastSeekTime;
    return m_lastSeekTime;
  }

  return officialPlaybackPosition();
}

bool HTMLMediaElement::isInCrossOriginFrame() const {
  return isDocumentCrossOrigin(document());
}

void HTMLMediaElement::pause() {
  BLINK_MEDIA_LOG << "pause(" << (void*)this << ")";

  if (webMediaPlayer() && UserGestureIndicator::utilizeUserGesture())
    webMediaPlayer()->setBufferingStrategy(
        WebMediaPlayer::BufferingStrategy::Aggressive);

  pauseInternal();
}

void HTMLMediaElement::playbackStateChanged() {
  BLINK_MEDIA_LOG << "playbackStateChanged(" << (void*)this << ")";

  if (!webMediaPlayer())
    return;

  if (webMediaPlayer()->paused())
    pauseInternal();
  else
    playInternal();
}

void HTMLMediaElement::finishParsingChildren() {
  HTMLElement::finishParsingChildren();

  if (Traversal<HTMLTrackElement>::firstChild(*this))
    scheduleTextTrackResourceLoad();
}

bool MockContentSettingsClient::allowRunningInsecureContent(
    bool enabled_per_settings,
    const blink::WebSecurityOrigin& context,
    const blink::WebURL& url) {
  return enabled_per_settings || flags_->running_insecure_content_allowed();
 }

void HTMLMediaElement::loadInternal() {
  m_textTracksWhenResourceSelectionBegan.clear();
  if (m_textTracks) {
    for (unsigned i = 0; i < m_textTracks->length(); ++i) {
      TextTrack* track = m_textTracks->anonymousIndexedGetter(i);
      if (track->mode() != TextTrack::disabledKeyword())
        m_textTracksWhenResourceSelectionBegan.push_back(track);
    }
  }

  selectMediaResource();
}

void HTMLMediaElement::updatePlaybackRate() {
  if (m_webMediaPlayer && potentiallyPlaying())
    webMediaPlayer()->setRate(playbackRate());
}

WebMediaPlayer::TrackId HTMLMediaElement::addVideoTrack(
    const WebString& id,
    WebMediaPlayerClient::VideoTrackKind kind,
    const WebString& label,
    const WebString& language,
    bool selected) {
  AtomicString kindString = VideoKindToString(kind);
  BLINK_MEDIA_LOG << "addVideoTrack(" << (void*)this << ", '" << (String)id
                  << "', '" << (AtomicString)kindString << "', '"
                  << (String)label << "', '" << (String)language << "', "
                  << boolString(selected) << ")";

  if (selected && videoTracks().selectedIndex() != -1)
    selected = false;

  VideoTrack* videoTrack =
      VideoTrack::create(id, kindString, label, language, selected);
  videoTracks().add(videoTrack);

  return videoTrack->id();
}

void HTMLMediaElement::startProgressEventTimer() {
  if (m_progressEventTimer.isActive())
    return;

  m_previousProgressTime = WTF::currentTime();
  m_progressEventTimer.startRepeating(0.350, BLINK_FROM_HERE);
}

Nullable<ExceptionCode> HTMLMediaElement::play() {
  BLINK_MEDIA_LOG << "play(" << (void*)this << ")";

  if (!UserGestureIndicator::processingUserGesture()) {
    m_autoplayUmaHelper->onAutoplayInitiated(AutoplaySource::Method);
    if (isGestureNeededForPlayback()) {
      if (!m_paused) {
        playInternal();
        return nullptr;
      }

      m_autoplayUmaHelper->recordCrossOriginAutoplayResult(
          CrossOriginAutoplayResult::AutoplayBlocked);
      String message = ExceptionMessages::failedToExecute(
          "play", "HTMLMediaElement",
          "API can only be initiated by a user gesture.");
      document().addConsoleMessage(ConsoleMessage::create(
          JSMessageSource, WarningMessageLevel, message));
      return NotAllowedError;
    } else {
      if (isGestureNeededForPlaybackIfCrossOriginExperimentEnabled()) {
        m_autoplayUmaHelper->recordCrossOriginAutoplayResult(
            CrossOriginAutoplayResult::AutoplayBlocked);
      } else {
        m_autoplayUmaHelper->recordCrossOriginAutoplayResult(
            CrossOriginAutoplayResult::AutoplayAllowed);
      }
    }
  } else {
    m_autoplayUmaHelper->recordCrossOriginAutoplayResult(
        CrossOriginAutoplayResult::PlayedWithGesture);
    UserGestureIndicator::utilizeUserGesture();
    unlockUserGesture();
  }

  if (m_error && m_error->code() == MediaError::kMediaErrSrcNotSupported)
    return NotSupportedError;

  playInternal();

  return nullptr;
}

void HTMLMediaElement::playInternal() {
  BLINK_MEDIA_LOG << "playInternal(" << (void*)this << ")";

  if (webMediaPlayer())
    webMediaPlayer()->setBufferingStrategy(
        WebMediaPlayer::BufferingStrategy::Normal);

  if (m_networkState == kNetworkEmpty)
    invokeResourceSelectionAlgorithm();

  if (endedPlayback(LoopCondition::Ignored))
    seek(0);

  if (m_paused) {
    m_paused = false;
    scheduleEvent(EventTypeNames::play);

    if (m_readyState <= kHaveCurrentData)
      scheduleEvent(EventTypeNames::waiting);
    else if (m_readyState >= kHaveFutureData)
      scheduleNotifyPlaying();
  } else if (m_readyState >= kHaveFutureData) {
    scheduleResolvePlayPromises();
  }

  m_autoplaying = false;

  setIgnorePreloadNone();
  updatePlayState();
}

void HTMLMediaElement::changeNetworkStateFromLoadingToIdle() {
  m_progressEventTimer.stop();

  if (webMediaPlayer() && webMediaPlayer()->didLoadingProgress())
    scheduleEvent(EventTypeNames::progress);
  scheduleEvent(EventTypeNames::suspend);
  setNetworkState(kNetworkIdle);
}

void HTMLMediaElement::loadSourceFromObject() {
  DCHECK(m_srcObject);
  m_loadState = LoadingFromSrcObject;

  loadResource(WebMediaPlayerSource(WebMediaStream(m_srcObject)),
               ContentType((String())));
}

void HTMLMediaElement::audioTracksTimerFired(TimerBase*) {
  Vector<WebMediaPlayer::TrackId> enabledTrackIds;
  for (unsigned i = 0; i < audioTracks().length(); ++i) {
    AudioTrack* track = audioTracks().anonymousIndexedGetter(i);
    if (track->enabled())
      enabledTrackIds.push_back(track->id());
  }

  webMediaPlayer()->enabledAudioTracksChanged(enabledTrackIds);
}

bool HTMLMediaElement::potentiallyPlaying() const {
  bool pausedToBuffer =
      m_readyStateMaximum >= kHaveFutureData && m_readyState < kHaveFutureData;
  return (pausedToBuffer || m_readyState >= kHaveFutureData) &&
         couldPlayIfEnoughData();
}

void HTMLMediaElement::setPlaybackRate(double rate) {
  BLINK_MEDIA_LOG << "setPlaybackRate(" << (void*)this << ", " << rate << ")";

  if (m_playbackRate != rate) {
    m_playbackRate = rate;
    scheduleEvent(EventTypeNames::ratechange);
  }

  updatePlaybackRate();
}

double HTMLMediaElement::currentPlaybackPosition() const {
  if (m_readyState == kHaveNothing)
    return 0;

  if (webMediaPlayer())
    return webMediaPlayer()->currentTime();

  if (m_readyState >= kHaveMetadata) {
    LOG(WARNING) << __func__ << " readyState = " << m_readyState
                 << " but no webMeidaPlayer to provide currentPlaybackPosition";
  }

  return 0;
}

WebMediaPlayer::TrackId HTMLMediaElement::getSelectedVideoTrackId() {
  DCHECK(RuntimeEnabledFeatures::backgroundVideoTrackOptimizationEnabled());
  DCHECK(hasSelectedVideoTrack());

  int selectedTrackIndex = m_videoTracks->selectedIndex();
  VideoTrack* track = m_videoTracks->anonymousIndexedGetter(selectedTrackIndex);
  return track->id();
}

void HTMLMediaElement::configureTextTrackDisplay() {
  DCHECK(m_textTracks);
  BLINK_MEDIA_LOG << "configureTextTrackDisplay(" << (void*)this << ")";

  if (m_processingPreferenceChange)
    return;

  bool haveVisibleTextTrack = m_textTracks->hasShowingTracks();
  m_textTracksVisible = haveVisibleTextTrack;

  if (!haveVisibleTextTrack && !mediaControls())
    return;

  cueTimeline().updateActiveCues(currentTime());

  updateTextTrackDisplay();
}

TextTrackContainer& HTMLMediaElement::ensureTextTrackContainer() {
  ShadowRoot& shadowRoot = ensureUserAgentShadowRoot();
  assertShadowRootChildren(shadowRoot);

  Node* firstChild = shadowRoot.firstChild();
  if (firstChild && firstChild->isTextTrackContainer())
    return toTextTrackContainer(*firstChild);

  TextTrackContainer* textTrackContainer =
      TextTrackContainer::create(document());

  shadowRoot.insertBefore(textTrackContainer, firstChild);

  assertShadowRootChildren(shadowRoot);

  return *textTrackContainer;
}

void HTMLMediaElement::AudioSourceProviderImpl::setClient(
    AudioSourceProviderClient* client) {
  MutexLocker locker(provideInputLock);

  if (client)
    m_client = new HTMLMediaElement::AudioClientImpl(client);
  else
    m_client.clear();

  if (m_webAudioSourceProvider)
    m_webAudioSourceProvider->setClient(m_client.get());
}

DEFINE_TRACE(HTMLMediaElement) {
  visitor->trace(m_playedTimeRanges);
  visitor->trace(m_asyncEventQueue);
  visitor->trace(m_error);
  visitor->trace(m_currentSourceNode);
  visitor->trace(m_nextChildNodeToConsider);
  visitor->trace(m_mediaSource);
  visitor->trace(m_audioTracks);
  visitor->trace(m_videoTracks);
  visitor->trace(m_cueTimeline);
  visitor->trace(m_textTracks);
  visitor->trace(m_textTracksWhenResourceSelectionBegan);
  visitor->trace(m_playPromiseResolvers);
  visitor->trace(m_playPromiseResolveList);
  visitor->trace(m_playPromiseRejectList);
  visitor->trace(m_audioSourceProvider);
  visitor->trace(m_autoplayUmaHelper);
  visitor->trace(m_srcObject);
  visitor->trace(m_autoplayVisibilityObserver);
  visitor->trace(m_mediaControls);
  visitor->template registerWeakMembers<HTMLMediaElement,
                                        &HTMLMediaElement::clearWeakMembers>(
      this);
  Supplementable<HTMLMediaElement>::trace(visitor);
  HTMLElement::trace(visitor);
  SuspendableObject::trace(visitor);
}

bool MockContentSettingsClient::allowPlugins(bool enabled_per_settings) {
  return enabled_per_settings && flags_->plugins_allowed();
}

void HTMLMediaElement::noneSupported() {
  BLINK_MEDIA_LOG << "noneSupported(" << (void*)this << ")";

  stopPeriodicTimers();
  m_loadState = WaitingForSource;
  m_currentSourceNode = nullptr;


  m_error = MediaError::create(MediaError::kMediaErrSrcNotSupported);

  forgetResourceSpecificTracks();

  setNetworkState(kNetworkNoSource);

  updateDisplayState();

  scheduleEvent(EventTypeNames::error);

  scheduleRejectPlayPromises(NotSupportedError);

  closeMediaSource();

  setShouldDelayLoadEvent(false);

  if (layoutObject())
    layoutObject()->updateFromElement();
}

void HTMLMediaElement::didNotifySubtreeInsertionsToDocument() {
  updateControlsVisibility();
}

void HTMLMediaElement::onVisibilityChangedForAutoplay(bool isVisible) {
  if (!isVisible)
    return;

  if (shouldAutoplay()) {
    m_paused = false;
    scheduleEvent(EventTypeNames::play);
    scheduleNotifyPlaying();
    m_autoplaying = false;

    updatePlayState();
  }

  m_autoplayVisibilityObserver->stop();
  m_autoplayVisibilityObserver = nullptr;
}

void HTMLMediaElement::requestSeek(double time) {
  setCurrentTime(time);
}

 void HTMLMediaElement::setNetworkState(NetworkState state) {
  if (m_networkState == state)
    return;

  m_networkState = state;
  if (mediaControls())
    mediaControls()->networkStateChanged();
}

void HTMLMediaElement::startDeferredLoad() {
  if (m_deferredLoadState == WaitingForTrigger) {
    executeDeferredLoad();
    return;
  }
  if (m_deferredLoadState == ExecuteOnStopDelayingLoadEventTask)
    return;
  DCHECK_EQ(m_deferredLoadState, WaitingForStopDelayingLoadEventTask);
  m_deferredLoadState = ExecuteOnStopDelayingLoadEventTask;
}

void HTMLMediaElement::waitForSourceChange() {
  BLINK_MEDIA_LOG << "waitForSourceChange(" << (void*)this << ")";

  stopPeriodicTimers();
  m_loadState = WaitingForSource;

  setNetworkState(kNetworkNoSource);

  setShouldDelayLoadEvent(false);

  updateDisplayState();

  if (layoutObject())
    layoutObject()->updateFromElement();
}

void HTMLMediaElement::selectedVideoTrackChanged(VideoTrack* track) {
  BLINK_MEDIA_LOG << "selectedVideoTrackChanged(" << (void*)this
                  << ") selectedTrackId="
                  << (track->selected() ? String(track->id()) : "none");
  DCHECK(mediaTracksEnabledInternally());

  if (track->selected())
    videoTracks().trackSelected(track->id());

  videoTracks().scheduleChangeEvent();

  if (m_mediaSource)
    m_mediaSource->onTrackChanged(track);

  WebMediaPlayer::TrackId id = track->id();
  webMediaPlayer()->selectedVideoTrackChanged(track->selected() ? &id
                                                                : nullptr);
}

bool HTMLMediaElement::isMediaDataCORSSameOrigin(SecurityOrigin* origin) const {
  return hasSingleSecurityOrigin() &&
         ((webMediaPlayer() && webMediaPlayer()->didPassCORSAccessCheck()) ||
          !origin->taintsCanvas(currentSrc()));
}

void HTMLMediaElement::playbackProgressTimerFired(TimerBase*) {
  if (!std::isnan(m_fragmentEndTime) && currentTime() >= m_fragmentEndTime &&
      getDirectionOfPlayback() == Forward) {
    m_fragmentEndTime = std::numeric_limits<double>::quiet_NaN();
    if (!m_paused) {
      UseCounter::count(document(),
                        UseCounter::HTMLMediaElementPauseAtFragmentEnd);
      pauseInternal();
    }
  }

  if (!m_seeking)
    scheduleTimeupdateEvent(true);

  if (!playbackRate())
    return;

  cueTimeline().updateActiveCues(currentTime());
}

bool HTMLMediaElement::isInteractiveContent() const {
  return fastHasAttribute(controlsAttr);
}

void HTMLMediaElement::startPlayerLoad(const KURL& playerProvidedUrl) {
  DCHECK(!m_webMediaPlayer);

  WebMediaPlayerSource source;
  if (m_srcObject) {
    source = WebMediaPlayerSource(WebMediaStream(m_srcObject));
  } else {
    KURL requestURL =
        playerProvidedUrl.isNull() ? KURL(m_currentSrc) : playerProvidedUrl;
    if (!requestURL.user().isEmpty())
      requestURL.setUser(String());
    if (!requestURL.pass().isEmpty())
      requestURL.setPass(String());

    KURL kurl(ParsedURLString, requestURL);
    source = WebMediaPlayerSource(WebURL(kurl));
  }

  LocalFrame* frame = document().frame();
  if (!frame) {
    mediaLoadingFailed(WebMediaPlayer::NetworkStateFormatError);
    return;
  }

  m_webMediaPlayer =
      frame->loader().client()->createWebMediaPlayer(*this, source, this);
  if (!m_webMediaPlayer) {
    mediaLoadingFailed(WebMediaPlayer::NetworkStateFormatError);
    return;
  }

  if (layoutObject())
    layoutObject()->setShouldDoFullPaintInvalidation();
  m_audioSourceProvider.wrap(m_webMediaPlayer->getAudioSourceProvider());
  m_webMediaPlayer->setVolume(effectiveMediaVolume());

  m_webMediaPlayer->setPoster(posterImageURL());

  m_webMediaPlayer->setPreload(effectivePreloadType());

  m_webMediaPlayer->requestRemotePlaybackDisabled(
      fastHasAttribute(disableremoteplaybackAttr));

  m_webMediaPlayer->load(loadType(), source, corsMode());

  if (isFullscreen())
    m_webMediaPlayer->enteredFullscreen();

  m_webMediaPlayer->becameDominantVisibleContent(m_mostlyFillingViewport);
}

void HTMLMediaElement::startPlaybackProgressTimer() {
  if (m_playbackProgressTimer.isActive())
    return;

  m_previousProgressTime = WTF::currentTime();
  m_playbackProgressTimer.startRepeating(maxTimeupdateEventFrequency,
                                         BLINK_FROM_HERE);
}

DEFINE_TRACE(HTMLMediaElement::AudioClientImpl) {
  visitor->trace(m_client);
}

WebMediaPlayer::CORSMode HTMLMediaElement::corsMode() const {
  const AtomicString& crossOriginMode = fastGetAttribute(crossoriginAttr);
  if (crossOriginMode.isNull())
    return WebMediaPlayer::CORSModeUnspecified;
  if (equalIgnoringCase(crossOriginMode, "use-credentials"))
    return WebMediaPlayer::CORSModeUseCredentials;
  return WebMediaPlayer::CORSModeAnonymous;
}

void HTMLMediaElement::setAudioSourceNode(
    AudioSourceProviderClient* sourceNode) {
  DCHECK(isMainThread());
  m_audioSourceNode = sourceNode;

  AudioSourceProviderClientLockScope scope(*this);
  getAudioSourceProvider().setClient(m_audioSourceNode);
}

void removeElementFromDocumentMap(HTMLMediaElement* element,
                                  Document* document) {
  DocumentElementSetMap& map = documentToElementSetMap();
  auto it = map.find(document);
  DCHECK(it != map.end());
  WeakMediaElementSet* set = it->value;
  set->remove(element);
  if (set->isEmpty())
    map.remove(it);
}

LayoutObject* HTMLMediaElement::createLayoutObject(const ComputedStyle&) {
  return new LayoutMedia(this);
}

void HTMLMediaElement::textTrackModeChanged(TextTrack* track) {
  if (track->trackType() == TextTrack::TrackElement)
    track->setHasBeenConfigured(true);

  configureTextTrackDisplay();

  DCHECK(textTracks()->contains(track));
  textTracks()->scheduleChangeEvent();
}

HTMLMediaElement::NetworkState HTMLMediaElement::getNetworkState() const {
  return m_networkState;
}

bool HTMLMediaElement::isSafeToLoadURL(const KURL& url,
                                       InvalidURLAction actionIfInvalid) {
  if (!url.isValid()) {
    BLINK_MEDIA_LOG << "isSafeToLoadURL(" << (void*)this << ", "
                    << urlForLoggingMedia(url)
                    << ") -> FALSE because url is invalid";
    return false;
  }

  LocalFrame* frame = document().frame();
  if (!frame || !document().getSecurityOrigin()->canDisplay(url)) {
    if (actionIfInvalid == Complain)
      FrameLoader::reportLocalLoadFailed(frame, url.elidedString());
    BLINK_MEDIA_LOG << "isSafeToLoadURL(" << (void*)this << ", "
                    << urlForLoggingMedia(url)
                    << ") -> FALSE rejected by SecurityOrigin";
    return false;
  }

  if (!document().contentSecurityPolicy()->allowMediaFromSource(url)) {
    BLINK_MEDIA_LOG << "isSafeToLoadURL(" << (void*)this << ", "
                    << urlForLoggingMedia(url)
                    << ") -> rejected by Content Security Policy";
    return false;
  }

  return true;
}

void HTMLMediaElement::durationChanged() {
  BLINK_MEDIA_LOG << "durationChanged(" << (void*)this << ")";

  CHECK(m_webMediaPlayer);
  double newDuration = m_webMediaPlayer->duration();

  durationChanged(newDuration, currentPlaybackPosition() > newDuration);
}

void HTMLMediaElement::ensureMediaControls() {
  if (mediaControls())
    return;

  ShadowRoot& shadowRoot = ensureUserAgentShadowRoot();
  m_mediaControls = MediaControls::create(*this, shadowRoot);

  assertShadowRootChildren(shadowRoot);
}

double HTMLMediaElement::earliestPossiblePosition() const {
  TimeRanges* seekableRanges = seekable();
  if (seekableRanges && seekableRanges->length() > 0)
    return seekableRanges->start(0, ASSERT_NO_EXCEPTION);

  return currentPlaybackPosition();
}

HTMLMediaElement::DirectionOfPlayback HTMLMediaElement::getDirectionOfPlayback()
    const {
  return m_playbackRate >= 0 ? Forward : Backward;
}

void HTMLMediaElement::finishSeek() {
  BLINK_MEDIA_LOG << "finishSeek(" << (void*)this << ")";

  m_seeking = false;

  setOfficialPlaybackPosition(currentPlaybackPosition());

  scheduleTimeupdateEvent(false);

  scheduleEvent(EventTypeNames::seeked);

  setDisplayMode(Video);
}

bool HTMLMediaElement::isAutoplayAllowedPerSettings() const {
LocalFrame* frame = document().frame();
if (!frame)
return false;
FrameLoaderClient* frameLoaderClient = frame->loader().client();
  return frameLoaderClient && frameLoaderClient->allowAutoplay(false);
}

void HTMLMediaElement::setPlayerPreload() {
  if (m_webMediaPlayer)
    m_webMediaPlayer->setPreload(effectivePreloadType());

  if (loadIsDeferred() && effectivePreloadType() != WebMediaPlayer::PreloadNone)
    startDeferredLoad();
}

void HTMLMediaElement::setIgnorePreloadNone() {
  BLINK_MEDIA_LOG << "setIgnorePreloadNone(" << (void*)this << ")";
  m_ignorePreloadNone = true;
  setPlayerPreload();
}

void HTMLMediaElement::removeTextTrack(WebInbandTextTrack* webTrack) {
  if (!m_textTracks)
    return;

  InbandTextTrack* textTrack = toInbandTextTrack(webTrack->client());
  if (!textTrack)
    return;

  m_textTracks->remove(textTrack);
}

void HTMLMediaElement::progressEventTimerFired(TimerBase*) {
  if (m_networkState != kNetworkLoading)
    return;

  double time = WTF::currentTime();
  double timedelta = time - m_previousProgressTime;

  if (webMediaPlayer() && webMediaPlayer()->didLoadingProgress()) {
    scheduleEvent(EventTypeNames::progress);
    m_previousProgressTime = time;
    m_sentStalledEvent = false;
    if (layoutObject())
      layoutObject()->updateFromElement();
  } else if (timedelta > 3.0 && !m_sentStalledEvent) {
    scheduleEvent(EventTypeNames::stalled);
    m_sentStalledEvent = true;
    setShouldDelayLoadEvent(false);
  }
}

void HTMLMediaElement::forgetResourceSpecificTracks() {
  if (m_textTracks) {
    TrackDisplayUpdateScope scope(this->cueTimeline());
    m_textTracks->removeAllInbandTracks();
  }

  m_audioTracks->removeAll();
  m_videoTracks->removeAll();

  m_audioTracksTimer.stop();
}

void HTMLMediaElement::cancelledRemotePlaybackRequest() {
  if (remotePlaybackClient())
    remotePlaybackClient()->promptCancelled();
}

bool MockContentSettingsClient::allowScript(bool enabled_per_settings) {
  return enabled_per_settings && flags_->scripts_allowed();
}

bool HTMLMediaElement::stoppedDueToErrors() const {
  if (m_readyState >= kHaveMetadata && m_error) {
    TimeRanges* seekableRanges = seekable();
    if (!seekableRanges->contain(currentTime()))
      return true;
  }

  return false;
}

Node::InsertionNotificationRequest HTMLMediaElement::insertedInto(
    ContainerNode* insertionPoint) {
  BLINK_MEDIA_LOG << "insertedInto(" << (void*)this << ", " << insertionPoint
                  << ")";

  HTMLElement::insertedInto(insertionPoint);
  if (insertionPoint->isConnected()) {
    UseCounter::count(document(), UseCounter::HTMLMediaElementInDocument);
    if ((!getAttribute(srcAttr).isEmpty() || m_srcObject) &&
        m_networkState == kNetworkEmpty) {
      m_ignorePreloadNone = false;
      invokeLoadAlgorithm();
    }
  }

  return InsertionShouldCallDidNotifySubtreeInsertions;
}

bool HTMLMediaElement::isMouseFocusable() const {
  return false;
}

String HTMLMediaElement::effectivePreload() const {
  return preloadTypeToString(effectivePreloadType());
}

void HTMLMediaElement::setNetworkState(WebMediaPlayer::NetworkState state) {
  BLINK_MEDIA_LOG << "setNetworkState(" << (void*)this << ", "
                  << static_cast<int>(state) << ") - current state is "
                  << static_cast<int>(m_networkState);

  if (state == WebMediaPlayer::NetworkStateEmpty) {
    setNetworkState(kNetworkEmpty);
    return;
  }

  if (state == WebMediaPlayer::NetworkStateFormatError ||
      state == WebMediaPlayer::NetworkStateNetworkError ||
      state == WebMediaPlayer::NetworkStateDecodeError) {
    mediaLoadingFailed(state);
    return;
  }

  if (state == WebMediaPlayer::NetworkStateIdle) {
    if (m_networkState > kNetworkIdle) {
      changeNetworkStateFromLoadingToIdle();
      setShouldDelayLoadEvent(false);
    } else {
      setNetworkState(kNetworkIdle);
    }
  }

  if (state == WebMediaPlayer::NetworkStateLoading) {
    if (m_networkState < kNetworkLoading || m_networkState == kNetworkNoSource)
      startProgressEventTimer();
    setNetworkState(kNetworkLoading);
  }

  if (state == WebMediaPlayer::NetworkStateLoaded) {
    if (m_networkState != kNetworkIdle)
      changeNetworkStateFromLoadingToIdle();
  }
}

void HTMLMediaElement::clearWeakMembers(Visitor* visitor) {
  if (!ThreadHeap::isHeapObjectAlive(m_audioSourceNode)) {
    getAudioSourceProvider().setClient(nullptr);
    m_audioSourceNode = nullptr;
  }
}

void HTMLMediaElement::scheduleEvent(Event* event) {
#if LOG_MEDIA_EVENTS
  BLINK_MEDIA_LOG << "scheduleEvent(" << (void*)this << ")"
                  << " - scheduling '" << event->type() << "'";
#endif
  m_asyncEventQueue->enqueueEvent(event);
}

  ~AudioSourceProviderClientLockScope() {
    if (m_client)
      m_client->unlock();
  }

void HTMLMediaElement::AudioClientImpl::setFormat(size_t numberOfChannels,
                                                  float sampleRate) {
  if (m_client)
    m_client->setFormat(numberOfChannels, sampleRate);
}

void HTMLMediaElement::setReadyState(ReadyState state) {
  BLINK_MEDIA_LOG << "setReadyState(" << (void*)this << ", "
                  << static_cast<int>(state) << ") - current state is "
                  << static_cast<int>(m_readyState);

  bool wasPotentiallyPlaying = potentiallyPlaying();

  ReadyState oldState = m_readyState;
  ReadyState newState = state;

  bool tracksAreReady = textTracksAreReady();

  if (newState == oldState && m_tracksAreReady == tracksAreReady)
    return;

  m_tracksAreReady = tracksAreReady;

  if (tracksAreReady) {
    m_readyState = newState;
  } else {
    if (newState <= kHaveMetadata)
      m_readyState = newState;
    else
      m_readyState = kHaveCurrentData;
  }

  if (oldState > m_readyStateMaximum)
    m_readyStateMaximum = oldState;

  if (m_networkState == kNetworkEmpty)
    return;

  if (m_seeking) {
    if (wasPotentiallyPlaying && m_readyState < kHaveFutureData)
      scheduleEvent(EventTypeNames::waiting);

    if (m_readyState >= kHaveCurrentData)
      finishSeek();
  } else {
    if (wasPotentiallyPlaying && m_readyState < kHaveFutureData) {
      setOfficialPlaybackPosition(currentPlaybackPosition());

      scheduleTimeupdateEvent(false);
      scheduleEvent(EventTypeNames::waiting);
    }
  }

  if (m_readyState >= kHaveMetadata && oldState < kHaveMetadata) {
    createPlaceholderTracksIfNecessary();

    selectInitialTracksIfNecessary();

    MediaFragmentURIParser fragmentParser(m_currentSrc);
    m_fragmentEndTime = fragmentParser.endTime();

    setOfficialPlaybackPosition(earliestPossiblePosition());

    m_duration = m_webMediaPlayer->duration();
    scheduleEvent(EventTypeNames::durationchange);

    if (isHTMLVideoElement())
      scheduleEvent(EventTypeNames::resize);
    scheduleEvent(EventTypeNames::loadedmetadata);

    bool jumped = false;
    if (m_defaultPlaybackStartPosition > 0) {
      seek(m_defaultPlaybackStartPosition);
      jumped = true;
    }
    m_defaultPlaybackStartPosition = 0;

    double initialPlaybackPosition = fragmentParser.startTime();
    if (std::isnan(initialPlaybackPosition))
      initialPlaybackPosition = 0;

    if (!jumped && initialPlaybackPosition > 0) {
      UseCounter::count(document(),
                        UseCounter::HTMLMediaElementSeekToFragmentStart);
      seek(initialPlaybackPosition);
      jumped = true;
    }

    if (layoutObject())
      layoutObject()->updateFromElement();
  }

  bool shouldUpdateDisplayState = false;

  if (m_readyState >= kHaveCurrentData && oldState < kHaveCurrentData &&
      !m_haveFiredLoadedData) {
    setOfficialPlaybackPosition(currentPlaybackPosition());

    m_haveFiredLoadedData = true;
    shouldUpdateDisplayState = true;
    scheduleEvent(EventTypeNames::loadeddata);
    setShouldDelayLoadEvent(false);
  }

  bool isPotentiallyPlaying = potentiallyPlaying();
  if (m_readyState == kHaveFutureData && oldState <= kHaveCurrentData &&
      tracksAreReady) {
    scheduleEvent(EventTypeNames::canplay);
    if (isPotentiallyPlaying)
      scheduleNotifyPlaying();
    shouldUpdateDisplayState = true;
  }

  if (m_readyState == kHaveEnoughData && oldState < kHaveEnoughData &&
      tracksAreReady) {
    if (oldState <= kHaveCurrentData) {
      scheduleEvent(EventTypeNames::canplay);
      if (isPotentiallyPlaying)
        scheduleNotifyPlaying();
    }

    if (shouldAutoplay()) {
      m_autoplayUmaHelper->onAutoplayInitiated(AutoplaySource::Attribute);

      if (!isGestureNeededForPlayback()) {
        if (isGestureNeededForPlaybackIfCrossOriginExperimentEnabled()) {
          m_autoplayUmaHelper->recordCrossOriginAutoplayResult(
              CrossOriginAutoplayResult::AutoplayBlocked);
        } else {
          m_autoplayUmaHelper->recordCrossOriginAutoplayResult(
              CrossOriginAutoplayResult::AutoplayAllowed);
        }
        if (isHTMLVideoElement() && muted() &&
            RuntimeEnabledFeatures::autoplayMutedVideosEnabled()) {
          if (!m_autoplayVisibilityObserver) {
            m_autoplayVisibilityObserver = new ElementVisibilityObserver(
                this,
                WTF::bind(&HTMLMediaElement::onVisibilityChangedForAutoplay,
                          wrapWeakPersistent(this)));
            m_autoplayVisibilityObserver->start();
          }
        } else {
          m_paused = false;
          scheduleEvent(EventTypeNames::play);
          scheduleNotifyPlaying();
          m_autoplaying = false;
        }
      } else {
        m_autoplayUmaHelper->recordCrossOriginAutoplayResult(
            CrossOriginAutoplayResult::AutoplayBlocked);
      }
    }

    scheduleEvent(EventTypeNames::canplaythrough);

    shouldUpdateDisplayState = true;
  }

  if (shouldUpdateDisplayState)
    updateDisplayState();

  updatePlayState();
  cueTimeline().updateActiveCues(currentTime());
}

void HTMLMediaElement::didRemoveTrackElement(HTMLTrackElement* trackElement) {
  KURL url = trackElement->getNonEmptyURLAttribute(srcAttr);
  BLINK_MEDIA_LOG << "didRemoveTrackElement(" << (void*)this << ") - 'src' is "
                  << urlForLoggingMedia(url);

  TextTrack* textTrack = trackElement->track();
  if (!textTrack)
    return;

  textTrack->setHasBeenConfigured(false);

  if (!m_textTracks)
    return;

  m_textTracks->remove(textTrack);

  size_t index = m_textTracksWhenResourceSelectionBegan.find(textTrack);
  if (index != kNotFound)
    m_textTracksWhenResourceSelectionBegan.remove(index);
}

bool HTMLMediaElement::loadIsDeferred() const {
  return m_deferredLoadState != NotDeferred;
}

void HTMLMediaElement::updatePlayState() {
  bool isPlaying = webMediaPlayer() && !webMediaPlayer()->paused();
  bool shouldBePlaying = potentiallyPlaying();

  BLINK_MEDIA_LOG << "updatePlayState(" << (void*)this
                  << ") - shouldBePlaying = " << boolString(shouldBePlaying)
                  << ", isPlaying = " << boolString(isPlaying);

  if (shouldBePlaying) {
    setDisplayMode(Video);

    if (!isPlaying) {
      webMediaPlayer()->setRate(playbackRate());
      webMediaPlayer()->setVolume(effectiveMediaVolume());
      webMediaPlayer()->play();
    }

    startPlaybackProgressTimer();
    m_playing = true;
  } else {  // Should not be playing right now
    if (isPlaying) {
      webMediaPlayer()->pause();
    }

    m_playbackProgressTimer.stop();
    m_playing = false;
    double time = currentTime();
    if (time > m_lastSeekTime)
      addPlayedRange(m_lastSeekTime, time);
  }

  if (layoutObject())
    layoutObject()->updateFromElement();
}

void HTMLMediaElement::rejectScheduledPlayPromises() {
  DCHECK(m_playPromiseErrorCode == AbortError ||
         m_playPromiseErrorCode == NotSupportedError);
  if (m_playPromiseErrorCode == AbortError)
    rejectPlayPromisesInternal(
        AbortError, "The play() request was interrupted by a call to pause().");
  else
    rejectPlayPromisesInternal(
        NotSupportedError,
        "Failed to load because no supported source was found.");
}

void HTMLMediaElement::requireOfficialPlaybackPositionUpdate() const {
  m_officialPlaybackPositionNeedsUpdate = true;
}

DEFINE_TRACE(HTMLMediaElement::AudioSourceProviderImpl) {
  visitor->trace(m_client);
}

void HTMLMediaElement::removeAudioTrack(WebMediaPlayer::TrackId trackId) {
  BLINK_MEDIA_LOG << "removeAudioTrack(" << (void*)this << ")";

  audioTracks().remove(trackId);
}

unsigned HTMLMediaElement::webkitVideoDecodedByteCount() const {
  if (!webMediaPlayer())
    return 0;
  return webMediaPlayer()->videoDecodedByteCount();
}

const char* boolString(bool val) {
  return val ? "true" : "false";
}

void HTMLMediaElement::closeMediaSource() {
  if (!m_mediaSource)
    return;

  m_mediaSource->close();
  m_mediaSource = nullptr;
}

void HTMLMediaElement::mediaControlsDidBecomeVisible() {
  BLINK_MEDIA_LOG << "mediaControlsDidBecomeVisible(" << (void*)this << ")";

  if (isHTMLVideoElement() && textTracksVisible())
    ensureTextTrackContainer().updateDisplay(
        *this, TextTrackContainer::DidStartExposingControls);
}

void HTMLMediaElement::connectedToRemoteDevice() {
  m_playingRemotely = true;
  if (remotePlaybackClient())
    remotePlaybackClient()->stateChanged(WebRemotePlaybackState::Connecting);

  if (mediaControls())
    mediaControls()->onRemotePlaybackConnecting();
}

CueTimeline& HTMLMediaElement::cueTimeline() {
  if (!m_cueTimeline)
    m_cueTimeline = new CueTimeline(*this);
  return *m_cueTimeline;
}

void HTMLMediaElement::loadTimerFired(TimerBase*) {
  if (m_pendingActionFlags & LoadTextTrackResource)
    honorUserPreferencesForAutomaticTextTrackSelection();

  if (m_pendingActionFlags & LoadMediaResource) {
    if (m_loadState == LoadingFromSourceElement)
      loadNextSourceChild();
    else
      loadInternal();
  }

  m_pendingActionFlags = 0;
}

void HTMLMediaElement::removedFrom(ContainerNode* insertionPoint) {
  BLINK_MEDIA_LOG << "removedFrom(" << (void*)this << ", " << insertionPoint
                  << ")";

  HTMLElement::removedFrom(insertionPoint);
  if (insertionPoint->inActiveDocument()) {
    updateControlsVisibility();
    if (m_networkState > kNetworkEmpty)
      pauseInternal();
  }
}

void HTMLMediaElement::cancelDeferredLoad() {
  m_deferredLoadTimer.stop();
  m_deferredLoadState = NotDeferred;
}

void HTMLMediaElement::sourceWasRemoved(HTMLSourceElement* source) {
  BLINK_MEDIA_LOG << "sourceWasRemoved(" << (void*)this << ", " << source
                  << ")";

  KURL url = source->getNonEmptyURLAttribute(srcAttr);
  BLINK_MEDIA_LOG << "sourceWasRemoved(" << (void*)this << ") - 'src' is "
                  << urlForLoggingMedia(url);

  if (source != m_currentSourceNode && source != m_nextChildNodeToConsider)
    return;

  if (source == m_nextChildNodeToConsider) {
    if (m_currentSourceNode)
      m_nextChildNodeToConsider = m_currentSourceNode->nextSibling();
    BLINK_MEDIA_LOG << "sourceWasRemoved(" << (void*)this
                    << ") - m_nextChildNodeToConsider set to "
                    << m_nextChildNodeToConsider.get();
  } else if (source == m_currentSourceNode) {
    m_currentSourceNode = nullptr;
    BLINK_MEDIA_LOG << "sourceWasRemoved(" << (void*)this
                    << ") - m_currentSourceNode set to 0";
  }
}

void HTMLMediaElement::scheduleTextTrackResourceLoad() {
  BLINK_MEDIA_LOG << "scheduleTextTrackResourceLoad(" << (void*)this << ")";

  m_pendingActionFlags |= LoadTextTrackResource;

  if (!m_loadTimer.isActive())
    m_loadTimer.startOneShot(0, BLINK_FROM_HERE);
}

void HTMLMediaElement::videoWillBeDrawnToCanvas() const {
  DCHECK(isHTMLVideoElement());
  UseCounter::count(document(), UseCounter::VideoInCanvas);
  if (m_autoplayUmaHelper->hasSource() && !m_autoplayUmaHelper->isVisible())
    UseCounter::count(document(), UseCounter::HiddenAutoplayedVideoInCanvas);
}

void HTMLMediaElement::mediaEngineError(MediaError* err) {
  DCHECK_GE(m_readyState, kHaveMetadata);
  BLINK_MEDIA_LOG << "mediaEngineError(" << (void*)this << ", "
                  << static_cast<int>(err->code()) << ")";

  stopPeriodicTimers();
  m_loadState = WaitingForSource;

  m_error = err;

  scheduleEvent(EventTypeNames::error);

  setNetworkState(kNetworkIdle);

  setShouldDelayLoadEvent(false);

  m_currentSourceNode = nullptr;
}

void HTMLMediaElement::loadSourceFromAttribute() {
  m_loadState = LoadingFromSrcAttr;
  const AtomicString& srcValue = fastGetAttribute(srcAttr);

  if (srcValue.isEmpty()) {
    mediaLoadingFailed(WebMediaPlayer::NetworkStateFormatError);
    BLINK_MEDIA_LOG << "loadSourceFromAttribute(" << (void*)this
                    << "), empty 'src'";
    return;
  }

  KURL mediaURL = document().completeURL(srcValue);
  if (!isSafeToLoadURL(mediaURL, Complain)) {
    mediaLoadingFailed(WebMediaPlayer::NetworkStateFormatError);
    return;
  }

  loadResource(WebMediaPlayerSource(WebURL(mediaURL)), ContentType((String())));
}

bool MockContentSettingsClient::allowScriptFromSource(
    bool enabled_per_settings,
    const blink::WebURL& script_url) {
  bool allowed = enabled_per_settings && flags_->scripts_allowed();
  if (flags_->dump_web_content_settings_client_callbacks() && delegate_) {
    delegate_->PrintMessage(
        std::string("MockContentSettingsClient: allowScriptFromSource(") +
        NormalizeLayoutTestURL(script_url.string().utf8()) + "): " +
        (allowed ? "true" : "false") + "\n");
  }
  return allowed;
}

void HTMLMediaElement::viewportFillDebouncerTimerFired(TimerBase*) {
  m_mostlyFillingViewport = true;
  if (m_webMediaPlayer)
    m_webMediaPlayer->becameDominantVisibleContent(m_mostlyFillingViewport);
}

bool HTMLMediaElement::textTracksVisible() const {
  return m_textTracksVisible;
}

void HTMLMediaElement::setLoop(bool b) {
  BLINK_MEDIA_LOG << "setLoop(" << (void*)this << ", " << boolString(b) << ")";
  setBooleanAttribute(loopAttr, b);
}

bool HTMLMediaElement::muted() const {
  return m_muted;
}

bool HTMLMediaElement::seeking() const {
  return m_seeking;
}

void HTMLMediaElement::rejectPlayPromisesInternal(ExceptionCode code,
                                                  const String& message) {
  DCHECK(code == AbortError || code == NotSupportedError);

  for (auto& resolver : m_playPromiseRejectList)
    resolver->reject(DOMException::create(code, message));

  m_playPromiseRejectList.clear();
}

void HTMLMediaElement::didMoveToNewDocument(Document& oldDocument) {
  BLINK_MEDIA_LOG << "didMoveToNewDocument(" << (void*)this << ")";

  m_loadTimer.moveToNewTaskRunner(
      TaskRunnerHelper::get(TaskType::Unthrottled, &document()));
  m_progressEventTimer.moveToNewTaskRunner(
      TaskRunnerHelper::get(TaskType::Unthrottled, &document()));
  m_playbackProgressTimer.moveToNewTaskRunner(
      TaskRunnerHelper::get(TaskType::Unthrottled, &document()));
  m_audioTracksTimer.moveToNewTaskRunner(
      TaskRunnerHelper::get(TaskType::Unthrottled, &document()));
  m_viewportFillDebouncerTimer.moveToNewTaskRunner(
      TaskRunnerHelper::get(TaskType::Unthrottled, &document()));
  m_checkViewportIntersectionTimer.moveToNewTaskRunner(
      TaskRunnerHelper::get(TaskType::Unthrottled, &document()));

  m_autoplayUmaHelper->didMoveToNewDocument(oldDocument);
  bool oldDocumentRequiresUserGesture =
      computeLockedPendingUserGesture(oldDocument);
  bool newDocumentRequiresUserGesture =
      computeLockedPendingUserGesture(document());
  if (newDocumentRequiresUserGesture && !oldDocumentRequiresUserGesture)
    m_lockedPendingUserGesture = true;

  if (m_shouldDelayLoadEvent) {
    document().incrementLoadEventDelayCount();
  } else {
    oldDocument.incrementLoadEventDelayCount();
  }

  if (isDocumentCrossOrigin(document()) && !isDocumentCrossOrigin(oldDocument))
    m_lockedPendingUserGestureIfCrossOriginExperimentEnabled = true;

  removeElementFromDocumentMap(this, &oldDocument);
  addElementToDocumentMap(this, &document());

  m_ignorePreloadNone = false;
  invokeLoadAlgorithm();

  oldDocument.decrementLoadEventDelayCount();

  SuspendableObject::didMoveToNewExecutionContext(&document());
  HTMLElement::didMoveToNewDocument(oldDocument);
}

void HTMLMediaElement::checkViewportIntersectionTimerFired(TimerBase*) {
  bool shouldReportRootBounds = true;
  IntersectionGeometry geometry(nullptr, *this, Vector<Length>(),
                                shouldReportRootBounds);
  geometry.computeGeometry();
  IntRect intersectRect = geometry.intersectionIntRect();
  if (m_currentIntersectRect == intersectRect)
    return;

  m_currentIntersectRect = intersectRect;
  m_viewportFillDebouncerTimer.stop();
  bool isMostlyFillingViewport =
      (m_currentIntersectRect.size().area() >
       kMostlyFillViewportThreshold * geometry.rootIntRect().size().area());
  if (m_mostlyFillingViewport == isMostlyFillingViewport)
    return;

  if (!isMostlyFillingViewport) {
    m_mostlyFillingViewport = isMostlyFillingViewport;
    if (m_webMediaPlayer)
      m_webMediaPlayer->becameDominantVisibleContent(m_mostlyFillingViewport);
    return;
  }

  m_viewportFillDebouncerTimer.startOneShot(
      kMostlyFillViewportBecomeStableSeconds, BLINK_FROM_HERE);
}

void HTMLMediaElement::setShouldDelayLoadEvent(bool shouldDelay) {
  if (m_shouldDelayLoadEvent == shouldDelay)
    return;

  BLINK_MEDIA_LOG << "setShouldDelayLoadEvent(" << (void*)this << ", "
                  << boolString(shouldDelay) << ")";

  m_shouldDelayLoadEvent = shouldDelay;
  if (shouldDelay)
    document().incrementLoadEventDelayCount();
  else
    document().decrementLoadEventDelayCount();
}

bool MockContentSettingsClient::allowImage(bool enabled_per_settings,
                                           const blink::WebURL& image_url) {
  bool allowed = enabled_per_settings && flags_->images_allowed();
  if (flags_->dump_web_content_settings_client_callbacks() && delegate_) {
    delegate_->PrintMessage(
        std::string("MockContentSettingsClient: allowImage(") +
        NormalizeLayoutTestURL(image_url.string().utf8()) +
        "): " + (allowed ? "true" : "false") + "\n");
  }
  return allowed;
}

void HTMLMediaElement::invokeResourceSelectionAlgorithm() {
  BLINK_MEDIA_LOG << "invokeResourceSelectionAlgorithm(" << (void*)this << ")";
  setNetworkState(kNetworkNoSource);


  m_playedTimeRanges = TimeRanges::create();

  m_lastSeekTime = 0;
  m_duration = std::numeric_limits<double>::quiet_NaN();

  setShouldDelayLoadEvent(true);
  if (mediaControls())
    mediaControls()->reset();

  scheduleNextSourceChild();
}

void HTMLMediaElement::setDefaultPlaybackRate(double rate) {
  if (m_defaultPlaybackRate == rate)
    return;

  m_defaultPlaybackRate = rate;
  scheduleEvent(EventTypeNames::ratechange);
}

void HTMLMediaElement::seek(double time) {
  BLINK_MEDIA_LOG << "seek(" << (void*)this << ", " << time << ")";

  if (!m_webMediaPlayer || m_readyState == kHaveNothing)
    return;

  setIgnorePreloadNone();

  double now = currentTime();


  m_seeking = true;

  time = std::min(time, duration());

  time = std::max(time, earliestPossiblePosition());

  double mediaTime = webMediaPlayer()->mediaTimeForTimeValue(time);
  if (time != mediaTime) {
    BLINK_MEDIA_LOG << "seek(" << (void*)this << ", " << time
                    << ") - media timeline equivalent is " << mediaTime;
    time = mediaTime;
  }

  TimeRanges* seekableRanges = seekable();

  if (!seekableRanges->length()) {
    m_seeking = false;
    return;
  }
  time = seekableRanges->nearest(time, now);

  if (m_playing && m_lastSeekTime < now)
    addPlayedRange(m_lastSeekTime, now);

  m_lastSeekTime = time;

  scheduleEvent(EventTypeNames::seeking);

  webMediaPlayer()->seek(time);

}

void HTMLMediaElement::parseAttribute(
    const AttributeModificationParams& params) {
  const QualifiedName& name = params.name;
  if (name == srcAttr) {
    BLINK_MEDIA_LOG << "parseAttribute(" << (void*)this
                    << ", srcAttr, old=" << params.oldValue
                    << ", new=" << params.newValue << ")";
    if (!params.newValue.isNull()) {
      m_ignorePreloadNone = false;
      invokeLoadAlgorithm();
    }
  } else if (name == controlsAttr) {
    UseCounter::count(document(),
                      UseCounter::HTMLMediaElementControlsAttribute);
    updateControlsVisibility();
  } else if (name == preloadAttr) {
    setPlayerPreload();
  } else if (name == disableremoteplaybackAttr) {
    UseCounter::count(document(), UseCounter::DisableRemotePlaybackAttribute);
    if (params.oldValue != params.newValue) {
      if (m_webMediaPlayer) {
        m_webMediaPlayer->requestRemotePlaybackDisabled(
            !params.newValue.isNull());
      }
      if (mediaControls())
        mediaControls()->onDisableRemotePlaybackAttributeChanged();
    }
  } else {
    HTMLElement::parseAttribute(params);
  }
}

void HTMLMediaElement::cancelPendingEventsAndCallbacks() {
  BLINK_MEDIA_LOG << "cancelPendingEventsAndCallbacks(" << (void*)this << ")";
  m_asyncEventQueue->cancelAllEvents();

  for (HTMLSourceElement* source =
           Traversal<HTMLSourceElement>::firstChild(*this);
       source; source = Traversal<HTMLSourceElement>::nextSibling(*source))
    source->cancelPendingErrorEvent();
}

void HTMLMediaElement::disconnectedFromRemoteDevice() {
  m_playingRemotely = false;
  if (remotePlaybackClient())
    remotePlaybackClient()->stateChanged(WebRemotePlaybackState::Disconnected);

  if (mediaControls())
    mediaControls()->onRemotePlaybackDisconnected();
}

void HTMLMediaElement::deferredLoadTimerFired(TimerBase*) {
  setShouldDelayLoadEvent(false);

  if (m_deferredLoadState == ExecuteOnStopDelayingLoadEventTask) {
    executeDeferredLoad();
    return;
  }
  DCHECK_EQ(m_deferredLoadState, WaitingForStopDelayingLoadEventTask);
  m_deferredLoadState = WaitingForTrigger;
}

void HTMLMediaElement::sourceWasAdded(HTMLSourceElement* source) {
  BLINK_MEDIA_LOG << "sourceWasAdded(" << (void*)this << ", " << source << ")";

  KURL url = source->getNonEmptyURLAttribute(srcAttr);
  BLINK_MEDIA_LOG << "sourceWasAdded(" << (void*)this << ") - 'src' is "
                  << urlForLoggingMedia(url);

  if (fastHasAttribute(srcAttr))
    return;

  if (getNetworkState() == HTMLMediaElement::kNetworkEmpty) {
    invokeResourceSelectionAlgorithm();
    m_nextChildNodeToConsider = source;
    return;
  }

  if (m_currentSourceNode && source == m_currentSourceNode->nextSibling()) {
    BLINK_MEDIA_LOG << "sourceWasAdded(" << (void*)this
                    << ") - <source> inserted immediately after current source";
    m_nextChildNodeToConsider = source;
    return;
  }

  if (m_nextChildNodeToConsider)
    return;

  if (m_loadState != WaitingForSource)
    return;

  setShouldDelayLoadEvent(true);

  setNetworkState(kNetworkLoading);

  m_nextChildNodeToConsider = source;
  scheduleNextSourceChild();
}

void HTMLMediaElement::scheduleNextSourceChild() {
  m_pendingActionFlags |= LoadMediaResource;
  m_loadTimer.startOneShot(0, BLINK_FROM_HERE);
}

void HTMLMediaElement::pauseInternal() {
  BLINK_MEDIA_LOG << "pauseInternal(" << (void*)this << ")";

  if (m_networkState == kNetworkEmpty)
    invokeResourceSelectionAlgorithm();

  m_autoplaying = false;

  if (!m_paused) {
    m_paused = true;
    scheduleTimeupdateEvent(false);
    scheduleEvent(EventTypeNames::pause);

    setOfficialPlaybackPosition(currentPlaybackPosition());

    scheduleRejectPlayPromises(AbortError);
  }

  updatePlayState();
}

void HTMLMediaElement::scheduleEvent(const AtomicString& eventName) {
  scheduleEvent(Event::createCancelable(eventName));
}

    clearMediaPlayerAndAudioSourceProviderClientWithoutLocking() {
  getAudioSourceProvider().setClient(nullptr);
  if (m_webMediaPlayer) {
    m_audioSourceProvider.wrap(nullptr);
    m_webMediaPlayer.reset();
  }
}

void HTMLMediaElement::attachLayoutTree(const AttachContext& context) {
  HTMLElement::attachLayoutTree(context);

  if (layoutObject())
    layoutObject()->updateFromElement();
}

 void MockContentSettingsClient::SetDelegate(WebTestDelegate* delegate) {
  delegate_ = delegate;
}

void HTMLMediaElement::AudioSourceProviderImpl::provideInput(
    AudioBus* bus,
    size_t framesToProcess) {
  DCHECK(bus);

  MutexTryLocker tryLocker(provideInputLock);
  if (!tryLocker.locked() || !m_webAudioSourceProvider || !m_client.get()) {
    bus->zero();
    return;
  }

  size_t n = bus->numberOfChannels();
  WebVector<float*> webAudioData(n);
  for (size_t i = 0; i < n; ++i)
    webAudioData[i] = bus->channel(i)->mutableData();

  m_webAudioSourceProvider->provideInput(webAudioData, framesToProcess);
}

VideoTrackList& HTMLMediaElement::videoTracks() {
  return *m_videoTracks;
}

void HTMLMediaElement::didAddTrackElement(HTMLTrackElement* trackElement) {
  TextTrack* textTrack = trackElement->track();
  if (!textTrack)
    return;

  textTracks()->append(textTrack);

  if (isFinishedParsingChildren())
    scheduleTextTrackResourceLoad();
}
