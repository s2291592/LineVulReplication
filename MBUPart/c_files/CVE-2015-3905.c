error(const char *message, ...)
{
  va_list val;
  va_start(val, message);
  fprintf(stderr, "%s: ", program_name);
  vfprintf(stderr, message, val);
  putc('\n', stderr);
  va_end(val);
}

static byte eencrypt(byte plain)
{
  byte cipher;

  cipher = (byte)(plain ^ (er >> 8));
  er = (uint16_t)((cipher + er) * c1 + c2);
  return cipher;
}

fatal_error(const char *message, ...)
{
  va_list val;
  va_start(val, message);
  fprintf(stderr, "%s: ", program_name);
  vfprintf(stderr, message, val);
  putc('\n', stderr);
  va_end(val);
  exit(1);
}

static void charstring_start(void)
{
  int i;

  if (!charstring_buf) {
    charstring_bufsiz = 65536;
    if (!(charstring_buf = (byte *) malloc(charstring_bufsiz)))
      fatal_error("out of memory");
  }

  charstring_bp = charstring_buf;
  cr = 4330;
  for (i = 0; i < lenIV; i++)
    *charstring_bp++ = cencrypt((byte) 0);
}

static int is_integer(char *string)
{
  if (isdigit(string[0]) || string[0] == '-' || string[0] == '+') {
    while (*++string && isdigit(*string))
;                                           /* deliberately empty */
if (!*string)
return 1;
}
return 0;
}

static int CDECL command_compare(const void *key, const void *item)
{
  return strcmp((const char *) key, ((const struct command *) item)->name);
}

static void charstring_byte(int v)
{
  byte b = (byte)(v & 0xff);
  if (charstring_bp - charstring_buf == charstring_bufsiz) {
    charstring_bufsiz *= 2;
    if (!(charstring_buf = (byte *) realloc(charstring_buf, charstring_bufsiz)))
      fatal_error("out of memory");
    charstring_bp = charstring_buf + charstring_bufsiz / 2;
  }
  *charstring_bp++ = cencrypt(b);
}

static void eexec_end(void)
{
  int i, j;

  if (!pfb)
    putc('\n', ofp);
  else if (w.blocktyp != PFB_ASCII) {
    pfb_writer_output_block(&w);
    w.blocktyp = PFB_ASCII;
  }

  in_eexec = active = 0;

  for (i = 0; i < 8; i++) {
    for (j = 0; j < 64; j++)
      eexec_byte('0');
    eexec_byte('\n');
  }
}

static byte cencrypt(byte plain)
{
  byte cipher;

  /* Thanks to Tom Kacvinsky <tjk@ams.org> who reported that lenIV == -1 means
     unencrypted charstrings. */
  if (lenIV < 0) return plain;

  cipher = (byte)(plain ^ (cr >> 8));
  cr = (uint16_t)((cipher + cr) * c1 + c2);
  return cipher;
}

static void get_charstring_token(void)
{
  int c = getc(ifp);
  while (isspace(c))
    c = getc(ifp);

  if (c == '%') {
    while (c != EOF && c != '\r' && c != '\n')
      c = getc(ifp);
    get_charstring_token();

  } else if (c == '}') {
    line[0] = '}';

static void eexec_string(const char *string)
{
  while (*string)
    eexec_byte(*string++);
}

static void charstring_int(int num)
{
  int x;

  if (num >= -107 && num <= 107) {
    charstring_byte(num + 139);
  } else if (num >= 108 && num <= 1131) {
    x = num - 108;
    charstring_byte(x / 256 + 247);
    charstring_byte(x % 256);
  } else if (num >= -1131 && num <= -108) {
    x = abs(num) - 108;
    charstring_byte(x / 256 + 251);
    charstring_byte(x % 256);
  } else if (num >= (-2147483647-1) && num <= 2147483647) {
    charstring_byte(255);
    charstring_byte(num >> 24);
    charstring_byte(num >> 16);
    charstring_byte(num >> 8);
    charstring_byte(num);
  } else {
    error("can't format huge number `%d'", num);
    /* output 0 instead */
    charstring_byte(139);
  }
}

static int check_line_charstring(void)
{
char *p = line;
  while (isspace(*p))
p++;
return (*p == '/' || (p[0] == 'd' && p[1] == 'u' && p[2] == 'p'));
}
