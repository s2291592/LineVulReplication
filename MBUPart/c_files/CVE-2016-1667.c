void QuicStreamHost::set_proxy(base::WeakPtr<QuicStreamProxy> stream_proxy) {
  DETACH_FROM_THREAD(thread_checker_);
  stream_proxy_ = stream_proxy;
}

  void RunUntilCallbacksFired() {
    while (callback_counter_ != 0) {
      ASSERT_GT(task_runner_->GetPostedTasks().size(), 0u);
      task_runner_->RunNextTask();
    }
  }

void QuicStreamHost::Reset() {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
  DCHECK(p2p_stream_);
  p2p_stream_->Reset();
   Delete();
 }

  scoped_refptr<net::test::TestTaskRunner> runner() { return runner_; }

 void P2PQuicStreamImpl::SetDelegate(P2PQuicStream::Delegate* delegate) {
   delegate_ = delegate;
 }

QuicTransportHost::~QuicTransportHost() {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
  if (ice_transport_host_) {
    ice_transport_host_->DisconnectConsumer(this);
  }
}

P2PQuicStreamImpl* P2PQuicTransportImpl::CreateStream() {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
  return CreateOutgoingBidirectionalStream();
}

  FakePacketTransport(quic::QuicAlarmFactory* alarm_factory,
                      quic::MockClock* clock)
      : alarm_(alarm_factory->CreateAlarm(new AlarmDelegate(this))),
        clock_(clock) {}

void QuicTransportHost::OnRemoteStopped() {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
  stream_hosts_.clear();
  PostCrossThreadTask(
      *proxy_thread(), FROM_HERE,
      CrossThreadBind(&QuicTransportProxy::OnRemoteStopped, proxy_));
}

void P2PQuicStreamImpl::OnClose() {
  closed_ = true;
  quic::QuicStream::OnClose();
}

void QuicTransportHost::Initialize(
IceTransportHost* ice_transport_host,
quic::Perspective perspective,
const std::vector<rtc::scoped_refptr<rtc::RTCCertificate>>& certificates) {
DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
DCHECK(ice_transport_host);
DCHECK(!ice_transport_host_);
ice_transport_host_ = ice_transport_host;
P2PQuicTransportConfig config(
this, ice_transport_host->ConnectConsumer(this)->packet_transport(),
      certificates);
config.is_server = (perspective == quic::Perspective::IS_SERVER);
quic_transport_ =
quic_transport_factory_->CreateQuicTransport(std::move(config));
}

void P2PQuicTransportImpl::OnCryptoHandshakeEvent(CryptoHandshakeEvent event) {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
  QuicSession::OnCryptoHandshakeEvent(event);
  if (event == HANDSHAKE_CONFIRMED) {
    DCHECK(IsEncryptionEstablished());
    DCHECK(IsCryptoHandshakeConfirmed());
    delegate_->OnConnected();
  }
}

void P2PQuicTransportImpl::OnConnectionClosed(
    quic::QuicErrorCode error,
    const std::string& error_details,
    quic::ConnectionCloseSource source) {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
  quic::QuicSession::OnConnectionClosed(error, error_details, source);
  if (error != quic::QuicErrorCode::QUIC_CONNECTION_CANCELLED) {
    delegate_->OnConnectionFailed(
        error_details, source == quic::ConnectionCloseSource::FROM_PEER);
  } else if (source == quic::ConnectionCloseSource::FROM_PEER) {
    delegate_->OnRemoteStopped();
  }
}

  void StartHandshake() {
    std::vector<std::unique_ptr<rtc::SSLFingerprint>> server_fingerprints;
    server_fingerprints.emplace_back(rtc::SSLFingerprint::Create(
        "sha-256", server_peer_->certificate()->identity()));
    server_peer_->quic_transport()->Start(std::move(server_fingerprints));

    std::vector<std::unique_ptr<rtc::SSLFingerprint>> client_fingerprints;
    client_fingerprints.emplace_back(rtc::SSLFingerprint::Create(
        "sha-256", client_peer_->certificate()->identity()));
    client_peer_->quic_transport()->Start(std::move(client_fingerprints));
  }

  FireCallbackAction(base::RepeatingCallback<void()> callback)
      : callback_(callback) {}

rtc::scoped_refptr<rtc::RTCCertificate> CreateTestCertificate() {
  rtc::KeyParams params;
  rtc::SSLIdentity* ssl_identity =
      rtc::SSLIdentity::Generate("dummy_certificate", params);
  return rtc::RTCCertificate::Create(
      std::unique_ptr<rtc::SSLIdentity>(ssl_identity));
}

  base::RepeatingCallback<void()> CreateCallback() {
    callback_counter_++;
    return base::BindRepeating(&CallbackRunLoop::OnCallbackFired,
                               base::Unretained(this));
  }

  QuicPeerForTest(
      std::unique_ptr<FakePacketTransport> packet_transport,
      std::unique_ptr<MockP2PQuicTransportDelegate> quic_transport_delegate,
      std::unique_ptr<P2PQuicTransportImpl> quic_transport,
      rtc::scoped_refptr<rtc::RTCCertificate> certificate)
      : packet_transport_(std::move(packet_transport)),
        quic_transport_delegate_(std::move(quic_transport_delegate)),
        quic_transport_(std::move(quic_transport)),
        certificate_(certificate) {}

void QuicTransportHost::OnRemoveStream(QuicStreamHost* stream_host_to_remove) {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);

  auto it = stream_hosts_.find(stream_host_to_remove);
  DCHECK(it != stream_hosts_.end());
  stream_hosts_.erase(it);
}

 void P2PQuicStreamImpl::OnStreamReset(const quic::QuicRstStreamFrame& frame) {
  quic::QuicStream::OnStreamReset(frame);
  delegate_->OnRemoteReset();
}

  quic::QuicConnection* client_connection() {
    return client_peer_->quic_transport()->connection();
  }

void P2PQuicTransportImpl::OnPacketDataReceived(const char* data,
                                                size_t data_len) {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
  quic::QuicReceivedPacket packet(data, data_len, clock_->Now());
  ProcessUdpPacket(connection()->self_address(), connection()->peer_address(),
                   packet);
}

  QuicPeerForTest* server_peer() { return server_peer_.get(); }

void QuicTransportHost::OnStream(P2PQuicStream* p2p_stream) {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
  DCHECK(p2p_stream);

  auto stream_proxy = std::make_unique<QuicStreamProxy>();
  auto stream_host = std::make_unique<QuicStreamHost>();
  stream_proxy->set_host(stream_host->AsWeakPtr());
  stream_host->set_proxy(stream_proxy->AsWeakPtr());

  stream_host->Initialize(this, p2p_stream);

  stream_hosts_.insert(
      std::make_pair(stream_host.get(), std::move(stream_host)));

  PostCrossThreadTask(*proxy_thread(), FROM_HERE,
                      CrossThreadBind(&QuicTransportProxy::OnStream, proxy_,
                                      WTF::Passed(std::move(stream_proxy))));
}

P2PQuicStreamImpl* P2PQuicTransportImpl::CreateIncomingStream(
    quic::QuicStreamId id) {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
  P2PQuicStreamImpl* stream = CreateStreamInternal(id);
  ActivateStream(std::unique_ptr<P2PQuicStreamImpl>(stream));
  delegate_->OnStream(stream);
  return stream;
}

 void P2PQuicStreamImpl::Reset() {
   if (rst_sent()) {
    return;
  }
   quic::QuicStream::Reset(quic::QuicRstStreamErrorCode::QUIC_STREAM_CANCELLED);
 }

 void P2PQuicTransportImpl::InitializeCryptoStream() {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
  DCHECK(!crypto_stream_);
  switch (perspective_) {
    case quic::Perspective::IS_CLIENT: {
      if (!crypto_client_config_) {
        std::unique_ptr<quic::ProofVerifier> proof_verifier(
            new InsecureProofVerifier);
        crypto_client_config_ = std::make_unique<quic::QuicCryptoClientConfig>(
            std::move(proof_verifier),
            quic::TlsClientHandshaker::CreateSslCtx());
      }
      char random_hostname[kHostnameLength];
      helper_->GetRandomGenerator()->RandBytes(random_hostname,
                                               kHostnameLength);
      quic::QuicServerId server_id(
          /*host=*/quic::QuicString(random_hostname, kHostnameLength),
          /*port=*/0,
          /*privacy_mode_enabled=*/false);
      crypto_stream_ = std::make_unique<quic::QuicCryptoClientStream>(
          server_id, /*QuicSession=*/this,
          crypto_client_config_->proof_verifier()->CreateDefaultContext(),
          crypto_client_config_.get(), /*ProofHandler=*/this);
      QuicSession::Initialize();
      break;
    }
    case quic::Perspective::IS_SERVER: {
      std::unique_ptr<quic::ProofSource> proof_source(new DummyProofSource);
      crypto_server_config_ = std::make_unique<quic::QuicCryptoServerConfig>(
          quic::QuicCryptoServerConfig::TESTING, helper_->GetRandomGenerator(),
          std::move(proof_source), quic::KeyExchangeSource::Default(),
          quic::TlsServerHandshaker::CreateSslCtx());
      quic::QuicCryptoServerConfig::ConfigOptions options;
      std::unique_ptr<quic::CryptoHandshakeMessage> message(
          crypto_server_config_->AddDefaultConfig(
              helper_->GetRandomGenerator(), helper_->GetClock(), options));
      compressed_certs_cache_.reset(new quic::QuicCompressedCertsCache(
          quic::QuicCompressedCertsCache::kQuicCompressedCertsCacheSize));
      bool use_stateless_rejects_if_peer_supported = false;
      server_stream_helper_ = std::make_unique<DummyCryptoServerStreamHelper>(
          helper_->GetRandomGenerator());

      crypto_stream_ = std::make_unique<quic::QuicCryptoServerStream>(
          crypto_server_config_.get(), compressed_certs_cache_.get(),
          use_stateless_rejects_if_peer_supported, this,
          server_stream_helper_.get());
      QuicSession::Initialize();
      break;
    }
    default:
      NOTREACHED();
      break;
  }
}

  void ExpectConnectionNotEstablished() {
    EXPECT_FALSE(client_peer_->quic_transport()->IsEncryptionEstablished());
    EXPECT_FALSE(client_peer_->quic_transport()->IsCryptoHandshakeConfirmed());
    EXPECT_FALSE(server_peer_->quic_transport()->IsCryptoHandshakeConfirmed());
    EXPECT_FALSE(server_peer_->quic_transport()->IsEncryptionEstablished());
  }

  void OnCallbackFired() { callback_counter_--; }

void P2PQuicTransportImpl::Stop() {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
  if (IsClosed()) {
    return;
  }
  connection_->CloseConnection(
      quic::QuicErrorCode::QUIC_CONNECTION_CANCELLED, kClosingDetails,
      quic::ConnectionCloseBehavior::SEND_CONNECTION_CLOSE_PACKET);
}

  QuicPeerForTest* client_peer() { return client_peer_.get(); }

  void ConnectPeerTransport(FakePacketTransport* peer_packet_transport) {
    DCHECK(!peer_packet_transport_);
    peer_packet_transport_ = peer_packet_transport;
  }

void QuicTransportHost::CreateStream(
    std::unique_ptr<QuicStreamHost> stream_host) {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);

  P2PQuicStream* p2p_stream = quic_transport_->CreateStream();
  stream_host->Initialize(this, p2p_stream);
  stream_hosts_.insert(
      std::make_pair(stream_host.get(), std::move(stream_host)));
}

  InsecureProofVerifier() {}

scoped_refptr<base::SingleThreadTaskRunner> QuicStreamHost::proxy_thread()
    const {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
  DCHECK(transport_host_);
  return transport_host_->proxy_thread();
}

  void RunCurrentTasks() {
    size_t posted_tasks_size = runner_->GetPostedTasks().size();
    for (size_t i = 0; i < posted_tasks_size; ++i) {
      runner_->RunNextTask();
    }
  }

  void ExpectTransportsClosed() {
    EXPECT_TRUE(client_peer_->quic_transport()->IsClosed());
    EXPECT_TRUE(server_peer_->quic_transport()->IsClosed());
  }

  quic::QuicStreamId stream_id() const { return stream_id_; }

void QuicTransportHost::OnConnected() {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
  PostCrossThreadTask(
      *proxy_thread(), FROM_HERE,
      CrossThreadBind(&QuicTransportProxy::OnConnected, proxy_));
}

QuicStreamHost::~QuicStreamHost() {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
}

P2PQuicStreamTest()
: connection_(
new quic::test::MockQuicConnection(&connection_helper_,
&alarm_factory_,
quic::Perspective::IS_CLIENT)),
session_(connection_) {
session_.Initialize();
    stream_ = new P2PQuicStreamImpl(kStreamId, &session_);
stream_->SetDelegate(&delegate_);
// The session takes the ownership of the stream.
session_.ActivateStream(std::unique_ptr<P2PQuicStreamImpl>(stream_));
// DCHECKS get hit when the clock is at 0.
connection_helper_.AdvanceTime(quic::QuicTime::Delta::FromSeconds(1));
}

  MockP2PQuicTransportDelegate* quic_transport_delegate() {
    return quic_transport_delegate_.get();
  }

void QuicStreamHost::OnRemoteReset() {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
  PostCrossThreadTask(
      *proxy_thread(), FROM_HERE,
      CrossThreadBind(&QuicStreamProxy::OnRemoteReset, stream_proxy_));
  Delete();
}

bool P2PQuicTransportImpl::IsClosed() {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
  return !connection_->connected();
}

  FailingProofVerifier() {}

PolymorphicAction<FireCallbackAction> FireCallback(
    base::RepeatingCallback<void()> callback) {
  return MakePolymorphicAction(FireCallbackAction(callback));
}

const quic::QuicCryptoStream* P2PQuicTransportImpl::GetCryptoStream() const {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
  return crypto_stream_.get();
}

P2PQuicStreamImpl::P2PQuicStreamImpl(quic::QuicStreamId id,
                                     quic::QuicSession* session)
    : quic::QuicStream(id, session, /*is_static=*/false, quic::BIDIRECTIONAL) {}

  P2PQuicTransportTest() {}

void P2PQuicTransportImpl::Start(
    std::vector<std::unique_ptr<rtc::SSLFingerprint>> remote_fingerprints) {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
  DCHECK_EQ(remote_fingerprints_.size(), 0u);
  DCHECK_GT(remote_fingerprints.size(), 0u);
  if (IsClosed()) {
    return;
  }
  remote_fingerprints_ = std::move(remote_fingerprints);

  if (perspective_ == quic::Perspective::IS_CLIENT) {
    quic::QuicCryptoClientStream* client_crypto_stream =
        static_cast<quic::QuicCryptoClientStream*>(crypto_stream_.get());
    client_crypto_stream->CryptoConnect();
  }
}

P2PQuicStreamImpl* P2PQuicTransportImpl::CreateStreamInternal(
quic::QuicStreamId id) {
DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
DCHECK(crypto_stream_);
DCHECK(IsEncryptionEstablished());
DCHECK(!IsClosed());
  return new P2PQuicStreamImpl(id, this);
}

  void InitializeWithFailingProofVerification() {
    Initialize(false);
    std::unique_ptr<quic::ProofVerifier> proof_verifier(
        new FailingProofVerifier);
    std::unique_ptr<quic::QuicCryptoClientConfig> crypto_client_config =
        std::make_unique<quic::QuicCryptoClientConfig>(
            std::move(proof_verifier),
            quic::TlsClientHandshaker::CreateSslCtx());
    client_peer_->quic_transport()->set_crypto_client_config(
        std::move(crypto_client_config));
    client_peer_->quic_transport()->InitializeCryptoStream();
    server_peer_->quic_transport()->InitializeCryptoStream();
  }

bool P2PQuicStreamImpl::IsClosedForTesting() {
  return closed_;
}

  rtc::scoped_refptr<rtc::RTCCertificate> certificate() { return certificate_; }

    explicit AlarmDelegate(FakePacketTransport* packet_transport)
        : packet_transport_(packet_transport) {}

void P2PQuicStreamImpl::OnDataAvailable() {
  sequencer()->MarkConsumed(sequencer()->ReadableBytes());
  if (sequencer()->IsClosed()) {
    OnFinRead();
   }
 }

  P2PQuicTransportImpl* quic_transport() { return quic_transport_.get(); }

void Initialize(bool can_respond_to_crypto_handshake = true) {
// Quic crashes if packets are sent at time 0, and the clock defaults to 0.
clock_.AdvanceTime(quic::QuicTime::Delta::FromMilliseconds(1000));
runner_ = new net::test::TestTaskRunner(&clock_);
net::QuicChromiumAlarmFactory* alarm_factory =
new net::QuicChromiumAlarmFactory(runner_.get(), &clock_);
quic_transport_factory_ = std::make_unique<P2PQuicTransportFactoryImpl>(
&clock_, std::unique_ptr<net::QuicChromiumAlarmFactory>(alarm_factory));

auto client_packet_transport =
std::make_unique<FakePacketTransport>(alarm_factory, &clock_);
auto server_packet_transport =
std::make_unique<FakePacketTransport>(alarm_factory, &clock_);
// Connect the transports so that they can speak to each other.
client_packet_transport->ConnectPeerTransport(
server_packet_transport.get());
server_packet_transport->ConnectPeerTransport(
client_packet_transport.get());
rtc::scoped_refptr<rtc::RTCCertificate> client_cert =
CreateTestCertificate();

auto client_quic_transport_delegate =
std::make_unique<MockP2PQuicTransportDelegate>();
std::vector<rtc::scoped_refptr<rtc::RTCCertificate>> client_certificates;
client_certificates.push_back(client_cert);
P2PQuicTransportConfig client_config(client_quic_transport_delegate.get(),
client_packet_transport.get(),
                                         client_certificates);
client_config.is_server = false;
client_config.can_respond_to_crypto_handshake =
can_respond_to_crypto_handshake;
// We can't downcast a unique_ptr to an object, so we have to release, cast
// it, then create a unique_ptr of the downcasted pointer.
P2PQuicTransportImpl* client_quic_transport_ptr =
static_cast<P2PQuicTransportImpl*>(
quic_transport_factory_
->CreateQuicTransport(std::move(client_config))
.release());
std::unique_ptr<P2PQuicTransportImpl> client_quic_transport =
std::unique_ptr<P2PQuicTransportImpl>(client_quic_transport_ptr);
client_peer_ = std::make_unique<QuicPeerForTest>(
std::move(client_packet_transport),
std::move(client_quic_transport_delegate),
std::move(client_quic_transport), client_cert);

auto server_quic_transport_delegate =
std::make_unique<MockP2PQuicTransportDelegate>();

rtc::scoped_refptr<rtc::RTCCertificate> server_cert =
CreateTestCertificate();
std::vector<rtc::scoped_refptr<rtc::RTCCertificate>> server_certificates;
server_certificates.push_back(server_cert);
P2PQuicTransportConfig server_config(server_quic_transport_delegate.get(),
server_packet_transport.get(),
                                         server_certificates);
server_config.is_server = true;
server_config.can_respond_to_crypto_handshake =
can_respond_to_crypto_handshake;
P2PQuicTransportImpl* server_quic_transport_ptr =
static_cast<P2PQuicTransportImpl*>(
quic_transport_factory_
->CreateQuicTransport(std::move(server_config))
.release());
std::unique_ptr<P2PQuicTransportImpl> server_quic_transport =
std::unique_ptr<P2PQuicTransportImpl>(server_quic_transport_ptr);
server_peer_ = std::make_unique<QuicPeerForTest>(
std::move(server_packet_transport),
std::move(server_quic_transport_delegate),
std::move(server_quic_transport), server_cert);
}

  int last_packet_num() { return last_packet_num_; }

void SetupConnectedStreams() {
CallbackRunLoop run_loop(runner());
// We must already have a secure connection before streams are created.
ASSERT_TRUE(client_peer_->quic_transport()->IsEncryptionEstablished());
ASSERT_TRUE(server_peer_->quic_transport()->IsEncryptionEstablished());

client_peer_->CreateStreamWithDelegate();
ASSERT_TRUE(client_peer_->stream());
ASSERT_TRUE(client_peer_->stream_delegate());

// Send some data to trigger the remote side (server side) to get an
// incoming stream. We capture the stream and set it's delegate when
// OnStream gets called on the mock object.
base::RepeatingCallback<void()> callback = run_loop.CreateCallback();
QuicPeerForTest* server_peer_ptr = server_peer_.get();
MockP2PQuicStreamDelegate* stream_delegate =
new MockP2PQuicStreamDelegate();
P2PQuicStream* server_stream;
EXPECT_CALL(*server_peer_->quic_transport_delegate(), OnStream(_))
.WillOnce(Invoke([&callback, &server_stream,
&stream_delegate](P2PQuicStream* stream) {
stream->SetDelegate(stream_delegate);
server_stream = stream;
callback.Run();
}));

    client_peer_->stream()->WriteOrBufferData(kTriggerRemoteStreamPhrase,
                                              /*fin=*/false, nullptr);
run_loop.RunUntilCallbacksFired();
// Set the stream and delegate to the |server_peer_|, so that it can be
// accessed by tests later.
server_peer_ptr->SetStreamAndDelegate(
static_cast<P2PQuicStreamImpl*>(server_stream),
std::unique_ptr<MockP2PQuicStreamDelegate>(stream_delegate));
ASSERT_TRUE(client_peer_->stream());
ASSERT_TRUE(client_peer_->stream_delegate());
}

  void DisconnectPeerTransport(FakePacketTransport* peer_packet_transport) {
    DCHECK(peer_packet_transport_ == peer_packet_transport);
    peer_packet_transport_ = nullptr;
  }

void QuicTransportHost::Start(
    std::vector<std::unique_ptr<rtc::SSLFingerprint>> remote_fingerprints) {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
  quic_transport_->Start(std::move(remote_fingerprints));
}

void P2PQuicStreamImpl::OnFinRead() {
  DCHECK(delegate_);
  quic::QuicStream::OnFinRead();
  delegate_->OnRemoteFinish();
}

scoped_refptr<base::SingleThreadTaskRunner> QuicTransportHost::host_thread()
    const {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
  return ice_transport_host_->host_thread();
}

P2PQuicStreamImpl* P2PQuicTransportImpl::CreateOutgoingBidirectionalStream() {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
  P2PQuicStreamImpl* stream = CreateStreamInternal(GetNextOutgoingStreamId());
  ActivateStream(std::unique_ptr<P2PQuicStreamImpl>(stream));
  return stream;
}

  P2PQuicStreamImpl* stream() const { return stream_; }

  bool IsClientClosed() { return client_peer_->quic_transport()->IsClosed(); }

void P2PQuicStreamImpl::Finish() {
  // Should never call Finish twice.
  DCHECK(!fin_sent());
  quic::QuicStream::WriteOrBufferData("", /*fin=*/true, nullptr);
}

  Result Perform(const ArgumentTuple& args) const {
    callback_.Run();
  }

void QuicStreamHost::OnRemoteFinish() {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
  PostCrossThreadTask(
      *proxy_thread(), FROM_HERE,
      CrossThreadBind(&QuicStreamProxy::OnRemoteFinish, stream_proxy_));
  readable_ = false;
  if (!readable_ && !writeable_) {
    Delete();
  }
}

  CallbackRunLoop(scoped_refptr<net::test::TestTaskRunner> task_runner)
      : task_runner_(task_runner) {}

scoped_refptr<base::SingleThreadTaskRunner> QuicTransportHost::proxy_thread()
    const {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
  return ice_transport_host_->proxy_thread();
}

void P2PQuicTransportImpl::set_crypto_client_config(
    std::unique_ptr<quic::QuicCryptoClientConfig> crypto_client_config) {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
  crypto_client_config_ = std::move(crypto_client_config);
}

void QuicStreamHost::Delete() {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
  DCHECK(transport_host_);
  transport_host_->OnRemoveStream(this);
}

  void CreateStreamWithDelegate() {
    stream_ = quic_transport_->CreateStream();
    stream_delegate_ = std::make_unique<MockP2PQuicStreamDelegate>();
    stream_->SetDelegate(stream_delegate_.get());
    stream_id_ = stream_->id();
  }

QuicTransportHost::QuicTransportHost(
    base::WeakPtr<QuicTransportProxy> proxy,
    std::unique_ptr<P2PQuicTransportFactory> quic_transport_factory)
    : quic_transport_factory_(std::move(quic_transport_factory)),
      proxy_(std::move(proxy)) {
  DETACH_FROM_THREAD(thread_checker_);
  DCHECK(quic_transport_factory_);
  DCHECK(proxy_);
}

  void ExpectStreamsClosed() {
    EXPECT_EQ(0u, client_peer_->quic_transport()->GetNumActiveStreams());
    EXPECT_TRUE(client_peer_->quic_transport()->IsClosedStream(
        client_peer()->stream_id()));

    EXPECT_EQ(0u, server_peer_->quic_transport()->GetNumActiveStreams());
    EXPECT_TRUE(server_peer()->quic_transport()->IsClosedStream(
        server_peer()->stream_id()));
  }

QuicStreamHost::QuicStreamHost() {
  DETACH_FROM_THREAD(thread_checker_);
}

P2PQuicTransportImpl::~P2PQuicTransportImpl() {
  packet_transport_->SetReceiveDelegate(nullptr);
}

void QuicStreamHost::Finish() {
DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
DCHECK(p2p_stream_);
  p2p_stream_->Finish();
writeable_ = false;
if (!readable_ && !writeable_) {
Delete();
}
}
