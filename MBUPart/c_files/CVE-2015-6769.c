bool AreSwitchesIdenticalToCurrentCommandLine(
    const base::CommandLine& new_cmdline,
    const base::CommandLine& active_cmdline,
    std::set<base::CommandLine::StringType>* out_difference) {
  const char* extra_flag_sentinel_begin_flag_name = nullptr;
  const char* extra_flag_sentinel_end_flag_name = nullptr;
#if defined(OS_CHROMEOS)
  extra_flag_sentinel_begin_flag_name =
      chromeos::switches::kPolicySwitchesBegin;
  extra_flag_sentinel_end_flag_name = chromeos::switches::kPolicySwitchesEnd;
#endif  // OS_CHROMEOS
  return flags_ui::FlagsState::AreSwitchesIdenticalToCurrentCommandLine(
      new_cmdline, active_cmdline, out_difference,
      extra_flag_sentinel_begin_flag_name, extra_flag_sentinel_end_flag_name);
}

  void TestGenerationFallback(bool custom_passphrase_enabled) {
    MockSyncService mock_sync_service;
    EXPECT_CALL(mock_sync_service, IsFirstSetupComplete())
        .WillRepeatedly(::testing::Return(true));
    EXPECT_CALL(mock_sync_service, IsSyncActive())
        .WillRepeatedly(::testing::Return(true));
    EXPECT_CALL(mock_sync_service, GetActiveDataTypes())
        .Times(::testing::AnyNumber())
        .WillRepeatedly(
            ::testing::Return(syncer::ModelTypeSet(syncer::PASSWORDS)));
    EXPECT_CALL(mock_sync_service, IsUsingSecondaryPassphrase())
        .WillRepeatedly(::testing::Return(custom_passphrase_enabled));
    std::unique_ptr<TestPasswordManagerClient> client(
        new TestPasswordManagerClient);
    std::unique_ptr<MockAutofillClient> autofill_client(
        new MockAutofillClient(&mock_sync_service));
    InitializePasswordAutofillManager(client.get(), autofill_client.get());

    gfx::RectF element_bounds;
    autofill::PasswordFormFillData data;
    data.username_field.value = test_username_;
    data.password_field.value = test_password_;
    data.origin = GURL("https://foo.test");

    int dummy_key = 0;
    password_autofill_manager_->OnAddPasswordFormMapping(dummy_key, data);
    SetManualFallbacks(true);

    std::vector<base::string16> elements = {
        l10n_util::GetStringUTF16(
            IDS_AUTOFILL_PASSWORD_FIELD_SUGGESTIONS_TITLE),
        test_username_};
    if (!IsPreLollipopAndroid() || !custom_passphrase_enabled) {
#if !defined(OS_ANDROID)
      elements.push_back(base::string16());
#endif
      elements.push_back(
          l10n_util::GetStringUTF16(IDS_AUTOFILL_SHOW_ALL_SAVED_FALLBACK));
      if (!custom_passphrase_enabled) {
#if !defined(OS_ANDROID)
        elements.push_back(base::string16());
#endif
        elements.push_back(
            l10n_util::GetStringUTF16(IDS_AUTOFILL_GENERATE_PASSWORD_FALLBACK));
      }
    }

    EXPECT_CALL(
        *autofill_client,
        ShowAutofillPopup(
            element_bounds, _,
            SuggestionVectorValuesAre(testing::ElementsAreArray(elements)), _));

    password_autofill_manager_->OnShowPasswordSuggestions(
        dummy_key, base::i18n::RIGHT_TO_LEFT, test_username_,
        autofill::IS_PASSWORD_FIELD, element_bounds);
  }

void AddSimpleSuggestionWithSeparatorOnTop(
    int value,
    int frontend_id,
    std::vector<autofill::Suggestion>* suggestions) {
#if !defined(OS_ANDROID)
  suggestions->push_back(autofill::Suggestion());
  suggestions->back().frontend_id = autofill::POPUP_ITEM_ID_SEPARATOR;
#endif

  autofill::Suggestion suggestion(l10n_util::GetStringUTF8(value),
                                  std::string(), std::string(), frontend_id);
  suggestions->push_back(suggestion);
}

void SetManualFallbacks(bool enabled) {
std::vector<std::string> features = {
        password_manager::features::kEnableManualFallbacksFilling.name,
password_manager::features::kEnableManualFallbacksFillingStandalone
.name,
password_manager::features::kEnableManualFallbacksGeneration.name};
if (enabled) {
scoped_feature_list_.InitFromCommandLine(base::JoinString(features, ","),
std::string());
} else {
scoped_feature_list_.InitFromCommandLine(std::string(),
base::JoinString(features, ","));
}
}

void PasswordAutofillManager::ClearPreviewedForm() {
  password_manager_driver_->ClearPreviewedForm();
}

  MockAutofillClient() : sync_service_(nullptr) {}

void PasswordAutofillManager::OnAddPasswordFormMapping(
    int key,
    const autofill::PasswordFormFillData& fill_data) {
  if (!autofill::IsValidPasswordFormFillData(fill_data))
    return;

  login_to_password_info_[key] = fill_data;
}

autofill::Suggestion PasswordAutofillManager::CreateFormNotSecureWarning() {
  autofill::Suggestion http_warning_suggestion(
      l10n_util::GetStringUTF8(IDS_AUTOFILL_LOGIN_HTTP_WARNING_MESSAGE),
      l10n_util::GetStringUTF8(IDS_AUTOFILL_HTTP_WARNING_LEARN_MORE),
      "httpWarning", autofill::POPUP_ITEM_ID_HTTP_NOT_SECURE_WARNING_MESSAGE);
  if (!did_show_form_not_secure_warning_) {
    did_show_form_not_secure_warning_ = true;
    metrics_util::LogShowedFormNotSecureWarningOnCurrentNavigation();
  }
  return http_warning_suggestion;
}

bool PasswordAutofillManager::FindLoginInfo(
    int key,
    autofill::PasswordFormFillData* found_password) {
  LoginToPasswordInfoMap::iterator iter = login_to_password_info_.find(key);
  if (iter == login_to_password_info_.end())
    return false;

  *found_password = iter->second;
  return true;
}

void AppendSuggestionIfMatching(
    const base::string16& field_suggestion,
    const base::string16& field_contents,
    const std::string& signon_realm,
    bool show_all,
    bool is_password_field,
    std::vector<autofill::Suggestion>* suggestions) {
  base::string16 lower_suggestion = base::i18n::ToLower(field_suggestion);
  base::string16 lower_contents = base::i18n::ToLower(field_contents);
  bool prefix_matched_suggestion =
      show_all || base::StartsWith(lower_suggestion, lower_contents,
                                   base::CompareCase::SENSITIVE);
  if (prefix_matched_suggestion ||
      autofill::FieldIsSuggestionSubstringStartingOnTokenBoundary(
          lower_suggestion, lower_contents, true)) {
    autofill::Suggestion suggestion(ReplaceEmptyUsername(field_suggestion));
    suggestion.label = GetHumanReadableRealm(signon_realm);
    suggestion.frontend_id = is_password_field
                                 ? autofill::POPUP_ITEM_ID_PASSWORD_ENTRY
                                 : autofill::POPUP_ITEM_ID_USERNAME_ENTRY;
    suggestion.match = prefix_matched_suggestion
                           ? autofill::Suggestion::PREFIX_MATCH
                           : autofill::Suggestion::SUBSTRING_MATCH;
    suggestions->push_back(suggestion);
  }
}

PasswordAutofillManager::PasswordAutofillManager(
    PasswordManagerDriver* password_manager_driver,
    autofill::AutofillClient* autofill_client,
    PasswordManagerClient* password_client)
    : form_data_key_(-1),
      password_manager_driver_(password_manager_driver),
      autofill_client_(autofill_client),
      password_client_(password_client),
      weak_ptr_factory_(this) {}

void ReportAboutFlagsHistogramFeatures(const std::string& uma_histogram_name,
                                       const std::set<std::string>& features) {
  for (const std::string& feature : features) {
    int uma_id = GetSwitchUMAId(feature);
    DVLOG(1) << "ReportAboutFlagsHistogram(): histogram='" << uma_histogram_name
             << "' '" << feature << "', uma_id=" << uma_id;
    base::UmaHistogramSparse(uma_histogram_name, uma_id);
  }
}

  TestPasswordManagerClient() : main_frame_url_(kMainFrameUrl) {}

bool ShouldShowManualFallbackForPreLollipop(syncer::SyncService* sync_service) {
#if defined(OS_ANDROID)
  return ((base::android::BuildInfo::GetInstance()->sdk_int() >=
           base::android::SDK_VERSION_LOLLIPOP) ||
          (password_manager_util::GetPasswordSyncState(sync_service) ==
           SYNCING_NORMAL_ENCRYPTION));
#else
  return true;
#endif
}

void PasswordAutofillManager::DidSelectSuggestion(const base::string16& value,
                                                  int identifier) {
  ClearPreviewedForm();
  if (identifier == autofill::POPUP_ITEM_ID_HTTP_NOT_SECURE_WARNING_MESSAGE ||
      identifier == autofill::POPUP_ITEM_ID_ALL_SAVED_PASSWORDS_ENTRY ||
      identifier == autofill::POPUP_ITEM_ID_GENERATE_PASSWORD_ENTRY)
    return;
  bool success =
      PreviewSuggestion(form_data_key_, GetUsernameFromSuggestion(value));
  DCHECK(success);
}

  void SetHttpWarningEnabled() {
    scoped_feature_list_.InitAndEnableFeature(
        security_state::kHttpFormWarningFeature);
  }

  void InitializePasswordAutofillManager(
      TestPasswordManagerClient* client,
      autofill::AutofillClient* autofill_client) {
    password_autofill_manager_.reset(new PasswordAutofillManager(
        client->mock_driver(), autofill_client, client));
    password_autofill_manager_->OnAddPasswordFormMapping(fill_data_id_,
                                                         fill_data_);
  }

void PasswordAutofillManager::OnPopupShown() {
}

  MockAutofillClient(MockSyncService* sync_service)
      : sync_service_(sync_service) {
    LOG(ERROR) << "init mpck client";
  }

void PasswordAutofillManager::DidAcceptSuggestion(const base::string16& value,
                                                  int identifier,
                                                  int position) {
  autofill_client_->ExecuteCommand(identifier);
  if (identifier == autofill::POPUP_ITEM_ID_GENERATE_PASSWORD_ENTRY) {
    password_manager_driver_->UserSelectedManualGenerationOption();
  } else if (identifier !=
                 autofill::POPUP_ITEM_ID_HTTP_NOT_SECURE_WARNING_MESSAGE &&
             identifier != autofill::POPUP_ITEM_ID_ALL_SAVED_PASSWORDS_ENTRY) {
    bool success =
        FillSuggestion(form_data_key_, GetUsernameFromSuggestion(value));
    DCHECK(success);
  }

  if (identifier == autofill::POPUP_ITEM_ID_ALL_SAVED_PASSWORDS_ENTRY) {
    DCHECK_NE(show_all_saved_passwords_shown_context_,
              metrics_util::SHOW_ALL_SAVED_PASSWORDS_CONTEXT_NONE);

    metrics_util::LogContextOfShowAllSavedPasswordsAccepted(
        show_all_saved_passwords_shown_context_);

    if (password_client_) {
      using UserAction =
          password_manager::PasswordManagerMetricsRecorder::PageLevelUserAction;
      switch (show_all_saved_passwords_shown_context_) {
        case metrics_util::SHOW_ALL_SAVED_PASSWORDS_CONTEXT_PASSWORD:
          password_client_->GetMetricsRecorder().RecordPageLevelUserAction(
              UserAction::kShowAllPasswordsWhileSomeAreSuggested);
          break;
        case metrics_util::SHOW_ALL_SAVED_PASSWORDS_CONTEXT_MANUAL_FALLBACK:
          password_client_->GetMetricsRecorder().RecordPageLevelUserAction(
              UserAction::kShowAllPasswordsWhileNoneAreSuggested);
          break;
        case metrics_util::SHOW_ALL_SAVED_PASSWORDS_CONTEXT_CONTEXT_MENU:
        case metrics_util::SHOW_ALL_SAVED_PASSWORDS_CONTEXT_NONE:
        case metrics_util::SHOW_ALL_SAVED_PASSWORDS_CONTEXT_COUNT:
          NOTREACHED();
      }
    }
  }

  autofill_client_->HideAutofillPopup();
}

void PasswordAutofillManager::OnShowNotSecureWarning(
    base::i18n::TextDirection text_direction,
    const gfx::RectF& bounds) {
  DCHECK(security_state::IsHttpWarningInFormEnabled());
  if (!autofill_client_)
    return;

  std::vector<autofill::Suggestion> suggestions;
  autofill::Suggestion http_warning_suggestion = CreateFormNotSecureWarning();
  suggestions.insert(suggestions.begin(), http_warning_suggestion);

  autofill_client_->ShowAutofillPopup(bounds, text_direction, suggestions,
                                      weak_ptr_factory_.GetWeakPtr());
}

  virtual ~MockSyncService() {}

bool PasswordAutofillManager::FillSuggestion(int key,
                                             const base::string16& username) {
  autofill::PasswordFormFillData fill_data;
  autofill::PasswordAndRealm password_and_realm;
  if (FindLoginInfo(key, &fill_data) &&
      GetPasswordAndRealmForUsername(
          username, fill_data, &password_and_realm)) {
    bool is_android_credential = FacetURI::FromPotentiallyInvalidSpec(
        password_and_realm.realm).IsValidAndroidFacetURI();
    metrics_util::LogFilledCredentialIsFromAndroidApp(is_android_credential);
    password_manager_driver_->FillSuggestion(
        username, password_and_realm.password);
    return true;
  }
  return false;
}

static bool IsManualFallbackForFillingEnabled() {
return base::FeatureList::IsEnabled(
               password_manager::features::kEnableManualFallbacksFilling) &&
!IsPreLollipopAndroid();
}

void RemoveFlagsSwitches(base::CommandLine::SwitchMap* switch_list) {
  FlagsStateSingleton::GetFlagsState()->RemoveFlagsSwitches(switch_list);
}

bool IsPreLollipopAndroid() {
#if defined(OS_ANDROID)
  return (base::android::BuildInfo::GetInstance()->sdk_int() <
          base::android::SDK_VERSION_LOLLIPOP);
#else
  return false;
#endif
}

autofill::AutofillDriver* PasswordAutofillManager::GetAutofillDriver() {
  return password_manager_driver_->GetAutofillDriver();
}

bool SkipConditionalFeatureEntry(const FeatureEntry& entry) {
  version_info::Channel channel = chrome::GetChannel();
#if defined(OS_CHROMEOS)
  if (!strcmp("mash", entry.internal_name) &&
      channel == version_info::Channel::STABLE) {
    return true;
  }

  if (!strcmp(ui_devtools::kEnableUiDevTools, entry.internal_name) &&
      channel == version_info::Channel::STABLE) {
    return true;
  }
#endif  // defined(OS_CHROMEOS)

  if ((!strcmp("data-reduction-proxy-lo-fi", entry.internal_name) ||
       !strcmp("enable-data-reduction-proxy-lite-page", entry.internal_name)) &&
      channel != version_info::Channel::BETA &&
      channel != version_info::Channel::DEV &&
      channel != version_info::Channel::CANARY &&
      channel != version_info::Channel::UNKNOWN) {
    return true;
  }

#if defined(OS_WIN)
  if (!strcmp("enable-hdr", entry.internal_name) &&
      base::win::GetVersion() < base::win::Version::VERSION_WIN10) {
    return true;
  }
#endif  // OS_WIN

  return false;
}

void PasswordAutofillManager::RegisterDeletionCallback(
    base::OnceClosure deletion_callback) {
  deletion_callback_ = std::move(deletion_callback);
}

  void SetManualFallbacksForFillingStandalone(bool enabled) {
    if (enabled) {
      scoped_feature_list_.InitAndEnableFeature(
          password_manager::features::kEnableManualFallbacksFillingStandalone);
    } else {
      scoped_feature_list_.InitAndDisableFeature(
          password_manager::features::kEnableManualFallbacksFillingStandalone);
    }
  }

void PasswordAutofillManager::DidNavigateMainFrame() {
  login_to_password_info_.clear();
  did_show_form_not_secure_warning_ = false;
}

  PasswordAutofillManagerTest()
      : test_username_(base::ASCIIToUTF16(kAliceUsername)),
        test_password_(base::ASCIIToUTF16(kAlicePassword)),
        fill_data_id_(0) {}

base::string16 ReplaceEmptyUsername(const base::string16& username) {
  if (username.empty())
    return l10n_util::GetStringUTF16(IDS_PASSWORD_MANAGER_EMPTY_LOGIN);
  return username;
}

bool PasswordAutofillManager::GetDeletionConfirmationText(
    const base::string16& value,
    int identifier,
    base::string16* title,
    base::string16* body) {
  return false;
}

  int fill_data_id() { return fill_data_id_; }

void PasswordAutofillManager::OnPopupHidden() {
}

void PasswordAutofillManager::OnShowPasswordSuggestions(
int key,
base::i18n::TextDirection text_direction,
const base::string16& typed_username,
int options,
const gfx::RectF& bounds) {
std::vector<autofill::Suggestion> suggestions;
LoginToPasswordInfoMap::const_iterator fill_data_it =
login_to_password_info_.find(key);
if (fill_data_it == login_to_password_info_.end()) {
// Probably a compromised renderer.
NOTREACHED();
return;
}
GetSuggestions(fill_data_it->second, typed_username, &suggestions,
(options & autofill::SHOW_ALL) != 0,
(options & autofill::IS_PASSWORD_FIELD) != 0);

form_data_key_ = key;

if (suggestions.empty()) {
autofill_client_->HideAutofillPopup();
return;
}

if (options & autofill::IS_PASSWORD_FIELD) {
autofill::Suggestion password_field_suggestions(l10n_util::GetStringUTF16(
IDS_AUTOFILL_PASSWORD_FIELD_SUGGESTIONS_TITLE));
password_field_suggestions.frontend_id = autofill::POPUP_ITEM_ID_TITLE;
suggestions.insert(suggestions.begin(), password_field_suggestions);
}

GURL origin = (fill_data_it->second).origin;
bool is_context_secure = autofill_client_->IsContextSecure() &&
(!origin.is_valid() || !origin.SchemeIs("http"));
if (!is_context_secure && security_state::IsHttpWarningInFormEnabled()) {
std::string icon_str;

// Show http info icon for http sites.
if (origin.is_valid() && origin.SchemeIs("http")) {
icon_str = "httpWarning";
} else {
// Show https_invalid icon for broken https sites.
icon_str = "httpsInvalid";
}

autofill::Suggestion http_warning_suggestion(
l10n_util::GetStringUTF8(IDS_AUTOFILL_LOGIN_HTTP_WARNING_MESSAGE),
l10n_util::GetStringUTF8(IDS_AUTOFILL_HTTP_WARNING_LEARN_MORE),
icon_str, autofill::POPUP_ITEM_ID_HTTP_NOT_SECURE_WARNING_MESSAGE);
#if !defined(OS_ANDROID)
suggestions.insert(suggestions.begin(), autofill::Suggestion());
suggestions.front().frontend_id = autofill::POPUP_ITEM_ID_SEPARATOR;
#endif
suggestions.insert(suggestions.begin(), http_warning_suggestion);

if (!did_show_form_not_secure_warning_) {
did_show_form_not_secure_warning_ = true;
metrics_util::LogShowedFormNotSecureWarningOnCurrentNavigation();
}
}

if (ShouldShowManualFallbackForPreLollipop(
autofill_client_->GetSyncService())) {
if (base::FeatureList::IsEnabled(
            password_manager::features::kEnableManualFallbacksFilling) &&
(options & autofill::IS_PASSWORD_FIELD) && password_client_ &&
password_client_->IsFillingFallbackEnabledForCurrentPage()) {
AddSimpleSuggestionWithSeparatorOnTop(
IDS_AUTOFILL_SHOW_ALL_SAVED_FALLBACK,
autofill::POPUP_ITEM_ID_ALL_SAVED_PASSWORDS_ENTRY, &suggestions);

show_all_saved_passwords_shown_context_ =
metrics_util::SHOW_ALL_SAVED_PASSWORDS_CONTEXT_PASSWORD;
metrics_util::LogContextOfShowAllSavedPasswordsShown(
show_all_saved_passwords_shown_context_);
}
if (base::FeatureList::IsEnabled(
password_manager::features::kEnableManualFallbacksGeneration) &&
password_manager_util::GetPasswordSyncState(
autofill_client_->GetSyncService()) == SYNCING_NORMAL_ENCRYPTION) {
AddSimpleSuggestionWithSeparatorOnTop(
IDS_AUTOFILL_GENERATE_PASSWORD_FALLBACK,
autofill::POPUP_ITEM_ID_GENERATE_PASSWORD_ENTRY, &suggestions);
}
}

autofill_client_->ShowAutofillPopup(bounds,
text_direction,
suggestions,
weak_ptr_factory_.GetWeakPtr());
}

base::string16 GetHumanReadableRealm(const std::string& signon_realm) {
  FacetURI maybe_facet_uri(FacetURI::FromPotentiallyInvalidSpec(signon_realm));
  if (maybe_facet_uri.IsValidAndroidFacetURI())
    return base::UTF8ToUTF16("android://" +
                             maybe_facet_uri.android_package_name() + "/");
  return base::UTF8ToUTF16(signon_realm);
}

void ReportAboutFlagsHistogramSwitches(const std::string& uma_histogram_name,
                                       const std::set<std::string>& switches) {
  for (const std::string& flag : switches) {
    int uma_id = about_flags::testing::kBadSwitchFormatHistogramId;
    if (base::StartsWith(flag, "--", base::CompareCase::SENSITIVE)) {
      std::string switch_name(flag.substr(2));

      const size_t value_pos = switch_name.find('=');
      if (value_pos != std::string::npos)
        switch_name.resize(value_pos);

      uma_id = GetSwitchUMAId(switch_name);
    } else {
      NOTREACHED() << "ReportAboutFlagsHistogram(): flag '" << flag
                   << "' has incorrect format.";
    }
    DVLOG(1) << "ReportAboutFlagsHistogram(): histogram='" << uma_histogram_name
             << "' '" << flag << "', uma_id=" << uma_id;
    base::UmaHistogramSparse(uma_histogram_name, uma_id);
  }
}

void ReportAboutFlagsHistogram(const std::string& uma_histogram_name,
                               const std::set<std::string>& switches,
                               const std::set<std::string>& features) {
  ReportAboutFlagsHistogramSwitches(uma_histogram_name, switches);
  ReportAboutFlagsHistogramFeatures(uma_histogram_name, features);
}

bool PasswordAutofillManager::GetPasswordAndRealmForUsername(
    const base::string16& current_username,
    const autofill::PasswordFormFillData& fill_data,
    autofill::PasswordAndRealm* password_and_realm) {

  if (fill_data.username_field.value == current_username) {
    password_and_realm->password = fill_data.password_field.value;
    password_and_realm->realm = fill_data.preferred_realm;
    return true;
  }

  for (autofill::PasswordFormFillData::LoginCollection::const_iterator iter =
           fill_data.additional_logins.begin();
       iter != fill_data.additional_logins.end(); ++iter) {
    if (iter->first == current_username) {
      *password_and_realm = iter->second;
      return true;
    }
  }

  for (autofill::PasswordFormFillData::UsernamesCollection::const_iterator
           usernames_iter = fill_data.other_possible_usernames.begin();
       usernames_iter != fill_data.other_possible_usernames.end();
       ++usernames_iter) {
    for (size_t i = 0; i < usernames_iter->second.size(); ++i) {
      if (usernames_iter->second[i] == current_username) {
        password_and_realm->password = usernames_iter->first.password;
        password_and_realm->realm = usernames_iter->first.realm;
        return true;
      }
    }
  }

  return false;
}

void GetSuggestions(const autofill::PasswordFormFillData& fill_data,
                    const base::string16& current_username,
                    std::vector<autofill::Suggestion>* suggestions,
                    bool show_all,
                    bool is_password_field) {
  AppendSuggestionIfMatching(fill_data.username_field.value, current_username,
                             fill_data.preferred_realm, show_all,
                             is_password_field, suggestions);

  for (const auto& login : fill_data.additional_logins) {
    AppendSuggestionIfMatching(login.first, current_username,
                               login.second.realm, show_all, is_password_field,
                               suggestions);
  }

  for (const auto& usernames : fill_data.other_possible_usernames) {
    for (size_t i = 0; i < usernames.second.size(); ++i) {
      AppendSuggestionIfMatching(usernames.second[i], current_username,
                                 usernames.first.realm, show_all,
                                 is_password_field, suggestions);
    }
  }

  if (autofill::IsFeatureSubstringMatchEnabled()) {
    std::sort(suggestions->begin(), suggestions->end(),
              [](const autofill::Suggestion& a, const autofill::Suggestion& b) {
                return a.match < b.match;
              });
  }
}

void PasswordAutofillManager::OnShowManualFallbackSuggestion(
    base::i18n::TextDirection text_direction,
    const gfx::RectF& bounds) {
  if (!autofill_client_ || !ShouldShowManualFallbackForPreLollipop(
                               autofill_client_->GetSyncService()))
    return;
  if (!password_client_ ||
      !password_client_->IsFillingFallbackEnabledForCurrentPage())
    return;
  std::vector<autofill::Suggestion> suggestions;
  autofill::Suggestion all_saved_passwords(
      l10n_util::GetStringUTF8(IDS_AUTOFILL_SHOW_ALL_SAVED_FALLBACK),
      std::string(), std::string(),
      autofill::POPUP_ITEM_ID_ALL_SAVED_PASSWORDS_ENTRY);
  suggestions.push_back(all_saved_passwords);

  show_all_saved_passwords_shown_context_ =
      metrics_util::SHOW_ALL_SAVED_PASSWORDS_CONTEXT_MANUAL_FALLBACK;
  metrics_util::LogContextOfShowAllSavedPasswordsShown(
      show_all_saved_passwords_shown_context_);

  if (base::FeatureList::IsEnabled(
          password_manager::features::kEnableManualFallbacksGeneration) &&
      password_manager_util::GetPasswordSyncState(
          autofill_client_->GetSyncService()) == SYNCING_NORMAL_ENCRYPTION) {
    AddSimpleSuggestionWithSeparatorOnTop(
        IDS_AUTOFILL_GENERATE_PASSWORD_FALLBACK,
        autofill::POPUP_ITEM_ID_GENERATE_PASSWORD_ENTRY, &suggestions);
  }
  autofill_client_->ShowAutofillPopup(bounds, text_direction, suggestions,
                                      weak_ptr_factory_.GetWeakPtr());
}

bool PasswordAutofillManager::RemoveSuggestion(const base::string16& value,
                                               int identifier) {
  return false;
}
