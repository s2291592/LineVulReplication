    EntryCapabilities(bool can_copy,
                      bool can_delete,
                      bool can_rename,
                      bool can_add_children,
                      bool can_share)
        : can_copy(can_copy),
          can_delete(can_delete),
          can_rename(can_rename),
          can_add_children(can_add_children),
          can_share(can_share) {}

  DriveTestVolume() : TestVolume("drive") {}

  virtual void CreateEntry(const AddEntriesMessage::TestEntryInfo& entry) {
    arc::FakeFileSystemInstance::Document document(
        authority_, entry.name_text, root_document_id_, entry.name_text,
        GetMimeType(entry), GetFileSize(entry),
        entry.last_modified_time.ToJavaTime());
    file_system_instance_->AddDocument(document);
  }

  virtual void CreateEntry(const AddEntriesMessage::TestEntryInfo& entry) {
    const base::FilePath path =
        base::FilePath::FromUTF8Unsafe(entry.target_path);
    const std::string target_name = path.BaseName().AsUTF8Unsafe();

    drive::FileError error = drive::FILE_ERROR_OK;
    std::unique_ptr<drive::ResourceEntry> parent_entry(
        new drive::ResourceEntry);

    if (!entry.team_drive_name.empty()) {
      integration_service_->file_system()->GetResourceEntry(
          drive::util::GetDriveTeamDrivesRootPath()
              .Append(entry.team_drive_name)
              .Append(path)
              .DirName(),
          google_apis::test_util::CreateCopyResultCallback(&error,
                                                           &parent_entry));
    } else {
      integration_service_->file_system()->GetResourceEntry(
          drive::util::GetDriveMyDriveRootPath().Append(path).DirName(),
          google_apis::test_util::CreateCopyResultCallback(&error,
                                                           &parent_entry));
    }
    content::RunAllTasksUntilIdle();
    ASSERT_EQ(drive::FILE_ERROR_OK, error);
    ASSERT_TRUE(parent_entry);

    google_apis::FileResourceCapabilities file_capabilities;
    file_capabilities.set_can_copy(entry.capabilities.can_copy);
    file_capabilities.set_can_delete(entry.capabilities.can_delete);
    file_capabilities.set_can_rename(entry.capabilities.can_rename);
    file_capabilities.set_can_add_children(entry.capabilities.can_add_children);
    file_capabilities.set_can_share(entry.capabilities.can_share);

    google_apis::TeamDriveCapabilities team_drive_capabilities;
    team_drive_capabilities.set_can_copy(entry.capabilities.can_copy);
    team_drive_capabilities.set_can_delete_team_drive(
        entry.capabilities.can_delete);
    team_drive_capabilities.set_can_rename_team_drive(
        entry.capabilities.can_rename);
    team_drive_capabilities.set_can_add_children(
        entry.capabilities.can_add_children);
    team_drive_capabilities.set_can_share(entry.capabilities.can_share);

    switch (entry.type) {
      case AddEntriesMessage::FILE:
        CreateFile(entry.source_file_name, parent_entry->resource_id(),
                   target_name, entry.mime_type,
                   entry.shared_option == AddEntriesMessage::SHARED ||
                       entry.shared_option == AddEntriesMessage::SHARED_WITH_ME,
                   entry.last_modified_time, file_capabilities);
        break;
      case AddEntriesMessage::DIRECTORY:
        CreateDirectory(
            parent_entry->resource_id(), target_name, entry.last_modified_time,
            entry.shared_option == AddEntriesMessage::SHARED ||
                entry.shared_option == AddEntriesMessage::SHARED_WITH_ME,
            file_capabilities);
        break;
      case AddEntriesMessage::TEAM_DRIVE:
        CreateTeamDrive(entry.team_drive_name, team_drive_capabilities);
        break;
      case AddEntriesMessage::COMPUTER:
        NOTREACHED() << "Can't create a computer in a drive test volume: "
                     << entry.computer_name;
    }

    CheckForUpdates();
    content::RunAllTasksUntilIdle();
  }

  void OnFilesOpened(const std::vector<FileOpenEvent>& opens) {
    ASSERT_TRUE(!opens.empty());
    for (auto& open : opens) {
      OnFilesOpenedImpl(open.path.value(), open.open_type);
    }
  }

  void Unmount(Profile* profile) {
    VolumeManager::Get(profile)->RemoveVolumeForTesting(
        root_path(), volume_type_, device_type_, read_only_, device_path_,
        drive_label_);
  }

  void CreateEntryImpl(const AddEntriesMessage::TestEntryInfo& entry,
                       const base::FilePath& target_path) {
    entries_.insert(std::make_pair(target_path, entry));
    switch (entry.type) {
      case AddEntriesMessage::FILE: {
        const base::FilePath source_path =
            TestVolume::GetTestDataFilePath(entry.source_file_name);
        ASSERT_TRUE(base::CopyFile(source_path, target_path))
            << "Copy from " << source_path.value() << " to "
            << target_path.value() << " failed.";
        break;
      }
      case AddEntriesMessage::DIRECTORY:
        ASSERT_TRUE(base::CreateDirectory(target_path))
            << "Failed to create a directory: " << target_path.value();
        break;
      case AddEntriesMessage::TEAM_DRIVE:
        NOTREACHED() << "Can't create a team drive in a local volume: "
                     << target_path.value();
        break;
      case AddEntriesMessage::COMPUTER:
        NOTREACHED() << "Can't create a computer in a local volume: "
                     << target_path.value();
        break;
      default:
        NOTREACHED() << "Unsupported entry type for: " << target_path.value();
    }

    ASSERT_TRUE(UpdateModifiedTime(entry, target_path));
  }

  void EnsureDownloadsFolderExists() {
    if (!base::FeatureList::IsEnabled(chromeos::features::kMyFilesVolume))
      return;

    auto downloads_folder = root_path().Append("Downloads");
    auto downloads_entry = AddEntriesMessage::TestEntryInfo(
        AddEntriesMessage::DIRECTORY, "", "Downloads");
    if (!base::PathExists(downloads_folder))
      CreateEntryImpl(downloads_entry, downloads_folder);

    InsertEntryOnMap(downloads_entry, downloads_folder);
  }

  base::FilePath GetMyDrivePath() { return mount_path().Append("root"); }

  bool CreateRootDirectory(const Profile* profile) {
    if (root_initialized_)
      return true;
    root_ = profile->GetPath().Append(name_);
    base::ScopedAllowBlockingForTesting allow_blocking;
    root_initialized_ = base::CreateDirectory(root_);
    return root_initialized_;
  }

    TestEntryInfo& SetEntryFolderFeature(
        const EntryFolderFeature& new_folder_feature) {
      folder_feature = new_folder_feature;
      return *this;
    }

  void CreateFile(const std::string& source_file_name,
                  const std::string& parent_id,
                  const std::string& target_name,
                  const std::string& mime_type,
                  bool shared_with_me,
                  const base::Time& modification_time,
                  const google_apis::FileResourceCapabilities& capabilities) {
    google_apis::DriveApiErrorCode error = google_apis::DRIVE_OTHER_ERROR;

    std::string content_data;
    if (!source_file_name.empty()) {
      base::FilePath source_path =
          TestVolume::GetTestDataFilePath(source_file_name);
      ASSERT_TRUE(base::ReadFileToString(source_path, &content_data));
    }

    std::unique_ptr<google_apis::FileResource> entry;
    fake_drive_service_->AddNewFile(
        mime_type, content_data, parent_id, target_name, shared_with_me,
        google_apis::test_util::CreateCopyResultCallback(&error, &entry));
    base::RunLoop().RunUntilIdle();
    ASSERT_EQ(google_apis::HTTP_CREATED, error);
    ASSERT_TRUE(entry);

    fake_drive_service_->SetLastModifiedTime(
        entry->file_id(), modification_time,
        google_apis::test_util::CreateCopyResultCallback(&error, &entry));
    base::RunLoop().RunUntilIdle();
    ASSERT_EQ(google_apis::HTTP_SUCCESS, error);
    ASSERT_TRUE(entry);

    fake_drive_service_->SetFileCapabilities(
        entry->file_id(), capabilities,
        google_apis::test_util::CreateCopyResultCallback(&error, &entry));
    base::RunLoop().RunUntilIdle();
    ASSERT_TRUE(error == google_apis::HTTP_SUCCESS);
    ASSERT_TRUE(entry);
  }

  void Unmount() { integration_service_->SetEnabled(false); }

  void Unmount(Profile* profile) {
    VolumeManager::Get(profile)->RemoveAndroidFilesDirectoryForTesting(
        root_path());
  }

void FileManagerBrowserTestBase::LaunchExtension(const base::FilePath& path,
                                                 const char* manifest_name) {
  base::FilePath source_dir;
  CHECK(base::PathService::Get(base::DIR_SOURCE_ROOT, &source_dir));

  const base::FilePath source_path = source_dir.Append(path);
  const extensions::Extension* const extension_launched =
      LoadExtensionAsComponentWithManifest(source_path, manifest_name);
  CHECK(extension_launched) << "Launching: " << manifest_name;
}

void FileManagerBrowserTestBase::OnCommand(const std::string& name,
                                           const base::DictionaryValue& value,
                                           std::string* output) {
  base::ScopedAllowBlockingForTesting allow_blocking;

  if (name == "isInGuestMode") {
    if (IsGuestModeTest() || IsIncognitoModeTest()) {
      LOG(INFO) << GetTestCaseName() << " isInGuestMode: true";
      *output = "true";
    } else {
      ASSERT_EQ(NOT_IN_GUEST_MODE, GetGuestMode());
      *output = "false";
    }

    return;
  }

  if (name == "getDriveFsEnabled") {
    *output = IsDriveFsTest() ? "true" : "false";
    return;
  }

  if (name == "zipArchiverLoaded") {
    if (IsZipTest()) {
      LOG(INFO) << "Preloading zip archiver NaCl module";
      auto event = std::make_unique<extensions::Event>(
          extensions::events::FOR_TEST,
          extensions::api::test::OnMessage::kEventName,
          base::ListValue::From(base::JSONReader::ReadDeprecated(
              R"([{"data": "preloadZip", "lastMessage": false}])")),
          profile());
      extensions::EventRouter::Get(profile())->DispatchEventToExtension(
          kZipArchiverId, std::move(event));
    }
    return;
  }

  if (name == "getRootPaths") {
    const std::string downloads_path =
        base::FeatureList::IsEnabled(chromeos::features::kMyFilesVolume)
            ? "/Downloads"
            : "";
    const auto downloads_root =
        util::GetDownloadsMountPointName(profile()) + downloads_path;

    base::DictionaryValue dictionary;
    dictionary.SetString("downloads", "/" + downloads_root);
    dictionary.SetString("downloads_path", downloads_path);

    if (!profile()->IsGuestSession()) {
      auto* drive_integration_service =
          drive::DriveIntegrationServiceFactory::GetForProfile(profile());
      if (drive_integration_service->IsMounted()) {
        const auto drive_mount_name =
            base::FilePath(drive_integration_service->GetMountPointPath())
                .BaseName();
        dictionary.SetString(
            "drive", base::StrCat({"/", drive_mount_name.value(), "/root"}));
      }
      if (android_files_volume_) {
        dictionary.SetString("android_files",
                             "/" + util::GetAndroidFilesMountPointName());
      }
    }
    base::JSONWriter::Write(dictionary, output);
    return;
  }

  if (name == "getTestName") {
    *output = GetTestCaseName();
    return;
  }

  if (name == "getCwsWidgetContainerMockUrl") {
    const GURL url = embedded_test_server()->GetURL(
        "/chromeos/file_manager/cws_container_mock/index.html");
    std::string origin = url.GetOrigin().spec();
    if (*origin.rbegin() == '/')  // Strip origin trailing '/'.
      origin.resize(origin.length() - 1);

    base::DictionaryValue dictionary;
    dictionary.SetString("url", url.spec());
    dictionary.SetString("origin", origin);

    base::JSONWriter::Write(dictionary, output);
    return;
  }

  if (name == "addEntries") {
    AddEntriesMessage message;
    ASSERT_TRUE(AddEntriesMessage::ConvertJSONValue(value, &message));

    for (size_t i = 0; i < message.entries.size(); ++i) {
      switch (message.volume) {
        case AddEntriesMessage::LOCAL_VOLUME:
          local_volume_->CreateEntry(*message.entries[i]);
          break;
        case AddEntriesMessage::CROSTINI_VOLUME:
          CHECK(crostini_volume_);
          ASSERT_TRUE(crostini_volume_->Initialize(profile()));
          crostini_volume_->CreateEntry(*message.entries[i]);
          break;
        case AddEntriesMessage::DRIVE_VOLUME:
          if (drive_volume_) {
            drive_volume_->CreateEntry(*message.entries[i]);
          } else if (!IsGuestModeTest()) {
            LOG(FATAL) << "Add entry: but no Drive volume.";
          }
          break;
        case AddEntriesMessage::USB_VOLUME:
          if (usb_volume_) {
            usb_volume_->CreateEntry(*message.entries[i]);
          } else {
            LOG(FATAL) << "Add entry: but no USB volume.";
          }
          break;
        case AddEntriesMessage::ANDROID_FILES_VOLUME:
          if (android_files_volume_) {
            android_files_volume_->CreateEntry(*message.entries[i]);
          } else {
            LOG(FATAL) << "Add entry: but no Android files volume.";
          }
          break;
        case AddEntriesMessage::DOCUMENTS_PROVIDER_VOLUME:
          if (documents_provider_volume_) {
            documents_provider_volume_->CreateEntry(*message.entries[i]);
          } else {
            LOG(FATAL) << "Add entry: but no DocumentsProvider volume.";
          }
          break;
      }
    }

    return;
  }

  if (name == "mountFakeUsb" || name == "mountFakeUsbEmpty" ||
      name == "mountFakeUsbDcim") {
    usb_volume_ = std::make_unique<FakeTestVolume>(
        "fake-usb", VOLUME_TYPE_REMOVABLE_DISK_PARTITION,
        chromeos::DEVICE_TYPE_USB);

    if (name == "mountFakeUsb")
      ASSERT_TRUE(usb_volume_->PrepareTestEntries(profile()));
    else if (name == "mountFakeUsbDcim")
      ASSERT_TRUE(usb_volume_->PrepareDcimTestEntries(profile()));

    ASSERT_TRUE(usb_volume_->Mount(profile()));
    return;
  }

  if (name == "unmountUsb") {
    DCHECK(usb_volume_);
    usb_volume_->Unmount(profile());
  }

  if (name == "mountUsbWithPartitions") {
    constexpr char kDevicePath[] =
        "sys/devices/pci0000:00/0000:00:14.0/usb1/1-2/1-2.2/1-2.2:1.0/host0/"
        "target0:0:0/0:0:0:0";
    const base::FilePath device_path(kDevicePath);

    partition_1_ = std::make_unique<RemovableTestVolume>(
        "partition-1", VOLUME_TYPE_REMOVABLE_DISK_PARTITION,
        chromeos::DEVICE_TYPE_USB, device_path, "Drive Label");
    partition_2_ = std::make_unique<RemovableTestVolume>(
        "partition-2", VOLUME_TYPE_REMOVABLE_DISK_PARTITION,
        chromeos::DEVICE_TYPE_USB, device_path, "Drive Label");

    ASSERT_TRUE(partition_1_->PreparePartitionTestEntries(profile()));
    ASSERT_TRUE(partition_2_->PreparePartitionTestEntries(profile()));

    ASSERT_TRUE(partition_1_->Mount(profile()));
    ASSERT_TRUE(partition_2_->Mount(profile()));
    return;
  }

  if (name == "unmountPartitions") {
    DCHECK(partition_1_);
    DCHECK(partition_2_);
    partition_1_->Unmount(profile());
    partition_2_->Unmount(profile());
    return;
  }

  if (name == "mountFakeMtp" || name == "mountFakeMtpEmpty") {
    mtp_volume_ = std::make_unique<FakeTestVolume>(
        "fake-mtp", VOLUME_TYPE_MTP, chromeos::DEVICE_TYPE_UNKNOWN);

    if (name == "mountFakeMtp")
      ASSERT_TRUE(mtp_volume_->PrepareTestEntries(profile()));

    ASSERT_TRUE(mtp_volume_->Mount(profile()));
    return;
  }

  if (name == "mountDrive") {
    ASSERT_TRUE(drive_volume_->Mount(profile()));
    return;
  }

  if (name == "unmountDrive") {
    drive_volume_->Unmount();
    return;
  }

  if (name == "mountDownloads") {
    ASSERT_TRUE(local_volume_->Mount(profile()));
    return;
  }

  if (name == "unmountDownloads") {
    local_volume_->Unmount(profile());
    return;
  }

  if (name == "mountMediaView") {
    CHECK(arc::IsArcAvailable())
        << "ARC required for mounting media view volumes";

    media_view_images_ = std::make_unique<MediaViewTestVolume>(
        arc_file_system_instance_.get(),
        "com.android.providers.media.documents", arc::kImagesRootDocumentId);
    media_view_videos_ = std::make_unique<MediaViewTestVolume>(
        arc_file_system_instance_.get(),
        "com.android.providers.media.documents", arc::kVideosRootDocumentId);
    media_view_audio_ = std::make_unique<MediaViewTestVolume>(
        arc_file_system_instance_.get(),
        "com.android.providers.media.documents", arc::kAudioRootDocumentId);

    ASSERT_TRUE(media_view_images_->Mount(profile()));
    ASSERT_TRUE(media_view_videos_->Mount(profile()));
    ASSERT_TRUE(media_view_audio_->Mount(profile()));
    return;
  }

  if (name == "mountPlayFiles") {
    DCHECK(android_files_volume_);
    android_files_volume_->Mount(profile());
    return;
  }

  if (name == "unmountPlayFiles") {
    DCHECK(android_files_volume_);
    android_files_volume_->Unmount(profile());
    return;
  }

  if (name == "setDriveEnabled") {
    bool enabled;
    ASSERT_TRUE(value.GetBoolean("enabled", &enabled));
    profile()->GetPrefs()->SetBoolean(drive::prefs::kDisableDrive, !enabled);
    return;
  }

  if (name == "useCellularNetwork") {
    net::NetworkChangeNotifier::NotifyObserversOfMaxBandwidthChangeForTests(
        net::NetworkChangeNotifier::GetMaxBandwidthMbpsForConnectionSubtype(
            net::NetworkChangeNotifier::SUBTYPE_HSPA),
        net::NetworkChangeNotifier::CONNECTION_3G);
    return;
  }

  if (name == "clickNotificationButton") {
    std::string extension_id;
    std::string notification_id;
    ASSERT_TRUE(value.GetString("extensionId", &extension_id));
    ASSERT_TRUE(value.GetString("notificationId", &notification_id));

    const std::string delegate_id = extension_id + "-" + notification_id;
    base::Optional<message_center::Notification> notification =
        display_service_->GetNotification(delegate_id);
    EXPECT_TRUE(notification);

    int index;
    ASSERT_TRUE(value.GetInteger("index", &index));
    display_service_->SimulateClick(NotificationHandler::Type::EXTENSION,
                                    delegate_id, index, base::nullopt);
    return;
  }

  if (name == "launchProviderExtension") {
    std::string manifest;
    ASSERT_TRUE(value.GetString("manifest", &manifest));
    LaunchExtension(base::FilePath(FILE_PATH_LITERAL(
                        "ui/file_manager/integration_tests/testing_provider")),
                    manifest.c_str());
    return;
  }

  if (name == "dispatchNativeMediaKey") {
    ui::KeyEvent key_event(ui::ET_KEY_PRESSED, ui::VKEY_MEDIA_PLAY_PAUSE, 0);

    const auto& app_windows =
        extensions::AppWindowRegistry::Get(profile())->app_windows();
    ASSERT_FALSE(app_windows.empty());
    app_windows.front()->GetNativeWindow()->GetHost()->DispatchKeyEventPostIME(
        &key_event, base::NullCallback());
    *output = "mediaKeyDispatched";
    return;
  }

  if (name == "dispatchTabKey") {
    ui::KeyEvent key_event(ui::ET_KEY_PRESSED, ui::VKEY_TAB, 0);

    const auto& app_windows =
        extensions::AppWindowRegistry::Get(profile())->app_windows();
    aura::WindowTreeHost* host = nullptr;
    if (app_windows.empty()) {
      ASSERT_TRUE(select_factory_);
      views::Widget* widget = select_factory_->GetLastWidget();
      ASSERT_TRUE(widget);
      host = widget->GetNativeWindow()->GetHost();
    } else {
      host = app_windows.front()->GetNativeWindow()->GetHost();
    }
    ASSERT_TRUE(host);
    host->DispatchKeyEventPostIME(&key_event, base::NullCallback());
    *output = "tabKeyDispatched";
    return;
  }

  if (name == "getAppWindowId") {
    std::string window_url;
    ASSERT_TRUE(value.GetString("windowUrl", &window_url));

    const auto& app_windows =
        extensions::AppWindowRegistry::Get(profile())->app_windows();
    ASSERT_FALSE(app_windows.empty());
    *output = "none";
    for (auto* window : app_windows) {
      if (!window->web_contents())
        continue;

      if (window->web_contents()->GetLastCommittedURL() == window_url) {
        *output = base::NumberToString(window->session_id().id());
        break;
      }
    }
    return;
  }

  if (name == "countAppWindows") {
    std::string app_id;
    ASSERT_TRUE(value.GetString("appId", &app_id));

    const auto& app_windows =
        extensions::AppWindowRegistry::Get(profile())->app_windows();
    ASSERT_FALSE(app_windows.empty());
    int window_count = 0;
    for (auto* window : app_windows) {
      if (window->extension_id() == app_id)
        window_count++;
    }
    *output = base::NumberToString(window_count);
    return;
  }

  if (name == "runJsInAppWindow") {
    std::string window_id_str;
    ASSERT_TRUE(value.GetString("windowId", &window_id_str));
    int window_id = 0;
    ASSERT_TRUE(base::StringToInt(window_id_str, &window_id));
    std::string script;
    ASSERT_TRUE(value.GetString("script", &script));

    const auto& app_windows =
        extensions::AppWindowRegistry::Get(profile())->app_windows();
    ASSERT_FALSE(app_windows.empty());
    for (auto* window : app_windows) {
      CHECK(window);
      if (window->session_id().id() != window_id) {
        continue;
      }

      if (!window->web_contents())
        break;

      CHECK(window->web_contents()->GetMainFrame());
      window->web_contents()->GetMainFrame()->ExecuteJavaScriptForTests(
          base::UTF8ToUTF16(script), base::NullCallback());

      break;
    }
    return;
  }

  if (name == "enableTabletMode") {
    ::test::SetAndWaitForTabletMode(true);
    *output = "tabletModeEnabled";
    return;
  }

  if (name == "runSelectFileDialog") {
    browser()->OpenFile();
    content::TestNavigationObserver observer(
        browser()->tab_strip_model()->GetActiveWebContents(), 1);
    observer.Wait();
    *output = observer.last_navigation_url().spec();
    return;
  }

  if (name == "isSmbEnabled") {
    *output = IsNativeSmbTest() ? "true" : "false";
    return;
  }

  if (name == "runLauncherSearch") {
    app_list::LauncherSearchProvider search_provider(profile());
    base::string16 query;
    ASSERT_TRUE(value.GetString("query", &query));

    search_provider.Start(query);
    base::RunLoop run_loop;
    search_provider.set_result_changed_callback(run_loop.QuitClosure());
    run_loop.Run();

    std::vector<base::Value> names;
    for (auto& result : search_provider.results()) {
      names.emplace_back(result->title());
    }
    std::sort(names.begin(), names.end());
    base::JSONWriter::Write(base::Value(std::move(names)), output);
    return;
  }

  if (name == "blockFileTaskRunner") {
    BlockFileTaskRunner(profile());
    return;
  }

  if (name == "unblockFileTaskRunner") {
    UnblockFileTaskRunner();
    return;
  }

  if (name == "expectFileTask") {
    ExpectFileTasksMessage message;
    ASSERT_TRUE(ExpectFileTasksMessage::ConvertJSONValue(value, &message));
    if (!file_tasks_observer_) {
      return;
    }
    for (const auto& file_name : message.file_names) {
      EXPECT_CALL(
          *file_tasks_observer_,
          OnFilesOpenedImpl(testing::HasSubstr(*file_name), message.open_type));
    }
    return;
  }

  FAIL() << "Unknown test message: " << name;
}

    static bool MapStringToEntryType(base::StringPiece value, EntryType* type) {
      if (value == "file")
        *type = FILE;
      else if (value == "directory")
        *type = DIRECTORY;
      else if (value == "team_drive")
        *type = TEAM_DRIVE;
      else if (value == "Computer")
        *type = COMPUTER;
      else
        return false;
      return true;
    }

  const base::FilePath& mount_path() const { return root_path(); }

  bool PreparePartitionTestEntries(Profile* profile) {
    if (!CreateRootDirectory(profile))
      return false;

    CreateEntry(AddEntriesMessage::TestEntryInfo(AddEntriesMessage::FILE,
                                                 "text.txt", "hello.txt")
                    .SetMimeType("text/plain"));

    CreateEntry(AddEntriesMessage::TestEntryInfo(AddEntriesMessage::DIRECTORY,
                                                 "", "Folder"));
    base::RunLoop().RunUntilIdle();
    return true;
  }

    EntryFolderFeature(bool is_machine_root,
                       bool is_arbitrary_sync_folder,
                       bool is_external_media)
        : is_machine_root(is_machine_root),
          is_arbitrary_sync_folder(is_arbitrary_sync_folder),
          is_external_media(is_external_media) {}

  void Unmount(Profile* profile) {
    VolumeManager::Get(profile)->RemoveVolumeForTesting(
        root_path(), volume_type_, device_type_, read_only_);
  }

    static bool MapStringToTime(base::StringPiece value, base::Time* time) {
      return base::Time::FromString(value.as_string().c_str(), time);
    }

    TestEntryInfo& SetComputerName(const std::string& name) {
      computer_name = name;
      return *this;
    }

void FileManagerBrowserTestBase::EnableVirtualKeyboard() {
  CHECK(IsTabletModeTest());

  ash::mojom::ShellTestApiPtr shell_test_api;
  content::ServiceManagerConnection::GetForProcess()
      ->GetConnector()
      ->BindInterface(ash::mojom::kServiceName, &shell_test_api);
  ash::mojom::ShellTestApiAsyncWaiter waiter(shell_test_api.get());
  waiter.EnableVirtualKeyboard();
}

  static bool ConvertJSONValue(const base::DictionaryValue& value,
                               ExpectFileTasksMessage* message) {
    base::JSONValueConverter<ExpectFileTasksMessage> converter;
    return converter.Convert(value, message);
  }

  base::FilePath GetTeamDriveGrandRoot() {
    return mount_path().Append("team_drives");
  }

  static void RegisterJSONConverter(
      base::JSONValueConverter<AddEntriesMessage>* converter) {
    converter->RegisterCustomField("volume", &AddEntriesMessage::volume,
                                   &MapStringToTargetVolume);
    converter->RegisterRepeatedMessage<struct TestEntryInfo>(
        "entries", &AddEntriesMessage::entries);
  }

  explicit TestVolume(const std::string& name) : name_(name) {}

  void Unmount(Profile* profile) {
    auto* volume = VolumeManager::Get(profile);
    volume->RemoveDownloadsDirectoryForTesting();
  }

  storage::ExternalMountPoints* GetMountPoints() {
    return storage::ExternalMountPoints::GetSystemInstance();
  }

  DocumentsProviderTestVolume(
      const std::string& name,
      arc::FakeFileSystemInstance* const file_system_instance,
      const std::string& authority,
      const std::string& root_document_id)
      : TestVolume(name),
        file_system_instance_(file_system_instance),
        authority_(authority),
        root_document_id_(root_document_id) {}

  explicit DriveFsTestVolume(Profile* profile) : profile_(profile) {}

    TestEntryInfo& SetTeamDriveName(const std::string& name) {
      team_drive_name = name;
      return *this;
    }

    static void RegisterJSONConverter(
        base::JSONValueConverter<EntryFolderFeature>* converter) {
      converter->RegisterBoolField("isMachineRoot",
                                   &EntryFolderFeature::is_machine_root);
      converter->RegisterBoolField(
          "isArbitrarySyncFolder",
          &EntryFolderFeature::is_arbitrary_sync_folder);
      converter->RegisterBoolField("isExternalMedia",
                                   &EntryFolderFeature::is_external_media);
    }

  static void RegisterJSONConverter(
      base::JSONValueConverter<ExpectFileTasksMessage>* converter) {
    converter->RegisterCustomField(
        "openType", &ExpectFileTasksMessage::open_type, &MapStringToOpenType);
    converter->RegisterRepeatedString("fileNames",
                                      &ExpectFileTasksMessage::file_names);
  }

  base::FilePath GetComputerPath(const std::string& computer_name) {
    return GetComputerGrandRoot().Append(computer_name);
  }

  const base::FilePath& root_path() const { return root_; }

base::FilePath FileManagerBrowserTestBase::MaybeMountCrostini(
    const std::string& source_path,
    const std::vector<std::string>& mount_options) {
  GURL source_url(source_path);
  DCHECK(source_url.is_valid());
  if (source_url.scheme() != "sshfs") {
    return {};
  }
  CHECK(crostini_volume_->Mount(profile()));
  return crostini_volume_->mount_path();
}

void UnblockFileTaskRunner() {
  GetLockForBlockingDefaultFileTaskRunner().Release();
}

  CreateDriveFsBootstrapListener() {
    return {};
  }

    static void RegisterJSONConverter(
        base::JSONValueConverter<TestEntryInfo>* converter) {
      converter->RegisterCustomField("type", &TestEntryInfo::type,
                                     &MapStringToEntryType);
      converter->RegisterStringField("sourceFileName",
                                     &TestEntryInfo::source_file_name);
      converter->RegisterStringField("targetPath", &TestEntryInfo::target_path);
      converter->RegisterStringField("nameText", &TestEntryInfo::name_text);
      converter->RegisterStringField("teamDriveName",
                                     &TestEntryInfo::team_drive_name);
      converter->RegisterStringField("computerName",
                                     &TestEntryInfo::computer_name);
      converter->RegisterStringField("mimeType", &TestEntryInfo::mime_type);
      converter->RegisterCustomField("sharedOption",
                                     &TestEntryInfo::shared_option,
                                     &MapStringToSharedOption);
      converter->RegisterCustomField("lastModifiedTime",
                                     &TestEntryInfo::last_modified_time,
                                     &MapStringToTime);
      converter->RegisterNestedField("capabilities",
                                     &TestEntryInfo::capabilities);
      converter->RegisterNestedField("folderFeature",
                                     &TestEntryInfo::folder_feature);
      converter->RegisterBoolField("pinned", &TestEntryInfo::pinned);
    }

  bool Initialize(Profile* profile) { return CreateRootDirectory(profile); }

bool FileManagerBrowserTestBase::GetEnableArc() const {
  return false;
}

  base::FilePath base_path() const {
    if (base::FeatureList::IsEnabled(chromeos::features::kMyFilesVolume))
      return root_path().Append("Downloads");

    return root_path();
  }

  base::FilePath GetRelativeDrivePathForTestEntry(
      const AddEntriesMessage::TestEntryInfo& entry) {
    const base::FilePath target_path = GetTargetPathForTestEntry(entry);
    base::FilePath drive_path("/");
    CHECK(mount_path().AppendRelativePath(target_path, &drive_path));
    return drive_path;
  }

    static void RegisterJSONConverter(
        base::JSONValueConverter<EntryCapabilities>* converter) {
      converter->RegisterBoolField("canCopy", &EntryCapabilities::can_copy);
      converter->RegisterBoolField("canDelete", &EntryCapabilities::can_delete);
      converter->RegisterBoolField("canRename", &EntryCapabilities::can_rename);
      converter->RegisterBoolField("canAddChildren",
                                   &EntryCapabilities::can_add_children);
      converter->RegisterBoolField("canShare", &EntryCapabilities::can_share);
    }

void BlockFileTaskRunner(Profile* profile) {
  GetLockForBlockingDefaultFileTaskRunner().Acquire();

  content::BrowserContext::GetDefaultStoragePartition(profile)
      ->GetFileSystemContext()
      ->default_file_task_runner()
      ->PostTask(FROM_HERE, base::BindOnce([] {
                   base::AutoLock l(GetLockForBlockingDefaultFileTaskRunner());
                 }));
}

  RemovableTestVolume(const std::string& name,
                      VolumeType volume_type,
                      chromeos::DeviceType device_type,
                      const base::FilePath& device_path,
                      const std::string& drive_label)
      : LocalTestVolume(name),
        volume_type_(volume_type),
        device_type_(device_type),
        device_path_(device_path),
        drive_label_(drive_label) {}

  views::Widget* GetLastWidget() {
    return last_select_->extension_dialog_->GetWidget();
  }

  base::FilePath GetTargetPathForTestEntry(
      const AddEntriesMessage::TestEntryInfo& entry) {
    const base::FilePath target_path =
        GetTargetBasePathForTestEntry(entry).Append(entry.target_path);
    if (entry.name_text != entry.target_path)
      return target_path.DirName().Append(entry.name_text);
    return target_path;
  }

    TestEntryInfo& SetEntryCapabilities(
        const EntryCapabilities& new_capabilities) {
      capabilities = new_capabilities;
      return *this;
    }

bool FileManagerBrowserTestBase::GetEnableDocumentsProvider() const {
  return false;
}

void FileManagerBrowserTestBase::SetUp() {
  net::NetworkChangeNotifier::SetTestNotificationsOnly(true);
  extensions::ExtensionApiTest::SetUp();
}

bool FileManagerBrowserTestBase::GetEnableNativeSmb() const {
  return true;
}

  DocumentsProviderTestVolume(
      arc::FakeFileSystemInstance* const file_system_instance,
      const std::string& authority,
      const std::string& root_document_id)
      : DocumentsProviderTestVolume("DocumentsProvider",
                                    file_system_instance,
                                    authority,
                                    root_document_id) {}

  static bool MapStringToTargetVolume(base::StringPiece value,
                                      TargetVolume* volume) {
    if (value == "local")
      *volume = LOCAL_VOLUME;
    else if (value == "drive")
      *volume = DRIVE_VOLUME;
    else if (value == "crostini")
      *volume = CROSTINI_VOLUME;
    else if (value == "usb")
      *volume = USB_VOLUME;
    else if (value == "android_files")
      *volume = ANDROID_FILES_VOLUME;
    else if (value == "documents_provider")
      *volume = DOCUMENTS_PROVIDER_VOLUME;
    else
      return false;
    return true;
  }

  void CheckForUpdates() {
    if (integration_service_ && integration_service_->file_system()) {
      integration_service_->file_system()->CheckForUpdates();
    }
  }

  CrostiniTestVolume() : LocalTestVolume("Crostini") {}

  FileManagerTestMessageListener() {
    registrar_.Add(this, extensions::NOTIFICATION_EXTENSION_TEST_PASSED,
                   content::NotificationService::AllSources());
    registrar_.Add(this, extensions::NOTIFICATION_EXTENSION_TEST_FAILED,
                   content::NotificationService::AllSources());
    registrar_.Add(this, extensions::NOTIFICATION_EXTENSION_TEST_MESSAGE,
                   content::NotificationService::AllSources());
  }

  void RegisterRoot() {
    arc::FakeFileSystemInstance::Document document(
        authority_, root_document_id_, "", "", arc::kAndroidDirectoryMimeType,
        0, 0);
    file_system_instance_->AddDocument(document);
  }

bool FileManagerBrowserTestBase::GetIsOffline() const {
  return false;
}

bool FileManagerBrowserTestBase::GetNeedsZipSupport() const {
  return false;
}

void FileManagerBrowserTestBase::RunTestMessageLoop() {
  FileManagerTestMessageListener listener;

  while (true) {
    auto message = listener.GetNextMessage();

    if (message.type == extensions::NOTIFICATION_EXTENSION_TEST_PASSED)
      return;  // Test PASSED.
    if (message.type == extensions::NOTIFICATION_EXTENSION_TEST_FAILED) {
      ADD_FAILURE() << message.message;
      return;  // Test FAILED.
    }

    const auto json = base::JSONReader::ReadDeprecated(message.message);
    const base::DictionaryValue* dictionary = nullptr;
    std::string command;
    if (!json || !json->GetAsDictionary(&dictionary) ||
        !dictionary->GetString("name", &command)) {
      message.function->Reply(std::string());
      continue;
    }

    std::string result;
    OnCommand(command, *dictionary, &result);
    if (!HasFatalFailure()) {
      message.function->Reply(result);
      continue;
    }

    LOG(INFO) << "[FAILED] " << GetTestCaseName();
    return;
  }
}

  static base::FilePath GetTestDataFilePath(const std::string& file_name) {
    base::FilePath source_dir;
    CHECK(base::PathService::Get(base::DIR_SOURCE_ROOT, &source_dir));
    auto test_data_dir = source_dir.AppendASCII("chrome")
                             .AppendASCII("test")
                             .AppendASCII("data")
                             .AppendASCII("chromeos")
                             .AppendASCII("file_manager");
    return test_data_dir.Append(base::FilePath::FromUTF8Unsafe(file_name));
  }

  bool UpdateModifiedTime(const AddEntriesMessage::TestEntryInfo& entry,
                          const base::FilePath& path) {
    if (!base::TouchFile(path, entry.last_modified_time,
                         entry.last_modified_time)) {
      return false;
    }

    if (path.DirName() != root_path()) {
      const auto& it = entries_.find(path.DirName());
      if (it == entries_.end())
        return false;
      return UpdateModifiedTime(it->second, path.DirName());
    }

    return true;
  }

    static bool MapStringToSharedOption(base::StringPiece value,
                                        SharedOption* option) {
      if (value == "shared")
        *option = SHARED;
      else if (value == "sharedWithMe")
        *option = SHARED_WITH_ME;
      else if (value == "nestedSharedWithMe")
        *option = NESTED_SHARED_WITH_ME;
      else if (value == "none")
        *option = NONE;
      else
        return false;
      return true;
    }

bool FileManagerBrowserTestBase::GetStartWithNoVolumesMounted() const {
  return false;
}

  MediaViewTestVolume(arc::FakeFileSystemInstance* const file_system_instance,
                      const std::string& authority,
                      const std::string& root_document_id)
      : DocumentsProviderTestVolume(root_document_id,
                                    file_system_instance,
                                    authority,
                                    root_document_id) {}

    TestEntryInfo& SetPinned(bool is_pinned) {
      pinned = is_pinned;
      return *this;
    }

  virtual bool Mount(Profile* profile) {
    RegisterRoot();

    VolumeManager::Get(profile)->OnDocumentsProviderRootAdded(
        authority_, root_document_id_, root_document_id_, name(), "", GURL(),
        true, std::vector<std::string>());
    return true;
  }

bool FileManagerBrowserTestBase::GetTabletMode() const {
  return false;
}

  bool UpdateModifiedTime(const AddEntriesMessage::TestEntryInfo& entry) {
    const auto path = GetTargetPathForTestEntry(entry);
    if (!base::TouchFile(path, entry.last_modified_time,
                         entry.last_modified_time)) {
      return false;
    }

    if (path.DirName() != GetTeamDriveGrandRoot() &&
        path.DirName() != GetComputerGrandRoot() &&
        path.DirName() != GetMyDrivePath() &&
        path.DirName() != GetSharedWithMePath()) {
      const auto it = entries_.find(path.DirName());
      if (it == entries_.end())
        return false;
      return UpdateModifiedTime(it->second);
    }

    return true;
  }

void FileManagerBrowserTestBase::SetUpCommandLine(
    base::CommandLine* command_line) {
  command_line->AppendSwitch(switches::kDisableAudioOutput);

  if (!GetRequiresStartupBrowser()) {
    command_line->AppendSwitch(switches::kNoStartupWindow);

    set_exit_when_last_browser_closes(false);
  }

  if (IsGuestModeTest()) {
    command_line->AppendSwitch(chromeos::switches::kGuestSession);
    command_line->AppendSwitchNative(chromeos::switches::kLoginUser, "$guest");
    command_line->AppendSwitchASCII(chromeos::switches::kLoginProfile, "user");
    command_line->AppendSwitch(switches::kIncognito);
    set_chromeos_user_ = false;
  }

  if (IsIncognitoModeTest()) {
     command_line->AppendSwitch(switches::kIncognito);
   }
 
   std::vector<base::Feature> enabled_features;
   std::vector<base::Feature> disabled_features;
 
  if (!IsGuestModeTest()) {
    enabled_features.emplace_back(features::kCrostini);
  }

  if (!IsNativeSmbTest()) {
    disabled_features.emplace_back(features::kNativeSmb);
  }

  if (IsDriveFsTest()) {
    enabled_features.emplace_back(chromeos::features::kDriveFs);
  } else {
    disabled_features.emplace_back(chromeos::features::kDriveFs);
  }

  if (IsMyFilesVolume()) {
    enabled_features.emplace_back(chromeos::features::kMyFilesVolume);
  } else {
    disabled_features.emplace_back(chromeos::features::kMyFilesVolume);
  }

  if (IsArcTest()) {
    arc::SetArcAvailableCommandLineForTesting(command_line);
  }

  if (IsDocumentsProviderTest()) {
    enabled_features.emplace_back(
        arc::kEnableDocumentsProviderInFilesAppFeature);
  } else {
    disabled_features.emplace_back(
        arc::kEnableDocumentsProviderInFilesAppFeature);
  }

  feature_list_.InitWithFeatures(enabled_features, disabled_features);

  extensions::ExtensionApiTest::SetUpCommandLine(command_line);
}

void FileManagerBrowserTestBase::TearDownOnMainThread() {
  file_tasks_observer_.reset();
  select_factory_ = nullptr;
  ui::SelectFileDialog::SetFactory(nullptr);
}

  const std::string& name() const { return name_; }

  explicit MockFileTasksObserver(Profile* profile) : observer_(this) {
    observer_.Add(file_tasks::FileTasksNotifier::GetForProfile(profile));
  }

void FileManagerBrowserTestBase::SetUpOnMainThread() {
// Must happen after the browser process is created because instantiating
// the factory will instantiate ExtensionSystemFactory which depends on
// ExtensionsBrowserClient setup in BrowserProcessImpl.
sync_file_system::SyncFileSystemServiceFactory::GetInstance()
->set_mock_remote_file_service(
std::make_unique<::testing::NiceMock<
sync_file_system::MockRemoteFileSyncService>>());

extensions::ExtensionApiTest::SetUpOnMainThread();
CHECK(profile());
CHECK_EQ(!!browser(), GetRequiresStartupBrowser());

if (DoesTestStartWithNoVolumesMounted()) {
VolumeManager::Get(profile())->RemoveDownloadsDirectoryForTesting();
} else {
CHECK(local_volume_->Mount(profile()));
}

if (!IsGuestModeTest()) {
// Start the embedded test server to serve the mocked CWS widget container.
CHECK(embedded_test_server()->Start());
drive_volume_ = drive_volumes_[profile()->GetOriginalProfile()].get();
if (!DoesTestStartWithNoVolumesMounted()) {
test_util::WaitUntilDriveMountPointIsAdded(profile());
}

// Init crostini.  Set prefs to enable crostini, set VM and container
// running for testing, and register CustomMountPointCallback.
// TODO(joelhockey): It would be better if the crostini interface allowed
// for testing without such tight coupling.
crostini_volume_ = std::make_unique<CrostiniTestVolume>();
profile()->GetPrefs()->SetBoolean(crostini::prefs::kCrostiniEnabled, true);
crostini::CrostiniManager* crostini_manager =
crostini::CrostiniManager::GetForProfile(
profile()->GetOriginalProfile());
crostini_manager->set_skip_restart_for_testing();
crostini_manager->AddRunningVmForTesting(crostini::kCrostiniDefaultVmName);
crostini_manager->AddRunningContainerForTesting(
crostini::kCrostiniDefaultVmName,
crostini::ContainerInfo(crostini::kCrostiniDefaultContainerName,
"testuser", "/home/testuser"));
chromeos::DBusThreadManager* dbus_thread_manager =
chromeos::DBusThreadManager::Get();
static_cast<chromeos::FakeCrosDisksClient*>(
dbus_thread_manager->GetCrosDisksClient())
->AddCustomMountPointCallback(
base::BindRepeating(&FileManagerBrowserTestBase::MaybeMountCrostini,
base::Unretained(this)));

if (arc::IsArcAvailable()) {
// When ARC is marked as available, we create fake FileSystemInstance and
// register it so that ARC-related services can work without real ARC
// container.
arc_file_system_instance_ =
std::make_unique<arc::FakeFileSystemInstance>();
arc::ArcServiceManager::Get()
->arc_bridge_service()
->file_system()
->SetInstance(arc_file_system_instance_.get());
arc::WaitForInstanceReady(
arc::ArcServiceManager::Get()->arc_bridge_service()->file_system());
ASSERT_TRUE(arc_file_system_instance_->InitCalled());

if (IsDocumentsProviderTest()) {
// Though we can have multiple DocumentsProvider volumes, only one
// volume is created and mounted for now.
documents_provider_volume_ =
std::make_unique<DocumentsProviderTestVolume>(
arc_file_system_instance_.get(), "com.example.documents",
"root");
if (!DoesTestStartWithNoVolumesMounted()) {
documents_provider_volume_->Mount(profile());
}
}
} else {
// When ARC is not available, "Android Files" will not be mounted.
// We need to mount testing volume here.
android_files_volume_ = std::make_unique<AndroidFilesTestVolume>();
if (!DoesTestStartWithNoVolumesMounted()) {
android_files_volume_->Mount(profile());
}
}

if (!IsIncognitoModeTest()) {
file_tasks_observer_ =
std::make_unique<testing::StrictMock<MockFileTasksObserver>>(
profile());
} else {
EXPECT_FALSE(file_tasks::FileTasksNotifier::GetForProfile(profile()));
}
}

display_service_ =
std::make_unique<NotificationDisplayServiceTester>(profile());

  if (IsOfflineTest()) {
    ExtensionFunctionRegistry::GetInstance().OverrideFunctionForTesting(
        "fileManagerPrivate.getDriveConnectionState",
        &NewExtensionFunction<OfflineGetDriveConnectionState>);
  }
content::NetworkConnectionChangeSimulator network_change_simulator;
network_change_simulator.SetConnectionType(
IsOfflineTest() ? network::mojom::ConnectionType::CONNECTION_NONE
: network::mojom::ConnectionType::CONNECTION_ETHERNET);

// The test resources are setup: enable and add default ChromeOS component
// extensions now and not before: crbug.com/831074, crbug.com/804413
test::AddDefaultComponentExtensionsOnMainThread(profile());

// For tablet mode tests, enable the Ash virtual keyboard.
if (IsTabletModeTest()) {
EnableVirtualKeyboard();
}

select_factory_ = new SelectFileDialogExtensionTestFactory();
ui::SelectFileDialog::SetFactory(select_factory_);
}

bool FileManagerBrowserTestBase::GetEnableDriveFs() const {
  return true;
}

void FileManagerBrowserTestBase::SetUpInProcessBrowserTestFixture() {
  extensions::ExtensionApiTest::SetUpInProcessBrowserTestFixture();

  local_volume_ = std::make_unique<DownloadsTestVolume>();

  if (!IsGuestModeTest()) {
    create_drive_integration_service_ =
        base::Bind(&FileManagerBrowserTestBase::CreateDriveIntegrationService,
                   base::Unretained(this));
    service_factory_for_test_ = std::make_unique<
        drive::DriveIntegrationServiceFactory::ScopedFactoryForTest>(
        &create_drive_integration_service_);
  }
}

  bool PrepareUsbTestEntries(Profile* profile) {
    if (!CreateRootDirectory(profile))
      return false;

    CreateEntry(AddEntriesMessage::TestEntryInfo(AddEntriesMessage::FILE,
                                                 "text.txt", "hello.txt")
                    .SetMimeType("text/plain"));
    CreateEntry(AddEntriesMessage::TestEntryInfo(AddEntriesMessage::DIRECTORY,
                                                 "", "Folder"));

    base::RunLoop().RunUntilIdle();
    return true;
  }

 base::Lock& GetLockForBlockingDefaultFileTaskRunner() {
   static base::NoDestructor<base::Lock> lock;
   return *lock;
}

    TestEntryInfo& SetMimeType(const std::string& type) {
      mime_type = type;
      return *this;
    }

  base::FilePath GetSharedWithMePath() {
    return mount_path().Append(".files-by-id/123");
  }

  static bool MapStringToOpenType(
      base::StringPiece value,
      file_tasks::FileTasksObserver::OpenType* open_type) {
    using OpenType = file_tasks::FileTasksObserver::OpenType;
    if (value == "launch") {
      *open_type = OpenType::kLaunch;
    } else if (value == "open") {
      *open_type = OpenType::kOpen;
    } else if (value == "saveAs") {
      *open_type = OpenType::kSaveAs;
    } else if (value == "download") {
      *open_type = OpenType::kDownload;
    } else {
      return false;
    }
    return true;
  }

  FakeTestVolume(const std::string& name,
                 VolumeType volume_type,
                 chromeos::DeviceType device_type)
      : LocalTestVolume(name),
        volume_type_(volume_type),
        device_type_(device_type) {}

    TestEntryInfo& SetLastModifiedTime(const base::Time& time) {
      last_modified_time = time;
      return *this;
    }

  AndroidFilesTestVolume() : LocalTestVolume("AndroidFiles") {}

  base::FilePath mount_path() { return root_path().Append("v2"); }

  DownloadsTestVolume() : LocalTestVolume("Downloads") {}

bool FileManagerBrowserTestBase::GetEnableMyFilesVolume() const {
  return false;
}

  static bool ConvertJSONValue(const base::DictionaryValue& value,
                               AddEntriesMessage* message) {
    base::JSONValueConverter<AddEntriesMessage> converter;
    return converter.Convert(value, message);
  }

  bool Mount(Profile* profile) {
    if (profile != profile_)
      return false;

    if (!integration_service_)
      return false;

    integration_service_->SetEnabled(true);
    CreateDriveFsBootstrapListener();
    return true;
  }

  void CreateDirectory(
      const std::string& parent_id,
      const std::string& target_name,
      const base::Time& modification_time,
      bool shared_with_me,
      const google_apis::FileResourceCapabilities& capabilities) {
    google_apis::DriveApiErrorCode error = google_apis::DRIVE_OTHER_ERROR;

    std::unique_ptr<google_apis::FileResource> entry;
    fake_drive_service_->AddNewDirectory(
        parent_id, target_name, drive::AddNewDirectoryOptions(),
        google_apis::test_util::CreateCopyResultCallback(&error, &entry));
    base::RunLoop().RunUntilIdle();
    ASSERT_EQ(google_apis::HTTP_CREATED, error);
    ASSERT_TRUE(entry);

    fake_drive_service_->SetLastModifiedTime(
        entry->file_id(), modification_time,
        google_apis::test_util::CreateCopyResultCallback(&error, &entry));
    base::RunLoop().RunUntilIdle();
    ASSERT_TRUE(error == google_apis::HTTP_SUCCESS);
    ASSERT_TRUE(entry);

    fake_drive_service_->SetFileCapabilities(
        entry->file_id(), capabilities,
        google_apis::test_util::CreateCopyResultCallback(&error, &entry));
    base::RunLoop().RunUntilIdle();
    ASSERT_TRUE(error == google_apis::HTTP_SUCCESS);
    ASSERT_TRUE(entry);

    if (shared_with_me) {
      ASSERT_EQ(google_apis::HTTP_SUCCESS,
                fake_drive_service_->SetFileAsSharedWithMe(entry->file_id()));
    }
  }

    TestEntryInfo(EntryType type,
                  const std::string& source_file_name,
                  const std::string& target_path)
        : type(type),
          shared_option(NONE),
          source_file_name(source_file_name),
          target_path(target_path),
          last_modified_time(base::Time::Now()) {}

  void InsertEntryOnMap(const AddEntriesMessage::TestEntryInfo& entry,
                        const base::FilePath& target_path) {
    const auto it = entries_.find(target_path);
    if (it == entries_.end())
      entries_.insert(std::make_pair(target_path, entry));
  }

  void CreateTeamDrive(const std::string& name,
                       google_apis::TeamDriveCapabilities capabilities) {
    fake_drive_service_->AddTeamDrive(name, name);
    fake_drive_service_->SetTeamDriveCapabilities(name, capabilities);
  }

bool FileManagerBrowserTestBase::GetRequiresStartupBrowser() const {
  return false;
}
