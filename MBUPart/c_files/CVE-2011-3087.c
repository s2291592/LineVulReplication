void RenderViewImpl::didCommitProvisionalLoad(WebFrame* frame,
bool is_new_navigation) {
DocumentState* document_state =
DocumentState::FromDataSource(frame->dataSource());
NavigationState* navigation_state = document_state->navigation_state();

if (document_state->commit_load_time().is_null())
document_state->set_commit_load_time(Time::Now());

if (is_new_navigation) {
// When we perform a new navigation, we need to update the last committed
// session history entry with state for the page we are leaving.
UpdateSessionHistory(frame);

// We bump our Page ID to correspond with the new session history entry.
page_id_ = next_page_id_++;

    // Don't update history_page_ids_ (etc) for about:swappedout, since we
    // don't want to forget the entry that was there, and since we will
    // never come back to about:swappedout.  Note that we have to call
// UpdateSessionHistory and update page_id_ even in this case, so that
// the current entry gets a state update and so that we don't send a
// state update to the wrong entry when we swap back in.
    if (GetLoadingUrl(frame) != GURL("about:swappedout")) {
// Advance our offset in session history, applying the length limit.
// There is now no forward history.
history_list_offset_++;
if (history_list_offset_ >= content::kMaxSessionHistoryEntries)
history_list_offset_ = content::kMaxSessionHistoryEntries - 1;
history_list_length_ = history_list_offset_ + 1;
history_page_ids_.resize(history_list_length_, -1);
history_page_ids_[history_list_offset_] = page_id_;
}
} else {
// Inspect the navigation_state on this frame to see if the navigation
// corresponds to a session history navigation...  Note: |frame| may or
// may not be the toplevel frame, but for the case of capturing session
// history, the first committed frame suffices.  We keep track of whether
// we've seen this commit before so that only capture session history once
// per navigation.
//
// Note that we need to check if the page ID changed. In the case of a
// reload, the page ID doesn't change, and UpdateSessionHistory gets the
// previous URL and the current page ID, which would be wrong.
if (navigation_state->pending_page_id() != -1 &&
navigation_state->pending_page_id() != page_id_ &&
!navigation_state->request_committed()) {
// This is a successful session history navigation!
UpdateSessionHistory(frame);
page_id_ = navigation_state->pending_page_id();

history_list_offset_ = navigation_state->pending_history_list_offset();

// If the history list is valid, our list of page IDs should be correct.
DCHECK(history_list_length_ <= 0 ||
history_list_offset_ < 0 ||
history_list_offset_ >= history_list_length_ ||
history_page_ids_[history_list_offset_] == page_id_);
}
}

FOR_EACH_OBSERVER(RenderViewObserver, observers_,
DidCommitProvisionalLoad(frame, is_new_navigation));

// Remember that we've already processed this request, so we don't update
// the session history again.  We do this regardless of whether this is
// a session history navigation, because if we attempted a session history
// navigation without valid HistoryItem state, WebCore will think it is a
// new navigation.
navigation_state->set_request_committed(true);

UpdateURL(frame);

// If this committed load was initiated by a client redirect, we're
// at the last stop now, so clear it.
completed_client_redirect_src_ = Referrer();

// Check whether we have new encoding name.
UpdateEncoding(frame, frame->view()->pageEncoding().utf8());
}

WebView* RenderViewImpl::createView(
    WebFrame* creator,
    const WebURLRequest& request,
    const WebWindowFeatures& features,
    const WebString& frame_name,
    WebNavigationPolicy policy) {
  if (shared_popup_counter_->data > kMaximumNumberOfUnacknowledgedPopups)
    return NULL;

  ViewHostMsg_CreateWindow_Params params;
  params.opener_id = routing_id_;
  params.user_gesture = creator->isProcessingUserGesture();
  params.window_container_type = WindowFeaturesToContainerType(features);
  params.session_storage_namespace_id = session_storage_namespace_id_;
  params.frame_name = frame_name;
  params.opener_frame_id = creator->identifier();
  params.opener_url = creator->document().url();
  params.opener_security_origin =
      creator->document().securityOrigin().toString().utf8();
  params.opener_suppressed = creator->willSuppressOpenerInNewFrame();
  params.disposition = NavigationPolicyToDisposition(policy);
  if (!request.isNull())
    params.target_url = request.url();

  int32 routing_id = MSG_ROUTING_NONE;
  int32 surface_id = 0;
  int64 cloned_session_storage_namespace_id;

  RenderThread::Get()->Send(
      new ViewHostMsg_CreateWindow(params,
                                   &routing_id,
                                   &surface_id,
                                   &cloned_session_storage_namespace_id));
  if (routing_id == MSG_ROUTING_NONE)
    return NULL;

  RenderViewImpl* view = RenderViewImpl::Create(
      0,
      routing_id_,
      renderer_preferences_,
      webkit_preferences_,
      shared_popup_counter_,
      routing_id,
      surface_id,
      cloned_session_storage_namespace_id,
      frame_name,
      1,
      screen_info_,
      guest_);
  view->opened_by_user_gesture_ = params.user_gesture;

  view->opener_suppressed_ = params.opener_suppressed;

  GURL creator_url(creator->document().securityOrigin().toString().utf8());
  if (!creator_url.is_valid() || !creator_url.IsStandard())
    creator_url = GURL();
  view->creator_url_ = creator_url;

  view->alternate_error_page_url_ = alternate_error_page_url_;

  return view->webview();
}

WebKit::WebCookieJar* TestWebKitPlatformSupport::cookieJar() {
  return &cookie_jar_;
}

GpuChannelHost* RenderThreadImpl::EstablishGpuChannelSync(
    content::CauseForGpuLaunch cause_for_gpu_launch) {
  if (gpu_channel_.get()) {
    if (gpu_channel_->state() == GpuChannelHost::kUnconnected ||
        gpu_channel_->state() == GpuChannelHost::kConnected)
      return GetGpuChannel();

    gpu_channel_ = NULL;
  }

  int client_id = 0;
  IPC::ChannelHandle channel_handle;
  base::ProcessHandle renderer_process_for_gpu;
  content::GPUInfo gpu_info;
  if (!Send(new GpuHostMsg_EstablishGpuChannel(cause_for_gpu_launch,
                                               &client_id,
                                               &channel_handle,
                                               &renderer_process_for_gpu,
                                               &gpu_info)) ||
      channel_handle.name.empty() ||
#if defined(OS_POSIX)
      channel_handle.socket.fd == -1 ||
#endif
      renderer_process_for_gpu == base::kNullProcessHandle) {
    gpu_channel_ = NULL;
    return NULL;
  }

  gpu_channel_ = new GpuChannelHost(this, 0, client_id);
  gpu_channel_->set_gpu_info(gpu_info);
  content::GetContentClient()->SetGpuInfo(gpu_info);

  gpu_channel_->Connect(channel_handle, renderer_process_for_gpu);

  return GetGpuChannel();
}

TestWebKitPlatformSupport::CreateResourceLoader(
    const webkit_glue::ResourceLoaderBridge::RequestInfo& request_info) {
  return SimpleResourceLoaderBridge::Create(request_info);
}

  static bool GetFilePathWithHostAndPortReplacement(
      const std::string& original_file_path,
      const net::HostPortPair& host_port_pair,
      std::string* replacement_path) {
    std::vector<net::TestServer::StringPair> replacement_text;
    replacement_text.push_back(
        make_pair("REPLACE_WITH_HOST_AND_PORT", host_port_pair.ToString()));
    return net::TestServer::GetFilePathWithReplacements(
        original_file_path, replacement_text, replacement_path);
   }

TestWebKitPlatformSupport::TestWebKitPlatformSupport(bool unit_test_mode)
      : unit_test_mode_(unit_test_mode) {
  v8::V8::SetCounterFunction(base::StatsTable::FindLocation);

  WebKit::initialize(this);
  WebKit::setLayoutTestMode(true);
  WebKit::WebSecurityPolicy::registerURLSchemeAsLocal(
       WebKit::WebString::fromUTF8("test-shell-resource"));
   WebKit::WebSecurityPolicy::registerURLSchemeAsNoAccess(
       WebKit::WebString::fromUTF8("test-shell-resource"));
   WebScriptController::enableV8SingleThreadMode();
   WebKit::WebRuntimeFeatures::enableSockets(true);
   WebKit::WebRuntimeFeatures::enableApplicationCache(true);
  WebKit::WebRuntimeFeatures::enableDatabase(true);
  WebKit::WebRuntimeFeatures::enableDataTransferItems(true);
  WebKit::WebRuntimeFeatures::enablePushState(true);
  WebKit::WebRuntimeFeatures::enableNotifications(true);
  WebKit::WebRuntimeFeatures::enableTouch(true);
  WebKit::WebRuntimeFeatures::enableGamepad(true);

  bool enable_media = false;
  FilePath module_path;
  if (PathService::Get(base::DIR_MODULE, &module_path)) {
#if defined(OS_MACOSX)
    if (base::mac::AmIBundled())
      module_path = module_path.DirName().DirName().DirName();
#endif
    if (media::InitializeMediaLibrary(module_path))
      enable_media = true;
  }
  WebKit::WebRuntimeFeatures::enableMediaPlayer(enable_media);
  LOG_IF(WARNING, !enable_media) << "Failed to initialize the media library.\n";

  WebKit::WebRuntimeFeatures::enableGeolocation(false);

  if (!appcache_dir_.CreateUniqueTempDir()) {
    LOG(WARNING) << "Failed to create a temp dir for the appcache, "
                    "using in-memory storage.";
    DCHECK(appcache_dir_.path().empty());
  }
  SimpleAppCacheSystem::InitializeOnUIThread(appcache_dir_.path());

  WebKit::WebDatabase::setObserver(&database_system_);

  blob_registry_ = new TestShellWebBlobRegistryImpl();

  file_utilities_.set_sandbox_enabled(false);

  if (!file_system_root_.CreateUniqueTempDir()) {
    LOG(WARNING) << "Failed to create a temp dir for the filesystem."
                    "FileSystem feature will be disabled.";
    DCHECK(file_system_root_.path().empty());
  }

#if defined(OS_WIN)
  SetThemeEngine(NULL);
#endif

  net::HttpCache::Mode cache_mode = net::HttpCache::NORMAL;
  net::CookieMonster::EnableFileScheme();

  SimpleResourceLoaderBridge::Init(FilePath(), cache_mode, true);

  webkit_glue::SetJavaScriptFlags(" --expose-gc");
  WebScriptController::registerExtension(extensions_v8::GCExtension::Get());
}

WebKit::WebAudioDevice* TestWebKitPlatformSupport::createAudioDevice(
    size_t bufferSize, unsigned numberOfChannels, double sampleRate,
    WebKit::WebAudioDevice::RenderCallback*) {
  return new WebAudioDeviceMock(sampleRate);
}

TestWebKitPlatformSupport::injectIDBKeyIntoSerializedValue(
    const WebKit::WebIDBKey& key,
    const WebKit::WebSerializedScriptValue& value,
    const WebKit::WebString& keyPath) {
  return WebKit::WebIDBKey::injectIDBKeyIntoSerializedValue(
      key, value, WebKit::WebIDBKeyPath::create(keyPath));
}

TestWebKitPlatformSupport::~TestWebKitPlatformSupport() {
}

WebKit::WebURLLoader* TestWebKitPlatformSupport::createURLLoader() {
  if (!unit_test_mode_)
    return webkit_glue::WebKitPlatformSupportImpl::createURLLoader();
  return url_loader_factory_.CreateURLLoader(
      webkit_glue::WebKitPlatformSupportImpl::createURLLoader());
}

TestWebKitPlatformSupport::createLocalStorageNamespace(
    const WebKit::WebString& path, unsigned quota) {
#ifdef ENABLE_NEW_DOM_STORAGE_BACKEND
  return dom_storage_system_.CreateLocalStorageNamespace();
#else
  return WebKit::WebStorageNamespace::createLocalStorageNamespace(path, quota);
#endif
}

TestWebKitPlatformSupport::createMessagePortChannel() {
  return new TestWebMessagePortChannel();
}

WebKit::WebString TestWebKitPlatformSupport::queryLocalizedString(
    WebKit::WebLocalizedString::Name name, const WebKit::WebString& value) {
  if (name == WebKit::WebLocalizedString::ValidationRangeUnderflow)
    return ASCIIToUTF16("range underflow");
  if (name == WebKit::WebLocalizedString::ValidationRangeOverflow)
    return ASCIIToUTF16("range overflow");
  return WebKitPlatformSupportImpl::queryLocalizedString(name, value);
}

void RegisterContentSchemes(const char** additional_savable_schemes) {
  url_util::AddStandardScheme(chrome::kChromeDevToolsScheme);
  url_util::AddStandardScheme(chrome::kChromeUIScheme);
  url_util::AddStandardScheme(chrome::kMetadataScheme);

  url_util::LockStandardSchemes();

  if (additional_savable_schemes) {
    int schemes = 0;
    while (additional_savable_schemes[++schemes]);
    g_savable_schemes = new char*[schemes + arraysize(kDefaultSavableSchemes)];
    memcpy(g_savable_schemes,
           kDefaultSavableSchemes,
           arraysize(kDefaultSavableSchemes) * sizeof(char*));
    for (int i = 0; i < schemes; ++i) {
      g_savable_schemes[arraysize(kDefaultSavableSchemes) + i - 1] =
          base::strdup(additional_savable_schemes[i]);
    }
    g_savable_schemes[arraysize(kDefaultSavableSchemes) + schemes - 1] = 0;
  }
}

void TestWebKitPlatformSupport::dispatchStorageEvent(
    const WebKit::WebString& key,
    const WebKit::WebString& old_value, const WebKit::WebString& new_value,
    const WebKit::WebString& origin, const WebKit::WebURL& url,
    bool is_local_storage) {
#ifdef ENABLE_NEW_DOM_STORAGE_BACKEND
  NOTREACHED();
#endif
}

WebNavigationPolicy RenderViewImpl::decidePolicyForNavigation(
WebFrame* frame, const WebURLRequest& request, WebNavigationType type,
const WebNode&, WebNavigationPolicy default_policy, bool is_redirect) {
// TODO(creis): Remove this when we fix OnSwapOut to not need a navigation.
if (is_swapped_out_) {
// It is possible for in-progress navigations to arrive here just after we
// are swapped out, including iframes.  We should cancel them.
    if (request.url() != GURL("about:swappedout"))
return WebKit::WebNavigationPolicyIgnore;

    // Allow about:swappedout to complete.
return default_policy;
}

// Webkit is asking whether to navigate to a new URL.
// This is fine normally, except if we're showing UI from one security
// context and they're trying to navigate to a different context.
const GURL& url = request.url();

// A content initiated navigation may have originated from a link-click,
// script, drag-n-drop operation, etc.
bool is_content_initiated =
DocumentState::FromDataSource(frame->provisionalDataSource())->
navigation_state()->is_content_initiated();

// Experimental:
// If --enable-strict-site-isolation is enabled, send all top-level
// navigations to the browser to let it swap processes when crossing site
// boundaries.  This is currently expected to break some script calls and
// navigations, such as form submissions.
const CommandLine& command_line = *CommandLine::ForCurrentProcess();
if (command_line.HasSwitch(switches::kEnableStrictSiteIsolation) &&
!frame->parent() && (is_content_initiated || is_redirect)) {
WebString origin_str = frame->document().securityOrigin().toString();
GURL frame_url(origin_str.utf8().data());
// TODO(cevans): revisit whether this origin check is still necessary once
// crbug.com/101395 is fixed.
if (frame_url.GetOrigin() != url.GetOrigin()) {
Referrer referrer(
GURL(request.httpHeaderField(WebString::fromUTF8("Referer"))),
GetReferrerPolicyFromRequest(request));
OpenURL(frame, url, referrer, default_policy);
return WebKit::WebNavigationPolicyIgnore;
}
}

// If the browser is interested, then give it a chance to look at top level
// navigations.
if (is_content_initiated) {
bool browser_handles_top_level_requests =
renderer_preferences_.browser_handles_top_level_requests &&
IsNonLocalTopLevelNavigation(url, frame, type);
if (browser_handles_top_level_requests ||
renderer_preferences_.browser_handles_all_requests) {
Referrer referrer(
GURL(request.httpHeaderField(WebString::fromUTF8("Referer"))),
GetReferrerPolicyFromRequest(request));
// Reset these counters as the RenderView could be reused for the next
// navigation.
page_id_ = -1;
last_page_id_sent_to_browser_ = -1;
OpenURL(frame, url, referrer, default_policy);
return WebKit::WebNavigationPolicyIgnore;  // Suppress the load here.
}
}

// Detect when we're crossing a permission-based boundary (e.g. into or out of
// an extension or app origin, leaving a WebUI page, etc). We only care about
// top-level navigations (not iframes). But we sometimes navigate to
// about:blank to clear a tab, and we want to still allow that.
//
// Note: this is known to break POST submissions when crossing process
// boundaries until http://crbug.com/101395 is fixed.  This is better for
// security than loading a WebUI, extension or app page in the wrong process.
// POST requests don't work because this mechanism does not preserve form
// POST data. We will need to send the request's httpBody data up to the
// browser process, and issue a special POST navigation in WebKit (via
// FrameLoader::loadFrameRequest). See ResourceDispatcher and WebURLLoaderImpl
// for examples of how to send the httpBody data.
if (!frame->parent() && is_content_initiated &&
!url.SchemeIs(chrome::kAboutScheme)) {
bool send_referrer = false;

// All navigations to WebUI URLs or within WebUI-enabled RenderProcesses
// must be handled by the browser process so that the correct bindings and
// data sources can be registered.
// Similarly, navigations to view-source URLs or within ViewSource mode
// must be handled by the browser process.
int cumulative_bindings =
RenderProcess::current()->GetEnabledBindings();
bool should_fork =
content::GetContentClient()->HasWebUIScheme(url) ||
(cumulative_bindings & content::BINDINGS_POLICY_WEB_UI) ||
url.SchemeIs(chrome::kViewSourceScheme) ||
frame->isViewSourceModeEnabled();

if (!should_fork) {
// Give the embedder a chance.
// For now, we skip this for POST submissions.  This is because
// http://crbug.com/101395 is more likely to cause compatibility issues
// with hosted apps and extensions than WebUI pages.  We will remove this
// check when cross-process POST submissions are supported.
if (request.httpMethod() == "GET") {
bool is_initial_navigation = page_id_ == -1;
should_fork = content::GetContentClient()->renderer()->ShouldFork(
frame, url, is_initial_navigation, &send_referrer);
}
}

if (should_fork) {
Referrer referrer(
GURL(request.httpHeaderField(WebString::fromUTF8("Referer"))),
GetReferrerPolicyFromRequest(request));
OpenURL(
frame, url, send_referrer ? referrer : Referrer(), default_policy);
return WebKit::WebNavigationPolicyIgnore;  // Suppress the load here.
}
}

// Use the frame's original request's URL rather than the document's URL for
// this check.  For a popup, the document's URL may become the opener window's
// URL if the opener has called document.write.  See http://crbug.com/93517.
GURL old_url(frame->dataSource()->request().url());

// Detect when a page is "forking" a new tab that can be safely rendered in
// its own process.  This is done by sites like Gmail that try to open links
// in new windows without script connections back to the original page.  We
// treat such cases as browser navigations (in which we will create a new
// renderer for a cross-site navigation), rather than WebKit navigations.
//
// We use the following heuristic to decide whether to fork a new page in its
// own process:
// The parent page must open a new tab to about:blank, set the new tab's
// window.opener to null, and then redirect the tab to a cross-site URL using
// JavaScript.
//
// TODO(creis): Deprecate this logic once we can rely on rel=noreferrer
// (see below).
bool is_fork =
// Must start from a tab showing about:blank, which is later redirected.
old_url == GURL(chrome::kAboutBlankURL) &&
// Must be the first real navigation of the tab.
historyBackListCount() < 1 &&
historyForwardListCount() < 1 &&
// The parent page must have set the child's window.opener to null before
// redirecting to the desired URL.
frame->opener() == NULL &&
// Must be a top-level frame.
frame->parent() == NULL &&
// Must not have issued the request from this page.
is_content_initiated &&
// Must be targeted at the current tab.
default_policy == WebKit::WebNavigationPolicyCurrentTab &&
// Must be a JavaScript navigation, which appears as "other".
type == WebKit::WebNavigationTypeOther;

if (is_fork) {
// Open the URL via the browser, not via WebKit.
OpenURL(frame, url, Referrer(), default_policy);
return WebKit::WebNavigationPolicyIgnore;
}

return default_policy;
}

gfx::NativeViewId RenderViewImpl::GetHostWindow() const {
  return host_window();
}

void RenderViewImpl::OnSwapOut(const ViewMsg_SwapOut_Params& params) {
// Ensure that no other in-progress navigation continues.
OnStop();

// Only run unload if we're not swapped out yet, but send the ack either way.
if (!is_swapped_out_) {
// Swap this RenderView out so the tab can navigate to a page rendered by a
// different process.  This involves running the unload handler and clearing
// the page.  Once WasSwappedOut is called, we also allow this process to
// exit if there are no other active RenderViews in it.

// Send an UpdateState message before we get swapped out.
SyncNavigationState();

// Synchronously run the unload handler before sending the ACK.
webview()->dispatchUnloadEvent();

// Swap out and stop sending any IPC messages that are not ACKs.
SetSwappedOut(true);

// Replace the page with a blank dummy URL.  The unload handler will not be
// run a second time, thanks to a check in FrameLoader::stopLoading.
// We use loadRequest instead of loadHTMLString because the former commits
// synchronously.  Otherwise a new navigation can interrupt the navigation
    // to about:swappedout.  If that happens to be to the page we had been
// showing, then WebKit will never send a commit and we'll be left spinning.
// TODO(creis): Need to add a better way to do this that avoids running the
// beforeunload handler.  For now, we just run it a second time silently.
    WebURLRequest request(GURL("about:swappedout"));
webview()->mainFrame()->loadRequest(request);
}

// Just echo back the params in the ACK.
Send(new ViewHostMsg_SwapOut_ACK(routing_id_, params));
}

WebKit::WebThemeEngine* TestWebKitPlatformSupport::themeEngine() {
  return active_theme_engine_;
}

bool RenderViewImpl::IsGuest() const {
  return guest_;
}

void TestWebKitPlatformSupport::sampleGamepads(WebKit::WebGamepads& data) {
  data = gamepad_data_;
}

void RenderThreadImpl::OnDOMStorageEvent(
    const DOMStorageMsg_Event_Params& params) {
  if (!dom_storage_event_dispatcher_.get()) {
    EnsureWebKitInitialized();
    dom_storage_event_dispatcher_.reset(WebStorageEventDispatcher::create());
  }
  dom_storage_event_dispatcher_->dispatchStorageEvent(params.key,
      params.old_value, params.new_value, params.origin, params.url,
      params.storage_type == DOM_STORAGE_LOCAL);
}

bool TestWebKitPlatformSupport::canAccelerate2dCanvas() {
  return true;
}

void RenderThreadImpl::EnsureWebKitInitialized() {
  if (webkit_platform_support_.get())
    return;

  v8::V8::SetCounterFunction(base::StatsTable::FindLocation);
  v8::V8::SetCreateHistogramFunction(CreateHistogram);
  v8::V8::SetAddHistogramSampleFunction(AddHistogramSample);

  webkit_platform_support_.reset(new RendererWebKitPlatformSupportImpl);
  WebKit::initialize(webkit_platform_support_.get());

  if (CommandLine::ForCurrentProcess()->HasSwitch(
      switches::kEnableThreadedCompositing)) {
    compositor_thread_.reset(new CompositorThread(this));
    AddFilter(compositor_thread_->GetMessageFilter());
    WebKit::WebCompositor::initialize(compositor_thread_->GetWebThread());
  } else
    WebKit::WebCompositor::initialize(NULL);
  compositor_initialized_ = true;
 
   WebScriptController::enableV8SingleThreadMode();
 
   const CommandLine& command_line = *CommandLine::ForCurrentProcess();
 
   webkit_glue::EnableWebCoreLogChannels(
      command_line.GetSwitchValueASCII(switches::kWebCoreLogChannels));

  if (command_line.HasSwitch(switches::kPlaybackMode) ||
      command_line.HasSwitch(switches::kRecordMode) ||
      command_line.HasSwitch(switches::kNoJsRandomness)) {
    RegisterExtension(extensions_v8::PlaybackExtension::Get());
  }

  if (CommandLine::ForCurrentProcess()->HasSwitch(
          switches::kDomAutomationController)) {
    base::StringPiece extension = content::GetContentClient()->GetDataResource(
        IDR_DOM_AUTOMATION_JS);
    RegisterExtension(new v8::Extension(
        "dom_automation.js", extension.data(), 0, NULL, extension.size()));
  }

  web_database_observer_impl_.reset(
      new WebDatabaseObserverImpl(sync_message_filter()));
  WebKit::WebDatabase::setObserver(web_database_observer_impl_.get());

  WebRuntimeFeatures::enableSockets(
      !command_line.HasSwitch(switches::kDisableWebSockets));

  WebRuntimeFeatures::enableDatabase(
      !command_line.HasSwitch(switches::kDisableDatabases));

  WebRuntimeFeatures::enableDataTransferItems(
      !command_line.HasSwitch(switches::kDisableDataTransferItems));

  WebRuntimeFeatures::enableApplicationCache(
      !command_line.HasSwitch(switches::kDisableApplicationCache));

  WebRuntimeFeatures::enableNotifications(
      !command_line.HasSwitch(switches::kDisableDesktopNotifications));

  WebRuntimeFeatures::enableLocalStorage(
      !command_line.HasSwitch(switches::kDisableLocalStorage));
  WebRuntimeFeatures::enableSessionStorage(
      !command_line.HasSwitch(switches::kDisableSessionStorage));

  WebRuntimeFeatures::enableIndexedDatabase(true);

  WebRuntimeFeatures::enableGeolocation(
      !command_line.HasSwitch(switches::kDisableGeolocation));

  WebKit::WebRuntimeFeatures::enableMediaSource(
      command_line.HasSwitch(switches::kEnableMediaSource));

  WebRuntimeFeatures::enableMediaPlayer(
      media::IsMediaLibraryInitialized());

  WebKit::WebRuntimeFeatures::enableMediaStream(
      command_line.HasSwitch(switches::kEnableMediaStream));

  WebKit::WebRuntimeFeatures::enableFullScreenAPI(
      !command_line.HasSwitch(switches::kDisableFullScreen));

  WebKit::WebRuntimeFeatures::enablePointerLock(
      command_line.HasSwitch(switches::kEnablePointerLock));

  WebKit::WebRuntimeFeatures::enableVideoTrack(
      command_line.HasSwitch(switches::kEnableVideoTrack));

#if defined(OS_CHROMEOS)
  WebRuntimeFeatures::enableWebAudio(false);
#else
  WebRuntimeFeatures::enableWebAudio(
      !command_line.HasSwitch(switches::kDisableWebAudio));
#endif

  WebRuntimeFeatures::enablePushState(true);

  WebRuntimeFeatures::enableTouch(
      command_line.HasSwitch(switches::kEnableTouchEvents));

  WebRuntimeFeatures::enableDeviceMotion(
      command_line.HasSwitch(switches::kEnableDeviceMotion));

  WebRuntimeFeatures::enableDeviceOrientation(
      !command_line.HasSwitch(switches::kDisableDeviceOrientation));

  WebRuntimeFeatures::enableSpeechInput(
      !command_line.HasSwitch(switches::kDisableSpeechInput));

  WebRuntimeFeatures::enableScriptedSpeech(
      command_line.HasSwitch(switches::kEnableScriptedSpeech));

  WebRuntimeFeatures::enableFileSystem(
      !command_line.HasSwitch(switches::kDisableFileSystem));

  WebRuntimeFeatures::enableJavaScriptI18NAPI(
      !command_line.HasSwitch(switches::kDisableJavaScriptI18NAPI));

  WebRuntimeFeatures::enableGamepad(
      command_line.HasSwitch(switches::kEnableGamepad));

  WebRuntimeFeatures::enableQuota(true);

  WebRuntimeFeatures::enableShadowDOM(
      command_line.HasSwitch(switches::kEnableShadowDOM));

  WebRuntimeFeatures::enableStyleScoped(
      command_line.HasSwitch(switches::kEnableStyleScoped));

  FOR_EACH_OBSERVER(RenderProcessObserver, observers_, WebKitInitialized());

  if (content::GetContentClient()->renderer()->
         RunIdleHandlerWhenWidgetsHidden()) {
    ScheduleIdleHandler(kLongIdleHandlerDelayMs);
   }
 }

void RenderThreadImpl::Init() {
  TRACE_EVENT_BEGIN_ETW("RenderThreadImpl::Init", 0, "");

#if defined(OS_MACOSX) || defined(OS_ANDROID)
  WebKit::WebView::setUseExternalPopupMenus(true);
#endif

  lazy_tls.Pointer()->Set(this);

#if defined(OS_WIN)
  if (RenderProcessImpl::InProcessPlugins())
    initialize_com_.reset(new base::win::ScopedCOMInitializer());
#endif

  ChildProcess::current()->set_main_thread(this);

  suspend_webkit_shared_timer_ = true;
  notify_webkit_of_modal_loop_ = true;
  plugin_refresh_allowed_ = true;
  widget_count_ = 0;
  hidden_widget_count_ = 0;
  idle_notification_delay_in_ms_ = kInitialIdleHandlerDelayMs;
  idle_notifications_to_skip_ = 0;
  compositor_initialized_ = false;

  appcache_dispatcher_.reset(new AppCacheDispatcher(Get()));
  main_thread_indexed_db_dispatcher_.reset(
      IndexedDBDispatcher::ThreadSpecificInstance());

  media_stream_center_ = NULL;

  db_message_filter_ = new DBMessageFilter();
  AddFilter(db_message_filter_.get());

  vc_manager_ = new VideoCaptureImplManager();
  AddFilter(vc_manager_->video_capture_message_filter());

  audio_input_message_filter_ = new AudioInputMessageFilter();
  AddFilter(audio_input_message_filter_.get());

  audio_message_filter_ = new AudioMessageFilter();
  AddFilter(audio_message_filter_.get());

  devtools_agent_message_filter_ = new DevToolsAgentFilter();
  AddFilter(devtools_agent_message_filter_.get());

  AddFilter(new IndexedDBMessageFilter);

  content::GetContentClient()->renderer()->RenderThreadStarted();

  FilePath media_path;
  PathService::Get(content::DIR_MEDIA_LIBS, &media_path);
  if (!media_path.empty())
    media::InitializeMediaLibrary(media_path);

  TRACE_EVENT_END_ETW("RenderThreadImpl::Init", 0, "");
}

long TestWebKitPlatformSupport::databaseGetFileAttributes(
    const WebKit::WebString& vfs_file_name) {
  return SimpleDatabaseSystem::GetInstance()->GetFileAttributes(
      vfs_file_name);
}

bool TestWebKitPlatformSupport::isLinkVisited(unsigned long long linkHash) {
  return false;
}

bool TestWebKitPlatformSupport::sandboxEnabled() {
  return true;
}

long long TestWebKitPlatformSupport::databaseGetFileSize(
    const WebKit::WebString& vfs_file_name) {
  return SimpleDatabaseSystem::GetInstance()->GetFileSize(vfs_file_name);
}

WebGraphicsContext3D* RenderViewImpl::createGraphicsContext3D(
    const WebGraphicsContext3D::Attributes& attributes) {
  if (!webview())
    return NULL;
  if (CommandLine::ForCurrentProcess()->HasSwitch(switches::kInProcessWebGL)) {
    return webkit::gpu::WebGraphicsContext3DInProcessImpl::CreateForWebView(
        attributes, true);
  } else {
    GURL url;
    if (webview()->mainFrame())
      url = GURL(webview()->mainFrame()->document().url());

    scoped_ptr<WebGraphicsContext3DCommandBufferImpl> context(
        new WebGraphicsContext3DCommandBufferImpl(
            surface_id(), url, RenderThreadImpl::current(), AsWeakPtr()));

    if (!context->Initialize(attributes))
      return NULL;
    context_is_web_graphics_context_3d_command_buffer_impl_ = true;
    return context.release();
  }
}

RenderViewImpl* RenderViewImpl::Create(
    gfx::NativeViewId parent_hwnd,
    int32 opener_id,
    const content::RendererPreferences& renderer_prefs,
    const WebPreferences& webkit_prefs,
    SharedRenderViewCounter* counter,
    int32 routing_id,
    int32 surface_id,
    int64 session_storage_namespace_id,
    const string16& frame_name,
    int32 next_page_id,
    const WebKit::WebScreenInfo& screen_info,
    bool guest) {
  DCHECK(routing_id != MSG_ROUTING_NONE);
  return new RenderViewImpl(
      parent_hwnd,
      opener_id,
      renderer_prefs,
      webkit_prefs,
      counter,
      routing_id,
      surface_id,
      session_storage_namespace_id,
      frame_name,
      next_page_id,
      screen_info,
      guest);
}

WebKit::WebString TestWebKitPlatformSupport::defaultLocale() {
  return ASCIIToUTF16("en-US");
}

void TestWebKitPlatformSupport::SetThemeEngine(WebKit::WebThemeEngine* engine) {
  active_theme_engine_ = engine ?
      engine : WebKitPlatformSupportImpl::themeEngine();
}

void RenderViewImpl::didCreateDataSource(WebFrame* frame, WebDataSource* ds) {
  DocumentState* document_state = DocumentState::FromDataSource(ds);
  if (!document_state) {
    document_state = new DocumentState;
    ds->setExtraData(document_state);
  }

  bool content_initiated = !pending_navigation_params_.get();
  if (content_initiated)
    document_state->set_navigation_state(
        NavigationState::CreateContentInitiated());
  else
    PopulateStateFromPendingNavigationParams(document_state);

  if (webview()) {
    if (WebFrame* old_frame = webview()->mainFrame()) {
      const WebURLRequest& original_request = ds->originalRequest();
      const GURL referrer(
          original_request.httpHeaderField(WebString::fromUTF8("Referer")));
      if (!referrer.is_empty() &&
          DocumentState::FromDataSource(
              old_frame->dataSource())->was_prefetcher()) {
        for (; old_frame; old_frame = old_frame->traverseNext(false)) {
          WebDataSource* old_frame_ds = old_frame->dataSource();
          if (old_frame_ds && referrer == GURL(old_frame_ds->request().url())) {
            document_state->set_was_referred_by_prefetcher(true);
            break;
          }
        }
      }
    }
  }

  if (content_initiated) {
    const WebURLRequest& request = ds->request();
    switch (request.cachePolicy()) {
      case WebURLRequest::UseProtocolCachePolicy:  // normal load.
        document_state->set_load_type(DocumentState::LINK_LOAD_NORMAL);
        break;
      case WebURLRequest::ReloadIgnoringCacheData:  // reload.
        document_state->set_load_type(DocumentState::LINK_LOAD_RELOAD);
        break;
      case WebURLRequest::ReturnCacheDataElseLoad:  // allow stale data.
        document_state->set_load_type(
            DocumentState::LINK_LOAD_CACHE_STALE_OK);
        break;
      case WebURLRequest::ReturnCacheDataDontLoad:  // Don't re-post.
        document_state->set_load_type(DocumentState::LINK_LOAD_CACHE_ONLY);
        break;
    }
  }

  FOR_EACH_OBSERVER(
      RenderViewObserver, observers_, DidCreateDataSource(frame, ds));
}

void RenderViewImpl::OnNavigate(const ViewMsg_Navigate_Params& params) {
#if defined(OS_CHROMEOS)
  LOG(ERROR) << "OnNavigate: url=" << params.url
             << ", webview=" << webview()
             << ", reload=" << IsReload(params)
             << ", paerams.state.empty=" << params.state.empty();
#endif
  MaybeHandleDebugURL(params.url);
  if (!webview())
    return;

  FOR_EACH_OBSERVER(RenderViewObserver, observers_, Navigate(params.url));

  bool is_reload = IsReload(params);

  if (IsBackForwardToStaleEntry(params, is_reload))
    return;

  if (is_swapped_out_)
    SetSwappedOut(false);

  history_list_offset_ = params.current_history_list_offset;
  history_list_length_ = params.current_history_list_length;
  if (history_list_length_ >= 0)
    history_page_ids_.resize(history_list_length_, -1);
  if (params.pending_history_list_offset >= 0 &&
      params.pending_history_list_offset < history_list_length_)
    history_page_ids_[params.pending_history_list_offset] = params.page_id;

  content::GetContentClient()->SetActiveURL(params.url);

  WebFrame* main_frame = webview()->mainFrame();
  if (is_reload && main_frame->currentHistoryItem().isNull()) {
    is_reload = false;
  }

  pending_navigation_params_.reset(new ViewMsg_Navigate_Params);
  *pending_navigation_params_.get() = params;

  if (is_reload) {
    bool ignore_cache = (params.navigation_type ==
                             ViewMsg_Navigate_Type::RELOAD_IGNORING_CACHE);
    main_frame->reload(ignore_cache);
  } else if (!params.state.empty()) {
    DCHECK_NE(params.page_id, -1);
    main_frame->loadHistoryItem(
        webkit_glue::HistoryItemFromString(params.state));
  } else {
    WebURLRequest request(params.url);

    CHECK_EQ(params.page_id, -1);

    if (main_frame->isViewSourceModeEnabled())
      request.setCachePolicy(WebURLRequest::ReturnCacheDataElseLoad);

    if (params.referrer.url.is_valid()) {
      WebString referrer = WebSecurityPolicy::generateReferrerHeader(
          params.referrer.policy,
          params.url,
          WebString::fromUTF8(params.referrer.url.spec()));
      if (!referrer.isEmpty())
        request.setHTTPHeaderField(WebString::fromUTF8("Referer"), referrer);
    }

    if (!params.extra_headers.empty()) {
      for (net::HttpUtil::HeadersIterator i(params.extra_headers.begin(),
                                            params.extra_headers.end(), "\n");
           i.GetNext(); ) {
        request.addHTTPHeaderField(WebString::fromUTF8(i.name()),
                                   WebString::fromUTF8(i.values()));
      }
    }
    main_frame->loadRequest(request);
  }

  pending_navigation_params_.reset();
}

bool RenderViewImpl::IsEditableNode(const WebKit::WebNode& node) const {
  bool is_editable_node = false;
  if (!node.isNull()) {
    if (node.isContentEditable()) {
      is_editable_node = true;
    } else if (node.isElementNode()) {
      is_editable_node =
          node.toConst<WebElement>().isTextFormControlElement();
    }
  }
  return is_editable_node;
}

    RVHObserver(RenderViewHostObserverArray* parent, RenderViewHost* rvh)
        : content::RenderViewHostObserver(rvh),
          parent_(parent) {
    }

const char** GetSavableSchemes() {
  return const_cast<const char**>(g_savable_schemes);
}

int TestWebKitPlatformSupport::databaseDeleteFile(
    const WebKit::WebString& vfs_file_name, bool sync_dir) {
  return SimpleDatabaseSystem::GetInstance()->DeleteFile(
      vfs_file_name, sync_dir);
}

WebKit::WebSandboxSupport* TestWebKitPlatformSupport::sandboxSupport() {
  return NULL;
}

long long TestWebKitPlatformSupport::databaseGetSpaceAvailableForOrigin(
    const WebKit::WebString& origin_identifier) {
  return SimpleDatabaseSystem::GetInstance()->GetSpaceAvailable(
      origin_identifier);
}

void TestWebKitPlatformSupport::createIDBKeysFromSerializedValuesAndKeyPath(
      const WebKit::WebVector<WebKit::WebSerializedScriptValue>& values,
      const WebKit::WebString& keyPath,
      WebKit::WebVector<WebKit::WebIDBKey>& keys_out) {
  WebKit::WebVector<WebKit::WebIDBKey> keys(values.size());
  for (size_t i = 0; i < values.size(); ++i) {
    keys[i] = WebKit::WebIDBKey::createFromValueAndKeyPath(
        values[i], WebKit::WebIDBKeyPath::create(keyPath));
  }
  keys_out.swap(keys);
}

TestWebKitPlatformSupport::createOffscreenGraphicsContext3D(
    const WebKit::WebGraphicsContext3D::Attributes& attributes) {
  switch (webkit_support::GetGraphicsContext3DImplementation()) {
    case webkit_support::IN_PROCESS:
      return webkit::gpu::WebGraphicsContext3DInProcessImpl::CreateForWebView(
          attributes, false);
    case webkit_support::IN_PROCESS_COMMAND_BUFFER: {
      scoped_ptr<webkit::gpu::WebGraphicsContext3DInProcessCommandBufferImpl>
          context(new
              webkit::gpu::WebGraphicsContext3DInProcessCommandBufferImpl());
      if (!context->Initialize(attributes, NULL))
        return NULL;
      return context.release();
    }
  }
  NOTREACHED();
  return NULL;
}

void RenderViewTest::SetUp() {
  if (!GetContentClient()->renderer())
    GetContentClient()->set_renderer(&mock_content_renderer_client_);

  if (!render_thread_.get())
    render_thread_.reset(new MockRenderThread());
  render_thread_->set_routing_id(kRouteId);
  render_thread_->set_surface_id(kSurfaceId);
  render_thread_->set_new_window_routing_id(kNewWindowRouteId);

  command_line_.reset(new CommandLine(CommandLine::NO_PROGRAM));
  params_.reset(new content::MainFunctionParams(*command_line_));
  platform_.reset(new RendererMainPlatformDelegate(*params_));
  platform_->PlatformInitialize();

   webkit_glue::SetJavaScriptFlags(" --expose-gc");
   WebKit::initialize(&webkit_platform_support_);
 
   mock_process_.reset(new MockRenderProcess);
 
  RenderViewImpl* view = RenderViewImpl::Create(
      0,
      kOpenerId,
      content::RendererPreferences(),
      WebPreferences(),
      new SharedRenderViewCounter(0),
      kRouteId,
      kSurfaceId,
      kInvalidSessionStorageNamespaceId,
      string16(),
      1,
      WebKit::WebScreenInfo(),
      false);
  view->AddRef();
  view_ = view;

  mock_keyboard_.reset(new MockKeyboard());
}

WebKit::WebString TestWebKitPlatformSupport::queryLocalizedString(
    WebKit::WebLocalizedString::Name name) {
  switch (name) {
    case WebKit::WebLocalizedString::ValidationValueMissing:
    case WebKit::WebLocalizedString::ValidationValueMissingForCheckbox:
    case WebKit::WebLocalizedString::ValidationValueMissingForFile:
    case WebKit::WebLocalizedString::ValidationValueMissingForMultipleFile:
    case WebKit::WebLocalizedString::ValidationValueMissingForRadio:
    case WebKit::WebLocalizedString::ValidationValueMissingForSelect:
      return ASCIIToUTF16("value missing");
    case WebKit::WebLocalizedString::ValidationTypeMismatch:
    case WebKit::WebLocalizedString::ValidationTypeMismatchForEmail:
    case WebKit::WebLocalizedString::ValidationTypeMismatchForMultipleEmail:
    case WebKit::WebLocalizedString::ValidationTypeMismatchForURL:
      return ASCIIToUTF16("type mismatch");
    case WebKit::WebLocalizedString::ValidationPatternMismatch:
      return ASCIIToUTF16("pattern mismatch");
    case WebKit::WebLocalizedString::ValidationTooLong:
      return ASCIIToUTF16("too long");
    case WebKit::WebLocalizedString::ValidationRangeUnderflow:
      return ASCIIToUTF16("range underflow");
    case WebKit::WebLocalizedString::ValidationRangeOverflow:
      return ASCIIToUTF16("range overflow");
    case WebKit::WebLocalizedString::ValidationStepMismatch:
      return ASCIIToUTF16("step mismatch");
    default:
      return WebKitPlatformSupportImpl::queryLocalizedString(name);
  }
}

WebKit::WebString TestWebKitPlatformSupport::queryLocalizedString(
    WebKit::WebLocalizedString::Name name,
    const WebKit::WebString& value1,
    const WebKit::WebString& value2) {
  if (name == WebKit::WebLocalizedString::ValidationTooLong)
    return ASCIIToUTF16("too long");
  if (name == WebKit::WebLocalizedString::ValidationStepMismatch)
    return ASCIIToUTF16("step mismatch");
  return WebKitPlatformSupportImpl::queryLocalizedString(name, value1, value2);
}

WebKit::WebClipboard* TestWebKitPlatformSupport::clipboard() {
  return &mock_clipboard_;
}

WebKit::WebIDBFactory* TestWebKitPlatformSupport::idbFactory() {
  return WebKit::WebIDBFactory::create();
}

 void RenderThreadImpl::RecordUserMetrics(const std::string& action) {
   Send(new ViewHostMsg_UserMetricsRecordAction(action));
 }
