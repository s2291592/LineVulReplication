void TypingCommand::deleteKeyPressed(Document& document,
                                     Options options,
                                     TextGranularity granularity) {
  if (granularity == CharacterGranularity) {
    LocalFrame* frame = document.frame();
    if (TypingCommand* lastTypingCommand =
            lastTypingCommandIfStillOpenForTyping(frame)) {
      if (lastTypingCommand->commandTypeOfOpenCommand() == DeleteKey) {
        updateSelectionIfDifferentFromCurrentSelection(lastTypingCommand,
                                                       frame);
        lastTypingCommand->setShouldPreventSpellChecking(options &
                                                         PreventSpellChecking);
        EditingState editingState;
        lastTypingCommand->deleteKeyPressed(granularity, options & KillRing,
                                            &editingState);
        return;
      }
    }
  }

  TypingCommand::create(document, DeleteKey, "", options, granularity)->apply();
}

TypingCommand* Editor::lastTypingCommandIfStillOpenForTyping() const {
  return TypingCommand::lastTypingCommandIfStillOpenForTyping(&frame());
}

static void writeImageNodeToPasteboard(Pasteboard* pasteboard,
                                       Node* node,
                                       const String& title) {
  DCHECK(pasteboard);
  DCHECK(node);

  RefPtr<Image> image = imageFromNode(*node);
  if (!image.get())
    return;

  AtomicString urlString;
  if (isHTMLImageElement(*node) || isHTMLInputElement(*node))
    urlString = toHTMLElement(node)->getAttribute(srcAttr);
  else if (isSVGImageElement(*node))
    urlString = toSVGElement(node)->imageSourceURL();
  else if (isHTMLEmbedElement(*node) || isHTMLObjectElement(*node) ||
           isHTMLCanvasElement(*node))
    urlString = toHTMLElement(node)->imageSourceURL();
  KURL url = urlString.isEmpty()
                 ? KURL()
                 : node->document().completeURL(
                       stripLeadingAndTrailingHTMLSpaces(urlString));

  pasteboard->writeImage(image.get(), url, title);
}

void Editor::paste(EditorCommandSource source) {
  DCHECK(frame().document());
  if (tryDHTMLPaste(AllMimeTypes))
    return;  // DHTML did the whole operation
  if (!canPaste())
    return;
  spellChecker().updateMarkersForWordsAffectedByEditing(false);
  ResourceFetcher* loader = frame().document()->fetcher();
  ResourceCacheValidationSuppressor validationSuppressor(loader);

  PasteMode pasteMode = frame().selection()
                                .computeVisibleSelectionInDOMTreeDeprecated()
                                .isContentRichlyEditable()
                            ? AllMimeTypes
                            : PlainTextOnly;

  if (source == CommandFromMenuOrKeyBinding) {
    DataTransfer* dataTransfer =
        DataTransfer::create(DataTransfer::CopyAndPaste, DataTransferReadable,
                             DataObject::createFromPasteboard(pasteMode));

    if (dispatchBeforeInputDataTransfer(findEventTargetFromSelection(),
                                        InputEvent::InputType::InsertFromPaste,
                                        dataTransfer) !=
        DispatchEventResult::NotCanceled)
      return;
    if (m_frame->document()->frame() != m_frame)
      return;
  }

  if (pasteMode == AllMimeTypes)
    pasteWithPasteboard(Pasteboard::generalPasteboard());
  else
    pasteAsPlainTextWithPasteboard(Pasteboard::generalPasteboard());
}

bool canAppendNewLineFeedToSelection(const VisibleSelection& selection) {
  Element* element = selection.rootEditableElement();
  if (!element)
    return false;

  BeforeTextInsertedEvent* event =
      BeforeTextInsertedEvent::create(String("\n"));
  element->dispatchEvent(event);
  return event->text().length();
}

bool Editor::insertTextWithoutSendingTextEvent(const String& text,
bool selectInsertedText,
TextEvent* triggeringEvent) {
if (text.isEmpty())
return false;

const VisibleSelection& selection = selectionForCommand(triggeringEvent);
if (!selection.isContentEditable())
return false;

spellChecker().updateMarkersForWordsAffectedByEditing(
isSpaceOrNewline(text[0]));

// Insert the text
TypingCommand::insertText(
      *selection.start().document(), text, selection,
selectInsertedText ? TypingCommand::SelectInsertedText : 0,
triggeringEvent && triggeringEvent->isComposition()
? TypingCommand::TextCompositionConfirm
: TypingCommand::TextCompositionNone);

// Reveal the current selection
if (LocalFrame* editedFrame = selection.start().document()->frame()) {
if (Page* page = editedFrame->page()) {
LocalFrame* focusedOrMainFrame =
toLocalFrame(page->focusController().focusedOrMainFrame());
focusedOrMainFrame->selection().revealSelection(
ScrollAlignment::alignCenterIfNeeded);
}
}

return true;
}

void Editor::cut(EditorCommandSource source) {
  if (tryDHTMLCut())
    return;  // DHTML did the whole operation
  if (!canCut())
    return;

  frame().document()->updateStyleAndLayoutIgnorePendingStylesheets();

  if (canDeleteRange(selectedRange())) {
    spellChecker().updateMarkersForWordsAffectedByEditing(true);
    if (enclosingTextControl(frame()
                                 .selection()
                                 .computeVisibleSelectionInDOMTreeDeprecated()
                                 .start())) {
      String plainText = frame().selectedTextForClipboard();
      Pasteboard::generalPasteboard()->writePlainText(
          plainText, canSmartCopyOrDelete() ? Pasteboard::CanSmartReplace
                                            : Pasteboard::CannotSmartReplace);
    } else {
      writeSelectionToPasteboard();
    }

    if (source == CommandFromMenuOrKeyBinding) {
      if (dispatchBeforeInputDataTransfer(findEventTargetFromSelection(),
                                          InputEvent::InputType::DeleteByCut,
                                          nullptr) !=
          DispatchEventResult::NotCanceled)
        return;
      if (m_frame->document()->frame() != m_frame)
        return;
    }
    deleteSelectionWithSmartDelete(
        canSmartCopyOrDelete() ? DeleteMode::Smart : DeleteMode::Simple,
        InputEvent::InputType::DeleteByCut);
  }
}

InputEvent::InputType TypingCommand::inputType() const {
  using InputType = InputEvent::InputType;

  if (m_compositionType != TextCompositionNone)
    return InputType::InsertCompositionText;

  switch (m_commandType) {
    case DeleteSelection:
      return InputType::DeleteContentBackward;
    case DeleteKey:
      return deletionInputTypeFromTextGranularity(DeleteDirection::Backward,
                                                  m_granularity);
    case ForwardDeleteKey:
      return deletionInputTypeFromTextGranularity(DeleteDirection::Forward,
                                                  m_granularity);
    case InsertText:
      return InputType::InsertText;
    case InsertLineBreak:
      return InputType::InsertLineBreak;
    case InsertParagraphSeparator:
    case InsertParagraphSeparatorInQuotedContent:
      return InputType::InsertParagraph;
    default:
      return InputType::None;
  }
}

void Editor::pasteAsPlainText(const String& pastingText, bool smartReplace) {
  Element* target = findEventTargetFromSelection();
  if (!target)
    return;
  target->dispatchEvent(TextEvent::createForPlainTextPaste(
      frame().domWindow(), pastingText, smartReplace));
}

void Editor::performDelete() {
  if (!canDelete())
    return;

  frame().document()->updateStyleAndLayoutIgnorePendingStylesheets();

  addToKillRing(selectedRange());
  deleteSelectionWithSmartDelete(
      canSmartCopyOrDelete() ? DeleteMode::Smart : DeleteMode::Simple,
      InputEvent::InputType::DeleteContentBackward);

  setStartNewKillRingSequence(false);
}

void TypingCommand::insertParagraphSeparator(EditingState* editingState) {
  if (!canAppendNewLineFeedToSelection(endingSelection()))
    return;

  applyCommandToComposite(InsertParagraphSeparatorCommand::create(document()),
                          editingState);
  if (editingState->isAborted())
    return;
  typingAddedToOpenCommand(InsertParagraphSeparator);
}

static Range* findStringBetweenPositions(
    const String& target,
    const EphemeralRangeTemplate<Strategy>& referenceRange,
    FindOptions options) {
  EphemeralRangeTemplate<Strategy> searchRange(referenceRange);

  bool forward = !(options & Backwards);

  while (true) {
    EphemeralRangeTemplate<Strategy> resultRange =
        findPlainText(searchRange, target, options);
    if (resultRange.isCollapsed())
      return nullptr;

    Range* rangeObject =
        Range::create(resultRange.document(),
                      toPositionInDOMTree(resultRange.startPosition()),
                      toPositionInDOMTree(resultRange.endPosition()));
    if (!rangeObject->collapsed())
      return rangeObject;

    if (forward) {
      searchRange = EphemeralRangeTemplate<Strategy>(
          nextPositionOf(resultRange.startPosition(),
                         PositionMoveType::GraphemeCluster),
          searchRange.endPosition());
    } else {
      searchRange = EphemeralRangeTemplate<Strategy>(
          searchRange.startPosition(),
          previousPositionOf(resultRange.endPosition(),
                             PositionMoveType::GraphemeCluster));
    }
  }

  NOTREACHED();
  return nullptr;
}

bool Editor::selectionStartHasStyle(CSSPropertyID propertyID,
                                    const String& value) const {
  EditingStyle* styleToCheck = EditingStyle::create(propertyID, value);
  EditingStyle* styleAtStart =
      EditingStyleUtilities::createStyleAtSelectionStart(
          frame().selection().computeVisibleSelectionInDOMTreeDeprecated(),
          propertyID == CSSPropertyBackgroundColor, styleToCheck->style());
  return styleToCheck->triStateOfStyle(styleAtStart);
}

EphemeralRange Editor::selectedRange() {
  return frame()
      .selection()
      .computeVisibleSelectionInDOMTreeDeprecated()
      .toNormalizedEphemeralRange();
}

PlainTextRange getSelectionOffsets(LocalFrame* frame) {
  EphemeralRange range = firstEphemeralRangeOf(
      frame->selection().computeVisibleSelectionInDOMTreeDeprecated());
  if (range.isNull())
    return PlainTextRange();
  ContainerNode* const editable = rootEditableElementOrTreeScopeRootNodeOf(
      frame->selection().computeVisibleSelectionInDOMTreeDeprecated());
  DCHECK(editable);
  return PlainTextRange::create(*editable, range);
}

void Editor::setMarkedTextMatchesAreHighlighted(bool flag) {
  if (flag == m_areMarkedTextMatchesHighlighted)
    return;

  m_areMarkedTextMatchesHighlighted = flag;
  frame().document()->markers().repaintMarkers(DocumentMarker::TextMatch);
}

bool TypingCommand::insertParagraphSeparator(Document& document) {
  if (TypingCommand* lastTypingCommand =
          lastTypingCommandIfStillOpenForTyping(document.frame())) {
    lastTypingCommand->setShouldRetainAutocorrectionIndicator(false);
    EditingState editingState;
    EventQueueScope eventQueueScope;
    lastTypingCommand->insertParagraphSeparator(&editingState);
    return !editingState.isAborted();
  }

  return TypingCommand::create(document, InsertParagraphSeparator, "", 0)
      ->apply();
}

void TypingCommand::forwardDeleteKeyPressed(Document& document,
                                            EditingState* editingState,
                                            Options options,
                                            TextGranularity granularity) {
  if (granularity == CharacterGranularity) {
    LocalFrame* frame = document.frame();
    if (TypingCommand* lastTypingCommand =
            lastTypingCommandIfStillOpenForTyping(frame)) {
      updateSelectionIfDifferentFromCurrentSelection(lastTypingCommand, frame);
      lastTypingCommand->setShouldPreventSpellChecking(options &
                                                       PreventSpellChecking);
      lastTypingCommand->forwardDeleteKeyPressed(
          granularity, options & KillRing, editingState);
      return;
    }
  }

  TypingCommand::create(document, ForwardDeleteKey, "", options, granularity)
      ->apply();
}

void Editor::tidyUpHTMLStructure(Document& document) {
  document.updateStyleAndLayoutTree();
  bool needsValidStructure = hasEditableStyle(document) ||
                             (document.documentElement() &&
                              hasEditableStyle(*document.documentElement()));
  if (!needsValidStructure)
    return;
  Element* existingHead = nullptr;
  Element* existingBody = nullptr;
  Element* currentRoot = document.documentElement();
  if (currentRoot) {
    if (isHTMLHtmlElement(currentRoot))
      return;
    if (isHTMLHeadElement(currentRoot))
      existingHead = currentRoot;
    else if (isHTMLBodyElement(currentRoot))
      existingBody = currentRoot;
    else if (isHTMLFrameSetElement(currentRoot))
      existingBody = currentRoot;
  }
  document.addConsoleMessage(ConsoleMessage::create(
      JSMessageSource, WarningMessageLevel,
      "document.execCommand() doesn't work with an invalid HTML structure. It "
      "is corrected automatically."));
  UseCounter::count(document, UseCounter::ExecCommandAltersHTMLStructure);

  Element* root = HTMLHtmlElement::create(document);
  if (existingHead)
    root->appendChild(existingHead);
  Element* body = nullptr;
  if (existingBody)
    body = existingBody;
  else
    body = HTMLBodyElement::create(document);
  if (document.documentElement() && body != document.documentElement())
    body->appendChild(document.documentElement());
  root->appendChild(body);
  DCHECK(!document.documentElement());
  document.appendChild(root);

}

static Range* findRangeOfStringAlgorithm(
    Document& document,
    const String& target,
    const EphemeralRangeTemplate<Strategy>& referenceRange,
    FindOptions options) {
  if (target.isEmpty())
    return nullptr;

  EphemeralRangeTemplate<Strategy> documentRange =
      EphemeralRangeTemplate<Strategy>::rangeOfContents(document);
  EphemeralRangeTemplate<Strategy> searchRange(documentRange);

  bool forward = !(options & Backwards);
  bool startInReferenceRange = false;
  if (referenceRange.isNotNull()) {
    startInReferenceRange = options & StartInSelection;
    if (forward && startInReferenceRange)
      searchRange = EphemeralRangeTemplate<Strategy>(
          referenceRange.startPosition(), documentRange.endPosition());
    else if (forward)
      searchRange = EphemeralRangeTemplate<Strategy>(
          referenceRange.endPosition(), documentRange.endPosition());
    else if (startInReferenceRange)
      searchRange = EphemeralRangeTemplate<Strategy>(
          documentRange.startPosition(), referenceRange.endPosition());
    else
      searchRange = EphemeralRangeTemplate<Strategy>(
          documentRange.startPosition(), referenceRange.startPosition());
  }

  Range* resultRange = findStringBetweenPositions(target, searchRange, options);

  if (resultRange && startInReferenceRange &&
      normalizeRange(EphemeralRangeTemplate<Strategy>(resultRange)) ==
          referenceRange) {
    if (forward)
      searchRange = EphemeralRangeTemplate<Strategy>(
          fromPositionInDOMTree<Strategy>(resultRange->endPosition()),
          searchRange.endPosition());
    else
      searchRange = EphemeralRangeTemplate<Strategy>(
          searchRange.startPosition(),
          fromPositionInDOMTree<Strategy>(resultRange->startPosition()));
    resultRange = findStringBetweenPositions(target, searchRange, options);
  }

  if (!resultRange && options & WrapAround)
    return findStringBetweenPositions(target, documentRange, options);

  return resultRange;
}

void Editor::pasteAsPlainTextWithPasteboard(Pasteboard* pasteboard) {
  String text = pasteboard->plainText();
  pasteAsPlainText(text, canSmartReplaceWithPasteboard(pasteboard));
}

bool Editor::smartInsertDeleteEnabled() const {
  if (Settings* settings = frame().settings())
    return settings->getSmartInsertDeleteEnabled();
  return false;
}

bool Editor::canDHTMLCut() {
  return !frame().selection().isInPasswordField() &&
         !dispatchCPPEvent(EventTypeNames::beforecut, DataTransferNumb);
}

void Editor::revealSelectionAfterEditingOperation(
    const ScrollAlignment& alignment,
    RevealExtentOption revealExtentOption) {
  if (m_preventRevealSelection)
    return;
  if (!frame().selection().isAvailable())
    return;
  frame().selection().revealSelection(alignment, revealExtentOption);
}

static bool isCaretAtStartOfWrappedLine(const FrameSelection& selection) {
  if (!selection.computeVisibleSelectionInDOMTreeDeprecated().isCaret())
    return false;
  if (selection.selectionInDOMTree().affinity() != TextAffinity::Downstream)
    return false;
  const Position& position =
      selection.computeVisibleSelectionInDOMTreeDeprecated().start();
  return !inSameLine(PositionWithAffinity(position, TextAffinity::Upstream),
                     PositionWithAffinity(position, TextAffinity::Downstream));
}

InputEvent::EventIsComposing isComposingFromCommand(
    const CompositeEditCommand* command) {
  if (command->isTypingCommand() &&
      toTypingCommand(command)->compositionType() !=
          TypingCommand::TextCompositionNone)
    return InputEvent::EventIsComposing::IsComposing;
  return InputEvent::EventIsComposing::NotComposing;
}

void Editor::unappliedEditing(UndoStep* cmd) {
  EventQueueScope scope;

  dispatchEditableContentChangedEvents(cmd->startingRootEditableElement(),
                                       cmd->endingRootEditableElement());
  dispatchInputEventEditableContentChanged(
      cmd->startingRootEditableElement(), cmd->endingRootEditableElement(),
      InputEvent::InputType::HistoryUndo, nullAtom,
      InputEvent::EventIsComposing::NotComposing);

  frame().document()->updateStyleAndLayoutIgnorePendingStylesheets();

  const VisibleSelection& newSelection =
      correctedVisibleSelection(cmd->startingSelection());
  DCHECK(newSelection.isValidFor(*frame().document())) << newSelection;
  changeSelectionAfterCommand(
      newSelection.asSelection(),
      FrameSelection::CloseTyping | FrameSelection::ClearTypingStyle);

  m_lastEditCommand = nullptr;
  m_undoStack->registerRedoStep(cmd);
  respondToChangedContents(newSelection.start());
}

void TypingCommand::insertParagraphSeparatorInQuotedContent(
    EditingState* editingState) {
  if (enclosingNodeOfType(endingSelection().start(), &isTableStructureNode)) {
    insertParagraphSeparator(editingState);
    return;
  }

  applyCommandToComposite(BreakBlockquoteCommand::create(document()),
                          editingState);
  if (editingState->isAborted())
    return;
  typingAddedToOpenCommand(InsertParagraphSeparatorInQuotedContent);
}

void TypingCommand::updateSelectionIfDifferentFromCurrentSelection(
    TypingCommand* typingCommand,
    LocalFrame* frame) {
  DCHECK(frame);
  VisibleSelection currentSelection =
      frame->selection().computeVisibleSelectionInDOMTreeDeprecated();
  if (currentSelection == typingCommand->endingSelection())
    return;

  typingCommand->setStartingSelection(currentSelection);
  typingCommand->setEndingVisibleSelection(currentSelection);
}

void Editor::applyStyle(StylePropertySet* style,
                        InputEvent::InputType inputType) {
  switch (frame()
              .selection()
              .computeVisibleSelectionInDOMTreeDeprecated()
              .getSelectionType()) {
    case NoSelection:
      break;
    case CaretSelection:
      computeAndSetTypingStyle(style, inputType);
      break;
    case RangeSelection:
      if (style) {
        DCHECK(frame().document());
        ApplyStyleCommand::create(*frame().document(),
                                  EditingStyle::create(style), inputType)
            ->apply();
      }
      break;
  }
}

void Editor::copy() {
  if (tryDHTMLCopy())
    return;  // DHTML did the whole operation
  if (!canCopy())
    return;

  frame().document()->updateStyleAndLayoutIgnorePendingStylesheets();

  if (enclosingTextControl(frame()
                               .selection()
                               .computeVisibleSelectionInDOMTreeDeprecated()
                               .start())) {
    Pasteboard::generalPasteboard()->writePlainText(
        frame().selectedTextForClipboard(),
        canSmartCopyOrDelete() ? Pasteboard::CanSmartReplace
                               : Pasteboard::CannotSmartReplace);
  } else {
    Document* document = frame().document();
    if (HTMLImageElement* imageElement =
            imageElementFromImageDocument(document))
      writeImageNodeToPasteboard(Pasteboard::generalPasteboard(), imageElement,
                                 document->title());
    else
      writeSelectionToPasteboard();
  }
}

void Editor::addToKillRing(const EphemeralRange& range) {
  if (m_shouldStartNewKillRingSequence)
    killRing().startNewSequence();

  DCHECK(!frame().document()->needsLayoutTreeUpdate());
  String text = plainText(range);
  killRing().append(text);
  m_shouldStartNewKillRingSequence = false;
}

void Editor::redo() {
  m_undoStack->redo();
}

void TypingCommand::doApply(EditingState* editingState) {
  if (!endingSelection().isNonOrphanedCaretOrRange())
    return;

  if (m_commandType == DeleteKey) {
    if (m_commands.isEmpty())
      m_openedByBackwardDelete = true;
  }

  switch (m_commandType) {
    case DeleteSelection:
      deleteSelection(m_smartDelete, editingState);
      return;
    case DeleteKey:
      deleteKeyPressed(m_granularity, m_killRing, editingState);
      return;
    case ForwardDeleteKey:
      forwardDeleteKeyPressed(m_granularity, m_killRing, editingState);
      return;
    case InsertLineBreak:
      insertLineBreak(editingState);
      return;
    case InsertParagraphSeparator:
      insertParagraphSeparator(editingState);
      return;
    case InsertParagraphSeparatorInQuotedContent:
      insertParagraphSeparatorInQuotedContent(editingState);
      return;
    case InsertText:
      insertText(m_textToInsert, m_selectInsertedText, editingState);
      return;
  }

  NOTREACHED();
}

void Editor::deleteSelectionWithSmartDelete(
    DeleteMode deleteMode,
    InputEvent::InputType inputType,
    const Position& referenceMovePosition) {
  if (frame().selection().computeVisibleSelectionInDOMTreeDeprecated().isNone())
    return;

  const bool kMergeBlocksAfterDelete = true;
  const bool kExpandForSpecialElements = false;
  const bool kSanitizeMarkup = true;
  DCHECK(frame().document());
  DeleteSelectionCommand::create(
      *frame().document(), deleteMode == DeleteMode::Smart,
      kMergeBlocksAfterDelete, kExpandForSpecialElements, kSanitizeMarkup,
      inputType, referenceMovePosition)
      ->apply();
}

bool Editor::canSmartReplaceWithPasteboard(Pasteboard* pasteboard) {
  return smartInsertDeleteEnabled() && pasteboard->canSmartReplace();
}

DispatchEventResult dispatchTextInputEvent(LocalFrame* frame,
                                           const String& text) {
  if (Element* target = frame->document()->focusedElement()) {
    TextEvent* event = TextEvent::create(frame->domWindow(), text,
                                         TextEventInputIncrementalInsertion);
    event->setUnderlyingEvent(nullptr);
    return target->dispatchEvent(event);
  }
  return DispatchEventResult::CanceledBeforeDispatch;
}

void Editor::replaceSelectionWithFragment(DocumentFragment* fragment,
                                          bool selectReplacement,
                                          bool smartReplace,
                                          bool matchStyle,
                                          InputEvent::InputType inputType) {
  DCHECK(!frame().document()->needsLayoutTreeUpdate());
  if (frame()
          .selection()
          .computeVisibleSelectionInDOMTreeDeprecated()
          .isNone() ||
      !frame()
           .selection()
           .computeVisibleSelectionInDOMTreeDeprecated()
           .isContentEditable() ||
      !fragment)
    return;

  ReplaceSelectionCommand::CommandOptions options =
      ReplaceSelectionCommand::PreventNesting |
      ReplaceSelectionCommand::SanitizeFragment;
  if (selectReplacement)
    options |= ReplaceSelectionCommand::SelectReplacement;
  if (smartReplace)
    options |= ReplaceSelectionCommand::SmartReplace;
  if (matchStyle)
    options |= ReplaceSelectionCommand::MatchStyle;
  DCHECK(frame().document());
  ReplaceSelectionCommand::create(*frame().document(), fragment, options,
                                  inputType)
      ->apply();
  revealSelectionAfterEditingOperation();
}

void Editor::pasteAsFragment(DocumentFragment* pastingFragment,
                             bool smartReplace,
                             bool matchStyle) {
  Element* target = findEventTargetFromSelection();
  if (!target)
    return;
  target->dispatchEvent(TextEvent::createForFragmentPaste(
      frame().domWindow(), pastingFragment, smartReplace, matchStyle));
}

IntRect Editor::firstRectForRange(const EphemeralRange& range) const {
  DCHECK(!frame().document()->needsLayoutTreeUpdate());
  DocumentLifecycle::DisallowTransitionScope disallowTransition(
      frame().document()->lifecycle());

  LayoutUnit extraWidthToEndOfLine;
  DCHECK(range.isNotNull());

  IntRect startCaretRect =
      RenderedPosition(
          createVisiblePosition(range.startPosition()).deepEquivalent(),
          TextAffinity::Downstream)
          .absoluteRect(&extraWidthToEndOfLine);
  if (startCaretRect.isEmpty())
    return IntRect();

  IntRect endCaretRect =
      RenderedPosition(
          createVisiblePosition(range.endPosition()).deepEquivalent(),
          TextAffinity::Upstream)
          .absoluteRect();
  if (endCaretRect.isEmpty())
    return IntRect();

  if (startCaretRect.y() == endCaretRect.y()) {
    return IntRect(std::min(startCaretRect.x(), endCaretRect.x()),
                   startCaretRect.y(),
                   abs(endCaretRect.x() - startCaretRect.x()),
                   std::max(startCaretRect.height(), endCaretRect.height()));
  }

  return IntRect(startCaretRect.x(), startCaretRect.y(),
                 (startCaretRect.width() + extraWidthToEndOfLine).toInt(),
                 startCaretRect.height());
}

String Editor::selectionStartCSSPropertyValue(CSSPropertyID propertyID) {
  EditingStyle* selectionStyle =
      EditingStyleUtilities::createStyleAtSelectionStart(
          frame().selection().computeVisibleSelectionInDOMTreeDeprecated(),
          propertyID == CSSPropertyBackgroundColor);
  if (!selectionStyle || !selectionStyle->style())
    return String();

  if (propertyID == CSSPropertyFontSize)
    return String::number(selectionStyle->legacyFontSize(frame().document()));
  return selectionStyle->style()->getPropertyValue(propertyID);
}

VisibleSelection Editor::selectionForCommand(Event* event) {
  VisibleSelection selection =
      frame().selection().computeVisibleSelectionInDOMTreeDeprecated();
  if (!event)
    return selection;
  TextControlElement* textControlOfSelectionStart =
      enclosingTextControl(selection.start());
  TextControlElement* textControlOfTarget =
      isTextControlElement(*event->target()->toNode())
          ? toTextControlElement(event->target()->toNode())
          : nullptr;
  if (textControlOfTarget &&
      (selection.start().isNull() ||
       textControlOfTarget != textControlOfSelectionStart)) {
    if (Range* range = textControlOfTarget->selection()) {
      return createVisibleSelection(
          SelectionInDOMTree::Builder()
              .setBaseAndExtent(EphemeralRange(range))
              .setIsDirectional(selection.isDirectional())
              .build());
    }
  }
  return selection;
}

bool Editor::canUndo() {
  return m_undoStack->canUndo();
}

void Editor::copyImage(const HitTestResult& result) {
  writeImageNodeToPasteboard(Pasteboard::generalPasteboard(),
                             result.innerNodeOrImageMapImage(),
                             result.altDisplayString());
}

Editor::RevealSelectionScope::RevealSelectionScope(Editor* editor)
    : m_editor(editor) {
  ++m_editor->m_preventRevealSelection;
}

void Editor::clear() {
  frame().inputMethodController().clear();
  m_shouldStyleWithCSS = false;
  m_defaultParagraphSeparator = EditorParagraphSeparatorIsDiv;
  m_lastEditCommand = nullptr;
  m_undoStack->clear();
}

bool Editor::insertParagraphSeparator() {
  if (!canEdit())
    return false;

  if (!canEditRichly())
    return insertLineBreak();

  VisiblePosition caret = frame()
                              .selection()
                              .computeVisibleSelectionInDOMTreeDeprecated()
                              .visibleStart();
  bool alignToEdge = isEndOfEditableOrNonEditableContent(caret);
  DCHECK(frame().document());
  EditingState editingState;
  if (!TypingCommand::insertParagraphSeparator(*frame().document()))
    return false;
  revealSelectionAfterEditingOperation(
      alignToEdge ? ScrollAlignment::alignToEdgeIfNeeded
                  : ScrollAlignment::alignCenterIfNeeded);

  return true;
}

Range* Editor::findRangeOfString(const String& target,
                                 const EphemeralRangeInFlatTree& reference,
                                 FindOptions options) {
  return findRangeOfStringAlgorithm<EditingInFlatTreeStrategy>(
      *frame().document(), target, reference, options);
}

void dispatchInputEvent(Element* target,
                        InputEvent::InputType inputType,
                        const String& data,
                        InputEvent::EventIsComposing isComposing) {
  if (!RuntimeEnabledFeatures::inputEventEnabled())
    return;
  if (!target)
    return;
  InputEvent* inputEvent =
      InputEvent::createInput(inputType, data, isComposing, nullptr);
  target->dispatchScopedEvent(inputEvent);
}

bool TypingCommand::insertParagraphSeparatorInQuotedContent(
    Document& document) {
  if (TypingCommand* lastTypingCommand =
          lastTypingCommandIfStillOpenForTyping(document.frame())) {
    EditingState editingState;
    EventQueueScope eventQueueScope;
    lastTypingCommand->insertParagraphSeparatorInQuotedContent(&editingState);
    return !editingState.isAborted();
  }

  return TypingCommand::create(document,
                               InsertParagraphSeparatorInQuotedContent)
      ->apply();
}

Range* Editor::findStringAndScrollToVisible(const String& target,
                                            Range* previousMatch,
                                            FindOptions options) {
  Range* nextMatch = findRangeOfString(
      target, EphemeralRangeInFlatTree(previousMatch), options);
  if (!nextMatch)
    return nullptr;

  Node* firstNode = nextMatch->firstNode();
  firstNode->layoutObject()->scrollRectToVisible(
      LayoutRect(nextMatch->boundingBox()),
      ScrollAlignment::alignCenterIfNeeded,
      ScrollAlignment::alignCenterIfNeeded, UserScroll);
  firstNode->document().setSequentialFocusNavigationStartingPoint(firstNode);

  return nextMatch;
}

static EditorClient& emptyEditorClient() {
  DEFINE_STATIC_LOCAL(EmptyEditorClient, client, ());
  return client;
}

TypingCommand* TypingCommand::lastTypingCommandIfStillOpenForTyping(
    LocalFrame* frame) {
  DCHECK(frame);

  CompositeEditCommand* lastEditCommand = frame->editor().lastEditCommand();
  if (!lastEditCommand || !lastEditCommand->isTypingCommand() ||
      !static_cast<TypingCommand*>(lastEditCommand)->isOpenForMoreTyping())
    return nullptr;

  return static_cast<TypingCommand*>(lastEditCommand);
}

bool Editor::canDeleteRange(const EphemeralRange& range) const {
  if (range.isCollapsed())
    return false;

  Node* startContainer = range.startPosition().computeContainerNode();
  Node* endContainer = range.endPosition().computeContainerNode();
  if (!startContainer || !endContainer)
    return false;

  return hasEditableStyle(*startContainer) && hasEditableStyle(*endContainer);
}

 void TypingCommand::adjustSelectionAfterIncrementalInsertion(
    LocalFrame* frame,
    const size_t textLength) {
  if (!isIncrementalInsertion())
    return;

  frame->document()->updateStyleAndLayoutIgnorePendingStylesheets();

  Element* element = frame->selection()
                         .computeVisibleSelectionInDOMTreeDeprecated()
                         .rootEditableElement();
  DCHECK(element);

  const size_t end = m_selectionStart + textLength;
  const size_t start =
      compositionType() == TextCompositionUpdate ? m_selectionStart : end;
  const SelectionInDOMTree& selection =
      createSelection(start, end, endingSelection().isDirectional(), element);

  if (selection ==
      frame->selection()
          .computeVisibleSelectionInDOMTreeDeprecated()
          .asSelection())
    return;

  setEndingSelection(selection);
  frame->selection().setSelection(selection);
}

bool Editor::findString(const String& target, FindOptions options) {
  VisibleSelection selection =
      frame().selection().computeVisibleSelectionInDOMTreeDeprecated();

  Range* resultRange = findRangeOfString(
      target, EphemeralRange(selection.start(), selection.end()),
      static_cast<FindOptions>(options | FindAPICall));

  if (!resultRange)
    return false;

  frame().selection().setSelection(
      SelectionInDOMTree::Builder()
          .setBaseAndExtent(EphemeralRange(resultRange))
          .build());
  frame().selection().revealSelection();
  return true;
}

bool Editor::tryDHTMLCut() {
  if (frame().selection().isInPasswordField())
    return false;

  return !dispatchCPPEvent(EventTypeNames::cut, DataTransferWritable);
}

bool Editor::dispatchCPPEvent(const AtomicString& eventType,
                              DataTransferAccessPolicy policy,
                              PasteMode pasteMode) {
  Element* target = findEventTargetFromSelection();
  if (!target)
    return true;

  DataTransfer* dataTransfer =
      DataTransfer::create(DataTransfer::CopyAndPaste, policy,
                           policy == DataTransferWritable
                               ? DataObject::create()
                               : DataObject::createFromPasteboard(pasteMode));

  Event* evt = ClipboardEvent::create(eventType, true, true, dataTransfer);
  target->dispatchEvent(evt);
  bool noDefaultProcessing = evt->defaultPrevented();
  if (noDefaultProcessing && policy == DataTransferWritable)
    Pasteboard::generalPasteboard()->writeDataObject(
        dataTransfer->dataObject());

  dataTransfer->setAccessPolicy(DataTransferNumb);

  return !noDefaultProcessing;
}

void Editor::setBaseWritingDirection(WritingDirection direction) {
  Element* focusedElement = frame().document()->focusedElement();
  if (isTextControlElement(focusedElement)) {
    if (direction == NaturalWritingDirection)
      return;
    focusedElement->setAttribute(
        dirAttr, direction == LeftToRightWritingDirection ? "ltr" : "rtl");
    focusedElement->dispatchInputEvent();
    return;
  }

  MutableStylePropertySet* style =
      MutableStylePropertySet::create(HTMLQuirksMode);
  style->setProperty(
      CSSPropertyDirection,
      direction == LeftToRightWritingDirection
          ? "ltr"
          : direction == RightToLeftWritingDirection ? "rtl" : "inherit",
      false);
  applyParagraphStyleToSelection(
      style, InputEvent::InputType::FormatSetBlockTextDirection);
}

void dispatchInputEventEditableContentChanged(
    Element* startRoot,
    Element* endRoot,
    InputEvent::InputType inputType,
    const String& data,
    InputEvent::EventIsComposing isComposing) {
  if (startRoot)
    dispatchInputEvent(startRoot, inputType, data, isComposing);
  if (endRoot && endRoot != startRoot)
    dispatchInputEvent(endRoot, inputType, data, isComposing);
}

bool Editor::insertLineBreak() {
  if (!canEdit())
    return false;

  VisiblePosition caret = frame()
                              .selection()
                              .computeVisibleSelectionInDOMTreeDeprecated()
                              .visibleStart();
  bool alignToEdge = isEndOfEditableOrNonEditableContent(caret);
  DCHECK(frame().document());
  if (!TypingCommand::insertLineBreak(*frame().document()))
    return false;
  revealSelectionAfterEditingOperation(
      alignToEdge ? ScrollAlignment::alignToEdgeIfNeeded
                  : ScrollAlignment::alignCenterIfNeeded);

  return true;
}

void TypingCommand::insertText(Document& document,
                               const String& text,
                               const VisibleSelection& selectionForInsertion,
                               Options options,
                               TextCompositionType compositionType,
                               const bool isIncrementalInsertion) {
LocalFrame* frame = document.frame();
DCHECK(frame);

VisibleSelection currentSelection =
frame->selection().computeVisibleSelectionInDOMTreeDeprecated();

String newText = text;
if (compositionType != TextCompositionUpdate)
newText = dispatchBeforeTextInsertedEvent(text, selectionForInsertion);

if (compositionType == TextCompositionConfirm) {
if (dispatchTextInputEvent(frame, newText) !=
DispatchEventResult::NotCanceled)
return;
}

// Do nothing if no need to delete and insert.
if (selectionForInsertion.isCaret() && newText.isEmpty())
return;

// TODO(xiaochengh): The use of updateStyleAndLayoutIgnorePendingStylesheets
// needs to be audited. see http://crbug.com/590369 for more details.
document.updateStyleAndLayoutIgnorePendingStylesheets();

const PlainTextRange selectionOffsets = getSelectionOffsets(frame);
if (selectionOffsets.isNull())
return;
const size_t selectionStart = selectionOffsets.start();

// Set the starting and ending selection appropriately if we are using a
// selection that is different from the current selection.  In the future, we
// should change EditCommand to deal with custom selections in a general way
// that can be used by all of the commands.
if (TypingCommand* lastTypingCommand =
lastTypingCommandIfStillOpenForTyping(frame)) {
if (lastTypingCommand->endingSelection() != selectionForInsertion) {
lastTypingCommand->setStartingSelection(selectionForInsertion);
lastTypingCommand->setEndingVisibleSelection(selectionForInsertion);
}

lastTypingCommand->setCompositionType(compositionType);
lastTypingCommand->setShouldRetainAutocorrectionIndicator(
options & RetainAutocorrectionIndicator);
lastTypingCommand->setShouldPreventSpellChecking(options &
PreventSpellChecking);
lastTypingCommand->m_isIncrementalInsertion = isIncrementalInsertion;
lastTypingCommand->m_selectionStart = selectionStart;

EditingState editingState;
EventQueueScope eventQueueScope;
lastTypingCommand->insertText(newText, options & SelectInsertedText,
&editingState);
return;
}

TypingCommand* command = TypingCommand::create(document, InsertText, newText,
options, compositionType);
bool changeSelection = selectionForInsertion != currentSelection;
if (changeSelection) {
command->setStartingSelection(selectionForInsertion);
command->setEndingVisibleSelection(selectionForInsertion);
}
command->m_isIncrementalInsertion = isIncrementalInsertion;
command->m_selectionStart = selectionStart;
command->apply();

if (changeSelection) {
command->setEndingVisibleSelection(currentSelection);
frame->selection().setSelection(currentSelection.asSelection());
}
}

static void dispatchEditableContentChangedEvents(Element* startRoot,
                                                 Element* endRoot) {
  if (startRoot)
    startRoot->dispatchEvent(
        Event::create(EventTypeNames::webkitEditableContentChanged));
  if (endRoot && endRoot != startRoot)
    endRoot->dispatchEvent(
        Event::create(EventTypeNames::webkitEditableContentChanged));
}

void Editor::writeSelectionToPasteboard() {
  KURL url = frame().document()->url();
  String html = frame().selection().selectedHTMLForClipboard();
  String plainText = frame().selectedTextForClipboard();
  Pasteboard::generalPasteboard()->writeHTML(html, url, plainText,
                                             canSmartCopyOrDelete());
}

TriState Editor::selectionHasStyle(CSSPropertyID propertyID,
                                   const String& value) const {
  return EditingStyle::create(propertyID, value)
      ->triStateOfStyle(
          frame().selection().computeVisibleSelectionInDOMTreeDeprecated());
}

bool Editor::deleteWithDirection(DeleteDirection direction,
                                 TextGranularity granularity,
                                 bool killRing,
                                 bool isTypingAction) {
  if (!canEdit())
    return false;

  EditingState editingState;
  if (frame()
          .selection()
          .computeVisibleSelectionInDOMTreeDeprecated()
          .isRange()) {
    if (isTypingAction) {
      DCHECK(frame().document());
      TypingCommand::deleteKeyPressed(
          *frame().document(),
          canSmartCopyOrDelete() ? TypingCommand::SmartDelete : 0, granularity);
      revealSelectionAfterEditingOperation();
    } else {
      if (killRing)
        addToKillRing(selectedRange());
      deleteSelectionWithSmartDelete(
          canSmartCopyOrDelete() ? DeleteMode::Smart : DeleteMode::Simple,
          deletionInputTypeFromTextGranularity(direction, granularity));
    }
  } else {
    TypingCommand::Options options = 0;
    if (canSmartCopyOrDelete())
      options |= TypingCommand::SmartDelete;
    if (killRing)
      options |= TypingCommand::KillRing;
    switch (direction) {
      case DeleteDirection::Forward:
        DCHECK(frame().document());
        TypingCommand::forwardDeleteKeyPressed(
            *frame().document(), &editingState, options, granularity);
        if (editingState.isAborted())
          return false;
        break;
      case DeleteDirection::Backward:
        DCHECK(frame().document());
        TypingCommand::deleteKeyPressed(*frame().document(), options,
                                        granularity);
        break;
    }
    revealSelectionAfterEditingOperation();
  }

  if (killRing)
    setStartNewKillRingSequence(false);

  return true;
}

bool TypingCommand::isTypingCommand() const {
  return true;
}

void TypingCommand::deleteSelection(bool smartDelete,
                                    EditingState* editingState) {
  CompositeEditCommand::deleteSelection(editingState, smartDelete);
  if (editingState->isAborted())
    return;
  typingAddedToOpenCommand(DeleteSelection);
}

bool Editor::canSmartCopyOrDelete() const {
  return smartInsertDeleteEnabled() &&
         frame().selection().granularity() == WordGranularity;
}

void Editor::applyParagraphStyleToSelection(StylePropertySet* style,
                                            InputEvent::InputType inputType) {
  if (!style || style->isEmpty() || !canEditRichly())
    return;

  applyParagraphStyle(style, inputType);
}

bool Editor::insertText(const String& text, KeyboardEvent* triggeringEvent) {
  return frame().eventHandler().handleTextInputEvent(text, triggeringEvent);
}

void Editor::appliedEditing(CompositeEditCommand* cmd) {
  DCHECK(!cmd->isCommandGroupWrapper());
  EventQueueScope scope;

  spellChecker().markMisspellingsAfterApplyingCommand(*cmd);

  UndoStep* undoStep = cmd->undoStep();
  DCHECK(undoStep);
  dispatchEditableContentChangedEvents(undoStep->startingRootEditableElement(),
                                       undoStep->endingRootEditableElement());
  dispatchInputEventEditableContentChanged(
      undoStep->startingRootEditableElement(),
      undoStep->endingRootEditableElement(), cmd->inputType(),
      cmd->textDataForInputEvent(), isComposingFromCommand(cmd));

  frame().document()->updateStyleAndLayoutIgnorePendingStylesheets();

  const VisibleSelection& newSelection =
      correctedVisibleSelection(cmd->endingSelection());

  changeSelectionAfterCommand(newSelection.asSelection(), 0);

  if (!cmd->preservesTypingStyle())
    clearTypingStyle();

  if (m_lastEditCommand.get() == cmd) {
    DCHECK(cmd->isTypingCommand());
  } else if (m_lastEditCommand && m_lastEditCommand->isDragAndDropCommand() &&
             (cmd->inputType() == InputEvent::InputType::DeleteByDrag ||
              cmd->inputType() == InputEvent::InputType::InsertFromDrop)) {
    if (!m_lastEditCommand->undoStep())
      m_undoStack->registerUndoStep(m_lastEditCommand->ensureUndoStep());
    m_lastEditCommand->appendCommandToUndoStep(cmd);
  } else {
    m_lastEditCommand = cmd;
    m_undoStack->registerUndoStep(m_lastEditCommand->ensureUndoStep());
  }

  respondToChangedContents(newSelection.start());
}

void Editor::respondToChangedContents(const Position& position) {
  if (frame().settings() && frame().settings()->getAccessibilityEnabled()) {
    Node* node = position.anchorNode();
    if (AXObjectCache* cache = frame().document()->existingAXObjectCache())
      cache->handleEditableTextContentChanged(node);
  }

  spellChecker().respondToChangedContents();
  client().respondToChangedContents();
}

bool Editor::tryDHTMLCopy() {
  if (frame().selection().isInPasswordField())
    return false;

  return !dispatchCPPEvent(EventTypeNames::copy, DataTransferWritable);
}

Editor* Editor::create(LocalFrame& frame) {
  return new Editor(frame);
}

bool Editor::canDHTMLCopy() {
  return !frame().selection().isInPasswordField() &&
         !dispatchCPPEvent(EventTypeNames::beforecopy, DataTransferNumb);
}

void TypingCommand::typingAddedToOpenCommand(
    ETypingCommand commandTypeForAddedTyping) {
  LocalFrame* frame = document().frame();
  if (!frame)
    return;

  updatePreservesTypingStyle(commandTypeForAddedTyping);
  updateCommandTypeOfOpenCommand(commandTypeForAddedTyping);

  frame->editor().appliedEditing(this);
}

void Editor::replaceSelection(const String& text) {
  DCHECK(!frame().document()->needsLayoutTreeUpdate());
  bool selectReplacement = behavior().shouldSelectReplacement();
  bool smartReplace = true;
  replaceSelectionWithText(text, selectReplacement, smartReplace,
                           InputEvent::InputType::InsertReplacementText);
}

void Editor::removeFormattingAndStyle() {
  DCHECK(frame().document());
  RemoveFormatCommand::create(*frame().document())->apply();
}

bool Editor::canEditRichly() const {
  return frame()
      .selection()
      .computeVisibleSelectionInDOMTreeDeprecated()
      .isContentRichlyEditable();
}

String TypingCommand::textDataForInputEvent() const {
  if (m_commands.isEmpty() || isIncrementalInsertion())
    return m_textToInsert;
  return m_commands.back()->textDataForInputEvent();
}

EditingBehavior Editor::behavior() const {
  if (!frame().settings())
    return EditingBehavior(EditingMacBehavior);

  return EditingBehavior(frame().settings()->getEditingBehaviorType());
}

static void countEditingEvent(ExecutionContext* executionContext,
                              const Event* event,
                              UseCounter::Feature featureOnInput,
                              UseCounter::Feature featureOnTextArea,
                              UseCounter::Feature featureOnContentEditable,
                              UseCounter::Feature featureOnNonNode) {
  EventTarget* eventTarget = event->target();
  Node* node = eventTarget->toNode();
  if (!node) {
    UseCounter::count(executionContext, featureOnNonNode);
    return;
  }

  if (isHTMLInputElement(node)) {
    UseCounter::count(executionContext, featureOnInput);
    return;
  }

  if (isHTMLTextAreaElement(node)) {
    UseCounter::count(executionContext, featureOnTextArea);
    return;
  }

  TextControlElement* control = enclosingTextControl(node);
  if (isHTMLInputElement(control)) {
    UseCounter::count(executionContext, featureOnInput);
    return;
  }

  if (isHTMLTextAreaElement(control)) {
    UseCounter::count(executionContext, featureOnTextArea);
    return;
  }

  UseCounter::count(executionContext, featureOnContentEditable);
}

DEFINE_TRACE(Editor) {
  visitor->trace(m_frame);
  visitor->trace(m_lastEditCommand);
  visitor->trace(m_undoStack);
  visitor->trace(m_mark);
  visitor->trace(m_typingStyle);
}

bool Editor::replaceSelectionAfterDraggingWithEvents(
    Element* dropTarget,
    DragData* dragData,
    DocumentFragment* fragment,
    Range* dropCaretRange,
    InsertMode insertMode,
    DragSourceType dragSourceType) {
  if (!dropTarget || !dropTarget->isConnected())
    return true;

  DataTransfer* dataTransfer =
      DataTransfer::create(DataTransfer::DragAndDrop, DataTransferReadable,
                           dragData->platformData());
  dataTransfer->setSourceOperation(dragData->draggingSourceOperationMask());
  const bool shouldInsert =
      dispatchBeforeInputDataTransfer(
          dropTarget, InputEvent::InputType::InsertFromDrop, dataTransfer) ==
      DispatchEventResult::NotCanceled;

  if (m_frame->document()->frame() != m_frame)
    return false;

  if (shouldInsert && dropTarget->isConnected())
    replaceSelectionAfterDragging(fragment, insertMode, dragSourceType);

  return true;
}

bool TypingCommand::makeEditableRootEmpty(EditingState* editingState) {
  Element* root = endingSelection().rootEditableElement();
  if (!root || !root->hasChildren())
    return false;

  if (root->firstChild() == root->lastChild()) {
    if (isHTMLBRElement(root->firstChild())) {
      if (root->layoutObject() && root->layoutObject()->isLayoutBlockFlow())
        return false;
    }
  }

  while (Node* child = root->firstChild()) {
    removeNode(child, editingState);
    if (editingState->isAborted())
      return false;
  }

  addBlockPlaceholderIfNeeded(root, editingState);
  if (editingState->isAborted())
    return false;
  setEndingSelection(SelectionInDOMTree::Builder()
                         .collapse(Position::firstPositionInNode(root))
                         .setIsDirectional(endingSelection().isDirectional())
                         .build());

  return true;
}

void TypingCommand::closeTyping(LocalFrame* frame) {
  if (TypingCommand* lastTypingCommand =
          lastTypingCommandIfStillOpenForTyping(frame))
    lastTypingCommand->closeTyping();
}

static HTMLImageElement* imageElementFromImageDocument(Document* document) {
  if (!document)
    return 0;
  if (!document->isImageDocument())
    return 0;

  HTMLElement* body = document->body();
  if (!body)
    return 0;

  Node* node = body->firstChild();
  if (!isHTMLImageElement(node))
    return 0;
  return toHTMLImageElement(node);
}

void Editor::pasteWithPasteboard(Pasteboard* pasteboard) {
  DocumentFragment* fragment = nullptr;
  bool chosePlainText = false;

  if (pasteboard->isHTMLAvailable()) {
    unsigned fragmentStart = 0;
    unsigned fragmentEnd = 0;
    KURL url;
    String markup = pasteboard->readHTML(url, fragmentStart, fragmentEnd);
    if (!markup.isEmpty()) {
      DCHECK(frame().document());
      fragment = createFragmentFromMarkupWithContext(
          *frame().document(), markup, fragmentStart, fragmentEnd, url,
          DisallowScriptingAndPluginContent);
    }
  }

  if (!fragment) {
    String text = pasteboard->plainText();
    if (!text.isEmpty()) {
      chosePlainText = true;

      frame().document()->updateStyleAndLayoutIgnorePendingStylesheets();

      fragment = createFragmentFromText(selectedRange(), text);
    }
  }

  if (fragment)
    pasteAsFragment(fragment, canSmartReplaceWithPasteboard(pasteboard),
                    chosePlainText);
}

void Editor::changeSelectionAfterCommand(
    const SelectionInDOMTree& newSelection,
    FrameSelection::SetSelectionOptions options) {
  if (newSelection.isNone())
    return;

  bool selectionDidNotChangeDOMPosition =
      newSelection == frame().selection().selectionInDOMTree();
  frame().selection().setSelection(newSelection, options);

  if (selectionDidNotChangeDOMPosition) {
    client().respondToChangedSelection(
        m_frame,
        frame()
            .selection()
            .computeVisibleSelectionInDOMTreeDeprecated()
            .getSelectionType());
  }
}

bool Editor::handleTextEvent(TextEvent* event) {
  if (event->isDrop())
    return false;

  if (event->isIncrementalInsertion())
    return false;

  m_frame->document()->updateStyleAndLayoutIgnorePendingStylesheets();

  if (event->isPaste()) {
    if (event->pastingFragment()) {
      replaceSelectionWithFragment(
          event->pastingFragment(), false, event->shouldSmartReplace(),
          event->shouldMatchStyle(), InputEvent::InputType::InsertFromPaste);
    } else {
      replaceSelectionWithText(event->data(), false,
                               event->shouldSmartReplace(),
                               InputEvent::InputType::InsertFromPaste);
    }
    return true;
  }

  String data = event->data();
  if (data == "\n") {
    if (event->isLineBreak())
      return insertLineBreak();
    return insertParagraphSeparator();
  }

  if (data == " " && !canEditRichly() &&
      isCaretAtStartOfWrappedLine(frame().selection())) {
    insertLineBreak();
  }

  return insertTextWithoutSendingTextEvent(data, false, event);
}

Editor::RevealSelectionScope::~RevealSelectionScope() {
  DCHECK(m_editor->m_preventRevealSelection);
  --m_editor->m_preventRevealSelection;
  if (!m_editor->m_preventRevealSelection) {
    m_editor->frame().selection().revealSelection(
        ScrollAlignment::alignToEdgeIfNeeded, RevealExtent);
  }
}

SelectionInDOMTree createSelection(const size_t start,
                                   const size_t end,
                                   const bool isDirectional,
                                   Element* element) {
  const EphemeralRange& startRange =
      PlainTextRange(0, static_cast<int>(start)).createRange(*element);
  DCHECK(startRange.isNotNull());
  const Position& startPosition = startRange.endPosition();

  const EphemeralRange& endRange =
      PlainTextRange(0, static_cast<int>(end)).createRange(*element);
  DCHECK(endRange.isNotNull());
  const Position& endPosition = endRange.endPosition();

  const SelectionInDOMTree& selection =
      SelectionInDOMTree::Builder()
          .setBaseAndExtent(startPosition, endPosition)
          .setIsDirectional(isDirectional)
          .build();
  return selection;
}

bool Editor::canEdit() const {
  return frame()
      .selection()
      .computeVisibleSelectionInDOMTreeDeprecated()
      .rootEditableElement();
}

Element* Editor::findEventTargetFromSelection() const {
  return findEventTargetFrom(
      frame().selection().computeVisibleSelectionInDOMTreeDeprecated());
}

Editor::Editor(LocalFrame& frame)
    : m_frame(&frame),
      m_undoStack(UndoStack::create()),
      m_preventRevealSelection(0),
      m_shouldStartNewKillRingSequence(false),
      m_shouldStyleWithCSS(false),
      m_killRing(WTF::wrapUnique(new KillRing)),
      m_areMarkedTextMatchesHighlighted(false),
      m_defaultParagraphSeparator(EditorParagraphSeparatorIsDiv),
      m_overwriteModeEnabled(false) {}

void TypingCommand::deleteKeyPressed(TextGranularity granularity,
                                     bool killRing,
                                     EditingState* editingState) {
  LocalFrame* frame = document().frame();
  if (!frame)
    return;

  frame->spellChecker().updateMarkersForWordsAffectedByEditing(false);

  VisibleSelection selectionToDelete;
  VisibleSelection selectionAfterUndo;

  switch (endingSelection().getSelectionType()) {
    case RangeSelection:
      selectionToDelete = endingSelection();
      selectionAfterUndo = selectionToDelete;
      break;
    case CaretSelection: {
      bool breakOutResult =
          breakOutOfEmptyMailBlockquotedParagraph(editingState);
      if (editingState->isAborted())
        return;
      if (breakOutResult)
        typingAddedToOpenCommand(DeleteKey);

      m_smartDelete = false;
      document().updateStyleAndLayoutIgnorePendingStylesheets();

      SelectionModifier selectionModifier(*frame, endingSelection());
      selectionModifier.modify(FrameSelection::AlterationExtend,
                               DirectionBackward, granularity);
      if (killRing && selectionModifier.selection().isCaret() &&
          granularity != CharacterGranularity)
        selectionModifier.modify(FrameSelection::AlterationExtend,
                                 DirectionBackward, CharacterGranularity);

      VisiblePosition visibleStart(endingSelection().visibleStart());
      if (previousPositionOf(visibleStart, CannotCrossEditingBoundary)
              .isNull()) {
        bool breakOutOfEmptyListItemResult =
            breakOutOfEmptyListItem(editingState);
        if (editingState->isAborted())
          return;
        if (breakOutOfEmptyListItemResult) {
          typingAddedToOpenCommand(DeleteKey);
          return;
        }
        if (nextPositionOf(visibleStart, CannotCrossEditingBoundary).isNull() &&
            makeEditableRootEmpty(editingState)) {
          typingAddedToOpenCommand(DeleteKey);
          return;
        }
        if (editingState->isAborted())
          return;
      }

      Node* enclosingTableCell =
          enclosingNodeOfType(visibleStart.deepEquivalent(), &isTableCell);
      if (enclosingTableCell &&
          visibleStart.deepEquivalent() ==
              VisiblePosition::firstPositionInNode(enclosingTableCell)
                  .deepEquivalent())
        return;

      if (isStartOfParagraph(visibleStart) &&
          tableElementJustBefore(
              previousPositionOf(visibleStart, CannotCrossEditingBoundary))) {
        if (tableElementJustAfter(visibleStart))
          return;
        selectionModifier.modify(FrameSelection::AlterationExtend,
                                 DirectionBackward, granularity);
      } else if (Element* table = tableElementJustBefore(visibleStart)) {
        setEndingSelection(
            SelectionInDOMTree::Builder()
                .collapse(Position::beforeNode(table))
                .extend(endingSelection().start())
                .setIsDirectional(endingSelection().isDirectional())
                .build());
        typingAddedToOpenCommand(DeleteKey);
        return;
      }

      selectionToDelete = selectionModifier.selection();

      if (granularity == CharacterGranularity &&
          selectionToDelete.end().computeContainerNode() ==
              selectionToDelete.start().computeContainerNode() &&
          selectionToDelete.end().computeOffsetInContainerNode() -
                  selectionToDelete.start().computeOffsetInContainerNode() >
              1) {
        selectionToDelete.setWithoutValidation(
            selectionToDelete.end(),
            previousPositionOf(selectionToDelete.end(),
                               PositionMoveType::BackwardDeletion));
      }

      if (!startingSelection().isRange() ||
          selectionToDelete.base() != startingSelection().start()) {
        selectionAfterUndo = selectionToDelete;
      } else {
        selectionAfterUndo.setWithoutValidation(startingSelection().end(),
                                                selectionToDelete.extent());
      }
      break;
    }
    case NoSelection:
      NOTREACHED();
      break;
  }

  DCHECK(!selectionToDelete.isNone());
  if (selectionToDelete.isNone())
    return;

  if (selectionToDelete.isCaret())
    return;

  if (killRing)
    frame->editor().addToKillRing(
        selectionToDelete.toNormalizedEphemeralRange());
  if (frame->editor().behavior().shouldUndoOfDeleteSelectText() &&
      m_openedByBackwardDelete)
    setStartingSelection(selectionAfterUndo);
  deleteSelectionIfRange(selectionToDelete, editingState, m_smartDelete);
  if (editingState->isAborted())
    return;
  setSmartDelete(false);
  typingAddedToOpenCommand(DeleteKey);
}

bool Editor::canRedo() {
  return m_undoStack->canRedo();
}

void Editor::reappliedEditing(UndoStep* cmd) {
  EventQueueScope scope;

  dispatchEditableContentChangedEvents(cmd->startingRootEditableElement(),
                                       cmd->endingRootEditableElement());
  dispatchInputEventEditableContentChanged(
      cmd->startingRootEditableElement(), cmd->endingRootEditableElement(),
      InputEvent::InputType::HistoryRedo, nullAtom,
      InputEvent::EventIsComposing::NotComposing);

  frame().document()->updateStyleAndLayoutIgnorePendingStylesheets();
  const VisibleSelection& newSelection =
      correctedVisibleSelection(cmd->endingSelection());
  DCHECK(newSelection.isValidFor(*frame().document())) << newSelection;
  changeSelectionAfterCommand(
      newSelection.asSelection(),
      FrameSelection::CloseTyping | FrameSelection::ClearTypingStyle);

  m_lastEditCommand = nullptr;
  m_undoStack->registerUndoStep(cmd);
  respondToChangedContents(newSelection.start());
}

bool TypingCommand::insertLineBreak(Document& document) {
  if (TypingCommand* lastTypingCommand =
          lastTypingCommandIfStillOpenForTyping(document.frame())) {
    lastTypingCommand->setShouldRetainAutocorrectionIndicator(false);
    EditingState editingState;
    EventQueueScope eventQueueScope;
    lastTypingCommand->insertLineBreak(&editingState);
    return !editingState.isAborted();
  }

  return TypingCommand::create(document, InsertLineBreak, "", 0)->apply();
}

void Editor::undo() {
  m_undoStack->undo();
}
