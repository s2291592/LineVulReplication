static void msg_quit(IRC_SERVER_REC *server, const char *nick,
		     const char *address, const char *reason)
{
	if (IS_IRC_SERVER(server) && quitmsg_is_split(reason))
		signal_stop();
}

static NETJOIN_SERVER_REC *netjoin_find_server(IRC_SERVER_REC *server)
{
	GSList *tmp;

	g_return_val_if_fail(server != NULL, NULL);

	for (tmp = joinservers; tmp != NULL; tmp = tmp->next) {
		NETJOIN_SERVER_REC *rec = tmp->data;

		if (rec->server == server)
                        return rec;
	}

	return NULL;
}

static int netjoin_set_nickmode(IRC_SERVER_REC *server, NETJOIN_REC *rec,
				const char *channel, char prefix)
{
	GSList *pos;
	const char *flags;
	char *found_chan = NULL;

	for (pos = rec->now_channels; pos != NULL; pos = pos->next) {
		char *chan = pos->data;
		if (strcasecmp(chan+1, channel) == 0) {
			found_chan = chan;
			break;
		}
	}

	if (found_chan == NULL)
		return FALSE;

	flags = server->get_nick_flags(SERVER(server));
	while (*flags != '\0') {
		if (found_chan[0] == *flags)
			break;
		if (prefix == *flags) {
			found_chan[0] = prefix;
			break;
		}
		flags++;
	}
	return TRUE;
}

 void fe_netjoin_deinit(void)
{
	while (joinservers != NULL)
		netjoin_server_remove(joinservers->data);
	if (join_tag != -1) {
		g_source_remove(join_tag);
		signal_remove("print starting", (SIGNAL_FUNC) sig_print_starting);
 	}
 
 	signal_remove("setup changed", (SIGNAL_FUNC) read_settings);
 
 	signal_remove("message quit", (SIGNAL_FUNC) msg_quit);
 	signal_remove("message join", (SIGNAL_FUNC) msg_join);
	signal_remove("message irc mode", (SIGNAL_FUNC) msg_mode);
}

 void fe_netjoin_init(void)
 {
 	settings_add_bool("misc", "hide_netsplit_quits", TRUE);
	settings_add_int("misc", "netjoin_max_nicks", 10);

	join_tag = -1;
	printing_joins = FALSE;
 
 	read_settings();
 	signal_add("setup changed", (SIGNAL_FUNC) read_settings);
 }

static NETJOIN_REC *netjoin_add(IRC_SERVER_REC *server, const char *nick,
				GSList *channels)
{
	NETJOIN_REC *rec;
	NETJOIN_SERVER_REC *srec;

	g_return_val_if_fail(server != NULL, NULL);
	g_return_val_if_fail(nick != NULL, NULL);

	rec = g_new0(NETJOIN_REC, 1);
	rec->nick = g_strdup(nick);
	while (channels != NULL) {
		NETSPLIT_CHAN_REC *channel = channels->data;

		rec->old_channels = g_slist_append(rec->old_channels,
						   g_strdup(channel->name));
		channels = channels->next;
	}

	srec = netjoin_find_server(server);
	if (srec == NULL) {
		srec = g_new0(NETJOIN_SERVER_REC, 1);
		srec->server = server;
                joinservers = g_slist_append(joinservers, srec);
	}

	srec->last_netjoin = time(NULL);
	srec->netjoins = g_slist_append(srec->netjoins, rec);
	return rec;
}

static void msg_join(IRC_SERVER_REC *server, const char *channel,
		     const char *nick, const char *address)
{
	NETSPLIT_REC *split;
	NETJOIN_REC *netjoin;
	GSList *channels;
	int rejoin = 1;

	if (!IS_IRC_SERVER(server))
		return;

	if (ignore_check(SERVER(server), nick, address,
			 channel, NULL, MSGLEVEL_JOINS))
		return;

	split = netsplit_find(server, nick, address);
	netjoin = netjoin_find(server, nick);
	if (split == NULL && netjoin == NULL)
                return;

	/* if this was not a channel they split from, treat it normally */
	if (netjoin != NULL) {
		if (!gslist_find_icase_string(netjoin->old_channels, channel))
			return;
	} else {
		channels = split->channels;
		while (channels != NULL) {
			NETSPLIT_CHAN_REC *schannel = channels->data;

			if (!strcasecmp(schannel->name, channel))
				break;
			channels = channels->next;
		}
		/* we still need to create a NETJOIN_REC now as the
		 * NETSPLIT_REC will be destroyed */
		if (channels == NULL)
			rejoin = 0;
	}

	if (join_tag == -1) {
		join_tag = g_timeout_add(1000, (GSourceFunc)
					 sig_check_netjoins, NULL);
		signal_add("print starting", (SIGNAL_FUNC) sig_print_starting);
	}

	if (netjoin == NULL)
		netjoin = netjoin_add(server, nick, split->channels);

	if (rejoin)
	{
		netjoin->now_channels = g_slist_append(netjoin->now_channels,
						       g_strconcat(" ", channel, NULL));
		signal_stop();
	}
}

static void netjoin_remove(NETJOIN_SERVER_REC *server, NETJOIN_REC *rec)
{
	server->netjoins = g_slist_remove(server->netjoins, rec);

        g_slist_foreach(rec->old_channels, (GFunc) g_free, NULL);
	g_slist_foreach(rec->now_channels, (GFunc) g_free, NULL);
	g_slist_free(rec->old_channels);
	g_slist_free(rec->now_channels);

	g_free(rec->nick);
	g_free(rec);
}

static void netjoin_server_remove(NETJOIN_SERVER_REC *server)
{
	joinservers = g_slist_remove(joinservers, server);

	while (server->netjoins != NULL)
		netjoin_remove(server, server->netjoins->data);
        g_free(server);
}

static void msg_mode(IRC_SERVER_REC *server, const char *channel,
		     const char *sender, const char *addr, const char *data)
{
	NETJOIN_REC *rec;
	char *params, *mode, *nicks;
	char **nicklist, **nick, type, prefix;
	int show;

	g_return_if_fail(data != NULL);
	if (!server_ischannel(SERVER(server), channel) || addr != NULL)
		return;

	params = event_get_params(data, 2 | PARAM_FLAG_GETREST,
				  &mode, &nicks);

	/* parse server mode changes - hide operator status changes and
	   show them in the netjoin message instead as @ before the nick */
	nick = nicklist = g_strsplit(nicks, " ", -1);

	type = '+'; show = FALSE;
	for (; *mode != '\0'; mode++) {
		if (*mode == '+' || *mode == '-') {
			type = *mode;
			continue;
		}

		if (*nick != NULL && GET_MODE_PREFIX(server, *mode)) {
                        /* give/remove ops */
			rec = netjoin_find(server, *nick);
			prefix = GET_MODE_PREFIX(server, *mode);
			if (rec == NULL || type != '+' || prefix == '\0' ||
			    !netjoin_set_nickmode(server, rec, channel, prefix))
				show = TRUE;
                        nick++;
		} else {
			if (HAS_MODE_ARG(server, type, *mode) && *nick != NULL)
				nick++;
			show = TRUE;
		}
	}

	if (!show) signal_stop();

	g_strfreev(nicklist);
	g_free(params);
}
