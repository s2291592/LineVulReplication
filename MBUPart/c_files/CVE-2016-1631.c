void PPB_Flash_MessageLoop_Impl::Quit() { InternalQuit(PP_OK); }

 TestFlashMessageLoop::~TestFlashMessageLoop() {
   PP_DCHECK(!message_loop_);
 }

  State() : result_(PP_OK), run_called_(false), quit_called_(false) {}

  void LaunchTestingApp(const std::string& extension_dirname) {
    base::FilePath data_dir;
    ASSERT_TRUE(PathService::Get(chrome::DIR_GEN_TEST_DATA, &data_dir));
    base::FilePath app_dir = data_dir.AppendASCII("ppapi")
                                     .AppendASCII("tests")
                                     .AppendASCII("extensions")
                                     .AppendASCII(extension_dirname)
                                     .AppendASCII(toolchain_);

    const extensions::Extension* extension = LoadExtension(app_dir);
    ASSERT_TRUE(extension);

    AppLaunchParams params(browser()->profile(), extension,
                           extensions::LAUNCH_CONTAINER_NONE, NEW_WINDOW,
                           extensions::SOURCE_TEST);
    params.command_line = *base::CommandLine::ForCurrentProcess();
    OpenApplication(params);
  }

void TestFlashMessageLoop::DestroyMessageLoopResourceTask(int32_t unused) {
if (message_loop_) {
delete message_loop_;
    message_loop_ = NULL;
} else {
PP_NOTREACHED();
}
}

TestFlashMessageLoop::TestFlashMessageLoop(TestingInstance* instance)
: TestCase(instance),
      message_loop_(NULL),
      callback_factory_(this) {
}

PPB_Flash_MessageLoop_Impl::PPB_Flash_MessageLoop_Impl(PP_Instance instance)
    : Resource(ppapi::OBJECT_IS_IMPL, instance), state_(new State()) {}

  bool run_called() const { return run_called_; }

 void TestFlashMessageLoop::RunTests(const std::string& filter) {
   RUN_TEST(Basics, filter);
   RUN_TEST(RunWithoutQuit, filter);
 }

  int32_t result() const { return result_; }

  void set_result(int32_t result) { result_ = result; }

void PPB_Flash_MessageLoop_Impl::InternalQuit(int32_t result) {
  if (!state_->run_called() || state_->quit_called())
    return;
  state_->set_quit_called();
  state_->set_result(result);

  base::MessageLoop::current()->QuitNow();

  if (!state_->run_callback().is_null())
    state_->run_callback().Run(result);
}

PPB_Flash_MessageLoop_Impl::AsPPB_Flash_MessageLoop_API() {
  return this;
}

  void set_run_callback(const RunFromHostProxyCallback& run_callback) {
    run_callback_ = run_callback;
  }

  virtual ~State() {}

  NewlibPackagedAppTest() : PackagedAppTest("newlib") { }

  void set_quit_called() { quit_called_ = true; }

void PPB_Flash_MessageLoop_Impl::RunFromHostProxy(
    const RunFromHostProxyCallback& callback) {
  InternalRun(callback);
}

 void TestFlashMessageLoop::QuitMessageLoopTask(int32_t unused) {
   if (message_loop_)
     message_loop_->Quit();
  else
    PP_NOTREACHED();
}

int32_t PPB_Flash_MessageLoop_Impl::InternalRun(
    const RunFromHostProxyCallback& callback) {
  if (state_->run_called()) {
    if (!callback.is_null())
      callback.Run(PP_ERROR_FAILED);
    return PP_ERROR_FAILED;
  }
  state_->set_run_called();
  state_->set_run_callback(callback);

  scoped_refptr<State> state_protector(state_);
   {
     base::MessageLoop::ScopedNestableTaskAllower allow(
         base::MessageLoop::current());
     base::MessageLoop::current()->Run();
   }
 
  return state_protector->result();
}

PPB_Flash_MessageLoop_Impl::~PPB_Flash_MessageLoop_Impl() {
  InternalQuit(PP_ERROR_ABORTED);
}

std::string TestFlashMessageLoop::TestRunWithoutQuit() {
message_loop_ = new pp::flash::MessageLoop(instance_);

pp::CompletionCallback callback = callback_factory_.NewCallback(
&TestFlashMessageLoop::DestroyMessageLoopResourceTask);
pp::Module::Get()->core()->CallOnMainThread(0, callback);
int32_t result = message_loop_->Run();

if (message_loop_) {
delete message_loop_;
    message_loop_ = NULL;
ASSERT_TRUE(false);
}

ASSERT_EQ(PP_ERROR_ABORTED, result);
PASS();
}

std::string TestFlashMessageLoop::TestBasics() {
message_loop_ = new pp::flash::MessageLoop(instance_);

pp::CompletionCallback callback = callback_factory_.NewCallback(
&TestFlashMessageLoop::QuitMessageLoopTask);
pp::Module::Get()->core()->CallOnMainThread(0, callback);
int32_t result = message_loop_->Run();

ASSERT_TRUE(message_loop_);
delete message_loop_;
  message_loop_ = NULL;

ASSERT_EQ(PP_OK, result);
PASS();
}

  NonSfiPackagedAppTest() : PackagedAppTest("nonsfi") { }
