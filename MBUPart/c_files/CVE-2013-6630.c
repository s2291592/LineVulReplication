bool EnableInProcessStackDumping() {
  struct sigaction sigpipe_action;
  memset(&sigpipe_action, 0, sizeof(sigpipe_action));
  sigpipe_action.sa_handler = SIG_IGN;
  sigemptyset(&sigpipe_action.sa_mask);
  bool success = (sigaction(SIGPIPE, &sigpipe_action, NULL) == 0);

  WarmUpBacktrace();

  struct sigaction action;
  memset(&action, 0, sizeof(action));
  action.sa_flags = SA_RESETHAND | SA_SIGINFO;
  action.sa_sigaction = &StackDumpSignalHandler;
  sigemptyset(&action.sa_mask);

  success &= (sigaction(SIGILL, &action, NULL) == 0);
  success &= (sigaction(SIGABRT, &action, NULL) == 0);
  success &= (sigaction(SIGFPE, &action, NULL) == 0);
  success &= (sigaction(SIGBUS, &action, NULL) == 0);
  success &= (sigaction(SIGSEGV, &action, NULL) == 0);
#if !defined(OS_LINUX)
  success &= (sigaction(SIGSYS, &action, NULL) == 0);
#endif  // !defined(OS_LINUX)

  return success;
}

  ~SandboxSymbolizeHelper() {
    UnregisterCallback();
    CloseObjectFiles();
  }

  const FilePath test_path() const { return dir_.path().AppendASCII("test"); }

static void VariableArgsFunc(const char* format, ...) {
  va_list org;
  va_start(org, format);

  va_list dup;
  GG_VA_COPY(dup, org);
  int i1 = va_arg(org, int);
  int j1 = va_arg(org, int);
  char* s1 = va_arg(org, char*);
  double d1 = va_arg(org, double);
  va_end(org);

  int i2 = va_arg(dup, int);
  int j2 = va_arg(dup, int);
  char* s2 = va_arg(dup, char*);
  double d2 = va_arg(dup, double);

  EXPECT_EQ(i1, i2);
  EXPECT_EQ(j1, j2);
  EXPECT_STREQ(s1, s2);
  EXPECT_EQ(d1, d2);

  va_end(dup);
}

bool EnableInProcessStackDumpingForSandbox() {
#if defined(USE_SYMBOLIZE)
  SandboxSymbolizeHelper::GetInstance();
#endif  // USE_SYMBOLIZE

  return EnableInProcessStackDumping();
}

void PrintToStderr(const char* output) {
  ignore_result(HANDLE_EINTR(write(STDERR_FILENO, output, strlen(output))));
}

bool Truncated(const std::string& input,
               const size_t byte_size,
               std::string* output) {
    size_t prev = input.length();
    TruncateUTF8ToByteSize(input, byte_size, output);
    return prev != output->length();
}

  static void WritesCorrectly(size_t num_chars) {
    std::string buffer;
    char kOriginal[] = "supercali";
    strncpy(WriteInto(&buffer, num_chars + 1), kOriginal, num_chars);
    EXPECT_EQ(std::string(kOriginal,
                          std::min(num_chars, arraysize(kOriginal) - 1)),
              std::string(buffer.c_str()));
    EXPECT_EQ(num_chars, buffer.size());
  }

  void UnregisterCallback() {
    if (is_initialized_) {
      google::InstallSymbolizeOpenObjectFileCallback(NULL);
      is_initialized_ = false;
    }
  }

void SetRTL(bool rtl) {
  SetICUDefaultLocale(rtl ? "he" : "en");
  EXPECT_EQ(rtl, IsRTL());
}

CancelableSyncSocket::CancelableSyncSocket(Handle handle)
    : SyncSocket(handle), shutdown_event_(true, false),
      file_operation_(true, false) {
}

bool CancelableSyncSocket::Close() {
  const bool result = SyncSocket::Close();
  shutdown_event_.Reset();
  return result;
}

  void DidCreateTemporary(File::Error error,
                          const FilePath& path) {
    error_ = error;
    path_ = path;
    MessageLoop::current()->QuitWhenIdle();
  }

scoped_refptr<base::FieldTrial> CreateFieldTrial(
    const std::string& trial_name,
    int total_probability,
    const std::string& default_group_name,
    int* default_group_number) {
  return FieldTrialList::FactoryGetFieldTrial(
      trial_name, total_probability, default_group_name,
      base::FieldTrialList::kNoExpirationYear, 1, 1,
      base::FieldTrial::SESSION_RANDOMIZED, default_group_number);
}

  const FilePath& test_dir_path() const { return dir_.path(); }

  void Init() {
    if (CacheMemoryRegions()) {
      OpenSymbolFiles();
      google::InstallSymbolizeOpenObjectFileCallback(
          &OpenObjectFileContainingPc);
    }
  }

bool SyncSocket::PrepareTransitDescriptor(ProcessHandle peer_process_handle,
                                          TransitDescriptor* descriptor) {
  DCHECK(descriptor);
  if (!::DuplicateHandle(GetCurrentProcess(), handle(), peer_process_handle,
                         descriptor, 0, FALSE, DUPLICATE_SAME_ACCESS)) {
    DPLOG(ERROR) << "Cannot duplicate socket handle for peer process.";
    return false;
  }
  return true;
}

  void CreateProxy(uint32 flags, FileProxy* proxy) {
    proxy->CreateOrOpen(
        test_path(), flags,
        Bind(&FileProxyTest::DidCreateOrOpen, weak_factory_.GetWeakPtr()));
    MessageLoop::current()->Run();
    EXPECT_TRUE(proxy->IsValid());
  }

size_t SyncSocket::Receive(void* buffer, size_t length) {
  ThreadRestrictions::AssertIOAllowed();
  DCHECK_GT(length, 0u);
  DCHECK_LE(length, kMaxMessageLength);
  DCHECK_NE(handle_, kInvalidHandle);
  size_t count = 0;
  while (count < length) {
    DWORD len;
    DWORD chunk = GetNextChunkSize(count, length);
    if (ReadFile(handle_, static_cast<char*>(buffer) + count,
                 chunk, &len, NULL) == FALSE) {
      return count;
    }
    count += len;
  }
  return count;
}

SyncSocket::~SyncSocket() {
  Close();
}

SyncSocket::Handle SyncSocket::UnwrapHandle(
    const TransitDescriptor& descriptor) {
  return descriptor;
}

void StackDumpSignalHandler(int signal, siginfo_t* info, void* void_context) {
// NOTE: This code MUST be async-signal safe.
// NO malloc or stdio is allowed here.

// Record the fact that we are in the signal handler now, so that the rest
// of StackTrace can behave in an async-signal-safe manner.
in_signal_handler = 1;

if (BeingDebugged())
BreakDebugger();

PrintToStderr("Received signal ");
char buf[1024] = { 0 };
internal::itoa_r(signal, buf, sizeof(buf), 10, 0);
PrintToStderr(buf);
if (signal == SIGBUS) {
if (info->si_code == BUS_ADRALN)
PrintToStderr(" BUS_ADRALN ");
else if (info->si_code == BUS_ADRERR)
PrintToStderr(" BUS_ADRERR ");
else if (info->si_code == BUS_OBJERR)
PrintToStderr(" BUS_OBJERR ");
else
PrintToStderr(" <unknown> ");
} else if (signal == SIGFPE) {
if (info->si_code == FPE_FLTDIV)
PrintToStderr(" FPE_FLTDIV ");
else if (info->si_code == FPE_FLTINV)
PrintToStderr(" FPE_FLTINV ");
else if (info->si_code == FPE_FLTOVF)
PrintToStderr(" FPE_FLTOVF ");
else if (info->si_code == FPE_FLTRES)
PrintToStderr(" FPE_FLTRES ");
else if (info->si_code == FPE_FLTSUB)
PrintToStderr(" FPE_FLTSUB ");
else if (info->si_code == FPE_FLTUND)
PrintToStderr(" FPE_FLTUND ");
else if (info->si_code == FPE_INTDIV)
PrintToStderr(" FPE_INTDIV ");
else if (info->si_code == FPE_INTOVF)
PrintToStderr(" FPE_INTOVF ");
else
PrintToStderr(" <unknown> ");
} else if (signal == SIGILL) {
if (info->si_code == ILL_BADSTK)
PrintToStderr(" ILL_BADSTK ");
else if (info->si_code == ILL_COPROC)
PrintToStderr(" ILL_COPROC ");
else if (info->si_code == ILL_ILLOPN)
PrintToStderr(" ILL_ILLOPN ");
else if (info->si_code == ILL_ILLADR)
PrintToStderr(" ILL_ILLADR ");
else if (info->si_code == ILL_ILLTRP)
PrintToStderr(" ILL_ILLTRP ");
else if (info->si_code == ILL_PRVOPC)
PrintToStderr(" ILL_PRVOPC ");
else if (info->si_code == ILL_PRVREG)
PrintToStderr(" ILL_PRVREG ");
else
PrintToStderr(" <unknown> ");
} else if (signal == SIGSEGV) {
if (info->si_code == SEGV_MAPERR)
PrintToStderr(" SEGV_MAPERR ");
else if (info->si_code == SEGV_ACCERR)
PrintToStderr(" SEGV_ACCERR ");
else
PrintToStderr(" <unknown> ");
}
if (signal == SIGBUS || signal == SIGFPE ||
signal == SIGILL || signal == SIGSEGV) {
internal::itoa_r(reinterpret_cast<intptr_t>(info->si_addr),
buf, sizeof(buf), 16, 12);
PrintToStderr(buf);
}
PrintToStderr("\n");

debug::StackTrace().Print();

#if defined(OS_LINUX)
#if ARCH_CPU_X86_FAMILY
ucontext_t* context = reinterpret_cast<ucontext_t*>(void_context);
const struct {
const char* label;
greg_t value;
} registers[] = {
#if ARCH_CPU_32_BITS
{ "  gs: ", context->uc_mcontext.gregs[REG_GS] },
{ "  fs: ", context->uc_mcontext.gregs[REG_FS] },
{ "  es: ", context->uc_mcontext.gregs[REG_ES] },
{ "  ds: ", context->uc_mcontext.gregs[REG_DS] },
{ " edi: ", context->uc_mcontext.gregs[REG_EDI] },
{ " esi: ", context->uc_mcontext.gregs[REG_ESI] },
{ " ebp: ", context->uc_mcontext.gregs[REG_EBP] },
{ " esp: ", context->uc_mcontext.gregs[REG_ESP] },
{ " ebx: ", context->uc_mcontext.gregs[REG_EBX] },
{ " edx: ", context->uc_mcontext.gregs[REG_EDX] },
{ " ecx: ", context->uc_mcontext.gregs[REG_ECX] },
{ " eax: ", context->uc_mcontext.gregs[REG_EAX] },
{ " trp: ", context->uc_mcontext.gregs[REG_TRAPNO] },
{ " err: ", context->uc_mcontext.gregs[REG_ERR] },
{ "  ip: ", context->uc_mcontext.gregs[REG_EIP] },
{ "  cs: ", context->uc_mcontext.gregs[REG_CS] },
{ " efl: ", context->uc_mcontext.gregs[REG_EFL] },
{ " usp: ", context->uc_mcontext.gregs[REG_UESP] },
{ "  ss: ", context->uc_mcontext.gregs[REG_SS] },
#elif ARCH_CPU_64_BITS
{ "  r8: ", context->uc_mcontext.gregs[REG_R8] },
{ "  r9: ", context->uc_mcontext.gregs[REG_R9] },
{ " r10: ", context->uc_mcontext.gregs[REG_R10] },
{ " r11: ", context->uc_mcontext.gregs[REG_R11] },
{ " r12: ", context->uc_mcontext.gregs[REG_R12] },
{ " r13: ", context->uc_mcontext.gregs[REG_R13] },
{ " r14: ", context->uc_mcontext.gregs[REG_R14] },
{ " r15: ", context->uc_mcontext.gregs[REG_R15] },
{ "  di: ", context->uc_mcontext.gregs[REG_RDI] },
{ "  si: ", context->uc_mcontext.gregs[REG_RSI] },
{ "  bp: ", context->uc_mcontext.gregs[REG_RBP] },
{ "  bx: ", context->uc_mcontext.gregs[REG_RBX] },
{ "  dx: ", context->uc_mcontext.gregs[REG_RDX] },
{ "  ax: ", context->uc_mcontext.gregs[REG_RAX] },
{ "  cx: ", context->uc_mcontext.gregs[REG_RCX] },
{ "  sp: ", context->uc_mcontext.gregs[REG_RSP] },
{ "  ip: ", context->uc_mcontext.gregs[REG_RIP] },
{ " efl: ", context->uc_mcontext.gregs[REG_EFL] },
{ " cgf: ", context->uc_mcontext.gregs[REG_CSGSFS] },
{ " erf: ", context->uc_mcontext.gregs[REG_ERR] },
{ " trp: ", context->uc_mcontext.gregs[REG_TRAPNO] },
{ " msk: ", context->uc_mcontext.gregs[REG_OLDMASK] },
{ " cr2: ", context->uc_mcontext.gregs[REG_CR2] },
#endif
};

#if ARCH_CPU_32_BITS
const int kRegisterPadding = 8;
#elif ARCH_CPU_64_BITS
const int kRegisterPadding = 16;
#endif

  for (size_t i = 0; i < ARRAYSIZE_UNSAFE(registers); i++) {
PrintToStderr(registers[i].label);
internal::itoa_r(registers[i].value, buf, sizeof(buf),
16, kRegisterPadding);
PrintToStderr(buf);

if ((i + 1) % 4 == 0)
PrintToStderr("\n");
}
PrintToStderr("\n");
#endif
#elif defined(OS_MACOSX)
// TODO(shess): Port to 64-bit, and ARM architecture (32 and 64-bit).
#if ARCH_CPU_X86_FAMILY && ARCH_CPU_32_BITS
ucontext_t* context = reinterpret_cast<ucontext_t*>(void_context);
size_t len;

// NOTE: Even |snprintf()| is not on the approved list for signal
// handlers, but buffered I/O is definitely not on the list due to
// potential for |malloc()|.
len = static_cast<size_t>(
snprintf(buf, sizeof(buf),
"ax: %x, bx: %x, cx: %x, dx: %x\n",
context->uc_mcontext->__ss.__eax,
context->uc_mcontext->__ss.__ebx,
context->uc_mcontext->__ss.__ecx,
context->uc_mcontext->__ss.__edx));
write(STDERR_FILENO, buf, std::min(len, sizeof(buf) - 1));

len = static_cast<size_t>(
snprintf(buf, sizeof(buf),
"di: %x, si: %x, bp: %x, sp: %x, ss: %x, flags: %x\n",
context->uc_mcontext->__ss.__edi,
context->uc_mcontext->__ss.__esi,
context->uc_mcontext->__ss.__ebp,
context->uc_mcontext->__ss.__esp,
context->uc_mcontext->__ss.__ss,
context->uc_mcontext->__ss.__eflags));
write(STDERR_FILENO, buf, std::min(len, sizeof(buf) - 1));

len = static_cast<size_t>(
snprintf(buf, sizeof(buf),
"ip: %x, cs: %x, ds: %x, es: %x, fs: %x, gs: %x\n",
context->uc_mcontext->__ss.__eip,
context->uc_mcontext->__ss.__cs,
context->uc_mcontext->__ss.__ds,
context->uc_mcontext->__ss.__es,
context->uc_mcontext->__ss.__fs,
context->uc_mcontext->__ss.__gs));
write(STDERR_FILENO, buf, std::min(len, sizeof(buf) - 1));
#endif  // ARCH_CPU_32_BITS
#endif  // defined(OS_MACOSX)
_exit(1);
}

  void DidGetFileInfo(File::Error error,
                      const File::Info& file_info) {
    error_ = error;
    file_info_ = file_info;
    MessageLoop::current()->QuitWhenIdle();
  }

void StackTrace::Print() const {

#if !defined(__UCLIBC__)
  PrintBacktraceOutputHandler handler;
  ProcessBacktrace(trace_, count_, &handler);
#endif
}

bool SyncSocket::CreatePair(SyncSocket* socket_a, SyncSocket* socket_b) {
  return CreatePairImpl(&socket_a->handle_, &socket_b->handle_, false);
}

void WarmUpBacktrace() {
  StackTrace stack_trace;
}

StackTrace::StackTrace() {

#if !defined(__UCLIBC__)
  count_ = base::saturated_cast<size_t>(backtrace(trace_, arraysize(trace_)));
#else
  count_ = 0;
#endif
}

  const std::string& trial_name() const { return trial_name_; }

DWORD GetNextChunkSize(size_t current_pos, size_t max_size) {
  return static_cast<DWORD>(((max_size - current_pos) <= UINT_MAX) ?
      (max_size - current_pos) : UINT_MAX);
}

  static SandboxSymbolizeHelper* GetInstance() {
    return Singleton<SandboxSymbolizeHelper>::get();
  }

int GetLastYear() {
  Time last_year_time = Time::NowFromSystemTime() - TimeDelta::FromDays(365);
  Time::Exploded exploded;
  last_year_time.LocalExplode(&exploded);
  return exploded.year;
}

size_t CancelableSyncSocket::Receive(void* buffer, size_t length) {
  return CancelableFileOperation(
      &ReadFile, handle_, reinterpret_cast<char*>(buffer), length,
      &file_operation_, &shutdown_event_, this, INFINITE);
}

  TestFieldTrialObserver() {
    FieldTrialList::AddObserver(this);
  }

bool CreatePairImpl(HANDLE* socket_a, HANDLE* socket_b, bool overlapped) {
  DCHECK_NE(socket_a, socket_b);
  DCHECK_EQ(*socket_a, SyncSocket::kInvalidHandle);
  DCHECK_EQ(*socket_b, SyncSocket::kInvalidHandle);

  wchar_t name[kPipePathMax];
  ScopedHandle handle_a;
  DWORD flags = PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE;
  if (overlapped)
    flags |= FILE_FLAG_OVERLAPPED;

  do {
    unsigned int rnd_name;
    if (rand_s(&rnd_name) != 0)
      return false;

    swprintf(name, kPipePathMax,
             kPipeNameFormat,
             GetCurrentProcessId(),
             GetCurrentThreadId(),
             rnd_name);

    handle_a.Set(CreateNamedPipeW(
        name,
        flags,
        PIPE_TYPE_BYTE | PIPE_READMODE_BYTE,
        1,
        kOutBufferSize,
        kInBufferSize,
        kDefaultTimeoutMilliSeconds,
        NULL));
  } while (!handle_a.IsValid() &&
           (GetLastError() == ERROR_PIPE_BUSY));

  if (!handle_a.IsValid()) {
    NOTREACHED();
    return false;
  }

  flags = SECURITY_SQOS_PRESENT | SECURITY_ANONYMOUS;
  if (overlapped)
    flags |= FILE_FLAG_OVERLAPPED;

  ScopedHandle handle_b(CreateFileW(name,
                                    GENERIC_READ | GENERIC_WRITE,
                                    0,          // no sharing.
                                    NULL,       // default security attributes.
                                    OPEN_EXISTING,  // opens existing pipe.
                                    flags,
                                    NULL));     // no template file.
  if (!handle_b.IsValid()) {
    DPLOG(ERROR) << "CreateFileW failed";
    return false;
  }

  if (!ConnectNamedPipe(handle_a.Get(), NULL)) {
    DWORD error = GetLastError();
    if (error != ERROR_PIPE_CONNECTED) {
      DPLOG(ERROR) << "ConnectNamedPipe failed";
      return false;
    }
  }

  *socket_a = handle_a.Take();
  *socket_b = handle_b.Take();

  return true;
}

  void DidCreateOrOpen(File::Error error) {
    error_ = error;
    MessageLoop::current()->QuitWhenIdle();
  }

  static int OpenObjectFileContainingPc(uint64_t pc, uint64_t& start_address,
                                        uint64_t& base_address, char* file_path,
                                        int file_path_size) {
    SandboxSymbolizeHelper* instance = GetInstance();

    std::vector<MappedMemoryRegion>::const_iterator it;
    bool is_first = true;
    for (it = instance->regions_.begin(); it != instance->regions_.end();
         ++it, is_first = false) {
      const MappedMemoryRegion& region = *it;
      if (region.start <= pc && pc < region.end) {
        start_address = region.start;
        base_address = (is_first ? 0U : start_address) - region.offset;
        if (file_path && file_path_size > 0) {
          strncpy(file_path, region.path.c_str(), file_path_size);
          file_path[file_path_size - 1] = '\0';
        }
        return instance->GetFileDescriptor(region.path.c_str());
      }
    }
    return -1;
  }

void OutputFrameId(intptr_t frame_id, BacktraceOutputHandler* handler) {
  char buf[30] = { '\0' };
  handler->HandleOutput("#");
  internal::itoa_r(frame_id, buf, sizeof(buf), 10, 1);
  handler->HandleOutput(buf);
}

  void DidFinish(File::Error error) {
    error_ = error;
    MessageLoop::current()->QuitWhenIdle();
  }

size_t SyncSocket::Peek() {
  DWORD available = 0;
  PeekNamedPipe(handle_, NULL, 0, NULL, &available, NULL);
  return available;
}

  virtual ~BacktraceOutputHandler() {}

  void OpenSymbolFiles() {
#if !defined(NDEBUG)
    std::vector<MappedMemoryRegion>::const_iterator it;
    for (it = regions_.begin(); it != regions_.end(); ++it) {
      const MappedMemoryRegion& region = *it;
      if ((region.permissions & MappedMemoryRegion::READ) ==
              MappedMemoryRegion::READ &&
          (region.permissions & MappedMemoryRegion::WRITE) == 0 &&
          (region.permissions & MappedMemoryRegion::EXECUTE) ==
              MappedMemoryRegion::EXECUTE) {
        if (region.path.empty()) {
          continue;
        }
        if (region.path[0] == '[') {
          continue;
        }
        if (modules_.find(region.path) == modules_.end()) {
          int fd = open(region.path.c_str(), O_RDONLY | O_CLOEXEC);
          if (fd >= 0) {
            modules_.insert(std::make_pair(region.path, fd));
          } else {
            LOG(WARNING) << "Failed to open file: " << region.path
                         << "\n  Error: " << strerror(errno);
          }
        }
      }
    }
#endif  // !defined(NDEBUG)
  }

size_t CancelableSyncSocket::Send(const void* buffer, size_t length) {
  static const DWORD kWaitTimeOutInMs = 500;
  return CancelableFileOperation(
      &WriteFile, handle_, reinterpret_cast<const char*>(buffer),
      length, &file_operation_, &shutdown_event_, this, kWaitTimeOutInMs);
}

  FieldTrialTest() : trial_list_(NULL) {}

  void DidRead(File::Error error,
               const char* data,
               int bytes_read) {
    error_ = error;
    buffer_.resize(bytes_read);
    memcpy(&buffer_[0], data, bytes_read);
    MessageLoop::current()->QuitWhenIdle();
  }

size_t SyncSocket::ReceiveWithTimeout(void* buffer,
                                      size_t length,
                                      TimeDelta timeout) {
  NOTIMPLEMENTED();
  return 0;
}

bool SyncSocket::Close() {
  if (handle_ == kInvalidHandle)
    return true;

  const BOOL result = CloseHandle(handle_);
  handle_ = kInvalidHandle;
  return result == TRUE;
}

size_t SyncSocket::Send(const void* buffer, size_t length) {
  ThreadRestrictions::AssertIOAllowed();
  DCHECK_GT(length, 0u);
  DCHECK_LE(length, kMaxMessageLength);
  DCHECK_NE(handle_, kInvalidHandle);
  size_t count = 0;
  while (count < length) {
    DWORD len;
    DWORD chunk = GetNextChunkSize(count, length);
    if (WriteFile(handle_, static_cast<const char*>(buffer) + count,
                  chunk, &len, NULL) == FALSE) {
      return count;
    }
    count += len;
  }
  return count;
}

CancelableSyncSocket::CancelableSyncSocket()
    : shutdown_event_(true, false), file_operation_(true, false) {
}

size_t CancelableSyncSocket::ReceiveWithTimeout(void* buffer,
                                                size_t length,
                                                TimeDelta timeout) {
  return CancelableFileOperation(
      &ReadFile, handle_, reinterpret_cast<char*>(buffer), length,
      &file_operation_, &shutdown_event_, this,
      static_cast<DWORD>(timeout.InMilliseconds()));
}

void SplitString(const std::wstring& str,
                 wchar_t c,
                 std::vector<std::wstring>* result) {
  std::vector<string16> result16;
  SplitString(WideToUTF16(str), c, &result16);
  for (size_t i = 0; i < result16.size(); ++i)
    result->push_back(UTF16ToWide(result16[i]));
}

void TokenizeTest() {
  std::vector<STR> r;
  size_t size;

  size = Tokenize(STR("This is a string"), STR(" "), &r);
  EXPECT_EQ(4U, size);
  ASSERT_EQ(4U, r.size());
  EXPECT_EQ(r[0], STR("This"));
  EXPECT_EQ(r[1], STR("is"));
  EXPECT_EQ(r[2], STR("a"));
  EXPECT_EQ(r[3], STR("string"));
  r.clear();

  size = Tokenize(STR("one,two,three"), STR(","), &r);
  EXPECT_EQ(3U, size);
  ASSERT_EQ(3U, r.size());
  EXPECT_EQ(r[0], STR("one"));
  EXPECT_EQ(r[1], STR("two"));
  EXPECT_EQ(r[2], STR("three"));
  r.clear();

  size = Tokenize(STR("one,two:three;four"), STR(",:"), &r);
  EXPECT_EQ(3U, size);
  ASSERT_EQ(3U, r.size());
  EXPECT_EQ(r[0], STR("one"));
  EXPECT_EQ(r[1], STR("two"));
  EXPECT_EQ(r[2], STR("three;four"));
  r.clear();

  size = Tokenize(STR("one,two:three;four"), STR(";,:"), &r);
  EXPECT_EQ(4U, size);
  ASSERT_EQ(4U, r.size());
  EXPECT_EQ(r[0], STR("one"));
  EXPECT_EQ(r[1], STR("two"));
  EXPECT_EQ(r[2], STR("three"));
  EXPECT_EQ(r[3], STR("four"));
  r.clear();

  size = Tokenize(STR("one, two, three"), STR(","), &r);
  EXPECT_EQ(3U, size);
  ASSERT_EQ(3U, r.size());
  EXPECT_EQ(r[0], STR("one"));
  EXPECT_EQ(r[1], STR(" two"));
  EXPECT_EQ(r[2], STR(" three"));
  r.clear();

  size = Tokenize(STR("one, two, three, "), STR(","), &r);
  EXPECT_EQ(4U, size);
  ASSERT_EQ(4U, r.size());
  EXPECT_EQ(r[0], STR("one"));
  EXPECT_EQ(r[1], STR(" two"));
  EXPECT_EQ(r[2], STR(" three"));
  EXPECT_EQ(r[3], STR(" "));
  r.clear();

  size = Tokenize(STR("one, two, three,"), STR(","), &r);
  EXPECT_EQ(3U, size);
  ASSERT_EQ(3U, r.size());
  EXPECT_EQ(r[0], STR("one"));
  EXPECT_EQ(r[1], STR(" two"));
  EXPECT_EQ(r[2], STR(" three"));
  r.clear();

  size = Tokenize(STR(), STR(","), &r);
  EXPECT_EQ(0U, size);
  ASSERT_EQ(0U, r.size());
  r.clear();

  size = Tokenize(STR(","), STR(","), &r);
  EXPECT_EQ(0U, size);
  ASSERT_EQ(0U, r.size());
  r.clear();

  size = Tokenize(STR(",;:."), STR(".:;,"), &r);
  EXPECT_EQ(0U, size);
  ASSERT_EQ(0U, r.size());
  r.clear();

  size = Tokenize(STR("\t\ta\t"), STR("\t"), &r);
  EXPECT_EQ(1U, size);
  ASSERT_EQ(1U, r.size());
  EXPECT_EQ(r[0], STR("a"));
  r.clear();

  size = Tokenize(STR("\ta\t\nb\tcc"), STR("\n"), &r);
  EXPECT_EQ(2U, size);
  ASSERT_EQ(2U, r.size());
  EXPECT_EQ(r[0], STR("\ta\t"));
  EXPECT_EQ(r[1], STR("b\tcc"));
  r.clear();
}

  virtual ~TestFieldTrialObserver() {
    FieldTrialList::RemoveObserver(this);
  }

string16 BuildString16(const wchar_t* s) {
#if defined(WCHAR_T_IS_UTF16)
  return string16(s);
#elif defined(WCHAR_T_IS_UTF32)
  string16 u16;
  while (*s != 0) {
    DCHECK_LE(static_cast<unsigned int>(*s), 0xFFFFu);
    u16.push_back(*s++);
  }
  return u16;
#endif
}

  TaskRunner* file_task_runner() const {
    return file_thread_.message_loop_proxy().get();
  }

  PrintBacktraceOutputHandler() {}
