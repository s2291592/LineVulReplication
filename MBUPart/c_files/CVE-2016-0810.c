Sample::Sample(int sampleID, const char* url)
{
    init();
    mSampleID = sampleID;
    mUrl = strdup(url);
    ALOGV("create sampleID=%d, url=%s", mSampleID, mUrl);
}

void SoundChannel::process(int event, void *info, unsigned long toggle)
{

 Mutex::Autolock lock(&mLock);

 AudioTrack::Buffer* b = NULL;
 if (event == AudioTrack::EVENT_MORE_DATA) {
       b = static_cast<AudioTrack::Buffer *>(info);
 }

 if (mToggle != toggle) {
        ALOGV("process wrong toggle %p channel %d", this, mChannelID);
 if (b != NULL) {
            b->size = 0;
 }
 return;
 }

    sp<Sample> sample = mSample;


 if (event == AudioTrack::EVENT_MORE_DATA) {

 if (b->size == 0) return;

 if (mState == IDLE) {
            b->size = 0;
 return;
 }

 if (sample != 0) {
 uint8_t* q = (uint8_t*) b->i8;
 size_t count = 0;

 if (mPos < (int)sample->size()) {
 uint8_t* p = sample->data() + mPos;
                count = sample->size() - mPos;
 if (count > b->size) {
                    count = b->size;
 }
                memcpy(q, p, count);
 } else if (mPos < mAudioBufferSize) {
                count = mAudioBufferSize - mPos;
 if (count > b->size) {
                    count = b->size;
 }
                memset(q, 0, count);
 }

            mPos += count;
            b->size = count;
 }
 } else if (event == AudioTrack::EVENT_UNDERRUN || event == AudioTrack::EVENT_BUFFER_END ||
            event == AudioTrack::EVENT_NEW_IAUDIOTRACK) {
        ALOGV("process %p channel %d event %s",
 this, mChannelID, (event == AudioTrack::EVENT_UNDERRUN) ? "UNDERRUN" :
 (event == AudioTrack::EVENT_BUFFER_END) ? "BUFFER_END" : "NEW_IAUDIOTRACK");
        mSoundPool->addToStopList(this);
 } else if (event == AudioTrack::EVENT_LOOP_END) {
        ALOGV("End loop %p channel %d", this, mChannelID);
 } else {
        ALOGW("SoundChannel::process unexpected event %d", event);
 }
}

void SoundPool::notify(SoundPoolEvent event)
{
 Mutex::Autolock lock(&mCallbackLock);
 if (mCallback != NULL) {
        mCallback(event, this, mUserData);
 }
}

int SoundPool::play(int sampleID, float leftVolume, float rightVolume,
int priority, int loop, float rate)

{
ALOGV("play sampleID=%d, leftVolume=%f, rightVolume=%f, priority=%d, loop=%d, rate=%f",
sampleID, leftVolume, rightVolume, priority, loop, rate);
    sp<Sample> sample;
SoundChannel* channel;
int channelID;

Mutex::Autolock lock(&mLock);

if (mQuit) {

return 0;
}
// is sample ready?
    sample = findSample(sampleID);
if ((sample == 0) || (sample->state() != Sample::READY)) {
ALOGW("  sample %d not READY", sampleID);
return 0;
}

dump();

// allocate a channel
channel = allocateChannel_l(priority);

// no channel allocated - return 0
if (!channel) {
ALOGV("No channel allocated");
return 0;
}

channelID = ++mNextChannelID;

ALOGV("play channel %p state = %d", channel, channel->state());
channel->play(sample, channelID, leftVolume, rightVolume, priority, loop, rate);
return channelID;
}

void SoundChannel::setRate(float rate)
{
 Mutex::Autolock lock(&mLock);
 if (mAudioTrack != NULL && mSample != 0) {
 uint32_t sampleRate = uint32_t(float(mSample->sampleRate()) * rate + 0.5);
        mAudioTrack->setSampleRate(sampleRate);
        mRate = rate;
 }
}

Sample::Sample(int sampleID, int fd, int64_t offset, int64_t length)
{
    init();
    mSampleID = sampleID;
    mFd = dup(fd);
    mOffset = offset;
    mLength = length;
    ALOGV("create sampleID=%d, fd=%d, offset=%" PRId64 " length=%" PRId64,
        mSampleID, mFd, mLength, mOffset);
}

SoundChannel::~SoundChannel()
{
    ALOGV("SoundChannel destructor %p", this);
 {
 Mutex::Autolock lock(&mLock);
        clearNextEvent();
        doStop_l();
 }
    mAudioTrack.clear();
}

void SoundPool::quit()
{
    mRestartLock.lock();
    mQuit = true;
    mCondition.signal();
    mCondition.wait(mRestartLock);
    ALOGV("return from quit");
    mRestartLock.unlock();
}

void SoundChannel::play(const sp<Sample>& sample, int nextChannelID, float leftVolume,
 float rightVolume, int priority, int loop, float rate)
{
    sp<AudioTrack> oldTrack;
    sp<AudioTrack> newTrack;
 status_t status;

 { // scope for the lock
 Mutex::Autolock lock(&mLock);

        ALOGV("SoundChannel::play %p: sampleID=%d, channelID=%d, leftVolume=%f, rightVolume=%f,"
 " priority=%d, loop=%d, rate=%f",
 this, sample->sampleID(), nextChannelID, leftVolume, rightVolume,
                priority, loop, rate);

 if (mState != IDLE) {
            ALOGV("channel %d stolen - event queued for channel %d", channelID(), nextChannelID);
            mNextEvent.set(sample, nextChannelID, leftVolume, rightVolume, priority, loop, rate);
            stop_l();
 return;
 }

 size_t afFrameCount;
 uint32_t afSampleRate;
 audio_stream_type_t streamType = audio_attributes_to_stream_type(mSoundPool->attributes());
 if (AudioSystem::getOutputFrameCount(&afFrameCount, streamType) != NO_ERROR) {
            afFrameCount = kDefaultFrameCount;
 }
 if (AudioSystem::getOutputSamplingRate(&afSampleRate, streamType) != NO_ERROR) {
            afSampleRate = kDefaultSampleRate;
 }
 int numChannels = sample->numChannels();
 uint32_t sampleRate = uint32_t(float(sample->sampleRate()) * rate + 0.5);
 uint32_t totalFrames = (kDefaultBufferCount * afFrameCount * sampleRate) / afSampleRate;
 uint32_t bufferFrames = (totalFrames + (kDefaultBufferCount - 1)) / kDefaultBufferCount;
 size_t frameCount = 0;

 if (loop) {
            frameCount = sample->size()/numChannels/
 ((sample->format() == AUDIO_FORMAT_PCM_16_BIT) ? sizeof(int16_t) : sizeof(uint8_t));
 }

#ifndef USE_SHARED_MEM_BUFFER
 if(frameCount < totalFrames) {
            frameCount = totalFrames;
 }
#endif

 unsigned long toggle = mToggle ^ 1;
 void *userData = (void *)((unsigned long)this | toggle);
 audio_channel_mask_t channelMask = audio_channel_out_mask_from_count(numChannels);

#ifdef USE_SHARED_MEM_BUFFER
        newTrack = new AudioTrack(streamType, sampleRate, sample->format(),
                channelMask, sample->getIMemory(), AUDIO_OUTPUT_FLAG_FAST, callback, userData);
#else
        newTrack = new AudioTrack(streamType, sampleRate, sample->format(),
                channelMask, frameCount, AUDIO_OUTPUT_FLAG_FAST, callback, userData,
                bufferFrames);
#endif
        oldTrack = mAudioTrack;
        status = newTrack->initCheck();
 if (status != NO_ERROR) {
            ALOGE("Error creating AudioTrack");
 goto exit;
 }
        ALOGV("setVolume %p", newTrack.get());
        newTrack->setVolume(leftVolume, rightVolume);
        newTrack->setLoop(0, frameCount, loop);

        mToggle = toggle;
        mAudioTrack = newTrack;
        mPos = 0;
        mSample = sample;
        mChannelID = nextChannelID;
        mPriority = priority;
        mLoop = loop;
        mLeftVolume = leftVolume;
        mRightVolume = rightVolume;
        mNumChannels = numChannels;
        mRate = rate;
        clearNextEvent();
        mState = PLAYING;
        mAudioTrack->start();
        mAudioBufferSize = newTrack->frameCount()*newTrack->frameSize();
 }

exit:
    ALOGV("delete oldTrack %p", oldTrack.get());
 if (status != NO_ERROR) {
        mAudioTrack.clear();
 }
}

void SoundPool::done_l(SoundChannel* channel)
{
    ALOGV("done_l(%d)", channel->channelID());
 if (channel->nextChannelID() != 0) {
        ALOGV("add to restart list");
        addToRestartList(channel);
 }

 else {
        ALOGV("move to front");
        moveToFront_l(channel);
 }
}

void SoundPool::doLoad(sp<Sample>& sample)
{
    ALOGV("doLoad: loading sample sampleID=%d", sample->sampleID());
    sample->startLoad();
    mDecodeThread->loadSample(sample->sampleID());
}

void SoundChannel::nextEvent()
{
    sp<Sample> sample;
 int nextChannelID;
 float leftVolume;
 float rightVolume;
 int priority;
 int loop;
 float rate;

 {
 Mutex::Autolock lock(&mLock);
        nextChannelID = mNextEvent.channelID();
 if (nextChannelID  == 0) {
            ALOGV("stolen channel has no event");
 return;
 }

        sample = mNextEvent.sample();
        leftVolume = mNextEvent.leftVolume();
        rightVolume = mNextEvent.rightVolume();
        priority = mNextEvent.priority();
        loop = mNextEvent.loop();
        rate = mNextEvent.rate();
 }

    ALOGV("Starting stolen channel %d -> %d", channelID(), nextChannelID);
    play(sample, nextChannelID, leftVolume, rightVolume, priority, loop, rate);
}

void SoundPool::autoResume()
{
    ALOGV("autoResume()");
 Mutex::Autolock lock(&mLock);
 for (int i = 0; i < mMaxChannels; ++i) {
 SoundChannel* channel = &mChannelPool[i];
        channel->autoResume();
 }
}

void SoundPool::moveToFront_l(SoundChannel* channel)
{
 for (List<SoundChannel*>::iterator iter = mChannels.begin(); iter != mChannels.end(); ++iter) {
 if (*iter == channel) {
            mChannels.erase(iter);
            mChannels.push_front(channel);
 break;
 }
 }
}

void SoundPool::dump()
{
 for (int i = 0; i < mMaxChannels; ++i) {
        mChannelPool[i].dump();
 }
}

void SoundPool::addToRestartList(SoundChannel* channel)
{
 Mutex::Autolock lock(&mRestartLock);
 if (!mQuit) {
        mRestart.push_back(channel);
        mCondition.signal();
 }
}

void SoundPool::stop(int channelID)
{
    ALOGV("stop(%d)", channelID);
 Mutex::Autolock lock(&mLock);
 SoundChannel* channel = findChannel(channelID);
 if (channel) {
        channel->stop();
 } else {
        channel = findNextChannel(channelID);
 if (channel)
            channel->clearNextEvent();
 }
}

void SoundChannel::setLoop(int loop)
{
 Mutex::Autolock lock(&mLock);
 if (mAudioTrack != NULL && mSample != 0) {
 uint32_t loopEnd = mSample->size()/mNumChannels/
 ((mSample->format() == AUDIO_FORMAT_PCM_16_BIT) ? sizeof(int16_t) : sizeof(uint8_t));
        mAudioTrack->setLoop(0, loopEnd, loop);
        mLoop = loop;
 }
}

void SoundPool::setPriority(int channelID, int priority)
{
    ALOGV("setPriority(%d, %d)", channelID, priority);
 Mutex::Autolock lock(&mLock);
 SoundChannel* channel = findChannel(channelID);
 if (channel) {
        channel->setPriority(priority);
 }
}

int SoundPool::beginThread(void* arg)
{
 SoundPool* p = (SoundPool*)arg;
 return p->run();
}

void SoundChannel::pause()
{
 Mutex::Autolock lock(&mLock);
 if (mState == PLAYING) {
        ALOGV("pause track");
        mState = PAUSED;
        mAudioTrack->pause();
 }
}

SoundPool::~SoundPool()
{
    ALOGV("SoundPool destructor");
    mDecodeThread->quit();
    quit();

 Mutex::Autolock lock(&mLock);

    mChannels.clear();
 if (mChannelPool)
 delete [] mChannelPool;
    ALOGV("clear samples");
    mSamples.clear();

 if (mDecodeThread)
 delete mDecodeThread;
}

int SoundPool::load(const char* path, int priority __unused)
{
ALOGV("load: path=%s, priority=%d", path, priority);
    Mutex::Autolock lock(&mLock);
    sp<Sample> sample = new Sample(++mNextSampleID, path);
    mSamples.add(sample->sampleID(), sample);
    doLoad(sample);
    return sample->sampleID();
}

 SoundChannel* SoundPool::findChannel(int channelID)
 {
     for (int i = 0; i < mMaxChannels; ++i) {
 if (mChannelPool[i].channelID() == channelID) {
 return &mChannelPool[i];
 }
 }
 return NULL;
}

bool SoundChannel::doStop_l()
{
 if (mState != IDLE) {
        setVolume_l(0, 0);
        ALOGV("stop");
        mAudioTrack->stop();
        mSample.clear();
        mState = IDLE;
        mPriority = IDLE_PRIORITY;
 return true;
 }
 return false;
}

void SoundChannel::resume()
{
 Mutex::Autolock lock(&mLock);
 if (mState == PAUSED) {
        ALOGV("resume track");
        mState = PLAYING;
        mAutoPaused = false;
        mAudioTrack->start();
 }
}

status_t Sample::doLoad()
{
 uint32_t sampleRate;
 int numChannels;
 audio_format_t format;
 status_t status;
    mHeap = new MemoryHeapBase(kDefaultHeapSize);

    ALOGV("Start decode");
 if (mUrl) {
        status = MediaPlayer::decode(
                NULL /* httpService */,
                mUrl,
 &sampleRate,
 &numChannels,
 &format,
                mHeap,
 &mSize);
 } else {
        status = MediaPlayer::decode(mFd, mOffset, mLength, &sampleRate, &numChannels, &format,
                                     mHeap, &mSize);
        ALOGV("close(%d)", mFd);
 ::close(mFd);
        mFd = -1;
 }
 if (status != NO_ERROR) {
        ALOGE("Unable to load sample: %s", mUrl);
 goto error;
 }
    ALOGV("pointer = %p, size = %zu, sampleRate = %u, numChannels = %d",
          mHeap->getBase(), mSize, sampleRate, numChannels);

 if (sampleRate > kMaxSampleRate) {
       ALOGE("Sample rate (%u) out of range", sampleRate);
       status = BAD_VALUE;
 goto error;
 }

 if ((numChannels < 1) || (numChannels > 2)) {
        ALOGE("Sample channel count (%d) out of range", numChannels);
        status = BAD_VALUE;
 goto error;
 }

    mData = new MemoryBase(mHeap, 0, mSize);
    mSampleRate = sampleRate;
    mNumChannels = numChannels;
    mFormat = format;
    mState = READY;
 return NO_ERROR;

error:
    mHeap.clear();
 return status;
}

Sample::~Sample()
{
    ALOGV("Sample::destructor sampleID=%d, fd=%d", mSampleID, mFd);
 if (mFd > 0) {
        ALOGV("close(%d)", mFd);
 ::close(mFd);
 }
    free(mUrl);
}

void SoundChannel::autoResume()
{
 Mutex::Autolock lock(&mLock);
 if (mAutoPaused && (mState == PAUSED)) {
        ALOGV("resume track");
        mState = PLAYING;
        mAutoPaused = false;
        mAudioTrack->start();
 }
}

void SoundPool::setRate(int channelID, float rate)
{
    ALOGV("setRate(%d, %f)", channelID, rate);
 Mutex::Autolock lock(&mLock);
 SoundChannel* channel = findChannel(channelID);
 if (channel) {
        channel->setRate(rate);
 }
}

void SoundPool::autoPause()
{
    ALOGV("autoPause()");
 Mutex::Autolock lock(&mLock);
 for (int i = 0; i < mMaxChannels; ++i) {
 SoundChannel* channel = &mChannelPool[i];
        channel->autoPause();
 }
}

void SoundPool::pause(int channelID)
{
    ALOGV("pause(%d)", channelID);
 Mutex::Autolock lock(&mLock);
 SoundChannel* channel = findChannel(channelID);
 if (channel) {
        channel->pause();
 }
}

void SoundChannel::stop_l()
{
 if (doStop_l()) {
        mSoundPool->done_l(this);
 }
}

void SoundEvent::set(const sp<Sample>& sample, int channelID, float leftVolume,
 float rightVolume, int priority, int loop, float rate)
{
    mSample = sample;
    mChannelID = channelID;
    mLeftVolume = leftVolume;
    mRightVolume = rightVolume;
    mPriority = priority;
    mLoop = loop;
    mRate =rate;
}

void SoundPool::setLoop(int channelID, int loop)
{
    ALOGV("setLoop(%d, %d)", channelID, loop);
 Mutex::Autolock lock(&mLock);
 SoundChannel* channel = findChannel(channelID);
 if (channel) {
        channel->setLoop(loop);
 }
}
