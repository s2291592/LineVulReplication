PresentationConnection* PresentationConnection::take(
    PresentationReceiver* receiver,
    const WebPresentationSessionInfo& sessionInfo) {
  DCHECK(receiver);

  PresentationConnection* connection = new PresentationConnection(
      receiver->frame(), sessionInfo.id, sessionInfo.url);
  receiver->registerConnection(connection);

  return connection;
}

DEFINE_TRACE(PresentationConnection) {
  visitor->trace(m_blobLoader);
  visitor->trace(m_messages);
  EventTargetWithInlineData::trace(visitor);
  ContextClient::trace(visitor);
}

void PresentationConnection::didFailLoadingBlob(
    FileError::ErrorCode errorCode) {
  ASSERT(!m_messages.isEmpty() && m_messages.first()->type == MessageTypeBlob);
  m_messages.removeFirst();
  m_blobLoader.clear();
  handleMessageQueue();
}

WebPresentationClient* presentationClient(ExecutionContext* executionContext) {
  ASSERT(executionContext && executionContext->isDocument());

  Document* document = toDocument(executionContext);
  if (!document->frame())
    return nullptr;
  PresentationController* controller =
      PresentationController::from(*document->frame());
  return controller ? controller->client() : nullptr;
}

  void cancel() { m_loader->cancel(); }

  BlobLoader(PassRefPtr<BlobDataHandle> blobDataHandle,
             PresentationConnection* PresentationConnection)
      : m_PresentationConnection(PresentationConnection),
        m_loader(FileReaderLoader::create(FileReaderLoader::ReadAsArrayBuffer,
                                          this)) {
    m_loader->start(m_PresentationConnection->getExecutionContext(),
                    std::move(blobDataHandle));
  }

const AtomicString& PresentationConnection::interfaceName() const {
  return EventTargetNames::PresentationConnection;
}

void PresentationConnection::didChangeState(
    WebPresentationConnectionState state) {
  didChangeState(state, true /* shouldDispatchEvent */);
}

void PresentationConnectionProxy::SendConnectionMessage(
    PresentationConnectionMessage message,
    const OnMessageCallback& callback) const {
  DCHECK(target_connection_ptr_);
  target_connection_ptr_->OnMessage(std::move(message), callback);
}

ExecutionContext* PresentationConnection::getExecutionContext() const {
  if (!frame())
    return nullptr;
  return frame()->document();
}

PresentationConnection::~PresentationConnection() {
  ASSERT(!m_blobLoader);
}

blink::mojom::PresentationConnectionPtr ControllerConnectionProxy::Bind() {
  return binding_.CreateInterfacePtrAndBind();
}

void PresentationConnectionProxy::OnMessage(
    PresentationConnectionMessage message,
    const OnMessageCallback& callback) {
  DCHECK(!callback.is_null());

  if (message.is_binary()) {
    source_connection_->didReceiveBinaryMessage(&(message.data->front()),
                                                message.data->size());
  } else {
    source_connection_->didReceiveTextMessage(
        blink::WebString::fromUTF8(*(message.message)));
  }

  callback.Run(true);
}

 void PresentationConnection::didFinishLoadingBlob(DOMArrayBuffer* buffer) {
   ASSERT(!m_messages.isEmpty() && m_messages.first()->type == MessageTypeBlob);
   ASSERT(buffer && buffer->buffer());
  WebPresentationClient* client = presentationClient(getExecutionContext());
  if (client) {
    client->sendBlobData(m_url, m_id,
                         static_cast<const uint8_t*>(buffer->data()),
                         buffer->byteLength(), m_proxy.get());
  }

  m_messages.removeFirst();
  m_blobLoader.clear();
  handleMessageQueue();
}

void PresentationConnection::dispatchStateChangeEvent(Event* event) {
  TaskRunnerHelper::get(TaskType::Presentation, getExecutionContext())
      ->postTask(BLINK_FROM_HERE,
                 WTF::bind(&PresentationConnection::dispatchEventAsync,
                           wrapPersistent(this), wrapPersistent(event)));
}

void throwPresentationDisconnectedError(ExceptionState& exceptionState) {
  exceptionState.throwDOMException(InvalidStateError,
                                   "Presentation connection is disconnected.");
}

void ReceiverConnectionProxy::BindControllerConnection(
    blink::mojom::PresentationConnectionPtr controller_connection_ptr) {
  DCHECK(!target_connection_ptr_);
  target_connection_ptr_ = std::move(controller_connection_ptr);
  target_connection_ptr_->DidChangeState(
      content::PRESENTATION_CONNECTION_STATE_CONNECTED);

  DidChangeState(content::PRESENTATION_CONNECTION_STATE_CONNECTED);
}

void PresentationConnection::handleMessageQueue() {
  WebPresentationClient* client = presentationClient(getExecutionContext());
  if (!client || !m_proxy)
    return;

  while (!m_messages.isEmpty() && !m_blobLoader) {
    Message* message = m_messages.first().get();
    switch (message->type) {
      case MessageTypeText:
        client->sendString(m_url, m_id, message->text, m_proxy.get());
        m_messages.removeFirst();
        break;
      case MessageTypeArrayBuffer:
        client->sendArrayBuffer(
            m_url, m_id,
            static_cast<const uint8_t*>(message->arrayBuffer->data()),
            message->arrayBuffer->byteLength(), m_proxy.get());
        m_messages.removeFirst();
        break;
      case MessageTypeBlob:
        ASSERT(!m_blobLoader);
        m_blobLoader = new BlobLoader(message->blobDataHandle, this);
        break;
    }
  }
}

PresentationConnection* PresentationConnection::take(
    ScriptPromiseResolver* resolver,
    const WebPresentationSessionInfo& sessionInfo,
    PresentationRequest* request) {
  ASSERT(resolver);
  ASSERT(request);
  ASSERT(resolver->getExecutionContext()->isDocument());

  Document* document = toDocument(resolver->getExecutionContext());
  if (!document->frame())
    return nullptr;

  PresentationController* controller =
      PresentationController::from(*document->frame());
  if (!controller)
    return nullptr;

  return take(controller, sessionInfo, request);
}

void PresentationConnection::close() {
  if (m_state != WebPresentationConnectionState::Connecting &&
      m_state != WebPresentationConnectionState::Connected) {
    return;
  }
  WebPresentationClient* client = presentationClient(getExecutionContext());
  if (client)
    client->closeSession(m_url, m_id, m_proxy.get());

  tearDown();
}

void PresentationConnectionProxy::OnClose() {
DCHECK(target_connection_ptr_);
  source_connection_->didChangeState(
      blink::WebPresentationConnectionState::Closed);
target_connection_ptr_->DidChangeState(
content::PRESENTATION_CONNECTION_STATE_CLOSED);
}

PresentationConnection::PresentationConnection(LocalFrame* frame,
                                               const String& id,
                                               const KURL& url)
    : ContextClient(frame),
      m_id(id),
      m_url(url),
      m_state(WebPresentationConnectionState::Connecting),
      m_binaryType(BinaryTypeBlob),
      m_proxy(nullptr) {}

const AtomicString& connectionCloseReasonToString(
    WebPresentationConnectionCloseReason reason) {
  DEFINE_STATIC_LOCAL(const AtomicString, errorValue, ("error"));
  DEFINE_STATIC_LOCAL(const AtomicString, closedValue, ("closed"));
  DEFINE_STATIC_LOCAL(const AtomicString, wentAwayValue, ("wentaway"));

  switch (reason) {
    case WebPresentationConnectionCloseReason::Error:
      return errorValue;
    case WebPresentationConnectionCloseReason::Closed:
      return closedValue;
    case WebPresentationConnectionCloseReason::WentAway:
      return wentAwayValue;
  }

  ASSERT_NOT_REACHED();
  return errorValue;
}

bool PresentationConnection::canSendMessage(ExceptionState& exceptionState) {
  if (m_state != WebPresentationConnectionState::Connected) {
    throwPresentationDisconnectedError(exceptionState);
    return false;
  }

  return !!presentationClient(getExecutionContext());
}

void PresentationConnection::didChangeState(
    WebPresentationConnectionState state,
    bool shouldDispatchEvent) {
  if (m_state == state)
    return;

  m_state = state;

  if (!shouldDispatchEvent)
    return;

  switch (m_state) {
    case WebPresentationConnectionState::Connecting:
      NOTREACHED();
      return;
    case WebPresentationConnectionState::Connected:
      dispatchStateChangeEvent(Event::create(EventTypeNames::connect));
      return;
    case WebPresentationConnectionState::Terminated:
      dispatchStateChangeEvent(Event::create(EventTypeNames::terminate));
      return;
    case WebPresentationConnectionState::Closed:
      NOTREACHED();
      return;
  }
  NOTREACHED();
}

void ReceiverConnectionProxy::Bind(
    blink::mojom::PresentationConnectionRequest receiver_connection_request) {
  binding_.Bind(std::move(receiver_connection_request));
}

void PresentationConnection::send(const String& message,
                                  ExceptionState& exceptionState) {
  if (!canSendMessage(exceptionState))
    return;

  m_messages.append(new Message(message));
  handleMessageQueue();
}

  Message(PassRefPtr<BlobDataHandle> blobDataHandle)
      : type(MessageTypeBlob), blobDataHandle(blobDataHandle) {}

void PresentationConnection::bindProxy(
    std::unique_ptr<WebPresentationConnectionProxy> proxy) {
  DCHECK(proxy);
  m_proxy = std::move(proxy);
}

void PresentationConnection::didReceiveBinaryMessage(const uint8_t* data,
                                                     size_t length) {
  if (m_state != WebPresentationConnectionState::Connected)
    return;

  switch (m_binaryType) {
    case BinaryTypeBlob: {
      std::unique_ptr<BlobData> blobData = BlobData::create();
      blobData->appendBytes(data, length);
      Blob* blob =
          Blob::create(BlobDataHandle::create(std::move(blobData), length));
      dispatchEvent(MessageEvent::create(blob));
      return;
    }
    case BinaryTypeArrayBuffer:
      DOMArrayBuffer* buffer = DOMArrayBuffer::create(data, length);
      dispatchEvent(MessageEvent::create(buffer));
      return;
  }
  ASSERT_NOT_REACHED();
}

PresentationConnection* PresentationConnection::take(
    PresentationController* controller,
    const WebPresentationSessionInfo& sessionInfo,
    PresentationRequest* request) {
  ASSERT(controller);
  ASSERT(request);

  PresentationConnection* connection = new PresentationConnection(
      controller->frame(), sessionInfo.id, sessionInfo.url);
  controller->registerConnection(connection);

  auto* event = PresentationConnectionAvailableEvent::create(
      EventTypeNames::connectionavailable, connection);
  TaskRunnerHelper::get(TaskType::Presentation, request->getExecutionContext())
      ->postTask(BLINK_FROM_HERE,
                 WTF::bind(&PresentationConnection::dispatchEventAsync,
                           wrapPersistent(request), wrapPersistent(event)));

  return connection;
}

void PresentationConnection::setBinaryType(const String& binaryType) {
  if (binaryType == "blob") {
    m_binaryType = BinaryTypeBlob;
    return;
  }
  if (binaryType == "arraybuffer") {
    m_binaryType = BinaryTypeArrayBuffer;
    return;
  }
  ASSERT_NOT_REACHED();
}

void PresentationConnectionProxy::DidChangeState(
content::PresentationConnectionState state) {
if (state == content::PRESENTATION_CONNECTION_STATE_CONNECTED) {
source_connection_->didChangeState(
blink::WebPresentationConnectionState::Connected);
} else if (state == content::PRESENTATION_CONNECTION_STATE_CLOSED) {
    source_connection_->didChangeState(
        blink::WebPresentationConnectionState::Closed);
} else {
NOTREACHED();
}
}

ReceiverConnectionProxy::ReceiverConnectionProxy(
    blink::WebPresentationConnection* receiver_connection)
    : PresentationConnectionProxy(receiver_connection) {}

  Message(DOMArrayBuffer* arrayBuffer)
      : type(MessageTypeArrayBuffer), arrayBuffer(arrayBuffer) {}

WebPresentationConnectionState PresentationConnection::getState() {
  return m_state;
}

void PresentationConnection::send(DOMArrayBuffer* arrayBuffer,
                                  ExceptionState& exceptionState) {
  ASSERT(arrayBuffer && arrayBuffer->buffer());
  if (!canSendMessage(exceptionState))
    return;

  m_messages.append(new Message(arrayBuffer));
  handleMessageQueue();
}

PresentationConnectionProxy::PresentationConnectionProxy(
    blink::WebPresentationConnection* source_connection)
    : binding_(this),
      target_connection_ptr_(nullptr),
      source_connection_(source_connection) {
  DCHECK(source_connection_);
}

void PresentationConnection::didReceiveTextMessage(const WebString& message) {
  if (m_state != WebPresentationConnectionState::Connected)
    return;

  dispatchEvent(MessageEvent::create(message));
}

void PresentationConnection::dispatchEventAsync(EventTarget* target,
                                                Event* event) {
  DCHECK(target);
  DCHECK(event);
  target->dispatchEvent(event);
}

void PresentationConnection::send(DOMArrayBufferView* arrayBufferView,
                                  ExceptionState& exceptionState) {
  ASSERT(arrayBufferView);
  if (!canSendMessage(exceptionState))
    return;

  m_messages.append(new Message(arrayBufferView->buffer()));
  handleMessageQueue();
}

void PresentationConnectionProxy::close() const {
  DCHECK(target_connection_ptr_);
  target_connection_ptr_->OnClose();
}
