static unsigned long mmap_legacy_base(unsigned long rnd)
{
	if (mmap_is_ia32())
		return TASK_UNMAPPED_BASE;
	else
		return TASK_UNMAPPED_BASE + rnd;
}

const char *arch_vma_name(struct vm_area_struct *vma)
{
	if (vma->vm_flags & VM_MPX)
		return "[mpx]";
	return NULL;
}

static unsigned long stack_maxrandom_size(void)
{
	unsigned long max = 0;
	if ((current->flags & PF_RANDOMIZE) &&
		!(current->personality & ADDR_NO_RANDOMIZE)) {
		max = ((-1UL) & STACK_RND_MASK) << PAGE_SHIFT;
	}

	return max;
}

static unsigned long mmap_base(unsigned long rnd)
{
	unsigned long gap = rlimit(RLIMIT_STACK);

	if (gap < MIN_GAP)
		gap = MIN_GAP;
	else if (gap > MAX_GAP)
		gap = MAX_GAP;

 	return PAGE_ALIGN(TASK_SIZE - gap - rnd);
 }

unsigned long arch_mmap_rnd(void)
{
	unsigned long rnd;

	if (mmap_is_ia32())
#ifdef CONFIG_COMPAT
		rnd = (unsigned long)get_random_int() & ((1 << mmap_rnd_compat_bits) - 1);
#else
		rnd = (unsigned long)get_random_int() & ((1 << mmap_rnd_bits) - 1);
#endif
	else
		rnd = (unsigned long)get_random_int() & ((1 << mmap_rnd_bits) - 1);

	return rnd << PAGE_SHIFT;
}
