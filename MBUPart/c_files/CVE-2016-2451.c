status_t OMX::sendCommand(
        node_id node, OMX_COMMANDTYPE cmd, OMX_S32 param) {
 return findInstance(node)->sendCommand(cmd, param);
}

status_t OMX::storeMetaDataInBuffers(
        node_id node, OMX_U32 port_index, OMX_BOOL enable, MetadataBufferType *type) {
 return findInstance(node)->storeMetaDataInBuffers(port_index, enable, type);
}

status_t OMX::emptyBuffer(
        node_id node,
        buffer_id buffer,
        OMX_U32 range_offset, OMX_U32 range_length,
        OMX_U32 flags, OMX_TICKS timestamp, int fenceFd) {
 return findInstance(node)->emptyBuffer(
            buffer, range_offset, range_length, flags, timestamp, fenceFd);
}

bool OMX::isSecure(node_id node) {
 OMXNodeInstance *instance = findInstance(node);
 return (instance == NULL ? false : instance->isSecure());
}

status_t OMX::createInputSurface(
        node_id node, OMX_U32 port_index,
        sp<IGraphicBufferProducer> *bufferProducer, MetadataBufferType *type) {
 return findInstance(node)->createInputSurface(
            port_index, bufferProducer, type);
}

status_t OMX::setConfig(
        node_id node, OMX_INDEXTYPE index,
 const void *params, size_t size) {
 return findInstance(node)->setConfig(
            index, params, size);
}

bool OMX::CallbackDispatcher::loop() {
 for (;;) {
        std::list<omx_message> messages;

 {
 Mutex::Autolock autoLock(mLock);
 while (!mDone && mQueue.empty()) {
                mQueueChanged.wait(mLock);
 }

 if (mDone) {
 break;
 }

            messages.swap(mQueue);
 }

        dispatch(messages);
 }

 return false;
}

status_t OMX::freeNode(node_id node) {
 OMXNodeInstance *instance = findInstance(node);

 {
 Mutex::Autolock autoLock(mLock);
 ssize_t index = mLiveNodes.indexOfKey(IInterface::asBinder(instance->observer()));
 if (index < 0) {
 return OK;
 }
        mLiveNodes.removeItemsAt(index);
 }

 IInterface::asBinder(instance->observer())->unlinkToDeath(this);

 status_t err = instance->freeNode(mMaster);

 {
 Mutex::Autolock autoLock(mLock);
 ssize_t index = mDispatchers.indexOfKey(node);
        CHECK(index >= 0);
        mDispatchers.removeItemsAt(index);
 }

 return err;
}

OMX_ERRORTYPE OMX::OnEvent(
        node_id node,
        OMX_IN OMX_EVENTTYPE eEvent,
        OMX_IN OMX_U32 nData1,
        OMX_IN OMX_U32 nData2,
        OMX_IN OMX_PTR pEventData) {
    ALOGV("OnEvent(%d, %" PRIu32", %" PRIu32 ")", eEvent, nData1, nData2);

    findInstance(node)->onEvent(eEvent, nData1, nData2);

    sp<OMX::CallbackDispatcher> dispatcher = findDispatcher(node);

 if (eEvent == OMX_EventOutputRendered) {
 if (pEventData == NULL) {
 return OMX_ErrorBadParameter;
 }

        OMX_VIDEO_RENDEREVENTTYPE *renderData = (OMX_VIDEO_RENDEREVENTTYPE *)pEventData;
 for (size_t i = 0; i < nData1; ++i) {
            omx_message msg;
            msg.type = omx_message::FRAME_RENDERED;
            msg.node = node;
            msg.fenceFd = -1;
            msg.u.render_data.timestamp = renderData[i].nMediaTimeUs;
            msg.u.render_data.nanoTime = renderData[i].nSystemTimeNs;

            dispatcher->post(msg, false /* realTime */);
 }
 return OMX_ErrorNone;
 }

    omx_message msg;
    msg.type = omx_message::EVENT;
    msg.node = node;
    msg.fenceFd = -1;
    msg.u.event_data.event = eEvent;
    msg.u.event_data.data1 = nData1;
    msg.u.event_data.data2 = nData2;

    dispatcher->post(msg, true /* realTime */);

 return OMX_ErrorNone;
}

status_t OMX::enableGraphicBuffers(
        node_id node, OMX_U32 port_index, OMX_BOOL enable) {
 return findInstance(node)->enableGraphicBuffers(port_index, enable);
}

status_t OMX::allocateBuffer(
        node_id node, OMX_U32 port_index, size_t size,
        buffer_id *buffer, void **buffer_data) {
 return findInstance(node)->allocateBuffer(
            port_index, size, buffer, buffer_data);
}

bool OMX::CallbackDispatcherThread::threadLoop() {
 return mDispatcher->loop();
}

status_t OMX::freeBuffer(node_id node, OMX_U32 port_index, buffer_id buffer) {
 return findInstance(node)->freeBuffer(
            port_index, buffer);
}

status_t OMX::configureVideoTunnelMode(
        node_id node, OMX_U32 portIndex, OMX_BOOL tunneled,
        OMX_U32 audioHwSync, native_handle_t **sidebandHandle) {
 return findInstance(node)->configureVideoTunnelMode(
            portIndex, tunneled, audioHwSync, sidebandHandle);
}

void SoftVPX::onQueueFilled(OMX_U32 /* portIndex */) {
 if (mOutputPortSettingsChange != NONE || mEOSStatus == OUTPUT_FRAMES_FLUSHED) {
 return;
 }

 List<BufferInfo *> &inQueue = getPortQueue(0);
 List<BufferInfo *> &outQueue = getPortQueue(1);
 bool EOSseen = false;
 vpx_codec_err_t err;
 bool portWillReset = false;

 while ((mEOSStatus == INPUT_EOS_SEEN || !inQueue.empty())
 && !outQueue.empty()) {
 if (mEOSStatus == INPUT_EOS_SEEN || mImg != NULL) {
 if (!outputBuffers(
                     mEOSStatus == INPUT_EOS_SEEN, true /* display */,
                     mEOSStatus == INPUT_EOS_SEEN, &portWillReset)) {
                ALOGE("on2 decoder failed to output frame.");
                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
 return;
 }
 if (portWillReset || mEOSStatus == OUTPUT_FRAMES_FLUSHED ||
                    mEOSStatus == INPUT_EOS_SEEN) {
 return;
 }
 }

 BufferInfo *inInfo = *inQueue.begin();
        OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;
        mTimeStamps[mTimeStampIdx] = inHeader->nTimeStamp;

 BufferInfo *outInfo = *outQueue.begin();
        OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;
 if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
            mEOSStatus = INPUT_EOS_SEEN;
 EOSseen = true;
 }

 if (inHeader->nFilledLen > 0 &&
            vpx_codec_decode((vpx_codec_ctx_t *)mCtx,
                              inHeader->pBuffer + inHeader->nOffset,
                              inHeader->nFilledLen,
 &mTimeStamps[mTimeStampIdx], 0)) {
            ALOGE("on2 decoder failed to decode frame.");
            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
 return;
 }
        mTimeStampIdx = (mTimeStampIdx + 1) % kNumBuffers;

 if (!outputBuffers(
 EOSseen /* flushDecoder */, true /* display */, EOSseen, &portWillReset)) {
            ALOGE("on2 decoder failed to output frame.");
            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
 return;
 }
 if (portWillReset) {
 return;
 }

        inInfo->mOwnedByUs = false;
        inQueue.erase(inQueue.begin());
        inInfo = NULL;
        notifyEmptyBufferDone(inHeader);
        inHeader = NULL;
 }
}

status_t OMX::setParameter(
        node_id node, OMX_INDEXTYPE index,
 const void *params, size_t size) {
    ALOGV("setParameter(%u %#x %p %zd)", node, index, params, size);
 return findInstance(node)->setParameter(
            index, params, size);
}

status_t OMX::getConfig(
        node_id node, OMX_INDEXTYPE index,
 void *params, size_t size) {
 return findInstance(node)->getConfig(
            index, params, size);
}

OMX_ERRORTYPE OMX::OnEmptyBufferDone(
        node_id node, buffer_id buffer, OMX_IN OMX_BUFFERHEADERTYPE *pBuffer, int fenceFd) {
    ALOGV("OnEmptyBufferDone buffer=%p", pBuffer);

    omx_message msg;
    msg.type = omx_message::EMPTY_BUFFER_DONE;
    msg.node = node;
    msg.fenceFd = fenceFd;
    msg.u.buffer_data.buffer = buffer;

    findDispatcher(node)->post(msg);

 return OMX_ErrorNone;
}

status_t OMX::prepareForAdaptivePlayback(
        node_id node, OMX_U32 portIndex, OMX_BOOL enable,
        OMX_U32 maxFrameWidth, OMX_U32 maxFrameHeight) {
 return findInstance(node)->prepareForAdaptivePlayback(
            portIndex, enable, maxFrameWidth, maxFrameHeight);
}

status_t OMX::allocateNode(
 const char *name, const sp<IOMXObserver> &observer, node_id *node) {
 Mutex::Autolock autoLock(mLock);

 *node = 0;

 OMXNodeInstance *instance = new OMXNodeInstance(this, observer, name);

    OMX_COMPONENTTYPE *handle;
    OMX_ERRORTYPE err = mMaster->makeComponentInstance(
            name, &OMXNodeInstance::kCallbacks,
            instance, &handle);

 if (err != OMX_ErrorNone) {
        ALOGE("FAILED to allocate omx component '%s' err=%s(%#x)", name, asString(err), err);

        instance->onGetHandleFailed();

 return StatusFromOMXError(err);
 }

 *node = makeNodeID(instance);
    mDispatchers.add(*node, new CallbackDispatcher(instance));

    instance->setHandle(*node, handle);

    mLiveNodes.add(IInterface::asBinder(observer), instance);
 IInterface::asBinder(observer)->linkToDeath(this);

 return OK;
}

void OMX::invalidateNodeID_l(node_id node) {
    mNodeIDToInstance.removeItem(node);
}

status_t OMX::useGraphicBuffer(
        node_id node, OMX_U32 port_index,
 const sp<GraphicBuffer> &graphicBuffer, buffer_id *buffer) {
 return findInstance(node)->useGraphicBuffer(
            port_index, graphicBuffer, buffer);
}

status_t OMX::setInternalOption(
        node_id node,
        OMX_U32 port_index,
 InternalOptionType type,
 const void *data,
 size_t size) {
 return findInstance(node)->setInternalOption(port_index, type, data, size);
}

OMX::node_id OMX::makeNodeID(OMXNodeInstance *instance) {

    node_id node = (node_id)++mNodeCounter;
    mNodeIDToInstance.add(node, instance);

 return node;
}

OMXNodeInstance *OMX::findInstance(node_id node) {
 Mutex::Autolock autoLock(mLock);

 ssize_t index = mNodeIDToInstance.indexOfKey(node);

 return index < 0 ? NULL : mNodeIDToInstance.valueAt(index);
}

void OMX::CallbackDispatcher::post(const omx_message &msg, bool realTime) {
 Mutex::Autolock autoLock(mLock);

    mQueue.push_back(msg);
 if (realTime) {
        mQueueChanged.signal();
 }
}

status_t OMX::setInputSurface(
        node_id node, OMX_U32 port_index,
 const sp<IGraphicBufferConsumer> &bufferConsumer, MetadataBufferType *type) {
 return findInstance(node)->setInputSurface(port_index, bufferConsumer, type);
}

OMX_ERRORTYPE OMX::OnFillBufferDone(
        node_id node, buffer_id buffer, OMX_IN OMX_BUFFERHEADERTYPE *pBuffer, int fenceFd) {
    ALOGV("OnFillBufferDone buffer=%p", pBuffer);

    omx_message msg;
    msg.type = omx_message::FILL_BUFFER_DONE;
    msg.node = node;
    msg.fenceFd = fenceFd;
    msg.u.extended_buffer_data.buffer = buffer;
    msg.u.extended_buffer_data.range_offset = pBuffer->nOffset;
    msg.u.extended_buffer_data.range_length = pBuffer->nFilledLen;
    msg.u.extended_buffer_data.flags = pBuffer->nFlags;
    msg.u.extended_buffer_data.timestamp = pBuffer->nTimeStamp;

    findDispatcher(node)->post(msg);

 return OMX_ErrorNone;
}

bool SoftVPX::outputBuffers(bool flushDecoder, bool display, bool eos, bool *portWillReset) {
List<BufferInfo *> &inQueue = getPortQueue(0);
List<BufferInfo *> &outQueue = getPortQueue(1);
BufferInfo *outInfo = NULL;
OMX_BUFFERHEADERTYPE *outHeader = NULL;
vpx_codec_iter_t iter = NULL;

if (flushDecoder && mFrameParallelMode) {
// Flush decoder by passing NULL data ptr and 0 size.
// Ideally, this should never fail.
if (vpx_codec_decode((vpx_codec_ctx_t *)mCtx, NULL, 0, NULL, 0)) {
ALOGE("Failed to flush on2 decoder.");
return false;
}
}

if (!display) {
if (!flushDecoder) {
ALOGE("Invalid operation.");
return false;
}
// Drop all the decoded frames in decoder.
while ((mImg = vpx_codec_get_frame((vpx_codec_ctx_t *)mCtx, &iter))) {
}
return true;
}

while (!outQueue.empty()) {
if (mImg == NULL) {
mImg = vpx_codec_get_frame((vpx_codec_ctx_t *)mCtx, &iter);
if (mImg == NULL) {
break;
}
}
uint32_t width = mImg->d_w;
uint32_t height = mImg->d_h;
outInfo = *outQueue.begin();
outHeader = outInfo->mHeader;
CHECK_EQ(mImg->fmt, VPX_IMG_FMT_I420);
handlePortSettingsChange(portWillReset, width, height);
if (*portWillReset) {
return true;
}

outHeader->nOffset = 0;

outHeader->nFlags = 0;
outHeader->nFilledLen = (outputBufferWidth() * outputBufferHeight() * 3) / 2;
outHeader->nTimeStamp = *(OMX_TICKS *)mImg->user_priv;
        uint8_t *dst = outHeader->pBuffer;
        const uint8_t *srcY = (const uint8_t *)mImg->planes[VPX_PLANE_Y];
        const uint8_t *srcU = (const uint8_t *)mImg->planes[VPX_PLANE_U];
        const uint8_t *srcV = (const uint8_t *)mImg->planes[VPX_PLANE_V];
        size_t srcYStride = mImg->stride[VPX_PLANE_Y];
        size_t srcUStride = mImg->stride[VPX_PLANE_U];
        size_t srcVStride = mImg->stride[VPX_PLANE_V];
        copyYV12FrameToOutputBuffer(dst, srcY, srcU, srcV, srcYStride, srcUStride, srcVStride);

mImg = NULL;
outInfo->mOwnedByUs = false;
outQueue.erase(outQueue.begin());
outInfo = NULL;
notifyFillBufferDone(outHeader);
outHeader = NULL;
}

if (!eos) {
return true;
}

if (!outQueue.empty()) {
outInfo = *outQueue.begin();
outQueue.erase(outQueue.begin());
outHeader = outInfo->mHeader;
outHeader->nTimeStamp = 0;
outHeader->nFilledLen = 0;
outHeader->nFlags = OMX_BUFFERFLAG_EOS;
outInfo->mOwnedByUs = false;
notifyFillBufferDone(outHeader);
mEOSStatus = OUTPUT_FRAMES_FLUSHED;
}
return true;
}

bool OMX::livesLocally(node_id /* node */, pid_t pid) {
 return pid == getpid();
}

status_t OMX::getParameter(
        node_id node, OMX_INDEXTYPE index,
 void *params, size_t size) {
    ALOGV("getParameter(%u %#x %p %zd)", node, index, params, size);
 return findInstance(node)->getParameter(
            index, params, size);
}

OMX::CallbackDispatcher::~CallbackDispatcher() {
 {
 Mutex::Autolock autoLock(mLock);

        mDone = true;
        mQueueChanged.signal();
 }

 status_t status = mThread->join();
 if (status != WOULD_BLOCK) {
        CHECK_EQ(status, (status_t)NO_ERROR);
 }
}

status_t OMX::fillBuffer(node_id node, buffer_id buffer, int fenceFd) {
 return findInstance(node)->fillBuffer(buffer, fenceFd);
}

status_t OMX::useBuffer(
        node_id node, OMX_U32 port_index, const sp<IMemory> &params,
        buffer_id *buffer, OMX_U32 allottedSize) {
 return findInstance(node)->useBuffer(
            port_index, params, buffer, allottedSize);
}

OMX::~OMX() {
 delete mMaster;
    mMaster = NULL;
}

OMX::CallbackDispatcher::CallbackDispatcher(OMXNodeInstance *owner)
 : mOwner(owner),
      mDone(false) {
    mThread = new CallbackDispatcherThread(this);
    mThread->run("OMXCallbackDisp", ANDROID_PRIORITY_FOREGROUND);
}

void OMX::binderDied(const wp<IBinder> &the_late_who) {
OMXNodeInstance *instance;

{

Mutex::Autolock autoLock(mLock);

ssize_t index = mLiveNodes.indexOfKey(the_late_who);
        CHECK(index >= 0);

instance = mLiveNodes.editValueAt(index);
mLiveNodes.removeItemsAt(index);

index = mDispatchers.indexOfKey(instance->nodeID());
CHECK(index >= 0);
mDispatchers.removeItemsAt(index);

invalidateNodeID_l(instance->nodeID());
}

instance->onObserverDied(mMaster);
}

status_t OMX::getExtensionIndex(
        node_id node,
 const char *parameter_name,
        OMX_INDEXTYPE *index) {
 return findInstance(node)->getExtensionIndex(
            parameter_name, index);
}

status_t OMX::createPersistentInputSurface(
        sp<IGraphicBufferProducer> *bufferProducer,
        sp<IGraphicBufferConsumer> *bufferConsumer) {
 return OMXNodeInstance::createPersistentInputSurface(
            bufferProducer, bufferConsumer);
}

 CallbackDispatcherThread(CallbackDispatcher *dispatcher)
 : mDispatcher(dispatcher) {
 }
