seconds_count_format_time_units (int seconds)
{
    int minutes;
    int hours;

    if (seconds < 0)
    {
        /* Just to make sure... */
        seconds = 0;
    }

    if (seconds < 60)
    {
        /* seconds */
        return seconds;
    }

    if (seconds < 60 * 60)
    {
        /* minutes */
        minutes = seconds / 60;
        return minutes;
    }

    hours = seconds / (60 * 60);

    if (seconds < 60 * 60 * 4)
    {
        /* minutes + hours */
        minutes = (seconds - hours * 60 * 60) / 60;
        return minutes + hours;
    }

    return hours;
}

activate_files (ActivateParameters *parameters)
{
    NautilusFile *file;
    NautilusWindow *window;
    NautilusWindowOpenFlags flags;
    g_autoptr (GList) open_in_app_parameters = NULL;
    g_autoptr (GList) unhandled_open_in_app_uris = NULL;
    ApplicationLaunchParameters *one_parameters;
    int count;
    g_autofree char *old_working_dir = NULL;
    GdkScreen *screen;
    gint num_apps;
    gint num_unhandled;
    gint num_files;
    gboolean open_files;
    gboolean closed_window;
    g_autoptr (GQueue) launch_desktop_files = NULL;
    g_autoptr (GQueue) launch_files = NULL;
    g_autoptr (GQueue) launch_in_terminal_files = NULL;
    g_autoptr (GQueue) open_in_app_uris = NULL;
    g_autoptr (GQueue) open_in_view_files = NULL;
    GList *l;
    ActivationAction action;
    LaunchLocation *location;

    launch_desktop_files = g_queue_new ();
    launch_files = g_queue_new ();
    launch_in_terminal_files = g_queue_new ();
    open_in_view_files = g_queue_new ();
    open_in_app_uris = g_queue_new ();

    for (l = parameters->locations; l != NULL; l = l->next)
    {
        location = l->data;
        file = location->file;

        if (file_was_cancelled (file))
        {
            continue;
        }

        action = get_activation_action (file);
        if (action == ACTIVATION_ACTION_ASK)
        {
            /* Special case for executable text files, since it might be
             * dangerous & unexpected to launch these.
             */
            pause_activation_timed_cancel (parameters);
            action = get_executable_text_file_action (parameters->parent_window, file);
            unpause_activation_timed_cancel (parameters);
        }

        switch (action)
        {
            case ACTIVATION_ACTION_LAUNCH_DESKTOP_FILE:
            {
                g_queue_push_tail (launch_desktop_files, file);
            }
            break;

            case ACTIVATION_ACTION_LAUNCH:
            {
                g_queue_push_tail (launch_files, file);
            }
            break;

            case ACTIVATION_ACTION_LAUNCH_IN_TERMINAL:
            {
                g_queue_push_tail (launch_in_terminal_files, file);
            }
            break;

            case ACTIVATION_ACTION_OPEN_IN_VIEW:
            {
                g_queue_push_tail (open_in_view_files, file);
            }
            break;

            case ACTIVATION_ACTION_OPEN_IN_APPLICATION:
            {
                g_queue_push_tail (open_in_app_uris, location->uri);
            }
            break;

            case ACTIVATION_ACTION_DO_NOTHING:
            {
            }
            break;

            case ACTIVATION_ACTION_EXTRACT:
            {
                /* Extraction of files should be handled in the view */
                g_assert_not_reached ();
            }
            break;

            case ACTIVATION_ACTION_ASK:
            {
                g_assert_not_reached ();
            }
            break;
        }
    }

    for (l = g_queue_peek_head_link (launch_desktop_files); l != NULL; l = l->next)
    {
        file = NAUTILUS_FILE (l->data);

        activate_desktop_file (parameters, file);
    }

    if (parameters->activation_directory &&
        (!g_queue_is_empty (launch_files) ||
         !g_queue_is_empty (launch_in_terminal_files)))
    {
        old_working_dir = g_get_current_dir ();
        g_chdir (parameters->activation_directory);
    }

    screen = gtk_widget_get_screen (GTK_WIDGET (parameters->parent_window));
    for (l = g_queue_peek_head_link (launch_files); l != NULL; l = l->next)
    {
        g_autofree char *uri = NULL;
        g_autofree char *executable_path = NULL;
        g_autofree char *quoted_path = NULL;

        file = NAUTILUS_FILE (l->data);

        uri = nautilus_file_get_activation_uri (file);
        executable_path = g_filename_from_uri (uri, NULL, NULL);
        quoted_path = g_shell_quote (executable_path);

        DEBUG ("Launching file path %s", quoted_path);

        nautilus_launch_application_from_command (screen, quoted_path, FALSE, NULL);
    }

    for (l = g_queue_peek_head_link (launch_in_terminal_files); l != NULL; l = l->next)
    {
        g_autofree char *uri = NULL;
        g_autofree char *executable_path = NULL;
        g_autofree char *quoted_path = NULL;

        file = NAUTILUS_FILE (l->data);

        uri = nautilus_file_get_activation_uri (file);
        executable_path = g_filename_from_uri (uri, NULL, NULL);
        quoted_path = g_shell_quote (executable_path);

        DEBUG ("Launching in terminal file quoted path %s", quoted_path);

        nautilus_launch_application_from_command (screen, quoted_path, TRUE, NULL);
    }

    if (old_working_dir != NULL)
    {
        g_chdir (old_working_dir);
    }

    count = g_queue_get_length (open_in_view_files);

    flags = parameters->flags;
    if (count > 1)
    {
        if ((parameters->flags & NAUTILUS_WINDOW_OPEN_FLAG_NEW_WINDOW) == 0)
        {
            /* if CLOSE_BEHIND is set and we have a directory to be activated, we
             * will first have to open a new window and after that we can open the
             * rest of files in tabs */
            if ((parameters->flags & NAUTILUS_WINDOW_OPEN_FLAG_CLOSE_BEHIND) != 0)
            {
                flags |= NAUTILUS_WINDOW_OPEN_FLAG_NEW_WINDOW;
            }
            else
            {
                flags |= NAUTILUS_WINDOW_OPEN_FLAG_NEW_TAB;
            }
        }
        else
        {
            flags |= NAUTILUS_WINDOW_OPEN_FLAG_NEW_WINDOW;
        }
    }
    else
    {
        /* if we want to close the window and activate a single directory, then we will need
         * the NEW_WINDOW flag set */
        if ((parameters->flags & NAUTILUS_WINDOW_OPEN_FLAG_CLOSE_BEHIND) != 0)
        {
            flags |= NAUTILUS_WINDOW_OPEN_FLAG_NEW_WINDOW;
        }
    }

    if (parameters->slot != NULL &&
        (!parameters->user_confirmation ||
         confirm_multiple_windows (parameters->parent_window, count,
                                   (flags & NAUTILUS_WINDOW_OPEN_FLAG_NEW_TAB) != 0)))
    {
        if ((flags & NAUTILUS_WINDOW_OPEN_FLAG_NEW_TAB) != 0 &&
            g_settings_get_enum (nautilus_preferences, NAUTILUS_PREFERENCES_NEW_TAB_POSITION) ==
            NAUTILUS_NEW_TAB_POSITION_AFTER_CURRENT_TAB)
        {
            /* When inserting N tabs after the current one,
             * we first open tab N, then tab N-1, ..., then tab 0.
             * Each of them is appended to the current tab, i.e.
             * prepended to the list of tabs to open.
             */
            g_queue_reverse (open_in_view_files);
        }

        closed_window = FALSE;

        for (l = g_queue_peek_head_link (open_in_view_files); l != NULL; l = l->next)
        {
            g_autofree char *uri = NULL;
            g_autoptr (GFile) location = NULL;
            g_autoptr (GFile) location_with_permissions = NULL;
            /* The ui should ask for navigation or object windows
             * depending on what the current one is */
            file = NAUTILUS_FILE (l->data);
            uri = nautilus_file_get_activation_uri (file);
            location = g_file_new_for_uri (uri);
            if (g_file_is_native (location) &&
                (nautilus_file_is_in_admin (file) ||
                 !nautilus_file_can_read (file) ||
                 !nautilus_file_can_execute (file)))
            {
                g_autofree gchar *file_path = NULL;

                g_free (uri);

                file_path = g_file_get_path (location);
                uri = g_strconcat ("admin://", file_path, NULL);
            }

            location_with_permissions = g_file_new_for_uri (uri);
            /* FIXME: we need to pass the parent_window, but we only use it for the current active window,
             * which nautilus-application should take care of. However is not working and creating regressions
             * in some cases. Until we figure out what's going on, continue to use the parameters->slot
             * to make splicit the window we want to use for activating the files */
            nautilus_application_open_location_full (NAUTILUS_APPLICATION (g_application_get_default ()),
                                                     location_with_permissions, flags, NULL, NULL, parameters->slot);

            /* close only the window from which the action was launched and then open
             * tabs/windows (depending on parameters->flags) */
            if (!closed_window && (flags & NAUTILUS_WINDOW_OPEN_FLAG_CLOSE_BEHIND) != 0)
            {
                flags &= (~NAUTILUS_WINDOW_OPEN_FLAG_CLOSE_BEHIND);

                /* if NEW_WINDOW is set, we want all files in new windows, not in tabs */
                if ((parameters->flags & NAUTILUS_WINDOW_OPEN_FLAG_NEW_WINDOW) == 0)
                {
                    flags &= (~NAUTILUS_WINDOW_OPEN_FLAG_NEW_WINDOW);
                    flags |= NAUTILUS_WINDOW_OPEN_FLAG_NEW_TAB;
                }

                closed_window = TRUE;
            }
        }
    }

    if (open_in_app_uris != NULL)
    {
        open_in_app_parameters = make_activation_parameters (g_queue_peek_head_link (open_in_app_uris),
                                                             &unhandled_open_in_app_uris);
    }

    num_apps = g_list_length (open_in_app_parameters);
    num_unhandled = g_list_length (unhandled_open_in_app_uris);
    num_files = g_queue_get_length (open_in_app_uris);
    open_files = TRUE;

    if (g_queue_is_empty (open_in_app_uris) &&
        (!parameters->user_confirmation ||
         num_files + num_unhandled > SILENT_OPEN_LIMIT) &&
        num_apps > 1)
    {
        GtkDialog *dialog;
        char *prompt;
        g_autofree char *detail = NULL;
        int response;

        pause_activation_timed_cancel (parameters);

        prompt = _("Are you sure you want to open all files?");
        detail = g_strdup_printf (ngettext ("This will open %d separate application.",
                                            "This will open %d separate applications.", num_apps), num_apps);
        dialog = eel_show_yes_no_dialog (prompt, detail,
                                         _("_OK"), _("_Cancel"),
                                         parameters->parent_window);
        response = gtk_dialog_run (dialog);
        gtk_widget_destroy (GTK_WIDGET (dialog));

        unpause_activation_timed_cancel (parameters);

        if (response != GTK_RESPONSE_YES)
        {
            open_files = FALSE;
        }
    }

    if (open_files)
    {
        for (l = open_in_app_parameters; l != NULL; l = l->next)
        {
            one_parameters = l->data;

            nautilus_launch_application_by_uri (one_parameters->application,
                                                one_parameters->uris,
                                                parameters->parent_window);
            application_launch_parameters_free (one_parameters);
        }

        for (l = unhandled_open_in_app_uris; l != NULL; l = l->next)
        {
            char *uri = l->data;

            /* this does not block */
            application_unhandled_uri (parameters, uri);
        }
    }

    window = NULL;
    if (parameters->slot != NULL)
    {
        window = nautilus_window_slot_get_window (parameters->slot);
    }

    if (open_in_app_parameters != NULL ||
        unhandled_open_in_app_uris != NULL)
    {
        if ((parameters->flags & NAUTILUS_WINDOW_OPEN_FLAG_CLOSE_BEHIND) != 0 &&
            window != NULL)
        {
            nautilus_window_close (window);
        }
    }

    activation_parameters_free (parameters);
}

deep_count_load (DeepCountState *state,
                 GFile          *location)
{
    state->deep_count_location = g_object_ref (location);

#ifdef DEBUG_LOAD_DIRECTORY
    g_message ("load_directory called to get deep file count for %p", location);
#endif
    g_file_enumerate_children_async (state->deep_count_location,
                                     G_FILE_ATTRIBUTE_STANDARD_NAME ","
                                     G_FILE_ATTRIBUTE_STANDARD_TYPE ","
                                     G_FILE_ATTRIBUTE_STANDARD_SIZE ","
                                     G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN ","
                                     G_FILE_ATTRIBUTE_STANDARD_IS_BACKUP ","
                                     G_FILE_ATTRIBUTE_ID_FILESYSTEM ","
                                     G_FILE_ATTRIBUTE_UNIX_INODE,
                                     G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,     /* flags */
                                     G_PRIORITY_LOW,     /* prio */
                                     state->cancellable,
                                     deep_count_callback,
                                     state);
}

fat_str_replace (char *str,
                 char  replacement)
{
    gboolean success;
    int i;

    success = FALSE;
    for (i = 0; str[i] != '\0'; i++)
    {
        if (strchr (FAT_FORBIDDEN_CHARACTERS, str[i]) ||
            str[i] < 32)
        {
            success = TRUE;
            str[i] = replacement;
        }
    }

    return success;
}

filesystem_info_cancel (NautilusDirectory *directory)
{
    if (directory->details->filesystem_info_state != NULL)
    {
        g_cancellable_cancel (directory->details->filesystem_info_state->cancellable);
        directory->details->filesystem_info_state->directory = NULL;
        directory->details->filesystem_info_state = NULL;
        async_job_end (directory, "filesystem info");
    }
}

nautilus_directory_monitor_add_internal (NautilusDirectory         *directory,
                                         NautilusFile              *file,
                                         gconstpointer              client,
                                         gboolean                   monitor_hidden_files,
                                         NautilusFileAttributes     file_attributes,
                                         NautilusDirectoryCallback  callback,
                                         gpointer                   callback_data)
{
    Monitor *monitor;
    GList *file_list;
    char *file_uri = NULL;
    char *dir_uri = NULL;

    g_assert (NAUTILUS_IS_DIRECTORY (directory));

    if (file != NULL)
    {
        file_uri = nautilus_file_get_uri (file);
    }
    if (directory != NULL)
    {
        dir_uri = nautilus_directory_get_uri (directory);
    }
    nautilus_profile_start ("uri %s file-uri %s client %p", dir_uri, file_uri, client);
    g_free (dir_uri);
    g_free (file_uri);

    /* Replace any current monitor for this client/file pair. */
    remove_monitor (directory, file, client);

    /* Add the new monitor. */
    monitor = g_new (Monitor, 1);
    monitor->file = file;
    monitor->monitor_hidden_files = monitor_hidden_files;
    monitor->client = client;
    monitor->request = nautilus_directory_set_up_request (file_attributes);

    if (file == NULL)
    {
        REQUEST_SET_TYPE (monitor->request, REQUEST_FILE_LIST);
    }
    directory->details->monitor_list =
        g_list_prepend (directory->details->monitor_list, monitor);
    request_counter_add_request (directory->details->monitor_counters,
                                 monitor->request);

    if (callback != NULL)
    {
        file_list = nautilus_directory_get_file_list (directory);
        (*callback)(directory, file_list, callback_data);
        nautilus_file_list_free (file_list);
    }

    /* Start the "real" monitoring (FAM or whatever). */
    /* We always monitor the whole directory since in practice
     * nautilus almost always shows the whole directory anyway, and
     * it allows us to avoid one file monitor per file in a directory.
     */
    if (directory->details->monitor == NULL)
    {
        directory->details->monitor = nautilus_monitor_directory (directory->details->location);
    }


    if (REQUEST_WANTS_TYPE (monitor->request, REQUEST_FILE_INFO) &&
        directory->details->mime_db_monitor == 0)
    {
        directory->details->mime_db_monitor =
            g_signal_connect_object (nautilus_signaller_get_current (),
                                     "mime-data-changed",
                                     G_CALLBACK (mime_db_changed_callback), directory, 0);
    }

    /* Put the monitor file or all the files on the work queue. */
    if (file != NULL)
    {
        nautilus_directory_add_file_to_work_queue (directory, file);
    }
    else
    {
        add_all_files_to_work_queue (directory);
    }

    /* Kick off I/O. */
    nautilus_directory_async_state_changed (directory);
    nautilus_profile_end (NULL);
}

activate_callback (GList    *files,
                   gpointer  callback_data)
{
    ActivateParameters *parameters = callback_data;
    GList *l, *next;
    NautilusFile *file;
    LaunchLocation *location;

    parameters->files_handle = NULL;

    for (l = parameters->locations; l != NULL; l = next)
    {
        location = l->data;
        file = location->file;
        next = l->next;

        if (file_was_cancelled (file))
        {
            launch_location_free (location);
            parameters->locations = g_list_delete_link (parameters->locations, l);
            continue;
        }

        if (file_was_not_mounted (file))
        {
            if (parameters->tried_mounting)
            {
                launch_location_free (location);
                parameters->locations = g_list_delete_link (parameters->locations, l);
            }
            else
            {
                parameters->not_mounted = g_list_prepend (parameters->not_mounted,
                                                          nautilus_file_ref (file));
            }
            continue;
        }
    }


    if (parameters->not_mounted != NULL)
    {
        activation_mount_not_mounted (parameters);
    }
    else
    {
        activate_files (parameters);
    }
}

nautilus_file_operations_move (GList                *files,
                               GArray               *relative_item_points,
                               GFile                *target_dir,
                               GtkWindow            *parent_window,
                               NautilusCopyCallback  done_callback,
                               gpointer              done_callback_data)
{
    GTask *task;
    CopyMoveJob *job;

    job = op_job_new (CopyMoveJob, parent_window);
    job->is_move = TRUE;
    job->done_callback = done_callback;
    job->done_callback_data = done_callback_data;
    job->files = g_list_copy_deep (files, (GCopyFunc) g_object_ref, NULL);
    job->destination = g_object_ref (target_dir);
    /* Need to indicate the destination for the operation notification open
     * button. */
    nautilus_progress_info_set_destination (((CommonJob *) job)->progress, target_dir);
    if (relative_item_points != NULL &&
        relative_item_points->len > 0)
    {
        job->icon_positions =
            g_memdup (relative_item_points->data,
                      sizeof (GdkPoint) * relative_item_points->len);
        job->n_icon_positions = relative_item_points->len;
    }
    job->debuting_files = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);

    inhibit_power_manager ((CommonJob *) job, _("Moving Files"));

    if (!nautilus_file_undo_manager_is_operating ())
    {
        GFile *src_dir;

        src_dir = g_file_get_parent (files->data);

        if (g_file_has_uri_scheme (g_list_first (files)->data, "trash"))
        {
            job->common.undo_info = nautilus_file_undo_info_ext_new (NAUTILUS_FILE_UNDO_OP_RESTORE_FROM_TRASH,
                                                                     g_list_length (files),
                                                                     src_dir, target_dir);
        }
        else
        {
            job->common.undo_info = nautilus_file_undo_info_ext_new (NAUTILUS_FILE_UNDO_OP_MOVE,
                                                                     g_list_length (files),
                                                                     src_dir, target_dir);
        }

        g_object_unref (src_dir);
    }

    task = g_task_new (NULL, job->common.cancellable, move_task_done, job);
    g_task_set_task_data (task, job, NULL);
    g_task_run_in_thread (task, move_task_thread_func);
    g_object_unref (task);
}

call_ready_callbacks_at_idle (gpointer callback_data)
{
    NautilusDirectory *directory;
    GList *node, *next;
    ReadyCallback *callback;

    directory = NAUTILUS_DIRECTORY (callback_data);
    directory->details->call_ready_idle_id = 0;

    nautilus_directory_ref (directory);

    callback = NULL;
    while (1)
    {
        /* Check if any callbacks are non-active and call them if they are. */
        for (node = directory->details->call_when_ready_list;
             node != NULL; node = next)
        {
            next = node->next;
            callback = node->data;
            if (!callback->active)
            {
                /* Non-active, remove and call */
                break;
            }
        }
        if (node == NULL)
        {
            break;
        }

        /* Callbacks are one-shots, so remove it now. */
        remove_callback_link_keep_data (directory, node);

        /* Call the callback. */
        ready_callback_call (directory, callback);
        g_free (callback);
    }

    nautilus_directory_async_state_changed (directory);

    nautilus_directory_unref (directory);

    return FALSE;
}

has_fs_id (GFile      *file,
           const char *fs_id)
{
    const char *id;
    GFileInfo *info;
    gboolean res;

    res = FALSE;
    info = g_file_query_info (file,
                              G_FILE_ATTRIBUTE_ID_FILESYSTEM,
                              G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,
                              NULL, NULL);

    if (info)
    {
        id = g_file_info_get_attribute_string (info, G_FILE_ATTRIBUTE_ID_FILESYSTEM);

        if (id && strcmp (id, fs_id) == 0)
        {
            res = TRUE;
        }

        g_object_unref (info);
    }

    return res;
}

get_file_list_for_launch_locations (GList *locations)
{
    GList *files, *l;
    LaunchLocation *location;

    files = NULL;
    for (l = locations; l != NULL; l = l->next)
    {
        location = l->data;

        files = g_list_prepend (files,
                                nautilus_file_ref (location->file));
    }
    return g_list_reverse (files);
}

get_max_name_length (GFile *file_dir)
{
    int max_length;
    char *dir;
    long max_path;
    long max_name;

    max_length = -1;

    if (!g_file_has_uri_scheme (file_dir, "file"))
    {
        return max_length;
    }

    dir = g_file_get_path (file_dir);
    if (!dir)
    {
        return max_length;
    }

    max_path = pathconf (dir, _PC_PATH_MAX);
    max_name = pathconf (dir, _PC_NAME_MAX);

    if (max_name == -1 && max_path == -1)
    {
        max_length = -1;
    }
    else if (max_name == -1 && max_path != -1)
    {
        max_length = max_path - (strlen (dir) + 1);
    }
    else if (max_name != -1 && max_path == -1)
    {
        max_length = max_name;
    }
    else
    {
        int leftover;

        leftover = max_path - (strlen (dir) + 1);

        max_length = MIN (leftover, max_name);
    }

    g_free (dir);

    return max_length;
}

trash_files (CommonJob *job,
             GList     *files,
             int       *files_skipped)
{
    GList *l;
    GFile *file;
    GList *to_delete;
    SourceInfo source_info;
    TransferInfo transfer_info;
    gboolean skipped_file;

    if (job_aborted (job))
    {
        return;
    }

    scan_sources (files,
                  &source_info,
                  job,
                  OP_KIND_TRASH);
    if (job_aborted (job))
    {
        return;
    }

    g_timer_start (job->time);

    memset (&transfer_info, 0, sizeof (transfer_info));
    report_trash_progress (job, &source_info, &transfer_info);

    to_delete = NULL;
    for (l = files;
         l != NULL && !job_aborted (job);
         l = l->next)
    {
        file = l->data;

        skipped_file = FALSE;
        trash_file (job, file,
                    &skipped_file,
                    &source_info, &transfer_info,
                    TRUE, &to_delete);
        if (skipped_file)
        {
            (*files_skipped)++;
            transfer_add_file_to_count (file, job, &transfer_info);
            report_trash_progress (job, &source_info, &transfer_info);
        }
    }

    if (to_delete)
    {
        to_delete = g_list_reverse (to_delete);
        delete_files (job, to_delete, files_skipped);
        g_list_free (to_delete);
    }
}

directory_load_one (NautilusDirectory *directory,
                    GFileInfo         *info)
{
    if (info == NULL)
    {
        return;
    }

    if (g_file_info_get_name (info) == NULL)
    {
        char *uri;

        uri = nautilus_directory_get_uri (directory);
        g_warning ("Got GFileInfo with NULL name in %s, ignoring. This shouldn't happen unless the gvfs backend is broken.\n", uri);
        g_free (uri);

        return;
    }

    /* Arrange for the "loading" part of the work. */
    g_object_ref (info);
    directory->details->pending_file_info
        = g_list_prepend (directory->details->pending_file_info, info);
    nautilus_directory_schedule_dequeue_pending (directory);
}

istr_set_destroy (GHashTable *table)
{
    g_hash_table_destroy (table);
}

search_for_application_dbus_call_notify_cb (GDBusProxy   *proxy,
                                            GAsyncResult *result,
                                            gpointer      user_data)
{
    ActivateParametersInstall *parameters_install = user_data;
    GVariant *variant;
    GError *error = NULL;

    variant = g_dbus_proxy_call_finish (proxy, result, &error);
    if (variant == NULL)
    {
        if (!g_dbus_error_is_remote_error (error) ||
            g_strcmp0 (g_dbus_error_get_remote_error (error), "org.freedesktop.PackageKit.Modify.Failed") == 0)
        {
            char *message;

            message = g_strdup_printf ("%s\n%s",
                                       _("There was an internal error trying to search for applications:"),
                                       error->message);
            eel_show_error_dialog (_("Unable to search for application"), message,
                                   parameters_install->parent_window);
            g_free (message);
        }
        else
        {
            g_warning ("Error while trying to search for applications: %s",
                       error->message);
        }

        g_error_free (error);
        activate_parameters_install_free (parameters_install);
        return;
    }

    g_variant_unref (variant);

    /* activate the file again */
    nautilus_mime_activate_files (parameters_install->parent_window,
                                  parameters_install->slot,
                                  parameters_install->files,
                                  parameters_install->activation_directory,
                                  parameters_install->flags,
                                  parameters_install->user_confirmation);

    activate_parameters_install_free (parameters_install);
}

activation_mount_not_mounted (ActivateParameters *parameters)
{
    NautilusFile *file;
    GFile *location;
    LaunchLocation *loc;
    GMountOperation *mount_op;
    GList *l, *next, *files;

    if (parameters->not_mounted != NULL)
    {
        file = parameters->not_mounted->data;
        mount_op = gtk_mount_operation_new (parameters->parent_window);
        g_mount_operation_set_password_save (mount_op, G_PASSWORD_SAVE_FOR_SESSION);
        g_signal_connect (mount_op, "notify::is-showing",
                          G_CALLBACK (activate_mount_op_active), parameters);
        location = nautilus_file_get_location (file);
        g_file_mount_enclosing_volume (location, 0, mount_op, parameters->cancellable,
                                       activation_mount_not_mounted_callback, parameters);
        g_object_unref (location);
        /* unref mount_op here - g_file_mount_enclosing_volume() does ref for itself */
        g_object_unref (mount_op);
        return;
    }

    parameters->tried_mounting = TRUE;

    if (parameters->locations == NULL)
    {
        activation_parameters_free (parameters);
        return;
    }

    /*  once the mount is finished, refresh all attributes        */
    /*  - fixes new windows not appearing after successful mount  */
    for (l = parameters->locations; l != NULL; l = next)
    {
        loc = l->data;
        next = l->next;
        nautilus_file_invalidate_all_attributes (loc->file);
    }

    files = get_file_list_for_launch_locations (parameters->locations);
    nautilus_file_list_call_when_ready
        (files,
        nautilus_mime_actions_get_required_file_attributes (),
        &parameters->files_handle,
        activate_callback, parameters);
    nautilus_file_list_free (files);
}

nautilus_file_operations_mount_volume_full (GtkWindow             *parent_window,
                                            GVolume               *volume,
                                            NautilusMountCallback  mount_callback,
                                            GObject               *mount_callback_data_object)
{
    GMountOperation *mount_op;

    mount_op = gtk_mount_operation_new (parent_window);
    g_mount_operation_set_password_save (mount_op, G_PASSWORD_SAVE_FOR_SESSION);
    g_object_set_data (G_OBJECT (mount_op),
                       "mount-callback",
                       mount_callback);

    if (mount_callback != NULL &&
        mount_callback_data_object != NULL)
    {
        g_object_weak_ref (mount_callback_data_object,
                           mount_callback_data_notify,
                           mount_op);
    }
    g_object_set_data (G_OBJECT (mount_op),
                       "mount-callback-data",
                       mount_callback_data_object);

    g_volume_mount (volume, 0, mount_op, NULL, volume_mount_cb, mount_op);
}

mime_db_changed_callback (GObject           *ignore,
                          NautilusDirectory *dir)
{
    NautilusFileAttributes attrs;

    g_assert (dir != NULL);
    g_assert (dir->details != NULL);

    attrs = NAUTILUS_FILE_ATTRIBUTE_INFO |
            NAUTILUS_FILE_ATTRIBUTE_LINK_INFO |
            NAUTILUS_FILE_ATTRIBUTE_DIRECTORY_ITEM_MIME_TYPES;

    nautilus_directory_force_reload_internal (dir, attrs);
}

pk_proxy_appeared_cb (GObject      *source,
                      GAsyncResult *res,
                      gpointer      user_data)
{
    ActivateParametersInstall *parameters_install = user_data;
    char *mime_type, *name_owner;
    char *error_message;
    GtkWidget *dialog;
    GDBusProxy *proxy;
    GError *error = NULL;

    proxy = g_dbus_proxy_new_for_bus_finish (res, &error);
    name_owner = g_dbus_proxy_get_name_owner (proxy);

    if (error != NULL || name_owner == NULL)
    {
        g_warning ("Couldn't call Modify on the PackageKit interface: %s",
                   error != NULL ? error->message : "no owner for PackageKit");
        g_clear_error (&error);

        /* show an unhelpful dialog */
        show_unhandled_type_error (parameters_install);

        return;
    }

    g_free (name_owner);

    mime_type = nautilus_file_get_mime_type (parameters_install->file);
    error_message = get_application_no_mime_type_handler_message (parameters_install->file,
                                                                  parameters_install->uri);
    /* use a custom dialog to prompt the user to install new software */
    dialog = gtk_message_dialog_new (parameters_install->parent_window, 0,
                                     GTK_MESSAGE_ERROR,
                                     GTK_BUTTONS_YES_NO,
                                     "%s", error_message);
    gtk_message_dialog_format_secondary_text (GTK_MESSAGE_DIALOG (dialog),
                                              _("There is no application installed for “%s” files.\n"
                                                "Do you want to search for an application to open this file?"),
                                              g_content_type_get_description (mime_type));
    gtk_window_set_resizable (GTK_WINDOW (dialog), FALSE);

    parameters_install->dialog = dialog;
    parameters_install->proxy = proxy;

    g_signal_connect (dialog, "response",
                      G_CALLBACK (application_unhandled_file_install),
                      parameters_install);
    g_signal_connect (dialog, "delete-event",
                      G_CALLBACK (delete_cb), NULL);
    gtk_widget_show_all (dialog);
    g_free (mime_type);
}

application_launch_parameters_free (ApplicationLaunchParameters *parameters)
{
    g_object_unref (parameters->application);
    g_list_free_full (parameters->uris, g_free);

    g_free (parameters);
}

launch_location_free (LaunchLocation *location)
{
    nautilus_file_unref (location->file);
    g_free (location->uri);
    g_free (location);
}

create_dest_dir (CommonJob  *job,
                 GFile      *src,
                 GFile     **dest,
                 gboolean    same_fs,
                 char      **dest_fs_type)
{
    GError *error;
    GFile *new_dest, *dest_dir;
    char *primary, *secondary, *details;
    int response;
    gboolean handled_invalid_filename;
    gboolean res;

    handled_invalid_filename = *dest_fs_type != NULL;

retry:
    /* First create the directory, then copy stuff to it before
     *  copying the attributes, because we need to be sure we can write to it */

    error = NULL;
    res = g_file_make_directory (*dest, job->cancellable, &error);

    if (res)
    {
        GFile *real;

        real = map_possibly_volatile_file_to_real (*dest, job->cancellable, &error);
        if (real == NULL)
        {
            res = FALSE;
        }
        else
        {
            g_object_unref (*dest);
            *dest = real;
        }
    }

    if (!res)
    {
        if (IS_IO_ERROR (error, CANCELLED))
        {
            g_error_free (error);
            return CREATE_DEST_DIR_FAILED;
        }
        else if (IS_IO_ERROR (error, INVALID_FILENAME) &&
                 !handled_invalid_filename)
        {
            handled_invalid_filename = TRUE;

            g_assert (*dest_fs_type == NULL);

            dest_dir = g_file_get_parent (*dest);

            if (dest_dir != NULL)
            {
                *dest_fs_type = query_fs_type (dest_dir, job->cancellable);

                new_dest = get_target_file (src, dest_dir, *dest_fs_type, same_fs);
                g_object_unref (dest_dir);

                if (!g_file_equal (*dest, new_dest))
                {
                    g_object_unref (*dest);
                    *dest = new_dest;
                    g_error_free (error);
                    return CREATE_DEST_DIR_RETRY;
                }
                else
                {
                    g_object_unref (new_dest);
                }
            }
        }

        primary = f (_("Error while copying."));
        details = NULL;

        if (IS_IO_ERROR (error, PERMISSION_DENIED))
        {
            secondary = f (_("The folder “%B” cannot be copied because you do not have "
                             "permissions to create it in the destination."), src);
        }
        else
        {
            secondary = f (_("There was an error creating the folder “%B”."), src);
            details = error->message;
        }

        response = run_warning (job,
                                primary,
                                secondary,
                                details,
                                FALSE,
                                CANCEL, SKIP, RETRY,
                                NULL);

        g_error_free (error);

        if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)
        {
            abort_job (job);
        }
        else if (response == 1)
        {
            /* Skip: Do Nothing  */
        }
        else if (response == 2)
        {
            goto retry;
        }
        else
        {
            g_assert_not_reached ();
        }
        return CREATE_DEST_DIR_FAILED;
    }
    nautilus_file_changes_queue_file_added (*dest);

    if (job->undo_info != NULL)
    {
        nautilus_file_undo_info_ext_add_origin_target_pair (NAUTILUS_FILE_UNDO_INFO_EXT (job->undo_info),
                                                            src, *dest);
    }

    return CREATE_DEST_DIR_SUCCESS;
}

remove_monitor (NautilusDirectory *directory,
                NautilusFile      *file,
                gconstpointer      client)
{
    remove_monitor_link (directory, find_monitor (directory, file, client));
}

compress_job_on_completed (AutoarCompressor *compressor,
                           gpointer          user_data)
{
    CompressJob *compress_job = user_data;
    g_autoptr (GFile) destination_directory = NULL;
    char *status;

    if (compress_job->total_files == 1)
    {
        status = f (_("Compressed “%B” into “%B”"),
                    G_FILE (compress_job->source_files->data),
                    compress_job->output_file);
    }
    else
    {
        status = f (ngettext ("Compressed %'d file into “%B”",
                              "Compressed %'d files into “%B”",
                              compress_job->total_files),
                    compress_job->total_files,
                    compress_job->output_file);
    }

    nautilus_progress_info_take_status (compress_job->common.progress,
                                        status);

    nautilus_file_changes_queue_file_added (compress_job->output_file);

    destination_directory = g_file_get_parent (compress_job->output_file);
    nautilus_progress_info_set_destination (compress_job->common.progress,
                                            destination_directory);
}

lacks_extension_info (NautilusFile *file)
{
    return file->details->pending_info_providers != NULL;
}

copy_task_thread_func (GTask        *task,
                       gpointer      source_object,
                       gpointer      task_data,
                       GCancellable *cancellable)
{
    CopyMoveJob *job;
    CommonJob *common;
    SourceInfo source_info;
    TransferInfo transfer_info;
    char *dest_fs_id;
    GFile *dest;

    job = task_data;
    common = &job->common;

    dest_fs_id = NULL;

    nautilus_progress_info_start (job->common.progress);

    scan_sources (job->files,
                  &source_info,
                  common,
                  OP_KIND_COPY);
    if (job_aborted (common))
    {
        goto aborted;
    }

    if (job->destination)
    {
        dest = g_object_ref (job->destination);
    }
    else
    {
        /* Duplication, no dest,
         * use source for free size, etc
         */
        dest = g_file_get_parent (job->files->data);
    }

    verify_destination (&job->common,
                        dest,
                        &dest_fs_id,
                        source_info.num_bytes);
    g_object_unref (dest);
    if (job_aborted (common))
    {
        goto aborted;
    }

    g_timer_start (job->common.time);

    memset (&transfer_info, 0, sizeof (transfer_info));
    copy_files (job,
                dest_fs_id,
                &source_info, &transfer_info);

aborted:

    g_free (dest_fs_id);
}

nautilus_mime_actions_get_required_file_attributes (void)
{
    return NAUTILUS_FILE_ATTRIBUTE_INFO |
           NAUTILUS_FILE_ATTRIBUTE_LINK_INFO;
}

confirm_multiple_windows (GtkWindow *parent_window,
                          int        count,
                          gboolean   use_tabs)
{
    GtkDialog *dialog;
    char *prompt;
    char *detail;
    int response;

    if (count <= SILENT_WINDOW_OPEN_LIMIT)
    {
        return TRUE;
    }

    prompt = _("Are you sure you want to open all files?");
    if (use_tabs)
    {
        detail = g_strdup_printf (ngettext ("This will open %d separate tab.",
                                            "This will open %d separate tabs.", count), count);
    }
    else
    {
        detail = g_strdup_printf (ngettext ("This will open %d separate window.",
                                            "This will open %d separate windows.", count), count);
    }
    dialog = eel_show_yes_no_dialog (prompt, detail,
                                     _("_OK"), _("_Cancel"),
                                     parent_window);
    g_free (detail);

    response = gtk_dialog_run (dialog);
    gtk_widget_destroy (GTK_WIDGET (dialog));

    return response == GTK_RESPONSE_YES;
}

get_unique_target_file (GFile      *src,
                        GFile      *dest_dir,
                        gboolean    same_fs,
                        const char *dest_fs_type,
                        int         count)
{
    const char *editname, *end;
    char *basename, *new_name;
    GFileInfo *info;
    GFile *dest;
    int max_length;

    max_length = get_max_name_length (dest_dir);

    dest = NULL;
    info = g_file_query_info (src,
                              G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME,
                              0, NULL, NULL);
    if (info != NULL)
    {
        editname = g_file_info_get_attribute_string (info, G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME);

        if (editname != NULL)
        {
            new_name = get_duplicate_name (editname, count, max_length);
            make_file_name_valid_for_dest_fs (new_name, dest_fs_type);
            dest = g_file_get_child_for_display_name (dest_dir, new_name, NULL);
            g_free (new_name);
        }

        g_object_unref (info);
    }

    if (dest == NULL)
    {
        basename = g_file_get_basename (src);

        if (g_utf8_validate (basename, -1, NULL))
        {
            new_name = get_duplicate_name (basename, count, max_length);
            make_file_name_valid_for_dest_fs (new_name, dest_fs_type);
            dest = g_file_get_child_for_display_name (dest_dir, new_name, NULL);
            g_free (new_name);
        }

        if (dest == NULL)
        {
            end = strrchr (basename, '.');
            if (end != NULL)
            {
                count += atoi (end + 1);
            }
            new_name = g_strdup_printf ("%s.%d", basename, count);
            make_file_name_valid_for_dest_fs (new_name, dest_fs_type);
            dest = g_file_get_child (dest_dir, new_name);
            g_free (new_name);
        }

        g_free (basename);
    }

    return dest;
}

istr_equal (gconstpointer v,
            gconstpointer v2)
{
    return g_ascii_strcasecmp (v, v2) == 0;
}

find_launch_location_for_file (GList        *list,
                               NautilusFile *file)
{
    LaunchLocation *location;
    GList *l;

    for (l = list; l != NULL; l = l->next)
    {
        location = l->data;

        if (location->file == file)
        {
            return location;
        }
    }
    return NULL;
}

create_task_thread_func (GTask        *task,
                         gpointer      source_object,
                         gpointer      task_data,
                         GCancellable *cancellable)
{
    CreateJob *job;
    CommonJob *common;
    int count;
    GFile *dest;
    g_autofree gchar *dest_uri = NULL;
    char *basename;
    char *filename, *filename2, *new_filename;
    char *filename_base, *suffix;
    char *dest_fs_type;
    GError *error;
    gboolean res;
    gboolean filename_is_utf8;
    char *primary, *secondary, *details;
    int response;
    char *data;
    int length;
    GFileOutputStream *out;
    gboolean handled_invalid_filename;
    int max_length, offset;

    job = task_data;
    common = &job->common;

    nautilus_progress_info_start (job->common.progress);

    handled_invalid_filename = FALSE;

    dest_fs_type = NULL;
    filename = NULL;
    dest = NULL;

    max_length = get_max_name_length (job->dest_dir);

    verify_destination (common,
                        job->dest_dir,
                        NULL, -1);
    if (job_aborted (common))
    {
        goto aborted;
    }

    filename = g_strdup (job->filename);
    filename_is_utf8 = FALSE;
    if (filename)
    {
        filename_is_utf8 = g_utf8_validate (filename, -1, NULL);
    }
    if (filename == NULL)
    {
        if (job->make_dir)
        {
            /* localizers: the initial name of a new folder  */
            filename = g_strdup (_("Untitled Folder"));
            filename_is_utf8 = TRUE;             /* Pass in utf8 */
        }
        else
        {
            if (job->src != NULL)
            {
                basename = g_file_get_basename (job->src);
                /* localizers: the initial name of a new template document */
                filename = g_strdup_printf ("%s", basename);

                g_free (basename);
            }
            if (filename == NULL)
            {
                /* localizers: the initial name of a new empty document */
                filename = g_strdup (_("Untitled Document"));
                filename_is_utf8 = TRUE;                 /* Pass in utf8 */
            }
        }
    }

    make_file_name_valid_for_dest_fs (filename, dest_fs_type);
    if (filename_is_utf8)
    {
        dest = g_file_get_child_for_display_name (job->dest_dir, filename, NULL);
    }
    if (dest == NULL)
    {
        dest = g_file_get_child (job->dest_dir, filename);
    }
    count = 1;

retry:

    error = NULL;
    if (job->make_dir)
    {
        res = g_file_make_directory (dest,
                                     common->cancellable,
                                     &error);

        if (res)
        {
            GFile *real;

            real = map_possibly_volatile_file_to_real (dest, common->cancellable, &error);
            if (real == NULL)
            {
                res = FALSE;
            }
            else
            {
                g_object_unref (dest);
                dest = real;
            }
        }

        if (res && common->undo_info != NULL)
        {
            nautilus_file_undo_info_create_set_data (NAUTILUS_FILE_UNDO_INFO_CREATE (common->undo_info),
                                                     dest, NULL, 0);
        }
    }
    else
    {
        if (job->src)
        {
            res = g_file_copy (job->src,
                               dest,
                               G_FILE_COPY_NONE,
                               common->cancellable,
                               NULL, NULL,
                               &error);

            if (res)
            {
                GFile *real;

                real = map_possibly_volatile_file_to_real (dest, common->cancellable, &error);
                if (real == NULL)
                {
                    res = FALSE;
                }
                else
                {
                    g_object_unref (dest);
                    dest = real;
                }
            }

            if (res && common->undo_info != NULL)
            {
                gchar *uri;

                uri = g_file_get_uri (job->src);
                nautilus_file_undo_info_create_set_data (NAUTILUS_FILE_UNDO_INFO_CREATE (common->undo_info),
                                                         dest, uri, 0);

                g_free (uri);
            }
        }
        else
        {
            data = "";
            length = 0;
            if (job->src_data)
            {
                data = job->src_data;
                length = job->length;
            }

            out = g_file_create (dest,
                                 G_FILE_CREATE_NONE,
                                 common->cancellable,
                                 &error);
            if (out)
            {
                GFile *real;

                real = map_possibly_volatile_file_to_real_on_write (dest,
                                                                    out,
                                                                    common->cancellable,
                                                                    &error);
                if (real == NULL)
                {
                    res = FALSE;
                    g_object_unref (out);
                }
                else
                {
                    g_object_unref (dest);
                    dest = real;

                    res = g_output_stream_write_all (G_OUTPUT_STREAM (out),
                                                     data, length,
                                                     NULL,
                                                     common->cancellable,
                                                     &error);
                    if (res)
                    {
                        res = g_output_stream_close (G_OUTPUT_STREAM (out),
                                                     common->cancellable,
                                                     &error);

                        if (res && common->undo_info != NULL)
                        {
                            nautilus_file_undo_info_create_set_data (NAUTILUS_FILE_UNDO_INFO_CREATE (common->undo_info),
                                                                     dest, data, length);
                        }
                    }

                    /* This will close if the write failed and we didn't close */
                    g_object_unref (out);
                }
            }
            else
            {
                res = FALSE;
            }
        }
    }

    if (res)
    {
        job->created_file = g_object_ref (dest);
        nautilus_file_changes_queue_file_added (dest);
        dest_uri = g_file_get_uri (dest);
        if (job->has_position)
        {
            nautilus_file_changes_queue_schedule_position_set (dest, job->position, common->screen_num);
        }
        else if (eel_uri_is_desktop (dest_uri))
        {
            nautilus_file_changes_queue_schedule_position_remove (dest);
        }
    }
    else
    {
        g_assert (error != NULL);

        if (IS_IO_ERROR (error, INVALID_FILENAME) &&
            !handled_invalid_filename)
        {
            handled_invalid_filename = TRUE;

            g_assert (dest_fs_type == NULL);
            dest_fs_type = query_fs_type (job->dest_dir, common->cancellable);

            if (count == 1)
            {
                new_filename = g_strdup (filename);
            }
            else
            {
                filename_base = eel_filename_strip_extension (filename);
                offset = strlen (filename_base);
                suffix = g_strdup (filename + offset);

                filename2 = g_strdup_printf ("%s %d%s", filename_base, count, suffix);

                new_filename = NULL;
                if (max_length > 0 && strlen (filename2) > max_length)
                {
                    new_filename = shorten_utf8_string (filename2, strlen (filename2) - max_length);
                }

                if (new_filename == NULL)
                {
                    new_filename = g_strdup (filename2);
                }

                g_free (filename2);
                g_free (suffix);
            }

            if (make_file_name_valid_for_dest_fs (new_filename, dest_fs_type))
            {
                g_object_unref (dest);

                if (filename_is_utf8)
                {
                    dest = g_file_get_child_for_display_name (job->dest_dir, new_filename, NULL);
                }
                if (dest == NULL)
                {
                    dest = g_file_get_child (job->dest_dir, new_filename);
                }

                g_free (new_filename);
                g_error_free (error);
                goto retry;
            }
            g_free (new_filename);
        }

        if (IS_IO_ERROR (error, EXISTS))
        {
            g_object_unref (dest);
            dest = NULL;
            filename_base = eel_filename_strip_extension (filename);
            offset = strlen (filename_base);
            suffix = g_strdup (filename + offset);

            filename2 = g_strdup_printf ("%s %d%s", filename_base, ++count, suffix);

            if (max_length > 0 && strlen (filename2) > max_length)
            {
                new_filename = shorten_utf8_string (filename2, strlen (filename2) - max_length);
                if (new_filename != NULL)
                {
                    g_free (filename2);
                    filename2 = new_filename;
                }
            }

            make_file_name_valid_for_dest_fs (filename2, dest_fs_type);
            if (filename_is_utf8)
            {
                dest = g_file_get_child_for_display_name (job->dest_dir, filename2, NULL);
            }
            if (dest == NULL)
            {
                dest = g_file_get_child (job->dest_dir, filename2);
            }
            g_free (filename2);
            g_free (suffix);
            g_error_free (error);
            goto retry;
        }
        else if (IS_IO_ERROR (error, CANCELLED))
        {
            g_error_free (error);
        }
        /* Other error */
        else
        {
            if (job->make_dir)
            {
                primary = f (_("Error while creating directory %B."), dest);
            }
            else
            {
                primary = f (_("Error while creating file %B."), dest);
            }
            secondary = f (_("There was an error creating the directory in %F."), job->dest_dir);
            details = error->message;

            response = run_warning (common,
                                    primary,
                                    secondary,
                                    details,
                                    FALSE,
                                    CANCEL, SKIP,
                                    NULL);

            g_error_free (error);

            if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)
            {
                abort_job (common);
            }
            else if (response == 1)                 /* skip */
            {                   /* do nothing */
            }
            else
            {
                g_assert_not_reached ();
            }
        }
    }

aborted:
    if (dest)
    {
        g_object_unref (dest);
    }
    g_free (filename);
    g_free (dest_fs_type);
}

activation_parameters_free (ActivateParameters *parameters)
{
    if (parameters->timed_wait_active)
    {
        eel_timed_wait_stop (cancel_activate_callback, parameters);
    }

    if (parameters->slot)
    {
        g_object_remove_weak_pointer (G_OBJECT (parameters->slot), (gpointer *) &parameters->slot);
    }
    if (parameters->parent_window)
    {
        g_object_remove_weak_pointer (G_OBJECT (parameters->parent_window), (gpointer *) &parameters->parent_window);
    }
    g_object_unref (parameters->cancellable);
    launch_location_list_free (parameters->locations);
    nautilus_file_list_free (parameters->mountables);
    nautilus_file_list_free (parameters->start_mountables);
    nautilus_file_list_free (parameters->not_mounted);
    g_free (parameters->activation_directory);
    g_free (parameters->timed_wait_prompt);
    g_assert (parameters->files_handle == NULL);
    g_free (parameters);
}

nautilus_mime_file_opens_in_external_app (NautilusFile *file)
{
    ActivationAction activation_action;

    activation_action = get_activation_action (file);

    return (activation_action == ACTIVATION_ACTION_OPEN_IN_APPLICATION);
}

get_scan_primary (OpKind kind)
{
    switch (kind)
    {
        default:
        case OP_KIND_COPY:
        {
            return f (_("Error while copying."));
        }

        case OP_KIND_MOVE:
        {
            return f (_("Error while moving."));
        }

        case OP_KIND_DELETE:
        {
            return f (_("Error while deleting."));
        }

        case OP_KIND_TRASH:
        {
            return f (_("Error while moving files to trash."));
        }

        case OP_KIND_COMPRESS:
            return f (_("Error while compressing files."));
    }
}

nautilus_mime_actions_check_if_required_attributes_ready (NautilusFile *file)
{
    NautilusFileAttributes attributes;
    gboolean ready;

    attributes = nautilus_mime_actions_get_required_file_attributes ();
    ready = nautilus_file_check_if_ready (file, attributes);

    return ready;
}

file_compare_by_parent_uri (NautilusFile *file_a,
                            NautilusFile *file_b)
{
    char *parent_uri_a, *parent_uri_b;
    int ret;

    parent_uri_a = nautilus_file_get_parent_uri (file_a);
    parent_uri_b = nautilus_file_get_parent_uri (file_b);

    ret = strcmp (parent_uri_a, parent_uri_b);

    g_free (parent_uri_a);
    g_free (parent_uri_b);

    return ret;
}

make_file_name_valid_for_dest_fs (char       *filename,
                                  const char *dest_fs_type)
{
    if (dest_fs_type != NULL && filename != NULL)
    {
        if (!strcmp (dest_fs_type, "fat") ||
            !strcmp (dest_fs_type, "vfat") ||
            !strcmp (dest_fs_type, "msdos") ||
            !strcmp (dest_fs_type, "msdosfs"))
        {
            gboolean ret;
            int i, old_len;

            ret = fat_str_replace (filename, '_');

            old_len = strlen (filename);
            for (i = 0; i < old_len; i++)
            {
                if (filename[i] != ' ')
                {
                    g_strchomp (filename);
                    ret |= (old_len != strlen (filename));
                    break;
                }
            }

            return ret;
        }
    }

    return FALSE;
}

nautilus_file_operations_link (GList                *files,
                               GArray               *relative_item_points,
                               GFile                *target_dir,
                               GtkWindow            *parent_window,
                               NautilusCopyCallback  done_callback,
                               gpointer              done_callback_data)
{
    GTask *task;
    CopyMoveJob *job;

    job = op_job_new (CopyMoveJob, parent_window);
    job->done_callback = done_callback;
    job->done_callback_data = done_callback_data;
    job->files = g_list_copy_deep (files, (GCopyFunc) g_object_ref, NULL);
    job->destination = g_object_ref (target_dir);
    /* Need to indicate the destination for the operation notification open
     * button. */
    nautilus_progress_info_set_destination (((CommonJob *) job)->progress, target_dir);
    if (relative_item_points != NULL &&
        relative_item_points->len > 0)
    {
        job->icon_positions =
            g_memdup (relative_item_points->data,
                      sizeof (GdkPoint) * relative_item_points->len);
        job->n_icon_positions = relative_item_points->len;
    }
    job->debuting_files = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);

    if (!nautilus_file_undo_manager_is_operating ())
    {
        GFile *src_dir;

        src_dir = g_file_get_parent (files->data);
        job->common.undo_info = nautilus_file_undo_info_ext_new (NAUTILUS_FILE_UNDO_OP_CREATE_LINK,
                                                                 g_list_length (files),
                                                                 src_dir, target_dir);
        g_object_unref (src_dir);
    }

    task = g_task_new (NULL, job->common.cancellable, link_task_done, job);
    g_task_set_task_data (task, job, NULL);
    g_task_run_in_thread (task, link_task_thread_func);
    g_object_unref (task);
}

get_mount_at (GFile *target)
{
    GVolumeMonitor *monitor;
    GFile *root;
    GList *mounts, *l;
    GMount *found;

    monitor = g_volume_monitor_get ();
    mounts = g_volume_monitor_get_mounts (monitor);

    found = NULL;
    for (l = mounts; l != NULL; l = l->next)
    {
        GMount *mount = G_MOUNT (l->data);

        if (g_mount_is_shadowed (mount))
        {
            continue;
        }

        root = g_mount_get_root (mount);

        if (g_file_equal (target, root))
        {
            found = g_object_ref (mount);
            break;
        }

        g_object_unref (root);
    }

    g_list_free_full (mounts, g_object_unref);

    g_object_unref (monitor);

    return found;
}

more_files_callback (GObject      *source_object,
                     GAsyncResult *res,
                     gpointer      user_data)
{
    DirectoryLoadState *state;
    NautilusDirectory *directory;
    GError *error;
    GList *files, *l;
    GFileInfo *info;

    state = user_data;

    if (state->directory == NULL)
    {
        /* Operation was cancelled. Bail out */
        directory_load_state_free (state);
        return;
    }

    directory = nautilus_directory_ref (state->directory);

    g_assert (directory->details->directory_load_in_progress != NULL);
    g_assert (directory->details->directory_load_in_progress == state);

    error = NULL;
    files = g_file_enumerator_next_files_finish (state->enumerator,
                                                 res, &error);

    for (l = files; l != NULL; l = l->next)
    {
        info = l->data;
        directory_load_one (directory, info);
        g_object_unref (info);
    }

    if (files == NULL)
    {
        directory_load_done (directory, error);
        directory_load_state_free (state);
    }
    else
    {
        g_file_enumerator_next_files_async (state->enumerator,
                                            DIRECTORY_LOAD_ITEMS_PER_CALLBACK,
                                            G_PRIORITY_DEFAULT,
                                            state->cancellable,
                                            more_files_callback,
                                            state);
    }

    nautilus_directory_unref (directory);

    if (error)
    {
        g_error_free (error);
    }

    g_list_free (files);
}

scan_sources (GList      *files,
              SourceInfo *source_info,
              CommonJob  *job,
              OpKind      kind)
{
    GList *l;
    GFile *file;
    g_autoptr (GHashTable) scanned = NULL;

    memset (source_info, 0, sizeof (SourceInfo));
    source_info->op = kind;

    scanned = g_hash_table_new_full (g_str_hash,
                                     g_str_equal,
                                     (GDestroyNotify) g_free,
                                     NULL);

    report_preparing_count_progress (job, source_info);

    for (l = files; l != NULL && !job_aborted (job); l = l->next)
    {
        file = l->data;

        scan_file (file,
                   source_info,
                   job,
                   scanned);
    }

    /* Make sure we report the final count */
    report_preparing_count_progress (job, source_info);
}

move_copy_file_callback_new (GFile    *file,
                             gboolean  overwrite,
                             GdkPoint *position)
{
    MoveFileCopyFallback *fallback;

    fallback = g_new (MoveFileCopyFallback, 1);
    fallback->file = file;
    fallback->overwrite = overwrite;
    if (position)
    {
        fallback->has_position = TRUE;
        fallback->position = *position;
    }
    else
    {
        fallback->has_position = FALSE;
    }

    return fallback;
}

get_application_no_mime_type_handler_message (NautilusFile *file,
                                              char         *uri)
{
    char *uri_for_display;
    char *name;
    char *error_message;

    name = nautilus_file_get_display_name (file);

    /* Truncate the URI so it doesn't get insanely wide. Note that even
     * though the dialog uses wrapped text, if the URI doesn't contain
     * white space then the text-wrapping code is too stupid to wrap it.
     */
    uri_for_display = eel_str_middle_truncate (name, MAX_URI_IN_DIALOG_LENGTH);
    error_message = g_strdup_printf (_("Could not display “%s”."), uri_for_display);
    g_free (uri_for_display);
    g_free (name);

    return error_message;
}

query_filesystem_info_callback (GObject      *source_object,
                                GAsyncResult *res,
                                gpointer      user_data)
{
    GFileInfo *info;
    FilesystemInfoState *state;

    state = user_data;
    if (state->directory == NULL)
    {
        /* Operation was cancelled. Bail out */
        filesystem_info_state_free (state);
        return;
    }

    info = g_file_query_filesystem_info_finish (G_FILE (source_object), res, NULL);

    got_filesystem_info (state, info);

    if (info != NULL)
    {
        g_object_unref (info);
    }
}

unpause_activation_timed_cancel (ActivateParameters *parameters)
{
    if (!parameters->timed_wait_active)
    {
        activation_start_timed_cancel (parameters);
    }
}

make_activation_parameters (GList  *uris,
                            GList **unhandled_uris)
{
    GList *ret, *l, *app_uris;
    NautilusFile *file;
    GAppInfo *app, *old_app;
    GHashTable *app_table;
    char *uri;

    ret = NULL;
    *unhandled_uris = NULL;

    app_table = g_hash_table_new_full
                    ((GHashFunc) mime_application_hash,
                    (GEqualFunc) g_app_info_equal,
                    (GDestroyNotify) g_object_unref,
                    (GDestroyNotify) g_list_free);

    for (l = uris; l != NULL; l = l->next)
    {
        uri = l->data;
        file = nautilus_file_get_by_uri (uri);

        app = nautilus_mime_get_default_application_for_file (file);
        if (app != NULL)
        {
            app_uris = NULL;

            if (g_hash_table_lookup_extended (app_table, app,
                                              (gpointer *) &old_app,
                                              (gpointer *) &app_uris))
            {
                g_hash_table_steal (app_table, old_app);

                app_uris = g_list_prepend (app_uris, uri);

                g_object_unref (app);
                app = old_app;
            }
            else
            {
                app_uris = g_list_prepend (NULL, uri);
            }

            g_hash_table_insert (app_table, app, app_uris);
        }
        else
        {
            *unhandled_uris = g_list_prepend (*unhandled_uris, uri);
        }
        nautilus_file_unref (file);
    }

    g_hash_table_foreach (app_table,
                          (GHFunc) list_to_parameters_foreach,
                          &ret);

    g_hash_table_destroy (app_table);

    *unhandled_uris = g_list_reverse (*unhandled_uris);

    return g_list_reverse (ret);
}

copy_move_file (CopyMoveJob   *copy_job,
GFile         *src,
GFile         *dest_dir,
gboolean       same_fs,
gboolean       unique_names,
char         **dest_fs_type,
SourceInfo    *source_info,
TransferInfo  *transfer_info,
GHashTable    *debuting_files,
GdkPoint      *position,
gboolean       overwrite,
gboolean      *skipped_file,
gboolean       readonly_source_fs)
{
GFile *dest, *new_dest;
g_autofree gchar *dest_uri = NULL;
GError *error;
GFileCopyFlags flags;
char *primary, *secondary, *details;
int response;
ProgressData pdata;
gboolean would_recurse, is_merge;
CommonJob *job;
gboolean res;
int unique_name_nr;
gboolean handled_invalid_filename;

job = (CommonJob *) copy_job;

if (should_skip_file (job, src))
{
*skipped_file = TRUE;
return;
}

unique_name_nr = 1;

/* another file in the same directory might have handled the invalid
* filename condition for us
*/
handled_invalid_filename = *dest_fs_type != NULL;

if (unique_names)
{
dest = get_unique_target_file (src, dest_dir, same_fs, *dest_fs_type, unique_name_nr++);
}
else if (copy_job->target_name != NULL)
{
dest = get_target_file_with_custom_name (src, dest_dir, *dest_fs_type, same_fs,
copy_job->target_name);
}
else
{
dest = get_target_file (src, dest_dir, *dest_fs_type, same_fs);
}

/* Don't allow recursive move/copy into itself.
* (We would get a file system error if we proceeded but it is nicer to
* detect and report it at this level) */
if (test_dir_is_parent (dest_dir, src))
{
if (job->skip_all_error)
{
goto out;
}

/*  the run_warning() frees all strings passed in automatically  */
primary = copy_job->is_move ? g_strdup (_("You cannot move a folder into itself."))
: g_strdup (_("You cannot copy a folder into itself."));
secondary = g_strdup (_("The destination folder is inside the source folder."));

response = run_cancel_or_skip_warning (job,
primary,
secondary,
NULL,
source_info->num_files,
source_info->num_files - transfer_info->num_files);

if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)
{
abort_job (job);
}
else if (response == 1)             /* skip all */
{
job->skip_all_error = TRUE;
}
else if (response == 2)             /* skip */
{               /* do nothing */
}
else
{
g_assert_not_reached ();
}

goto out;
}

/* Don't allow copying over the source or one of the parents of the source.
*/
if (test_dir_is_parent (src, dest))
{
if (job->skip_all_error)
{
goto out;
}

/*  the run_warning() frees all strings passed in automatically  */
primary = copy_job->is_move ? g_strdup (_("You cannot move a file over itself."))
: g_strdup (_("You cannot copy a file over itself."));
secondary = g_strdup (_("The source file would be overwritten by the destination."));

response = run_cancel_or_skip_warning (job,
primary,
secondary,
NULL,
source_info->num_files,
source_info->num_files - transfer_info->num_files);

if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)
{
abort_job (job);
}
else if (response == 1)             /* skip all */
{
job->skip_all_error = TRUE;
}
else if (response == 2)             /* skip */
{               /* do nothing */
}
else
{
g_assert_not_reached ();
}

goto out;
}


retry:

error = NULL;
flags = G_FILE_COPY_NOFOLLOW_SYMLINKS;
if (overwrite)
{
flags |= G_FILE_COPY_OVERWRITE;
}
if (readonly_source_fs)
{
flags |= G_FILE_COPY_TARGET_DEFAULT_PERMS;
}

pdata.job = copy_job;
pdata.last_size = 0;
pdata.source_info = source_info;
pdata.transfer_info = transfer_info;

if (copy_job->is_move)
{
res = g_file_move (src, dest,
flags,
job->cancellable,
copy_file_progress_callback,
&pdata,
&error);
}
else
{
res = g_file_copy (src, dest,
flags,
job->cancellable,
copy_file_progress_callback,
&pdata,
&error);
}

if (res)
{
GFile *real;

real = map_possibly_volatile_file_to_real (dest, job->cancellable, &error);
if (real == NULL)
{
res = FALSE;
}
else
{
g_object_unref (dest);
dest = real;
}
}

if (res)
{
transfer_info->num_files++;
report_copy_progress (copy_job, source_info, transfer_info);

if (debuting_files)
{
dest_uri = g_file_get_uri (dest);
if (position)
{
nautilus_file_changes_queue_schedule_position_set (dest, *position, job->screen_num);
}
else if (eel_uri_is_desktop (dest_uri))
{
nautilus_file_changes_queue_schedule_position_remove (dest);
}

g_hash_table_replace (debuting_files, g_object_ref (dest), GINT_TO_POINTER (TRUE));
}
if (copy_job->is_move)
{
nautilus_file_changes_queue_file_moved (src, dest);
}
else
{
nautilus_file_changes_queue_file_added (dest);
}

/* If copying a trusted desktop file to the desktop,
*  mark it as trusted. */
if (copy_job->desktop_location != NULL &&
g_file_equal (copy_job->desktop_location, dest_dir) &&
is_trusted_desktop_file (src, job->cancellable))
{
            mark_desktop_file_trusted (job,
                                       job->cancellable,
                                       dest,
                                       FALSE);
}

if (job->undo_info != NULL)
{
nautilus_file_undo_info_ext_add_origin_target_pair (NAUTILUS_FILE_UNDO_INFO_EXT (job->undo_info),
src, dest);
}

g_object_unref (dest);
return;
}

if (!handled_invalid_filename &&
IS_IO_ERROR (error, INVALID_FILENAME))
{
handled_invalid_filename = TRUE;

g_assert (*dest_fs_type == NULL);
*dest_fs_type = query_fs_type (dest_dir, job->cancellable);

if (unique_names)
{
new_dest = get_unique_target_file (src, dest_dir, same_fs, *dest_fs_type, unique_name_nr);
}
else
{
new_dest = get_target_file (src, dest_dir, *dest_fs_type, same_fs);
}

if (!g_file_equal (dest, new_dest))
{
g_object_unref (dest);
dest = new_dest;

g_error_free (error);
goto retry;
}
else
{
g_object_unref (new_dest);
}
}

/* Conflict */
if (!overwrite &&
IS_IO_ERROR (error, EXISTS))
{
gboolean is_merge;
FileConflictResponse *response;

g_error_free (error);

if (unique_names)
{
g_object_unref (dest);
dest = get_unique_target_file (src, dest_dir, same_fs, *dest_fs_type, unique_name_nr++);
goto retry;
}

is_merge = FALSE;

if (is_dir (dest) && is_dir (src))
{
is_merge = TRUE;
}

if ((is_merge && job->merge_all) ||
(!is_merge && job->replace_all))
{
overwrite = TRUE;
goto retry;
}

if (job->skip_all_conflict)
{
goto out;
}

response = handle_copy_move_conflict (job, src, dest, dest_dir);

if (response->id == GTK_RESPONSE_CANCEL ||
response->id == GTK_RESPONSE_DELETE_EVENT)
{
file_conflict_response_free (response);
abort_job (job);
}
else if (response->id == CONFLICT_RESPONSE_SKIP)
{
if (response->apply_to_all)
{
job->skip_all_conflict = TRUE;
}
file_conflict_response_free (response);
}
else if (response->id == CONFLICT_RESPONSE_REPLACE)             /* merge/replace */
{
if (response->apply_to_all)
{
if (is_merge)
{
job->merge_all = TRUE;
}
else
{
job->replace_all = TRUE;
}
}
overwrite = TRUE;
file_conflict_response_free (response);
goto retry;
}
else if (response->id == CONFLICT_RESPONSE_RENAME)
{
g_object_unref (dest);
dest = get_target_file_for_display_name (dest_dir,
response->new_name);
file_conflict_response_free (response);
goto retry;
}
else
{
g_assert_not_reached ();
}
}
else if (overwrite &&
IS_IO_ERROR (error, IS_DIRECTORY))
{
gboolean existing_file_deleted;
DeleteExistingFileData data;

g_error_free (error);

data.job = job;
data.source = src;

existing_file_deleted =
delete_file_recursively (dest,
job->cancellable,
existing_file_removed_callback,
&data);

if (existing_file_deleted)
{
goto retry;
}
}
/* Needs to recurse */
else if (IS_IO_ERROR (error, WOULD_RECURSE) ||
IS_IO_ERROR (error, WOULD_MERGE))
{
is_merge = error->code == G_IO_ERROR_WOULD_MERGE;
would_recurse = error->code == G_IO_ERROR_WOULD_RECURSE;
g_error_free (error);

if (overwrite && would_recurse)
{
error = NULL;

/* Copying a dir onto file, first remove the file */
if (!g_file_delete (dest, job->cancellable, &error) &&
!IS_IO_ERROR (error, NOT_FOUND))
{
if (job->skip_all_error)
{
g_error_free (error);
goto out;
}
if (copy_job->is_move)
{
primary = f (_("Error while moving “%B”."), src);
}
else
{
primary = f (_("Error while copying “%B”."), src);
}
secondary = f (_("Could not remove the already existing file with the same name in %F."), dest_dir);
details = error->message;

/* setting TRUE on show_all here, as we could have
* another error on the same file later.
*/
response = run_warning (job,
primary,
secondary,
details,
TRUE,
CANCEL, SKIP_ALL, SKIP,
NULL);

g_error_free (error);

if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)
{
abort_job (job);
}
else if (response == 1)                     /* skip all */
{
job->skip_all_error = TRUE;
}
else if (response == 2)                     /* skip */
{                       /* do nothing */
}
else
{
g_assert_not_reached ();
}
goto out;
}
if (error)
{
g_error_free (error);
error = NULL;
}
nautilus_file_changes_queue_file_removed (dest);
}

if (is_merge)
{
/* On merge we now write in the target directory, which may not
*   be in the same directory as the source, even if the parent is
*   (if the merged directory is a mountpoint). This could cause
*   problems as we then don't transcode filenames.
*   We just set same_fs to FALSE which is safe but a bit slower. */
same_fs = FALSE;
}

if (!copy_move_directory (copy_job, src, &dest, same_fs,
would_recurse, dest_fs_type,
source_info, transfer_info,
debuting_files, skipped_file,
readonly_source_fs))
{
/* destination changed, since it was an invalid file name */
g_assert (*dest_fs_type != NULL);
handled_invalid_filename = TRUE;
goto retry;
}

g_object_unref (dest);
return;
}
else if (IS_IO_ERROR (error, CANCELLED))
{
g_error_free (error);
}
/* Other error */
else
{
if (job->skip_all_error)
{
g_error_free (error);
goto out;
}
primary = f (_("Error while copying “%B”."), src);
secondary = f (_("There was an error copying the file into %F."), dest_dir);
details = error->message;

response = run_cancel_or_skip_warning (job,
primary,
secondary,
details,
source_info->num_files,
source_info->num_files - transfer_info->num_files);

g_error_free (error);

if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)
{
abort_job (job);
}
else if (response == 1)             /* skip all */
{
job->skip_all_error = TRUE;
}
else if (response == 2)             /* skip */
{               /* do nothing */
}
else
{
g_assert_not_reached ();
}
}
out:
*skipped_file = TRUE;     /* Or aborted, but same-same */
g_object_unref (dest);
}

compress_job_on_progress (AutoarCompressor *compressor,
                          guint64           completed_size,
                          guint             completed_files,
                          gpointer          user_data)
{
    CompressJob *compress_job = user_data;
    CommonJob *common = user_data;
    char *status;
    char *details;
    int files_left;
    double elapsed;
    double transfer_rate;
    int remaining_time;

    files_left = compress_job->total_files - completed_files;

    if (compress_job->total_files == 1)
    {
        status = f (_("Compressing “%B” into “%B”"),
                    G_FILE (compress_job->source_files->data),
                    compress_job->output_file);
    }
    else
    {
        status = f (ngettext ("Compressing %'d file into “%B”",
                              "Compressing %'d files into “%B”",
                              compress_job->total_files),
                    compress_job->total_files,
                    compress_job->output_file);
    }

    nautilus_progress_info_take_status (common->progress, status);

    elapsed = g_timer_elapsed (common->time, NULL);

    transfer_rate = 0;
    remaining_time = -1;

    if (elapsed > 0)
    {
        if (completed_size > 0)
        {
            transfer_rate = completed_size / elapsed;
            remaining_time = (compress_job->total_size - completed_size) / transfer_rate;
        }
        else if (completed_files > 0)
        {
            transfer_rate = completed_files / elapsed;
            remaining_time = (compress_job->total_files - completed_files) / transfer_rate;
        }
    }

    if (elapsed < SECONDS_NEEDED_FOR_RELIABLE_TRANSFER_RATE ||
        transfer_rate == 0)
    {
        if (compress_job->total_files == 1)
        {
            /* To translators: %S will expand to a size like "2 bytes" or "3 MB", so something like "4 kb / 4 MB" */
            details = f (_("%S / %S"), completed_size, compress_job->total_size);
        }
        else
        {
            details = f (_("%'d / %'d"),
                         files_left > 0 ? completed_files + 1 : completed_files,
                         compress_job->total_files);
        }
    }
    else
    {
        if (compress_job->total_files == 1)
        {
            if (files_left > 0)
            {
                /* To translators: %S will expand to a size like "2 bytes" or "3 MB", %T to a time duration like
                 * "2 minutes". So the whole thing will be something like "2 kb / 4 MB -- 2 hours left (4kb/sec)"
                 *
                 * The singular/plural form will be used depending on the remaining time (i.e. the %T argument).
                 */
                details = f (ngettext ("%S / %S \xE2\x80\x94 %T left (%S/sec)",
                                       "%S / %S \xE2\x80\x94 %T left (%S/sec)",
                                       seconds_count_format_time_units (remaining_time)),
                             completed_size, compress_job->total_size,
                             remaining_time,
                             (goffset) transfer_rate);
            }
            else
            {
                /* To translators: %S will expand to a size like "2 bytes" or "3 MB". */
                details = f (_("%S / %S"),
                             completed_size,
                             compress_job->total_size);
            }
        }
        else
        {
            if (files_left > 0)
            {
                /* To translators: %T will expand to a time duration like "2 minutes".
                 * So the whole thing will be something like "1 / 5 -- 2 hours left (4kb/sec)"
                 *
                 * The singular/plural form will be used depending on the remaining time (i.e. the %T argument).
                 */
                details = f (ngettext ("%'d / %'d \xE2\x80\x94 %T left (%S/sec)",
                                       "%'d / %'d \xE2\x80\x94 %T left (%S/sec)",
                                       seconds_count_format_time_units (remaining_time)),
                             completed_files + 1, compress_job->total_files,
                             remaining_time,
                             (goffset) transfer_rate);
            }
            else
            {
                /* To translators: %'d is the number of files completed for the operation,
                 * so it will be something like 2/14. */
                details = f (_("%'d / %'d"),
                             completed_files,
                             compress_job->total_files);
            }
        }
    }

    nautilus_progress_info_take_details (common->progress, details);

    if (elapsed > SECONDS_NEEDED_FOR_APROXIMATE_TRANSFER_RATE)
    {
        nautilus_progress_info_set_remaining_time (common->progress,
                                                   remaining_time);
        nautilus_progress_info_set_elapsed_time (common->progress,
                                                 elapsed);
    }

    nautilus_progress_info_set_progress (common->progress,
                                         completed_size,
                                         compress_job->total_size);
}

run_warning (CommonJob  *job,
             char       *primary_text,
             char       *secondary_text,
             const char *details_text,
             gboolean    show_all,
             ...)
{
    va_list varargs;
    int res;

    va_start (varargs, show_all);
    res = run_simple_dialog_va (job,
                                FALSE,
                                GTK_MESSAGE_WARNING,
                                primary_text,
                                secondary_text,
                                details_text,
                                show_all,
                                varargs);
    va_end (varargs);
    return res;
}

istr_set_new (void)
{
    return g_hash_table_new_full (istr_hash, istr_equal, g_free, NULL);
}

custom_size_to_string (char    *format,
                       va_list  va)
{
    goffset size;

    size = va_arg (va, goffset);
    return g_format_size (size);
}

nautilus_file_operations_copy (GList                *files,
                               GArray               *relative_item_points,
                               GFile                *target_dir,
                               GtkWindow            *parent_window,
                               NautilusCopyCallback  done_callback,
                               gpointer              done_callback_data)
{
    GTask *task;
    CopyMoveJob *job;

    job = op_job_new (CopyMoveJob, parent_window);
    job->desktop_location = nautilus_get_desktop_location ();
    job->done_callback = done_callback;
    job->done_callback_data = done_callback_data;
    job->files = g_list_copy_deep (files, (GCopyFunc) g_object_ref, NULL);
    job->destination = g_object_ref (target_dir);
    /* Need to indicate the destination for the operation notification open
     * button. */
    nautilus_progress_info_set_destination (((CommonJob *) job)->progress, target_dir);
    if (relative_item_points != NULL &&
        relative_item_points->len > 0)
    {
        job->icon_positions =
            g_memdup (relative_item_points->data,
                      sizeof (GdkPoint) * relative_item_points->len);
        job->n_icon_positions = relative_item_points->len;
    }
    job->debuting_files = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);

    inhibit_power_manager ((CommonJob *) job, _("Copying Files"));

    if (!nautilus_file_undo_manager_is_operating ())
    {
        GFile *src_dir;

        src_dir = g_file_get_parent (files->data);
        job->common.undo_info = nautilus_file_undo_info_ext_new (NAUTILUS_FILE_UNDO_OP_COPY,
                                                                 g_list_length (files),
                                                                 src_dir, target_dir);

        g_object_unref (src_dir);
    }

    task = g_task_new (NULL, job->common.cancellable, copy_task_done, job);
    g_task_set_task_data (task, job, NULL);
    g_task_run_in_thread (task, copy_task_thread_func);
    g_object_unref (task);
}

copy_move_directory (CopyMoveJob   *copy_job,
                     GFile         *src,
                     GFile        **dest,
                     gboolean       same_fs,
                     gboolean       create_dest,
                     char         **parent_dest_fs_type,
                     SourceInfo    *source_info,
                     TransferInfo  *transfer_info,
                     GHashTable    *debuting_files,
                     gboolean      *skipped_file,
                     gboolean       readonly_source_fs)
{
    GFileInfo *info;
    GError *error;
    GFile *src_file;
    GFileEnumerator *enumerator;
    char *primary, *secondary, *details;
    char *dest_fs_type;
    int response;
    gboolean skip_error;
    gboolean local_skipped_file;
    CommonJob *job;
    GFileCopyFlags flags;

    job = (CommonJob *) copy_job;

    if (create_dest)
    {
        switch (create_dest_dir (job, src, dest, same_fs, parent_dest_fs_type))
        {
            case CREATE_DEST_DIR_RETRY:
            {
                /* next time copy_move_directory() is called,
                 * create_dest will be FALSE if a directory already
                 * exists under the new name (i.e. WOULD_RECURSE)
                 */
                return FALSE;
            }

            case CREATE_DEST_DIR_FAILED:
            {
                *skipped_file = TRUE;
                return TRUE;
            }

            case CREATE_DEST_DIR_SUCCESS:
            default:
            {
            }
            break;
        }

        if (debuting_files)
        {
            g_hash_table_replace (debuting_files, g_object_ref (*dest), GINT_TO_POINTER (TRUE));
        }
    }

    local_skipped_file = FALSE;
    dest_fs_type = NULL;

    skip_error = should_skip_readdir_error (job, src);
retry:
    error = NULL;
    enumerator = g_file_enumerate_children (src,
                                            G_FILE_ATTRIBUTE_STANDARD_NAME,
                                            G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,
                                            job->cancellable,
                                            &error);
    if (enumerator)
    {
        error = NULL;

        while (!job_aborted (job) &&
               (info = g_file_enumerator_next_file (enumerator, job->cancellable, skip_error ? NULL : &error)) != NULL)
        {
            src_file = g_file_get_child (src,
                                         g_file_info_get_name (info));
            copy_move_file (copy_job, src_file, *dest, same_fs, FALSE, &dest_fs_type,
                            source_info, transfer_info, NULL, NULL, FALSE, &local_skipped_file,
                            readonly_source_fs);

            if (local_skipped_file)
            {
                transfer_add_file_to_count (src_file, job, transfer_info);
                report_copy_progress (copy_job, source_info, transfer_info);
            }

            g_object_unref (src_file);
            g_object_unref (info);
        }
        g_file_enumerator_close (enumerator, job->cancellable, NULL);
        g_object_unref (enumerator);

        if (error && IS_IO_ERROR (error, CANCELLED))
        {
            g_error_free (error);
        }
        else if (error)
        {
            if (copy_job->is_move)
            {
                primary = f (_("Error while moving."));
            }
            else
            {
                primary = f (_("Error while copying."));
            }
            details = NULL;

            if (IS_IO_ERROR (error, PERMISSION_DENIED))
            {
                secondary = f (_("Files in the folder “%B” cannot be copied because you do "
                                 "not have permissions to see them."), src);
            }
            else
            {
                secondary = f (_("There was an error getting information about the files in the folder “%B”."), src);
                details = error->message;
            }

            response = run_warning (job,
                                    primary,
                                    secondary,
                                    details,
                                    FALSE,
                                    CANCEL, _("_Skip files"),
                                    NULL);

            g_error_free (error);

            if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)
            {
                abort_job (job);
            }
            else if (response == 1)
            {
                /* Skip: Do Nothing */
                local_skipped_file = TRUE;
            }
            else
            {
                g_assert_not_reached ();
            }
        }

        /* Count the copied directory as a file */
        transfer_info->num_files++;
        report_copy_progress (copy_job, source_info, transfer_info);

        if (debuting_files)
        {
            g_hash_table_replace (debuting_files, g_object_ref (*dest), GINT_TO_POINTER (create_dest));
        }
    }
    else if (IS_IO_ERROR (error, CANCELLED))
    {
        g_error_free (error);
    }
    else
    {
        if (copy_job->is_move)
        {
            primary = f (_("Error while moving."));
        }
        else
        {
            primary = f (_("Error while copying."));
        }
        details = NULL;

        if (IS_IO_ERROR (error, PERMISSION_DENIED))
        {
            secondary = f (_("The folder “%B” cannot be copied because you do not have "
                             "permissions to read it."), src);
        }
        else
        {
            secondary = f (_("There was an error reading the folder “%B”."), src);
            details = error->message;
        }

        response = run_warning (job,
                                primary,
                                secondary,
                                details,
                                FALSE,
                                CANCEL, SKIP, RETRY,
                                NULL);

        g_error_free (error);

        if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)
        {
            abort_job (job);
        }
        else if (response == 1)
        {
            /* Skip: Do Nothing  */
            local_skipped_file = TRUE;
        }
        else if (response == 2)
        {
            goto retry;
        }
        else
        {
            g_assert_not_reached ();
        }
    }

    if (create_dest)
    {
        flags = (readonly_source_fs) ? G_FILE_COPY_NOFOLLOW_SYMLINKS | G_FILE_COPY_TARGET_DEFAULT_PERMS
                : G_FILE_COPY_NOFOLLOW_SYMLINKS;
        /* Ignore errors here. Failure to copy metadata is not a hard error */
        g_file_copy_attributes (src, *dest,
                                flags,
                                job->cancellable, NULL);
    }

    if (!job_aborted (job) && copy_job->is_move &&
        /* Don't delete source if there was a skipped file */
        !local_skipped_file)
    {
        if (!g_file_delete (src, job->cancellable, &error))
        {
            if (job->skip_all_error)
            {
                goto skip;
            }
            primary = f (_("Error while moving “%B”."), src);
            secondary = f (_("Could not remove the source folder."));
            details = error->message;

            response = run_cancel_or_skip_warning (job,
                                                   primary,
                                                   secondary,
                                                   details,
                                                   source_info->num_files,
                                                   source_info->num_files - transfer_info->num_files);

            if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)
            {
                abort_job (job);
            }
            else if (response == 1)                 /* skip all */
            {
                job->skip_all_error = TRUE;
                local_skipped_file = TRUE;
            }
            else if (response == 2)                 /* skip */
            {
                local_skipped_file = TRUE;
            }
            else
            {
                g_assert_not_reached ();
            }

skip:
            g_error_free (error);
        }
    }

    if (local_skipped_file)
    {
        *skipped_file = TRUE;
    }

    g_free (dest_fs_type);
    return TRUE;
}

file_compare_by_mime_type (NautilusFile *file_a,
                           NautilusFile *file_b)
{
    char *mime_type_a, *mime_type_b;
    int ret;

    mime_type_a = nautilus_file_get_mime_type (file_a);
    mime_type_b = nautilus_file_get_mime_type (file_b);

    ret = strcmp (mime_type_a, mime_type_b);

    g_free (mime_type_a);
    g_free (mime_type_b);

    return ret;
}

custom_basename_skip (va_list *va)
{
    (void) va_arg (*va, GFile *);
}

start_or_stop_io (NautilusDirectory *directory)
{
    NautilusFile *file;
    gboolean doing_io;

    /* Start or stop reading files. */
    file_list_start_or_stop (directory);

    /* Stop any no longer wanted attribute fetches. */
    file_info_stop (directory);
    directory_count_stop (directory);
    deep_count_stop (directory);
    mime_list_stop (directory);
    link_info_stop (directory);
    extension_info_stop (directory);
    mount_stop (directory);
    thumbnail_stop (directory);
    filesystem_info_stop (directory);

    doing_io = FALSE;
    /* Take files that are all done off the queue. */
    while (!nautilus_file_queue_is_empty (directory->details->high_priority_queue))
    {
        file = nautilus_file_queue_head (directory->details->high_priority_queue);

        /* Start getting attributes if possible */
        file_info_start (directory, file, &doing_io);
        link_info_start (directory, file, &doing_io);

        if (doing_io)
        {
            return;
        }

        move_file_to_low_priority_queue (directory, file);
    }

    /* High priority queue must be empty */
    while (!nautilus_file_queue_is_empty (directory->details->low_priority_queue))
    {
        file = nautilus_file_queue_head (directory->details->low_priority_queue);

        /* Start getting attributes if possible */
        mount_start (directory, file, &doing_io);
        directory_count_start (directory, file, &doing_io);
        deep_count_start (directory, file, &doing_io);
        mime_list_start (directory, file, &doing_io);
        thumbnail_start (directory, file, &doing_io);
        filesystem_info_start (directory, file, &doing_io);

        if (doing_io)
        {
            return;
        }

        move_file_to_extension_queue (directory, file);
    }

    /* Low priority queue must be empty */
    while (!nautilus_file_queue_is_empty (directory->details->extension_queue))
    {
        file = nautilus_file_queue_head (directory->details->extension_queue);

        /* Start getting attributes if possible */
        extension_info_start (directory, file, &doing_io);
        if (doing_io)
        {
            return;
        }

        nautilus_directory_remove_file_from_work_queue (directory, file);
    }
}

nautilus_file_operations_copy_file (GFile                *source_file,
                                    GFile                *target_dir,
                                    const gchar          *source_display_name,
                                    const gchar          *new_name,
                                    GtkWindow            *parent_window,
                                    NautilusCopyCallback  done_callback,
                                    gpointer              done_callback_data)
{
    GTask *task;
    CopyMoveJob *job;

    job = op_job_new (CopyMoveJob, parent_window);
    job->done_callback = done_callback;
    job->done_callback_data = done_callback_data;
    job->files = g_list_append (NULL, g_object_ref (source_file));
    job->destination = g_object_ref (target_dir);
    /* Need to indicate the destination for the operation notification open
     * button. */
    nautilus_progress_info_set_destination (((CommonJob *) job)->progress, target_dir);
    job->target_name = g_strdup (new_name);
    job->debuting_files = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);

    if (source_display_name != NULL)
    {
        gchar *path;

        path = g_build_filename ("/", source_display_name, NULL);
        job->fake_display_source = g_file_new_for_path (path);

        g_free (path);
    }

    inhibit_power_manager ((CommonJob *) job, _("Copying Files"));

    task = g_task_new (NULL, job->common.cancellable, copy_task_done, job);
    g_task_set_task_data (task, job, NULL);
    g_task_run_in_thread (task, copy_task_thread_func);
    g_object_unref (task);
}

mime_list_state_free (MimeListState *state)
{
    if (state->enumerator)
    {
        if (!g_file_enumerator_is_closed (state->enumerator))
        {
            g_file_enumerator_close_async (state->enumerator,
                                           0, NULL, NULL, NULL);
        }
        g_object_unref (state->enumerator);
    }
    g_object_unref (state->cancellable);
    istr_set_destroy (state->mime_list_hash);
    nautilus_directory_unref (state->directory);
    g_free (state);
}

empty_trash_thread_func (GTask        *task,
                         gpointer      source_object,
                         gpointer      task_data,
                         GCancellable *cancellable)
{
    EmptyTrashJob *job = task_data;
    CommonJob *common;
    GList *l;
    gboolean confirmed;

    common = (CommonJob *) job;

    nautilus_progress_info_start (job->common.progress);

    if (job->should_confirm)
    {
        confirmed = confirm_empty_trash (common);
    }
    else
    {
        confirmed = TRUE;
    }
    if (confirmed)
    {
        for (l = job->trash_dirs;
             l != NULL && !job_aborted (common);
             l = l->next)
        {
            delete_trash_file (common, l->data, FALSE, TRUE);
        }
    }
}

unmount_mount_callback (GObject      *source_object,
                        GAsyncResult *res,
                        gpointer      user_data)
{
    UnmountData *data = user_data;
    GError *error;
    char *primary;
    gboolean unmounted;

    error = NULL;
    if (data->eject)
    {
        unmounted = g_mount_eject_with_operation_finish (G_MOUNT (source_object),
                                                         res, &error);
    }
    else
    {
        unmounted = g_mount_unmount_with_operation_finish (G_MOUNT (source_object),
                                                           res, &error);
    }

    if (!unmounted)
    {
        if (error->code != G_IO_ERROR_FAILED_HANDLED)
        {
            if (data->eject)
            {
                primary = f (_("Unable to eject %V"), source_object);
            }
            else
            {
                primary = f (_("Unable to unmount %V"), source_object);
            }
            eel_show_error_dialog (primary,
                                   error->message,
                                   data->parent_window);
            g_free (primary);
        }
    }

    if (data->callback)
    {
        data->callback (data->callback_data);
    }

    if (error != NULL)
    {
        g_error_free (error);
    }

    unmount_data_free (data);
}

extract_task_done (GObject      *source_object,
                   GAsyncResult *res,
                   gpointer      user_data)
{
    ExtractJob *extract_job;

    extract_job = user_data;

    if (extract_job->done_callback)
    {
        extract_job->done_callback (extract_job->output_files,
                                    extract_job->done_callback_data);
    }

    g_list_free_full (extract_job->source_files, g_object_unref);
    g_list_free_full (extract_job->output_files, g_object_unref);
    g_object_unref (extract_job->destination_directory);

    finalize_common ((CommonJob *) extract_job);

    nautilus_file_changes_consume_changes (TRUE);
}

handle_copy_move_conflict (CommonJob *job,
                           GFile     *src,
                           GFile     *dest,
                           GFile     *dest_dir)
{
    FileConflictResponse *response;

    g_timer_stop (job->time);
    nautilus_progress_info_pause (job->progress);

    response = copy_move_conflict_ask_user_action (job->parent_window,
                                                   src,
                                                   dest,
                                                   dest_dir);

    nautilus_progress_info_resume (job->progress);
    g_timer_continue (job->time);

    return response;
}

cancel_filesystem_info_for_file (NautilusDirectory *directory,
                                 NautilusFile      *file)
{
    if (directory->details->filesystem_info_state != NULL &&
        directory->details->filesystem_info_state->file == file)
    {
        filesystem_info_cancel (directory);
    }
}

new_files_cancel (NautilusDirectory *directory)
{
    GList *l;
    NewFilesState *state;

    if (directory->details->new_files_in_progress != NULL)
    {
        for (l = directory->details->new_files_in_progress; l != NULL; l = l->next)
        {
            state = l->data;
            g_cancellable_cancel (state->cancellable);
            state->directory = NULL;
        }
        g_list_free (directory->details->new_files_in_progress);
        directory->details->new_files_in_progress = NULL;
    }
}

mount_state_free (MountState *state)
{
    g_object_unref (state->cancellable);
    g_free (state);
}

nautilus_directory_async_state_changed (NautilusDirectory *directory)
{
    /* Check if any callbacks are satisfied and call them if they
     * are. Do this last so that any changes done in start or stop
     * I/O functions immediately (not in callbacks) are taken into
     * consideration. If any callbacks are called, consider the
     * I/O state again so that we can release or cancel I/O that
     * is not longer needed once the callbacks are satisfied.
     */

    if (directory->details->in_async_service_loop)
    {
        directory->details->state_changed = TRUE;
        return;
    }
    directory->details->in_async_service_loop = TRUE;
    nautilus_directory_ref (directory);
    do
    {
        directory->details->state_changed = FALSE;
        start_or_stop_io (directory);
        if (call_ready_callbacks (directory))
        {
            directory->details->state_changed = TRUE;
        }
    }
    while (directory->details->state_changed);
    directory->details->in_async_service_loop = FALSE;
    nautilus_directory_unref (directory);

    /* Check if any directories should wake up. */
    async_job_wake_up ();
}

nautilus_metadata_get_id (const char *metadata)
{
    static GHashTable *hash;
    int i;

    if (hash == NULL)
    {
        hash = g_hash_table_new (g_str_hash, g_str_equal);
        for (i = 0; used_metadata_names[i] != NULL; i++)
        {
            g_hash_table_insert (hash,
                                 used_metadata_names[i],
                                 GINT_TO_POINTER (i + 1));
        }
    }

    return GPOINTER_TO_INT (g_hash_table_lookup (hash, metadata));
}

nautilus_directory_cancel_loading_file_attributes (NautilusDirectory      *directory,
                                                   NautilusFile           *file,
                                                   NautilusFileAttributes  file_attributes)
{
    Request request;

    nautilus_directory_remove_file_from_work_queue (directory, file);

    request = nautilus_directory_set_up_request (file_attributes);

    if (REQUEST_WANTS_TYPE (request, REQUEST_DIRECTORY_COUNT))
    {
        cancel_directory_count_for_file (directory, file);
    }
    if (REQUEST_WANTS_TYPE (request, REQUEST_DEEP_COUNT))
    {
        cancel_deep_counts_for_file (directory, file);
    }
    if (REQUEST_WANTS_TYPE (request, REQUEST_MIME_LIST))
    {
        cancel_mime_list_for_file (directory, file);
    }
    if (REQUEST_WANTS_TYPE (request, REQUEST_FILE_INFO))
    {
        cancel_file_info_for_file (directory, file);
    }
    if (REQUEST_WANTS_TYPE (request, REQUEST_FILESYSTEM_INFO))
    {
        cancel_filesystem_info_for_file (directory, file);
    }
    if (REQUEST_WANTS_TYPE (request, REQUEST_LINK_INFO))
    {
        cancel_link_info_for_file (directory, file);
    }
    if (REQUEST_WANTS_TYPE (request, REQUEST_THUMBNAIL))
    {
        cancel_thumbnail_for_file (directory, file);
    }
    if (REQUEST_WANTS_TYPE (request, REQUEST_MOUNT))
    {
        cancel_mount_for_file (directory, file);
    }

    nautilus_directory_async_state_changed (directory);
}

find_monitor (NautilusDirectory *directory,
              NautilusFile      *file,
              gconstpointer      client)
{
    Monitor monitor;

    monitor.client = client;
    monitor.file = file;

    return g_list_find_custom (directory->details->monitor_list,
                               &monitor,
                               monitor_key_compare);
}

transfer_add_file_to_count (GFile        *file,
                            CommonJob    *job,
                            TransferInfo *transfer_info)
{
    g_autoptr (GFileInfo) file_info = NULL;

    if (g_cancellable_is_cancelled (job->cancellable))
    {
        return;
    }

    file_info = g_file_query_info (file,
                                   G_FILE_ATTRIBUTE_STANDARD_SIZE,
                                   G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,
                                   job->cancellable,
                                   NULL);

    transfer_info->num_files++;
    if (file_info != NULL)
    {
        transfer_info->num_bytes += g_file_info_get_size (file_info);
    }
}

copy_file_progress_callback (goffset  current_num_bytes,
                             goffset  total_num_bytes,
                             gpointer user_data)
{
    ProgressData *pdata;
    goffset new_size;

    pdata = user_data;

    new_size = current_num_bytes - pdata->last_size;

    if (new_size > 0)
    {
        pdata->transfer_info->num_bytes += new_size;
        pdata->last_size = current_num_bytes;
        report_copy_progress (pdata->job,
                              pdata->source_info,
                              pdata->transfer_info);
    }
}

find_enclosing_mount_callback (GObject      *source_object,
                               GAsyncResult *res,
                               gpointer      user_data)
{
    GMount *mount;
    MountState *state;
    GFile *location, *root;

    state = user_data;
    if (state->directory == NULL)
    {
        /* Operation was cancelled. Bail out */
        mount_state_free (state);
        return;
    }

    mount = g_file_find_enclosing_mount_finish (G_FILE (source_object),
                                                res, NULL);

    if (mount)
    {
        root = g_mount_get_root (mount);
        location = nautilus_file_get_location (state->file);
        if (!g_file_equal (location, root))
        {
            g_object_unref (mount);
            mount = NULL;
        }
        g_object_unref (root);
        g_object_unref (location);
    }

    got_mount (state, mount);

    if (mount)
    {
        g_object_unref (mount);
    }
}

custom_mount_to_string (char    *format,
                        va_list  va)
{
    GMount *mount;

    mount = va_arg (va, GMount *);
    return g_mount_get_name (mount);
}

directory_count_start (NautilusDirectory *directory,
                       NautilusFile      *file,
                       gboolean          *doing_io)
{
    DirectoryCountState *state;
    GFile *location;

    if (directory->details->count_in_progress != NULL)
    {
        *doing_io = TRUE;
        return;
    }

    if (!is_needy (file,
                   should_get_directory_count_now,
                   REQUEST_DIRECTORY_COUNT))
    {
        return;
    }
    *doing_io = TRUE;

    if (!nautilus_file_is_directory (file))
    {
        file->details->directory_count_is_up_to_date = TRUE;
        file->details->directory_count_failed = FALSE;
        file->details->got_directory_count = FALSE;

        nautilus_directory_async_state_changed (directory);
        return;
    }

    if (!async_job_start (directory, "directory count"))
    {
        return;
    }

    /* Start counting. */
    state = g_new0 (DirectoryCountState, 1);
    state->count_file = file;
    state->directory = nautilus_directory_ref (directory);
    state->cancellable = g_cancellable_new ();

    directory->details->count_in_progress = state;

    location = nautilus_file_get_location (file);
#ifdef DEBUG_LOAD_DIRECTORY
    {
        char *uri;
        uri = g_file_get_uri (location);
        g_message ("load_directory called to get shallow file count for %s", uri);
        g_free (uri);
    }
#endif

    g_file_enumerate_children_async (location,
                                     G_FILE_ATTRIBUTE_STANDARD_NAME ","
                                     G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN ","
                                     G_FILE_ATTRIBUTE_STANDARD_IS_BACKUP,
                                     G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,     /* flags */
                                     G_PRIORITY_DEFAULT,     /* prio */
                                     state->cancellable,
                                     count_children_callback,
                                     state);
    g_object_unref (location);
}

ready_callback_call (NautilusDirectory   *directory,
                     const ReadyCallback *callback)
{
    GList *file_list;

    /* Call the callback. */
    if (callback->file != NULL)
    {
        if (callback->callback.file)
        {
            (*callback->callback.file)(callback->file,
                                       callback->callback_data);
        }
    }
    else if (callback->callback.directory != NULL)
    {
        if (directory == NULL ||
            !REQUEST_WANTS_TYPE (callback->request, REQUEST_FILE_LIST))
        {
            file_list = NULL;
        }
        else
        {
            file_list = nautilus_directory_get_file_list (directory);
        }

        /* Pass back the file list if the user was waiting for it. */
        (*callback->callback.directory)(directory,
                                        file_list,
                                        callback->callback_data);

        nautilus_file_list_free (file_list);
    }
}

move_files (CopyMoveJob   *job,
            GList         *fallbacks,
            const char    *dest_fs_id,
            char         **dest_fs_type,
            SourceInfo    *source_info,
            TransferInfo  *transfer_info)
{
    CommonJob *common;
    GList *l;
    GFile *src;
    gboolean same_fs;
    int i;
    GdkPoint *point;
    gboolean skipped_file;
    MoveFileCopyFallback *fallback;
    common = &job->common;

    report_copy_progress (job, source_info, transfer_info);

    i = 0;
    for (l = fallbacks;
         l != NULL && !job_aborted (common);
         l = l->next)
    {
        fallback = l->data;
        src = fallback->file;

        if (fallback->has_position)
        {
            point = &fallback->position;
        }
        else
        {
            point = NULL;
        }

        same_fs = FALSE;
        if (dest_fs_id)
        {
            same_fs = has_fs_id (src, dest_fs_id);
        }

        /* Set overwrite to true, as the user has
         *  selected overwrite on all toplevel items */
        skipped_file = FALSE;
        copy_move_file (job, src, job->destination,
                        same_fs, FALSE, dest_fs_type,
                        source_info, transfer_info,
                        job->debuting_files,
                        point, fallback->overwrite, &skipped_file, FALSE);
        i++;

        if (skipped_file)
        {
            transfer_add_file_to_count (src, common, transfer_info);
            report_copy_progress (job, source_info, transfer_info);
        }
    }
}

nautilus_directory_set_up_request (NautilusFileAttributes file_attributes)
{
    Request request;

    request = 0;

    if ((file_attributes & NAUTILUS_FILE_ATTRIBUTE_DIRECTORY_ITEM_COUNT) != 0)
    {
        REQUEST_SET_TYPE (request, REQUEST_DIRECTORY_COUNT);
    }

    if ((file_attributes & NAUTILUS_FILE_ATTRIBUTE_DEEP_COUNTS) != 0)
    {
        REQUEST_SET_TYPE (request, REQUEST_DEEP_COUNT);
    }

    if ((file_attributes & NAUTILUS_FILE_ATTRIBUTE_DIRECTORY_ITEM_MIME_TYPES) != 0)
    {
        REQUEST_SET_TYPE (request, REQUEST_MIME_LIST);
    }
    if ((file_attributes & NAUTILUS_FILE_ATTRIBUTE_INFO) != 0)
    {
        REQUEST_SET_TYPE (request, REQUEST_FILE_INFO);
    }

    if (file_attributes & NAUTILUS_FILE_ATTRIBUTE_LINK_INFO)
    {
        REQUEST_SET_TYPE (request, REQUEST_FILE_INFO);
        REQUEST_SET_TYPE (request, REQUEST_LINK_INFO);
    }

    if ((file_attributes & NAUTILUS_FILE_ATTRIBUTE_EXTENSION_INFO) != 0)
    {
        REQUEST_SET_TYPE (request, REQUEST_EXTENSION_INFO);
    }

    if (file_attributes & NAUTILUS_FILE_ATTRIBUTE_THUMBNAIL)
    {
        REQUEST_SET_TYPE (request, REQUEST_THUMBNAIL);
        REQUEST_SET_TYPE (request, REQUEST_FILE_INFO);
    }

    if (file_attributes & NAUTILUS_FILE_ATTRIBUTE_MOUNT)
    {
        REQUEST_SET_TYPE (request, REQUEST_MOUNT);
        REQUEST_SET_TYPE (request, REQUEST_FILE_INFO);
    }

    if (file_attributes & NAUTILUS_FILE_ATTRIBUTE_FILESYSTEM_INFO)
    {
        REQUEST_SET_TYPE (request, REQUEST_FILESYSTEM_INFO);
    }

    return request;
}

should_get_directory_count_now (NautilusFile *file)
{
    return lacks_directory_count (file)
           && !file->details->loading_directory;
}

remove_callback_link (NautilusDirectory *directory,
                      GList             *link)
{
    ReadyCallback *callback;

    callback = link->data;
    remove_callback_link_keep_data (directory, link);
    g_free (callback);
}

mount_stop (NautilusDirectory *directory)
{
    NautilusFile *file;

    if (directory->details->mount_state != NULL)
    {
        file = directory->details->mount_state->file;

        if (file != NULL)
        {
            g_assert (NAUTILUS_IS_FILE (file));
            g_assert (file->details->directory == directory);
            if (is_needy (file,
                          lacks_mount,
                          REQUEST_MOUNT))
            {
                return;
            }
        }

        /* The link info is not wanted, so stop it. */
        mount_cancel (directory);
    }
}

init_common (gsize      job_size,
             GtkWindow *parent_window)
{
    CommonJob *common;
    GdkScreen *screen;

    common = g_malloc0 (job_size);

    if (parent_window)
    {
        common->parent_window = parent_window;
        g_object_add_weak_pointer (G_OBJECT (common->parent_window),
                                   (gpointer *) &common->parent_window);
    }
    common->progress = nautilus_progress_info_new ();
    common->cancellable = nautilus_progress_info_get_cancellable (common->progress);
    common->time = g_timer_new ();
    common->inhibit_cookie = 0;
    common->screen_num = 0;
    if (parent_window)
    {
        screen = gtk_widget_get_screen (GTK_WIDGET (parent_window));
        common->screen_num = gdk_screen_get_number (screen);
    }

    return common;
}

mount_cancel (NautilusDirectory *directory)
{
    if (directory->details->mount_state != NULL)
    {
        g_cancellable_cancel (directory->details->mount_state->cancellable);
        directory->details->mount_state->directory = NULL;
        directory->details->mount_state = NULL;
        async_job_end (directory, "mount");
    }
}

nautilus_file_operations_unmount_mount_full (GtkWindow               *parent_window,
                                             GMount                  *mount,
                                             GMountOperation         *mount_operation,
                                             gboolean                 eject,
                                             gboolean                 check_trash,
                                             NautilusUnmountCallback  callback,
                                             gpointer                 callback_data)
{
    UnmountData *data;
    int response;

    data = g_new0 (UnmountData, 1);
    data->callback = callback;
    data->callback_data = callback_data;
    if (parent_window)
    {
        data->parent_window = parent_window;
        g_object_add_weak_pointer (G_OBJECT (data->parent_window),
                                   (gpointer *) &data->parent_window);
    }
    if (mount_operation)
    {
        data->mount_operation = g_object_ref (mount_operation);
    }
    data->eject = eject;
    data->mount = g_object_ref (mount);

    if (check_trash && has_trash_files (mount))
    {
        response = prompt_empty_trash (parent_window);

        if (response == GTK_RESPONSE_ACCEPT)
        {
            GTask *task;
            EmptyTrashJob *job;

            job = op_job_new (EmptyTrashJob, parent_window);
            job->should_confirm = FALSE;
            job->trash_dirs = get_trash_dirs_for_mount (mount);
            job->done_callback = empty_trash_for_unmount_done;
            job->done_callback_data = data;

            task = g_task_new (NULL, NULL, empty_trash_task_done, job);
            g_task_set_task_data (task, job, NULL);
            g_task_run_in_thread (task, empty_trash_thread_func);
            g_object_unref (task);
            return;
        }
        else if (response == GTK_RESPONSE_CANCEL)
        {
            if (callback)
            {
                callback (callback_data);
            }

            unmount_data_free (data);
            return;
        }
    }

    do_unmount (data);
}

mime_list_stop (NautilusDirectory *directory)
{
    NautilusFile *file;

    if (directory->details->mime_list_in_progress != NULL)
    {
        file = directory->details->mime_list_in_progress->mime_list_file;
        if (file != NULL)
        {
            g_assert (NAUTILUS_IS_FILE (file));
            g_assert (file->details->directory == directory);
            if (is_needy (file,
                          should_get_mime_list,
                          REQUEST_MIME_LIST))
            {
                return;
            }
        }

        /* The count is not wanted, so stop it. */
        mime_list_cancel (directory);
    }
}

trash_or_delete_internal (GList                  *files,
                          GtkWindow              *parent_window,
                          gboolean                try_trash,
                          NautilusDeleteCallback  done_callback,
                          gpointer                done_callback_data)
{
    GTask *task;
    DeleteJob *job;

    /* TODO: special case desktop icon link files ... */

    job = op_job_new (DeleteJob, parent_window);
    job->files = g_list_copy_deep (files, (GCopyFunc) g_object_ref, NULL);
    job->try_trash = try_trash;
    job->user_cancel = FALSE;
    job->done_callback = done_callback;
    job->done_callback_data = done_callback_data;

    if (try_trash)
    {
        inhibit_power_manager ((CommonJob *) job, _("Trashing Files"));
    }
    else
    {
        inhibit_power_manager ((CommonJob *) job, _("Deleting Files"));
    }

    if (!nautilus_file_undo_manager_is_operating () && try_trash)
    {
        job->common.undo_info = nautilus_file_undo_info_trash_new (g_list_length (files));
    }

    task = g_task_new (NULL, NULL, delete_task_done, job);
    g_task_set_task_data (task, job, NULL);
    g_task_run_in_thread (task, delete_task_thread_func);
    g_object_unref (task);
}

custom_size_skip (va_list *va)
{
    (void) va_arg (*va, goffset);
}

lacks_mime_list (NautilusFile *file)
{
    return !file->details->mime_list_is_up_to_date;
}

confirm_delete_directly (CommonJob *job,
                         GList     *files)
{
    char *prompt;
    int file_count;
    int response;

    /* Just Say Yes if the preference says not to confirm. */
    if (!should_confirm_trash ())
    {
        return TRUE;
    }

    file_count = g_list_length (files);
    g_assert (file_count > 0);

    if (can_delete_files_without_confirm (files))
    {
        return TRUE;
    }

    if (file_count == 1)
    {
        prompt = f (_("Are you sure you want to permanently delete “%B”?"),
                    files->data);
    }
    else
    {
        prompt = f (ngettext ("Are you sure you want to permanently delete "
                              "the %'d selected item?",
                              "Are you sure you want to permanently delete "
                              "the %'d selected items?", file_count),
                    file_count);
    }

    response = run_warning (job,
                            prompt,
                            f (_("If you delete an item, it will be permanently lost.")),
                            NULL,
                            FALSE,
                            CANCEL, DELETE,
                            NULL);

    return response == 1;
}

dequeue_pending_idle_callback (gpointer callback_data)
{
    NautilusDirectory *directory;
    GList *pending_file_info;
    GList *node, *next;
    NautilusFile *file;
    GList *changed_files, *added_files;
    GFileInfo *file_info;
    const char *mimetype, *name;
    DirectoryLoadState *dir_load_state;

    directory = NAUTILUS_DIRECTORY (callback_data);

    nautilus_directory_ref (directory);

    nautilus_profile_start ("nitems %d", g_list_length (directory->details->pending_file_info));

    directory->details->dequeue_pending_idle_id = 0;

    /* Handle the files in the order we saw them. */
    pending_file_info = g_list_reverse (directory->details->pending_file_info);
    directory->details->pending_file_info = NULL;

    /* If we are no longer monitoring, then throw away these. */
    if (!nautilus_directory_is_file_list_monitored (directory))
    {
        nautilus_directory_async_state_changed (directory);
        goto drain;
    }

    added_files = NULL;
    changed_files = NULL;

    dir_load_state = directory->details->directory_load_in_progress;

    /* Build a list of NautilusFile objects. */
    for (node = pending_file_info; node != NULL; node = node->next)
    {
        file_info = node->data;

        name = g_file_info_get_name (file_info);

        /* Update the file count. */
        /* FIXME bugzilla.gnome.org 45063: This could count a
         * file twice if we get it from both load_directory
         * and from new_files_callback. Not too hard to fix by
         * moving this into the actual callback instead of
         * waiting for the idle function.
         */
        if (dir_load_state &&
            !should_skip_file (directory, file_info))
        {
            dir_load_state->load_file_count += 1;

            /* Add the MIME type to the set. */
            mimetype = g_file_info_get_content_type (file_info);
            if (mimetype != NULL)
            {
                istr_set_insert (dir_load_state->load_mime_list_hash,
                                 mimetype);
            }
        }

        /* check if the file already exists */
        file = nautilus_directory_find_file_by_name (directory, name);
        if (file != NULL)
        {
            /* file already exists in dir, check if we still need to
             *  emit file_added or if it changed */
            set_file_unconfirmed (file, FALSE);
            if (!file->details->is_added)
            {
                /* We consider this newly added even if its in the list.
                 * This can happen if someone called nautilus_file_get_by_uri()
                 * on a file in the folder before the add signal was
                 * emitted */
                nautilus_file_ref (file);
                file->details->is_added = TRUE;
                added_files = g_list_prepend (added_files, file);
            }
            else if (nautilus_file_update_info (file, file_info))
            {
                /* File changed, notify about the change. */
                nautilus_file_ref (file);
                changed_files = g_list_prepend (changed_files, file);
            }
        }
        else
        {
            /* new file, create a nautilus file object and add it to the list */
            file = nautilus_file_new_from_info (directory, file_info);
            nautilus_directory_add_file (directory, file);
            file->details->is_added = TRUE;
            added_files = g_list_prepend (added_files, file);
        }
    }

    /* If we are done loading, then we assume that any unconfirmed
     * files are gone.
     */
    if (directory->details->directory_loaded)
    {
        for (node = directory->details->file_list;
             node != NULL; node = next)
        {
            file = NAUTILUS_FILE (node->data);
            next = node->next;

            if (file->details->unconfirmed)
            {
                nautilus_file_ref (file);
                changed_files = g_list_prepend (changed_files, file);

                nautilus_file_mark_gone (file);
            }
        }
    }

    /* Send the changed and added signals. */
    nautilus_directory_emit_change_signals (directory, changed_files);
    nautilus_file_list_free (changed_files);
    nautilus_directory_emit_files_added (directory, added_files);
    nautilus_file_list_free (added_files);

    if (directory->details->directory_loaded &&
        !directory->details->directory_loaded_sent_notification)
    {
        /* Send the done_loading signal. */
        nautilus_directory_emit_done_loading (directory);

        if (dir_load_state)
        {
            file = dir_load_state->load_directory_file;

            file->details->directory_count = dir_load_state->load_file_count;
            file->details->directory_count_is_up_to_date = TRUE;
            file->details->got_directory_count = TRUE;

            file->details->got_mime_list = TRUE;
            file->details->mime_list_is_up_to_date = TRUE;
            g_list_free_full (file->details->mime_list, g_free);
            file->details->mime_list = istr_set_get_as_list
                                           (dir_load_state->load_mime_list_hash);

            nautilus_file_changed (file);
        }

        nautilus_directory_async_state_changed (directory);

        directory->details->directory_loaded_sent_notification = TRUE;
    }

drain:
    g_list_free_full (pending_file_info, g_object_unref);

    /* Get the state machine running again. */
    nautilus_directory_async_state_changed (directory);

    nautilus_profile_end (NULL);

    nautilus_directory_unref (directory);
    return FALSE;
}

deep_count_cancel (NautilusDirectory *directory)
{
    if (directory->details->deep_count_in_progress != NULL)
    {
        g_assert (NAUTILUS_IS_FILE (directory->details->deep_count_file));

        g_cancellable_cancel (directory->details->deep_count_in_progress->cancellable);

        directory->details->deep_count_file->details->deep_counts_status = NAUTILUS_REQUEST_NOT_STARTED;

        directory->details->deep_count_in_progress->directory = NULL;
        directory->details->deep_count_in_progress = NULL;
        directory->details->deep_count_file = NULL;

        async_job_end (directory, "deep count");
    }
}

 is_all_button_text (const char *button_text)
{
    g_assert (button_text != NULL);

    return !strcmp (button_text, SKIP_ALL) ||
           !strcmp (button_text, REPLACE_ALL) ||
           !strcmp (button_text, DELETE_ALL) ||
           !strcmp (button_text, MERGE_ALL);
}

nautilus_file_operations_new_folder (GtkWidget              *parent_view,
                                     GdkPoint               *target_point,
                                     const char             *parent_dir,
                                     const char             *folder_name,
                                     NautilusCreateCallback  done_callback,
                                     gpointer                done_callback_data)
{
    GTask *task;
    CreateJob *job;
    GtkWindow *parent_window;

    parent_window = NULL;
    if (parent_view)
    {
        parent_window = (GtkWindow *) gtk_widget_get_ancestor (parent_view, GTK_TYPE_WINDOW);
    }

    job = op_job_new (CreateJob, parent_window);
    job->done_callback = done_callback;
    job->done_callback_data = done_callback_data;
    job->dest_dir = g_file_new_for_uri (parent_dir);
    job->filename = g_strdup (folder_name);
    job->make_dir = TRUE;
    if (target_point != NULL)
    {
        job->position = *target_point;
        job->has_position = TRUE;
    }

    if (!nautilus_file_undo_manager_is_operating ())
    {
        job->common.undo_info = nautilus_file_undo_info_create_new (NAUTILUS_FILE_UNDO_OP_CREATE_FOLDER);
    }

    task = g_task_new (NULL, job->common.cancellable, create_task_done, job);
    g_task_set_task_data (task, job, NULL);
    g_task_run_in_thread (task, create_task_thread_func);
    g_object_unref (task);
}

count_non_skipped_files (GList *list)
{
    guint count;
    GList *node;
    GFileInfo *info;

    count = 0;
    for (node = list; node != NULL; node = node->next)
    {
        info = node->data;
        if (!should_skip_file (NULL, info))
        {
            count += 1;
        }
    }
    return count;
}

get_duplicate_name (const char *name,
                    int         count_increment,
                    int         max_length)
{
    char *result;
    char *name_base;
    const char *suffix;
    int count;

    parse_previous_duplicate_name (name, &name_base, &suffix, &count);
    result = make_next_duplicate_name (name_base, suffix, count + count_increment, max_length);

    g_free (name_base);

    return result;
}

monitor_key_compare (gconstpointer a,
                     gconstpointer data)
{
    const Monitor *monitor;
    const Monitor *compare_monitor;

    monitor = a;
    compare_monitor = data;

    if (monitor->client < compare_monitor->client)
    {
        return -1;
    }
    if (monitor->client > compare_monitor->client)
    {
        return +1;
    }

    if (monitor->file < compare_monitor->file)
    {
        return -1;
    }
    if (monitor->file > compare_monitor->file)
    {
        return +1;
    }

    return 0;
}

copy_files (CopyMoveJob  *job,
            const char   *dest_fs_id,
            SourceInfo   *source_info,
            TransferInfo *transfer_info)
{
    CommonJob *common;
    GList *l;
    GFile *src;
    gboolean same_fs;
    int i;
    GdkPoint *point;
    gboolean skipped_file;
    gboolean unique_names;
    GFile *dest;
    GFile *source_dir;
    char *dest_fs_type;
    GFileInfo *inf;
    gboolean readonly_source_fs;

    dest_fs_type = NULL;
    readonly_source_fs = FALSE;

    common = &job->common;

    report_copy_progress (job, source_info, transfer_info);

    /* Query the source dir, not the file because if it's a symlink we'll follow it */
    source_dir = g_file_get_parent ((GFile *) job->files->data);
    if (source_dir)
    {
        inf = g_file_query_filesystem_info (source_dir, "filesystem::readonly", NULL, NULL);
        if (inf != NULL)
        {
            readonly_source_fs = g_file_info_get_attribute_boolean (inf, "filesystem::readonly");
            g_object_unref (inf);
        }
        g_object_unref (source_dir);
    }

    unique_names = (job->destination == NULL);
    i = 0;
    for (l = job->files;
         l != NULL && !job_aborted (common);
         l = l->next)
    {
        src = l->data;

        if (i < job->n_icon_positions)
        {
            point = &job->icon_positions[i];
        }
        else
        {
            point = NULL;
        }


        same_fs = FALSE;
        if (dest_fs_id)
        {
            same_fs = has_fs_id (src, dest_fs_id);
        }

        if (job->destination)
        {
            dest = g_object_ref (job->destination);
        }
        else
        {
            dest = g_file_get_parent (src);
        }
        if (dest)
        {
            skipped_file = FALSE;
            copy_move_file (job, src, dest,
                            same_fs, unique_names,
                            &dest_fs_type,
                            source_info, transfer_info,
                            job->debuting_files,
                            point, FALSE, &skipped_file,
                            readonly_source_fs);
            g_object_unref (dest);

            if (skipped_file)
            {
                transfer_add_file_to_count (src, common, transfer_info);
                report_copy_progress (job, source_info, transfer_info);
            }
        }
        i++;
    }

    g_free (dest_fs_type);
}

extract_job_on_error (AutoarExtractor *extractor,
                      GError          *error,
                      gpointer         user_data)
{
    ExtractJob *extract_job = user_data;
    GFile *source_file;
    gint response_id;

    source_file = autoar_extractor_get_source_file (extractor);

    if (IS_IO_ERROR (error, NOT_SUPPORTED))
    {
        handle_unsupported_compressed_file (extract_job->common.parent_window,
                                            source_file);

        return;
    }

    nautilus_progress_info_take_status (extract_job->common.progress,
                                        f (_("Error extracting “%B”"),
                                           source_file));

    response_id = run_warning ((CommonJob *) extract_job,
                               f (_("There was an error while extracting “%B”."),
                                  source_file),
                               g_strdup (error->message),
                               NULL,
                               FALSE,
                               CANCEL,
                               SKIP,
                               NULL);

    if (response_id == 0 || response_id == GTK_RESPONSE_DELETE_EVENT)
    {
        abort_job ((CommonJob *) extract_job);
    }
}

map_possibly_volatile_file_to_real (GFile         *volatile_file,
                                    GCancellable  *cancellable,
                                    GError       **error)
{
    GFile *real_file = NULL;
    GFileInfo *info = NULL;

    info = g_file_query_info (volatile_file,
                              G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK ","
                              G_FILE_ATTRIBUTE_STANDARD_IS_VOLATILE ","
                              G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET,
                              G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,
                              cancellable,
                              error);
    if (info == NULL)
    {
        return NULL;
    }
    else
    {
        gboolean is_volatile;

        is_volatile = g_file_info_get_attribute_boolean (info,
                                                         G_FILE_ATTRIBUTE_STANDARD_IS_VOLATILE);
        if (is_volatile)
        {
            const gchar *target;

            target = g_file_info_get_symlink_target (info);
            real_file = g_file_resolve_relative_path (volatile_file, target);
        }
    }

    g_object_unref (info);

    if (real_file == NULL)
    {
        real_file = g_object_ref (volatile_file);
    }

    return real_file;
}

deep_count_start (NautilusDirectory *directory,
                  NautilusFile      *file,
                  gboolean          *doing_io)
{
    GFile *location;
    DeepCountState *state;

    if (directory->details->deep_count_in_progress != NULL)
    {
        *doing_io = TRUE;
        return;
    }

    if (!is_needy (file,
                   lacks_deep_count,
                   REQUEST_DEEP_COUNT))
    {
        return;
    }
    *doing_io = TRUE;

    if (!nautilus_file_is_directory (file))
    {
        file->details->deep_counts_status = NAUTILUS_REQUEST_DONE;

        nautilus_directory_async_state_changed (directory);
        return;
    }

    if (!async_job_start (directory, "deep count"))
    {
        return;
    }

    /* Start counting. */
    file->details->deep_counts_status = NAUTILUS_REQUEST_IN_PROGRESS;
    file->details->deep_directory_count = 0;
    file->details->deep_file_count = 0;
    file->details->deep_unreadable_count = 0;
    file->details->deep_size = 0;
    directory->details->deep_count_file = file;

    state = g_new0 (DeepCountState, 1);
    state->directory = directory;
    state->cancellable = g_cancellable_new ();
    state->seen_deep_count_inodes = g_array_new (FALSE, TRUE, sizeof (guint64));
    state->fs_id = NULL;

    directory->details->deep_count_in_progress = state;

    location = nautilus_file_get_location (file);
    g_file_query_info_async (location,
                             G_FILE_ATTRIBUTE_ID_FILESYSTEM,
                             G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,
                             G_PRIORITY_DEFAULT,
                             NULL,
                             deep_count_got_info,
                             state);
    g_object_unref (location);
}

compress_task_done (GObject      *source_object,
                    GAsyncResult *res,
                    gpointer      user_data)
{
    CompressJob *compress_job = user_data;

    if (compress_job->done_callback)
    {
        compress_job->done_callback (compress_job->output_file,
                                     compress_job->success,
                                     compress_job->done_callback_data);
    }

    g_object_unref (compress_job->output_file);
    g_list_free_full (compress_job->source_files, g_object_unref);

    finalize_common ((CommonJob *) compress_job);

    nautilus_file_changes_consume_changes (TRUE);
}

link_task_thread_func (GTask        *task,
                       gpointer      source_object,
                       gpointer      task_data,
                       GCancellable *cancellable)
{
    CopyMoveJob *job;
    CommonJob *common;
    GFile *src;
    GdkPoint *point;
    char *dest_fs_type;
    int total, left;
    int i;
    GList *l;

    job = task_data;
    common = &job->common;

    dest_fs_type = NULL;

    nautilus_progress_info_start (job->common.progress);

    verify_destination (&job->common,
                        job->destination,
                        NULL,
                        -1);
    if (job_aborted (common))
    {
        goto aborted;
    }

    total = left = g_list_length (job->files);

    report_preparing_link_progress (job, total, left);

    i = 0;
    for (l = job->files;
         l != NULL && !job_aborted (common);
         l = l->next)
    {
        src = l->data;

        if (i < job->n_icon_positions)
        {
            point = &job->icon_positions[i];
        }
        else
        {
            point = NULL;
        }


        link_file (job, src, job->destination,
                   &dest_fs_type, job->debuting_files,
                   point, left);
        report_preparing_link_progress (job, total, --left);
        i++;
    }

aborted:
    g_free (dest_fs_type);
}

async_job_end (NautilusDirectory *directory,
               const char        *job)
{
#ifdef DEBUG_ASYNC_JOBS
    char *key;
    gpointer table_key, value;
#endif

#ifdef DEBUG_START_STOP
    g_message ("stopping %s in %p", job, directory->details->location);
#endif

    g_assert (async_job_count > 0);

#ifdef DEBUG_ASYNC_JOBS
    {
        char *uri;
        uri = nautilus_directory_get_uri (directory);
        g_assert (async_jobs != NULL);
        key = g_strconcat (uri, ": ", job, NULL);
        if (!g_hash_table_lookup_extended (async_jobs, key, &table_key, &value))
        {
            g_warning ("ending job we didn't start: %s in %s",
                       job, uri);
        }
        else
        {
            g_hash_table_remove (async_jobs, key);
            g_free (table_key);
        }
        g_free (uri);
        g_free (key);
    }
#endif

    async_job_count -= 1;
}

launch_location_from_file (NautilusFile *file)
{
    LaunchLocation *location;
    location = g_new (LaunchLocation, 1);
    location->file = nautilus_file_ref (file);
    location->uri = nautilus_file_get_uri (file);

    return location;
}

move_files_prepare (CopyMoveJob  *job,
                    const char   *dest_fs_id,
                    char        **dest_fs_type,
                    GList       **fallbacks)
{
    CommonJob *common;
    GList *l;
    GFile *src;
    gboolean same_fs;
    int i;
    GdkPoint *point;
    int total, left;

    common = &job->common;

    total = left = g_list_length (job->files);

    report_preparing_move_progress (job, total, left);

    i = 0;
    for (l = job->files;
         l != NULL && !job_aborted (common);
         l = l->next)
    {
        src = l->data;

        if (i < job->n_icon_positions)
        {
            point = &job->icon_positions[i];
        }
        else
        {
            point = NULL;
        }


        same_fs = FALSE;
        if (dest_fs_id)
        {
            same_fs = has_fs_id (src, dest_fs_id);
        }

        move_file_prepare (job, src, job->destination,
                           same_fs, dest_fs_type,
                           job->debuting_files,
                           point,
                           fallbacks,
                           left);
        report_preparing_move_progress (job, total, --left);
        i++;
    }

    *fallbacks = g_list_reverse (*fallbacks);
}

can_delete_files_without_confirm (GList *files)
{
    g_assert (files != NULL);

    while (files != NULL)
    {
        if (!can_delete_without_confirm (files->data))
        {
            return FALSE;
        }

        files = files->next;
    }

    return TRUE;
}

directory_load_cancel (NautilusDirectory *directory)
{
    NautilusFile *file;
    DirectoryLoadState *state;

    state = directory->details->directory_load_in_progress;
    if (state != NULL)
    {
        file = state->load_directory_file;
        file->details->loading_directory = FALSE;
        if (file->details->directory != directory)
        {
            nautilus_directory_async_state_changed (file->details->directory);
        }

        g_cancellable_cancel (state->cancellable);
        state->directory = NULL;
        directory->details->directory_load_in_progress = NULL;
        async_job_end (directory, "file list");
    }
}

nautilus_file_operations_new_file_from_template (GtkWidget              *parent_view,
                                                 GdkPoint               *target_point,
                                                 const char             *parent_dir,
                                                 const char             *target_filename,
                                                 const char             *template_uri,
                                                 NautilusCreateCallback  done_callback,
                                                 gpointer                done_callback_data)
{
    GTask *task;
    CreateJob *job;
    GtkWindow *parent_window;

    parent_window = NULL;
    if (parent_view)
    {
        parent_window = (GtkWindow *) gtk_widget_get_ancestor (parent_view, GTK_TYPE_WINDOW);
    }

    job = op_job_new (CreateJob, parent_window);
    job->done_callback = done_callback;
    job->done_callback_data = done_callback_data;
    job->dest_dir = g_file_new_for_uri (parent_dir);
    if (target_point != NULL)
    {
        job->position = *target_point;
        job->has_position = TRUE;
    }
    job->filename = g_strdup (target_filename);

    if (template_uri)
    {
        job->src = g_file_new_for_uri (template_uri);
    }

    if (!nautilus_file_undo_manager_is_operating ())
    {
        job->common.undo_info = nautilus_file_undo_info_create_new (NAUTILUS_FILE_UNDO_OP_CREATE_FILE_FROM_TEMPLATE);
    }

    task = g_task_new (NULL, job->common.cancellable, create_task_done, job);
    g_task_set_task_data (task, job, NULL);
    g_task_run_in_thread (task, create_task_thread_func);
    g_object_unref (task);
}

link_file (CopyMoveJob  *job,
           GFile        *src,
           GFile        *dest_dir,
           char        **dest_fs_type,
           GHashTable   *debuting_files,
           GdkPoint     *position,
           int           files_left)
{
    GFile *src_dir, *dest, *new_dest;
    g_autofree gchar *dest_uri = NULL;
    int count;
    char *path;
    gboolean not_local;
    GError *error;
    CommonJob *common;
    char *primary, *secondary, *details;
    int response;
    gboolean handled_invalid_filename;

    common = (CommonJob *) job;

    count = 0;

    src_dir = g_file_get_parent (src);
    if (g_file_equal (src_dir, dest_dir))
    {
        count = 1;
    }
    g_object_unref (src_dir);

    handled_invalid_filename = *dest_fs_type != NULL;

    dest = get_target_file_for_link (src, dest_dir, *dest_fs_type, count);

retry:
    error = NULL;
    not_local = FALSE;

    path = get_abs_path_for_symlink (src, dest);
    if (path == NULL)
    {
        not_local = TRUE;
    }
    else if (g_file_make_symbolic_link (dest,
                                        path,
                                        common->cancellable,
                                        &error))
    {
        if (common->undo_info != NULL)
        {
            nautilus_file_undo_info_ext_add_origin_target_pair (NAUTILUS_FILE_UNDO_INFO_EXT (common->undo_info),
                                                                src, dest);
        }

        g_free (path);
        if (debuting_files)
        {
            g_hash_table_replace (debuting_files, g_object_ref (dest), GINT_TO_POINTER (TRUE));
        }

        nautilus_file_changes_queue_file_added (dest);
        dest_uri = g_file_get_uri (dest);
        if (position)
        {
            nautilus_file_changes_queue_schedule_position_set (dest, *position, common->screen_num);
        }
        else if (eel_uri_is_desktop (dest_uri))
        {
            nautilus_file_changes_queue_schedule_position_remove (dest);
        }

        g_object_unref (dest);

        return;
    }
    g_free (path);

    if (error != NULL &&
        IS_IO_ERROR (error, INVALID_FILENAME) &&
        !handled_invalid_filename)
    {
        handled_invalid_filename = TRUE;

        g_assert (*dest_fs_type == NULL);
        *dest_fs_type = query_fs_type (dest_dir, common->cancellable);

        new_dest = get_target_file_for_link (src, dest_dir, *dest_fs_type, count);

        if (!g_file_equal (dest, new_dest))
        {
            g_object_unref (dest);
            dest = new_dest;
            g_error_free (error);

            goto retry;
        }
        else
        {
            g_object_unref (new_dest);
        }
    }
    /* Conflict */
    if (error != NULL && IS_IO_ERROR (error, EXISTS))
    {
        g_object_unref (dest);
        dest = get_target_file_for_link (src, dest_dir, *dest_fs_type, count++);
        g_error_free (error);
        goto retry;
    }
    else if (error != NULL && IS_IO_ERROR (error, CANCELLED))
    {
        g_error_free (error);
    }
    /* Other error */
    else if (error != NULL)
    {
        if (common->skip_all_error)
        {
            goto out;
        }
        primary = f (_("Error while creating link to %B."), src);
        if (not_local)
        {
            secondary = f (_("Symbolic links only supported for local files"));
            details = NULL;
        }
        else if (IS_IO_ERROR (error, NOT_SUPPORTED))
        {
            secondary = f (_("The target doesn’t support symbolic links."));
            details = NULL;
        }
        else
        {
            secondary = f (_("There was an error creating the symlink in %F."), dest_dir);
            details = error->message;
        }

        response = run_warning (common,
                                primary,
                                secondary,
                                details,
                                files_left > 1,
                                CANCEL, SKIP_ALL, SKIP,
                                NULL);

        if (error)
        {
            g_error_free (error);
        }

        if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)
        {
            abort_job (common);
        }
        else if (response == 1)             /* skip all */
        {
            common->skip_all_error = TRUE;
        }
        else if (response == 2)             /* skip */
        {               /* do nothing */
        }
        else
        {
            g_assert_not_reached ();
        }
    }

out:
    g_object_unref (dest);
}

report_copy_progress (CopyMoveJob  *copy_job,
                      SourceInfo   *source_info,
                      TransferInfo *transfer_info)
{
    int files_left;
    goffset total_size;
    double elapsed, transfer_rate;
    int remaining_time;
    guint64 now;
    CommonJob *job;
    gboolean is_move;
    gchar *status;
    char *details;

    job = (CommonJob *) copy_job;

    is_move = copy_job->is_move;

    now = g_get_monotonic_time ();

    files_left = source_info->num_files - transfer_info->num_files;

    /* Races and whatnot could cause this to be negative... */
    if (files_left < 0)
    {
        files_left = 0;
    }

    /* If the number of files left is 0, we want to update the status without
     * considering this time, since we want to change the status to completed
     * and probably we won't get more calls to this function */
    if (transfer_info->last_report_time != 0 &&
        ABS ((gint64) (transfer_info->last_report_time - now)) < 100 * NSEC_PER_MICROSEC &&
        files_left > 0)
    {
        return;
    }
    transfer_info->last_report_time = now;

    if (files_left != transfer_info->last_reported_files_left ||
        transfer_info->last_reported_files_left == 0)
    {
        /* Avoid changing this unless files_left changed since last time */
        transfer_info->last_reported_files_left = files_left;

        if (source_info->num_files == 1)
        {
            if (copy_job->destination != NULL)
            {
                if (is_move)
                {
                    if (files_left > 0)
                    {
                        status = _("Moving “%B” to “%B”");
                    }
                    else
                    {
                        status = _("Moved “%B” to “%B”");
                    }
                }
                else
                {
                    if (files_left > 0)
                    {
                        status = _("Copying “%B” to “%B”");
                    }
                    else
                    {
                        status = _("Copied “%B” to “%B”");
                    }
                }
                nautilus_progress_info_take_status (job->progress,
                                                    f (status,
                                                       copy_job->fake_display_source != NULL ?
                                                       copy_job->fake_display_source :
                                                       (GFile *) copy_job->files->data,
                                                       copy_job->destination));
            }
            else
            {
                if (files_left > 0)
                {
                    status = _("Duplicating “%B”");
                }
                else
                {
                    status = _("Duplicated “%B”");
                }
                nautilus_progress_info_take_status (job->progress,
                                                    f (status,
                                                       (GFile *) copy_job->files->data));
            }
        }
        else if (copy_job->files != NULL)
        {
            if (copy_job->destination != NULL)
            {
                if (files_left > 0)
                {
                    if (is_move)
                    {
                        status = ngettext ("Moving %'d file to “%B”",
                                           "Moving %'d files to “%B”",
                                           source_info->num_files);
                    }
                    else
                    {
                        status = ngettext ("Copying %'d file to “%B”",
                                           "Copying %'d files to “%B”",
                                           source_info->num_files);
                    }
                    nautilus_progress_info_take_status (job->progress,
                                                        f (status,
                                                           source_info->num_files,
                                                           (GFile *) copy_job->destination));
                }
                else
                {
                    if (is_move)
                    {
                        status = ngettext ("Moved %'d file to “%B”",
                                           "Moved %'d files to “%B”",
                                           source_info->num_files);
                    }
                    else
                    {
                        status = ngettext ("Copied %'d file to “%B”",
                                           "Copied %'d files to “%B”",
                                           source_info->num_files);
                    }
                    nautilus_progress_info_take_status (job->progress,
                                                        f (status,
                                                           source_info->num_files,
                                                           (GFile *) copy_job->destination));
                }
            }
            else
            {
                GFile *parent;

                parent = g_file_get_parent (copy_job->files->data);
                if (files_left > 0)
                {
                    status = ngettext ("Duplicating %'d file in “%B”",
                                       "Duplicating %'d files in “%B”",
                                       source_info->num_files);
                    nautilus_progress_info_take_status (job->progress,
                                                        f (status,
                                                           source_info->num_files,
                                                           parent));
                }
                else
                {
                    status = ngettext ("Duplicated %'d file in “%B”",
                                       "Duplicated %'d files in “%B”",
                                       source_info->num_files);
                    nautilus_progress_info_take_status (job->progress,
                                                        f (status,
                                                           source_info->num_files,
                                                           parent));
                }
                g_object_unref (parent);
            }
        }
    }

    total_size = MAX (source_info->num_bytes, transfer_info->num_bytes);

    elapsed = g_timer_elapsed (job->time, NULL);
    transfer_rate = 0;
    remaining_time = INT_MAX;
    if (elapsed > 0)
    {
        transfer_rate = transfer_info->num_bytes / elapsed;
        if (transfer_rate > 0)
        {
            remaining_time = (total_size - transfer_info->num_bytes) / transfer_rate;
        }
    }

    if (elapsed < SECONDS_NEEDED_FOR_RELIABLE_TRANSFER_RATE &&
        transfer_rate > 0)
    {
        if (source_info->num_files == 1)
        {
            /* To translators: %S will expand to a size like "2 bytes" or "3 MB", so something like "4 kb / 4 MB" */
            details = f (_("%S / %S"), transfer_info->num_bytes, total_size);
        }
        else
        {
            if (files_left > 0)
            {
                /* To translators: %'d is the number of files completed for the operation,
                 * so it will be something like 2/14. */
                details = f (_("%'d / %'d"),
                             transfer_info->num_files + 1,
                             source_info->num_files);
            }
            else
            {
                /* To translators: %'d is the number of files completed for the operation,
                 * so it will be something like 2/14. */
                details = f (_("%'d / %'d"),
                             transfer_info->num_files,
                             source_info->num_files);
            }
        }
    }
    else
    {
        if (source_info->num_files == 1)
        {
            if (files_left > 0)
            {
                /* To translators: %S will expand to a size like "2 bytes" or "3 MB", %T to a time duration like
                 * "2 minutes". So the whole thing will be something like "2 kb / 4 MB -- 2 hours left (4kb/sec)"
                 *
                 * The singular/plural form will be used depending on the remaining time (i.e. the %T argument).
                 */
                details = f (ngettext ("%S / %S \xE2\x80\x94 %T left (%S/sec)",
                                       "%S / %S \xE2\x80\x94 %T left (%S/sec)",
                                       seconds_count_format_time_units (remaining_time)),
                             transfer_info->num_bytes, total_size,
                             remaining_time,
                             (goffset) transfer_rate);
            }
            else
            {
                /* To translators: %S will expand to a size like "2 bytes" or "3 MB". */
                details = f (_("%S / %S"),
                             transfer_info->num_bytes,
                             total_size);
            }
        }
        else
        {
            if (files_left > 0)
            {
                /* To translators: %T will expand to a time duration like "2 minutes".
                 * So the whole thing will be something like "1 / 5 -- 2 hours left (4kb/sec)"
                 *
                 * The singular/plural form will be used depending on the remaining time (i.e. the %T argument).
                 */
                details = f (ngettext ("%'d / %'d \xE2\x80\x94 %T left (%S/sec)",
                                       "%'d / %'d \xE2\x80\x94 %T left (%S/sec)",
                                       seconds_count_format_time_units (remaining_time)),
                             transfer_info->num_files + 1, source_info->num_files,
                             remaining_time,
                             (goffset) transfer_rate);
            }
            else
            {
                /* To translators: %'d is the number of files completed for the operation,
                 * so it will be something like 2/14. */
                details = f (_("%'d / %'d"),
                             transfer_info->num_files,
                             source_info->num_files);
            }
        }
    }
    nautilus_progress_info_take_details (job->progress, details);

    if (elapsed > SECONDS_NEEDED_FOR_APROXIMATE_TRANSFER_RATE)
    {
        nautilus_progress_info_set_remaining_time (job->progress,
                                                   remaining_time);
        nautilus_progress_info_set_elapsed_time (job->progress,
                                                 elapsed);
    }

    nautilus_progress_info_set_progress (job->progress, transfer_info->num_bytes, total_size);
}

thumbnail_start (NautilusDirectory *directory,
                 NautilusFile      *file,
                 gboolean          *doing_io)
{
    GFile *location;
    ThumbnailState *state;

    if (directory->details->thumbnail_state != NULL)
    {
        *doing_io = TRUE;
        return;
    }

    if (!is_needy (file,
                   lacks_thumbnail,
                   REQUEST_THUMBNAIL))
    {
        return;
    }
    *doing_io = TRUE;

    if (!async_job_start (directory, "thumbnail"))
    {
        return;
    }

    state = g_new0 (ThumbnailState, 1);
    state->directory = directory;
    state->file = file;
    state->cancellable = g_cancellable_new ();

    if (file->details->thumbnail_wants_original)
    {
        state->tried_original = TRUE;
        state->trying_original = TRUE;
        location = nautilus_file_get_location (file);
    }
    else
    {
        location = g_file_new_for_path (file->details->thumbnail_path);
    }

    directory->details->thumbnail_state = state;

    g_file_load_contents_async (location,
                                state->cancellable,
                                thumbnail_read_callback,
                                state);
    g_object_unref (location);
}

query_info_callback (GObject      *source_object,
                     GAsyncResult *res,
                     gpointer      user_data)
{
    NautilusDirectory *directory;
    NautilusFile *get_info_file;
    GFileInfo *info;
    GetInfoState *state;
    GError *error;

    state = user_data;

    if (state->directory == NULL)
    {
        /* Operation was cancelled. Bail out */
        get_info_state_free (state);
        return;
    }

    directory = nautilus_directory_ref (state->directory);

    get_info_file = directory->details->get_info_file;
    g_assert (NAUTILUS_IS_FILE (get_info_file));

    directory->details->get_info_file = NULL;
    directory->details->get_info_in_progress = NULL;

    /* ref here because we might be removing the last ref when we
     * mark the file gone below, but we need to keep a ref at
     * least long enough to send the change notification.
     */
    nautilus_file_ref (get_info_file);

    error = NULL;
    info = g_file_query_info_finish (G_FILE (source_object), res, &error);

    if (info == NULL)
    {
        if (error->domain == G_IO_ERROR && error->code == G_IO_ERROR_NOT_FOUND)
        {
            /* mark file as gone */
            nautilus_file_mark_gone (get_info_file);
        }
        get_info_file->details->file_info_is_up_to_date = TRUE;
        nautilus_file_clear_info (get_info_file);
        get_info_file->details->get_info_failed = TRUE;
        get_info_file->details->get_info_error = error;
    }
    else
    {
        nautilus_file_update_info (get_info_file, info);
        g_object_unref (info);
    }

    nautilus_file_changed (get_info_file);
    nautilus_file_unref (get_info_file);

    async_job_end (directory, "file info");
    nautilus_directory_async_state_changed (directory);

    nautilus_directory_unref (directory);

    get_info_state_free (state);
}

thumbnail_cancel (NautilusDirectory *directory)
{
    if (directory->details->thumbnail_state != NULL)
    {
        g_cancellable_cancel (directory->details->thumbnail_state->cancellable);
        directory->details->thumbnail_state->directory = NULL;
        directory->details->thumbnail_state = NULL;
        async_job_end (directory, "thumbnail");
    }
}

extension_info_stop (NautilusDirectory *directory)
{
    if (directory->details->extension_info_in_progress != NULL)
    {
        NautilusFile *file;

        file = directory->details->extension_info_file;
        if (file != NULL)
        {
            g_assert (NAUTILUS_IS_FILE (file));
            g_assert (file->details->directory == directory);
            if (is_needy (file, lacks_extension_info, REQUEST_EXTENSION_INFO))
            {
                return;
            }
        }

        /* The info is not wanted, so stop it. */
        extension_info_cancel (directory);
    }
}

deep_count_one (DeepCountState *state,
                GFileInfo      *info)
{
    NautilusFile *file;
    GFile *subdir;
    gboolean is_seen_inode;
    const char *fs_id;

    if (should_skip_file (NULL, info))
    {
        return;
    }

    is_seen_inode = seen_inode (state, info);
    if (!is_seen_inode)
    {
        mark_inode_as_seen (state, info);
    }

    file = state->directory->details->deep_count_file;

    if (g_file_info_get_file_type (info) == G_FILE_TYPE_DIRECTORY)
    {
        /* Count the directory. */
        file->details->deep_directory_count += 1;

        /* Record the fact that we have to descend into this directory. */
        fs_id = g_file_info_get_attribute_string (info, G_FILE_ATTRIBUTE_ID_FILESYSTEM);
        if (g_strcmp0 (fs_id, state->fs_id) == 0)
        {
            /* only if it is on the same filesystem */
            subdir = g_file_get_child (state->deep_count_location, g_file_info_get_name (info));
            state->deep_count_subdirectories = g_list_prepend
                                                   (state->deep_count_subdirectories, subdir);
        }
    }
    else
    {
        /* Even non-regular files count as files. */
        file->details->deep_file_count += 1;
    }

    /* Count the size. */
    if (!is_seen_inode && g_file_info_has_attribute (info, G_FILE_ATTRIBUTE_STANDARD_SIZE))
    {
        file->details->deep_size += g_file_info_get_size (info);
    }
}

link_info_cancel (NautilusDirectory *directory)
{
    if (directory->details->link_info_read_state != NULL)
    {
        g_cancellable_cancel (directory->details->link_info_read_state->cancellable);
        directory->details->link_info_read_state->directory = NULL;
        directory->details->link_info_read_state = NULL;
        async_job_end (directory, "link info");
    }
}

get_one_value (GHashTable *table)
{
    gpointer value;

    value = NULL;
    if (table != NULL)
    {
        g_hash_table_foreach (table, get_one_value_callback, &value);
    }
    return value;
}

report_preparing_count_progress (CommonJob  *job,
                                 SourceInfo *source_info)
{
    char *s;

    switch (source_info->op)
    {
        default:
        case OP_KIND_COPY:
        {
            s = f (ngettext ("Preparing to copy %'d file (%S)",
                             "Preparing to copy %'d files (%S)",
                             source_info->num_files),
                   source_info->num_files, source_info->num_bytes);
        }
        break;

        case OP_KIND_MOVE:
        {
            s = f (ngettext ("Preparing to move %'d file (%S)",
                             "Preparing to move %'d files (%S)",
                             source_info->num_files),
                   source_info->num_files, source_info->num_bytes);
        }
        break;

        case OP_KIND_DELETE:
        {
            s = f (ngettext ("Preparing to delete %'d file (%S)",
                             "Preparing to delete %'d files (%S)",
                             source_info->num_files),
                   source_info->num_files, source_info->num_bytes);
        }
        break;

        case OP_KIND_TRASH:
        {
            s = f (ngettext ("Preparing to trash %'d file",
                             "Preparing to trash %'d files",
                             source_info->num_files),
                   source_info->num_files);
        }
        break;

        case OP_KIND_COMPRESS:
            s = f (ngettext ("Preparing to compress %'d file",
                             "Preparing to compress %'d files",
                             source_info->num_files),
                   source_info->num_files);
    }

    nautilus_progress_info_take_details (job->progress, s);
    nautilus_progress_info_pulse_progress (job->progress);
}

activation_mount_not_mounted_callback (GObject      *source_object,
                                       GAsyncResult *res,
                                       gpointer      user_data)
{
    ActivateParameters *parameters = user_data;
    GError *error;
    NautilusFile *file;
    LaunchLocation *loc;

    file = parameters->not_mounted->data;

    error = NULL;
    if (!g_file_mount_enclosing_volume_finish (G_FILE (source_object), res, &error))
    {
        if (error->domain != G_IO_ERROR ||
            (error->code != G_IO_ERROR_CANCELLED &&
             error->code != G_IO_ERROR_FAILED_HANDLED &&
             error->code != G_IO_ERROR_ALREADY_MOUNTED))
        {
            eel_show_error_dialog (_("Unable to access location"), error->message, parameters->parent_window);
        }

        if (error->domain != G_IO_ERROR ||
            error->code != G_IO_ERROR_ALREADY_MOUNTED)
        {
            loc = find_launch_location_for_file (parameters->locations,
                                                 file);
            if (loc)
            {
                parameters->locations =
                    g_list_remove (parameters->locations, loc);
                launch_location_free (loc);
            }
        }

        g_error_free (error);
    }

    parameters->not_mounted = g_list_delete_link (parameters->not_mounted,
                                                  parameters->not_mounted);
    nautilus_file_unref (file);

    activation_mount_not_mounted (parameters);
}

directory_count_cancel (NautilusDirectory *directory)
{
    if (directory->details->count_in_progress != NULL)
    {
        g_cancellable_cancel (directory->details->count_in_progress->cancellable);
        directory->details->count_in_progress = NULL;
    }
}

link_info_done (NautilusDirectory *directory,
                NautilusFile      *file,
                const char        *uri,
                const char        *name,
                GIcon             *icon,
                gboolean           is_launcher,
                gboolean           is_foreign)
{
    gboolean is_trusted;

    file->details->link_info_is_up_to_date = TRUE;

    is_trusted = is_link_trusted (file, is_launcher);

    if (is_trusted)
    {
        nautilus_file_set_display_name (file, name, name, TRUE);
    }
    else
    {
        nautilus_file_set_display_name (file, NULL, NULL, TRUE);
    }

    file->details->got_link_info = TRUE;
    g_clear_object (&file->details->custom_icon);

    if (uri)
    {
        g_free (file->details->activation_uri);
        file->details->activation_uri = NULL;
        file->details->got_custom_activation_uri = TRUE;
        file->details->activation_uri = g_strdup (uri);
    }
    if (is_trusted && (icon != NULL))
    {
        file->details->custom_icon = g_object_ref (icon);
    }
    file->details->is_launcher = is_launcher;
    file->details->is_foreign_link = is_foreign;
    file->details->is_trusted_link = is_trusted;

    nautilus_directory_async_state_changed (directory);
}

nautilus_mime_types_get_number_of_groups (void)
{
    return G_N_ELEMENTS (mimetype_groups);
}

activation_start_mountables (ActivateParameters *parameters)
{
    NautilusFile *file;
    GMountOperation *start_op;

    if (parameters->start_mountables != NULL)
    {
        file = parameters->start_mountables->data;
        start_op = gtk_mount_operation_new (parameters->parent_window);
        g_signal_connect (start_op, "notify::is-showing",
                          G_CALLBACK (activate_mount_op_active), parameters);
        nautilus_file_start (file,
                             start_op,
                             parameters->cancellable,
                             activation_mountable_started,
                             parameters);
        g_object_unref (start_op);
        return;
    }

    if (parameters->mountables == NULL && parameters->start_mountables == NULL)
    {
        activation_get_activation_uris (parameters);
    }
}

nautilus_mime_get_default_application_for_files (GList *files)
{
    GList *l, *sorted_files;
    NautilusFile *file;
    GAppInfo *app, *one_app;

    g_assert (files != NULL);

    sorted_files = g_list_sort (g_list_copy (files), (GCompareFunc) file_compare_by_mime_type);

    app = NULL;
    for (l = sorted_files; l != NULL; l = l->next)
    {
        file = l->data;

        if (l->prev &&
            file_compare_by_mime_type (file, l->prev->data) == 0 &&
            file_compare_by_parent_uri (file, l->prev->data) == 0)
        {
            continue;
        }

        one_app = nautilus_mime_get_default_application_for_file (file);
        if (one_app == NULL || (app != NULL && !g_app_info_equal (app, one_app)))
        {
            if (app)
            {
                g_object_unref (app);
            }
            if (one_app)
            {
                g_object_unref (one_app);
            }
            app = NULL;
            break;
        }

        if (app == NULL)
        {
            app = one_app;
        }
        else
        {
            g_object_unref (one_app);
        }
    }

    g_list_free (sorted_files);

    return app;
}

deep_count_got_info (GObject      *source_object,
                     GAsyncResult *res,
                     gpointer      user_data)
{
    GFileInfo *info;
    const char *id;
    GFile *file = (GFile *) source_object;
    DeepCountState *state = (DeepCountState *) user_data;

    info = g_file_query_info_finish (file, res, NULL);
    if (info != NULL)
    {
        id = g_file_info_get_attribute_string (info, G_FILE_ATTRIBUTE_ID_FILESYSTEM);
        state->fs_id = g_strdup (id);
        g_object_unref (info);
    }
    deep_count_load (state, file);
}

has_invalid_xml_char (char *str)
{
    gunichar c;

    while (*str != 0)
    {
        c = g_utf8_get_char (str);
        /* characters XML permits */
        if (!(c == 0x9 ||
              c == 0xA ||
              c == 0xD ||
              (c >= 0x20 && c <= 0xD7FF) ||
              (c >= 0xE000 && c <= 0xFFFD) ||
              (c >= 0x10000 && c <= 0x10FFFF)))
        {
            return TRUE;
        }
        str = g_utf8_next_char (str);
    }
    return FALSE;
}

delete_cb (GtkDialog *dialog)
{
    gtk_dialog_response (dialog, GTK_RESPONSE_DELETE_EVENT);
    return TRUE;
}

copy_task_done (GObject      *source_object,
                GAsyncResult *res,
                gpointer      user_data)
{
    CopyMoveJob *job;

    job = user_data;
    if (job->done_callback)
    {
        job->done_callback (job->debuting_files,
                            !job_aborted ((CommonJob *) job),
                            job->done_callback_data);
    }

    g_list_free_full (job->files, g_object_unref);
    if (job->destination)
    {
        g_object_unref (job->destination);
    }
    if (job->desktop_location)
    {
        g_object_unref (job->desktop_location);
    }
    g_hash_table_unref (job->debuting_files);
    g_free (job->icon_positions);
    g_free (job->target_name);

    g_clear_object (&job->fake_display_source);

    finalize_common ((CommonJob *) job);

    nautilus_file_changes_consume_changes (TRUE);
}

show_unhandled_type_error (ActivateParametersInstall *parameters)
{
    GtkWidget *dialog;

    char *mime_type = nautilus_file_get_mime_type (parameters->file);
    char *error_message = get_application_no_mime_type_handler_message (parameters->file, parameters->uri);
    if (g_content_type_is_unknown (mime_type))
    {
        dialog = gtk_message_dialog_new (parameters->parent_window,
                                         GTK_DIALOG_DESTROY_WITH_PARENT | GTK_DIALOG_MODAL,
                                         GTK_MESSAGE_ERROR,
                                         0,
                                         "%s", error_message);
        gtk_message_dialog_format_secondary_text (GTK_MESSAGE_DIALOG (dialog),
                                                  _("The file is of an unknown type"));
    }
    else
    {
        char *text;
        text = g_strdup_printf (_("There is no application installed for “%s” files"), g_content_type_get_description (mime_type));

        dialog = gtk_message_dialog_new (parameters->parent_window,
                                         GTK_DIALOG_DESTROY_WITH_PARENT | GTK_DIALOG_MODAL,
                                         GTK_MESSAGE_ERROR,
                                         0,
                                         "%s", error_message);
        gtk_message_dialog_format_secondary_text (GTK_MESSAGE_DIALOG (dialog),
                                                  "%s", text);

        g_free (text);
    }

    gtk_dialog_add_button (GTK_DIALOG (dialog), _("_Select Application"), GTK_RESPONSE_ACCEPT);

    gtk_dialog_add_button (GTK_DIALOG (dialog), _("_OK"), GTK_RESPONSE_OK);

    gtk_dialog_set_default_response (GTK_DIALOG (dialog), GTK_RESPONSE_OK);

    g_object_set_data_full (G_OBJECT (dialog),
                            "mime-action:file",
                            nautilus_file_ref (parameters->file),
                            (GDestroyNotify) nautilus_file_unref);

    gtk_widget_show (GTK_WIDGET (dialog));

    g_signal_connect (dialog, "response",
                      G_CALLBACK (choose_program), parameters);

    g_free (error_message);
    g_free (mime_type);
}

lacks_deep_count (NautilusFile *file)
{
    return file->details->deep_counts_status != NAUTILUS_REQUEST_DONE;
}

thumbnail_loader_size_prepared (GdkPixbufLoader *loader,
                                int              width,
                                int              height,
                                gpointer         user_data)
{
    int max_thumbnail_size;
    double aspect_ratio;

    aspect_ratio = ((double) width) / height;

    /* cf. nautilus_file_get_icon() */
    max_thumbnail_size = NAUTILUS_CANVAS_ICON_SIZE_LARGER * cached_thumbnail_size / NAUTILUS_CANVAS_ICON_SIZE_SMALL;
    if (MAX (width, height) > max_thumbnail_size)
    {
        if (width > height)
        {
            width = max_thumbnail_size;
            height = width / aspect_ratio;
        }
        else
        {
            height = max_thumbnail_size;
            width = height * aspect_ratio;
        }

        gdk_pixbuf_loader_set_size (loader, width, height);
    }
}

async_job_start (NautilusDirectory *directory,
                 const char        *job)
{
#ifdef DEBUG_ASYNC_JOBS
    char *key;
#endif

#ifdef DEBUG_START_STOP
    g_message ("starting %s in %p", job, directory->details->location);
#endif

    g_assert (async_job_count >= 0);
    g_assert (async_job_count <= MAX_ASYNC_JOBS);

    if (async_job_count >= MAX_ASYNC_JOBS)
    {
        if (waiting_directories == NULL)
        {
            waiting_directories = g_hash_table_new (NULL, NULL);
        }

        g_hash_table_insert (waiting_directories,
                             directory,
                             directory);

        return FALSE;
    }

#ifdef DEBUG_ASYNC_JOBS
    {
        char *uri;
        if (async_jobs == NULL)
        {
            async_jobs = g_hash_table_new (g_str_hash, g_str_equal);
        }
        uri = nautilus_directory_get_uri (directory);
        key = g_strconcat (uri, ": ", job, NULL);
        if (g_hash_table_lookup (async_jobs, key) != NULL)
        {
            g_warning ("same job twice: %s in %s",
                       job, uri);
        }
        g_free (uri);
        g_hash_table_insert (async_jobs, key, directory);
    }
#endif

    async_job_count += 1;
    return TRUE;
}

get_trash_dirs_for_mount (GMount *mount)
{
    GFile *root;
    GFile *trash;
    char *relpath;
    GList *list;

    root = g_mount_get_root (mount);
    if (root == NULL)
    {
        return NULL;
    }

    list = NULL;

    if (g_file_is_native (root))
    {
        relpath = g_strdup_printf (".Trash/%d", getuid ());
        trash = g_file_resolve_relative_path (root, relpath);
        g_free (relpath);

        list = g_list_prepend (list, g_file_get_child (trash, "files"));
        list = g_list_prepend (list, g_file_get_child (trash, "info"));

        g_object_unref (trash);

        relpath = g_strdup_printf (".Trash-%d", getuid ());
        trash = g_file_get_child (root, relpath);
        g_free (relpath);

        list = g_list_prepend (list, g_file_get_child (trash, "files"));
        list = g_list_prepend (list, g_file_get_child (trash, "info"));

        g_object_unref (trash);
    }

    g_object_unref (root);

    return list;
}

is_dir (GFile *file)
{
    GFileInfo *info;
    gboolean res;

    res = FALSE;
    info = g_file_query_info (file,
                              G_FILE_ATTRIBUTE_STANDARD_TYPE,
                              G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,
                              NULL, NULL);
    if (info)
    {
        res = g_file_info_get_file_type (info) == G_FILE_TYPE_DIRECTORY;
        g_object_unref (info);
    }

    return res;
}

mark_all_files_unconfirmed (NautilusDirectory *directory)
{
    GList *node;
    NautilusFile *file;

    for (node = directory->details->file_list; node != NULL; node = node->next)
    {
        file = node->data;
        set_file_unconfirmed (file, TRUE);
    }
}

report_preparing_link_progress (CopyMoveJob *link_job,
                                int          total,
                                int          left)
{
    CommonJob *job;

    job = (CommonJob *) link_job;

    nautilus_progress_info_take_status (job->progress,
                                        f (_("Creating links in “%B”"),
                                           link_job->destination));

    nautilus_progress_info_take_details (job->progress,
                                         f (ngettext ("Making link to %'d file",
                                                      "Making links to %'d files",
                                                      left), left));

    nautilus_progress_info_set_progress (job->progress, left, total);
}

nautilus_directory_cancel (NautilusDirectory *directory)
{
    /* Arbitrary order (kept alphabetical). */
    deep_count_cancel (directory);
    directory_count_cancel (directory);
    file_info_cancel (directory);
    file_list_cancel (directory);
    link_info_cancel (directory);
    mime_list_cancel (directory);
    new_files_cancel (directory);
    extension_info_cancel (directory);
    thumbnail_cancel (directory);
    mount_cancel (directory);
    filesystem_info_cancel (directory);

    /* We aren't waiting for anything any more. */
    if (waiting_directories != NULL)
    {
        g_hash_table_remove (waiting_directories, directory);
    }

    /* Check if any directories should wake up. */
    async_job_wake_up ();
}

deep_count_stop (NautilusDirectory *directory)
{
    NautilusFile *file;

    if (directory->details->deep_count_in_progress != NULL)
    {
        file = directory->details->deep_count_file;
        if (file != NULL)
        {
            g_assert (NAUTILUS_IS_FILE (file));
            g_assert (file->details->directory == directory);
            if (is_needy (file,
                          lacks_deep_count,
                          REQUEST_DEEP_COUNT))
            {
                return;
            }
        }

        /* The count is not wanted, so stop it. */
        deep_count_cancel (directory);
    }
}

get_one_value_callback (gpointer key,
                        gpointer value,
                        gpointer callback_data)
{
    gpointer *returned_value;

    returned_value = callback_data;
    *returned_value = value;
}

nautilus_directory_remove_file_from_work_queue (NautilusDirectory *directory,
                                                NautilusFile      *file)
{
    nautilus_file_queue_remove (directory->details->high_priority_queue,
                                file);
    nautilus_file_queue_remove (directory->details->low_priority_queue,
                                file);
    nautilus_file_queue_remove (directory->details->extension_queue,
                                file);
}

deep_count_callback (GObject      *source_object,
                     GAsyncResult *res,
                     gpointer      user_data)
{
    DeepCountState *state;
    GFileEnumerator *enumerator;
    NautilusFile *file;

    state = user_data;

    if (state->directory == NULL)
    {
        /* Operation was cancelled. Bail out */
        deep_count_state_free (state);
        return;
    }

    file = state->directory->details->deep_count_file;

    enumerator = g_file_enumerate_children_finish (G_FILE (source_object), res, NULL);

    if (enumerator == NULL)
    {
        file->details->deep_unreadable_count += 1;

        deep_count_next_dir (state);
    }
    else
    {
        state->enumerator = enumerator;
        g_file_enumerator_next_files_async (state->enumerator,
                                            DIRECTORY_LOAD_ITEMS_PER_CALLBACK,
                                            G_PRIORITY_LOW,
                                            state->cancellable,
                                            deep_count_more_files_callback,
                                            state);
    }
}

directory_load_done (NautilusDirectory *directory,
                     GError            *error)
{
    GList *node;

    nautilus_profile_start (NULL);
    g_object_ref (directory);

    directory->details->directory_loaded = TRUE;
    directory->details->directory_loaded_sent_notification = FALSE;

    if (error != NULL)
    {
        /* The load did not complete successfully. This means
         * we don't know the status of the files in this directory.
         * We clear the unconfirmed bit on each file here so that
         * they won't be marked "gone" later -- we don't know enough
         * about them to know whether they are really gone.
         */
        for (node = directory->details->file_list;
             node != NULL; node = node->next)
        {
            set_file_unconfirmed (NAUTILUS_FILE (node->data), FALSE);
        }

        nautilus_directory_emit_load_error (directory, error);
    }

    /* Call the idle function right away. */
    if (directory->details->dequeue_pending_idle_id != 0)
    {
        g_source_remove (directory->details->dequeue_pending_idle_id);
    }
    dequeue_pending_idle_callback (directory);

    directory_load_cancel (directory);

    g_object_unref (directory);
    nautilus_profile_end (NULL);
}

thumbnail_state_free (ThumbnailState *state)
{
    g_object_unref (state->cancellable);
    g_free (state);
}

nautilus_directory_has_active_request_for_file (NautilusDirectory *directory,
                                                NautilusFile      *file)
{
    GList *node;
    ReadyCallback *callback;
    Monitor *monitor;

    for (node = directory->details->call_when_ready_list;
         node != NULL; node = node->next)
    {
        callback = node->data;
        if (callback->file == file ||
            callback->file == NULL)
        {
            return TRUE;
        }
    }

    for (node = directory->details->monitor_list;
         node != NULL; node = node->next)
    {
        monitor = node->data;
        if (monitor->file == file ||
            monitor->file == NULL)
        {
            return TRUE;
        }
    }

    return FALSE;
}

move_task_thread_func (GTask        *task,
                       gpointer      source_object,
                       gpointer      task_data,
                       GCancellable *cancellable)
{
    CopyMoveJob *job;
    CommonJob *common;
    GList *fallbacks;
    SourceInfo source_info;
    TransferInfo transfer_info;
    char *dest_fs_id;
    char *dest_fs_type;
    GList *fallback_files;

    job = task_data;
    common = &job->common;

    dest_fs_id = NULL;
    dest_fs_type = NULL;

    fallbacks = NULL;

    nautilus_progress_info_start (job->common.progress);

    verify_destination (&job->common,
                        job->destination,
                        &dest_fs_id,
                        -1);
    if (job_aborted (common))
    {
        goto aborted;
    }

    /* This moves all files that we can do without copy + delete */
    move_files_prepare (job, dest_fs_id, &dest_fs_type, &fallbacks);
    if (job_aborted (common))
    {
        goto aborted;
    }

    /* The rest we need to do deep copy + delete behind on,
     *  so scan for size */

    fallback_files = get_files_from_fallbacks (fallbacks);
    scan_sources (fallback_files,
                  &source_info,
                  common,
                  OP_KIND_MOVE);

    g_list_free (fallback_files);

    if (job_aborted (common))
    {
        goto aborted;
    }

    verify_destination (&job->common,
                        job->destination,
                        NULL,
                        source_info.num_bytes);
    if (job_aborted (common))
    {
        goto aborted;
    }

    memset (&transfer_info, 0, sizeof (transfer_info));
    move_files (job,
                fallbacks,
                dest_fs_id, &dest_fs_type,
                &source_info, &transfer_info);

aborted:
    g_list_free_full (fallbacks, g_free);

    g_free (dest_fs_id);
    g_free (dest_fs_type);
}

mark_trusted_task_done (GObject      *source_object,
                        GAsyncResult *res,
                        gpointer      user_data)
{
MarkTrustedJob *job = user_data;

g_object_unref (job->file);

if (job->done_callback)
{
job->done_callback (!job_aborted ((CommonJob *) job),
job->done_callback_data);
}

finalize_common ((CommonJob *) job);
}

set_permissions_task_done (GObject      *source_object,
                           GAsyncResult *res,
                           gpointer      user_data)
{
    SetPermissionsJob *job;

    job = user_data;

    g_object_unref (job->file);

    if (job->done_callback)
    {
        job->done_callback (!job_aborted ((CommonJob *) job),
                            job->done_callback_data);
    }

    finalize_common ((CommonJob *) job);
}

get_target_file_with_custom_name (GFile       *src,
                                  GFile       *dest_dir,
                                  const char  *dest_fs_type,
                                  gboolean     same_fs,
                                  const gchar *custom_name)
{
    char *basename;
    GFile *dest;
    GFileInfo *info;
    char *copyname;

    dest = NULL;

    if (custom_name != NULL)
    {
        copyname = g_strdup (custom_name);
        make_file_name_valid_for_dest_fs (copyname, dest_fs_type);
        dest = g_file_get_child_for_display_name (dest_dir, copyname, NULL);

        g_free (copyname);
    }

    if (dest == NULL && !same_fs)
    {
        info = g_file_query_info (src,
                                  G_FILE_ATTRIBUTE_STANDARD_COPY_NAME ","
                                  G_FILE_ATTRIBUTE_TRASH_ORIG_PATH,
                                  0, NULL, NULL);

        if (info)
        {
            copyname = NULL;

            /* if file is being restored from trash make sure it uses its original name */
            if (g_file_has_uri_scheme (src, "trash"))
            {
                copyname = g_path_get_basename (g_file_info_get_attribute_byte_string (info, G_FILE_ATTRIBUTE_TRASH_ORIG_PATH));
            }

            if (copyname == NULL)
            {
                copyname = g_strdup (g_file_info_get_attribute_string (info, G_FILE_ATTRIBUTE_STANDARD_COPY_NAME));
            }

            if (copyname)
            {
                make_file_name_valid_for_dest_fs (copyname, dest_fs_type);
                dest = g_file_get_child_for_display_name (dest_dir, copyname, NULL);
                g_free (copyname);
            }

            g_object_unref (info);
        }
    }

    if (dest == NULL)
    {
        basename = g_file_get_basename (src);
        make_file_name_valid_for_dest_fs (basename, dest_fs_type);
        dest = g_file_get_child (dest_dir, basename);
        g_free (basename);
    }

    return dest;
}

launch_locations_from_file_list (GList *list)
{
    GList *new;

    new = NULL;
    while (list)
    {
        new = g_list_prepend (new,
                              launch_location_from_file (list->data));
        list = list->next;
    }
    new = g_list_reverse (new);
    return new;
}

has_trash_files (GMount *mount)
{
    GList *dirs, *l;
    GFile *dir;
    gboolean res;

    dirs = get_trash_dirs_for_mount (mount);

    res = FALSE;

    for (l = dirs; l != NULL; l = l->next)
    {
        dir = l->data;

        if (dir_has_files (dir))
        {
            res = TRUE;
            break;
        }
    }

    g_list_free_full (dirs, g_object_unref);

    return res;
}

nautilus_file_operations_duplicate (GList                *files,
                                    GArray               *relative_item_points,
                                    GtkWindow            *parent_window,
                                    NautilusCopyCallback  done_callback,
                                    gpointer              done_callback_data)
{
    GTask *task;
    CopyMoveJob *job;
    GFile *parent;

    job = op_job_new (CopyMoveJob, parent_window);
    job->done_callback = done_callback;
    job->done_callback_data = done_callback_data;
    job->files = g_list_copy_deep (files, (GCopyFunc) g_object_ref, NULL);
    job->destination = NULL;
    /* Duplicate files doesn't have a destination, since is the same as source.
     * For that set as destination the source parent folder */
    parent = g_file_get_parent (files->data);
    /* Need to indicate the destination for the operation notification open
     * button. */
    nautilus_progress_info_set_destination (((CommonJob *) job)->progress, parent);
    if (relative_item_points != NULL &&
        relative_item_points->len > 0)
    {
        job->icon_positions =
            g_memdup (relative_item_points->data,
                      sizeof (GdkPoint) * relative_item_points->len);
        job->n_icon_positions = relative_item_points->len;
    }
    job->debuting_files = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);

    if (!nautilus_file_undo_manager_is_operating ())
    {
        GFile *src_dir;

        src_dir = g_file_get_parent (files->data);
        job->common.undo_info =
            nautilus_file_undo_info_ext_new (NAUTILUS_FILE_UNDO_OP_DUPLICATE,
                                             g_list_length (files),
                                             src_dir, src_dir);
        g_object_unref (src_dir);
    }

    task = g_task_new (NULL, job->common.cancellable, copy_task_done, job);
    g_task_set_task_data (task, job, NULL);
    g_task_run_in_thread (task, copy_task_thread_func);
    g_object_unref (task);

    g_object_unref (parent);
}

has_problem (NautilusDirectory *directory,
             NautilusFile      *file,
             FileCheck          problem)
{
    GList *node;

    if (file != NULL)
    {
        return (*problem)(file);
    }

    for (node = directory->details->file_list; node != NULL; node = node->next)
    {
        if ((*problem)(node->data))
        {
            return TRUE;
        }
    }

    return FALSE;
}

nautilus_file_operations_unmount_mount (GtkWindow *parent_window,
                                        GMount    *mount,
                                        gboolean   eject,
                                        gboolean   check_trash)
{
    nautilus_file_operations_unmount_mount_full (parent_window, mount, NULL, eject,
                                                 check_trash, NULL, NULL);
}

mime_list_start (NautilusDirectory *directory,
                 NautilusFile      *file,
                 gboolean          *doing_io)
{
    MimeListState *state;
    GFile *location;

    mime_list_stop (directory);

    if (directory->details->mime_list_in_progress != NULL)
    {
        *doing_io = TRUE;
        return;
    }

    /* Figure out which file to get a mime list for. */
    if (!is_needy (file,
                   should_get_mime_list,
                   REQUEST_MIME_LIST))
    {
        return;
    }
    *doing_io = TRUE;

    if (!nautilus_file_is_directory (file))
    {
        g_list_free (file->details->mime_list);
        file->details->mime_list_failed = FALSE;
        file->details->got_mime_list = FALSE;
        file->details->mime_list_is_up_to_date = TRUE;

        nautilus_directory_async_state_changed (directory);
        return;
    }

    if (!async_job_start (directory, "MIME list"))
    {
        return;
    }


    state = g_new0 (MimeListState, 1);
    state->mime_list_file = file;
    state->directory = nautilus_directory_ref (directory);
    state->cancellable = g_cancellable_new ();
    state->mime_list_hash = istr_set_new ();

    directory->details->mime_list_in_progress = state;

    location = nautilus_file_get_location (file);
#ifdef DEBUG_LOAD_DIRECTORY
    {
        char *uri;
        uri = g_file_get_uri (location);
        g_message ("load_directory called to get MIME list of %s", uri);
        g_free (uri);
    }
#endif

    g_file_enumerate_children_async (location,
                                     G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE,
                                     0,     /* flags */
                                     G_PRIORITY_LOW,     /* prio */
                                     state->cancellable,
                                     list_mime_enum_callback,
                                     state);
    g_object_unref (location);
}

should_get_mime_list (NautilusFile *file)
{
    return lacks_mime_list (file)
           && !file->details->loading_directory;
}

deep_count_next_dir (DeepCountState *state)
{
    GFile *location;
    NautilusFile *file;
    NautilusDirectory *directory;
    gboolean done;

    directory = state->directory;

    g_object_unref (state->deep_count_location);
    state->deep_count_location = NULL;

    done = FALSE;
    file = directory->details->deep_count_file;

    if (state->deep_count_subdirectories != NULL)
    {
        /* Work on a new directory. */
        location = state->deep_count_subdirectories->data;
        state->deep_count_subdirectories = g_list_remove
                                               (state->deep_count_subdirectories, location);
        deep_count_load (state, location);
        g_object_unref (location);
    }
    else
    {
        file->details->deep_counts_status = NAUTILUS_REQUEST_DONE;
        directory->details->deep_count_file = NULL;
        directory->details->deep_count_in_progress = NULL;
        deep_count_state_free (state);
        done = TRUE;
    }

    nautilus_file_updated_deep_count_in_progress (file);

    if (done)
    {
        nautilus_file_changed (file);
        async_job_end (directory, "deep count");
        nautilus_directory_async_state_changed (directory);
    }
}

nautilus_file_operations_delete (GList                  *files,
                                 GtkWindow              *parent_window,
                                 NautilusDeleteCallback  done_callback,
                                 gpointer                done_callback_data)
{
    trash_or_delete_internal (files, parent_window,
                              FALSE,
                              done_callback, done_callback_data);
}

nautilus_directory_invalidate_file_attributes (NautilusDirectory      *directory,
                                               NautilusFileAttributes  file_attributes)
{
    GList *node;

    cancel_loading_attributes (directory, file_attributes);

    for (node = directory->details->file_list; node != NULL; node = node->next)
    {
        nautilus_file_invalidate_attributes_internal (NAUTILUS_FILE (node->data),
                                                      file_attributes);
    }

    if (directory->details->as_file != NULL)
    {
        nautilus_file_invalidate_attributes_internal (directory->details->as_file,
                                                      file_attributes);
    }
}

nautilus_directory_call_when_ready_internal (NautilusDirectory         *directory,
                                             NautilusFile              *file,
                                             NautilusFileAttributes     file_attributes,
                                             gboolean                   wait_for_file_list,
                                             NautilusDirectoryCallback  directory_callback,
                                             NautilusFileCallback       file_callback,
                                             gpointer                   callback_data)
{
    ReadyCallback callback;

    g_assert (directory == NULL || NAUTILUS_IS_DIRECTORY (directory));
    g_assert (file == NULL || NAUTILUS_IS_FILE (file));
    g_assert (file != NULL || directory_callback != NULL);

    /* Construct a callback object. */
    callback.active = TRUE;
    callback.file = file;
    if (file == NULL)
    {
        callback.callback.directory = directory_callback;
    }
    else
    {
        callback.callback.file = file_callback;
    }
    callback.callback_data = callback_data;
    callback.request = nautilus_directory_set_up_request (file_attributes);
    if (wait_for_file_list)
    {
        REQUEST_SET_TYPE (callback.request, REQUEST_FILE_LIST);
    }

    /* Handle the NULL case. */
    if (directory == NULL)
    {
        ready_callback_call (NULL, &callback);
        return;
    }

    /* Check if the callback is already there. */
    if (g_list_find_custom (directory->details->call_when_ready_list,
                            &callback,
                            ready_callback_key_compare_only_active) != NULL)
    {
        if (file_callback != NULL && directory_callback != NULL)
        {
            g_warning ("tried to add a new callback while an old one was pending");
        }
        /* NULL callback means, just read it. Conflicts are ok. */
        return;
    }

    /* Add the new callback to the list. */
    directory->details->call_when_ready_list = g_list_prepend
                                                   (directory->details->call_when_ready_list,
                                                   g_memdup (&callback, sizeof (callback)));
    request_counter_add_request (directory->details->call_when_ready_counters,
                                 callback.request);

    /* Put the callback file or all the files on the work queue. */
    if (file != NULL)
    {
        nautilus_directory_add_file_to_work_queue (directory, file);
    }
    else
    {
        add_all_files_to_work_queue (directory);
    }

    nautilus_directory_async_state_changed (directory);
}

mark_desktop_file_trusted (CommonJob    *common,
                           GCancellable *cancellable,
                           GFile        *file,
                           gboolean      interactive)
{
    char *contents, *new_contents;
    gsize length, new_length;
GError *error;
guint32 current_perms, new_perms;
int response;
GFileInfo *info;

retry:
    error = NULL;
    if (!g_file_load_contents (file,
                               cancellable,
                               &contents, &length,
                               NULL, &error))
    {
        if (interactive)
        {
            response = run_error (common,
                                  g_strdup (_("Unable to mark launcher trusted (executable)")),
                                  error->message,
                                  NULL,
                                  FALSE,
                                  CANCEL, RETRY,
                                  NULL);
        }
        else
        {
            response = 0;
        }
        if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)
        {
            abort_job (common);
        }
        else if (response == 1)
        {
            goto retry;
        }
        else
        {
            g_assert_not_reached ();
        }
        goto out;
    }
    if (!g_str_has_prefix (contents, "#!"))
    {
        new_length = length + strlen (TRUSTED_SHEBANG);
        new_contents = g_malloc (new_length);
        strcpy (new_contents, TRUSTED_SHEBANG);
        memcpy (new_contents + strlen (TRUSTED_SHEBANG),
                contents, length);
        if (!g_file_replace_contents (file,
                                      new_contents,
                                      new_length,
                                      NULL,
                                      FALSE, 0,
                                      NULL, cancellable, &error))
        {
            g_free (contents);
            g_free (new_contents);
            if (interactive)
            {
                response = run_error (common,
                                      g_strdup (_("Unable to mark launcher trusted (executable)")),
                                      error->message,
                                      NULL,
                                      FALSE,
                                      CANCEL, RETRY,
                                      NULL);
            }
            else
            {
                response = 0;
            }
            if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)
            {
                abort_job (common);
            }
            else if (response == 1)
            {
                goto retry;
            }
            else
            {
                g_assert_not_reached ();
            }
            goto out;
        }
        g_free (new_contents);
    }
    g_free (contents);

info = g_file_query_info (file,
G_FILE_ATTRIBUTE_STANDARD_TYPE ","
G_FILE_ATTRIBUTE_UNIX_MODE,
G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,
common->cancellable,
&error);

if (info == NULL)
{
if (interactive)
{
response = run_error (common,
g_strdup (_("Unable to mark launcher trusted (executable)")),
error->message,
NULL,
FALSE,
CANCEL, RETRY,
NULL);
}
else
{
response = 0;
}

if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)
{
abort_job (common);
}
else if (response == 1)
{
goto retry;
}
else
{
g_assert_not_reached ();
}

goto out;
}


if (g_file_info_has_attribute (info, G_FILE_ATTRIBUTE_UNIX_MODE))
{
current_perms = g_file_info_get_attribute_uint32 (info, G_FILE_ATTRIBUTE_UNIX_MODE);
new_perms = current_perms | S_IXGRP | S_IXUSR | S_IXOTH;

if ((current_perms != new_perms) &&
!g_file_set_attribute_uint32 (file, G_FILE_ATTRIBUTE_UNIX_MODE,
new_perms, G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,
common->cancellable, &error))
{
g_object_unref (info);

if (interactive)
{
response = run_error (common,
g_strdup (_("Unable to mark launcher trusted (executable)")),
error->message,
NULL,
FALSE,
CANCEL, RETRY,
NULL);
}
else
{
response = 0;
}

if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)
{
abort_job (common);
}
else if (response == 1)
{
goto retry;
}
else
{
g_assert_not_reached ();
}

goto out;
}
}
g_object_unref (info);
out:
;
}

info_provider_callback (NautilusInfoProvider    *provider,
                        NautilusOperationHandle *handle,
                        NautilusOperationResult  result,
                        gpointer                 user_data)
{
    InfoProviderResponse *response;

    response = g_new0 (InfoProviderResponse, 1);
    response->provider = provider;
    response->handle = handle;
    response->result = result;
    response->directory = NAUTILUS_DIRECTORY (user_data);

    response->directory->details->extension_info_idle =
        g_idle_add_full (G_PRIORITY_DEFAULT_IDLE,
                         info_provider_idle_callback, response,
                         g_free);
}

should_skip_file (CommonJob *common,
                  GFile     *file)
{
    if (common->skip_files != NULL)
    {
        return g_hash_table_lookup (common->skip_files, file) != NULL;
    }
    return FALSE;
}

mount_start (NautilusDirectory *directory,
             NautilusFile      *file,
             gboolean          *doing_io)
{
    GFile *location;
    MountState *state;

    if (directory->details->mount_state != NULL)
    {
        *doing_io = TRUE;
        return;
    }

    if (!is_needy (file,
                   lacks_mount,
                   REQUEST_MOUNT))
    {
        return;
    }
    *doing_io = TRUE;

    if (!async_job_start (directory, "mount"))
    {
        return;
    }

    state = g_new0 (MountState, 1);
    state->directory = directory;
    state->file = file;
    state->cancellable = g_cancellable_new ();

    location = nautilus_file_get_location (file);

    directory->details->mount_state = state;

    if (file->details->type == G_FILE_TYPE_MOUNTABLE)
    {
        GFile *target;
        GMount *mount;

        mount = NULL;
        target = nautilus_file_get_activation_location (file);
        if (target != NULL)
        {
            mount = get_mount_at (target);
            g_object_unref (target);
        }

        got_mount (state, mount);

        if (mount)
        {
            g_object_unref (mount);
        }
    }
    else
    {
        g_file_find_enclosing_mount_async (location,
                                           G_PRIORITY_DEFAULT,
                                           state->cancellable,
                                           find_enclosing_mount_callback,
                                           state);
    }
    g_object_unref (location);
}

is_link_trusted (NautilusFile *file,
gboolean      is_launcher)
{
GFile *location;
gboolean res;

if (!is_launcher)
{
return TRUE;
}

    if (nautilus_file_can_execute (file))
{
return TRUE;
}

res = FALSE;

if (nautilus_file_is_local (file))
{
location = nautilus_file_get_location (file);
res = nautilus_is_in_system_dir (location);
g_object_unref (location);
}

return res;
}

request_counter_remove_request (RequestCounter counter,
                                Request        request)
{
    guint i;

    for (i = 0; i < REQUEST_TYPE_LAST; i++)
    {
        if (REQUEST_WANTS_TYPE (request, i))
        {
            counter[i]--;
        }
    }
}

directory_load_state_free (DirectoryLoadState *state)
{
    if (state->enumerator)
    {
        if (!g_file_enumerator_is_closed (state->enumerator))
        {
            g_file_enumerator_close_async (state->enumerator,
                                           0, NULL, NULL, NULL);
        }
        g_object_unref (state->enumerator);
    }

    if (state->load_mime_list_hash != NULL)
    {
        istr_set_destroy (state->load_mime_list_hash);
    }
    nautilus_file_unref (state->load_directory_file);
    g_object_unref (state->cancellable);
    g_free (state);
}

nautilus_file_operations_trash_or_delete (GList                  *files,
                                          GtkWindow              *parent_window,
                                          NautilusDeleteCallback  done_callback,
                                          gpointer                done_callback_data)
{
    trash_or_delete_internal (files, parent_window,
                              TRUE,
                              done_callback, done_callback_data);
}

cancel_mime_list_for_file (NautilusDirectory *directory,
                           NautilusFile      *file)
{
    if (directory->details->mime_list_in_progress != NULL &&
        directory->details->mime_list_in_progress->mime_list_file == file)
    {
        mime_list_cancel (directory);
    }
}

link_info_nautilus_link_read_callback (GObject      *source_object,
                                       GAsyncResult *res,
                                       gpointer      user_data)
{
    LinkInfoReadState *state;
    gsize file_size;
    char *file_contents;
    gboolean result;
    NautilusDirectory *directory;

    state = user_data;

    if (state->directory == NULL)
    {
        /* Operation was cancelled. Bail out */
        link_info_read_state_free (state);
        return;
    }

    directory = nautilus_directory_ref (state->directory);

    result = g_file_load_contents_finish (G_FILE (source_object),
                                          res,
                                          &file_contents, &file_size,
                                          NULL, NULL);

    state->directory->details->link_info_read_state = NULL;
    async_job_end (state->directory, "link info");

    link_info_got_data (state->directory, state->file, result, file_size, file_contents);

    if (result)
    {
        g_free (file_contents);
    }

    link_info_read_state_free (state);

    nautilus_directory_unref (directory);
}

extension_info_cancel (NautilusDirectory *directory)
{
    if (directory->details->extension_info_in_progress != NULL)
    {
        if (directory->details->extension_info_idle)
        {
            g_source_remove (directory->details->extension_info_idle);
        }
        else
        {
            nautilus_info_provider_cancel_update
                (directory->details->extension_info_provider,
                directory->details->extension_info_in_progress);
        }

        directory->details->extension_info_in_progress = NULL;
        directory->details->extension_info_file = NULL;
        directory->details->extension_info_provider = NULL;
        directory->details->extension_info_idle = 0;

        async_job_end (directory, "extension info");
    }
}

call_ready_callbacks (NautilusDirectory *directory)
{
    gboolean found_any;
    GList *node, *next;
    ReadyCallback *callback;

    found_any = FALSE;

    /* Check if any callbacks are satisifed and mark them for call them if they are. */
    for (node = directory->details->call_when_ready_list;
         node != NULL; node = next)
    {
        next = node->next;
        callback = node->data;
        if (callback->active &&
            request_is_satisfied (directory, callback->file, callback->request))
        {
            callback->active = FALSE;
            found_any = TRUE;
        }
    }

    if (found_any)
    {
        schedule_call_ready_callbacks (directory);
    }

    return found_any;
}

cancel_link_info_for_file (NautilusDirectory *directory,
                           NautilusFile      *file)
{
    if (directory->details->link_info_read_state != NULL &&
        directory->details->link_info_read_state->file == file)
    {
        link_info_cancel (directory);
    }
}

delete_task_done (GObject      *source_object,
                  GAsyncResult *res,
                  gpointer      user_data)
{
    DeleteJob *job;
    GHashTable *debuting_uris;

    job = user_data;

    g_list_free_full (job->files, g_object_unref);

    if (job->done_callback)
    {
        debuting_uris = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);
        job->done_callback (debuting_uris, job->user_cancel, job->done_callback_data);
        g_hash_table_unref (debuting_uris);
    }

    finalize_common ((CommonJob *) job);

    nautilus_file_changes_consume_changes (TRUE);
}

choose_program (GtkDialog *message_dialog,
                int        response,
                gpointer   callback_data)
{
    GtkWidget *dialog;
    NautilusFile *file;
    GFile *location;
    ActivateParametersInstall *parameters = callback_data;

    if (response != GTK_RESPONSE_ACCEPT)
    {
        gtk_widget_destroy (GTK_WIDGET (message_dialog));
        activate_parameters_install_free (parameters);
        return;
    }

    file = g_object_get_data (G_OBJECT (message_dialog), "mime-action:file");

    g_assert (NAUTILUS_IS_FILE (file));

    location = nautilus_file_get_location (file);
    nautilus_file_ref (file);

    /* Destroy the message dialog after ref:ing the file */
    gtk_widget_destroy (GTK_WIDGET (message_dialog));

    dialog = gtk_app_chooser_dialog_new (parameters->parent_window,
                                         GTK_DIALOG_MODAL,
                                         location);
    g_object_set_data_full (G_OBJECT (dialog),
                            "mime-action:file",
                            nautilus_file_ref (file),
                            (GDestroyNotify) nautilus_file_unref);

    gtk_widget_show (dialog);

    g_signal_connect (dialog,
                      "response",
                      G_CALLBACK (open_with_response_cb),
                      parameters);

    g_object_unref (location);
    nautilus_file_unref (file);
}

nautilus_mime_file_extracts (NautilusFile *file)
{
    return get_activation_action (file) == ACTIVATION_ACTION_EXTRACT;
}

cancel_activate_callback (gpointer callback_data)
{
    ActivateParameters *parameters = callback_data;

    parameters->timed_wait_active = FALSE;

    g_cancellable_cancel (parameters->cancellable);

    if (parameters->files_handle)
    {
        nautilus_file_list_cancel_call_when_ready (parameters->files_handle);
        parameters->files_handle = NULL;
        activation_parameters_free (parameters);
    }
}

skip_file (CommonJob *common,
           GFile     *file)
{
    if (common->skip_files == NULL)
    {
        common->skip_files =
            g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);
    }

    g_hash_table_insert (common->skip_files, g_object_ref (file), file);
}

empty_trash_task_done (GObject      *source_object,
                       GAsyncResult *res,
                       gpointer      user_data)
{
    EmptyTrashJob *job;

    job = user_data;

    g_list_free_full (job->trash_dirs, g_object_unref);

    if (job->done_callback)
    {
        job->done_callback (!job_aborted ((CommonJob *) job),
                            job->done_callback_data);
    }

    finalize_common ((CommonJob *) job);
}

custom_time_to_string (char    *format,
                       va_list  va)
{
    int secs;

    secs = va_arg (va, int);
    return format_time (secs);
}

cancel_directory_count_for_file (NautilusDirectory *directory,
                                 NautilusFile      *file)
{
    if (directory->details->count_in_progress != NULL &&
        directory->details->count_in_progress->count_file == file)
    {
        directory_count_cancel (directory);
    }
}

nautilus_file_operations_extract_files (GList                   *files,
                                        GFile                   *destination_directory,
                                        GtkWindow               *parent_window,
                                        NautilusExtractCallback  done_callback,
                                        gpointer                 done_callback_data)
{
    ExtractJob *extract_job;
    g_autoptr (GTask) task = NULL;

    extract_job = op_job_new (ExtractJob, parent_window);
    extract_job->source_files = g_list_copy_deep (files,
                                                  (GCopyFunc) g_object_ref,
                                                  NULL);
    extract_job->destination_directory = g_object_ref (destination_directory);
    extract_job->done_callback = done_callback;
    extract_job->done_callback_data = done_callback_data;

    inhibit_power_manager ((CommonJob *) extract_job, _("Extracting Files"));

    if (!nautilus_file_undo_manager_is_operating ())
    {
        extract_job->common.undo_info = nautilus_file_undo_info_extract_new (files,
                                                                             destination_directory);
    }

    task = g_task_new (NULL, extract_job->common.cancellable,
                       extract_task_done, extract_job);
    g_task_set_task_data (task, extract_job, NULL);
    g_task_run_in_thread (task, extract_task_thread_func);
}

search_for_application_mime_type (ActivateParametersInstall *parameters_install,
                                  const gchar               *mime_type)
{
    GdkWindow *window;
    guint xid = 0;
    const char *mime_types[2];

    g_assert (parameters_install->proxy != NULL);

    /* get XID from parent window */
    window = gtk_widget_get_window (GTK_WIDGET (parameters_install->parent_window));
    if (window != NULL)
    {
        xid = GDK_WINDOW_XID (window);
    }

    mime_types[0] = mime_type;
    mime_types[1] = NULL;

    g_dbus_proxy_call (parameters_install->proxy,
                       "InstallMimeTypes",
                       g_variant_new ("(u^ass)",
                                      xid,
                                      mime_types,
                                      "hide-confirm-search"),
                       G_DBUS_CALL_FLAGS_NONE,
                       G_MAXINT /* no timeout */,
                       NULL /* cancellable */,
                       (GAsyncReadyCallback) search_for_application_dbus_call_notify_cb,
                       parameters_install);

    DEBUG ("InstallMimeType method invoked for %s", mime_type);
}

report_trash_progress (CommonJob    *job,
                       SourceInfo   *source_info,
                       TransferInfo *transfer_info)
{
    int files_left;
    double elapsed, transfer_rate;
    int remaining_time;
    gint64 now;
    char *details;
    char *status;
    DeleteJob *delete_job;

    delete_job = (DeleteJob *) job;
    now = g_get_monotonic_time ();
    files_left = source_info->num_files - transfer_info->num_files;

    /* Races and whatnot could cause this to be negative... */
    if (files_left < 0)
    {
        files_left = 0;
    }

    /* If the number of files left is 0, we want to update the status without
     * considering this time, since we want to change the status to completed
     * and probably we won't get more calls to this function */
    if (transfer_info->last_report_time != 0 &&
        ABS ((gint64) (transfer_info->last_report_time - now)) < 100 * NSEC_PER_MICROSEC &&
        files_left > 0)
    {
        return;
    }

    transfer_info->last_report_time = now;

    if (source_info->num_files == 1)
    {
        if (files_left > 0)
        {
            status = _("Trashing “%B”");
        }
        else
        {
            status = _("Trashed “%B”");
        }
        nautilus_progress_info_take_status (job->progress,
                                            f (status,
                                               (GFile *) delete_job->files->data));
    }
    else
    {
        if (files_left > 0)
        {
            status = ngettext ("Trashing %'d file",
                               "Trashing %'d files",
                               source_info->num_files);
        }
        else
        {
            status = ngettext ("Trashed %'d file",
                               "Trashed %'d files",
                               source_info->num_files);
        }
        nautilus_progress_info_take_status (job->progress,
                                            f (status,
                                               source_info->num_files));
    }


    elapsed = g_timer_elapsed (job->time, NULL);
    transfer_rate = 0;
    remaining_time = INT_MAX;
    if (elapsed > 0)
    {
        transfer_rate = transfer_info->num_files / elapsed;
        if (transfer_rate > 0)
        {
            remaining_time = (source_info->num_files - transfer_info->num_files) / transfer_rate;
        }
    }

    if (elapsed < SECONDS_NEEDED_FOR_RELIABLE_TRANSFER_RATE)
    {
        if (files_left > 0)
        {
            /* To translators: %'d is the number of files completed for the operation,
             * so it will be something like 2/14. */
            details = f (_("%'d / %'d"),
                         transfer_info->num_files + 1,
                         source_info->num_files);
        }
        else
        {
            /* To translators: %'d is the number of files completed for the operation,
             * so it will be something like 2/14. */
            details = f (_("%'d / %'d"),
                         transfer_info->num_files,
                         source_info->num_files);
        }
    }
    else
    {
        if (files_left > 0)
        {
            gchar *time_left_message;
            gchar *files_per_second_message;
            gchar *concat_detail;

            /* To translators: %T will expand to a time duration like "2 minutes".
             * So the whole thing will be something like "1 / 5 -- 2 hours left (4 files/sec)"
             *
             * The singular/plural form will be used depending on the remaining time (i.e. the %T argument).
             */
            time_left_message = ngettext ("%'d / %'d \xE2\x80\x94 %T left",
                                          "%'d / %'d \xE2\x80\x94 %T left",
                                          seconds_count_format_time_units (remaining_time));
            files_per_second_message = ngettext ("(%d file/sec)",
                                                 "(%d files/sec)",
                                                 (int) (transfer_rate + 0.5));
            concat_detail = g_strconcat (time_left_message, " ", files_per_second_message, NULL);

            details = f (concat_detail,
                         transfer_info->num_files + 1, source_info->num_files,
                         remaining_time,
                         (int) transfer_rate + 0.5);

            g_free (concat_detail);
        }
        else
        {
            /* To translators: %'d is the number of files completed for the operation,
             * so it will be something like 2/14. */
            details = f (_("%'d / %'d"),
                         transfer_info->num_files,
                         source_info->num_files);
        }
    }
    nautilus_progress_info_set_details (job->progress, details);

    if (elapsed > SECONDS_NEEDED_FOR_APROXIMATE_TRANSFER_RATE)
    {
        nautilus_progress_info_set_remaining_time (job->progress,
                                                   remaining_time);
        nautilus_progress_info_set_elapsed_time (job->progress,
                                                 elapsed);
    }

    if (source_info->num_files != 0)
    {
        nautilus_progress_info_set_progress (job->progress, transfer_info->num_files, source_info->num_files);
    }
}

mount_callback_data_notify (gpointer  data,
                            GObject  *object)
{
    GMountOperation *mount_op;

    mount_op = G_MOUNT_OPERATION (data);
    g_object_set_data (G_OBJECT (mount_op), "mount-callback", NULL);
    g_object_set_data (G_OBJECT (mount_op), "mount-callback-data", NULL);
}

lacks_thumbnail (NautilusFile *file)
{
    return nautilus_file_should_show_thumbnail (file) &&
           file->details->thumbnail_path != NULL &&
           !file->details->thumbnail_is_up_to_date;
}

existing_file_removed_callback (GFile    *file,
                                GError   *error,
                                gpointer  callback_data)
{
    DeleteExistingFileData *data = callback_data;
    CommonJob *job;
    GFile *source;
    GFileType file_type;
    char *primary;
    char *secondary;
    char *details = NULL;
    int response;

    job = data->job;
    source = data->source;

    if (error == NULL)
    {
        nautilus_file_changes_queue_file_removed (file);

        return;
    }

    if (job_aborted (job) || job->skip_all_error)
    {
        return;
    }

    primary = f (_("Error while copying “%B”."), source);

    file_type = g_file_query_file_type (file,
                                        G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,
                                        job->cancellable);

    if (file_type == G_FILE_TYPE_DIRECTORY)
    {
        secondary = f (_("Could not remove the already existing folder %F."),
                       file);
    }
    else
    {
        secondary = f (_("Could not remove the already existing file %F."),
                       file);
    }

    details = error->message;

    /* set show_all to TRUE here, as we don't know how many
     * files we'll end up processing yet.
     */
    response = run_warning (job,
                            primary,
                            secondary,
                            details,
                            TRUE,
                            CANCEL, SKIP_ALL, SKIP,
                            NULL);

    if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)
    {
        abort_job (job);
    }
    else if (response == 1)
    {
        /* skip all */
        job->skip_all_error = TRUE;
    }
}

move_file_prepare (CopyMoveJob  *move_job,
                   GFile        *src,
                   GFile        *dest_dir,
                   gboolean      same_fs,
                   char        **dest_fs_type,
                   GHashTable   *debuting_files,
                   GdkPoint     *position,
                   GList       **fallback_files,
                   int           files_left)
{
    GFile *dest, *new_dest;
    g_autofree gchar *dest_uri = NULL;
    GError *error;
    CommonJob *job;
    gboolean overwrite;
    char *primary, *secondary, *details;
    int response;
    GFileCopyFlags flags;
    MoveFileCopyFallback *fallback;
    gboolean handled_invalid_filename;

    overwrite = FALSE;
    handled_invalid_filename = *dest_fs_type != NULL;

    job = (CommonJob *) move_job;

    dest = get_target_file (src, dest_dir, *dest_fs_type, same_fs);


    /* Don't allow recursive move/copy into itself.
     * (We would get a file system error if we proceeded but it is nicer to
     * detect and report it at this level) */
    if (test_dir_is_parent (dest_dir, src))
    {
        if (job->skip_all_error)
        {
            goto out;
        }

        /*  the run_warning() frees all strings passed in automatically  */
        primary = move_job->is_move ? g_strdup (_("You cannot move a folder into itself."))
                  : g_strdup (_("You cannot copy a folder into itself."));
        secondary = g_strdup (_("The destination folder is inside the source folder."));

        response = run_warning (job,
                                primary,
                                secondary,
                                NULL,
                                files_left > 1,
                                CANCEL, SKIP_ALL, SKIP,
                                NULL);

        if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)
        {
            abort_job (job);
        }
        else if (response == 1)             /* skip all */
        {
            job->skip_all_error = TRUE;
        }
        else if (response == 2)             /* skip */
        {               /* do nothing */
        }
        else
        {
            g_assert_not_reached ();
        }

        goto out;
    }

retry:

    flags = G_FILE_COPY_NOFOLLOW_SYMLINKS | G_FILE_COPY_NO_FALLBACK_FOR_MOVE;
    if (overwrite)
    {
        flags |= G_FILE_COPY_OVERWRITE;
    }

    error = NULL;
    if (g_file_move (src, dest,
                     flags,
                     job->cancellable,
                     NULL,
                     NULL,
                     &error))
    {
        if (debuting_files)
        {
            g_hash_table_replace (debuting_files, g_object_ref (dest), GINT_TO_POINTER (TRUE));
        }

        nautilus_file_changes_queue_file_moved (src, dest);

        dest_uri = g_file_get_uri (dest);
        if (position)
        {
            nautilus_file_changes_queue_schedule_position_set (dest, *position, job->screen_num);
        }
        else if (eel_uri_is_desktop (dest_uri))
        {
            nautilus_file_changes_queue_schedule_position_remove (dest);
        }

        if (job->undo_info != NULL)
        {
            nautilus_file_undo_info_ext_add_origin_target_pair (NAUTILUS_FILE_UNDO_INFO_EXT (job->undo_info),
                                                                src, dest);
        }

        return;
    }

    if (IS_IO_ERROR (error, INVALID_FILENAME) &&
        !handled_invalid_filename)
    {
        g_error_free (error);

        handled_invalid_filename = TRUE;

        g_assert (*dest_fs_type == NULL);
        *dest_fs_type = query_fs_type (dest_dir, job->cancellable);

        new_dest = get_target_file (src, dest_dir, *dest_fs_type, same_fs);
        if (!g_file_equal (dest, new_dest))
        {
            g_object_unref (dest);
            dest = new_dest;
            goto retry;
        }
        else
        {
            g_object_unref (new_dest);
        }
    }
    /* Conflict */
    else if (!overwrite &&
             IS_IO_ERROR (error, EXISTS))
    {
        gboolean is_merge;
        FileConflictResponse *response;

        g_error_free (error);

        is_merge = FALSE;
        if (is_dir (dest) && is_dir (src))
        {
            is_merge = TRUE;
        }

        if ((is_merge && job->merge_all) ||
            (!is_merge && job->replace_all))
        {
            overwrite = TRUE;
            goto retry;
        }

        if (job->skip_all_conflict)
        {
            goto out;
        }

        response = handle_copy_move_conflict (job, src, dest, dest_dir);

        if (response->id == GTK_RESPONSE_CANCEL ||
            response->id == GTK_RESPONSE_DELETE_EVENT)
        {
            file_conflict_response_free (response);
            abort_job (job);
        }
        else if (response->id == CONFLICT_RESPONSE_SKIP)
        {
            if (response->apply_to_all)
            {
                job->skip_all_conflict = TRUE;
            }
            file_conflict_response_free (response);
        }
        else if (response->id == CONFLICT_RESPONSE_REPLACE)             /* merge/replace */
        {
            if (response->apply_to_all)
            {
                if (is_merge)
                {
                    job->merge_all = TRUE;
                }
                else
                {
                    job->replace_all = TRUE;
                }
            }
            overwrite = TRUE;
            file_conflict_response_free (response);
            goto retry;
        }
        else if (response->id == CONFLICT_RESPONSE_RENAME)
        {
            g_object_unref (dest);
            dest = get_target_file_for_display_name (dest_dir,
                                                     response->new_name);
            file_conflict_response_free (response);
            goto retry;
        }
        else
        {
            g_assert_not_reached ();
        }
    }
    else if (IS_IO_ERROR (error, WOULD_RECURSE) ||
             IS_IO_ERROR (error, WOULD_MERGE) ||
             IS_IO_ERROR (error, NOT_SUPPORTED) ||
             (overwrite && IS_IO_ERROR (error, IS_DIRECTORY)))
    {
        g_error_free (error);

        fallback = move_copy_file_callback_new (src,
                                                overwrite,
                                                position);
        *fallback_files = g_list_prepend (*fallback_files, fallback);
    }
    else if (IS_IO_ERROR (error, CANCELLED))
    {
        g_error_free (error);
    }
    /* Other error */
    else
    {
        if (job->skip_all_error)
        {
            g_error_free (error);
            goto out;
        }
        primary = f (_("Error while moving “%B”."), src);
        secondary = f (_("There was an error moving the file into %F."), dest_dir);
        details = error->message;

        response = run_warning (job,
                                primary,
                                secondary,
                                details,
                                files_left > 1,
                                CANCEL, SKIP_ALL, SKIP,
                                NULL);

        g_error_free (error);

        if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)
        {
            abort_job (job);
        }
        else if (response == 1)             /* skip all */
        {
            job->skip_all_error = TRUE;
        }
        else if (response == 2)             /* skip */
        {               /* do nothing */
        }
        else
        {
            g_assert_not_reached ();
        }
    }

out:
    g_object_unref (dest);
}

nautilus_self_check_file_operations (void)
{
    setlocale (LC_MESSAGES, "C");


    /* test the next duplicate name generator */
    EEL_CHECK_STRING_RESULT (get_duplicate_name (" (copy)", 1, -1), " (another copy)");
    EEL_CHECK_STRING_RESULT (get_duplicate_name ("foo", 1, -1), "foo (copy)");
    EEL_CHECK_STRING_RESULT (get_duplicate_name (".bashrc", 1, -1), ".bashrc (copy)");
    EEL_CHECK_STRING_RESULT (get_duplicate_name (".foo.txt", 1, -1), ".foo (copy).txt");
    EEL_CHECK_STRING_RESULT (get_duplicate_name ("foo foo", 1, -1), "foo foo (copy)");
    EEL_CHECK_STRING_RESULT (get_duplicate_name ("foo.txt", 1, -1), "foo (copy).txt");
    EEL_CHECK_STRING_RESULT (get_duplicate_name ("foo foo.txt", 1, -1), "foo foo (copy).txt");
    EEL_CHECK_STRING_RESULT (get_duplicate_name ("foo foo.txt txt", 1, -1), "foo foo (copy).txt txt");
    EEL_CHECK_STRING_RESULT (get_duplicate_name ("foo...txt", 1, -1), "foo.. (copy).txt");
    EEL_CHECK_STRING_RESULT (get_duplicate_name ("foo...", 1, -1), "foo... (copy)");
    EEL_CHECK_STRING_RESULT (get_duplicate_name ("foo. (copy)", 1, -1), "foo. (another copy)");
    EEL_CHECK_STRING_RESULT (get_duplicate_name ("foo (copy)", 1, -1), "foo (another copy)");
    EEL_CHECK_STRING_RESULT (get_duplicate_name ("foo (copy).txt", 1, -1), "foo (another copy).txt");
    EEL_CHECK_STRING_RESULT (get_duplicate_name ("foo (another copy)", 1, -1), "foo (3rd copy)");
    EEL_CHECK_STRING_RESULT (get_duplicate_name ("foo (another copy).txt", 1, -1), "foo (3rd copy).txt");
    EEL_CHECK_STRING_RESULT (get_duplicate_name ("foo foo (another copy).txt", 1, -1), "foo foo (3rd copy).txt");
    EEL_CHECK_STRING_RESULT (get_duplicate_name ("foo (13th copy)", 1, -1), "foo (14th copy)");
    EEL_CHECK_STRING_RESULT (get_duplicate_name ("foo (13th copy).txt", 1, -1), "foo (14th copy).txt");
    EEL_CHECK_STRING_RESULT (get_duplicate_name ("foo (21st copy)", 1, -1), "foo (22nd copy)");
    EEL_CHECK_STRING_RESULT (get_duplicate_name ("foo (21st copy).txt", 1, -1), "foo (22nd copy).txt");
    EEL_CHECK_STRING_RESULT (get_duplicate_name ("foo (22nd copy)", 1, -1), "foo (23rd copy)");
    EEL_CHECK_STRING_RESULT (get_duplicate_name ("foo (22nd copy).txt", 1, -1), "foo (23rd copy).txt");
    EEL_CHECK_STRING_RESULT (get_duplicate_name ("foo (23rd copy)", 1, -1), "foo (24th copy)");
    EEL_CHECK_STRING_RESULT (get_duplicate_name ("foo (23rd copy).txt", 1, -1), "foo (24th copy).txt");
    EEL_CHECK_STRING_RESULT (get_duplicate_name ("foo (24th copy)", 1, -1), "foo (25th copy)");
    EEL_CHECK_STRING_RESULT (get_duplicate_name ("foo (24th copy).txt", 1, -1), "foo (25th copy).txt");
    EEL_CHECK_STRING_RESULT (get_duplicate_name ("foo foo (24th copy)", 1, -1), "foo foo (25th copy)");
    EEL_CHECK_STRING_RESULT (get_duplicate_name ("foo foo (24th copy).txt", 1, -1), "foo foo (25th copy).txt");
    EEL_CHECK_STRING_RESULT (get_duplicate_name ("foo foo (100000000000000th copy).txt", 1, -1), "foo foo (copy).txt");
    EEL_CHECK_STRING_RESULT (get_duplicate_name ("foo (10th copy)", 1, -1), "foo (11th copy)");
    EEL_CHECK_STRING_RESULT (get_duplicate_name ("foo (10th copy).txt", 1, -1), "foo (11th copy).txt");
    EEL_CHECK_STRING_RESULT (get_duplicate_name ("foo (11th copy)", 1, -1), "foo (12th copy)");
    EEL_CHECK_STRING_RESULT (get_duplicate_name ("foo (11th copy).txt", 1, -1), "foo (12th copy).txt");
    EEL_CHECK_STRING_RESULT (get_duplicate_name ("foo (12th copy)", 1, -1), "foo (13th copy)");
    EEL_CHECK_STRING_RESULT (get_duplicate_name ("foo (12th copy).txt", 1, -1), "foo (13th copy).txt");
    EEL_CHECK_STRING_RESULT (get_duplicate_name ("foo (110th copy)", 1, -1), "foo (111th copy)");
    EEL_CHECK_STRING_RESULT (get_duplicate_name ("foo (110th copy).txt", 1, -1), "foo (111th copy).txt");
    EEL_CHECK_STRING_RESULT (get_duplicate_name ("foo (122nd copy)", 1, -1), "foo (123rd copy)");
    EEL_CHECK_STRING_RESULT (get_duplicate_name ("foo (122nd copy).txt", 1, -1), "foo (123rd copy).txt");
    EEL_CHECK_STRING_RESULT (get_duplicate_name ("foo (123rd copy)", 1, -1), "foo (124th copy)");
    EEL_CHECK_STRING_RESULT (get_duplicate_name ("foo (123rd copy).txt", 1, -1), "foo (124th copy).txt");

    setlocale (LC_MESSAGES, "");
}

file_info_start (NautilusDirectory *directory,
                 NautilusFile      *file,
                 gboolean          *doing_io)
{
    GFile *location;
    GetInfoState *state;

    file_info_stop (directory);

    if (directory->details->get_info_in_progress != NULL)
    {
        *doing_io = TRUE;
        return;
    }

    if (!is_needy (file, lacks_info, REQUEST_FILE_INFO))
    {
        return;
    }
    *doing_io = TRUE;

    if (!async_job_start (directory, "file info"))
    {
        return;
    }

    directory->details->get_info_file = file;
    file->details->get_info_failed = FALSE;
    if (file->details->get_info_error)
    {
        g_error_free (file->details->get_info_error);
        file->details->get_info_error = NULL;
    }

    state = g_new (GetInfoState, 1);
    state->directory = directory;
    state->cancellable = g_cancellable_new ();

    directory->details->get_info_in_progress = state;

    location = nautilus_file_get_location (file);
    g_file_query_info_async (location,
                             NAUTILUS_FILE_DEFAULT_ATTRIBUTES,
                             0,
                             G_PRIORITY_DEFAULT,
                             state->cancellable, query_info_callback, state);
    g_object_unref (location);
}

trash_or_delete_files (GtkWindow   *parent_window,
                       const GList *files,
                       gboolean     delete_if_all_already_in_trash)
{
    GList *locations;
    const GList *node;

    locations = NULL;
    for (node = files; node != NULL; node = node->next)
    {
        locations = g_list_prepend (locations,
                                    nautilus_file_get_location ((NautilusFile *) node->data));
    }

    locations = g_list_reverse (locations);

    nautilus_file_operations_trash_or_delete (locations,
                                              parent_window,
                                              NULL, NULL);
    g_list_free_full (locations, g_object_unref);
}

extract_job_on_completed (AutoarExtractor *extractor,
                          gpointer         user_data)
{
    ExtractJob *extract_job = user_data;
    GFile *output_file;

    output_file = G_FILE (extract_job->output_files->data);

    nautilus_file_changes_queue_file_added (output_file);
}

nautilus_directory_check_if_ready_internal (NautilusDirectory      *directory,
                                            NautilusFile           *file,
                                            NautilusFileAttributes  file_attributes)
{
    Request request;

    g_assert (NAUTILUS_IS_DIRECTORY (directory));

    request = nautilus_directory_set_up_request (file_attributes);
    return request_is_satisfied (directory, file, request);
}

info_provider_idle_callback (gpointer user_data)
{
    InfoProviderResponse *response;
    NautilusDirectory *directory;

    response = user_data;
    directory = response->directory;

    if (response->handle != directory->details->extension_info_in_progress
        || response->provider != directory->details->extension_info_provider)
    {
        g_warning ("Unexpected plugin response.  This probably indicates a bug in a Nautilus extension: handle=%p", response->handle);
    }
    else
    {
        NautilusFile *file;
        async_job_end (directory, "extension info");

        file = directory->details->extension_info_file;

        directory->details->extension_info_file = NULL;
        directory->details->extension_info_provider = NULL;
        directory->details->extension_info_in_progress = NULL;
        directory->details->extension_info_idle = 0;

        finish_info_provider (directory, file, response->provider);
    }

    return FALSE;
}

file_was_cancelled (NautilusFile *file)
{
    GError *error;

    error = nautilus_file_get_file_info_error (file);
    return
        error != NULL &&
        error->domain == G_IO_ERROR &&
        error->code == G_IO_ERROR_CANCELLED;
}

count_children_done (NautilusDirectory *directory,
                     NautilusFile      *count_file,
                     gboolean           succeeded,
                     int                count)
{
    g_assert (NAUTILUS_IS_FILE (count_file));

    count_file->details->directory_count_is_up_to_date = TRUE;

    /* Record either a failure or success. */
    if (!succeeded)
    {
        count_file->details->directory_count_failed = TRUE;
        count_file->details->got_directory_count = FALSE;
        count_file->details->directory_count = 0;
    }
    else
    {
        count_file->details->directory_count_failed = FALSE;
        count_file->details->got_directory_count = TRUE;
        count_file->details->directory_count = count;
    }
    directory->details->count_in_progress = NULL;

    /* Send file-changed even if count failed, so interested parties can
     * distinguish between unknowable and not-yet-known cases.
     */
    nautilus_file_changed (count_file);

    /* Start up the next one. */
    async_job_end (directory, "directory count");
    nautilus_directory_async_state_changed (directory);
}

extract_job_on_progress (AutoarExtractor *extractor,
                         guint64          archive_current_decompressed_size,
                         guint            archive_current_decompressed_files,
                         gpointer         user_data)
{
    ExtractJob *extract_job = user_data;
    CommonJob *common = user_data;
    GFile *source_file;
    char *details;
    double elapsed;
    double transfer_rate;
    int remaining_time;
    guint64 archive_total_decompressed_size;
    gdouble archive_weight;
    gdouble archive_decompress_progress;
    guint64 job_completed_size;
    gdouble job_progress;

    source_file = autoar_extractor_get_source_file (extractor);

    nautilus_progress_info_take_status (common->progress,
                                        f (_("Extracting “%B”"), source_file));

    archive_total_decompressed_size = autoar_extractor_get_total_size (extractor);

    archive_decompress_progress = (gdouble) archive_current_decompressed_size /
                                  (gdouble) archive_total_decompressed_size;

    archive_weight = 0;
    if (extract_job->total_compressed_size)
    {
        archive_weight = (gdouble) extract_job->archive_compressed_size /
                         (gdouble) extract_job->total_compressed_size;
    }

    job_progress = archive_decompress_progress * archive_weight + extract_job->base_progress;

    elapsed = g_timer_elapsed (common->time, NULL);

    transfer_rate = 0;
    remaining_time = -1;

    job_completed_size = job_progress * extract_job->total_compressed_size;

    if (elapsed > 0)
    {
        transfer_rate = job_completed_size / elapsed;
    }
    if (transfer_rate > 0)
    {
        remaining_time = (extract_job->total_compressed_size - job_completed_size) /
                         transfer_rate;
    }

    if (elapsed < SECONDS_NEEDED_FOR_RELIABLE_TRANSFER_RATE ||
        transfer_rate == 0)
    {
        /* To translators: %S will expand to a size like "2 bytes" or
         * "3 MB", so something like "4 kb / 4 MB"
         */
        details = f (_("%S / %S"), job_completed_size, extract_job->total_compressed_size);
    }
    else
    {
        /* To translators: %S will expand to a size like "2 bytes" or
         * "3 MB", %T to a time duration like "2 minutes". So the whole
         * thing will be something like
         * "2 kb / 4 MB -- 2 hours left (4kb/sec)"
         *
         * The singular/plural form will be used depending on the
         * remaining time (i.e. the %T argument).
         */
        details = f (ngettext ("%S / %S \xE2\x80\x94 %T left (%S/sec)",
                               "%S / %S \xE2\x80\x94 %T left (%S/sec)",
                               seconds_count_format_time_units (remaining_time)),
                     job_completed_size, extract_job->total_compressed_size,
                     remaining_time,
                     (goffset) transfer_rate);
    }

    nautilus_progress_info_take_details (common->progress, details);

    if (elapsed > SECONDS_NEEDED_FOR_APROXIMATE_TRANSFER_RATE)
    {
        nautilus_progress_info_set_remaining_time (common->progress,
                                                   remaining_time);
        nautilus_progress_info_set_elapsed_time (common->progress,
                                                 elapsed);
    }

    nautilus_progress_info_set_progress (common->progress, job_progress, 1);
}

show_hidden_files_changed_callback (gpointer callback_data)
{
    show_hidden_files = g_settings_get_boolean (gtk_filechooser_preferences, NAUTILUS_PREFERENCES_SHOW_HIDDEN_FILES);
}

shorten_utf8_string (const char *base,
                     int         reduce_by_num_bytes)
{
    int len;
    char *ret;
    const char *p;

    len = strlen (base);
    len -= reduce_by_num_bytes;

    if (len <= 0)
    {
        return NULL;
    }

    ret = g_new (char, len + 1);

    p = base;
    while (len)
    {
        char *next;
        next = g_utf8_next_char (p);
        if (next - p > len || *next == '\0')
        {
            break;
        }

        len -= next - p;
        p = next;
    }

    if (p - base == 0)
    {
        g_free (ret);
        return NULL;
    }
    else
    {
        memcpy (ret, base, p - base);
        ret[p - base] = '\0';
        return ret;
    }
}

get_info_state_free (GetInfoState *state)
{
    g_object_unref (state->cancellable);
    g_free (state);
}

add_istr_to_list (gpointer key,
                  gpointer value,
                  gpointer callback_data)
{
    GList **list;

    list = callback_data;
    *list = g_list_prepend (*list, g_strdup (key));
}

list_mime_enum_callback (GObject      *source_object,
                         GAsyncResult *res,
                         gpointer      user_data)
{
    MimeListState *state;
    GFileEnumerator *enumerator;
    NautilusDirectory *directory;
    GError *error;

    state = user_data;

    if (g_cancellable_is_cancelled (state->cancellable))
    {
        /* Operation was cancelled. Bail out */
        directory = state->directory;
        directory->details->mime_list_in_progress = NULL;

        async_job_end (directory, "MIME list");
        nautilus_directory_async_state_changed (directory);

        mime_list_state_free (state);

        return;
    }

    error = NULL;
    enumerator = g_file_enumerate_children_finish (G_FILE (source_object),
                                                   res, &error);

    if (enumerator == NULL)
    {
        mime_list_done (state, FALSE);
        g_error_free (error);
        mime_list_state_free (state);
        return;
    }
    else
    {
        state->enumerator = enumerator;
        g_file_enumerator_next_files_async (state->enumerator,
                                            DIRECTORY_LOAD_ITEMS_PER_CALLBACK,
                                            G_PRIORITY_DEFAULT,
                                            state->cancellable,
                                            mime_list_callback,
                                            state);
    }
}

mime_list_done (MimeListState *state,
                gboolean       success)
{
    NautilusFile *file;
    NautilusDirectory *directory;

    directory = state->directory;
    g_assert (directory != NULL);

    file = state->mime_list_file;

    file->details->mime_list_is_up_to_date = TRUE;
    g_list_free_full (file->details->mime_list, g_free);
    if (success)
    {
        file->details->mime_list_failed = TRUE;
        file->details->mime_list = NULL;
    }
    else
    {
        file->details->got_mime_list = TRUE;
        file->details->mime_list = istr_set_get_as_list (state->mime_list_hash);
    }
    directory->details->mime_list_in_progress = NULL;

    /* Send file-changed even if getting the item type list
     * failed, so interested parties can distinguish between
     * unknowable and not-yet-known cases.
     */
    nautilus_file_changed (file);

    /* Start up the next one. */
    async_job_end (directory, "MIME list");
    nautilus_directory_async_state_changed (directory);
}

should_confirm_trash (void)
{
    GSettings *prefs;
    gboolean confirm_trash;

    prefs = g_settings_new ("org.gnome.nautilus.preferences");
    confirm_trash = g_settings_get_boolean (prefs, NAUTILUS_PREFERENCES_CONFIRM_TRASH);
    g_object_unref (prefs);
    return confirm_trash;
}

launch_location_list_free (GList *list)
{
    g_list_foreach (list, (GFunc) launch_location_free, NULL);
    g_list_free (list);
}

link_task_done (GObject      *source_object,
                GAsyncResult *res,
                gpointer      user_data)
{
    CopyMoveJob *job;

    job = user_data;
    if (job->done_callback)
    {
        job->done_callback (job->debuting_files,
                            !job_aborted ((CommonJob *) job),
                            job->done_callback_data);
    }

    g_list_free_full (job->files, g_object_unref);
    g_object_unref (job->destination);
    g_hash_table_unref (job->debuting_files);
    g_free (job->icon_positions);

    finalize_common ((CommonJob *) job);

    nautilus_file_changes_consume_changes (TRUE);
}

custom_time_skip (va_list *va)
{
    (void) va_arg (*va, int);
}

link_info_got_data (NautilusDirectory *directory,
                    NautilusFile      *file,
                    gboolean           result,
                    goffset            bytes_read,
                    char              *file_contents)
{
    char *link_uri, *uri, *name;
    GIcon *icon;
    gboolean is_launcher;
    gboolean is_foreign;

    nautilus_directory_ref (directory);

    uri = NULL;
    name = NULL;
    icon = NULL;
    is_launcher = FALSE;
    is_foreign = FALSE;

    /* Handle the case where we read the Nautilus link. */
    if (result)
    {
        link_uri = nautilus_file_get_uri (file);
        nautilus_link_get_link_info_given_file_contents (file_contents, bytes_read, link_uri,
                                                         &uri, &name, &icon, &is_launcher, &is_foreign);
        g_free (link_uri);
    }
    else
    {
        /* FIXME bugzilla.gnome.org 42433: We should report this error to the user. */
    }

    nautilus_file_ref (file);
    link_info_done (directory, file, uri, name, icon, is_launcher, is_foreign);
    nautilus_file_changed (file);
    nautilus_file_unref (file);

    g_free (uri);
    g_free (name);

    if (icon != NULL)
    {
        g_object_unref (icon);
    }

    nautilus_directory_unref (directory);
}

get_target_file_for_display_name (GFile       *dir,
                                  const gchar *name)
{
    GFile *dest;

    dest = NULL;
    dest = g_file_get_child_for_display_name (dir, name, NULL);

    if (dest == NULL)
    {
        dest = g_file_get_child (dir, name);
    }

    return dest;
}

thumbnail_read_callback (GObject      *source_object,
                         GAsyncResult *res,
                         gpointer      user_data)
{
    ThumbnailState *state;
    gsize file_size;
    char *file_contents;
    gboolean result;
    NautilusDirectory *directory;
    GdkPixbuf *pixbuf;
    GFile *location;

    state = user_data;

    if (state->directory == NULL)
    {
        /* Operation was cancelled. Bail out */
        thumbnail_state_free (state);
        return;
    }

    directory = nautilus_directory_ref (state->directory);

    result = g_file_load_contents_finish (G_FILE (source_object),
                                          res,
                                          &file_contents, &file_size,
                                          NULL, NULL);

    pixbuf = NULL;
    if (result)
    {
        pixbuf = get_pixbuf_for_content (file_size, file_contents);
        g_free (file_contents);
    }

    if (pixbuf == NULL && state->trying_original)
    {
        state->trying_original = FALSE;

        location = g_file_new_for_path (state->file->details->thumbnail_path);
        g_file_load_contents_async (location,
                                    state->cancellable,
                                    thumbnail_read_callback,
                                    state);
        g_object_unref (location);
    }
    else
    {
        state->directory->details->thumbnail_state = NULL;
        async_job_end (state->directory, "thumbnail");

        thumbnail_got_pixbuf (state->directory, state->file, pixbuf, state->tried_original);

        thumbnail_state_free (state);
    }

    nautilus_directory_unref (directory);
}

application_unhandled_uri (ActivateParameters *parameters,
                           char               *uri)
{
    gboolean show_install_mime;
    char *mime_type;
    NautilusFile *file;
    ActivateParametersInstall *parameters_install;

    file = nautilus_file_get_by_uri (uri);

    mime_type = nautilus_file_get_mime_type (file);

    /* copy the parts of parameters we are interested in as the orignal will be unref'd */
    parameters_install = g_new0 (ActivateParametersInstall, 1);
    parameters_install->slot = parameters->slot;
    g_object_add_weak_pointer (G_OBJECT (parameters_install->slot), (gpointer *) &parameters_install->slot);
    if (parameters->parent_window)
    {
        parameters_install->parent_window = parameters->parent_window;
        g_object_add_weak_pointer (G_OBJECT (parameters_install->parent_window), (gpointer *) &parameters_install->parent_window);
    }
    parameters_install->activation_directory = g_strdup (parameters->activation_directory);
    parameters_install->file = file;
    parameters_install->files = get_file_list_for_launch_locations (parameters->locations);
    parameters_install->flags = parameters->flags;
    parameters_install->user_confirmation = parameters->user_confirmation;
    parameters_install->uri = g_strdup (uri);

#ifdef ENABLE_PACKAGEKIT
    /* allow an admin to disable the PackageKit search functionality */
    show_install_mime = g_settings_get_boolean (nautilus_preferences, NAUTILUS_PREFERENCES_INSTALL_MIME_ACTIVATION);
#else
    /* we have no install functionality */
    show_install_mime = FALSE;
#endif
    /* There is no use trying to look for handlers of application/octet-stream */
    if (g_content_type_is_unknown (mime_type))
    {
        show_install_mime = FALSE;
    }

    g_free (mime_type);

    if (!show_install_mime)
    {
        goto out;
    }

    g_dbus_proxy_new_for_bus (G_BUS_TYPE_SESSION,
                              G_DBUS_PROXY_FLAGS_NONE,
                              NULL,
                              "org.freedesktop.PackageKit",
                              "/org/freedesktop/PackageKit",
                              "org.freedesktop.PackageKit.Modify",
                              NULL,
                              pk_proxy_appeared_cb,
                              parameters_install);

    return;

out:
    /* show an unhelpful dialog */
    show_unhandled_type_error (parameters_install);
}

file_was_not_mounted (NautilusFile *file)
{
    GError *error;

    error = nautilus_file_get_file_info_error (file);
    return
        error != NULL &&
        error->domain == G_IO_ERROR &&
        error->code == G_IO_ERROR_NOT_MOUNTED;
}

file_list_start_or_stop (NautilusDirectory *directory)
{
    if (nautilus_directory_is_anyone_monitoring_file_list (directory))
    {
        start_monitoring_file_list (directory);
    }
    else
    {
        nautilus_directory_stop_monitoring_file_list (directory);
    }
}

untrusted_launcher_response_callback (GtkDialog                 *dialog,
int                        response_id,
ActivateParametersDesktop *parameters)
{
GdkScreen *screen;
char *uri;
GFile *file;

switch (response_id)
{
        case RESPONSE_RUN:
{
screen = gtk_widget_get_screen (GTK_WIDGET (parameters->parent_window));
uri = nautilus_file_get_uri (parameters->file);
DEBUG ("Launching untrusted launcher %s", uri);
nautilus_launch_desktop_file (screen, uri, NULL,
parameters->parent_window);
g_free (uri);
        }
        break;
        case RESPONSE_MARK_TRUSTED:
        {
            file = nautilus_file_get_location (parameters->file);
            nautilus_file_mark_desktop_file_trusted (file,
                                                     parameters->parent_window,
                                                     TRUE,
                                                     NULL, NULL);
g_object_unref (file);
}
break;

default:
{
/* Just destroy dialog */
}
break;
}

gtk_widget_destroy (GTK_WIDGET (dialog));
activate_parameters_desktop_free (parameters);
}

skip_readdir_error (CommonJob *common,
                    GFile     *dir)
{
    if (common->skip_readdir_error == NULL)
    {
        common->skip_readdir_error =
            g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);
    }

    g_hash_table_insert (common->skip_readdir_error, g_object_ref (dir), dir);
}

mime_application_hash (GAppInfo *app)
{
    const char *id;

    id = g_app_info_get_id (app);

    if (id == NULL)
    {
        return GPOINTER_TO_UINT (app);
    }

    return g_str_hash (id);
}

pause_activation_timed_cancel (ActivateParameters *parameters)
{
    if (parameters->timed_wait_active)
    {
        eel_timed_wait_stop (cancel_activate_callback, parameters);
        parameters->timed_wait_active = FALSE;
    }
}

remove_callback_link_keep_data (NautilusDirectory *directory,
                                GList             *link)
{
    ReadyCallback *callback;

    callback = link->data;

    directory->details->call_when_ready_list = g_list_remove_link
                                                   (directory->details->call_when_ready_list, link);

    request_counter_remove_request (directory->details->call_when_ready_counters,
                                    callback->request);
    g_list_free_1 (link);
}

callback_for_move_to_trash (GHashTable      *debuting_uris,
                            gboolean         user_cancelled,
                            MoveTrashCBData *data)
{
    if (data->real_callback)
    {
        data->real_callback (debuting_uris, !user_cancelled, data->real_data);
    }
    g_slice_free (MoveTrashCBData, data);
}

should_skip_file (NautilusDirectory *directory,
                  GFileInfo         *info)
{
    static gboolean show_hidden_files_changed_callback_installed = FALSE;

    /* Add the callback once for the life of our process */
    if (!show_hidden_files_changed_callback_installed)
    {
        g_signal_connect_swapped (gtk_filechooser_preferences,
                                  "changed::" NAUTILUS_PREFERENCES_SHOW_HIDDEN_FILES,
                                  G_CALLBACK (show_hidden_files_changed_callback),
                                  NULL);

        show_hidden_files_changed_callback_installed = TRUE;

        /* Peek for the first time */
        show_hidden_files_changed_callback (NULL);
    }

    if (!show_hidden_files &&
        (g_file_info_get_is_hidden (info) ||
         g_file_info_get_is_backup (info)))
    {
        return TRUE;
    }

    return FALSE;
}

activation_start_timed_cancel (ActivateParameters *parameters)
{
    parameters->timed_wait_active = TRUE;
    eel_timed_wait_start_with_duration
        (DELAY_UNTIL_CANCEL_MSECS,
        cancel_activate_callback,
        parameters,
        parameters->timed_wait_prompt,
        parameters->parent_window);
}

nautilus_file_mark_desktop_file_trusted (GFile              *file,
                                         GtkWindow          *parent_window,
                                         gboolean            interactive,
                                         NautilusOpCallback  done_callback,
                                         gpointer            done_callback_data)
{
GTask *task;
MarkTrustedJob *job;

job = op_job_new (MarkTrustedJob, parent_window);
job->file = g_object_ref (file);
job->interactive = interactive;
job->done_callback = done_callback;
job->done_callback_data = done_callback_data;

    task = g_task_new (NULL, NULL, mark_trusted_task_done, job);
g_task_set_task_data (task, job, NULL);
    g_task_run_in_thread (task, mark_trusted_task_thread_func);
g_object_unref (task);
}

deep_count_more_files_callback (GObject      *source_object,
                                GAsyncResult *res,
                                gpointer      user_data)
{
    DeepCountState *state;
    NautilusDirectory *directory;
    GList *files, *l;
    GFileInfo *info;

    state = user_data;

    if (state->directory == NULL)
    {
        /* Operation was cancelled. Bail out */
        deep_count_state_free (state);
        return;
    }

    directory = nautilus_directory_ref (state->directory);

    g_assert (directory->details->deep_count_in_progress != NULL);
    g_assert (directory->details->deep_count_in_progress == state);

    files = g_file_enumerator_next_files_finish (state->enumerator,
                                                 res, NULL);

    for (l = files; l != NULL; l = l->next)
    {
        info = l->data;
        deep_count_one (state, info);
        g_object_unref (info);
    }

    if (files == NULL)
    {
        g_file_enumerator_close_async (state->enumerator, 0, NULL, NULL, NULL);
        g_object_unref (state->enumerator);
        state->enumerator = NULL;

        deep_count_next_dir (state);
    }
    else
    {
        g_file_enumerator_next_files_async (state->enumerator,
                                            DIRECTORY_LOAD_ITEMS_PER_CALLBACK,
                                            G_PRIORITY_LOW,
                                            state->cancellable,
                                            deep_count_more_files_callback,
                                            state);
    }

    g_list_free (files);

    nautilus_directory_unref (directory);
}

application_launch_parameters_new (GAppInfo *application,
                                   GList    *uris)
{
    ApplicationLaunchParameters *result;

    result = g_new0 (ApplicationLaunchParameters, 1);
    result->application = g_object_ref (application);
    result->uris = g_list_copy_deep (uris, (GCopyFunc) g_strdup, NULL);

    return result;
}

activation_mountable_mounted (NautilusFile *file,
                              GFile        *result_location,
                              GError       *error,
                              gpointer      callback_data)
{
    ActivateParameters *parameters = callback_data;
    NautilusFile *target_file;
    LaunchLocation *location;

    /* Remove from list of files that have to be mounted */
    parameters->mountables = g_list_remove (parameters->mountables, file);
    nautilus_file_unref (file);


    if (error == NULL)
    {
        /* Replace file with the result of the mount */
        target_file = nautilus_file_get (result_location);

        location = find_launch_location_for_file (parameters->locations,
                                                  file);
        if (location)
        {
            launch_location_update_from_file (location, target_file);
        }
        nautilus_file_unref (target_file);
    }
    else
    {
        /* Remove failed file */

        if (error->domain != G_IO_ERROR ||
            (error->code != G_IO_ERROR_FAILED_HANDLED &&
             error->code != G_IO_ERROR_ALREADY_MOUNTED))
        {
            location = find_launch_location_for_file (parameters->locations,
                                                      file);
            if (location)
            {
                parameters->locations =
                    g_list_remove (parameters->locations,
                                   location);
                launch_location_free (location);
            }
        }

        if (error->domain != G_IO_ERROR ||
            (error->code != G_IO_ERROR_CANCELLED &&
             error->code != G_IO_ERROR_FAILED_HANDLED &&
             error->code != G_IO_ERROR_ALREADY_MOUNTED))
        {
            eel_show_error_dialog (_("Unable to access location"),
                                   error->message, parameters->parent_window);
        }

        if (error->code == G_IO_ERROR_CANCELLED)
        {
            activation_parameters_free (parameters);
            return;
        }
    }

    /* Mount more mountables */
    activation_mount_mountables (parameters);
}

query_fs_type (GFile        *file,
               GCancellable *cancellable)
{
    GFileInfo *fsinfo;
    char *ret;

    ret = NULL;

    fsinfo = g_file_query_filesystem_info (file,
                                           G_FILE_ATTRIBUTE_FILESYSTEM_TYPE,
                                           cancellable,
                                           NULL);
    if (fsinfo != NULL)
    {
        ret = g_strdup (g_file_info_get_attribute_string (fsinfo, G_FILE_ATTRIBUTE_FILESYSTEM_TYPE));
        g_object_unref (fsinfo);
    }

    if (ret == NULL)
    {
        /* ensure that we don't attempt to query
         * the FS type for each file in a given
         * directory, if it can't be queried. */
        ret = g_strdup ("");
    }

    return ret;
}

cancel_loading_attributes (NautilusDirectory      *directory,
                           NautilusFileAttributes  file_attributes)
{
    Request request;

    request = nautilus_directory_set_up_request (file_attributes);

    if (REQUEST_WANTS_TYPE (request, REQUEST_DIRECTORY_COUNT))
    {
        directory_count_cancel (directory);
    }
    if (REQUEST_WANTS_TYPE (request, REQUEST_DEEP_COUNT))
    {
        deep_count_cancel (directory);
    }
    if (REQUEST_WANTS_TYPE (request, REQUEST_MIME_LIST))
    {
        mime_list_cancel (directory);
    }
    if (REQUEST_WANTS_TYPE (request, REQUEST_FILE_INFO))
    {
        file_info_cancel (directory);
    }
    if (REQUEST_WANTS_TYPE (request, REQUEST_FILESYSTEM_INFO))
    {
        filesystem_info_cancel (directory);
    }
    if (REQUEST_WANTS_TYPE (request, REQUEST_LINK_INFO))
    {
        link_info_cancel (directory);
    }

    if (REQUEST_WANTS_TYPE (request, REQUEST_EXTENSION_INFO))
    {
        extension_info_cancel (directory);
    }

    if (REQUEST_WANTS_TYPE (request, REQUEST_THUMBNAIL))
    {
        thumbnail_cancel (directory);
    }

    if (REQUEST_WANTS_TYPE (request, REQUEST_MOUNT))
    {
        mount_cancel (directory);
    }

    nautilus_directory_async_state_changed (directory);
}

activation_get_activation_uris (ActivateParameters *parameters)
{
    GList *l, *files;
    NautilusFile *file;
    LaunchLocation *location;

    /* link target info might be stale, re-read it */
    for (l = parameters->locations; l != NULL; l = l->next)
    {
        location = l->data;
        file = location->file;

        if (file_was_cancelled (file))
        {
            launch_location_free (location);
            parameters->locations = g_list_delete_link (parameters->locations, l);
            continue;
        }
    }

    if (parameters->locations == NULL)
    {
        activation_parameters_free (parameters);
        return;
    }

    files = get_file_list_for_launch_locations (parameters->locations);
    nautilus_file_list_call_when_ready
        (files, nautilus_mime_actions_get_required_file_attributes (),
        &parameters->files_handle,
        activate_activation_uris_ready_callback, parameters);
    nautilus_file_list_free (files);
}

run_question (CommonJob  *job,
              char       *primary_text,
              char       *secondary_text,
              const char *details_text,
              gboolean    show_all,
              ...)
{
    va_list varargs;
    int res;

    va_start (varargs, show_all);
    res = run_simple_dialog_va (job,
                                FALSE,
                                GTK_MESSAGE_QUESTION,
                                primary_text,
                                secondary_text,
                                details_text,
                                show_all,
                                varargs);
    va_end (varargs);
    return res;
}

trash_file (CommonJob     *job,
            GFile         *file,
            gboolean      *skipped_file,
            SourceInfo    *source_info,
            TransferInfo  *transfer_info,
            gboolean       toplevel,
            GList        **to_delete)
{
    GError *error;
    char *primary, *secondary, *details;
    int response;

    if (should_skip_file (job, file))
    {
        *skipped_file = TRUE;
        return;
    }

    error = NULL;

    if (g_file_trash (file, job->cancellable, &error))
    {
        transfer_info->num_files++;
        nautilus_file_changes_queue_file_removed (file);

        if (job->undo_info != NULL)
        {
            nautilus_file_undo_info_trash_add_file (NAUTILUS_FILE_UNDO_INFO_TRASH (job->undo_info), file);
        }

        report_trash_progress (job, source_info, transfer_info);
        return;
    }

    if (job->skip_all_error)
    {
        *skipped_file = TRUE;
        goto skip;
    }

    if (job->delete_all)
    {
        *to_delete = g_list_prepend (*to_delete, file);
        goto skip;
    }

    /* Translators: %B is a file name */
    primary = f (_("“%B” can’t be put in the trash. Do you want to delete it immediately?"), file);
    details = NULL;
    secondary = NULL;
    if (!IS_IO_ERROR (error, NOT_SUPPORTED))
    {
        details = error->message;
    }
    else if (!g_file_is_native (file))
    {
        secondary = f (_("This remote location does not support sending items to the trash."));
    }

    response = run_question (job,
                             primary,
                             secondary,
                             details,
                             (source_info->num_files - transfer_info->num_files) > 1,
                             CANCEL, SKIP_ALL, SKIP, DELETE_ALL, DELETE,
                             NULL);

    if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)
    {
        ((DeleteJob *) job)->user_cancel = TRUE;
        abort_job (job);
    }
    else if (response == 1)         /* skip all */
    {
        *skipped_file = TRUE;
        job->skip_all_error = TRUE;
    }
    else if (response == 2)         /* skip */
    {
        *skipped_file = TRUE;
        job->skip_all_error = TRUE;
    }
    else if (response == 3)         /* delete all */
    {
        *to_delete = g_list_prepend (*to_delete, file);
        job->delete_all = TRUE;
    }
    else if (response == 4)         /* delete */
    {
        *to_delete = g_list_prepend (*to_delete, file);
    }

skip:
    g_error_free (error);
}

delete_task_thread_func (GTask        *task,
                         gpointer      source_object,
                         gpointer      task_data,
                         GCancellable *cancellable)
{
    DeleteJob *job = task_data;
    GList *to_trash_files;
    GList *to_delete_files;
    GList *l;
    GFile *file;
    gboolean confirmed;
    CommonJob *common;
    gboolean must_confirm_delete_in_trash;
    gboolean must_confirm_delete;
    int files_skipped;

    common = (CommonJob *) job;

    nautilus_progress_info_start (job->common.progress);

    to_trash_files = NULL;
    to_delete_files = NULL;

    must_confirm_delete_in_trash = FALSE;
    must_confirm_delete = FALSE;
    files_skipped = 0;

    for (l = job->files; l != NULL; l = l->next)
    {
        file = l->data;

        if (job->try_trash &&
            g_file_has_uri_scheme (file, "trash"))
        {
            must_confirm_delete_in_trash = TRUE;
            to_delete_files = g_list_prepend (to_delete_files, file);
        }
        else if (can_delete_without_confirm (file))
        {
            to_delete_files = g_list_prepend (to_delete_files, file);
        }
        else
        {
            if (job->try_trash)
            {
                to_trash_files = g_list_prepend (to_trash_files, file);
            }
            else
            {
                must_confirm_delete = TRUE;
                to_delete_files = g_list_prepend (to_delete_files, file);
            }
        }
    }

    if (to_delete_files != NULL)
    {
        to_delete_files = g_list_reverse (to_delete_files);
        confirmed = TRUE;
        if (must_confirm_delete_in_trash)
        {
            confirmed = confirm_delete_from_trash (common, to_delete_files);
        }
        else if (must_confirm_delete)
        {
            confirmed = confirm_delete_directly (common, to_delete_files);
        }
        if (confirmed)
        {
            delete_files (common, to_delete_files, &files_skipped);
        }
        else
        {
            job->user_cancel = TRUE;
        }
    }

    if (to_trash_files != NULL)
    {
        to_trash_files = g_list_reverse (to_trash_files);

        trash_files (common, to_trash_files, &files_skipped);
    }

    g_list_free (to_trash_files);
    g_list_free (to_delete_files);

    if (files_skipped == g_list_length (job->files))
    {
        /* User has skipped all files, report user cancel */
        job->user_cancel = TRUE;
    }
}

nautilus_file_operations_mount_volume (GtkWindow *parent_window,
                                       GVolume   *volume)
{
    nautilus_file_operations_mount_volume_full (parent_window, volume,
                                                NULL, NULL);
}

get_default_executable_text_file_action (void)
{
    int preferences_value;

    preferences_value = g_settings_get_enum (nautilus_preferences,
                                             NAUTILUS_PREFERENCES_EXECUTABLE_TEXT_ACTIVATION);
    switch (preferences_value)
    {
        case NAUTILUS_EXECUTABLE_TEXT_LAUNCH:
        {
            return ACTIVATION_ACTION_LAUNCH;
        }

        case NAUTILUS_EXECUTABLE_TEXT_DISPLAY:
        {
            return ACTIVATION_ACTION_OPEN_IN_APPLICATION;
        }

        case NAUTILUS_EXECUTABLE_TEXT_ASK:
        default:
            return ACTIVATION_ACTION_ASK;
    }
}

do_unmount (UnmountData *data)
{
    GMountOperation *mount_op;

    if (data->mount_operation)
    {
        mount_op = g_object_ref (data->mount_operation);
    }
    else
    {
        mount_op = gtk_mount_operation_new (data->parent_window);
    }
    if (data->eject)
    {
        g_mount_eject_with_operation (data->mount,
                                      0,
                                      mount_op,
                                      NULL,
                                      unmount_mount_callback,
                                      data);
    }
    else
    {
        g_mount_unmount_with_operation (data->mount,
                                        0,
                                        mount_op,
                                        NULL,
                                        unmount_mount_callback,
                                        data);
    }
    g_object_unref (mount_op);
}

run_cancel_or_skip_warning (CommonJob  *job,
                            char       *primary_text,
                            char       *secondary_text,
                            const char *details_text,
                            int         total_operations,
                            int         operations_remaining)
{
    int response;

    if (total_operations == 1)
    {
        response = run_warning (job,
                                primary_text,
                                secondary_text,
                                details_text,
                                FALSE,
                                CANCEL,
                                NULL);
    }
    else
    {
        response = run_warning (job,
                                primary_text,
                                secondary_text,
                                details_text,
                                operations_remaining > 1,
                                CANCEL, SKIP_ALL, SKIP,
                                NULL);
    }

    return response;
}

thumbnail_got_pixbuf (NautilusDirectory *directory,
                      NautilusFile      *file,
                      GdkPixbuf         *pixbuf,
                      gboolean           tried_original)
{
    nautilus_directory_ref (directory);

    nautilus_file_ref (file);
    thumbnail_done (directory, file, pixbuf, tried_original);
    nautilus_file_changed (file);
    nautilus_file_unref (file);

    if (pixbuf)
    {
        g_object_unref (pixbuf);
    }

    nautilus_directory_unref (directory);
}

nautilus_mime_activate_files (GtkWindow               *parent_window,
                              NautilusWindowSlot      *slot,
                              GList                   *files,
                              const char              *launch_directory,
                              NautilusWindowOpenFlags  flags,
                              gboolean                 user_confirmation)
{
    ActivateParameters *parameters;
    char *file_name;
    int file_count;
    GList *l, *next;
    NautilusFile *file;
    LaunchLocation *location;

    if (files == NULL)
    {
        return;
    }

    DEBUG_FILES (files, "Calling activate_files() with files:");

    parameters = g_new0 (ActivateParameters, 1);
    parameters->slot = slot;
    g_object_add_weak_pointer (G_OBJECT (parameters->slot), (gpointer *) &parameters->slot);
    if (parent_window)
    {
        parameters->parent_window = parent_window;
        g_object_add_weak_pointer (G_OBJECT (parameters->parent_window), (gpointer *) &parameters->parent_window);
    }
    parameters->cancellable = g_cancellable_new ();
    parameters->activation_directory = g_strdup (launch_directory);
    parameters->locations = launch_locations_from_file_list (files);
    parameters->flags = flags;
    parameters->user_confirmation = user_confirmation;

    file_count = g_list_length (files);
    if (file_count == 1)
    {
        file_name = nautilus_file_get_display_name (files->data);
        parameters->timed_wait_prompt = g_strdup_printf (_("Opening “%s”."), file_name);
        g_free (file_name);
    }
    else
    {
        parameters->timed_wait_prompt = g_strdup_printf (ngettext ("Opening %d item.",
                                                                   "Opening %d items.",
                                                                   file_count),
                                                         file_count);
    }


    for (l = parameters->locations; l != NULL; l = next)
    {
        location = l->data;
        file = location->file;
        next = l->next;

        if (nautilus_file_can_mount (file))
        {
            parameters->mountables = g_list_prepend (parameters->mountables,
                                                     nautilus_file_ref (file));
        }

        if (nautilus_file_can_start (file))
        {
            parameters->start_mountables = g_list_prepend (parameters->start_mountables,
                                                           nautilus_file_ref (file));
        }
    }

    activation_start_timed_cancel (parameters);
    if (parameters->mountables != NULL)
    {
        activation_mount_mountables (parameters);
    }
    if (parameters->start_mountables != NULL)
    {
        activation_start_mountables (parameters);
    }
    if (parameters->mountables == NULL && parameters->start_mountables == NULL)
    {
        activation_get_activation_uris (parameters);
    }
}

launch_location_update_from_uri (LaunchLocation *location,
                                 const char     *uri)
{
    nautilus_file_unref (location->file);
    g_free (location->uri);
    location->file = nautilus_file_get_by_uri (uri);
    location->uri = g_strdup (uri);
}

link_info_read_state_free (LinkInfoReadState *state)
{
    g_object_unref (state->cancellable);
    g_free (state);
}

application_unhandled_file_install (GtkDialog                 *dialog,
                                    gint                       response_id,
                                    ActivateParametersInstall *parameters_install)
{
    char *mime_type;

    gtk_widget_destroy (GTK_WIDGET (dialog));
    parameters_install->dialog = NULL;

    if (response_id == GTK_RESPONSE_YES)
    {
        mime_type = nautilus_file_get_mime_type (parameters_install->file);
        search_for_application_mime_type (parameters_install, mime_type);
        g_free (mime_type);
    }
    else
    {
        /* free as we're not going to get the async dbus callback */
        activate_parameters_install_free (parameters_install);
    }
}

nautilus_file_invalidate_count_and_mime_list (NautilusFile *file)
{
    NautilusFileAttributes attributes;

    attributes = NAUTILUS_FILE_ATTRIBUTE_DIRECTORY_ITEM_COUNT |
                 NAUTILUS_FILE_ATTRIBUTE_DIRECTORY_ITEM_MIME_TYPES;

    nautilus_file_invalidate_attributes (file, attributes);
}

get_executable_text_file_action (GtkWindow    *parent_window,
                                 NautilusFile *file)
{
    GtkDialog *dialog;
    char *file_name;
    char *prompt;
    char *detail;
    int preferences_value;
    int response;

    g_assert (nautilus_file_contains_text (file));

    preferences_value = g_settings_get_enum (nautilus_preferences,
                                             NAUTILUS_PREFERENCES_EXECUTABLE_TEXT_ACTIVATION);
    switch (preferences_value)
    {
        case NAUTILUS_EXECUTABLE_TEXT_LAUNCH:
        {
            return ACTIVATION_ACTION_LAUNCH;
        }

        case NAUTILUS_EXECUTABLE_TEXT_DISPLAY:
        {
            return ACTIVATION_ACTION_OPEN_IN_APPLICATION;
        }

        case NAUTILUS_EXECUTABLE_TEXT_ASK:
        {
        }
        break;

        default:
            /* Complain non-fatally, since preference data can't be trusted */
            g_warning ("Unknown value %d for NAUTILUS_PREFERENCES_EXECUTABLE_TEXT_ACTIVATION",
                       preferences_value);
    }


    file_name = nautilus_file_get_display_name (file);
    prompt = g_strdup_printf (_("Do you want to run “%s”, or display its contents?"),
                              file_name);
    detail = g_strdup_printf (_("“%s” is an executable text file."),
                              file_name);
    g_free (file_name);

    dialog = eel_create_question_dialog (prompt,
                                         detail,
                                         _("Run in _Terminal"), RESPONSE_RUN_IN_TERMINAL,
                                         _("_Display"), RESPONSE_DISPLAY,
                                         parent_window);
    gtk_dialog_add_button (dialog, _("_Cancel"), GTK_RESPONSE_CANCEL);
    gtk_dialog_add_button (dialog, _("_Run"), RESPONSE_RUN);
    gtk_dialog_set_default_response (dialog, GTK_RESPONSE_CANCEL);
    gtk_widget_show (GTK_WIDGET (dialog));

    g_free (prompt);
    g_free (detail);

    response = gtk_dialog_run (dialog);
    gtk_widget_destroy (GTK_WIDGET (dialog));

    switch (response)
    {
        case RESPONSE_RUN:
        {
            return ACTIVATION_ACTION_LAUNCH;
        }

        case RESPONSE_RUN_IN_TERMINAL:
        {
            return ACTIVATION_ACTION_LAUNCH_IN_TERMINAL;
        }

        case RESPONSE_DISPLAY:
        {
            return ACTIVATION_ACTION_OPEN_IN_APPLICATION;
        }

        default:
            return ACTIVATION_ACTION_DO_NOTHING;
    }
}

mark_trusted_task_thread_func (GTask        *task,
                               gpointer      source_object,
                               gpointer      task_data,
                               GCancellable *cancellable)
{
MarkTrustedJob *job = task_data;
CommonJob *common;

common = (CommonJob *) job;

nautilus_progress_info_start (job->common.progress);

    mark_desktop_file_trusted (common,
                               cancellable,
                               job->file,
                               job->interactive);
}

report_broken_symbolic_link (GtkWindow    *parent_window,
                             NautilusFile *file)
{
    char *target_path;
    char *display_name;
    char *prompt;
    char *detail;
    GtkDialog *dialog;
    GList file_as_list;
    int response;
    gboolean can_trash;

    g_assert (nautilus_file_is_broken_symbolic_link (file));

    display_name = nautilus_file_get_display_name (file);
    can_trash = nautilus_file_can_trash (file) && !nautilus_file_is_in_trash (file);

    if (can_trash)
    {
        prompt = g_strdup_printf (_("The link “%s” is broken. Move it to Trash?"), display_name);
    }
    else
    {
        prompt = g_strdup_printf (_("The link “%s” is broken."), display_name);
    }
    g_free (display_name);

    target_path = nautilus_file_get_symbolic_link_target_path (file);
    if (target_path == NULL)
    {
        detail = g_strdup (_("This link cannot be used because it has no target."));
    }
    else
    {
        detail = g_strdup_printf (_("This link cannot be used because its target "
                                    "“%s” doesn’t exist."), target_path);
    }

    if (!can_trash)
    {
        eel_run_simple_dialog (GTK_WIDGET (parent_window), FALSE, GTK_MESSAGE_WARNING,
                               prompt, detail, _("_Cancel"), NULL);
        goto out;
    }

    dialog = eel_show_yes_no_dialog (prompt, detail, _("Mo_ve to Trash"), _("_Cancel"),
                                     parent_window);

    gtk_dialog_set_default_response (dialog, GTK_RESPONSE_CANCEL);

    /* Make this modal to avoid problems with reffing the view & file
     * to keep them around in case the view changes, which would then
     * cause the old view not to be destroyed, which would cause its
     * merged Bonobo items not to be un-merged. Maybe we need to unmerge
     * explicitly when disconnecting views instead of relying on the
     * unmerge in Destroy. But since BonoboUIHandler is probably going
     * to change wildly, I don't want to mess with this now.
     */

    response = gtk_dialog_run (dialog);
    gtk_widget_destroy (GTK_WIDGET (dialog));

    if (response == GTK_RESPONSE_YES)
    {
        file_as_list.data = file;
        file_as_list.next = NULL;
        file_as_list.prev = NULL;
        trash_or_delete_files (parent_window, &file_as_list, TRUE);
    }

out:
    g_free (prompt);
    g_free (target_path);
    g_free (detail);
}

new_files_callback (GObject      *source_object,
                    GAsyncResult *res,
                    gpointer      user_data)
{
    NautilusDirectory *directory;
    GFileInfo *info;
    NewFilesState *state;

    state = user_data;

    if (state->directory == NULL)
    {
        /* Operation was cancelled. Bail out */
        new_files_state_unref (state);
        return;
    }

    directory = nautilus_directory_ref (state->directory);

    /* Queue up the new file. */
    info = g_file_query_info_finish (G_FILE (source_object), res, NULL);
    if (info != NULL)
    {
        directory_load_one (directory, info);
        g_object_unref (info);
    }

    new_files_state_unref (state);

    nautilus_directory_unref (directory);
}

async_job_wake_up (void)
{
    static gboolean already_waking_up = FALSE;
    gpointer value;

    g_assert (async_job_count >= 0);
    g_assert (async_job_count <= MAX_ASYNC_JOBS);

    if (already_waking_up)
    {
        return;
    }

    already_waking_up = TRUE;
    while (async_job_count < MAX_ASYNC_JOBS)
    {
        value = get_one_value (waiting_directories);
        if (value == NULL)
        {
            break;
        }
        g_hash_table_remove (waiting_directories, value);
        nautilus_directory_async_state_changed
            (NAUTILUS_DIRECTORY (value));
    }
    already_waking_up = FALSE;
}

ready_callback_key_compare_only_active (gconstpointer a,
                                        gconstpointer b)
{
    const ReadyCallback *callback_a;

    callback_a = a;

    /* Non active callbacks never match */
    if (!callback_a->active)
    {
        return -1;
    }

    return ready_callback_key_compare (a, b);
}

nautilus_mime_types_group_get_mimetypes (gint group_index)
{
    GList *mimetypes;
    gint i;

    g_return_val_if_fail (group_index < G_N_ELEMENTS (mimetype_groups), NULL);

    mimetypes = NULL;

    /* Setup the new mimetypes set */
    for (i = 0; mimetype_groups[group_index].mimetypes[i]; i++)
    {
        mimetypes = g_list_append (mimetypes, mimetype_groups[group_index].mimetypes[i]);
    }

    return mimetypes;
}

seen_inode (DeepCountState *state,
            GFileInfo      *info)
{
    guint64 inode, inode2;
    guint i;

    inode = g_file_info_get_attribute_uint64 (info, G_FILE_ATTRIBUTE_UNIX_INODE);

    if (inode != 0)
    {
        for (i = 0; i < state->seen_deep_count_inodes->len; i++)
        {
            inode2 = g_array_index (state->seen_deep_count_inodes, guint64, i);
            if (inode == inode2)
            {
                return TRUE;
            }
        }
    }

    return FALSE;
}

mime_list_callback (GObject      *source_object,
                    GAsyncResult *res,
                    gpointer      user_data)
{
    MimeListState *state;
    NautilusDirectory *directory;
    GError *error;
    GList *files, *l;
    GFileInfo *info;

    state = user_data;
    directory = state->directory;

    if (g_cancellable_is_cancelled (state->cancellable))
    {
        /* Operation was cancelled. Bail out */
        directory->details->mime_list_in_progress = NULL;

        async_job_end (directory, "MIME list");
        nautilus_directory_async_state_changed (directory);

        mime_list_state_free (state);

        return;
    }

    g_assert (directory->details->mime_list_in_progress != NULL);
    g_assert (directory->details->mime_list_in_progress == state);

    error = NULL;
    files = g_file_enumerator_next_files_finish (state->enumerator,
                                                 res, &error);

    for (l = files; l != NULL; l = l->next)
    {
        info = l->data;
        mime_list_one (state, info);
        g_object_unref (info);
    }

    if (files == NULL)
    {
        mime_list_done (state, error != NULL);
        mime_list_state_free (state);
    }
    else
    {
        g_file_enumerator_next_files_async (state->enumerator,
                                            DIRECTORY_LOAD_ITEMS_PER_CALLBACK,
                                            G_PRIORITY_DEFAULT,
                                            state->cancellable,
                                            mime_list_callback,
                                            state);
    }

    g_list_free (files);

    if (error)
    {
        g_error_free (error);
    }
}

nautilus_directory_schedule_dequeue_pending (NautilusDirectory *directory)
{
    if (directory->details->dequeue_pending_idle_id == 0)
    {
        directory->details->dequeue_pending_idle_id
            = g_idle_add (dequeue_pending_idle_callback, directory);
    }
}

do_run_simple_dialog (gpointer _data)
{
    RunSimpleDialogData *data = _data;
    const char *button_title;
    GtkWidget *dialog;
    int result;
    int response_id;

    g_mutex_lock (&data->mutex);

    /* Create the dialog. */
    dialog = gtk_message_dialog_new (*data->parent_window,
                                     0,
                                     data->message_type,
                                     GTK_BUTTONS_NONE,
                                     NULL);

    g_object_set (dialog,
                  "text", data->primary_text,
                  "secondary-text", data->secondary_text,
                  NULL);

    for (response_id = 0;
         data->button_titles[response_id] != NULL;
         response_id++)
    {
        button_title = data->button_titles[response_id];
        if (!data->show_all && is_all_button_text (button_title))
        {
            continue;
        }

        gtk_dialog_add_button (GTK_DIALOG (dialog), button_title, response_id);
        gtk_dialog_set_default_response (GTK_DIALOG (dialog), response_id);
    }

    if (data->details_text)
    {
        eel_gtk_message_dialog_set_details_label (GTK_MESSAGE_DIALOG (dialog),
                                                  data->details_text);
    }

    /* Run it. */
    result = gtk_dialog_run (GTK_DIALOG (dialog));

    while ((result == GTK_RESPONSE_NONE || result == GTK_RESPONSE_DELETE_EVENT) && data->ignore_close_box)
    {
        result = gtk_dialog_run (GTK_DIALOG (dialog));
    }

    gtk_widget_destroy (dialog);

    data->result = result;
    data->completed = TRUE;

    g_cond_signal (&data->cond);
    g_mutex_unlock (&data->mutex);

    return FALSE;
}

lacks_filesystem_info (NautilusFile *file)
{
    return !file->details->filesystem_info_is_up_to_date;
}

custom_mount_skip (va_list *va)
{
    (void) va_arg (*va, GMount *);
}

monitor_includes_file (const Monitor *monitor,
                       NautilusFile  *file)
{
    if (monitor->file == file)
    {
        return TRUE;
    }
    if (monitor->file != NULL)
    {
        return FALSE;
    }
    if (file == file->details->directory->details->as_file)
    {
        return FALSE;
    }
    return nautilus_file_should_show (file,
                                      monitor->monitor_hidden_files,
                                      TRUE);
}

directory_count_state_free (DirectoryCountState *state)
{
    if (state->enumerator)
    {
        if (!g_file_enumerator_is_closed (state->enumerator))
        {
            g_file_enumerator_close_async (state->enumerator,
                                           0, NULL, NULL, NULL);
        }
        g_object_unref (state->enumerator);
    }
    g_object_unref (state->cancellable);
    nautilus_directory_unref (state->directory);
    g_free (state);
}

custom_basename_to_string (char    *format,
                           va_list  va)
{
    GFile *file;
    GFileInfo *info;
    char *name, *basename, *tmp;
    GMount *mount;

    file = va_arg (va, GFile *);

    if ((mount = nautilus_get_mounted_mount_for_root (file)) != NULL)
    {
        name = g_mount_get_name (mount);
        g_object_unref (mount);
    }
    else
    {
        info = g_file_query_info (file,
                                  G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME,
                                  0,
                                  g_cancellable_get_current (),
                                  NULL);
        name = NULL;
        if (info)
        {
            name = g_strdup (g_file_info_get_display_name (info));
            g_object_unref (info);
        }
    }

    if (name == NULL)
    {
        basename = g_file_get_basename (file);
        if (g_utf8_validate (basename, -1, NULL))
        {
            name = basename;
        }
        else
        {
            name = g_uri_escape_string (basename, G_URI_RESERVED_CHARS_ALLOWED_IN_PATH, TRUE);
            g_free (basename);
        }
    }

    /* Some chars can't be put in the markup we use for the dialogs... */
    if (has_invalid_xml_char (name))
    {
        tmp = name;
        name = g_uri_escape_string (name, G_URI_RESERVED_CHARS_ALLOWED_IN_PATH, TRUE);
        g_free (tmp);
    }

    /* Finally, if the string is too long, truncate it. */
    if (name != NULL)
    {
        tmp = name;
        name = eel_str_middle_truncate (tmp, MAXIMUM_DISPLAYED_FILE_NAME_LENGTH);
        g_free (tmp);
    }


    return name;
}

nautilus_directory_invalidate_count_and_mime_list (NautilusDirectory *directory)
{
    NautilusFile *file;

    file = nautilus_directory_get_existing_corresponding_file (directory);
    if (file != NULL)
    {
        nautilus_file_invalidate_count_and_mime_list (file);
    }

    nautilus_file_unref (file);
}

should_skip_readdir_error (CommonJob *common,
                           GFile     *dir)
{
    if (common->skip_readdir_error != NULL)
    {
        return g_hash_table_lookup (common->skip_readdir_error, dir) != NULL;
    }
    return FALSE;
}

remove_monitor_link (NautilusDirectory *directory,
                     GList             *link)
{
    Monitor *monitor;

    if (link != NULL)
    {
        monitor = link->data;
        request_counter_remove_request (directory->details->monitor_counters,
                                        monitor->request);
        directory->details->monitor_list =
            g_list_remove_link (directory->details->monitor_list, link);
        g_free (monitor);
        g_list_free_1 (link);
    }
}

report_preparing_move_progress (CopyMoveJob *move_job,
                                int          total,
                                int          left)
{
    CommonJob *job;

    job = (CommonJob *) move_job;

    nautilus_progress_info_take_status (job->progress,
                                        f (_("Preparing to move to “%B”"),
                                           move_job->destination));

    nautilus_progress_info_take_details (job->progress,
                                         f (ngettext ("Preparing to move %'d file",
                                                      "Preparing to move %'d files",
                                                      left), left));

    nautilus_progress_info_pulse_progress (job->progress);
}

is_needy (NautilusFile *file,
          FileCheck     check_missing,
          RequestType   request_type_wanted)
{
    NautilusDirectory *directory;
    GList *node;
    ReadyCallback *callback;
    Monitor *monitor;

    if (!(*check_missing)(file))
    {
        return FALSE;
    }

    directory = file->details->directory;
    if (directory->details->call_when_ready_counters[request_type_wanted] > 0)
    {
        for (node = directory->details->call_when_ready_list;
             node != NULL; node = node->next)
        {
            callback = node->data;
            if (callback->active &&
                REQUEST_WANTS_TYPE (callback->request, request_type_wanted))
            {
                if (callback->file == file)
                {
                    return TRUE;
                }
                if (callback->file == NULL
                    && file != directory->details->as_file)
                {
                    return TRUE;
                }
            }
        }
    }

    if (directory->details->monitor_counters[request_type_wanted] > 0)
    {
        for (node = directory->details->monitor_list;
             node != NULL; node = node->next)
        {
            monitor = node->data;
            if (REQUEST_WANTS_TYPE (monitor->request, request_type_wanted))
            {
                if (monitor_includes_file (monitor, file))
                {
                    return TRUE;
                }
            }
        }
    }
    return FALSE;
}

list_to_parameters_foreach (GAppInfo  *application,
                            GList     *uris,
                            GList    **ret)
{
    ApplicationLaunchParameters *parameters;

    uris = g_list_reverse (uris);

    parameters = application_launch_parameters_new
                     (application, uris);
    *ret = g_list_prepend (*ret, parameters);
}

compress_task_thread_func (GTask        *task,
                           gpointer      source_object,
                           gpointer      task_data,
                           GCancellable *cancellable)
{
    CompressJob *compress_job = task_data;
    SourceInfo source_info;
    g_autoptr (AutoarCompressor) compressor = NULL;

    g_timer_start (compress_job->common.time);

    nautilus_progress_info_start (compress_job->common.progress);

    scan_sources (compress_job->source_files,
                  &source_info,
                  (CommonJob *) compress_job,
                  OP_KIND_COMPRESS);

    compress_job->total_files = source_info.num_files;
    compress_job->total_size = source_info.num_bytes;

    compressor = autoar_compressor_new (compress_job->source_files,
                                        compress_job->output_file,
                                        compress_job->format,
                                        compress_job->filter,
                                        FALSE);

    autoar_compressor_set_output_is_dest (compressor, TRUE);

    autoar_compressor_set_notify_interval (compressor,
                                           PROGRESS_NOTIFY_INTERVAL);

    g_signal_connect (compressor, "progress",
                      G_CALLBACK (compress_job_on_progress), compress_job);
    g_signal_connect (compressor, "error",
                      G_CALLBACK (compress_job_on_error), compress_job);
    g_signal_connect (compressor, "completed",
                      G_CALLBACK (compress_job_on_completed), compress_job);
    autoar_compressor_start (compressor,
                             compress_job->common.cancellable);

    compress_job->success = g_file_query_exists (compress_job->output_file,
                                                 NULL);

    /* There is nothing to undo if the output was not created */
    if (compress_job->common.undo_info != NULL && !compress_job->success)
    {
        g_clear_object (&compress_job->common.undo_info);
    }
}

add_all_files_to_work_queue (NautilusDirectory *directory)
{
    GList *node;
    NautilusFile *file;

    for (node = directory->details->file_list; node != NULL; node = node->next)
    {
        file = NAUTILUS_FILE (node->data);

        nautilus_directory_add_file_to_work_queue (directory, file);
    }
}

cancel_deep_counts_for_file (NautilusDirectory *directory,
                             NautilusFile      *file)
{
    if (directory->details->deep_count_file == file)
    {
        deep_count_cancel (directory);
    }
}

get_abs_path_for_symlink (GFile *file,
                          GFile *destination)
{
    GFile *root, *parent;
    char *relative, *abs;

    if (g_file_is_native (file) || g_file_is_native (destination))
    {
        return g_file_get_path (file);
    }

    root = g_object_ref (file);
    while ((parent = g_file_get_parent (root)) != NULL)
    {
        g_object_unref (root);
        root = parent;
    }

    relative = g_file_get_relative_path (root, file);
    g_object_unref (root);
    abs = g_strconcat ("/", relative, NULL);
    g_free (relative);
    return abs;
}

thumbnail_done (NautilusDirectory *directory,
                NautilusFile      *file,
                GdkPixbuf         *pixbuf,
                gboolean           tried_original)
{
    const char *thumb_mtime_str;
    time_t thumb_mtime = 0;

    file->details->thumbnail_is_up_to_date = TRUE;
    file->details->thumbnail_tried_original = tried_original;
    if (file->details->thumbnail)
    {
        g_object_unref (file->details->thumbnail);
        file->details->thumbnail = NULL;
    }
    if (file->details->scaled_thumbnail)
    {
        g_object_unref (file->details->scaled_thumbnail);
        file->details->scaled_thumbnail = NULL;
    }

    if (pixbuf)
    {
        if (tried_original)
        {
            thumb_mtime = file->details->mtime;
        }
        else
        {
            thumb_mtime_str = gdk_pixbuf_get_option (pixbuf, "tEXt::Thumb::MTime");
            if (thumb_mtime_str)
            {
                thumb_mtime = atol (thumb_mtime_str);
            }
        }

        if (thumb_mtime == 0 ||
            thumb_mtime == file->details->mtime)
        {
            file->details->thumbnail = g_object_ref (pixbuf);
            file->details->thumbnail_mtime = thumb_mtime;
        }
        else
        {
            g_free (file->details->thumbnail_path);
            file->details->thumbnail_path = NULL;
        }
    }

    nautilus_directory_async_state_changed (directory);
}

move_file_to_extension_queue (NautilusDirectory *directory,
                              NautilusFile      *file)
{
    /* Must add before removing to avoid ref underflow */
    nautilus_file_queue_enqueue (directory->details->extension_queue,
                                 file);
    nautilus_file_queue_remove (directory->details->low_priority_queue,
                                file);
}

istr_set_get_as_list (GHashTable *table)
{
    GList *list;

    list = NULL;
    g_hash_table_foreach (table, add_istr_to_list, &list);
    return list;
}

volume_mount_cb (GObject      *source_object,
                 GAsyncResult *res,
                 gpointer      user_data)
{
    NautilusMountCallback mount_callback;
    GObject *mount_callback_data_object;
    GMountOperation *mount_op = user_data;
    GError *error;
    char *primary;
    char *name;
    gboolean success;

    success = TRUE;
    error = NULL;
    if (!g_volume_mount_finish (G_VOLUME (source_object), res, &error))
    {
        if (error->code != G_IO_ERROR_FAILED_HANDLED &&
            error->code != G_IO_ERROR_ALREADY_MOUNTED)
        {
            GtkWindow *parent;

            parent = gtk_mount_operation_get_parent (GTK_MOUNT_OPERATION (mount_op));
            name = g_volume_get_name (G_VOLUME (source_object));
            primary = g_strdup_printf (_("Unable to access “%s”"), name);
            g_free (name);
            success = FALSE;
            eel_show_error_dialog (primary,
                                   error->message,
                                   parent);
            g_free (primary);
        }
        g_error_free (error);
    }

    mount_callback = (NautilusMountCallback)
                     g_object_get_data (G_OBJECT (mount_op), "mount-callback");
    mount_callback_data_object =
        g_object_get_data (G_OBJECT (mount_op), "mount-callback-data");

    if (mount_callback != NULL)
    {
        (*mount_callback)(G_VOLUME (source_object),
                          success,
                          mount_callback_data_object);

        if (mount_callback_data_object != NULL)
        {
            g_object_weak_unref (mount_callback_data_object,
                                 mount_callback_data_notify,
                                 mount_op);
        }
    }

    g_object_unref (mount_op);
}

map_possibly_volatile_file_to_real_on_write (GFile              *volatile_file,
                                             GFileOutputStream  *stream,
                                             GCancellable       *cancellable,
                                             GError            **error)
{
    GFile *real_file = NULL;
    GFileInfo *info = NULL;

    info = g_file_output_stream_query_info (stream,
                                            G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK ","
                                            G_FILE_ATTRIBUTE_STANDARD_IS_VOLATILE ","
                                            G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET,
                                            cancellable,
                                            error);
    if (info == NULL)
    {
        return NULL;
    }
    else
    {
        gboolean is_volatile;

        is_volatile = g_file_info_get_attribute_boolean (info,
                                                         G_FILE_ATTRIBUTE_STANDARD_IS_VOLATILE);
        if (is_volatile)
        {
            const gchar *target;

            target = g_file_info_get_symlink_target (info);
            real_file = g_file_resolve_relative_path (volatile_file, target);
        }
    }

    g_object_unref (info);

    if (real_file == NULL)
    {
        real_file = g_object_ref (volatile_file);
    }

    return real_file;
}

lacks_info (NautilusFile *file)
{
    return !file->details->file_info_is_up_to_date
           && !file->details->is_gone;
}

nautilus_file_operations_new_file (GtkWidget              *parent_view,
                                   GdkPoint               *target_point,
                                   const char             *parent_dir,
                                   const char             *target_filename,
                                   const char             *initial_contents,
                                   int                     length,
                                   NautilusCreateCallback  done_callback,
                                   gpointer                done_callback_data)
{
    GTask *task;
    CreateJob *job;
    GtkWindow *parent_window;

    parent_window = NULL;
    if (parent_view)
    {
        parent_window = (GtkWindow *) gtk_widget_get_ancestor (parent_view, GTK_TYPE_WINDOW);
    }

    job = op_job_new (CreateJob, parent_window);
    job->done_callback = done_callback;
    job->done_callback_data = done_callback_data;
    job->dest_dir = g_file_new_for_uri (parent_dir);
    if (target_point != NULL)
    {
        job->position = *target_point;
        job->has_position = TRUE;
    }
    job->src_data = g_memdup (initial_contents, length);
    job->length = length;
    job->filename = g_strdup (target_filename);

    if (!nautilus_file_undo_manager_is_operating ())
    {
        job->common.undo_info = nautilus_file_undo_info_create_new (NAUTILUS_FILE_UNDO_OP_CREATE_EMPTY_FILE);
    }

    task = g_task_new (NULL, job->common.cancellable, create_task_done, job);
    g_task_set_task_data (task, job, NULL);
    g_task_run_in_thread (task, create_task_thread_func);
    g_object_unref (task);
}

activation_mountable_started (NautilusFile *file,
                              GFile        *gfile_of_file,
                              GError       *error,
                              gpointer      callback_data)
{
    ActivateParameters *parameters = callback_data;
    LaunchLocation *location;

    /* Remove from list of files that have to be mounted */
    parameters->start_mountables = g_list_remove (parameters->start_mountables, file);
    nautilus_file_unref (file);

    if (error == NULL)
    {
        /* Remove file */
        location = find_launch_location_for_file (parameters->locations, file);
        if (location != NULL)
        {
            parameters->locations = g_list_remove (parameters->locations, location);
            launch_location_free (location);
        }
    }
    else
    {
        /* Remove failed file */
        if (error->domain != G_IO_ERROR ||
            (error->code != G_IO_ERROR_FAILED_HANDLED))
        {
            location = find_launch_location_for_file (parameters->locations,
                                                      file);
            if (location)
            {
                parameters->locations =
                    g_list_remove (parameters->locations,
                                   location);
                launch_location_free (location);
            }
        }

        if (error->domain != G_IO_ERROR ||
            (error->code != G_IO_ERROR_CANCELLED &&
             error->code != G_IO_ERROR_FAILED_HANDLED))
        {
            eel_show_error_dialog (_("Unable to start location"),
                                   error->message, NULL);
        }

        if (error->code == G_IO_ERROR_CANCELLED)
        {
            activation_parameters_free (parameters);
            return;
        }
    }

    /* Start more mountables */
    activation_start_mountables (parameters);
}

finish_info_provider (NautilusDirectory    *directory,
                      NautilusFile         *file,
                      NautilusInfoProvider *provider)
{
    file->details->pending_info_providers =
        g_list_remove (file->details->pending_info_providers,
                       provider);
    g_object_unref (provider);

    nautilus_directory_async_state_changed (directory);

    if (file->details->pending_info_providers == NULL)
    {
        nautilus_file_info_providers_done (file);
    }
}

mime_list_cancel (NautilusDirectory *directory)
{
    if (directory->details->mime_list_in_progress != NULL)
    {
        g_cancellable_cancel (directory->details->mime_list_in_progress->cancellable);
    }
}

filesystem_info_start (NautilusDirectory *directory,
                       NautilusFile      *file,
                       gboolean          *doing_io)
{
    GFile *location;
    FilesystemInfoState *state;

    if (directory->details->filesystem_info_state != NULL)
    {
        *doing_io = TRUE;
        return;
    }

    if (!is_needy (file,
                   lacks_filesystem_info,
                   REQUEST_FILESYSTEM_INFO))
    {
        return;
    }
    *doing_io = TRUE;

    if (!async_job_start (directory, "filesystem info"))
    {
        return;
    }

    state = g_new0 (FilesystemInfoState, 1);
    state->directory = directory;
    state->file = file;
    state->cancellable = g_cancellable_new ();

    location = nautilus_file_get_location (file);

    directory->details->filesystem_info_state = state;

    g_file_query_filesystem_info_async (location,
                                        G_FILE_ATTRIBUTE_FILESYSTEM_READONLY ","
                                        G_FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW ","
                                        G_FILE_ATTRIBUTE_FILESYSTEM_TYPE,
                                        G_PRIORITY_DEFAULT,
                                        state->cancellable,
                                        query_filesystem_info_callback,
                                        state);
    g_object_unref (location);
}

nautilus_directory_add_file_monitors (NautilusDirectory *directory,
                                      NautilusFile      *file,
                                      FileMonitors      *monitors)
{
    GList **list;
    GList *l;
    Monitor *monitor;

    g_assert (NAUTILUS_IS_DIRECTORY (directory));
    g_assert (NAUTILUS_IS_FILE (file));
    g_assert (file->details->directory == directory);

    if (monitors == NULL)
    {
        return;
    }

    for (l = (GList *) monitors; l != NULL; l = l->next)
    {
        monitor = l->data;
        request_counter_add_request (directory->details->monitor_counters,
                                     monitor->request);
    }

    list = &directory->details->monitor_list;
    *list = g_list_concat (*list, (GList *) monitors);

    nautilus_directory_add_file_to_work_queue (directory, file);

    nautilus_directory_async_state_changed (directory);
}

move_task_done (GObject      *source_object,
                GAsyncResult *res,
                gpointer      user_data)
{
    CopyMoveJob *job;

    job = user_data;
    if (job->done_callback)
    {
        job->done_callback (job->debuting_files,
                            !job_aborted ((CommonJob *) job),
                            job->done_callback_data);
    }

    g_list_free_full (job->files, g_object_unref);
    g_object_unref (job->destination);
    g_hash_table_unref (job->debuting_files);
    g_free (job->icon_positions);

    finalize_common ((CommonJob *) job);

    nautilus_file_changes_consume_changes (TRUE);
}

run_simple_dialog_va (CommonJob      *job,
                      gboolean        ignore_close_box,
                      GtkMessageType  message_type,
                      char           *primary_text,
                      char           *secondary_text,
                      const char     *details_text,
                      gboolean        show_all,
                      va_list         varargs)
{
    RunSimpleDialogData *data;
    int res;
    const char *button_title;
    GPtrArray *ptr_array;

    g_timer_stop (job->time);

    data = g_new0 (RunSimpleDialogData, 1);
    data->parent_window = &job->parent_window;
    data->ignore_close_box = ignore_close_box;
    data->message_type = message_type;
    data->primary_text = primary_text;
    data->secondary_text = secondary_text;
    data->details_text = details_text;
    data->show_all = show_all;
    data->completed = FALSE;
    g_mutex_init (&data->mutex);
    g_cond_init (&data->cond);

    ptr_array = g_ptr_array_new ();
    while ((button_title = va_arg (varargs, const char *)) != NULL)
    {
        g_ptr_array_add (ptr_array, (char *) button_title);
    }
    g_ptr_array_add (ptr_array, NULL);
    data->button_titles = (const char **) g_ptr_array_free (ptr_array, FALSE);

    nautilus_progress_info_pause (job->progress);

    g_mutex_lock (&data->mutex);

    g_main_context_invoke (NULL,
                           do_run_simple_dialog,
                           data);

    while (!data->completed)
    {
        g_cond_wait (&data->cond, &data->mutex);
    }

    nautilus_progress_info_resume (job->progress);
    res = data->result;

    g_mutex_unlock (&data->mutex);
    g_mutex_clear (&data->mutex);
    g_cond_clear (&data->cond);

    g_free (data->button_titles);
    g_free (data);

    g_timer_continue (job->time);

    g_free (primary_text);
    g_free (secondary_text);

    return res;
}

nautilus_directory_force_reload_internal (NautilusDirectory      *directory,
                                          NautilusFileAttributes  file_attributes)
{
    nautilus_profile_start (NULL);

    /* invalidate attributes that are getting reloaded for all files */
    nautilus_directory_invalidate_file_attributes (directory, file_attributes);

    /* Start a new directory load. */
    file_list_cancel (directory);
    directory->details->directory_loaded = FALSE;

    /* Start a new directory count. */
    nautilus_directory_invalidate_count_and_mime_list (directory);

    add_all_files_to_work_queue (directory);
    nautilus_directory_async_state_changed (directory);

    nautilus_profile_end (NULL);
}

activate_activation_uris_ready_callback (GList    *files_ignore,
                                         gpointer  callback_data)
{
    ActivateParameters *parameters = callback_data;
    GList *l, *next, *files;
    NautilusFile *file;
    LaunchLocation *location;

    parameters->files_handle = NULL;

    for (l = parameters->locations; l != NULL; l = next)
    {
        location = l->data;
        file = location->file;
        next = l->next;

        if (file_was_cancelled (file))
        {
            launch_location_free (location);
            parameters->locations = g_list_delete_link (parameters->locations, l);
            continue;
        }

        if (nautilus_file_is_broken_symbolic_link (file))
        {
            launch_location_free (location);
            parameters->locations = g_list_delete_link (parameters->locations, l);
            pause_activation_timed_cancel (parameters);
            report_broken_symbolic_link (parameters->parent_window, file);
            unpause_activation_timed_cancel (parameters);
            continue;
        }

        if (nautilus_file_get_file_type (file) == G_FILE_TYPE_MOUNTABLE &&
            !nautilus_file_has_activation_uri (file))
        {
            /* Don't launch these... There is nothing we
             *  can do */
            launch_location_free (location);
            parameters->locations = g_list_delete_link (parameters->locations, l);
            continue;
        }
    }

    if (parameters->locations == NULL)
    {
        activation_parameters_free (parameters);
        return;
    }

    /* Convert the files to the actual activation uri files */
    for (l = parameters->locations; l != NULL; l = l->next)
    {
        char *uri;
        location = l->data;

        /* We want the file for the activation URI since we care
         * about the attributes for that, not for the original file.
         */
        uri = nautilus_file_get_activation_uri (location->file);
        if (uri != NULL)
        {
            launch_location_update_from_uri (location, uri);
        }
        g_free (uri);
    }


    /* get the parameters for the actual files */
    files = get_file_list_for_launch_locations (parameters->locations);
    nautilus_file_list_call_when_ready
        (files,
        nautilus_mime_actions_get_required_file_attributes (),
        &parameters->files_handle,
        activate_callback, parameters);
    nautilus_file_list_free (files);
}

get_target_file_for_link (GFile      *src,
                          GFile      *dest_dir,
                          const char *dest_fs_type,
                          int         count)
{
    const char *editname;
    char *basename, *new_name;
    GFileInfo *info;
    GFile *dest;
    int max_length;

    max_length = get_max_name_length (dest_dir);

    dest = NULL;
    info = g_file_query_info (src,
                              G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME,
                              0, NULL, NULL);
    if (info != NULL)
    {
        editname = g_file_info_get_attribute_string (info, G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME);

        if (editname != NULL)
        {
            new_name = get_link_name (editname, count, max_length);
            make_file_name_valid_for_dest_fs (new_name, dest_fs_type);
            dest = g_file_get_child_for_display_name (dest_dir, new_name, NULL);
            g_free (new_name);
        }

        g_object_unref (info);
    }

    if (dest == NULL)
    {
        basename = g_file_get_basename (src);
        make_file_name_valid_for_dest_fs (basename, dest_fs_type);

        if (g_utf8_validate (basename, -1, NULL))
        {
            new_name = get_link_name (basename, count, max_length);
            make_file_name_valid_for_dest_fs (new_name, dest_fs_type);
            dest = g_file_get_child_for_display_name (dest_dir, new_name, NULL);
            g_free (new_name);
        }

        if (dest == NULL)
        {
            if (count == 1)
            {
                new_name = g_strdup_printf ("%s.lnk", basename);
            }
            else
            {
                new_name = g_strdup_printf ("%s.lnk%d", basename, count);
            }
            make_file_name_valid_for_dest_fs (new_name, dest_fs_type);
            dest = g_file_get_child (dest_dir, new_name);
            g_free (new_name);
        }

        g_free (basename);
    }

    return dest;
}

dir_has_files (GFile *dir)
{
    GFileEnumerator *enumerator;
    gboolean res;
    GFileInfo *file_info;

    res = FALSE;

    enumerator = g_file_enumerate_children (dir,
                                            G_FILE_ATTRIBUTE_STANDARD_NAME,
                                            0,
                                            NULL, NULL);
    if (enumerator)
    {
        file_info = g_file_enumerator_next_file (enumerator, NULL, NULL);
        if (file_info != NULL)
        {
            res = TRUE;
            g_object_unref (file_info);
        }

        g_file_enumerator_close (enumerator, NULL, NULL);
        g_object_unref (enumerator);
    }


    return res;
}

got_mount (MountState *state,
           GMount     *mount)
{
    NautilusDirectory *directory;
    NautilusFile *file;

    directory = nautilus_directory_ref (state->directory);

    state->directory->details->mount_state = NULL;
    async_job_end (state->directory, "mount");

    file = nautilus_file_ref (state->file);

    file->details->mount_is_up_to_date = TRUE;
    nautilus_file_set_mount (file, mount);

    nautilus_directory_async_state_changed (directory);
    nautilus_file_changed (file);

    nautilus_file_unref (file);

    nautilus_directory_unref (directory);

    mount_state_free (state);
}

finalize_common (CommonJob *common)
{
    nautilus_progress_info_finish (common->progress);

    if (common->inhibit_cookie != 0)
    {
        gtk_application_uninhibit (GTK_APPLICATION (g_application_get_default ()),
                                   common->inhibit_cookie);
    }

    common->inhibit_cookie = 0;
    g_timer_destroy (common->time);

    if (common->parent_window)
    {
        g_object_remove_weak_pointer (G_OBJECT (common->parent_window),
                                      (gpointer *) &common->parent_window);
    }

    if (common->skip_files)
    {
        g_hash_table_destroy (common->skip_files);
    }
    if (common->skip_readdir_error)
    {
        g_hash_table_destroy (common->skip_readdir_error);
    }

    if (common->undo_info != NULL)
    {
        nautilus_file_undo_manager_set_action (common->undo_info);
        g_object_unref (common->undo_info);
    }

    g_object_unref (common->progress);
    g_object_unref (common->cancellable);
    g_free (common);
}

delete_trash_file (CommonJob *job,
                   GFile     *file,
                   gboolean   del_file,
                   gboolean   del_children)
{
    GFileInfo *info;
    GFile *child;
    GFileEnumerator *enumerator;

    if (job_aborted (job))
    {
        return;
    }

    if (del_children)
    {
        enumerator = g_file_enumerate_children (file,
                                                G_FILE_ATTRIBUTE_STANDARD_NAME ","
                                                G_FILE_ATTRIBUTE_STANDARD_TYPE,
                                                G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,
                                                job->cancellable,
                                                NULL);
        if (enumerator)
        {
            while (!job_aborted (job) &&
                   (info = g_file_enumerator_next_file (enumerator, job->cancellable, NULL)) != NULL)
            {
                child = g_file_get_child (file,
                                          g_file_info_get_name (info));
                delete_trash_file (job, child, TRUE,
                                   g_file_info_get_file_type (info) == G_FILE_TYPE_DIRECTORY);
                g_object_unref (child);
                g_object_unref (info);
            }
            g_file_enumerator_close (enumerator, job->cancellable, NULL);
            g_object_unref (enumerator);
        }
    }

    if (!job_aborted (job) && del_file)
    {
        g_file_delete (file, job->cancellable, NULL);
    }
}

run_error (CommonJob  *job,
           char       *primary_text,
           char       *secondary_text,
           const char *details_text,
           gboolean    show_all,
           ...)
{
    va_list varargs;
    int res;

    va_start (varargs, show_all);
    res = run_simple_dialog_va (job,
                                FALSE,
                                GTK_MESSAGE_ERROR,
                                primary_text,
                                secondary_text,
                                details_text,
                                show_all,
                                varargs);
    va_end (varargs);
    return res;
}

test_dir_is_parent (GFile *child,
                    GFile *root)
{
    GFile *f, *tmp;

    f = g_file_dup (child);
    while (f)
    {
        if (g_file_equal (f, root))
        {
            g_object_unref (f);
            return TRUE;
        }
        tmp = f;
        f = g_file_get_parent (f);
        g_object_unref (tmp);
    }
    if (f)
    {
        g_object_unref (f);
    }
    return FALSE;
}

schedule_call_ready_callbacks (NautilusDirectory *directory)
{
    if (directory->details->call_ready_idle_id == 0)
    {
        directory->details->call_ready_idle_id
            = g_idle_add (call_ready_callbacks_at_idle, directory);
    }
}

request_counter_add_request (RequestCounter counter,
                             Request        request)
{
    guint i;

    for (i = 0; i < REQUEST_TYPE_LAST; i++)
    {
        if (REQUEST_WANTS_TYPE (request, i))
        {
            counter[i]++;
        }
    }
}

extract_job_on_decide_destination (AutoarExtractor *extractor,
                                   GFile           *destination,
                                   GList           *files,
                                   gpointer         user_data)
{
    ExtractJob *extract_job = user_data;
    GFile *decided_destination;
    g_autofree char *basename = NULL;

    nautilus_progress_info_set_details (extract_job->common.progress,
                                        _("Verifying destination"));

    basename = g_file_get_basename (destination);
    decided_destination = nautilus_generate_unique_file_in_directory (extract_job->destination_directory,
                                                                      basename);

    if (job_aborted ((CommonJob *) extract_job))
    {
        g_object_unref (decided_destination);
        return NULL;
    }

    extract_job->output_files = g_list_prepend (extract_job->output_files,
                                                decided_destination);

    return g_object_ref (decided_destination);
}

move_file_to_low_priority_queue (NautilusDirectory *directory,
                                 NautilusFile      *file)
{
    /* Must add before removing to avoid ref underflow */
    nautilus_file_queue_enqueue (directory->details->low_priority_queue,
                                 file);
    nautilus_file_queue_remove (directory->details->high_priority_queue,
                                file);
}

nautilus_directory_is_file_list_monitored (NautilusDirectory *directory)
{
    return directory->details->file_list_monitored;
}

thumbnail_stop (NautilusDirectory *directory)
{
    NautilusFile *file;

    if (directory->details->thumbnail_state != NULL)
    {
        file = directory->details->thumbnail_state->file;

        if (file != NULL)
        {
            g_assert (NAUTILUS_IS_FILE (file));
            g_assert (file->details->directory == directory);
            if (is_needy (file,
                          lacks_thumbnail,
                          REQUEST_THUMBNAIL))
            {
                return;
            }
        }

        /* The link info is not wanted, so stop it. */
        thumbnail_cancel (directory);
    }
}

get_activation_action (NautilusFile *file)
{
    ActivationAction action;
    char *activation_uri;
    gboolean can_extract;
    can_extract = g_settings_get_boolean (nautilus_preferences,
                                          NAUTILUS_PREFERENCES_AUTOMATIC_DECOMPRESSION);

    if (can_extract && nautilus_file_is_archive (file))
    {
        return ACTIVATION_ACTION_EXTRACT;
    }

    if (nautilus_file_is_nautilus_link (file))
    {
        return ACTIVATION_ACTION_LAUNCH_DESKTOP_FILE;
    }

    activation_uri = nautilus_file_get_activation_uri (file);
    if (activation_uri == NULL)
    {
        activation_uri = nautilus_file_get_uri (file);
    }

    action = ACTIVATION_ACTION_DO_NOTHING;
    if (nautilus_file_is_launchable (file))
    {
        char *executable_path;

        action = ACTIVATION_ACTION_LAUNCH;

        executable_path = g_filename_from_uri (activation_uri, NULL, NULL);
        if (!executable_path)
        {
            action = ACTIVATION_ACTION_DO_NOTHING;
        }
        else if (nautilus_file_contains_text (file))
        {
            action = get_default_executable_text_file_action ();
        }
        g_free (executable_path);
    }

    if (action == ACTIVATION_ACTION_DO_NOTHING)
    {
        if (nautilus_file_opens_in_view (file))
        {
            action = ACTIVATION_ACTION_OPEN_IN_VIEW;
        }
        else
        {
            action = ACTIVATION_ACTION_OPEN_IN_APPLICATION;
        }
    }
    g_free (activation_uri);

    return action;
}

file_info_stop (NautilusDirectory *directory)
{
    NautilusFile *file;

    if (directory->details->get_info_in_progress != NULL)
    {
        file = directory->details->get_info_file;
        if (file != NULL)
        {
            g_assert (NAUTILUS_IS_FILE (file));
            g_assert (file->details->directory == directory);
            if (is_needy (file, lacks_info, REQUEST_FILE_INFO))
            {
                return;
            }
        }

        /* The info is not wanted, so stop it. */
        file_info_cancel (directory);
    }
}

abort_job (CommonJob *job)
{
    /* destroy the undo action data too */
    g_clear_object (&job->undo_info);

    g_cancellable_cancel (job->cancellable);
}

format_time (int seconds)
{
    int minutes;
    int hours;
    char *res;

    if (seconds < 0)
    {
        /* Just to make sure... */
        seconds = 0;
    }

    if (seconds < 60)
    {
        return g_strdup_printf (ngettext ("%'d second", "%'d seconds", (int) seconds), (int) seconds);
    }

    if (seconds < 60 * 60)
    {
        minutes = seconds / 60;
        return g_strdup_printf (ngettext ("%'d minute", "%'d minutes", minutes), minutes);
    }

    hours = seconds / (60 * 60);

    if (seconds < 60 * 60 * 4)
    {
        char *h, *m;

        minutes = (seconds - hours * 60 * 60) / 60;

        h = g_strdup_printf (ngettext ("%'d hour", "%'d hours", hours), hours);
        m = g_strdup_printf (ngettext ("%'d minute", "%'d minutes", minutes), minutes);
        res = g_strconcat (h, ", ", m, NULL);
        g_free (h);
        g_free (m);
        return res;
    }

    return g_strdup_printf (ngettext ("approximately %'d hour",
                                      "approximately %'d hours",
                                      hours), hours);
}

prompt_empty_trash (GtkWindow *parent_window)
{
    gint result;
    GtkWidget *dialog;
    GdkScreen *screen;

    screen = NULL;
    if (parent_window != NULL)
    {
        screen = gtk_widget_get_screen (GTK_WIDGET (parent_window));
    }

    /* Do we need to be modal ? */
    dialog = gtk_message_dialog_new (NULL, GTK_DIALOG_MODAL,
                                     GTK_MESSAGE_QUESTION, GTK_BUTTONS_NONE,
                                     _("Do you want to empty the trash before you unmount?"));
    gtk_message_dialog_format_secondary_text (GTK_MESSAGE_DIALOG (dialog),
                                              _("In order to regain the "
                                                "free space on this volume "
                                                "the trash must be emptied. "
                                                "All trashed items on the volume "
                                                "will be permanently lost."));
    gtk_dialog_add_buttons (GTK_DIALOG (dialog),
                            _("Do _not Empty Trash"), GTK_RESPONSE_REJECT,
                            CANCEL, GTK_RESPONSE_CANCEL,
                            _("Empty _Trash"), GTK_RESPONSE_ACCEPT, NULL);
    gtk_dialog_set_default_response (GTK_DIALOG (dialog), GTK_RESPONSE_ACCEPT);
    gtk_window_set_title (GTK_WINDOW (dialog), "");     /* as per HIG */
    gtk_window_set_skip_taskbar_hint (GTK_WINDOW (dialog), TRUE);
    if (screen)
    {
        gtk_window_set_screen (GTK_WINDOW (dialog), screen);
    }
    atk_object_set_role (gtk_widget_get_accessible (dialog), ATK_ROLE_ALERT);
    gtk_window_set_wmclass (GTK_WINDOW (dialog), "empty_trash",
                            "Nautilus");

    /* Make transient for the window group */
    gtk_widget_realize (dialog);
    if (screen != NULL)
    {
        gdk_window_set_transient_for (gtk_widget_get_window (GTK_WIDGET (dialog)),
                                      gdk_screen_get_root_window (screen));
    }

    result = gtk_dialog_run (GTK_DIALOG (dialog));
    gtk_widget_destroy (dialog);
    return result;
}

scan_dir (GFile      *dir,
          SourceInfo *source_info,
          CommonJob  *job,
          GQueue     *dirs,
          GHashTable *scanned)
{
    GFileInfo *info;
    GError *error;
    GFile *subdir;
    GFileEnumerator *enumerator;
    char *primary, *secondary, *details;
    int response;
    SourceInfo saved_info;

    saved_info = *source_info;

retry:
    error = NULL;
    enumerator = g_file_enumerate_children (dir,
                                            G_FILE_ATTRIBUTE_STANDARD_NAME ","
                                            G_FILE_ATTRIBUTE_STANDARD_TYPE ","
                                            G_FILE_ATTRIBUTE_STANDARD_SIZE,
                                            G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,
                                            job->cancellable,
                                            &error);
    if (enumerator)
    {
        error = NULL;
        while ((info = g_file_enumerator_next_file (enumerator, job->cancellable, &error)) != NULL)
        {
            g_autoptr (GFile) file = NULL;
            g_autofree char *file_uri = NULL;

            file = g_file_enumerator_get_child (enumerator, info);
            file_uri = g_file_get_uri (file);

            if (!g_hash_table_contains (scanned, file_uri))
            {
                g_hash_table_add (scanned, g_strdup (file_uri));

                count_file (info, job, source_info);

                if (g_file_info_get_file_type (info) == G_FILE_TYPE_DIRECTORY)
                {
                    subdir = g_file_get_child (dir,
                                               g_file_info_get_name (info));

                    /* Push to head, since we want depth-first */
                    g_queue_push_head (dirs, subdir);
                }
            }
            g_object_unref (info);
        }
        g_file_enumerator_close (enumerator, job->cancellable, NULL);
        g_object_unref (enumerator);

        if (error && IS_IO_ERROR (error, CANCELLED))
        {
            g_error_free (error);
        }
        else if (error)
        {
            primary = get_scan_primary (source_info->op);
            details = NULL;

            if (IS_IO_ERROR (error, PERMISSION_DENIED))
            {
                secondary = f (_("Files in the folder “%B” cannot be handled because you do "
                                 "not have permissions to see them."), dir);
            }
            else
            {
                secondary = f (_("There was an error getting information about the files in the folder “%B”."), dir);
                details = error->message;
            }

            response = run_warning (job,
                                    primary,
                                    secondary,
                                    details,
                                    FALSE,
                                    CANCEL, RETRY, SKIP,
                                    NULL);

            g_error_free (error);

            if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)
            {
                abort_job (job);
            }
            else if (response == 1)
            {
                *source_info = saved_info;
                goto retry;
            }
            else if (response == 2)
            {
                skip_readdir_error (job, dir);
            }
            else
            {
                g_assert_not_reached ();
            }
        }
    }
    else if (job->skip_all_error)
    {
        g_error_free (error);
        skip_file (job, dir);
    }
    else if (IS_IO_ERROR (error, CANCELLED))
    {
        g_error_free (error);
    }
    else
    {
        primary = get_scan_primary (source_info->op);
        details = NULL;

        if (IS_IO_ERROR (error, PERMISSION_DENIED))
        {
            secondary = f (_("The folder “%B” cannot be handled because you do not have "
                             "permissions to read it."), dir);
        }
        else
        {
            secondary = f (_("There was an error reading the folder “%B”."), dir);
            details = error->message;
        }
        /* set show_all to TRUE here, as we don't know how many
         * files we'll end up processing yet.
         */
        response = run_warning (job,
                                primary,
                                secondary,
                                details,
                                TRUE,
                                CANCEL, SKIP_ALL, SKIP, RETRY,
                                NULL);

        g_error_free (error);

        if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)
        {
            abort_job (job);
        }
        else if (response == 1 || response == 2)
        {
            if (response == 1)
            {
                job->skip_all_error = TRUE;
            }
            skip_file (job, dir);
        }
        else if (response == 3)
        {
            goto retry;
        }
        else
        {
            g_assert_not_reached ();
        }
    }
}
