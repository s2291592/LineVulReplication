void ImageBitmapFactories::DidFinishLoading(ImageBitmapLoader* loader) {
  DCHECK(pending_loaders_.Contains(loader));
   pending_loaders_.erase(loader);
 }

void ImageBitmapFactories::ImageBitmapLoader::LoadBlobAsync(
    Blob* blob) {
loader_->Start(blob->GetBlobDataHandle());
}

ScriptPromise ImageBitmapFactories::CreateImageBitmapFromBlob(
    ScriptState* script_state,
    EventTarget& event_target,
    ImageBitmapSource* bitmap_source,
    base::Optional<IntRect> crop_rect,
    const ImageBitmapOptions* options) {
  Blob* blob = static_cast<Blob*>(bitmap_source);
  ImageBitmapLoader* loader = ImageBitmapFactories::ImageBitmapLoader::Create(
      From(event_target), crop_rect, options, script_state);
  ScriptPromise promise = loader->Promise();
  From(event_target).AddLoader(loader);
  loader->LoadBlobAsync(blob);
  return promise;
}

void ImageBitmapFactories::ImageBitmapLoader::DidFail(FileErrorCode) {
  RejectPromise(kUndecodableImageBitmapRejectionReason);
}

 void ImageBitmapFactories::ImageBitmapLoader::DidFinishLoading() {
   DOMArrayBuffer* array_buffer = loader_->ArrayBufferResult();
   if (!array_buffer) {
     RejectPromise(kAllocationFailureImageBitmapRejectionReason);
     return;
  }
  ScheduleAsyncImageBitmapDecoding(array_buffer);
}

 void ImageBitmapFactories::ImageBitmapLoader::RejectPromise(
    ImageBitmapRejectionReason reason) {
  switch (reason) {
    case kUndecodableImageBitmapRejectionReason:
      resolver_->Reject(
          DOMException::Create(DOMExceptionCode::kInvalidStateError,
                               "The source image could not be decoded."));
      break;
    case kAllocationFailureImageBitmapRejectionReason:
      resolver_->Reject(
          DOMException::Create(DOMExceptionCode::kInvalidStateError,
                               "The ImageBitmap could not be allocated."));
      break;
     default:
       NOTREACHED();
   }
   factory_->DidFinishLoading(this);
 }

ScriptPromise ImageBitmapFactories::CreateImageBitmap(
    ScriptState* script_state,
    EventTarget& event_target,
    const ImageBitmapSourceUnion& bitmap_source,
    const ImageBitmapOptions* options) {
  WebFeature feature = WebFeature::kCreateImageBitmap;
  UseCounter::Count(ExecutionContext::From(script_state), feature);
  ImageBitmapSource* bitmap_source_internal =
      ToImageBitmapSourceInternal(bitmap_source, options, false);
  if (!bitmap_source_internal)
    return ScriptPromise();
  return CreateImageBitmap(script_state, event_target, bitmap_source_internal,
                           base::Optional<IntRect>(), options);
}

ImageBitmapFactories& ImageBitmapFactories::FromInternal(GlobalObject& object) {
  ImageBitmapFactories* supplement =
      Supplement<GlobalObject>::template From<ImageBitmapFactories>(object);
  if (!supplement) {
    supplement = MakeGarbageCollected<ImageBitmapFactories>();
    Supplement<GlobalObject>::ProvideTo(object, supplement);
  }
  return *supplement;
}

ScriptPromise ImageBitmapFactories::CreateImageBitmap(
    ScriptState* script_state,
    EventTarget& event_target,
    const ImageBitmapSourceUnion& bitmap_source,
    int sx,
    int sy,
    int sw,
    int sh,
    const ImageBitmapOptions* options) {
  WebFeature feature = WebFeature::kCreateImageBitmap;
  UseCounter::Count(ExecutionContext::From(script_state), feature);
  ImageBitmapSource* bitmap_source_internal =
      ToImageBitmapSourceInternal(bitmap_source, options, true);
  if (!bitmap_source_internal)
    return ScriptPromise();
  base::Optional<IntRect> crop_rect = IntRect(sx, sy, sw, sh);
  return CreateImageBitmap(script_state, event_target, bitmap_source_internal,
                           crop_rect, options);
}

void ImageBitmapFactories::AddLoader(ImageBitmapLoader* loader) {
  pending_loaders_.insert(loader);
}

void ImageBitmapFactories::Trace(blink::Visitor* visitor) {
  visitor->Trace(pending_loaders_);
  Supplement<LocalDOMWindow>::Trace(visitor);
  Supplement<WorkerGlobalScope>::Trace(visitor);
}
