void read_mv(stream_t *stream,mv_t *mv,mv_t *mvp)
{
    mv_t mvd;
    int mvabs, mvsign = 0;

    /* MVX */
    if ((mvabs = get_vlc(7, stream)))
      mvsign = get_flc(1, stream);
    mvd.x = mvabs * (mvsign ? -1 : 1);
    mv->x = mvp->x + mvd.x;

    /* MVY */
    if ((mvabs = get_vlc(7, stream)))
      mvsign = get_flc(1, stream);
    mvd.y = mvabs * (mvsign ? -1 : 1);
    mv->y = mvp->y + mvd.y;
}

static void copy_deblock_data(decoder_info_t *decoder_info, block_info_dec_t *block_info){

  int size = block_info->block_pos.size;
  int block_posy = block_info->block_pos.ypos/MIN_PB_SIZE;
  int block_posx = block_info->block_pos.xpos/MIN_PB_SIZE;
  int block_stride = decoder_info->width/MIN_PB_SIZE;
  int block_index;
  int m,n,m0,n0,index;
  int div = size/(2*MIN_PB_SIZE);
  int bwidth =  block_info->block_pos.bwidth;
  int bheight =  block_info->block_pos.bheight;
  uint8_t tb_split = block_info->block_param.tb_split > 0;
  part_t pb_part = block_info->block_param.mode == MODE_INTER ? block_info->block_param.pb_part : PART_NONE; //TODO: Set pb_part properly for SKIP and BIPRED

  for (m=0;m<bheight/MIN_PB_SIZE;m++){
    for (n=0;n<bwidth/MIN_PB_SIZE;n++){
      block_index = (block_posy+m)*block_stride + block_posx+n;
      m0 = div > 0 ? m/div : 0;
      n0 = div > 0 ? n/div : 0;
      index = 2*m0+n0;
      if (index > 3) printf("error: index=%4d\n",index);
      decoder_info->deblock_data[block_index].cbp = block_info->cbp;
      decoder_info->deblock_data[block_index].tb_split = tb_split;
      decoder_info->deblock_data[block_index].pb_part = pb_part;
      decoder_info->deblock_data[block_index].size = block_info->block_pos.size;

      decoder_info->deblock_data[block_index].mode = block_info->block_param.mode;
      if (decoder_info->bit_count.stat_frame_type == B_FRAME && decoder_info->interp_ref == 2 && block_info->block_param.mode == MODE_SKIP && block_info->block_param.skip_idx==0) {
        int phase = decoder_info->frame_info.phase;
        decoder_info->deblock_data[block_index].inter_pred.mv0 = decoder_info->deblock_data[block_index].inter_pred_arr[phase].mv0;
        decoder_info->deblock_data[block_index].inter_pred.mv1 = decoder_info->deblock_data[block_index].inter_pred_arr[phase].mv0;
        if (decoder_info->num_reorder_pics == 2 && phase == 1) {
          decoder_info->deblock_data[block_index].inter_pred.mv1.x *= 2;
          decoder_info->deblock_data[block_index].inter_pred.mv1.y *= 2;
        }
      }
      else {
        decoder_info->deblock_data[block_index].inter_pred.mv0 = block_info->block_param.mv_arr0[index];
        decoder_info->deblock_data[block_index].inter_pred.mv1 = block_info->block_param.mv_arr1[index];
      }
      decoder_info->deblock_data[block_index].inter_pred.ref_idx0 = block_info->block_param.ref_idx0;
      decoder_info->deblock_data[block_index].inter_pred.ref_idx1 = block_info->block_param.ref_idx1;
      decoder_info->deblock_data[block_index].inter_pred.bipred_flag = block_info->block_param.dir;
    }
  }
}

static void decode_and_reconstruct_block_intra_uv (SAMPLE *rec_u, SAMPLE *rec_v, int stride, int size, int qp, SAMPLE *pblock_u, SAMPLE *pblock_v, int16_t *coeffq_u, int16_t *coeffq_v,
                                                   int tb_split, int upright_available,int downleft_available, intra_mode_t intra_mode,int ypos,int xpos,int width,int comp, int bitdepth,
                                                   qmtx_t ** iwmatrix, SAMPLE *pblock_y, SAMPLE *rec_y, int rec_stride, int sub){

  int16_t *rcoeff = thor_alloc(2*MAX_TR_SIZE*MAX_TR_SIZE, 32);
  int16_t *rblock = thor_alloc(2*MAX_TR_SIZE*MAX_TR_SIZE, 32);
  int16_t *rblock2 = thor_alloc(2*MAX_TR_SIZE*MAX_TR_SIZE, 32);

  SAMPLE* left_data = (SAMPLE*)thor_alloc((2*MAX_TR_SIZE+2)*sizeof(SAMPLE),32)+1;
  SAMPLE* top_data = (SAMPLE*)thor_alloc((2*MAX_TR_SIZE+2)*sizeof(SAMPLE),32)+1;
  SAMPLE top_left;

  if (tb_split){
    int size2 = size/2;
    int i,j,index;
    for (i=0;i<size;i+=size2){
      for (j=0;j<size;j+=size2){
        TEMPLATE(make_top_and_left)(left_data,top_data,&top_left,rec_u,stride,&rec_u[i*stride+j],stride,i,j,ypos,xpos,size2,upright_available,downleft_available,1,bitdepth);
        TEMPLATE(get_intra_prediction)(left_data,top_data,top_left,ypos+i,xpos+j,size2,&pblock_u[i*size+j],size,intra_mode,bitdepth);
        TEMPLATE(make_top_and_left)(left_data,top_data,&top_left,rec_v,stride,&rec_v[i*stride+j],stride,i,j,ypos,xpos,size2,upright_available,downleft_available,1,bitdepth);
        TEMPLATE(get_intra_prediction)(left_data,top_data,top_left,ypos+i,xpos+j,size2,&pblock_v[i*size+j],size,intra_mode,bitdepth);
	if (pblock_y)
	  TEMPLATE(improve_uv_prediction)(&pblock_y[i*size+j], &pblock_u[i*size+j], &pblock_v[i*size+j], &rec_y[(i<<sub)*rec_stride+(j<<sub)], size2 << sub, size << sub, rec_stride, sub, bitdepth);
        index = 2*(i/size2) + (j/size2);
        TEMPLATE(dequantize)(coeffq_u+index*size2*size2, rcoeff, qp, size2, iwmatrix ? iwmatrix[log2i(size2/4)] : NULL);
        inverse_transform (rcoeff, rblock2, size2, bitdepth);
        TEMPLATE(reconstruct_block)(rblock2,&pblock_u[i*size+j],&rec_u[i*stride+j],size2,size,stride,bitdepth);
        TEMPLATE(dequantize)(coeffq_v+index*size2*size2, rcoeff, qp, size2, iwmatrix ? iwmatrix[log2i(size2/4)] : NULL);
        inverse_transform (rcoeff, rblock2, size2, bitdepth);
        TEMPLATE(reconstruct_block)(rblock2,&pblock_v[i*size+j],&rec_v[i*stride+j],size2,size,stride,bitdepth);
      }
    }
  }
  else{
    TEMPLATE(make_top_and_left)(left_data,top_data,&top_left,rec_u,stride,NULL,0,0,0,ypos,xpos,size,upright_available,downleft_available,0,bitdepth);
    TEMPLATE(get_intra_prediction)(left_data,top_data,top_left,ypos,xpos,size,pblock_u,size,intra_mode,bitdepth);
    TEMPLATE(make_top_and_left)(left_data,top_data,&top_left,rec_v,stride,NULL,0,0,0,ypos,xpos,size,upright_available,downleft_available,0,bitdepth);
    TEMPLATE(get_intra_prediction)(left_data,top_data,top_left,ypos,xpos,size,pblock_v,size,intra_mode,bitdepth);
    if (pblock_y)
      TEMPLATE(improve_uv_prediction)(pblock_y, pblock_u, pblock_v, rec_y, size << sub, size << sub, rec_stride, sub, bitdepth);
    TEMPLATE(dequantize)(coeffq_u, rcoeff, qp, size, iwmatrix ? iwmatrix[log2i(size/4)] : NULL);
    inverse_transform (rcoeff, rblock, size, bitdepth);
    TEMPLATE(reconstruct_block)(rblock,pblock_u,rec_u,size,size,stride,bitdepth);
    TEMPLATE(dequantize)(coeffq_v, rcoeff, qp, size, iwmatrix ? iwmatrix[log2i(size/4)] : NULL);
    inverse_transform (rcoeff, rblock, size, bitdepth);
    TEMPLATE(reconstruct_block)(rblock,pblock_v,rec_v,size,size,stride,bitdepth);
  }

  thor_free(top_data - 1);
  thor_free(left_data - 1);
  thor_free(rcoeff);
  thor_free(rblock);
  thor_free(rblock2);
}

static void decode_and_reconstruct_block_inter (SAMPLE *rec, int stride, int size, int qp, SAMPLE *pblock,
                                                int16_t *coeffq,int tb_split, int bitdepth, qmtx_t ** iwmatrix){

  int16_t *rcoeff = thor_alloc(2*MAX_TR_SIZE*MAX_TR_SIZE, 32);
  int16_t *rblock = thor_alloc(2*MAX_TR_SIZE*MAX_TR_SIZE, 32);
  int16_t *rblock2 = thor_alloc(2*MAX_TR_SIZE*MAX_TR_SIZE, 32);

  if (tb_split){
    int size2 = size/2;
    int i,j,k,index;
    for (i=0;i<size;i+=size2){
      for (j=0;j<size;j+=size2){
        index = 2*(i/size2) + (j/size2);
        TEMPLATE(dequantize)(coeffq+index*size2*size2, rcoeff, qp, size2, iwmatrix ? iwmatrix[log2i(size2/4)] : NULL);
        inverse_transform (rcoeff, rblock2, size2, bitdepth);
        /* Copy from compact block of quarter size to full size */
        for (k=0;k<size2;k++){
          memcpy(rblock+(i+k)*size+j,rblock2+k*size2,size2*sizeof(int16_t));
        }
      }
    }
  }
  else {
    TEMPLATE(dequantize)(coeffq, rcoeff, qp, size, iwmatrix ? iwmatrix[log2i(size/4)] : NULL);

    inverse_transform (rcoeff, rblock, size, bitdepth);
  }
  TEMPLATE(reconstruct_block)(rblock,pblock,rec,size,size,stride,bitdepth);

  thor_free(rcoeff);
  thor_free(rblock);
  thor_free(rblock2);
}

int read_block(decoder_info_t *decoder_info,stream_t *stream,block_info_dec_t *block_info, frame_type_t frame_type)
{
  int width = decoder_info->width;
  int height = decoder_info->height;
  int bit_start;
  int code,tb_split;
  int pb_part=0;
  cbp_t cbp;
  int stat_frame_type = decoder_info->bit_count.stat_frame_type; //TODO: Use only one variable for frame type

  int size = block_info->block_pos.size;
  int ypos = block_info->block_pos.ypos;
  int xpos = block_info->block_pos.xpos;

  YPOS = ypos;
  XPOS = xpos;

  int sizeY = size;
  int sizeC = size>>block_info->sub;

  mv_t mv,zerovec;
  mv_t mvp;
  mv_t mv_arr[4]; //TODO: Use mv_arr0 instead
  mv_t mv_arr0[4];
  mv_t mv_arr1[4];

  block_mode_t mode;
  intra_mode_t intra_mode = MODE_DC;

  int16_t *coeff_y = block_info->coeffq_y;
  int16_t *coeff_u = block_info->coeffq_u;
  int16_t *coeff_v = block_info->coeffq_v;

  zerovec.y = zerovec.x = 0;
  bit_start = stream->bitcnt;

  mode = decoder_info->mode;
  int coeff_block_type = (mode == MODE_INTRA)<<1;

  /* Initialize bit counter for statistical purposes */
  bit_start = stream->bitcnt;

  if (mode == MODE_SKIP){
    /* Derive skip vector candidates and number of skip vector candidates from neighbour blocks */
    mv_t mv_skip[MAX_NUM_SKIP];
    int num_skip_vec,skip_idx;
    inter_pred_t skip_candidates[MAX_NUM_SKIP];
    num_skip_vec = TEMPLATE(get_mv_skip)(ypos, xpos, width, height, size, size, 1 << decoder_info->log2_sb_size, decoder_info->deblock_data, skip_candidates);
    if (decoder_info->bit_count.stat_frame_type == B_FRAME && decoder_info->interp_ref == 2) {
      num_skip_vec = TEMPLATE(get_mv_skip_temp)(decoder_info->width, decoder_info->frame_info.phase, decoder_info->num_reorder_pics + 1, &block_info->block_pos, decoder_info->deblock_data, skip_candidates);
    }
    for (int idx = 0; idx < num_skip_vec; idx++) {
      mv_skip[idx] = skip_candidates[idx].mv0;
    }
    /* Decode skip index */
    if (num_skip_vec == 4)
      skip_idx = get_flc(2, stream);
    else if (num_skip_vec == 3){
      skip_idx = get_vlc(12, stream);
    }
    else if (num_skip_vec == 2){
      skip_idx = get_flc(1, stream);
    }
    else
      skip_idx = 0;
    decoder_info->bit_count.skip_idx[stat_frame_type] += (stream->bitcnt - bit_start);

    block_info->num_skip_vec = num_skip_vec;
    block_info->block_param.skip_idx = skip_idx;

    if (skip_idx == num_skip_vec)
      mv = mv_skip[0];
    else
      mv = mv_skip[skip_idx];
    mv_arr[0] = mv;
    mv_arr[1] = mv;
    mv_arr[2] = mv;
    mv_arr[3] = mv;

    block_info->block_param.ref_idx0 = skip_candidates[skip_idx].ref_idx0;
    block_info->block_param.ref_idx1 = skip_candidates[skip_idx].ref_idx1;
    for (int i = 0; i < 4; i++) {
      mv_arr0[i] = skip_candidates[skip_idx].mv0;
      mv_arr1[i] = skip_candidates[skip_idx].mv1;
    }
    block_info->block_param.dir = skip_candidates[skip_idx].bipred_flag;
  }
  else if (mode == MODE_MERGE){
    /* Derive skip vector candidates and number of skip vector candidates from neighbour blocks */
    mv_t mv_skip[MAX_NUM_SKIP];
    int num_skip_vec,skip_idx;
    inter_pred_t merge_candidates[MAX_NUM_SKIP];
    num_skip_vec = TEMPLATE(get_mv_merge)(ypos, xpos, width, height, size, size, 1 << decoder_info->log2_sb_size, decoder_info->deblock_data, merge_candidates);
    for (int idx = 0; idx < num_skip_vec; idx++) {
      mv_skip[idx] = merge_candidates[idx].mv0;
    }
    /* Decode skip index */
    if (num_skip_vec == 4)
      skip_idx = get_flc(2, stream);
    else if (num_skip_vec == 3){
      skip_idx = get_vlc(12, stream);
    }
    else if (num_skip_vec == 2){
      skip_idx = get_flc(1, stream);
    }
    else
      skip_idx = 0;
    decoder_info->bit_count.skip_idx[stat_frame_type] += (stream->bitcnt - bit_start);

    block_info->num_skip_vec = num_skip_vec;
    block_info->block_param.skip_idx = skip_idx;

    if (skip_idx == num_skip_vec)
      mv = mv_skip[0];
    else
      mv = mv_skip[skip_idx];
    mv_arr[0] = mv;
    mv_arr[1] = mv;
    mv_arr[2] = mv;
    mv_arr[3] = mv;

    block_info->block_param.ref_idx0 = merge_candidates[skip_idx].ref_idx0;
    block_info->block_param.ref_idx1 = merge_candidates[skip_idx].ref_idx1;
    for (int i = 0; i < 4; i++) {
      mv_arr0[i] = merge_candidates[skip_idx].mv0;
      mv_arr1[i] = merge_candidates[skip_idx].mv1;
    }
    block_info->block_param.dir = merge_candidates[skip_idx].bipred_flag;
  }
  else if (mode==MODE_INTER){
    int ref_idx;

    if (decoder_info->pb_split){
      /* Decode PU partition */
      pb_part = get_vlc(13, stream);
    }
    else{
      pb_part = 0;
    }
    block_info->block_param.pb_part = pb_part;
    if (decoder_info->frame_info.num_ref > 1){
      ref_idx = decoder_info->ref_idx;
    }
    else{
      ref_idx = 0;
    }

    decoder_info->bit_count.size_and_ref_idx[stat_frame_type][log2i(size)-3][ref_idx] += 1;

    mvp = TEMPLATE(get_mv_pred)(ypos,xpos,width,height,size,size,1<<decoder_info->log2_sb_size,ref_idx,decoder_info->deblock_data);

    /* Deode motion vectors for each prediction block */
    mv_t mvp2 = mvp;

    if (pb_part==0){
      read_mv(stream,&mv_arr[0],&mvp2);
      mv_arr[1] = mv_arr[0];
      mv_arr[2] = mv_arr[0];
      mv_arr[3] = mv_arr[0];
    }
    else if(pb_part==1){ //HOR
      read_mv(stream,&mv_arr[0],&mvp2);
      mvp2 = mv_arr[0];
      read_mv(stream,&mv_arr[2],&mvp2);
      mv_arr[1] = mv_arr[0];
      mv_arr[3] = mv_arr[2];
    }
    else if(pb_part==2){ //VER
      read_mv(stream,&mv_arr[0],&mvp2);
      mvp2 = mv_arr[0];
      read_mv(stream,&mv_arr[1],&mvp2);
      mv_arr[2] = mv_arr[0];
      mv_arr[3] = mv_arr[1];
    }
    else{
      read_mv(stream,&mv_arr[0],&mvp2);
      mvp2 = mv_arr[0];
      read_mv(stream,&mv_arr[1],&mvp2);
      read_mv(stream,&mv_arr[2],&mvp2);
      read_mv(stream,&mv_arr[3],&mvp2);
    }
    decoder_info->bit_count.mv[stat_frame_type] += (stream->bitcnt - bit_start);
    block_info->block_param.ref_idx0 = ref_idx;
    block_info->block_param.ref_idx1 = ref_idx;
    block_info->block_param.dir = 0;
  }
  else if (mode==MODE_BIPRED){
    int ref_idx = 0;
    mvp = TEMPLATE(get_mv_pred)(ypos,xpos,width,height,size,size,1 << decoder_info->log2_sb_size, ref_idx,decoder_info->deblock_data);

    /* Deode motion vectors */
    mv_t mvp2 = mvp;

#if BIPRED_PART
    if (decoder_info->pb_split) {
      /* Decode PU partition */
      pb_part = get_vlc(13, stream);
    }
    else {
      pb_part = 0;
    }
#else
    pb_part = 0;
#endif
    block_info->block_param.pb_part = pb_part;

    if (pb_part == 0) {
      read_mv(stream, &mv_arr0[0], &mvp2);
      mv_arr0[1] = mv_arr0[0];
      mv_arr0[2] = mv_arr0[0];
      mv_arr0[3] = mv_arr0[0];
    }
    else {
      mv_arr0[0] = mvp2;
      mv_arr0[1] = mvp2;
      mv_arr0[2] = mvp2;
      mv_arr0[3] = mvp2;
    }
    if (decoder_info->bit_count.stat_frame_type == B_FRAME)
      mvp2 = mv_arr0[0];
    if (pb_part == 0) {
      read_mv(stream, &mv_arr1[0], &mvp2);
      mv_arr1[1] = mv_arr1[0];
      mv_arr1[2] = mv_arr1[0];
      mv_arr1[3] = mv_arr1[0];
    }
    else if (pb_part == 1) { //HOR
      read_mv(stream, &mv_arr1[0], &mvp2);
      mvp2 = mv_arr1[0];
      read_mv(stream, &mv_arr1[2], &mvp2);
      mv_arr1[1] = mv_arr1[0];
      mv_arr1[3] = mv_arr1[2];
    }
    else if (pb_part == 2) { //VER
      read_mv(stream, &mv_arr1[0], &mvp2);
      mvp2 = mv_arr1[0];
      read_mv(stream, &mv_arr1[1], &mvp2);
      mv_arr1[2] = mv_arr1[0];
      mv_arr1[3] = mv_arr1[1];
    }
    else {
      read_mv(stream, &mv_arr1[0], &mvp2);
      mvp2 = mv_arr1[0];
      read_mv(stream, &mv_arr1[1], &mvp2);
      read_mv(stream, &mv_arr1[2], &mvp2);
      read_mv(stream, &mv_arr1[3], &mvp2);
    }

    if (decoder_info->bit_count.stat_frame_type == B_FRAME) {
      block_info->block_param.ref_idx0 = 0;
      block_info->block_param.ref_idx1 = 1;
      if (decoder_info->frame_info.interp_ref > 0) {
        block_info->block_param.ref_idx0 += 1;
        block_info->block_param.ref_idx1 += 1;
      }
    }
    else{
      if (decoder_info->frame_info.num_ref == 2) {
        int code = get_vlc(13, stream);
        block_info->block_param.ref_idx0 = (code >> 1) & 1;
        block_info->block_param.ref_idx1 = (code >> 0) & 1;
      }
      else {
        int code = get_vlc(10, stream);
        block_info->block_param.ref_idx0 = (code >> 2) & 3;
        block_info->block_param.ref_idx1 = (code >> 0) & 3;
      }
    }
    block_info->block_param.dir = 2;
    int combined_ref = block_info->block_param.ref_idx0 * decoder_info->frame_info.num_ref + block_info->block_param.ref_idx1;
    decoder_info->bit_count.bi_ref[stat_frame_type][combined_ref] += 1;
    decoder_info->bit_count.mv[stat_frame_type] += (stream->bitcnt - bit_start);
  }

  else if (mode==MODE_INTRA){
    /* Decode intra prediction mode */
    if (decoder_info->frame_info.num_intra_modes<=4){
      intra_mode = get_flc(2, stream);
    }
    else {
      intra_mode = get_vlc(8, stream);
    }

    decoder_info->bit_count.intra_mode[stat_frame_type] += (stream->bitcnt - bit_start);
    decoder_info->bit_count.size_and_intra_mode[stat_frame_type][log2i(size)-3][intra_mode] += 1;

    block_info->block_param.intra_mode = intra_mode;
    for (int i=0;i<4;i++){
      mv_arr[i] = zerovec; //Note: This is necessary for derivation of mvp and mv_skip
    }
    block_info->block_param.ref_idx0 = 0;
    block_info->block_param.ref_idx1 = 0;
    block_info->block_param.dir = -1;
  }


  if (mode!=MODE_SKIP){
    int tmp;
    int cbp_table[8] = {1,0,5,2,6,3,7,4};
    code = 0;

    if (decoder_info->subsample == 400) {
      tb_split = cbp.u = cbp.v = 0;
      cbp.y = get_flc(1,stream);
      if (decoder_info->tb_split_enable && cbp.y) {
        tb_split = get_flc(1,stream);
        cbp.y &= !tb_split;
      }
    } else {
      bit_start = stream->bitcnt;
      code = get_vlc(0,stream);
      int off = (mode == MODE_MERGE) ? 1 : 2;
      if (decoder_info->tb_split_enable) {
        tb_split = code == off;
        if (code > off) code -= 1;
        if (tb_split)
          decoder_info->bit_count.cbp2_stat[0][stat_frame_type][mode-1][log2i(size)-3][8] += 1;
      }
      else{
        tb_split = 0;
      }
    }
    block_info->block_param.tb_split = tb_split;
    decoder_info->bit_count.cbp[stat_frame_type] += (stream->bitcnt - bit_start);

    if (tb_split == 0){
      if (decoder_info->subsample != 400) {
        tmp = 0;
        if (mode==MODE_MERGE){
          if (code==7)
            code = 1;
          else if (code>0)
            code = code+1;
        }
        else {
          if (decoder_info->block_context->cbp == 0 && code < 2) {
            code = 1 - code;
          }
        }
        while (tmp < 8 && code != cbp_table[tmp]) tmp++;
        decoder_info->bit_count.cbp2_stat[max(0,decoder_info->block_context->cbp)][stat_frame_type][mode-1][log2i(size)-3][tmp] += 1;

        cbp.y = ((tmp>>0)&1);
        cbp.u = ((tmp>>1)&1);
        cbp.v = ((tmp>>2)&1);
      }
      block_info->cbp = cbp;

      if (cbp.y){
        bit_start = stream->bitcnt;
        read_coeff(stream,coeff_y,sizeY,coeff_block_type|0);
        decoder_info->bit_count.coeff_y[stat_frame_type] += (stream->bitcnt - bit_start);
      }
      else
        memset(coeff_y,0,sizeY*sizeY*sizeof(int16_t));

      if (cbp.u){
        bit_start = stream->bitcnt;
        read_coeff(stream,coeff_u,sizeC,coeff_block_type|1);
        decoder_info->bit_count.coeff_u[stat_frame_type] += (stream->bitcnt - bit_start);
      }
      else
        memset(coeff_u,0,sizeC*sizeC*sizeof(int16_t));

      if (cbp.v){
        bit_start = stream->bitcnt;
        read_coeff(stream,coeff_v,sizeC,coeff_block_type|1);
        decoder_info->bit_count.coeff_v[stat_frame_type] += (stream->bitcnt - bit_start);
      }
      else
        memset(coeff_v,0,sizeC*sizeC*sizeof(int16_t));
    }
    else{
      if (sizeC > 4){
        int index;
        int16_t *coeff;

        /* Loop over 4 TUs */
        for (index=0;index<4;index++){
          bit_start = stream->bitcnt;
          code = get_vlc(0,stream);
          int tmp = 0;
          while (code != cbp_table[tmp] && tmp < 8) tmp++;
          if (decoder_info->block_context->cbp==0 && tmp < 2)
            tmp = 1-tmp;
          cbp.y = ((tmp>>0)&1);
          cbp.u = ((tmp>>1)&1);
          cbp.v = ((tmp>>2)&1);

          /* Updating statistics for CBP */
          decoder_info->bit_count.cbp[stat_frame_type] += (stream->bitcnt - bit_start);
          decoder_info->bit_count.cbp_stat[stat_frame_type][cbp.y + (cbp.u<<1) + (cbp.v<<2)] += 1;

          /* Decode coefficients for this TU */

          /* Y */
          coeff = coeff_y + index*sizeY/2*sizeY/2;
          if (cbp.y){
            bit_start = stream->bitcnt;
            read_coeff(stream,coeff,sizeY/2,coeff_block_type|0);
            decoder_info->bit_count.coeff_y[stat_frame_type] += (stream->bitcnt - bit_start);
          }
          else{
            memset(coeff,0,sizeY/2*sizeY/2*sizeof(int16_t));
          }

          /* U */
          coeff = coeff_u + index*sizeC/2*sizeC/2;
          if (cbp.u){
            bit_start = stream->bitcnt;
            read_coeff(stream,coeff,sizeC/2,coeff_block_type|1);
            decoder_info->bit_count.coeff_u[stat_frame_type] += (stream->bitcnt - bit_start);
          }
          else{
            memset(coeff,0,sizeC/2*sizeC/2*sizeof(int16_t));
          }

          /* V */
          coeff = coeff_v + index*sizeC/2*sizeC/2;
          if (cbp.v){
            bit_start = stream->bitcnt;
            read_coeff(stream,coeff,sizeC/2,coeff_block_type|1);
            decoder_info->bit_count.coeff_v[stat_frame_type] += (stream->bitcnt - bit_start);
          }
          else{
            memset(coeff,0,sizeC/2*sizeC/2*sizeof(int16_t));
          }
        }
        block_info->cbp.y = 1; //TODO: Do properly with respect to deblocking filter
        block_info->cbp.u = 1;
        block_info->cbp.v = 1;
      }
      else{
        int index;
        int16_t *coeff;

        /* Loop over 4 TUs */
        for (index=0;index<4;index++){
          bit_start = stream->bitcnt;
          cbp.y = get_flc(1, stream);
          decoder_info->bit_count.cbp[stat_frame_type] += (stream->bitcnt - bit_start);

          /* Y */
          coeff = coeff_y + index*sizeY/2*sizeY/2;
          if (cbp.y){
            bit_start = stream->bitcnt;
            read_coeff(stream,coeff,sizeY/2,coeff_block_type|0);
            decoder_info->bit_count.coeff_y[stat_frame_type] += (stream->bitcnt - bit_start);
          }
          else{
            memset(coeff,0,sizeY/2*sizeY/2*sizeof(int16_t));
          }
        }

        bit_start = stream->bitcnt;
        if (decoder_info->subsample != 400) {
          int tmp;
          tmp = get_vlc(13, stream);
          cbp.u = tmp & 1;
          cbp.v = (tmp >> 1) & 1;
        } else
          cbp.u = cbp.v = 0;
        decoder_info->bit_count.cbp[stat_frame_type] += (stream->bitcnt - bit_start);
        if (cbp.u){
          bit_start = stream->bitcnt;
          read_coeff(stream,coeff_u,sizeC,coeff_block_type|1);
          decoder_info->bit_count.coeff_u[stat_frame_type] += (stream->bitcnt - bit_start);
        }
        else
          memset(coeff_u,0,sizeC*sizeC*sizeof(int16_t));
        if (cbp.v){
          bit_start = stream->bitcnt;
          read_coeff(stream,coeff_v,sizeC,coeff_block_type|1);
          decoder_info->bit_count.coeff_v[stat_frame_type] += (stream->bitcnt - bit_start);
        }
        else
          memset(coeff_v,0,sizeC*sizeC*sizeof(int16_t));

        block_info->cbp.y = 1; //TODO: Do properly with respect to deblocking filter
        block_info->cbp.u = 1;
        block_info->cbp.v = 1;
      } //if (size==8)
    } //if (tb_split==0)
  } //if (mode!=MODE_SKIP)
  else{
    tb_split = 0;
    block_info->cbp.y = 0;
    block_info->cbp.u = 0;
    block_info->cbp.v = 0;
  }

  /* Store block data */
  if (mode==MODE_BIPRED){
    memcpy(block_info->block_param.mv_arr0,mv_arr0,4*sizeof(mv_t)); //Used for mv0 coding
    memcpy(block_info->block_param.mv_arr1,mv_arr1,4*sizeof(mv_t)); //Used for mv1 coding
  }
  else if(mode==MODE_SKIP){
    memcpy(block_info->block_param.mv_arr0,mv_arr0,4*sizeof(mv_t)); //Used for mv0 coding
    memcpy(block_info->block_param.mv_arr1,mv_arr1,4*sizeof(mv_t)); //Used for mv1 coding
  }
  else if(mode==MODE_MERGE){
    memcpy(block_info->block_param.mv_arr0,mv_arr0,4*sizeof(mv_t)); //Used for mv0 coding
    memcpy(block_info->block_param.mv_arr1,mv_arr1,4*sizeof(mv_t)); //Used for mv1 coding
  }
  else{
    memcpy(block_info->block_param.mv_arr0,mv_arr,4*sizeof(mv_t)); //Used for mv0 coding
    memcpy(block_info->block_param.mv_arr1,mv_arr,4*sizeof(mv_t)); //Used for mv1 coding
  }
  block_info->block_param.mode = mode;
  block_info->block_param.tb_split = tb_split;

  int bwidth = min(size,width - xpos);
  int bheight = min(size,height - ypos);

  /* Update mode and block size statistics */
  decoder_info->bit_count.mode[stat_frame_type][mode] += (bwidth/MIN_BLOCK_SIZE * bheight/MIN_BLOCK_SIZE);
  decoder_info->bit_count.size[stat_frame_type][log2i(size)-3] += (bwidth/MIN_BLOCK_SIZE * bheight/MIN_BLOCK_SIZE);
  decoder_info->bit_count.size_and_mode[stat_frame_type][log2i(size)-3][mode] += (bwidth/MIN_BLOCK_SIZE * bheight/MIN_BLOCK_SIZE);
  return 0;
}

static int decode_super_mode(decoder_info_t *decoder_info, int size, int decode_this_size){
  stream_t *stream = decoder_info->stream;
  block_context_t *block_context = decoder_info->block_context;

  frame_type_t frame_type = decoder_info->frame_info.frame_type;
  int split_flag = 0;
  int mode = MODE_SKIP;
  int stat_mode = STAT_SKIP;
  int num_ref=0,code,maxbit;
  int idx = log2i(size)-3;

  decoder_info->mode = MODE_SKIP; //Default initial value

  if (frame_type==I_FRAME){
    decoder_info->mode = MODE_INTRA;
    if (size > MIN_BLOCK_SIZE && decode_this_size)
      split_flag = get_flc(1, stream);
    else
      split_flag = !decode_this_size;
    return split_flag;
  }

  if (!decode_this_size) {
    split_flag = !get_flc(1, stream);
    return split_flag;
  }

  if (size > MAX_TR_SIZE) {
    split_flag = !get_flc(1, stream);
    if (!split_flag)  decoder_info->mode = MODE_SKIP;
    return split_flag;
  }


  num_ref = decoder_info->frame_info.num_ref;
  int bipred_possible_flag = num_ref > 1 && decoder_info->bipred;
  int split_possible_flag = size > MIN_BLOCK_SIZE;
  maxbit = 2 + num_ref + split_possible_flag + bipred_possible_flag;

  int interp_ref = decoder_info->frame_info.interp_ref;

  if (interp_ref > 2) {
    maxbit -= 1; //ref_idx = 0 is disallowed
  }

  code = get_vlc(10 + maxbit, stream);

  if (interp_ref) {

    if ((block_context->index == 2 || block_context->index>3) && size>MIN_BLOCK_SIZE){
      /* Move skip down the list */
      if (code<3)
        code = (code + 1) % 3;
    }

    if (split_possible_flag && code==1) {
      /* Set split flag and return */
      split_flag = 1;
      decoder_info->bit_count.super_mode_stat[decoder_info->bit_count.stat_frame_type][idx][STAT_SPLIT] += 1;
      return split_flag;
    }

    if (!split_possible_flag && code > 0) {
      /* Didn't need a codeword for split so adjust for the empty slot */
      code += 1;
    }

    if (!bipred_possible_flag && code >= 3) {
      /* Don't need a codeword for bipred so adjust for the empty slot */
      code += 1;
    }

    if (code == 0) {
      mode = MODE_SKIP;
      stat_mode = STAT_SKIP;
    } else if (code == 2) {
      mode = MODE_MERGE;
      stat_mode = STAT_MERGE;
    } else if (code == 3) {
      mode = MODE_BIPRED;
      stat_mode = STAT_BIPRED;
    } else if (code == 4) {
      mode = MODE_INTRA;
      stat_mode = STAT_INTRA;
    } else if (code == 4 + num_ref) {
      mode = MODE_INTER;
      decoder_info->ref_idx = 0;
      stat_mode = STAT_REF_IDX0;
    }
    else{
      mode = MODE_INTER;
      decoder_info->ref_idx = code - 4;
      stat_mode = STAT_REF_IDX1 + decoder_info->ref_idx-1;
    }
    decoder_info->mode = mode;


  } else {
    if ((block_context->index == 2 || block_context->index>3) && size>MIN_BLOCK_SIZE){
      /* Skip is less likely than split, merge and inter-ref_idx=0 so move skip down the list */
      if (code<4)
        code = (code + 1) % 4;
    }

    if (split_possible_flag && code==1) {
      /* Set split flag and return */
      split_flag = 1;
      decoder_info->bit_count.super_mode_stat[decoder_info->bit_count.stat_frame_type][idx][STAT_SPLIT] += 1;
      return split_flag;
    }

    if (!split_possible_flag && code > 0) {
      /* Didn't need a codeword for split so adjust for the empty slot */
      code += 1;
    }

    if (!bipred_possible_flag && code >= 4) {
      /* Don't need a codeword for bipred so adjust for the empty slot */
      code += 1;
    }

    if (code == 0) {
      mode = MODE_SKIP;
      stat_mode = STAT_SKIP;
    }
    else if (code == 2) {
      mode = MODE_INTER;
      decoder_info->ref_idx = 0;
      stat_mode = STAT_REF_IDX0;
    }
    else if (code == 3) {
      mode = MODE_MERGE;
      stat_mode = STAT_MERGE;
    }
    else if (code == 4) {
      mode = MODE_BIPRED;
      stat_mode = STAT_BIPRED;
    }
    else if (code == 5) {
      mode = MODE_INTRA;
      stat_mode = STAT_INTRA;
    }
    else{
      mode = MODE_INTER;
      decoder_info->ref_idx = code - 5;
      stat_mode = STAT_REF_IDX1 + decoder_info->ref_idx - 1;
    }
    decoder_info->mode = mode;

  }
  decoder_info->bit_count.super_mode_stat[decoder_info->bit_count.stat_frame_type][idx][stat_mode] += 1;

  return split_flag;
}

static void decode_block(decoder_info_t *decoder_info,int size,int ypos,int xpos,int sub){

  int width = decoder_info->width;
  int height = decoder_info->height;
  int xposY = xpos;
  int yposY = ypos;
  int xposC = xpos >> sub;
  int yposC = ypos >> sub;
  int sizeY = size;
  int sizeC = size >> sub;

  block_mode_t mode;
  intra_mode_t intra_mode;

  frame_type_t frame_type = decoder_info->frame_info.frame_type;
  int bipred = decoder_info->bipred;

  int qpY = decoder_info->frame_info.qpb;
  int qpC = sub ? chroma_qp[qpY] : qpY;

  /* Intermediate block variables */
  SAMPLE *pblock_y = thor_alloc(MAX_SB_SIZE*MAX_SB_SIZE*sizeof(SAMPLE), 32);
  SAMPLE *pblock_u = thor_alloc((MAX_SB_SIZE*MAX_SB_SIZE >> 2*sub)*sizeof(SAMPLE), 32);
  SAMPLE *pblock_v = thor_alloc((MAX_SB_SIZE*MAX_SB_SIZE >> 2*sub)*sizeof(SAMPLE), 32);
  int16_t *coeff_y = thor_alloc(2*MAX_TR_SIZE*MAX_TR_SIZE, 32);
  int16_t *coeff_u = thor_alloc(2*MAX_TR_SIZE*MAX_TR_SIZE, 32);
  int16_t *coeff_v = thor_alloc(2*MAX_TR_SIZE*MAX_TR_SIZE, 32);

  /* Block variables for bipred */
  SAMPLE *pblock0_y = thor_alloc(MAX_SB_SIZE*MAX_SB_SIZE*sizeof(SAMPLE), 32);
  SAMPLE *pblock0_u = thor_alloc((MAX_SB_SIZE*MAX_SB_SIZE >> 2*sub)*sizeof(SAMPLE), 32);
  SAMPLE *pblock0_v = thor_alloc((MAX_SB_SIZE*MAX_SB_SIZE >> 2*sub)*sizeof(SAMPLE), 32);
  SAMPLE *pblock1_y = thor_alloc(MAX_SB_SIZE*MAX_SB_SIZE*sizeof(SAMPLE), 32);
  SAMPLE *pblock1_u = thor_alloc((MAX_SB_SIZE*MAX_SB_SIZE >> 2*sub)*sizeof(SAMPLE), 32);
  SAMPLE *pblock1_v = thor_alloc((MAX_SB_SIZE*MAX_SB_SIZE >> 2*sub)*sizeof(SAMPLE), 32);
  yuv_frame_t *rec = decoder_info->rec;
  yuv_frame_t *ref = decoder_info->ref[0];


  /* Pointers to current position in reconstructed frame*/
  SAMPLE *rec_y = &rec->y[yposY*rec->stride_y+xposY];
  SAMPLE *rec_u = &rec->u[yposC*rec->stride_c+xposC];
  SAMPLE *rec_v = &rec->v[yposC*rec->stride_c+xposC];

  stream_t *stream = decoder_info->stream;

  /* Read data from bitstream */
  block_info_dec_t block_info;
  block_info.block_pos.size = size;
  block_info.block_pos.ypos = ypos;
  block_info.block_pos.xpos = xpos;
  block_info.coeffq_y = coeff_y;
  block_info.coeffq_u = coeff_u;
  block_info.coeffq_v = coeff_v;
  block_info.sub = sub;

  /* Used for rectangular skip blocks */
  int bwidth = min(size,width - xpos);
  int bheight = min(size,height - ypos);
  block_info.block_pos.bwidth = bwidth;
  block_info.block_pos.bheight = bheight;

  read_block(decoder_info,stream,&block_info,frame_type);
  mode = block_info.block_param.mode;

  if (mode == MODE_INTRA){
    int ql = decoder_info->qmtx ? qp_to_qlevel(qpY,decoder_info->qmtx_offset) : 0;
    intra_mode = block_info.block_param.intra_mode;
    int bwidth = size; //TODO: fix for non-square blocks
    int bheight = size; //TODO: fix for non-square blocks
    int upright_available = get_upright_available(yposY, xposY, bwidth, bheight, width, height, 1 << decoder_info->log2_sb_size);
    int downleft_available = get_downleft_available(yposY, xposY, bwidth, bheight, width, height, 1 << decoder_info->log2_sb_size);

    int tb_split = block_info.block_param.tb_split;
    decode_and_reconstruct_block_intra(rec_y,rec->stride_y,sizeY,qpY,pblock_y,coeff_y,tb_split,upright_available,downleft_available,intra_mode,yposY,xposY,width,0,decoder_info->bitdepth,decoder_info->qmtx ? decoder_info->iwmatrix[ql][0][1] : NULL);
    if (decoder_info->subsample != 400)
      decode_and_reconstruct_block_intra_uv(rec_u,rec_v,rec->stride_c,sizeC,qpC,pblock_u,pblock_v,coeff_u,coeff_v,tb_split && sizeC > 4,upright_available,downleft_available,intra_mode,yposC,xposC,width>>sub,1,decoder_info->bitdepth,decoder_info->qmtx ? decoder_info->iwmatrix[ql][1][1] : NULL, decoder_info->cfl_intra ? pblock_y : 0, rec_y, rec->stride_y, sub);
  }
  else
  {
    int tb_split = block_info.block_param.tb_split;
    if (mode==MODE_SKIP){
      if (block_info.block_param.dir==2){
        SAMPLE *pblock0_y = thor_alloc(MAX_SB_SIZE*MAX_SB_SIZE*sizeof(SAMPLE), 32);
        SAMPLE *pblock0_u = thor_alloc((MAX_SB_SIZE*MAX_SB_SIZE >> 2*sub)*sizeof(SAMPLE), 32);
        SAMPLE *pblock0_v = thor_alloc((MAX_SB_SIZE*MAX_SB_SIZE >> 2*sub)*sizeof(SAMPLE), 32);
        SAMPLE *pblock1_y = thor_alloc(MAX_SB_SIZE*MAX_SB_SIZE*sizeof(SAMPLE), 32);
        SAMPLE *pblock1_u = thor_alloc((MAX_SB_SIZE*MAX_SB_SIZE >> 2*sub)*sizeof(SAMPLE), 32);
        SAMPLE *pblock1_v = thor_alloc((MAX_SB_SIZE*MAX_SB_SIZE >> 2*sub)*sizeof(SAMPLE), 32);

        int r0 = decoder_info->frame_info.ref_array[block_info.block_param.ref_idx0];
        yuv_frame_t *ref0 = r0 >= 0 ? decoder_info->ref[r0] : decoder_info->interp_frames[0];
        int sign0 = ref0->frame_num >= rec->frame_num;
        int r1 = decoder_info->frame_info.ref_array[block_info.block_param.ref_idx1];
        yuv_frame_t *ref1 = r1 >= 0 ? decoder_info->ref[r1] : decoder_info->interp_frames[0];
        int sign1 = ref1->frame_num >= rec->frame_num;
        if (decoder_info->bit_count.stat_frame_type == B_FRAME && decoder_info->interp_ref == 2 && block_info.block_param.skip_idx==0) {
          TEMPLATE(get_inter_prediction_temp)(width, height, ref0, ref1, &block_info.block_pos, decoder_info->deblock_data, decoder_info->num_reorder_pics + 1, decoder_info->frame_info.phase, pblock_y, pblock_u, pblock_v);
        }
        else {
          TEMPLATE(get_inter_prediction_yuv)(ref0, pblock0_y, pblock0_u, pblock0_v, &block_info.block_pos, block_info.block_param.mv_arr0, sign0, width, height, bipred, 0, decoder_info->bitdepth);
          TEMPLATE(get_inter_prediction_yuv)(ref1, pblock1_y, pblock1_u, pblock1_v, &block_info.block_pos, block_info.block_param.mv_arr1, sign1, width, height, bipred, 0, decoder_info->bitdepth);
          TEMPLATE(average_blocks_all)(pblock_y, pblock_u, pblock_v, pblock0_y, pblock0_u, pblock0_v, pblock1_y, pblock1_u, pblock1_v, &block_info.block_pos, sub);
        }
        thor_free(pblock0_y);
        thor_free(pblock0_u);
        thor_free(pblock0_v);
        thor_free(pblock1_y);
        thor_free(pblock1_u);
        thor_free(pblock1_v);
      }
      else{
        int ref_idx = block_info.block_param.ref_idx0; //TODO: Move to top
        int r = decoder_info->frame_info.ref_array[ref_idx];
        ref = r>=0 ? decoder_info->ref[r] : decoder_info->interp_frames[0];
        int sign = ref->frame_num > rec->frame_num;

        TEMPLATE(get_inter_prediction_yuv)(ref, pblock_y, pblock_u, pblock_v, &block_info.block_pos, block_info.block_param.mv_arr0, sign, width, height, bipred, 0, decoder_info->bitdepth);
      }
      int j;
      for (j = 0; j<bheight; j++) {
        memcpy(&rec_y[j*rec->stride_y], &pblock_y[j*sizeY], bwidth*sizeof(SAMPLE));
      }
      for (j = 0; j<bheight >> sub; j++) {
        memcpy(&rec_u[j*rec->stride_c], &pblock_u[j*sizeC], (bwidth >> sub)*sizeof(SAMPLE));
        memcpy(&rec_v[j*rec->stride_c], &pblock_v[j*sizeC], (bwidth >> sub)*sizeof(SAMPLE));
      }
      copy_deblock_data(decoder_info, &block_info);
      return;
    }
    else if (mode==MODE_MERGE){
      if (block_info.block_param.dir==2){

        SAMPLE *pblock0_y = thor_alloc(MAX_SB_SIZE*MAX_SB_SIZE*sizeof(SAMPLE), 32);
        SAMPLE *pblock0_u = thor_alloc((MAX_SB_SIZE*MAX_SB_SIZE >> 2*sub)*sizeof(SAMPLE), 32);
        SAMPLE *pblock0_v = thor_alloc((MAX_SB_SIZE*MAX_SB_SIZE >> 2*sub)*sizeof(SAMPLE), 32);
        SAMPLE *pblock1_y = thor_alloc(MAX_SB_SIZE*MAX_SB_SIZE*sizeof(SAMPLE), 32);
        SAMPLE *pblock1_u = thor_alloc((MAX_SB_SIZE*MAX_SB_SIZE >> 2*sub)*sizeof(SAMPLE), 32);
        SAMPLE *pblock1_v = thor_alloc((MAX_SB_SIZE*MAX_SB_SIZE >> 2*sub)*sizeof(SAMPLE), 32);

        int r0 = decoder_info->frame_info.ref_array[block_info.block_param.ref_idx0];
        yuv_frame_t *ref0 = r0 >= 0 ? decoder_info->ref[r0] : decoder_info->interp_frames[0];
        int sign0 = ref0->frame_num >= rec->frame_num;
        TEMPLATE(get_inter_prediction_yuv)(ref0, pblock0_y, pblock0_u, pblock0_v, &block_info.block_pos, block_info.block_param.mv_arr0, sign0, width, height, bipred, 0, decoder_info->bitdepth);

        int r1 = decoder_info->frame_info.ref_array[block_info.block_param.ref_idx1];
        yuv_frame_t *ref1 = r1 >= 0 ? decoder_info->ref[r1] : decoder_info->interp_frames[0];
        int sign1 = ref1->frame_num >= rec->frame_num;
        TEMPLATE(get_inter_prediction_yuv)(ref1, pblock1_y, pblock1_u, pblock1_v, &block_info.block_pos, block_info.block_param.mv_arr1, sign1, width, height, bipred, 0, decoder_info->bitdepth);

        TEMPLATE(average_blocks_all)(pblock_y, pblock_u, pblock_v, pblock0_y, pblock0_u, pblock0_v, pblock1_y, pblock1_u, pblock1_v, &block_info.block_pos, sub);

        thor_free(pblock0_y);
        thor_free(pblock0_u);
        thor_free(pblock0_v);
        thor_free(pblock1_y);
        thor_free(pblock1_u);
        thor_free(pblock1_v);
      }
      else{
        int ref_idx = block_info.block_param.ref_idx0; //TODO: Move to top
        int r = decoder_info->frame_info.ref_array[ref_idx];
        ref = r>=0 ? decoder_info->ref[r] : decoder_info->interp_frames[0];
        int sign = ref->frame_num > rec->frame_num;
        TEMPLATE(get_inter_prediction_yuv)(ref, pblock_y, pblock_u, pblock_v, &block_info.block_pos, block_info.block_param.mv_arr0, sign, width, height, bipred, 0, decoder_info->bitdepth);
      }
    }
    else if (mode == MODE_INTER){
      int ref_idx = block_info.block_param.ref_idx0;
      int r = decoder_info->frame_info.ref_array[ref_idx];
      ref = r>=0 ? decoder_info->ref[r] : decoder_info->interp_frames[0];
      int sign = ref->frame_num > rec->frame_num;
      TEMPLATE(get_inter_prediction_yuv)(ref, pblock_y, pblock_u, pblock_v, &block_info.block_pos, block_info.block_param.mv_arr0, sign, width, height, bipred, decoder_info->pb_split, decoder_info->bitdepth);
    }
    else if (mode == MODE_BIPRED){

      SAMPLE *pblock0_y = thor_alloc(MAX_SB_SIZE*MAX_SB_SIZE*sizeof(SAMPLE), 32);
      SAMPLE *pblock0_u = thor_alloc((MAX_SB_SIZE*MAX_SB_SIZE >> 2*sub)*sizeof(SAMPLE), 32);
      SAMPLE *pblock0_v = thor_alloc((MAX_SB_SIZE*MAX_SB_SIZE >> 2*sub)*sizeof(SAMPLE), 32);
      SAMPLE *pblock1_y = thor_alloc(MAX_SB_SIZE*MAX_SB_SIZE*sizeof(SAMPLE), 32);
      SAMPLE *pblock1_u = thor_alloc((MAX_SB_SIZE*MAX_SB_SIZE >> 2*sub)*sizeof(SAMPLE), 32);
      SAMPLE *pblock1_v = thor_alloc((MAX_SB_SIZE*MAX_SB_SIZE >> 2*sub)*sizeof(SAMPLE), 32);

      int r0 = decoder_info->frame_info.ref_array[block_info.block_param.ref_idx0];
      yuv_frame_t *ref0 = r0 >= 0 ? decoder_info->ref[r0] : decoder_info->interp_frames[0];
      int sign0 = ref0->frame_num >= rec->frame_num;
      TEMPLATE(get_inter_prediction_yuv)(ref0, pblock0_y, pblock0_u, pblock0_v, &block_info.block_pos, block_info.block_param.mv_arr0, sign0, width, height, bipred, decoder_info->pb_split, decoder_info->bitdepth);

      int r1 = decoder_info->frame_info.ref_array[block_info.block_param.ref_idx1];
      yuv_frame_t *ref1 = r1 >= 0 ? decoder_info->ref[r1] : decoder_info->interp_frames[0];
      int sign1 = ref1->frame_num >= rec->frame_num;
      TEMPLATE(get_inter_prediction_yuv)(ref1, pblock1_y, pblock1_u, pblock1_v, &block_info.block_pos, block_info.block_param.mv_arr1, sign1, width, height, bipred, decoder_info->pb_split, decoder_info->bitdepth);

      TEMPLATE(average_blocks_all)(pblock_y, pblock_u, pblock_v, pblock0_y, pblock0_u, pblock0_v, pblock1_y, pblock1_u, pblock1_v, &block_info.block_pos, sub);

      thor_free(pblock0_y);
      thor_free(pblock0_u);
      thor_free(pblock0_v);
      thor_free(pblock1_y);
      thor_free(pblock1_u);
      thor_free(pblock1_v);
    }

    /* Dequantize, invere tranform and reconstruct */
    int ql = decoder_info->qmtx ? qp_to_qlevel(qpY,decoder_info->qmtx_offset) : 0;
    decode_and_reconstruct_block_inter(rec_y,rec->stride_y,sizeY,qpY,pblock_y,coeff_y,tb_split,decoder_info->bitdepth,decoder_info->qmtx ? decoder_info->iwmatrix[ql][0][0] : NULL);
    if (decoder_info->cfl_inter && decoder_info->subsample != 400)
      TEMPLATE(improve_uv_prediction)(pblock_y, pblock_u, pblock_v, rec_y, sizeY, sizeY, rec->stride_y, sub, decoder_info->bitdepth);
    decode_and_reconstruct_block_inter(rec_u,rec->stride_c,sizeC,qpC,pblock_u,coeff_u,tb_split&&sizeC>4,decoder_info->bitdepth,decoder_info->qmtx ? decoder_info->iwmatrix[ql][1][0] : NULL);
    decode_and_reconstruct_block_inter(rec_v,rec->stride_c,sizeC,qpC,pblock_v,coeff_v,tb_split&&sizeC>4,decoder_info->bitdepth,decoder_info->qmtx ? decoder_info->iwmatrix[ql][2][0] : NULL);
  }

  /* Copy deblock data to frame array */
  copy_deblock_data(decoder_info,&block_info);

  thor_free(pblock0_y);
  thor_free(pblock0_u);
  thor_free(pblock0_v);
  thor_free(pblock1_y);
  thor_free(pblock1_u);
  thor_free(pblock1_v);
  thor_free(pblock_y);
  thor_free(pblock_u);
  thor_free(pblock_v);
  thor_free(coeff_y);
  thor_free(coeff_u);
  thor_free(coeff_v);
}

void read_coeff(stream_t *stream,int16_t *coeff,int size,int type){

  int16_t scoeff[MAX_QUANT_SIZE*MAX_QUANT_SIZE];
  int i,j,levelFlag,sign,level,pos,run,tmp,code;
  int qsize = min(size,MAX_QUANT_SIZE);
  int N = qsize*qsize;
  int level_mode;
  int chroma_flag = type&1;
  int intra_flag = (type>>1)&1;
  int vlc_adaptive = intra_flag && !chroma_flag;

  /* Initialize arrays */
  memset(scoeff,0,N*sizeof(int16_t));
  memset(coeff,0,size*size*sizeof(int16_t));

  pos = 0;
  /* Use one bit to signal chroma/last_pos=1/level=1 */
  if (chroma_flag==1){
    int tmp = get_flc(1, stream);
    if (tmp){
      sign = get_flc(1, stream);
      scoeff[pos] = sign ? -1 : 1;
      pos = N;
    }
  }

  /* Initiate forward scan */
  level_mode = 1;
  level = 1;
  while (pos < N){
    if (level_mode){
      /* Level-mode */
      while (pos < N && level > 0){
        level = get_vlc(vlc_adaptive,stream);
        if (level){
          sign = get_flc(1, stream);
        }
        else{
          sign = 1;
        }
        scoeff[pos] = sign ? -level : level;
        if (chroma_flag==0)
          vlc_adaptive = level > 3;
        pos++;
      }
    }
    if (pos >= N){
      break;
    }

    /* Run-mode */
    int eob;
    int eob_pos = chroma_flag ? 0 : 2;
    if (chroma_flag && size <= 8)
      code = get_vlc(10, stream);
    else
      code = get_vlc(6, stream);

    eob = code == eob_pos;
    if (eob) {
      break;
    }
    if (code > eob_pos) code -= 1;
    levelFlag = (code % 5) == 4;
    if (levelFlag)
      run = code / 5;
    else
      run = 4*(code/5) + code % 5;
    pos += run;

    /* Decode level and sign */
    if (levelFlag){
      tmp = get_vlc(0,stream);
      sign = tmp&1;
      level = (tmp>>1)+2;
    }
    else{
      level = 1;
      sign = get_flc(1, stream);
    }
    scoeff[pos] = sign ? -level : level;

    level_mode = level > 1; //Set level_mode
    pos++;
  } //while pos < N

  /* Perform inverse zigzag scan */
  int *zigzagptr = zigzag64;
  if (qsize==4)
    zigzagptr = zigzag16;
  else if (qsize==8)
    zigzagptr = zigzag64;
  else if (qsize==16)
    zigzagptr = zigzag256;
  for (i=0;i<qsize;i++){
    for (j=0;j<qsize;j++){
      coeff[i*qsize + j] = scoeff[zigzagptr[i*qsize + j]];
    }
  }
}
