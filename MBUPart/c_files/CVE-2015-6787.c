static void CheckCcScrollNode(const ScrollPaintPropertyNode& blink_scroll,
                              const cc::ScrollNode& cc_scroll) {
  EXPECT_EQ(static_cast<gfx::Size>(blink_scroll.ContainerRect().Size()),
            cc_scroll.container_bounds);
  EXPECT_EQ(static_cast<gfx::Size>(blink_scroll.ContentsRect().Size()),
            cc_scroll.bounds);
  EXPECT_EQ(blink_scroll.UserScrollableHorizontal(),
            cc_scroll.user_scrollable_horizontal);
  EXPECT_EQ(blink_scroll.UserScrollableVertical(),
            cc_scroll.user_scrollable_vertical);
  EXPECT_EQ(blink_scroll.GetCompositorElementId(), cc_scroll.element_id);
  EXPECT_EQ(blink_scroll.GetMainThreadScrollingReasons(),
            cc_scroll.main_thread_scrolling_reasons);
}

void BlockPainter::PaintCarets(const PaintInfo& paint_info,
                               const LayoutPoint& paint_offset) {
  LocalFrame* frame = layout_block_.GetFrame();

  if (layout_block_.ShouldPaintCursorCaret())
    frame->Selection().PaintCaret(paint_info.context, paint_offset);

  if (layout_block_.ShouldPaintDragCaret()) {
    frame->GetPage()->GetDragCaret().PaintDragCaret(frame, paint_info.context,
                                                    paint_offset);
  }
}

void PaintController::BeginFrame(const void* frame) {
  frame_first_paints_.push_back(FrameFirstPaint(frame));
}

SkBlendMode PropertyTreeManager::SynthesizeCcEffectsForClipsIfNeeded(
    const ClipPaintPropertyNode* target_clip,
    SkBlendMode delegated_blend,
    bool effect_is_newly_built) {
  if (delegated_blend != SkBlendMode::kSrcOver) {
    while (IsCurrentCcEffectSynthetic())
      CloseCcEffect();

    GetEffectTree().Node(current_effect_id_)->has_render_surface = true;
  } else {
    const auto& lca = LowestCommonAncestor(*current_clip_, *target_clip);
    while (current_clip_ != &lca) {
      DCHECK(IsCurrentCcEffectSynthetic());
      const auto* pre_exit_clip = current_clip_;
      CloseCcEffect();
      if (IsNodeOnAncestorChain(lca, *pre_exit_clip, *current_clip_))
        break;
    }

    if (!effect_is_newly_built && !IsCurrentCcEffectSynthetic() &&
        current_effect_->Opacity() != 1.f)
      GetEffectTree().Node(current_effect_id_)->has_render_surface = true;
  }

  DCHECK(current_clip_->IsAncestorOf(*target_clip));

  Vector<const ClipPaintPropertyNode*> pending_clips;
  for (; target_clip != current_clip_; target_clip = target_clip->Parent()) {
    DCHECK(target_clip);
    bool should_synthesize =
        target_clip->ClipRect().IsRounded() || target_clip->ClipPath();
    if (should_synthesize)
      pending_clips.push_back(target_clip);
  }

  for (size_t i = pending_clips.size(); i--;) {
    const ClipPaintPropertyNode* next_clip = pending_clips[i];

    cc::EffectNode& mask_isolation = *GetEffectTree().Node(
        GetEffectTree().Insert(cc::EffectNode(), current_effect_id_));
    mask_isolation.clip_id = EnsureCompositorClipNode(next_clip);
    mask_isolation.has_render_surface = true;
    DCHECK(delegated_blend != SkBlendMode::kDstIn);
    mask_isolation.blend_mode = delegated_blend;
    delegated_blend = SkBlendMode::kSrcOver;

    effect_stack_.emplace_back(
        EffectStackEntry{current_effect_id_, current_effect_type_,
                         current_effect_, current_clip_});
    current_effect_id_ = mask_isolation.id;
    current_effect_type_ = CcEffectType::kSynthesizedClip;
    current_clip_ = next_clip;
  }

  return delegated_blend;
}

  int ElementIdToEffectNodeIndex(CompositorElementId element_id) {
    return web_layer_tree_view_->GetLayerTreeHost()
        ->property_trees()
        ->element_id_to_effect_node_index[element_id];
  }

void FragmentPaintPropertyTreeBuilder::UpdateScrollAndScrollTranslation() {
DCHECK(properties_);

if (NeedsPaintPropertyUpdate()) {
if (NeedsScrollNode(object_)) {
const LayoutBox& box = ToLayoutBox(object_);
auto* scrollable_area = box.GetScrollableArea();
ScrollPaintPropertyNode::State state;

// The container bounds are snapped to integers to match the equivalent
// bounds on cc::ScrollNode. The offset is snapped to match the current
// integer offsets used in CompositedLayerMapping.
state.container_rect = PixelSnappedIntRect(
box.OverflowClipRect(context_.current.paint_offset));
state.contents_rect = IntRect(
-scrollable_area->ScrollOrigin() + state.container_rect.Location(),
scrollable_area->ContentsSize());
// In flipped blocks writing mode, if there is scrollbar on the right,
// we move the contents to the left with extra amount of ScrollTranslation
// (-VerticalScrollbarWidth, 0). As contents_rect is in the space of
// ScrollTranslation, we need to compensate the extra ScrollTranslation
// to get correct contents_rect origin.
if (box.HasFlippedBlocksWritingMode())
state.contents_rect.Move(box.VerticalScrollbarWidth(), 0);

state.user_scrollable_horizontal =
scrollable_area->UserInputScrollable(kHorizontalScrollbar);
state.user_scrollable_vertical =
scrollable_area->UserInputScrollable(kVerticalScrollbar);

auto ancestor_reasons =
context_.current.scroll->GetMainThreadScrollingReasons();
state.main_thread_scrolling_reasons =
GetMainThreadScrollingReasons(object_, ancestor_reasons);

// Main thread scrolling reasons depend on their ancestor's reasons
// so ensure the entire subtree is updated when reasons change.
if (auto* existing_scroll = properties_->Scroll()) {
if (existing_scroll->GetMainThreadScrollingReasons() !=
state.main_thread_scrolling_reasons)
full_context_.force_subtree_update = true;
}

if (RuntimeEnabledFeatures::SlimmingPaintV2Enabled() ||
RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled())
state.compositor_element_id = scrollable_area->GetCompositorElementId();

      OnUpdate(
          properties_->UpdateScroll(context_.current.scroll, std::move(state)));
} else {
OnClear(properties_->ClearScroll());
}

// A scroll translation node is created for static offset (e.g., overflow
// hidden with scroll offset) or cases that scroll and have a scroll node.
if (NeedsScrollOrScrollTranslation(object_)) {
const LayoutBox& box = ToLayoutBox(object_);
TransformPaintPropertyNode::State state;
IntSize scroll_offset = box.ScrolledContentOffset();
state.matrix.Translate(-scroll_offset.Width(), -scroll_offset.Height());
state.flattens_inherited_transform =
context_.current.should_flatten_inherited_transform;
if (RuntimeEnabledFeatures::SlimmingPaintV2Enabled() ||
RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) {
state.direct_compositing_reasons = CompositingReasonsForScroll(box);
state.rendering_context_id = context_.current.rendering_context_id;
}
state.scroll = properties_->Scroll();
      OnUpdate(properties_->UpdateScrollTranslation(context_.current.transform,
std::move(state)));
} else {
OnClear(properties_->ClearScrollTranslation());
}
}

if (properties_->Scroll())
context_.current.scroll = properties_->Scroll();
if (properties_->ScrollTranslation()) {
context_.current.transform = properties_->ScrollTranslation();
context_.current.should_flatten_inherited_transform = false;
}
}

  void OnClearClip(bool cleared) {
    OnClear(cleared);
    full_context_.clip_changed |= cleared;
  }

void AddChunk(const TransformPaintPropertyNode* t,
                const ClipPaintPropertyNode* c,
                const EffectPaintPropertyNode* e,
const FloatRect& bounds = FloatRect(0, 0, 100, 100)) {
auto record = sk_make_sp<PaintRecord>();
record->push<cc::DrawRectOp>(bounds, cc::PaintFlags());
AddChunk(std::move(record), t, c, e, bounds);
}

TestPaintArtifact& TestPaintArtifact::RectDrawing(const FloatRect& bounds,
                                                  Color color) {
  return RectDrawing(NewClient(), bounds, color);
}

ScrollPaintPropertyNode* ScrollPaintPropertyNode::Root() {
  DEFINE_STATIC_REF(ScrollPaintPropertyNode, root,
                    (ScrollPaintPropertyNode::Create(nullptr, State{})));
return root;
}

static bool IsPrintingRootLayoutView(const LayoutObject& object) {
  if (!object.IsLayoutView())
    return false;

  const auto& frame = *object.GetFrame();
  if (!frame.GetDocument()->Printing())
    return false;

  const auto* parent_frame = frame.Tree().Parent();
  if (!parent_frame)
    return true;
  if (!parent_frame->IsLocalFrame())
    return true;

  return !ToLocalFrame(parent_frame)->GetDocument()->Printing();
}

void ConversionContext::StartClip(
    const FloatRoundedRect& combined_clip_rect,
    const ClipPaintPropertyNode* lowest_combined_clip_node) {
  if (lowest_combined_clip_node->LocalTransformSpace() != current_transform_)
    EndTransform();
  cc_list_.StartPaint();
  cc_list_.push<cc::SaveOp>();
  ApplyTransform(lowest_combined_clip_node->LocalTransformSpace());
  const bool antialias = true;
  if (combined_clip_rect.IsRounded()) {
    cc_list_.push<cc::ClipRRectOp>(combined_clip_rect, SkClipOp::kIntersect,
                                   antialias);
  } else {
    cc_list_.push<cc::ClipRectOp>(combined_clip_rect.Rect(),
                                  SkClipOp::kIntersect, antialias);
  }
  if (lowest_combined_clip_node->ClipPath()) {
    cc_list_.push<cc::ClipPathOp>(
        lowest_combined_clip_node->ClipPath()->GetSkPath(),
        SkClipOp::kIntersect, antialias);
  }
  cc_list_.EndPaintOfPairedBegin();

  PushState(StateEntry::kClip, 1);
  current_clip_ = lowest_combined_clip_node;
  current_transform_ = lowest_combined_clip_node->LocalTransformSpace();
}

void PaintArtifactCompositor::Update(
    const PaintArtifact& paint_artifact,
    CompositorElementIdSet& composited_element_ids) {
  DCHECK(root_layer_);

  cc::LayerTreeHost* host = root_layer_->layer_tree_host();
  if (!host)
    return;

  if (extra_data_for_testing_enabled_)
    extra_data_for_testing_.reset(new ExtraDataForTesting);

  RemoveChildLayers();
  root_layer_->set_property_tree_sequence_number(
      g_s_property_tree_sequence_number);

  PropertyTreeManager property_tree_manager(*this, *host->property_trees(),
                                            root_layer_.get(),
                                            g_s_property_tree_sequence_number);
  Vector<PendingLayer, 0> pending_layers;
  CollectPendingLayers(paint_artifact, pending_layers);

  Vector<std::unique_ptr<ContentLayerClientImpl>> new_content_layer_clients;
  new_content_layer_clients.ReserveCapacity(pending_layers.size());
  Vector<scoped_refptr<cc::Layer>> new_scroll_hit_test_layers;

  for (auto& entry : synthesized_clip_cache_)
    entry.in_use = false;

  for (auto& pending_layer : pending_layers) {
    const auto& property_state = pending_layer.property_tree_state;
    const auto* transform = property_state.Transform();
    const auto* clip = property_state.Clip();

    if (clip->LocalTransformSpace() == transform) {
      pending_layer.bounds.Intersect(clip->ClipRect().Rect());
    } else if (const auto* scroll = transform->ScrollNode()) {
      pending_layer.bounds.Intersect(FloatRect(scroll->ContentsRect()));
    }

    gfx::Vector2dF layer_offset;
    scoped_refptr<cc::Layer> layer = CompositedLayerForPendingLayer(
        paint_artifact, pending_layer, layer_offset, new_content_layer_clients,
        new_scroll_hit_test_layers);

    int transform_id =
        property_tree_manager.EnsureCompositorTransformNode(transform);
    int clip_id = property_tree_manager.EnsureCompositorClipNode(clip);
    int effect_id = property_tree_manager.SwitchToEffectNodeWithSynthesizedClip(
        *property_state.Effect(), *clip);
    const auto& scroll_translation =
        ScrollTranslationForPendingLayer(paint_artifact, pending_layer);
    int scroll_id =
        property_tree_manager.EnsureCompositorScrollNode(&scroll_translation);

    layer->set_offset_to_transform_parent(layer_offset);

    CompositorElementId element_id =
        layer->scrollable()
            ? layer->element_id()
            : property_state.GetCompositorElementId(composited_element_ids);
    if (element_id) {
      layer->SetElementId(element_id);
      composited_element_ids.insert(element_id);
    }

    root_layer_->AddChild(layer);
    if (element_id) {
      host->RegisterElement(element_id, cc::ElementListType::ACTIVE,
                            layer.get());
    }

    layer->set_property_tree_sequence_number(g_s_property_tree_sequence_number);
    layer->SetTransformTreeIndex(transform_id);
    layer->SetScrollTreeIndex(scroll_id);
    layer->SetClipTreeIndex(clip_id);
    layer->SetEffectTreeIndex(effect_id);
    bool backface_hidden =
        IsBackfaceHidden(pending_layer.property_tree_state.Transform());
    layer->SetDoubleSided(!backface_hidden);
    layer->SetShouldCheckBackfaceVisibility(backface_hidden);
  }
  property_tree_manager.Finalize();
  content_layer_clients_.swap(new_content_layer_clients);
  scroll_hit_test_layers_.swap(new_scroll_hit_test_layers);

  synthesized_clip_cache_.erase(
      std::remove_if(synthesized_clip_cache_.begin(),
                     synthesized_clip_cache_.end(),
                     [](const auto& entry) { return !entry.in_use; }),
      synthesized_clip_cache_.end());
  if (extra_data_for_testing_enabled_) {
    for (const auto& entry : synthesized_clip_cache_) {
      extra_data_for_testing_->synthesized_clip_layers.push_back(
          entry.synthesized_clip->GetLayer());
    }
  }

  host->property_trees()->sequence_number = g_s_property_tree_sequence_number;
  host->property_trees()->needs_rebuild = false;
  host->property_trees()->ResetCachedData();

  g_s_property_tree_sequence_number++;

#if DCHECK_IS_ON()
  if (VLOG_IS_ON(2)) {
    static String s_previous_output;
    LayerTreeFlags flags = VLOG_IS_ON(3) ? 0xffffffff : 0;
    String new_output = LayersAsJSON(flags)->ToPrettyJSONString();
    if (new_output != s_previous_output) {
      LOG(ERROR) << "PaintArtifactCompositor::Update() done\n"
                 << "Composited layers:\n"
                 << new_output.Utf8().data();
      s_previous_output = new_output;
    }
  }
#endif
}

bool PaintController::CacheIsAllInvalid() const {
  DCHECK(!RuntimeEnabledFeatures::SlimmingPaintV2Enabled());
  return current_paint_artifact_.IsEmpty() &&
         current_cache_generation_.GetPaintInvalidationReason() !=
             PaintInvalidationReason::kNone;
}

bool PaintPropertyTreeBuilder::ObjectTypeMightNeedPaintProperties() const {
  return object_.IsBoxModelObject() || object_.IsSVG() ||
         context_.painting_layer->EnclosingPaginationLayer() ||
         context_.is_repeating_table_section ||
         context_.is_repeating_fixed_position;
}

ClipPaintPropertyNode* ClipPaintPropertyNode::Root() {
  DEFINE_STATIC_REF(
ClipPaintPropertyNode, root,
      (ClipPaintPropertyNode::Create(
          nullptr, State{TransformPaintPropertyNode::Root(),
                         FloatRoundedRect(LayoutRect::InfiniteIntRect())})));
return root;
}

TransformPaintPropertyNode* TransformPaintPropertyNode::Root() {
  DEFINE_STATIC_REF(
TransformPaintPropertyNode, root,
      base::AdoptRef(new TransformPaintPropertyNode(
          nullptr,
          State{TransformationMatrix(), FloatPoint3D(), false,
                BackfaceVisibility::kVisible, 0, CompositingReason::kNone,
                CompositorElementId(), ScrollPaintPropertyNode::Root()})));
return root;
}

  bool PropertyAddedOrRemoved() const { return property_added_or_removed_; }

const DisplayItem* PaintController::LastDisplayItem(unsigned offset) {
  if (offset < new_display_item_list_.size())
    return &new_display_item_list_[new_display_item_list_.size() - offset - 1];
  return nullptr;
}

void PropertyTreeManager::SetupRootTransformNode() {
// cc is hardcoded to use transform node index 1 for device scale and
// transform.
cc::TransformTree& transform_tree = property_trees_.transform_tree;
transform_tree.clear();
property_trees_.element_id_to_transform_node_index.clear();
cc::TransformNode& transform_node = *transform_tree.Node(
transform_tree.Insert(cc::TransformNode(), kRealRootNodeId));
DCHECK_EQ(transform_node.id, kSecondaryRootNodeId);
transform_node.source_node_id = transform_node.parent_id;

// TODO(jaydasika): We shouldn't set ToScreen and FromScreen of root
// transform node here. They should be set while updating transform tree in
// cc.
float device_scale_factor =
root_layer_->layer_tree_host()->device_scale_factor();
gfx::Transform to_screen;
to_screen.Scale(device_scale_factor, device_scale_factor);
transform_tree.SetToScreen(kRealRootNodeId, to_screen);
gfx::Transform from_screen;
bool invertible = to_screen.GetInverse(&from_screen);
DCHECK(invertible);
transform_tree.SetFromScreen(kRealRootNodeId, from_screen);
transform_tree.set_needs_update(true);

  transform_node_map_.Set(TransformPaintPropertyNode::Root(),
transform_node.id);
root_layer_->SetTransformTreeIndex(transform_node.id);
}

static const EffectPaintPropertyNode* StrictChildOfAlongPath(
    const EffectPaintPropertyNode* ancestor,
    const EffectPaintPropertyNode* node) {
  for (; node; node = node->Parent()) {
    if (node->Parent() == ancestor)
      return node;
  }
  return nullptr;
}

void CompositedLayerRasterInvalidator::FullyInvalidateChunk(
    const PaintChunkInfo& old_chunk,
    const PaintChunkInfo& new_chunk,
    PaintInvalidationReason reason) {
  FullyInvalidateOldChunk(old_chunk, reason);
  if (old_chunk.bounds_in_layer != new_chunk.bounds_in_layer)
    FullyInvalidateNewChunk(new_chunk, reason);
}

void FragmentPaintPropertyTreeBuilder::UpdatePaintOffset() {
  const auto* enclosing_pagination_layer =
      full_context_.painting_layer->EnclosingPaginationLayer();
  if (enclosing_pagination_layer &&
      !context_.current.paint_offset_root->PaintingLayer()
           ->EnclosingPaginationLayer()) {
    LayoutPoint paint_offset =
        PaintOffsetInPaginationContainer(object_, *enclosing_pagination_layer);

    paint_offset.MoveBy(fragment_data_.PaginationOffset());
    paint_offset.Move(context_.repeating_paint_offset_adjustment);
    paint_offset.MoveBy(
        VisualOffsetFromPaintOffsetRoot(context_, enclosing_pagination_layer));

    paint_offset.MoveBy(
        context_.current.paint_offset_root->FirstFragment().PaintOffset());

    context_.current.paint_offset = paint_offset;

    return;
  }

  if (object_.IsFloating())
    context_.current.paint_offset = context_.paint_offset_for_float;

  if (object_.IsColumnSpanAll()) {
    context_.current.paint_offset =
        object_.Container()->FirstFragment().PaintOffset();
  }

  if (object_.IsBoxModelObject()) {
    const LayoutBoxModelObject& box_model_object =
        ToLayoutBoxModelObject(object_);
    switch (box_model_object.StyleRef().GetPosition()) {
      case EPosition::kStatic:
        break;
      case EPosition::kRelative:
        context_.current.paint_offset +=
            box_model_object.OffsetForInFlowPosition();
        break;
      case EPosition::kAbsolute: {
        DCHECK(full_context_.container_for_absolute_position ==
               box_model_object.Container());
        context_.current = context_.absolute_position;

        const auto* container = full_context_.container_for_absolute_position;
        if (container && container->IsLayoutInline()) {
          DCHECK(container->CanContainAbsolutePositionObjects());
          DCHECK(box_model_object.IsBox());
          context_.current.paint_offset +=
              ToLayoutInline(container)->OffsetForInFlowPositionedInline(
                  ToLayoutBox(box_model_object));
        }
        break;
      }
      case EPosition::kSticky:
        context_.current.paint_offset +=
            box_model_object.OffsetForInFlowPosition();
        break;
      case EPosition::kFixed: {
        DCHECK(full_context_.container_for_fixed_position ==
               box_model_object.Container());
        context_.current = context_.fixed_position;
        if (context_.fixed_position.fixed_position_children_fixed_to_root)
          context_.current.paint_offset_root = &box_model_object;

        const auto* container = full_context_.container_for_fixed_position;
        if (container && container->IsLayoutInline()) {
          DCHECK(container->CanContainFixedPositionObjects());
          DCHECK(box_model_object.IsBox());
          context_.current.paint_offset +=
              ToLayoutInline(container)->OffsetForInFlowPositionedInline(
                  ToLayoutBox(box_model_object));
        }
        break;
      }
      default:
        NOTREACHED();
    }
  }

  if (object_.IsBox()) {
    context_.current.paint_offset.MoveBy(
        ToLayoutBox(object_).PhysicalLocation());

    if (object_.IsTableCell()) {
      LayoutObject* parent_row = object_.Parent();
      DCHECK(parent_row && parent_row->IsTableRow());
      context_.current.paint_offset.MoveBy(
          -ToLayoutBox(parent_row)->PhysicalLocation());
    }
  }

  context_.current.paint_offset.Move(
      context_.repeating_paint_offset_adjustment);
}

PaintArtifactCompositor::PaintArtifactCompositor(
    base::RepeatingCallback<void(const gfx::ScrollOffset&,
                                 const cc::ElementId&)> scroll_callback)
    : scroll_callback_(std::move(scroll_callback)),
      tracks_raster_invalidations_(false) {
  if (!RuntimeEnabledFeatures::SlimmingPaintV2Enabled() &&
      !RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled())
    return;
  root_layer_ = cc::Layer::Create();
}

void CompositedLayerRasterInvalidator::SetTracksRasterInvalidations(
    bool should_track) {
  if (should_track) {
    if (!tracking_info_)
      tracking_info_ = std::make_unique<RasterInvalidationTrackingInfo>();
    tracking_info_->tracking.ClearInvalidations();
    for (const auto& info : paint_chunks_info_) {
      tracking_info_->old_client_debug_names.Set(&info.id.client,
                                                 info.id.client.DebugName());
    }
  } else if (!RasterInvalidationTracking::ShouldAlwaysTrack()) {
    tracking_info_ = nullptr;
  } else if (tracking_info_) {
    tracking_info_->tracking.ClearInvalidations();
  }
}

void PaintPropertyTreeBuilder::CreateFragmentDataForRepeatingInPagedMedia(
    bool needs_paint_properties) {
  DCHECK(IsRepeatingInPagedMedia());

  FragmentData* fragment_data = nullptr;
  for (auto& fragment_context : context_.fragments) {
    fragment_data = fragment_data
                        ? &fragment_data->EnsureNextFragment()
                        : &object_.GetMutableForPainting().FirstFragment();
    InitFragmentPaintProperties(*fragment_data, needs_paint_properties,
                                LayoutPoint(),
                                fragment_context.logical_top_in_flow_thread);
  }
  DCHECK(fragment_data);
  fragment_data->ClearNextFragment();
}

void PaintController::CheckUnderInvalidation() {
  DCHECK(RuntimeEnabledFeatures::PaintUnderInvalidationCheckingEnabled());

  if (!IsCheckingUnderInvalidation())
    return;

  const DisplayItem& new_item = new_display_item_list_.Last();
  if (new_item.SkippedCache()) {
    under_invalidation_checking_end_ = 0;
    next_item_to_match_ = next_item_to_index_ =
        under_invalidation_checking_begin_;
    return;
  }

  size_t old_item_index = under_invalidation_checking_begin_ +
                          skipped_probable_under_invalidation_count_;
  DisplayItem* old_item =
      old_item_index < current_paint_artifact_.GetDisplayItemList().size()
          ? &current_paint_artifact_.GetDisplayItemList()[old_item_index]
          : nullptr;

  bool old_and_new_equal = (old_item && new_item.Equals(*old_item));
  if (!old_and_new_equal) {
    if (new_item.IsBegin()) {
      ++skipped_probable_under_invalidation_count_;
      return;
    }
    if (new_item.IsDrawing() &&
        skipped_probable_under_invalidation_count_ == 1) {
      DCHECK_GE(new_display_item_list_.size(), 2u);
      if (new_display_item_list_[new_display_item_list_.size() - 2].GetType() ==
          DisplayItem::kBeginCompositing) {
        ++skipped_probable_under_invalidation_count_;
        return;
      }
    }
  }

  if (skipped_probable_under_invalidation_count_ || !old_and_new_equal) {
    ShowUnderInvalidationError(
        "under-invalidation: display item changed",
        new_display_item_list_[new_display_item_list_.size() -
                               skipped_probable_under_invalidation_count_ - 1],
        &current_paint_artifact_
             .GetDisplayItemList()[under_invalidation_checking_begin_]);
    CHECK(false);
  }

  new_display_item_list_.RemoveLast();
  MoveItemFromCurrentListToNewList(old_item_index);

  ++under_invalidation_checking_begin_;
}

int PropertyTreeManager::SwitchToEffectNodeWithSynthesizedClip(
    const EffectPaintPropertyNode& next_effect,
    const ClipPaintPropertyNode& next_clip) {
  const auto& ancestor = LowestCommonAncestor(*current_effect_, next_effect);
  while (current_effect_ != &ancestor)
    CloseCcEffect();

  bool newly_built = BuildEffectNodesRecursively(&next_effect);
  SynthesizeCcEffectsForClipsIfNeeded(&next_clip, SkBlendMode::kSrcOver,
                                      newly_built);

  return current_effect_id_;
}

void FragmentPaintPropertyTreeBuilder::UpdateForSelf() {
  base::Optional<IntPoint> paint_offset_translation;
  UpdateForObjectLocationAndSize(paint_offset_translation);
  if (&fragment_data_ == &object_.FirstFragment())
    SetNeedsPaintPropertyUpdateIfNeeded();
  UpdateClipPathCache();

  if (properties_) {
    UpdateFragmentClip();
    UpdatePaintOffsetTranslation(paint_offset_translation);
  }

#if DCHECK_IS_ON()
  FindObjectPropertiesNeedingUpdateScope check_needs_update_scope(
      object_, fragment_data_, full_context_.force_subtree_update);
#endif

  if (properties_) {
    UpdateTransform();
    UpdateClipPathClip(false);
    if (RuntimeEnabledFeatures::SlimmingPaintV175Enabled())
      UpdateEffect();
    UpdateClipPathClip(true);  // Special pass for SPv1 composited clip-path.
    UpdateCssClip();
    UpdateFilter();
    UpdateOverflowControlsClip();
  }
  UpdateLocalBorderBoxContext();
}

size_t PaintController::FindCachedItem(const DisplayItem::Id& id) {
  DCHECK(ClientCacheIsValid(id.client));

  for (size_t i = next_item_to_match_;
       i < current_paint_artifact_.GetDisplayItemList().size(); ++i) {
    const DisplayItem& item = current_paint_artifact_.GetDisplayItemList()[i];
    if (item.IsTombstone())
      break;
    if (id == item.GetId()) {
#if DCHECK_IS_ON()
      ++num_sequential_matches_;
#endif
      return i;
    }
    if (item.IsCacheable())
      break;
  }

  size_t found_index =
      FindMatchingItemFromIndex(id, out_of_order_item_indices_,
                                current_paint_artifact_.GetDisplayItemList());
  if (found_index != kNotFound) {
#if DCHECK_IS_ON()
    ++num_out_of_order_matches_;
#endif
    return found_index;
  }

  return FindOutOfOrderCachedItemForward(id);
}

void PaintArtifactCompositor::RemoveChildLayers() {
  cc::LayerTreeHost* host = root_layer_->layer_tree_host();
  if (!host)
    return;
  for (auto child : root_layer_->children()) {
    host->UnregisterElement(child->element_id(), cc::ElementListType::ACTIVE);
  }
  root_layer_->RemoveAllChildren();
  if (extra_data_for_testing_enabled_) {
    extra_data_for_testing_->content_layers.clear();
    extra_data_for_testing_->synthesized_clip_layers.clear();
    extra_data_for_testing_->scroll_hit_test_layers.clear();
  }
}

void CompositedLayerRasterInvalidator::AddRasterInvalidation(
    const IntRect& rect,
    const DisplayItemClient* client,
    PaintInvalidationReason reason,
    const String* debug_name) {
  raster_invalidation_function_(rect);
  if (tracking_info_) {
    tracking_info_->tracking.AddInvalidation(
        client, debug_name ? *debug_name : client->DebugName(), rect, reason);
  }
}

  int ElementIdToScrollNodeIndex(CompositorElementId element_id) {
    return web_layer_tree_view_->GetLayerTreeHost()
        ->property_trees()
        ->element_id_to_scroll_node_index[element_id];
  }

void FragmentPaintPropertyTreeBuilder::UpdatePerspective() {
DCHECK(properties_);

if (NeedsPaintPropertyUpdate()) {
if (NeedsPerspective(object_)) {
const ComputedStyle& style = object_.StyleRef();
// The perspective node must not flatten (else nothing will get
// perspective), but it should still extend the rendering context as
// most transform nodes do.
TransformPaintPropertyNode::State state;
state.matrix.ApplyPerspective(style.Perspective());
state.origin = PerspectiveOrigin(ToLayoutBox(object_)) +
ToLayoutSize(context_.current.paint_offset);
state.flattens_inherited_transform =
context_.current.should_flatten_inherited_transform;
if (RuntimeEnabledFeatures::SlimmingPaintV2Enabled() ||
RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled())
state.rendering_context_id = context_.current.rendering_context_id;
      OnUpdate(properties_->UpdatePerspective(context_.current.transform,
std::move(state)));
} else {
OnClear(properties_->ClearPerspective());
}
}

if (properties_->Perspective()) {
context_.current.transform = properties_->Perspective();
context_.current.should_flatten_inherited_transform = false;
}
}

bool PaintController::ClientCacheIsValid(
    const DisplayItemClient& client) const {
#if DCHECK_IS_ON()
  DCHECK(client.IsAlive());
#endif
  if (IsSkippingCache())
    return false;
  return client.DisplayItemsAreCached(current_cache_generation_);
}

std::unique_ptr<JSONObject> ScrollPaintPropertyNode::ToJSON() const {
  auto json = JSONObject::Create();
  if (Parent())
    json->SetString("parent", String::Format("%p", Parent()));
  if (state_.container_rect != IntRect())
    json->SetString("containerRect", state_.container_rect.ToString());
  if (state_.contents_rect != IntRect())
    json->SetString("contentsRect", state_.contents_rect.ToString());
  if (state_.user_scrollable_horizontal || state_.user_scrollable_vertical) {
    json->SetString(
        "userScrollable",
        state_.user_scrollable_horizontal
            ? (state_.user_scrollable_vertical ? "both" : "horizontal")
            : "vertical");
  }
  if (state_.main_thread_scrolling_reasons) {
    json->SetString(
        "mainThreadReasons",
        MainThreadScrollingReason::AsText(state_.main_thread_scrolling_reasons)
            .c_str());
  }
  if (state_.compositor_element_id) {
    json->SetString("compositorElementId",
                    state_.compositor_element_id.ToString().c_str());
  }
  return json;
}

void FragmentPaintPropertyTreeBuilder::UpdateEffect() {
DCHECK(properties_);
const ComputedStyle& style = object_.StyleRef();

// TODO(trchen): Can't omit effect node if we have 3D children.
if (NeedsPaintPropertyUpdate()) {
// Use the current clip as output_clip for SVG children because their
// effects never interleave with clips.
const auto* output_clip =
object_.IsSVGChild() ? context_.current.clip : nullptr;
if (NeedsEffect(object_)) {
base::Optional<IntRect> mask_clip = CSSMaskPainter::MaskBoundingBox(
object_, context_.current.paint_offset);
bool has_clip_path =
style.ClipPath() && fragment_data_.ClipPathBoundingBox();
bool has_spv1_composited_clip_path =
has_clip_path && object_.HasLayer() &&
ToLayoutBoxModelObject(object_).Layer()->GetCompositedLayerMapping();
bool has_mask_based_clip_path =
has_clip_path && !fragment_data_.ClipPathPath();
base::Optional<IntRect> clip_path_clip;
if (has_spv1_composited_clip_path || has_mask_based_clip_path) {
clip_path_clip = fragment_data_.ClipPathBoundingBox();
}
if ((mask_clip || clip_path_clip) &&
// TODO(crbug.com/768691): Remove the following condition after mask
// clip doesn't fail fast/borders/inline-mask-overlay-image-outset-
// vertical-rl.html.
RuntimeEnabledFeatures::SlimmingPaintV175Enabled()) {
IntRect combined_clip = mask_clip ? *mask_clip : *clip_path_clip;
if (mask_clip && clip_path_clip)
combined_clip.Intersect(*clip_path_clip);

OnUpdateClip(properties_->UpdateMaskClip(
            context_.current.clip,
ClipPaintPropertyNode::State{context_.current.transform,
FloatRoundedRect(combined_clip)}));
output_clip = properties_->MaskClip();
} else {
OnClearClip(properties_->ClearMaskClip());
}

EffectPaintPropertyNode::State state;
state.local_transform_space = context_.current.transform;
state.output_clip = output_clip;
state.opacity = style.Opacity();
if (object_.IsBlendingAllowed()) {
state.blend_mode = WebCoreCompositeToSkiaComposite(
kCompositeSourceOver, style.GetBlendMode());
}
if (RuntimeEnabledFeatures::SlimmingPaintV2Enabled() ||
RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) {
// We may begin to composite our subtree prior to an animation starts,
// but a compositor element ID is only needed when an animation is
// current.
if (CompositingReasonFinder::RequiresCompositingForOpacityAnimation(
style)) {
state.direct_compositing_reasons =
CompositingReason::kActiveOpacityAnimation;
}
state.compositor_element_id = CompositorElementIdFromUniqueObjectId(
object_.UniqueId(), CompositorElementIdNamespace::kPrimary);
}
      OnUpdate(
          properties_->UpdateEffect(context_.current_effect, std::move(state)));

if (mask_clip || has_spv1_composited_clip_path) {
EffectPaintPropertyNode::State mask_state;
mask_state.local_transform_space = context_.current.transform;
mask_state.output_clip = output_clip;
mask_state.color_filter = CSSMaskPainter::MaskColorFilter(object_);
mask_state.blend_mode = SkBlendMode::kDstIn;
if (RuntimeEnabledFeatures::SlimmingPaintV2Enabled() ||
RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) {
mask_state.compositor_element_id =
CompositorElementIdFromUniqueObjectId(
object_.UniqueId(),
CompositorElementIdNamespace::kEffectMask);
}
        OnUpdate(properties_->UpdateMask(properties_->Effect(),
std::move(mask_state)));
} else {
OnClear(properties_->ClearMask());
}

if (has_mask_based_clip_path) {
        const EffectPaintPropertyNode* parent = has_spv1_composited_clip_path
                                                    ? properties_->Mask()
                                                    : properties_->Effect();
EffectPaintPropertyNode::State clip_path_state;
clip_path_state.local_transform_space = context_.current.transform;
clip_path_state.output_clip = output_clip;
clip_path_state.blend_mode = SkBlendMode::kDstIn;
if (RuntimeEnabledFeatures::SlimmingPaintV2Enabled() ||
RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) {
clip_path_state.compositor_element_id =
CompositorElementIdFromUniqueObjectId(
object_.UniqueId(),
CompositorElementIdNamespace::kEffectClipPath);
}
OnUpdate(
properties_->UpdateClipPath(parent, std::move(clip_path_state)));
} else {
OnClear(properties_->ClearClipPath());
}
} else {
OnClear(properties_->ClearEffect());
OnClear(properties_->ClearMask());
OnClear(properties_->ClearClipPath());
OnClearClip(properties_->ClearMaskClip());
}
}

if (properties_->Effect()) {
context_.current_effect = properties_->Effect();
if (properties_->MaskClip()) {
context_.current.clip = context_.absolute_position.clip =
context_.fixed_position.clip = properties_->MaskClip();
}
}
}

static ScrollPaintPropertyNode::State ScrollState1() {
  ScrollPaintPropertyNode::State state;
  state.container_rect = IntRect(3, 5, 11, 13);
  state.contents_rect = IntRect(-3, -5, 27, 31);
  state.user_scrollable_horizontal = true;
  return state;
}

static bool NeedsScrollOrScrollTranslation(const LayoutObject& object) {
  if (!object.HasOverflowClip())
    return false;
  IntSize scroll_offset = ToLayoutBox(object).ScrolledContentOffset();
  return !scroll_offset.IsZero() || NeedsScrollNode(object);
}

PaintController::SubsequenceMarkers* PaintController::GetSubsequenceMarkers(
    const DisplayItemClient& client) {
  auto result = current_cached_subsequences_.find(&client);
  if (result == current_cached_subsequences_.end())
    return nullptr;
  return &result->value;
}

void PaintArtifactCompositor::EnableExtraDataForTesting() {
  extra_data_for_testing_enabled_ = true;
  extra_data_for_testing_ = std::make_unique<ExtraDataForTesting>();
}

static bool NeedsInnerBorderRadiusClip(const LayoutObject& object) {
  if (!object.StyleRef().HasBorderRadius())
    return false;
  if (object.IsBox() && NeedsOverflowClip(object))
    return true;
  if (object.IsLayoutReplaced() && !object.IsSVGRoot())
    return true;
  return false;
}

void FragmentPaintPropertyTreeBuilder::UpdateOutOfFlowContext() {
if (!object_.IsBoxModelObject() && !properties_)
return;

if (object_.IsLayoutBlock())
context_.paint_offset_for_float = context_.current.paint_offset;

if (object_.CanContainAbsolutePositionObjects()) {
context_.absolute_position = context_.current;
}

if (object_.IsLayoutView()) {
const auto* initial_fixed_transform = context_.fixed_position.transform;
const auto* initial_fixed_scroll = context_.fixed_position.scroll;

context_.fixed_position = context_.current;
context_.fixed_position.fixed_position_children_fixed_to_root = true;

// Fixed position transform and scroll nodes should not be affected.
context_.fixed_position.transform = initial_fixed_transform;
context_.fixed_position.scroll = initial_fixed_scroll;
} else if (object_.CanContainFixedPositionObjects()) {
context_.fixed_position = context_.current;
context_.fixed_position.fixed_position_children_fixed_to_root = false;
} else if (properties_ && properties_->CssClip()) {
// CSS clip applies to all descendants, even if this object is not a
// containing block ancestor of the descendant. It is okay for
// absolute-position descendants because having CSS clip implies being
// absolute position container. However for fixed-position descendants we
// need to insert the clip here if we are not a containing block ancestor of
// them.
auto* css_clip = properties_->CssClip();

// Before we actually create anything, check whether in-flow context and
// fixed-position context has exactly the same clip. Reuse if possible.
if (context_.fixed_position.clip == css_clip->Parent()) {
context_.fixed_position.clip = css_clip;
} else {
if (NeedsPaintPropertyUpdate()) {
OnUpdate(properties_->UpdateCssClipFixedPosition(
            context_.fixed_position.clip,
ClipPaintPropertyNode::State{css_clip->LocalTransformSpace(),
css_clip->ClipRect()}));
}
if (properties_->CssClipFixedPosition())
context_.fixed_position.clip = properties_->CssClipFixedPosition();
return;
}
}

if (NeedsPaintPropertyUpdate() && properties_)
OnClear(properties_->ClearCssClipFixedPosition());
}

size_t ClipPaintPropertyNode::CacheMemoryUsageInBytes() const {
  size_t total_bytes = sizeof(*this);
  if (geometry_mapper_clip_cache_)
    total_bytes += sizeof(*geometry_mapper_clip_cache_);
  if (Parent())
    total_bytes += Parent()->CacheMemoryUsageInBytes();
  return total_bytes;
}

void ConversionContext::EndClips() {
  while (state_stack_.size() && state_stack_.back().type == StateEntry::kClip)
    EndClip();
}

  cc::Layer* ScrollHitTestLayerAt(unsigned index) {
    return paint_artifact_compositor_->GetExtraDataForTesting()
        ->scroll_hit_test_layers[index]
        .get();
  }

  GraphicsLayerTest() {
    clip_layer_ = std::make_unique<FakeGraphicsLayer>(client_);
    scroll_elasticity_layer_ = std::make_unique<FakeGraphicsLayer>(client_);
    page_scale_layer_ = std::make_unique<FakeGraphicsLayer>(client_);
    graphics_layer_ = std::make_unique<FakeGraphicsLayer>(client_);
    graphics_layer_->SetDrawsContent(true);
    clip_layer_->AddChild(scroll_elasticity_layer_.get());
    scroll_elasticity_layer_->AddChild(page_scale_layer_.get());
    page_scale_layer_->AddChild(graphics_layer_.get());
    graphics_layer_->CcLayer()->SetScrollable(clip_layer_->CcLayer()->bounds());
    cc_layer_ = graphics_layer_->CcLayer();
    layer_tree_view_ = std::make_unique<WebLayerTreeViewImplForTesting>();
    DCHECK(layer_tree_view_);
    layer_tree_view_->SetRootLayer(clip_layer_->CcLayer());
    WebLayerTreeView::ViewportLayers viewport_layers;
    viewport_layers.overscroll_elasticity = scroll_elasticity_layer_->CcLayer();
    viewport_layers.page_scale = page_scale_layer_->CcLayer();
    viewport_layers.inner_viewport_container = clip_layer_->CcLayer();
    viewport_layers.inner_viewport_scroll = graphics_layer_->CcLayer();
    layer_tree_view_->RegisterViewportLayers(viewport_layers);
    layer_tree_view_->SetViewportSize(WebSize(1, 1));

      graphics_layer_->SetLayerState(
          PropertyTreeState(PropertyTreeState::Root()), IntPoint());
  }

std::unique_ptr<JSONObject> ClipPaintPropertyNode::ToJSON() const {
auto json = JSONObject::Create();
if (Parent())
json->SetString("parent", String::Format("%p", Parent()));
json->SetString("localTransformSpace",
                  String::Format("%p", state_.local_transform_space.get()));
json->SetString("rect", state_.clip_rect.ToString());
if (state_.clip_rect_excluding_overlay_scrollbars) {
json->SetString("rectExcludingOverlayScrollbars",
state_.clip_rect_excluding_overlay_scrollbars->ToString());
}
if (state_.clip_path) {
json->SetBoolean("hasClipPath", true);
}
if (state_.direct_compositing_reasons != CompositingReason::kNone) {
json->SetString(
"directCompositingReasons",
CompositingReason::ToString(state_.direct_compositing_reasons));
}
return json;
}

 void PaintPropertyTreeBuilder::SetupContextForFrame(
    LocalFrameView& frame_view,
    PaintPropertyTreeBuilderContext& full_context) {
  if (full_context.fragments.IsEmpty())
    full_context.fragments.push_back(PaintPropertyTreeBuilderFragmentContext());

  PaintPropertyTreeBuilderFragmentContext& context = full_context.fragments[0];
  context.current.paint_offset.MoveBy(frame_view.Location());
  context.current.rendering_context_id = 0;
  context.current.should_flatten_inherited_transform = true;
  context.absolute_position = context.current;
  full_context.container_for_absolute_position = nullptr;
  full_context.container_for_fixed_position = nullptr;
  context.fixed_position = context.current;
  context.fixed_position.fixed_position_children_fixed_to_root = true;
}

cc::ClipTree& PropertyTreeManager::GetClipTree() {
  return property_trees_.clip_tree;
}

void BlockPainter::PaintOverflowControlsIfNeeded(
    const PaintInfo& paint_info,
    const LayoutPoint& paint_offset) {
  if (layout_block_.HasOverflowClip() &&
      layout_block_.Style()->Visibility() == EVisibility::kVisible &&
      ShouldPaintSelfBlockBackground(paint_info.phase)) {
    base::Optional<ClipRecorder> clip_recorder;
    if (!layout_block_.Layer()->IsSelfPaintingLayer()) {
      LayoutRect clip_rect = layout_block_.BorderBoxRect();
      clip_rect.MoveBy(paint_offset);
      clip_recorder.emplace(paint_info.context, layout_block_,
                            DisplayItem::kClipScrollbarsToBoxBounds,
                            PixelSnappedIntRect(clip_rect));
    }
    ScrollableAreaPainter(*layout_block_.Layer()->GetScrollableArea())
        .PaintOverflowControls(paint_info, RoundedIntPoint(paint_offset),
                               false /* painting_overlay_controls */);
  }
}

IntRect ChunkToLayerMapper::MapVisualRect(const FloatRect& rect) const {
  if (rect.IsEmpty())
    return IntRect();

  if (UNLIKELY(has_filter_that_moves_pixels_))
    return MapUsingGeometryMapper(rect);

  FloatRect mapped_rect = transform_.MapRect(rect);
  if (!mapped_rect.IsEmpty() && !clip_rect_.IsInfinite())
    mapped_rect.Intersect(clip_rect_.Rect());

  if (mapped_rect.IsEmpty()) {
    DCHECK(MapUsingGeometryMapper(rect).IsEmpty());
    return IntRect();
  }

  mapped_rect.Inflate(outset_for_raster_effects_);
  AdjustVisualRectBySubpixelOffset(mapped_rect);

  auto result = EnclosingIntRect(mapped_rect);
#if DCHECK_IS_ON()
  auto slow_result = MapUsingGeometryMapper(rect);
  if (result != slow_result) {
    LOG(WARNING) << "ChunkToLayerMapper::MapVisualRect: Different results from"
                 << "fast path (" << result << ") and slow path ("
                 << slow_result << ")";
  }
#endif
  return result;
}

TestPaintArtifact& TestPaintArtifact::ForeignLayer(
    DisplayItemClient& client,
    const FloatPoint& location,
    const IntSize& size,
    scoped_refptr<cc::Layer> layer) {
  static_cast<DummyRectClient&>(client).SetVisualRect(
      FloatRect(location, FloatSize(size)));
  display_item_list_.AllocateAndConstruct<ForeignLayerDisplayItem>(
      client, DisplayItem::kForeignLayerFirst, std::move(layer), location,
      size);
  return *this;
 }

PaintArtifactCompositor::PendingLayer::PendingLayer(
const PaintChunk& first_paint_chunk,
size_t chunk_index,
bool chunk_requires_own_layer)
: bounds(first_paint_chunk.bounds),
rect_known_to_be_opaque(
first_paint_chunk.known_to_be_opaque ? bounds : FloatRect()),
      property_tree_state(first_paint_chunk.properties.GetPropertyTreeState()),
requires_own_layer(chunk_requires_own_layer) {
paint_chunk_indices.push_back(chunk_index);
}

PaintPropertyTreeBuilderTest::PaintPropertiesForElement(const char* name) {
  return GetDocument()
      .getElementById(name)
      ->GetLayoutObject()
      ->FirstFragment()
      .PaintProperties();
}

void ConversionContext::EndTransform() {
  if (!previous_transform_)
    return;

  cc_list_.StartPaint();
  cc_list_.push<cc::RestoreOp>();
  cc_list_.EndPaintOfPairedEnd();
  current_transform_ = previous_transform_;
  previous_transform_ = nullptr;
}

  size_t ContentLayerCount() {
    return paint_artifact_compositor_->GetExtraDataForTesting()
        ->content_layers.size();
  }

static bool NeedsCssClip(const LayoutObject& object) {
  return object.HasClip();
}

PaintPropertyTreeBuilderFragmentContext()
    : current_effect(EffectPaintPropertyNode::Root()) {
current.clip = absolute_position.clip = fixed_position.clip =
      ClipPaintPropertyNode::Root();
current.transform = absolute_position.transform = fixed_position.transform =
      TransformPaintPropertyNode::Root();
current.scroll = absolute_position.scroll = fixed_position.scroll =
      ScrollPaintPropertyNode::Root();
}

static FloatPoint PerspectiveOrigin(const LayoutBox& box) {
  const ComputedStyle& style = box.StyleRef();
  DCHECK(style.HasPerspective());
  FloatSize border_box_size(box.Size());
  return FloatPointForLengthPoint(style.PerspectiveOrigin(), border_box_size);
}

  void ResetAllChanged() {
    grandchild1->ClearChangedToRoot();
     grandchild2->ClearChangedToRoot();
   }

void PaintController::SetFirstPainted() {
  frame_first_paints_.back().first_painted = true;
}

static bool IsNonCompositingAncestorOf(
    const TransformPaintPropertyNode* ancestor,
    const TransformPaintPropertyNode* node) {
  for (; node != ancestor; node = node->Parent()) {
    if (!node || node->HasDirectCompositingReasons())
      return false;
  }
  return true;
}

void FragmentPaintPropertyTreeBuilder::UpdateForPaintOffsetTranslation(
    base::Optional<IntPoint>& paint_offset_translation) {
  if (!NeedsPaintOffsetTranslation(object_))
    return;

  paint_offset_translation = RoundedIntPoint(context_.current.paint_offset);
  LayoutPoint fractional_paint_offset =
      LayoutPoint(context_.current.paint_offset - *paint_offset_translation);
  if (fractional_paint_offset != LayoutPoint()) {
    TransformationMatrix matrix;
    object_.StyleRef().ApplyTransform(
        matrix, LayoutSize(), ComputedStyle::kExcludeTransformOrigin,
        ComputedStyle::kIncludeMotionPath,
        ComputedStyle::kIncludeIndependentTransformProperties);
    if (!matrix.IsIdentityOrTranslation())
      fractional_paint_offset = LayoutPoint();
  }
  context_.current.paint_offset = fractional_paint_offset;
}

const EffectPaintPropertyNode* e0() {
  return EffectPaintPropertyNode::Root();
}

static scoped_refptr<ScrollPaintPropertyNode> CreateScroll(
    scoped_refptr<const ScrollPaintPropertyNode> parent,
const ScrollPaintPropertyNode::State& state_arg,
MainThreadScrollingReasons main_thread_scrolling_reasons =
MainThreadScrollingReason::kNotScrollingOnMain,
CompositorElementId scroll_element_id = CompositorElementId()) {
ScrollPaintPropertyNode::State state = state_arg;
state.main_thread_scrolling_reasons = main_thread_scrolling_reasons;
state.compositor_element_id = scroll_element_id;
return ScrollPaintPropertyNode::Create(parent, std::move(state));
}

bool PaintController::UseCachedDrawingIfPossible(
    const DisplayItemClient& client,
    DisplayItem::Type type) {
  DCHECK(DisplayItem::IsDrawingType(type));

  if (DisplayItemConstructionIsDisabled())
    return false;

  if (!ClientCacheIsValid(client))
    return false;

  if (RuntimeEnabledFeatures::PaintUnderInvalidationCheckingEnabled() &&
      IsCheckingUnderInvalidation()) {
    return false;
  }

  size_t cached_item =
      FindCachedItem(DisplayItem::Id(client, type, current_fragment_));
  if (cached_item == kNotFound) {
    return false;
  }

  ++num_cached_new_items_;
  EnsureNewDisplayItemListInitialCapacity();
  current_paint_artifact_.GetDisplayItemList()[cached_item].UpdateVisualRect();
  if (!RuntimeEnabledFeatures::PaintUnderInvalidationCheckingEnabled())
    ProcessNewItem(MoveItemFromCurrentListToNewList(cached_item));

  next_item_to_match_ = cached_item + 1;
  if (next_item_to_match_ > next_item_to_index_)
    next_item_to_index_ = next_item_to_match_;

  if (RuntimeEnabledFeatures::PaintUnderInvalidationCheckingEnabled()) {
    if (!IsCheckingUnderInvalidation()) {
      under_invalidation_checking_begin_ = cached_item;
      under_invalidation_checking_end_ = cached_item + 1;
      under_invalidation_message_prefix_ = "";
    }
    return false;
  }

  return true;
}

  CompositedLayerRasterInvalidator& EnsureRasterInvalidator(
      GraphicsLayer& layer) {
    return layer.EnsureRasterInvalidator();
  }

void PaintController::AppendDebugDrawingAfterCommit(
    const DisplayItemClient& display_item_client,
    sk_sp<const PaintRecord> record,
    const PropertyTreeState* property_tree_state) {
  DCHECK(!RuntimeEnabledFeatures::SlimmingPaintV2Enabled());
  DCHECK(new_display_item_list_.IsEmpty());
  auto& display_item_list = current_paint_artifact_.GetDisplayItemList();
  auto& display_item =
      display_item_list.AllocateAndConstruct<DrawingDisplayItem>(
          display_item_client, DisplayItem::kDebugDrawing, std::move(record));
  display_item.SetSkippedCache();

  if (property_tree_state) {
    DCHECK(RuntimeEnabledFeatures::SlimmingPaintV175Enabled());
    current_paint_artifact_.PaintChunks().emplace_back(
        display_item_list.size() - 1, display_item_list.size(),
        display_item.GetId(), *property_tree_state);
  }
}

void PropertyTreeManager::CreateCompositorScrollNode(
    const ScrollPaintPropertyNode* scroll_node,
    const cc::TransformNode& scroll_offset_translation) {
  DCHECK(!scroll_node_map_.Contains(scroll_node));

  auto parent_it = scroll_node_map_.find(scroll_node->Parent());
  DCHECK(parent_it != scroll_node_map_.end());
  int parent_id = parent_it->value;
  int id = GetScrollTree().Insert(cc::ScrollNode(), parent_id);

  cc::ScrollNode& compositor_node = *GetScrollTree().Node(id);
  compositor_node.scrollable = true;

  compositor_node.container_bounds =
      static_cast<gfx::Size>(scroll_node->ContainerRect().Size());
  compositor_node.bounds =
      static_cast<gfx::Size>(scroll_node->ContentsRect().Size());
  compositor_node.user_scrollable_horizontal =
      scroll_node->UserScrollableHorizontal();
  compositor_node.user_scrollable_vertical =
      scroll_node->UserScrollableVertical();
  compositor_node.main_thread_scrolling_reasons =
      scroll_node->GetMainThreadScrollingReasons();

  auto compositor_element_id = scroll_node->GetCompositorElementId();
  if (compositor_element_id) {
    compositor_node.element_id = compositor_element_id;
    property_trees_.element_id_to_scroll_node_index[compositor_element_id] = id;
  }

  compositor_node.transform_id = scroll_offset_translation.id;


  auto result = scroll_node_map_.Set(scroll_node, id);
  DCHECK(result.is_new_entry);

  GetScrollTree().SetScrollOffset(compositor_element_id,
                                  scroll_offset_translation.scroll_offset);
  GetScrollTree().set_needs_update(true);
}

void PaintController::SetTracksRasterInvalidations(bool value) {
  if (value) {
    raster_invalidation_tracking_info_ =
        std::make_unique<RasterInvalidationTrackingInfo>();

    DCHECK(new_display_item_list_.IsEmpty());
    for (const auto& item : current_paint_artifact_.GetDisplayItemList()) {
      raster_invalidation_tracking_info_->old_client_debug_names.Set(
          &item.Client(), item.Client().DebugName());
    }
  } else if (!RasterInvalidationTracking::ShouldAlwaysTrack()) {
    raster_invalidation_tracking_info_ = nullptr;
  }
}

void BlockPainter::Paint(const PaintInfo& paint_info,
                         const LayoutPoint& paint_offset) {
  AdjustPaintOffsetScope adjustment(layout_block_, paint_info, paint_offset);
  auto adjusted_paint_offset = adjustment.AdjustedPaintOffset();
  auto& local_paint_info = adjustment.MutablePaintInfo();

  if (!IntersectsPaintRect(local_paint_info, adjusted_paint_offset))
    return;

  PaintPhase original_phase = local_paint_info.phase;

  ContentsClipBehavior contents_clip_behavior = kForceContentsClip;
  if (layout_block_.ShouldClipOverflow() && !layout_block_.HasControlClip() &&
      !layout_block_.ShouldPaintCarets())
    contents_clip_behavior = kSkipContentsClipIfPossible;

  if (original_phase == PaintPhase::kOutline) {
    local_paint_info.phase = PaintPhase::kDescendantOutlinesOnly;
  } else if (ShouldPaintSelfBlockBackground(original_phase)) {
    local_paint_info.phase = PaintPhase::kSelfBlockBackgroundOnly;
    layout_block_.PaintObject(local_paint_info, adjusted_paint_offset);
    if (ShouldPaintDescendantBlockBackgrounds(original_phase))
      local_paint_info.phase = PaintPhase::kDescendantBlockBackgroundsOnly;
  }

  if (original_phase != PaintPhase::kSelfBlockBackgroundOnly &&
      original_phase != PaintPhase::kSelfOutlineOnly) {
    base::Optional<BoxClipper> clipper;
    if (!layout_block_.IsSVGForeignObject() ||
        RuntimeEnabledFeatures::SlimmingPaintV175Enabled()) {
      clipper.emplace(layout_block_, local_paint_info, adjusted_paint_offset,
                      contents_clip_behavior);
    }
    layout_block_.PaintObject(local_paint_info, adjusted_paint_offset);
  }

  if (ShouldPaintSelfOutline(original_phase)) {
    local_paint_info.phase = PaintPhase::kSelfOutlineOnly;
    layout_block_.PaintObject(local_paint_info, adjusted_paint_offset);
  }

  local_paint_info.phase = original_phase;
  PaintOverflowControlsIfNeeded(local_paint_info, adjusted_paint_offset);
}

  static testing::Matcher<const cc::PaintOpBuffer&> Make(
      std::initializer_list<cc::PaintOpType> args) {
    return testing::MakeMatcher(new PaintRecordMatcher(args));
  }

void ConversionContext::PushState(StateEntry::PairedType type,
                                  int saved_count) {
  state_stack_.emplace_back(StateEntry{type, saved_count, current_transform_,
                                       current_clip_, current_effect_,
                                       previous_transform_});
  previous_transform_ = nullptr;
}

  static PaintChunk Chunk(const PropertyTreeState& state) {
    DEFINE_STATIC_LOCAL(FakeDisplayItemClient, fake_client, ());
    DEFINE_STATIC_LOCAL(
        base::Optional<PaintChunk::Id>, id,
        (PaintChunk::Id(fake_client, DisplayItem::kDrawingFirst)));
    PaintChunk chunk(0, 0, *id, state);
    return chunk;
  }

void FragmentPaintPropertyTreeBuilder::UpdateCssClip() {
DCHECK(properties_);

if (NeedsPaintPropertyUpdate()) {
if (NeedsCssClip(object_)) {
// Create clip node for descendants that are not fixed position.
// We don't have to setup context.absolutePosition.clip here because this
// object must be a container for absolute position descendants, and will
// copy from in-flow context later at updateOutOfFlowContext() step.
DCHECK(object_.CanContainAbsolutePositionObjects());
OnUpdateClip(properties_->UpdateCssClip(
          context_.current.clip,
ClipPaintPropertyNode::State{context_.current.transform,
ToClipRect(ToLayoutBox(object_).ClipRect(
context_.current.paint_offset))}));
} else {
OnClearClip(properties_->ClearCssClip());
}
}

if (properties_->CssClip())
context_.current.clip = properties_->CssClip();
}

void DrawPath(GraphicsContext& context,
              DisplayItemClient& client,
              DisplayItem::Type type,
              unsigned count) {
  if (DrawingRecorder::UseCachedDrawingIfPossible(context, client, type))
    return;

  DrawingRecorder recorder(context, client, type);
  SkPath path;
  path.moveTo(0, 0);
  path.lineTo(0, 100);
  path.lineTo(50, 50);
  path.lineTo(100, 100);
  path.lineTo(100, 0);
  path.close();
  PaintFlags flags;
  flags.setAntiAlias(true);
  for (unsigned i = 0; i < count; i++)
    context.DrawPath(path, flags);
}

void ConversionContext::Convert(const PaintChunkSubset& paint_chunks,
const DisplayItemList& display_items) {
for (const auto& chunk : paint_chunks) {
const auto& chunk_state = chunk.properties;
bool switched_to_chunk_state = false;

for (const auto& item : display_items.ItemsInPaintChunk(chunk)) {
DCHECK(item.IsDrawing());
auto record =
static_cast<const DrawingDisplayItem&>(item).GetPaintRecord();
// If we have an empty paint record, then we would prefer not to draw it.
// However, if we also have a non-root effect, it means that the filter
// applied might draw something even if the record is empty. We need to
// "draw" this record in order to ensure that the effect has correct
// visual rects.
if ((!record || record->size() == 0) &&
          chunk_state.Effect() == EffectPaintPropertyNode::Root()) {
continue;
}

TranslateForLayerOffsetOnce();
if (!switched_to_chunk_state) {
SwitchToChunkState(chunk);
switched_to_chunk_state = true;
}

cc_list_.StartPaint();
if (record && record->size() != 0)
cc_list_.push<cc::DrawRecordOp>(std::move(record));
cc_list_.EndPaintOfUnpaired(
chunk_to_layer_mapper_.MapVisualRect(item.VisualRect()));
}
UpdateEffectBounds(chunk.bounds, chunk_state.Transform());
}
}

 const CompositorElementId PropertyTreeState::GetCompositorElementId(
    const CompositorElementIdSet& element_ids) const {
  if (Effect()->GetCompositorElementId() &&
      !element_ids.Contains(Effect()->GetCompositorElementId()))
    return Effect()->GetCompositorElementId();
  if (Transform()->GetCompositorElementId() &&
      !element_ids.Contains(Transform()->GetCompositorElementId()))
    return Transform()->GetCompositorElementId();
  return CompositorElementId();
}

DisplayItemClient& TestPaintArtifact::Client(size_t i) const {
  return *dummy_clients_[i];
}

  int LayerIndex(const cc::Layer* layer) {
    for (size_t i = 0; i < RootLayer()->children().size(); ++i) {
      if (RootLayer()->children()[i] == layer)
        return i;
    }
    return -1;
   }

void PaintArtifactCompositor::PendingLayer::Upcast(
    const PropertyTreeState& new_state) {
  DCHECK(!requires_own_layer);
  FloatClipRect float_clip_rect(bounds);
  GeometryMapper::LocalToAncestorVisualRect(property_tree_state, new_state,
                                            float_clip_rect);
  bounds = float_clip_rect.Rect();

  property_tree_state = new_state;
  rect_known_to_be_opaque = FloatRect();
}

static bool NeedsTransform(const LayoutObject& object) {
  if (RuntimeEnabledFeatures::SlimmingPaintV2Enabled() &&
      object.StyleRef().BackfaceVisibility() == EBackfaceVisibility::kHidden)
    return true;

  if (!object.IsBox())
    return false;
  return object.StyleRef().HasTransform() || object.StyleRef().Preserves3D() ||
         CompositingReasonsForTransform(ToLayoutBox(object)) !=
             CompositingReason::kNone;
}

  bool PaintWithoutCommit(GraphicsLayer& layer, const IntRect* interest_rect) {
    return layer.PaintWithoutCommit(interest_rect);
  }

void PaintController::ShowSequenceUnderInvalidationError(
    const char* reason,
    const DisplayItemClient& client,
    int start,
    int end) {
  LOG(ERROR) << under_invalidation_message_prefix_ << " " << reason;
  LOG(ERROR) << "Subsequence client: " << client.DebugName();
#if DCHECK_IS_ON()
  ShowDebugData();
#else
  LOG(ERROR) << "Run a build with DCHECK on to get more details.";
#endif
  LOG(ERROR) << "See http://crbug.com/619103.";
}

  FakeScrollClient() : did_scroll_count(0) {}

void FragmentPaintPropertyTreeBuilder::UpdatePaintOffsetTranslation(
const base::Optional<IntPoint>& paint_offset_translation) {
DCHECK(properties_);

if (paint_offset_translation) {
TransformPaintPropertyNode::State state;
state.matrix.Translate(paint_offset_translation->X(),
paint_offset_translation->Y());
state.flattens_inherited_transform =
context_.current.should_flatten_inherited_transform;
if (RuntimeEnabledFeatures::SlimmingPaintV2Enabled() ||
RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled())
state.rendering_context_id = context_.current.rendering_context_id;
OnUpdate(properties_->UpdatePaintOffsetTranslation(
        context_.current.transform, std::move(state)));
context_.current.transform = properties_->PaintOffsetTranslation();
if (object_.IsLayoutView()) {
context_.absolute_position.transform =
properties_->PaintOffsetTranslation();
context_.fixed_position.transform = properties_->PaintOffsetTranslation();
}
} else {
OnClear(properties_->ClearPaintOffsetTranslation());
}
}

  void AppendRestore(size_t n) {
    cc_list_.StartPaint();
    while (n--)
      cc_list_.push<cc::RestoreOp>();
    cc_list_.EndPaintOfPairedEnd();
  }

  void TestChangeDrawingInSubsequence() {
    FakeDisplayItemClient first("first");
    GraphicsContext context(GetPaintController());
    InitRootChunk();
    {
      SubsequenceRecorder r(context, first);
      first.SetVisualRect(LayoutRect(100, 100, 300, 300));
      DrawRect(context, first, kBackgroundType, FloatRect(100, 100, 300, 300));
      DrawRect(context, first, kForegroundType, FloatRect(100, 100, 300, 300));
    }
    GetPaintController().CommitNewDisplayItems();

    InitRootChunk();
    {
      EXPECT_FALSE(
          SubsequenceRecorder::UseCachedSubsequenceIfPossible(context, first));
      SubsequenceRecorder r(context, first);
      first.SetVisualRect(LayoutRect(200, 200, 300, 300));
      DrawRect(context, first, kBackgroundType, FloatRect(200, 200, 300, 300));
      DrawRect(context, first, kForegroundType, FloatRect(100, 100, 300, 300));
    }
    GetPaintController().CommitNewDisplayItems();
  }

void PaintController::SetImagePainted() {
  frame_first_paints_.back().image_painted = true;
}

CompositedLayerRasterInvalidator::ChunkPropertiesChanged(
    const RefCountedPropertyTreeState& new_chunk_state,
const PaintChunkInfo& new_chunk,
const PaintChunkInfo& old_chunk,
const PropertyTreeState& layer_state) const {
// Special case for transform changes because we may create or delete some
// transform nodes when no raster invalidation is needed. For example, when
// a composited layer previously not transformed now gets transformed.
// Check for real accumulated transform change instead.
if (!ApproximatelyEqual(new_chunk.chunk_to_layer_transform,
old_chunk.chunk_to_layer_transform))
return PaintInvalidationReason::kPaintProperty;

// Treat the chunk property as changed if the effect node pointer is
// different, or the effect node's value changed between the layer state and
// the chunk state.
if (new_chunk_state.Effect() != old_chunk.effect_state ||
new_chunk_state.Effect()->Changed(*layer_state.Effect()))
return PaintInvalidationReason::kPaintProperty;

// Check for accumulated clip rect change, if the clip rects are tight.
if (new_chunk.chunk_to_layer_clip.IsTight() &&
old_chunk.chunk_to_layer_clip.IsTight()) {
if (new_chunk.chunk_to_layer_clip == old_chunk.chunk_to_layer_clip)
return PaintInvalidationReason::kNone;
// Ignore differences out of the current layer bounds.
if (ClipByLayerBounds(new_chunk.chunk_to_layer_clip.Rect()) ==
ClipByLayerBounds(old_chunk.chunk_to_layer_clip.Rect()))
return PaintInvalidationReason::kNone;
return PaintInvalidationReason::kIncremental;
}

// Otherwise treat the chunk property as changed if the clip node pointer is
// different, or the clip node's value changed between the layer state and the
// chunk state.
if (new_chunk_state.Clip() != old_chunk.clip_state ||
new_chunk_state.Clip()->Changed(*layer_state.Clip()))
return PaintInvalidationReason::kPaintProperty;

return PaintInvalidationReason::kNone;
}

bool BlockPainter::IntersectsPaintRect(
    const PaintInfo& paint_info,
    const LayoutPoint& adjusted_paint_offset) const {
  LayoutRect overflow_rect;
  if (paint_info.IsPrinting() && layout_block_.IsAnonymousBlock() &&
      layout_block_.ChildrenInline()) {
    Vector<LayoutRect> rects;
    layout_block_.AddElementVisualOverflowRects(rects, LayoutPoint());
    overflow_rect = UnionRect(rects);
  }
  overflow_rect.Unite(layout_block_.VisualOverflowRect());

  bool uses_composited_scrolling = layout_block_.HasOverflowModel() &&
                                   layout_block_.UsesCompositedScrolling();

  if (uses_composited_scrolling) {
    LayoutRect layout_overflow_rect = layout_block_.LayoutOverflowRect();
    overflow_rect.Unite(layout_overflow_rect);
  }
  layout_block_.FlipForWritingMode(overflow_rect);

  if (uses_composited_scrolling) {
    overflow_rect.Move(-layout_block_.ScrolledContentOffset());
  }

  overflow_rect.MoveBy(adjusted_paint_offset);
  return paint_info.GetCullRect().IntersectsCullRect(overflow_rect);
}

bool GeometryMapper::LocalToAncestorVisualRectInternal(
    const PropertyTreeState& local_state,
    const PropertyTreeState& ancestor_state,
    FloatClipRect& rect_to_map,
    OverlayScrollbarClipBehavior clip_behavior,
    InclusiveIntersectOrNot inclusive_behavior,
    bool& success) {
  if (local_state == ancestor_state) {
    success = true;
    return true;
  }

  if (local_state.Effect() != ancestor_state.Effect()) {
    return SlowLocalToAncestorVisualRectWithEffects(
        local_state, ancestor_state, rect_to_map, clip_behavior,
        inclusive_behavior, success);
  }

  const auto& transform_matrix = SourceToDestinationProjectionInternal(
      local_state.Transform(), ancestor_state.Transform(), success);
  if (!success) {
    success = true;
    rect_to_map = FloatClipRect(FloatRect());
    return false;
  }
  rect_to_map.Map(transform_matrix);

  FloatClipRect clip_rect = LocalToAncestorClipRectInternal(
      local_state.Clip(), ancestor_state.Clip(), ancestor_state.Transform(),
      clip_behavior, inclusive_behavior, success);
  if (success) {
    if (inclusive_behavior == kInclusiveIntersect)
      return rect_to_map.InclusiveIntersect(clip_rect);
    rect_to_map.Intersect(clip_rect);
    return !rect_to_map.Rect().IsEmpty();
  }

  if (!RuntimeEnabledFeatures::SlimmingPaintV2Enabled()) {
    success = true;
    rect_to_map.ClearIsTight();
  }
  return !rect_to_map.Rect().IsEmpty();
}

bool PaintPropertyTreeBuilder::UpdateForChildren() {
  if (!ObjectTypeMightNeedPaintProperties())
    return false;

  bool property_changed = false;
  bool property_added_or_removed = false;
  auto* fragment_data = &object_.GetMutableForPainting().FirstFragment();
  for (auto& fragment_context : context_.fragments) {
    FragmentPaintPropertyTreeBuilder builder(object_, context_,
                                             fragment_context, *fragment_data);
    builder.UpdateForChildren();
    property_changed |= builder.PropertyChanged();
    property_added_or_removed |= builder.PropertyAddedOrRemoved();
    context_.force_subtree_update |= object_.SubtreeNeedsPaintPropertyUpdate();
    fragment_data = fragment_data->NextFragment();
  }
  DCHECK(!fragment_data);

  if (object_.CanContainAbsolutePositionObjects())
    context_.container_for_absolute_position = &object_;
  if (object_.CanContainFixedPositionObjects())
    context_.container_for_fixed_position = &object_;

  if (property_added_or_removed &&
      RuntimeEnabledFeatures::SlimmingPaintV175Enabled())
    context_.painting_layer->SetNeedsRepaint();

  return property_changed;
}

void PaintController::InvalidateAll() {
  DCHECK(!RuntimeEnabledFeatures::SlimmingPaintV2Enabled());
  InvalidateAllInternal();
}

static bool NeedsFilter(const LayoutObject& object) {
  if (object.IsBoxModelObject() && ToLayoutBoxModelObject(object).Layer() &&
      (object.StyleRef().HasFilter() || object.HasReflection()))
    return true;
  if (object.IsLayoutImage() && ToLayoutImage(object).ShouldInvertColor())
    return true;
  return false;
}

bool GeometryMapper::PointVisibleInAncestorSpace(
    const PropertyTreeState& local_state,
    const PropertyTreeState& ancestor_state,
    const FloatPoint& local_point) {
  for (const auto* clip = local_state.Clip();
       clip && clip != ancestor_state.Clip(); clip = clip->Parent()) {
    FloatPoint mapped_point =
        SourceToDestinationProjection(local_state.Transform(),
                                      clip->LocalTransformSpace())
            .MapPoint(local_point);

    if (!clip->ClipRect().IntersectsQuad(
            FloatRect(mapped_point, FloatSize(1, 1))))
      return false;

    if (clip->ClipPath() && !clip->ClipPath()->Contains(mapped_point))
      return false;
  }

  return true;
}

void CompositedLayerRasterInvalidator::FullyInvalidateOldChunk(
    const PaintChunkInfo& info,
    PaintInvalidationReason reason) {
  String debug_name;
  if (tracking_info_)
    debug_name = tracking_info_->old_client_debug_names.at(&info.id.client);
  AddRasterInvalidation(info.bounds_in_layer, &info.id.client, reason,
                        &debug_name);
}

const PaintArtifact& PaintController::GetPaintArtifact() const {
  DCHECK(new_display_item_list_.IsEmpty());
  DCHECK(new_paint_chunks_.IsInInitialState());
  return current_paint_artifact_;
}

static bool NeedsEffect(const LayoutObject& object) {
  const ComputedStyle& style = object.StyleRef();

  const bool is_css_isolated_group =
      object.IsBoxModelObject() && style.IsStackingContext();

  if (!is_css_isolated_group && !object.IsSVG())
    return false;

  if (object.IsSVG()) {
    if (object.IsSVGRoot() && is_css_isolated_group &&
        object.HasNonIsolatedBlendingDescendants())
      return true;
    if (SVGLayoutSupport::IsIsolationRequired(&object))
      return true;
    if (SVGResources* resources =
            SVGResourcesCache::CachedResourcesForLayoutObject(object)) {
      if (resources->Masker()) {
        return true;
      }
    }
  } else if (object.IsBoxModelObject()) {
    if (PaintLayer* layer = ToLayoutBoxModelObject(object).Layer()) {
      if (layer->HasNonIsolatedDescendantWithBlendMode())
        return true;
    }
  }

  SkBlendMode blend_mode = object.IsBlendingAllowed()
                               ? WebCoreCompositeToSkiaComposite(
                                     kCompositeSourceOver, style.GetBlendMode())
                               : SkBlendMode::kSrcOver;
  if (blend_mode != SkBlendMode::kSrcOver)
    return true;

  float opacity = style.Opacity();
  if (opacity != 1.0f)
    return true;

  if (CompositingReasonFinder::RequiresCompositingForOpacityAnimation(style))
    return true;

  if (object.StyleRef().HasMask())
    return true;

  if (object.HasLayer() &&
      ToLayoutBoxModelObject(object).Layer()->GetCompositedLayerMapping() &&
      ToLayoutBoxModelObject(object)
          .Layer()
          ->GetCompositedLayerMapping()
          ->MaskLayer()) {
    return true;
  }

  if (object.StyleRef().ClipPath() &&
      object.FirstFragment().ClipPathBoundingBox() &&
      !object.FirstFragment().ClipPathPath()) {
    return true;
  }

  return false;
}

void PaintArtifactCompositor::PendingLayer::Merge(const PendingLayer& guest) {
  DCHECK(!requires_own_layer && !guest.requires_own_layer);

  paint_chunk_indices.AppendVector(guest.paint_chunk_indices);
  FloatClipRect guest_bounds_in_home(guest.bounds);
  GeometryMapper::LocalToAncestorVisualRect(
      guest.property_tree_state, property_tree_state, guest_bounds_in_home);
  bounds.Unite(guest_bounds_in_home.Rect());
}

    UpdateRepeatingTableFooterPaintOffsetAdjustment() {
  const auto& section = ToLayoutTableSection(object_);
  DCHECK(section.IsRepeatingFooterGroup());

  LayoutUnit fragment_height;
  LayoutUnit original_offset_in_flow_thread =
      context_.repeating_table_section_bounding_box.MaxY() -
      section.LogicalHeight();
  LayoutUnit original_offset_in_fragment;
  const LayoutFlowThread* flow_thread = nullptr;
  if (const auto* pagination_layer =
          context_.painting_layer->EnclosingPaginationLayer()) {
    flow_thread = &ToLayoutFlowThread(pagination_layer->GetLayoutObject());
    if (!flow_thread->IsPageLogicalHeightKnown())
      return;

    fragment_height =
        flow_thread->PageLogicalHeightForOffset(original_offset_in_flow_thread);
    original_offset_in_fragment =
        fragment_height - flow_thread->PageRemainingLogicalHeightForOffset(
                              original_offset_in_flow_thread,
                              LayoutBox::kAssociateWithLatterPage);
  } else {
    fragment_height = object_.View()->PageLogicalHeight();
    original_offset_in_fragment =
        IntMod(original_offset_in_flow_thread, fragment_height);
  }

  const auto& table = *section.Table();
  auto repeating_offset_in_fragment = fragment_height -
                                      table.RowOffsetFromRepeatingFooter() -
                                      table.VBorderSpacing();
  if (table.ShouldCollapseBorders())
    repeating_offset_in_fragment -= table.BorderBottom();

  auto adjustment = repeating_offset_in_fragment - original_offset_in_fragment;

  auto fragment_offset_in_flow_thread =
      original_offset_in_flow_thread - original_offset_in_fragment;
  for (auto i = context_.fragments.size(); i > 0; --i) {
    auto& fragment_context = context_.fragments[i - 1];
    fragment_context.repeating_paint_offset_adjustment = LayoutSize();
    if (i != context_.fragments.size())
      fragment_context.repeating_paint_offset_adjustment.SetHeight(adjustment);

    adjustment -= fragment_height;
    fragment_offset_in_flow_thread -= fragment_height;

    if (flow_thread) {
      fragment_height = flow_thread->PageLogicalHeightForOffset(
          fragment_offset_in_flow_thread);
    }
  }
}

  cc::Layer* GetLayer() const { return layer_.get(); }

  void TestInvalidationInSubsequence() {
    FakeDisplayItemClient container("container");
    FakeDisplayItemClient content("content");
    GraphicsContext context(GetPaintController());

    InitRootChunk();
    {
      SubsequenceRecorder r(context, container);
      DrawRect(context, content, kBackgroundType,
               FloatRect(100, 100, 300, 300));
    }
    GetPaintController().CommitNewDisplayItems();

    content.SetDisplayItemsUncached();
    InitRootChunk();
    {
      EXPECT_FALSE(SubsequenceRecorder::UseCachedSubsequenceIfPossible(
          context, container));
      SubsequenceRecorder r(context, container);
      DrawRect(context, content, kBackgroundType,
               FloatRect(100, 100, 300, 300));
    }
    GetPaintController().CommitNewDisplayItems();
  }

void FragmentPaintPropertyTreeBuilder::UpdateOverflowControlsClip() {
DCHECK(properties_);

if (!NeedsPaintPropertyUpdate())
return;

if (NeedsOverflowControlsClip()) {
// Clip overflow controls to the border box rect. Not wrapped with
// OnUpdateClip() because this clip doesn't affect descendants.
properties_->UpdateOverflowControlsClip(
        context_.current.clip,
ClipPaintPropertyNode::State{
context_.current.transform,
ToClipRect(LayoutRect(context_.current.paint_offset,
ToLayoutBox(object_).Size()))});
} else {
properties_->ClearOverflowControlsClip();
}

// No need to set force_subtree_update and clip_changed because
// OverflowControlsClip applies to overflow controls only, not descendants.
// We also don't walk into custom scrollbars in PrePaintTreeWalk and
// LayoutObjects under custom scrollbars don't support paint properties.
}

  void Update(const PaintArtifact& artifact) {
    CompositorElementIdSet element_ids;
    Update(artifact, element_ids);
  }

void PaintController::CommitNewDisplayItems() {
  TRACE_EVENT2("blink,benchmark", "PaintController::commitNewDisplayItems",
               "current_display_list_size",
               (int)current_paint_artifact_.GetDisplayItemList().size(),
               "num_non_cached_new_items",
               (int)new_display_item_list_.size() - num_cached_new_items_);

  num_cached_new_items_ = 0;
#if DCHECK_IS_ON()
  new_display_item_indices_by_client_.clear();
  new_paint_chunk_indices_by_client_.clear();
#endif

  if (RuntimeEnabledFeatures::SlimmingPaintV175Enabled() &&
      !new_display_item_list_.IsEmpty())
    GenerateRasterInvalidations(new_paint_chunks_.LastChunk());

  auto old_cache_generation = current_cache_generation_;
  current_cache_generation_ =
      DisplayItemClient::CacheGenerationOrInvalidationReason::Next();

  new_cached_subsequences_.swap(current_cached_subsequences_);
  new_cached_subsequences_.clear();
  last_cached_subsequence_end_ = 0;
  for (auto& item : current_cached_subsequences_)
    item.key->SetDisplayItemsCached(current_cache_generation_);

  Vector<const DisplayItemClient*> skipped_cache_clients;
  for (const auto& item : new_display_item_list_) {
    const auto& client = item.Client();
    if (RuntimeEnabledFeatures::SlimmingPaintV175Enabled())
      client.ClearPartialInvalidationRect();

    if (item.IsCacheable()) {
      client.SetDisplayItemsCached(current_cache_generation_);
    } else {
      if (client.IsJustCreated())
        client.ClearIsJustCreated();
      if (item.SkippedCache())
        skipped_cache_clients.push_back(&item.Client());
    }
  }

  for (auto* client : skipped_cache_clients) {
    if (client->DisplayItemsAreCached(old_cache_generation) ||
        client->DisplayItemsAreCached(current_cache_generation_))
      client->SetDisplayItemsUncached();
  }

  new_display_item_list_.ShrinkToFit();

  current_paint_artifact_ = PaintArtifact(std::move(new_display_item_list_),
                                          new_paint_chunks_.ReleaseData());

  ResetCurrentListIndices();
  out_of_order_item_indices_.clear();
  out_of_order_chunk_indices_.clear();
  items_moved_into_new_list_.clear();

  if (RuntimeEnabledFeatures::SlimmingPaintV175Enabled()) {
    for (const auto& chunk : current_paint_artifact_.PaintChunks()) {
      if (chunk.id.client.IsJustCreated())
        chunk.id.client.ClearIsJustCreated();
    }
  }

  new_display_item_list_ = DisplayItemList(0);

#if DCHECK_IS_ON()
  num_sequential_matches_ = 0;
  num_out_of_order_matches_ = 0;
  num_indexed_items_ = 0;
#endif

  if (raster_invalidation_tracking_info_) {
    raster_invalidation_tracking_info_->old_client_debug_names.clear();
    std::swap(raster_invalidation_tracking_info_->old_client_debug_names,
              raster_invalidation_tracking_info_->new_client_debug_names);
  }

#if DCHECK_IS_ON()
  if (VLOG_IS_ON(2)) {
    LOG(ERROR) << "PaintController::CommitNewDisplayItems() done";
    if (VLOG_IS_ON(3))
      ShowDebugDataWithRecords();
    else
      ShowDebugData();
  }
#endif
}

size_t PaintController::FindOutOfOrderCachedItemForward(
    const DisplayItem::Id& id) {
  for (size_t i = next_item_to_index_;
       i < current_paint_artifact_.GetDisplayItemList().size(); ++i) {
    const DisplayItem& item = current_paint_artifact_.GetDisplayItemList()[i];
    if (item.IsTombstone())
      continue;
    if (id == item.GetId()) {
#if DCHECK_IS_ON()
      ++num_sequential_matches_;
#endif
      return i;
    }
    if (item.IsCacheable()) {
#if DCHECK_IS_ON()
      ++num_indexed_items_;
#endif
      AddToIndicesByClientMap(item.Client(), i, out_of_order_item_indices_);
    }
  }

  if (RuntimeEnabledFeatures::PaintUnderInvalidationCheckingEnabled()) {
#if DCHECK_IS_ON()
    ShowDebugData();
#endif
    LOG(WARNING) << "Can't find cached display item: " << id.client.DebugName()
                 << " " << id.ToString();
  }
  return kNotFound;
}

  static IntRect ChunkRectToLayer(const FloatRect& rect,
                                  const IntPoint& chunk_offset_from_layer) {
    FloatRect r = rect;
    r.MoveBy(chunk_offset_from_layer);
    return EnclosingIntRect(r);
  }

void PrintTo(const Vector<cc::PaintOpType>& ops, std::ostream* os) {
  *os << "[";
  bool first = true;
  for (auto op : ops) {
    if (first)
      first = false;
    else
      *os << ", ";
    *os << op;
  }
  *os << "]";
}

void ViewPainterTest::RunFixedBackgroundTest(
    bool prefer_compositing_to_lcd_text) {
  if (RuntimeEnabledFeatures::SlimmingPaintV2Enabled())
    return;

  if (prefer_compositing_to_lcd_text) {
    Settings* settings = GetDocument().GetFrame()->GetSettings();
    settings->SetPreferCompositingToLCDTextEnabled(true);
  }
  SetBodyInnerHTML(R"HTML(
    <style>
      ::-webkit-scrollbar { display: none; }
      body {
        margin: 0;
        width: 1200px;
        height: 900px;
        background: radial-gradient(
          circle at 100px 100px, blue, transparent 200px) fixed;
      }
    </style>
  )HTML");

  LocalFrameView* frame_view = GetDocument().View();
  ScrollableArea* layout_viewport = frame_view->LayoutViewportScrollableArea();

  ScrollOffset scroll_offset(200, 150);
  layout_viewport->SetScrollOffset(scroll_offset, kUserScroll);
  frame_view->UpdateAllLifecyclePhases();

  CompositedLayerMapping* clm =
      GetLayoutView().Layer()->GetCompositedLayerMapping();

  GraphicsLayer* layer_for_background;
  if (prefer_compositing_to_lcd_text) {
    layer_for_background = clm->MainGraphicsLayer();
  } else {
    layer_for_background = clm->ScrollingContentsLayer();
  }
  const DisplayItemList& display_items =
      layer_for_background->GetPaintController().GetDisplayItemList();
  const DisplayItem& background = display_items[0];
  EXPECT_EQ(background.GetType(), kDocumentBackgroundType);
  DisplayItemClient* expected_client;
  if (!prefer_compositing_to_lcd_text)
    expected_client = GetLayoutView().Layer()->GraphicsLayerBacking();
  else
    expected_client = &GetLayoutView();
  EXPECT_EQ(&background.Client(), expected_client);

  sk_sp<const PaintRecord> record =
      static_cast<const DrawingDisplayItem&>(background).GetPaintRecord();
  ASSERT_EQ(record->size(), 2u);
  cc::PaintOpBuffer::Iterator it(record.get());
  ASSERT_EQ((*++it)->GetType(), cc::PaintOpType::DrawRect);

  SkRect rect = static_cast<const cc::DrawRectOp*>(*it)->rect;
  ASSERT_EQ(prefer_compositing_to_lcd_text ? ScrollOffset() : scroll_offset,
            ScrollOffset(rect.fLeft, rect.fTop));
}

void ConversionContext::SwitchToClip(const ClipPaintPropertyNode* target_clip) {
  if (target_clip == current_clip_)
    return;

  const ClipPaintPropertyNode* lca_clip =
      &LowestCommonAncestor(*target_clip, *current_clip_);
  while (current_clip_ != lca_clip) {
#if DCHECK_IS_ON()
    DCHECK(state_stack_.size() && state_stack_.back().type == StateEntry::kClip)
        << "Error: Chunk has a clip that escaped its layer's or effect's clip."
        << "\ntarget_clip:\n"
        << target_clip->ToTreeString().Utf8().data() << "current_clip_:\n"
        << current_clip_->ToTreeString().Utf8().data();
#endif
    if (!state_stack_.size() || state_stack_.back().type != StateEntry::kClip)
      break;
    current_clip_ = current_clip_->Parent();
    StateEntry& previous_state = state_stack_.back();
    if (current_clip_ == lca_clip) {
      current_clip_ = lca_clip = previous_state.clip;
    }
    if (current_clip_ == previous_state.clip)
      EndClip();
  }

  if (target_clip == current_clip_)
    return;

  Vector<const ClipPaintPropertyNode*, 1u> pending_clips;
  for (const ClipPaintPropertyNode* clip = target_clip; clip != current_clip_;
       clip = clip->Parent()) {
    if (!clip)
      break;
    pending_clips.push_back(clip);
  }

  DCHECK(pending_clips.size());
  auto pending_combined_clip_rect = pending_clips.back()->ClipRect();
  const auto* lowest_combined_clip_node = pending_clips.back();
  for (size_t i = pending_clips.size() - 1; i--;) {
    const auto* sub_clip = pending_clips[i];
    if (CombineClip(sub_clip, pending_combined_clip_rect)) {
      lowest_combined_clip_node = sub_clip;
    } else {
      StartClip(pending_combined_clip_rect, lowest_combined_clip_node);
      pending_combined_clip_rect = sub_clip->ClipRect();
      lowest_combined_clip_node = sub_clip;
    }
  }
  StartClip(pending_combined_clip_rect, lowest_combined_clip_node);

  DCHECK_EQ(current_clip_, target_clip);
}

TestPaintArtifact& TestPaintArtifact::Chunk(
    scoped_refptr<const TransformPaintPropertyNode> transform,
    scoped_refptr<const ClipPaintPropertyNode> clip,
    scoped_refptr<const EffectPaintPropertyNode> effect) {
return Chunk(NewClient(), transform, clip, effect);
}

bool PaintController::LastDisplayItemIsNoopBegin() const {
  DCHECK(!RuntimeEnabledFeatures::SlimmingPaintV175Enabled());

  if (new_display_item_list_.IsEmpty())
    return false;

  const auto& last_display_item = new_display_item_list_.Last();
  return last_display_item.IsBegin() && !last_display_item.DrawsContent();
}

static bool NeedsPaintOffsetTranslation(const LayoutObject& object) {
  if (!object.IsBoxModelObject())
    return false;

  if (object.IsSVGForeignObject())
    return false;

  const LayoutBoxModelObject& box_model = ToLayoutBoxModelObject(object);

  if (box_model.IsLayoutView()) {
    return true;
  }

  if (box_model.HasLayer() && box_model.Layer()->PaintsWithTransform(
                                  kGlobalPaintFlattenCompositingLayers)) {
    return true;
  }
  if (NeedsScrollOrScrollTranslation(object))
    return true;
  if (NeedsPaintOffsetTranslationForScrollbars(box_model))
    return true;
  if (NeedsSVGLocalToBorderBoxTransform(object))
    return true;

  if (!RuntimeEnabledFeatures::SlimmingPaintV2Enabled() &&
      (object.IsLayoutBlock() || object.IsLayoutReplaced()) &&
      object.HasLayer() &&
      !ToLayoutBoxModelObject(object).Layer()->EnclosingPaginationLayer() &&
      object.GetCompositingState() == kPaintsIntoOwnBacking)
    return true;

  return false;
}

void FragmentPaintPropertyTreeBuilder::UpdateForChildren() {
#if DCHECK_IS_ON()
  FindObjectPropertiesNeedingUpdateScope check_needs_update_scope(
      object_, fragment_data_, full_context_.force_subtree_update);
#endif

  if (properties_) {
    UpdateInnerBorderRadiusClip();
    UpdateOverflowClip();
    UpdatePerspective();
    UpdateSvgLocalToBorderBoxTransform();
    UpdateScrollAndScrollTranslation();
  }
  UpdateOutOfFlowContext();
}

  void TestLessDrawing() {
    FakeDisplayItemClient first("first");
    GraphicsContext context(GetPaintController());

    InitRootChunk();
    DrawRect(context, first, kBackgroundType, FloatRect(100, 100, 300, 300));
    DrawRect(context, first, kForegroundType, FloatRect(100, 100, 300, 300));
    GetPaintController().CommitNewDisplayItems();

    InitRootChunk();
    DrawRect(context, first, kBackgroundType, FloatRect(100, 100, 300, 300));
    GetPaintController().CommitNewDisplayItems();
  }

void CompositedLayerRasterInvalidator::AddDisplayItemRasterInvalidations(
    const PaintArtifact& paint_artifact,
    const PaintChunk& chunk,
    const ChunkToLayerMapper& mapper) {
  const auto* rects = paint_artifact.GetRasterInvalidationRects(chunk);
  if (!rects || rects->IsEmpty())
    return;

  const auto* tracking = paint_artifact.GetRasterInvalidationTracking(chunk);
  DCHECK(!tracking || tracking->IsEmpty() || tracking->size() == rects->size());

  for (size_t i = 0; i < rects->size(); ++i) {
    auto rect = ClipByLayerBounds(mapper.MapVisualRect((*rects)[i]));
    if (rect.IsEmpty())
      continue;
    raster_invalidation_function_(rect);

    if (tracking && !tracking->IsEmpty()) {
      const auto& info = (*tracking)[i];
      tracking_info_->tracking.AddInvalidation(
          info.client, info.client_debug_name, rect, info.reason);
    }
  }
}

  CompositorElementId GetMaskIsolationId() const { return mask_isolation_id_; }

void PaintController::CopyCachedSubsequence(size_t begin_index,
size_t end_index) {
DCHECK(!RuntimeEnabledFeatures::PaintUnderInvalidationCheckingEnabled());

base::AutoReset<size_t> subsequence_begin_index(
&current_cached_subsequence_begin_index_in_new_list_,
new_display_item_list_.size());
DisplayItem* cached_item =
&current_paint_artifact_.GetDisplayItemList()[begin_index];

Vector<PaintChunk>::const_iterator cached_chunk;
base::Optional<PropertyTreeState> properties_before_subsequence;
if (RuntimeEnabledFeatures::SlimmingPaintV175Enabled()) {
cached_chunk =
current_paint_artifact_.FindChunkByDisplayItemIndex(begin_index);
DCHECK(cached_chunk != current_paint_artifact_.PaintChunks().end());

properties_before_subsequence =
new_paint_chunks_.CurrentPaintChunkProperties();
UpdateCurrentPaintChunkPropertiesUsingIdWithFragment(
        cached_chunk->id, cached_chunk->properties.GetPropertyTreeState());
} else {
// Avoid uninitialized variable error on Windows.
cached_chunk = current_paint_artifact_.PaintChunks().begin();
}

for (size_t current_index = begin_index; current_index < end_index;
++current_index) {
cached_item = &current_paint_artifact_.GetDisplayItemList()[current_index];
SECURITY_CHECK(!cached_item->IsTombstone());
#if DCHECK_IS_ON()
DCHECK(cached_item->Client().IsAlive());
#endif

if (RuntimeEnabledFeatures::SlimmingPaintV175Enabled() &&
current_index == cached_chunk->end_index) {
++cached_chunk;
DCHECK(cached_chunk != current_paint_artifact_.PaintChunks().end());
new_paint_chunks_.ForceNewChunk();
UpdateCurrentPaintChunkPropertiesUsingIdWithFragment(
          cached_chunk->id, cached_chunk->properties.GetPropertyTreeState());
}

#if DCHECK_IS_ON()
// Visual rect change should not happen in a cached subsequence.
// However, because of different method of pixel snapping in different
// paths, there are false positives. Just log an error.
if (cached_item->VisualRect() !=
FloatRect(cached_item->Client().VisualRect())) {
LOG(ERROR) << "Visual rect changed in a cached subsequence: "
<< cached_item->Client().DebugName()
<< " old=" << cached_item->VisualRect().ToString()
<< " new=" << cached_item->Client().VisualRect().ToString();
}
#endif

ProcessNewItem(MoveItemFromCurrentListToNewList(current_index));
if (RuntimeEnabledFeatures::SlimmingPaintV175Enabled()) {
DCHECK((!new_paint_chunks_.LastChunk().is_cacheable &&
!cached_chunk->is_cacheable) ||
new_paint_chunks_.LastChunk().Matches(*cached_chunk));
}
}

if (RuntimeEnabledFeatures::PaintUnderInvalidationCheckingEnabled()) {
under_invalidation_checking_end_ = end_index;
DCHECK(IsCheckingUnderInvalidation());
} else if (RuntimeEnabledFeatures::SlimmingPaintV175Enabled()) {
// Restore properties and force new chunk for any trailing display items
// after the cached subsequence without new properties.
new_paint_chunks_.ForceNewChunk();
UpdateCurrentPaintChunkProperties(base::nullopt,
*properties_before_subsequence);
}
}

const PropertyTreeState& PropertyTreeState::Root() {
DEFINE_STATIC_LOCAL(
      std::unique_ptr<PropertyTreeState>, root,
      (std::make_unique<PropertyTreeState>(TransformPaintPropertyNode::Root(),
                                           ClipPaintPropertyNode::Root(),
                                           EffectPaintPropertyNode::Root())));
  return *root;
}

 PaintChunk::Id DefaultId() {
   DEFINE_STATIC_LOCAL(FakeDisplayItemClient, fake_client,
                       ("FakeDisplayItemClient", LayoutRect(0, 0, 100, 100)));
  return PaintChunk::Id(fake_client, DisplayItem::kDrawingFirst);
}

static CompositingReasons CompositingReasonsForTransform(const LayoutBox& box) {
  if (!box.HasLayer())
    return CompositingReason::kNone;

  const ComputedStyle& style = box.StyleRef();
  CompositingReasons compositing_reasons = CompositingReason::kNone;
  if (CompositingReasonFinder::RequiresCompositingForTransform(box))
    compositing_reasons |= CompositingReason::k3DTransform;

  if (CompositingReasonFinder::RequiresCompositingForTransformAnimation(style))
    compositing_reasons |= CompositingReason::kActiveTransformAnimation;

  if (style.HasWillChangeCompositingHint() &&
      !style.SubtreeWillChangeContents())
    compositing_reasons |= CompositingReason::kWillChangeCompositingHint;

  if (box.HasLayer() && box.Layer()->Has3DTransformedDescendant()) {
    if (style.HasPerspective())
      compositing_reasons |= CompositingReason::kPerspectiveWith3DDescendants;
    if (style.UsedTransformStyle3D() == ETransformStyle3D::kPreserve3d)
      compositing_reasons |= CompositingReason::kPreserve3DWith3DDescendants;
  }

  return compositing_reasons;
}

const ScrollPaintPropertyNode* PaintPropertyTreeBuilderTest::DocScroll(
    const Document* document) {
  if (!document)
    document = &GetDocument();
  return document->GetLayoutView()->FirstFragment().PaintProperties()->Scroll();
}

bool GeometryMapper::SlowLocalToAncestorVisualRectWithEffects(
    const PropertyTreeState& local_state,
    const PropertyTreeState& ancestor_state,
    FloatClipRect& mapping_rect,
    OverlayScrollbarClipBehavior clip_behavior,
    InclusiveIntersectOrNot inclusive_behavior,
    bool& success) {
  PropertyTreeState last_transform_and_clip_state(local_state.Transform(),
                                                  local_state.Clip(), nullptr);

  for (const auto* effect = local_state.Effect();
       effect && effect != ancestor_state.Effect(); effect = effect->Parent()) {
    if (!effect->HasFilterThatMovesPixels())
      continue;

    DCHECK(effect->OutputClip());
    PropertyTreeState transform_and_clip_state(effect->LocalTransformSpace(),
                                               effect->OutputClip(), nullptr);
    bool intersects = LocalToAncestorVisualRectInternal(
        last_transform_and_clip_state, transform_and_clip_state, mapping_rect,
        clip_behavior, inclusive_behavior, success);
    if (!success || !intersects) {
      success = true;
      mapping_rect = FloatClipRect(FloatRect());
      return false;
    }

    mapping_rect = FloatClipRect(effect->MapRect(mapping_rect.Rect()));
    last_transform_and_clip_state = transform_and_clip_state;
  }

  PropertyTreeState final_transform_and_clip_state(
      ancestor_state.Transform(), ancestor_state.Clip(), nullptr);
  LocalToAncestorVisualRectInternal(
      last_transform_and_clip_state, final_transform_and_clip_state,
      mapping_rect, clip_behavior, inclusive_behavior, success);

  mapping_rect.ClearIsTight();
  return true;
}

    CreateFragmentContextsForRepeatingTableSectionInPagedMedia() {
  DCHECK(ObjectIsRepeatingTableSectionInPagedMedia());

  LayoutView* view = object_.View();
  context_.repeating_table_section_bounding_box =
      BoundingBoxInPaginationContainer(object_, *view->Layer());

  auto page_height = view->PageLogicalHeight();
  const auto& bounding_box = context_.repeating_table_section_bounding_box;
  int first_page = floorf(bounding_box.Y() / page_height);
  int last_page = ceilf(bounding_box.MaxY() / page_height) - 1;
  if (first_page >= last_page)
    return;

  context_.fragments.resize(last_page - first_page + 1);
  for (int page = first_page; page <= last_page; page++) {
    if (page > first_page)
      context_.fragments[page - first_page] = context_.fragments[0];
    context_.fragments[page - first_page].logical_top_in_flow_thread =
        page * page_height;
  }

  const auto& painting_object = context_.painting_layer->GetLayoutObject();
  if (painting_object == object_)
    return;

  int page_count = ceilf(view->DocumentRect().Height() / page_height);
  auto* fragment = &painting_object.GetMutableForPainting().FirstFragment();
  if (fragment->NextFragment()) {
#if DCHECK_IS_ON()
    int fragment_count = 1;
    while ((fragment = fragment->NextFragment()))
      fragment_count++;
    DCHECK_EQ(fragment_count, page_count);
#endif
    return;
  }

  for (int page = 1; page < page_count; page++) {
    auto* new_fragment = &fragment->EnsureNextFragment();
    new_fragment->SetLocalBorderBoxProperties(
        fragment->LocalBorderBoxProperties());
    new_fragment->SetLogicalTopInFlowThread(page * page_height);
    fragment = new_fragment;
  }
}

  void TestMoreDrawingInSubsequence() {
    FakeDisplayItemClient first("first");
    GraphicsContext context(GetPaintController());

    InitRootChunk();
    {
      SubsequenceRecorder r(context, first);
      DrawRect(context, first, kBackgroundType, FloatRect(100, 100, 300, 300));
    }
    GetPaintController().CommitNewDisplayItems();

    InitRootChunk();
    {
      EXPECT_FALSE(
          SubsequenceRecorder::UseCachedSubsequenceIfPossible(context, first));
      SubsequenceRecorder r(context, first);
      DrawRect(context, first, kBackgroundType, FloatRect(100, 100, 300, 300));
      DrawRect(context, first, kForegroundType, FloatRect(100, 100, 300, 300));
    }
    GetPaintController().CommitNewDisplayItems();
  }

void CompositingLayerPropertyUpdater::Update(const LayoutObject& object) {
if (!RuntimeEnabledFeatures::SlimmingPaintV175Enabled() ||
RuntimeEnabledFeatures::SlimmingPaintV2Enabled())
return;

// We flatten compositing layers in real printing, so no need of properties
// for compositing layers.
if (object.GetDocument().Printing() &&
!RuntimeEnabledFeatures::PrintBrowserEnabled())
return;

if (!object.HasLayer())
return;
const auto* paint_layer = ToLayoutBoxModelObject(object).Layer();
const auto* mapping = paint_layer->GetCompositedLayerMapping();
if (!mapping)
return;

const FragmentData& fragment_data = object.FirstFragment();
DCHECK(fragment_data.HasLocalBorderBoxProperties());
// SPv1 compositing forces single fragment for composited elements.
DCHECK(!fragment_data.NextFragment());

LayoutPoint layout_snapped_paint_offset =
fragment_data.PaintOffset() - mapping->SubpixelAccumulation();
IntPoint snapped_paint_offset = RoundedIntPoint(layout_snapped_paint_offset);

// A layer without visible contents can be composited due to animation.
// Since the layer itself has no visible subtree, there is no guarantee
// that all of its ancestors have a visible subtree. An ancestor with no
// visible subtree can be non-composited despite we expected it to, this
// resulted in the paint offset used by CompositedLayerMapping to mismatch.
#if 0
// TODO(crbug.com/838018): Re-enable this check.
bool subpixel_accumulation_may_be_bogus = paint_layer->SubtreeIsInvisible();
DCHECK(layout_snapped_paint_offset == snapped_paint_offset ||
subpixel_accumulation_may_be_bogus);
#endif

base::Optional<PropertyTreeState> container_layer_state;
auto SetContainerLayerState =
[&fragment_data, &snapped_paint_offset,
&container_layer_state](GraphicsLayer* graphics_layer) {
if (graphics_layer) {
if (!container_layer_state) {
container_layer_state = fragment_data.LocalBorderBoxProperties();
if (const auto* properties = fragment_data.PaintProperties()) {
// CSS clip should be applied within the layer.
if (const auto* css_clip = properties->CssClip())
container_layer_state->SetClip(css_clip->Parent());
}
}
graphics_layer->SetLayerState(
*container_layer_state,
snapped_paint_offset + graphics_layer->OffsetFromLayoutObject());
}
};
SetContainerLayerState(mapping->MainGraphicsLayer());
SetContainerLayerState(mapping->DecorationOutlineLayer());
SetContainerLayerState(mapping->ChildClippingMaskLayer());

base::Optional<PropertyTreeState> scrollbar_layer_state;

auto SetContainerLayerStateForScrollbars =
[&fragment_data, &snapped_paint_offset, &container_layer_state,
&scrollbar_layer_state](GraphicsLayer* graphics_layer) {
if (graphics_layer) {
if (!scrollbar_layer_state) {
// OverflowControlsClip should be applied within the scrollbar
// layers.
if (container_layer_state) {
scrollbar_layer_state = container_layer_state;
} else {
scrollbar_layer_state = fragment_data.LocalBorderBoxProperties();
}

if (const auto* properties = fragment_data.PaintProperties()) {
if (const auto* clip = properties->OverflowControlsClip()) {
scrollbar_layer_state->SetClip(clip);
} else if (const auto* css_clip = properties->CssClip()) {
scrollbar_layer_state->SetClip(css_clip->Parent());
}
}
}
graphics_layer->SetLayerState(
*scrollbar_layer_state,
snapped_paint_offset + graphics_layer->OffsetFromLayoutObject());
}
};

SetContainerLayerStateForScrollbars(mapping->LayerForHorizontalScrollbar());
SetContainerLayerStateForScrollbars(mapping->LayerForVerticalScrollbar());
SetContainerLayerStateForScrollbars(mapping->LayerForScrollCorner());

if (mapping->ScrollingContentsLayer()) {
auto paint_offset = snapped_paint_offset;

// In flipped blocks writing mode, if there is scrollbar on the right,
// we move the contents to the left with extra amount of ScrollTranslation
// (-VerticalScrollbarWidth, 0). However, ScrollTranslation doesn't apply
// on ScrollingContentsLayer so we shift paint offset instead.
if (object.IsBox() && object.HasFlippedBlocksWritingMode())
paint_offset.Move(ToLayoutBox(object).VerticalScrollbarWidth(), 0);

auto SetContentsLayerState =
[&fragment_data, &paint_offset](GraphicsLayer* graphics_layer) {
if (graphics_layer) {
graphics_layer->SetLayerState(
fragment_data.ContentsProperties(),
paint_offset + graphics_layer->OffsetFromLayoutObject());
}
};
SetContentsLayerState(mapping->ScrollingContentsLayer());
SetContentsLayerState(mapping->ForegroundLayer());
} else {
SetContainerLayerState(mapping->ForegroundLayer());
}

if (auto* squashing_layer = mapping->SquashingLayer()) {
auto state = fragment_data.PreEffectProperties();
// The squashing layer's ClippingContainer is the common ancestor of clip
// state of all squashed layers, so we should use its clip state. This skips
// any control clips on the squashing layer's object which should not apply
// on squashed layers.
const auto* clipping_container = paint_layer->ClippingContainer();
state.SetClip(
clipping_container
? clipping_container->FirstFragment().ContentsProperties().Clip()
            : ClipPaintPropertyNode::Root());
squashing_layer->SetLayerState(
state,
snapped_paint_offset + mapping->SquashingLayerOffsetFromLayoutObject());
}

if (auto* mask_layer = mapping->MaskLayer()) {
auto state = fragment_data.LocalBorderBoxProperties();
const auto* properties = fragment_data.PaintProperties();
DCHECK(properties && properties->Mask());
state.SetEffect(properties->Mask());
state.SetClip(properties->MaskClip());

mask_layer->SetLayerState(
state, snapped_paint_offset + mask_layer->OffsetFromLayoutObject());
}

if (auto* ancestor_clipping_mask_layer =
mapping->AncestorClippingMaskLayer()) {
PropertyTreeState state(
fragment_data.PreTransform(),
mapping->ClipInheritanceAncestor()
->GetLayoutObject()
.FirstFragment()
.PostOverflowClip(),
// This is a hack to incorporate mask-based clip-path. Really should be
// nullptr or some dummy.
fragment_data.PreFilter());
ancestor_clipping_mask_layer->SetLayerState(
state, snapped_paint_offset +
ancestor_clipping_mask_layer->OffsetFromLayoutObject());
}

if (auto* child_clipping_mask_layer = mapping->ChildClippingMaskLayer()) {
PropertyTreeState state = fragment_data.LocalBorderBoxProperties();
// Same hack as for ancestor_clipping_mask_layer.
state.SetEffect(fragment_data.PreFilter());
child_clipping_mask_layer->SetLayerState(
state, snapped_paint_offset +
child_clipping_mask_layer->OffsetFromLayoutObject());
}
}

void PaintArtifactCompositor::SetTracksRasterInvalidations(bool should_track) {
  for (auto& client : content_layer_clients_)
    client->SetTracksRasterInvalidations(should_track);
}

  SynthesizedClip() : layer_(cc::PictureLayer::Create(this)) {
    mask_isolation_id_ =
        CompositorElementIdFromUniqueObjectId(NewUniqueObjectId());
    mask_effect_id_ =
        CompositorElementIdFromUniqueObjectId(NewUniqueObjectId());
    layer_->SetIsDrawable(true);
  }

PaintPropertyTreeBuilderTest::DocPreTranslation(const Document* document) {
  if (!document)
    document = &GetDocument();
  return document->GetLayoutView()
      ->FirstFragment()
      .PaintProperties()
      ->PaintOffsetTranslation();
}

PropertyTreeState LayerState() {
    DEFINE_STATIC_REF(
        TransformPaintPropertyNode, transform,
        CreateTransform(TransformPaintPropertyNode::Root(),
                        TransformationMatrix().Translate(123, 456),
                        FloatPoint3D(1, 2, 3)));
    DEFINE_STATIC_REF(ClipPaintPropertyNode, clip,
                      CreateClip(ClipPaintPropertyNode::Root(), transform,
                                 FloatRoundedRect(12, 34, 56, 78)));
    DEFINE_STATIC_REF(
        EffectPaintPropertyNode, effect,
        EffectPaintPropertyNode::Create(
            EffectPaintPropertyNode::Root(),
            EffectPaintPropertyNode::State{
                transform, clip, kColorFilterLuminanceToAlpha,
                CompositorFilterOperations(), 0.789f, SkBlendMode::kSrcIn}));
    return PropertyTreeState(transform, clip, effect);
}

CompositedLayerRasterInvalidatorTest& Properties(
      const TransformPaintPropertyNode* t,
      const ClipPaintPropertyNode* c = ClipPaintPropertyNode::Root(),
      const EffectPaintPropertyNode* e = EffectPaintPropertyNode::Root()) {
    auto& state = data_.chunks.back().properties;
    state.SetTransform(t);
    state.SetClip(c);
    state.SetEffect(e);
return *this;
}

static bool NeedsOverflowClip(const LayoutObject& object) {
  if (RuntimeEnabledFeatures::SlimmingPaintV175Enabled() &&
      object.IsSVGViewportContainer() &&
      SVGLayoutSupport::IsOverflowHidden(object))
    return true;

  return object.IsBox() && ToLayoutBox(object).ShouldClipOverflow() &&
         !IsPrintingRootLayoutView(object);
}

size_t PropertyTreeState::CacheMemoryUsageInBytes() const {
  return Clip()->CacheMemoryUsageInBytes() +
         Transform()->CacheMemoryUsageInBytes();
}

scoped_refptr<cc::DisplayItemList> PaintChunksToCcLayer::Convert(
    const PaintChunkSubset& paint_chunks,
    const PropertyTreeState& layer_state,
    const gfx::Vector2dF& layer_offset,
    const DisplayItemList& display_items,
    cc::DisplayItemList::UsageHint hint,
    RasterUnderInvalidationCheckingParams* under_invalidation_checking_params) {
  auto cc_list = base::MakeRefCounted<cc::DisplayItemList>(hint);
  ConvertInto(paint_chunks, layer_state, layer_offset, FloatSize(),
              display_items, *cc_list);

  if (under_invalidation_checking_params) {
    auto& params = *under_invalidation_checking_params;
    PaintRecorder recorder;
    recorder.beginRecording(params.interest_rect);
    auto list_clone = base::MakeRefCounted<cc::DisplayItemList>(
        cc::DisplayItemList::kToBeReleasedAsPaintOpBuffer);
    ConvertInto(paint_chunks, layer_state, layer_offset, FloatSize(),
                display_items, *list_clone);
    recorder.getRecordingCanvas()->drawPicture(list_clone->ReleaseAsRecord());
    params.tracking.CheckUnderInvalidations(params.debug_name,
                                            recorder.finishRecordingAsPicture(),
                                            params.interest_rect);
    if (auto record = params.tracking.UnderInvalidationRecord()) {
      cc_list->StartPaint();
      cc_list->push<cc::DrawRecordOp>(std::move(record));
      cc_list->EndPaintOfUnpaired(params.interest_rect);
    }
  }

  cc_list->Finalize();
  return cc_list;
}

PaintChunk DefaultChunk() {
  return PaintChunk(0, 1, DefaultId(), PropertyTreeState::Root());
}

bool PaintArtifactCompositor::MightOverlap(const PendingLayer& layer_a,
const PendingLayer& layer_b) {
  PropertyTreeState root_property_tree_state(TransformPaintPropertyNode::Root(),
                                             ClipPaintPropertyNode::Root(),
                                             EffectPaintPropertyNode::Root());
FloatClipRect bounds_a(layer_a.bounds);
  GeometryMapper::LocalToAncestorVisualRect(layer_a.property_tree_state,
                                            root_property_tree_state, bounds_a);
FloatClipRect bounds_b(layer_b.bounds);
  GeometryMapper::LocalToAncestorVisualRect(layer_b.property_tree_state,
                                            root_property_tree_state, bounds_b);

return bounds_a.Rect().Intersects(bounds_b.Rect());
}

void CompositedLayerRasterInvalidator::Generate(
    const PaintArtifact& paint_artifact,
    const gfx::Rect& layer_bounds,
    const PropertyTreeState& layer_state,
    const FloatSize& visual_rect_subpixel_offset) {
  Generate(paint_artifact, paint_artifact.PaintChunks(), layer_bounds,
           layer_state, visual_rect_subpixel_offset);
}

 TestPaintArtifact& TestPaintArtifact::Chunk(
    const PropertyTreeState& properties) {
  return Chunk(NewClient(), properties);
}

static bool NeedsPaintOffsetTranslationForScrollbars(
    const LayoutBoxModelObject& object) {
  if (auto* area = object.GetScrollableArea()) {
    if (area->HorizontalScrollbar() || area->VerticalScrollbar())
      return true;
  }
  return false;
}

  CompositedLayerRasterInvalidatorTest& Uncacheable() {
    data_.chunks.back().is_cacheable = false;
    return *this;
  }

static bool IsRepeatingTableSection(const LayoutObject& object) {
  if (!object.IsTableSection())
    return false;
  const auto& section = ToLayoutTableSection(object);
  return section.IsRepeatingHeaderGroup() || section.IsRepeatingFooterGroup();
}

void PaintController::GenerateRasterInvalidationsComparingChunks(
    PaintChunk& new_chunk,
    const PaintChunk& old_chunk) {
  DCHECK(RuntimeEnabledFeatures::SlimmingPaintV175Enabled());


  struct OldAndNewDisplayItems {
    const DisplayItem* old_item = nullptr;
    const DisplayItem* new_item = nullptr;
  };
  HashMap<const DisplayItemClient*, OldAndNewDisplayItems>
      clients_to_invalidate;

  size_t highest_moved_to_index = 0;
  for (size_t old_index = old_chunk.begin_index;
       old_index < old_chunk.end_index; ++old_index) {
    const DisplayItem& old_item =
        current_paint_artifact_.GetDisplayItemList()[old_index];
    const DisplayItemClient* client_to_invalidate_old_visual_rect = nullptr;

    if (old_item.IsTombstone()) {
      size_t moved_to_index = items_moved_into_new_list_[old_index];
      if (new_display_item_list_[moved_to_index].DrawsContent()) {
        if (moved_to_index < new_chunk.begin_index ||
            moved_to_index >= new_chunk.end_index) {
          const auto& new_item = new_display_item_list_[moved_to_index];
          PaintChunk& moved_to_chunk =
              new_paint_chunks_.FindChunkByDisplayItemIndex(moved_to_index);
          AddRasterInvalidation(new_item.Client(), moved_to_chunk,
                                new_item.VisualRect(),
                                PaintInvalidationReason::kAppeared);
          client_to_invalidate_old_visual_rect = &new_item.Client();
        } else if (moved_to_index < highest_moved_to_index) {
          client_to_invalidate_old_visual_rect =
              &new_display_item_list_[moved_to_index].Client();
        } else {
          highest_moved_to_index = moved_to_index;
        }
      }
    } else if (old_item.DrawsContent()) {
      client_to_invalidate_old_visual_rect = &old_item.Client();
    }

    if (client_to_invalidate_old_visual_rect) {
      clients_to_invalidate
          .insert(client_to_invalidate_old_visual_rect, OldAndNewDisplayItems())
          .stored_value->value.old_item = &old_item;
    }
  }

  for (size_t new_index = new_chunk.begin_index;
       new_index < new_chunk.end_index; ++new_index) {
    const DisplayItem& new_item = new_display_item_list_[new_index];
    if (new_item.DrawsContent() && !ClientCacheIsValid(new_item.Client())) {
      clients_to_invalidate.insert(&new_item.Client(), OldAndNewDisplayItems())
          .stored_value->value.new_item = &new_item;
    }
  }

  for (const auto& item : clients_to_invalidate) {
    GenerateRasterInvalidation(*item.key, new_chunk, item.value.old_item,
                               item.value.new_item);
  }
}

PropertyTreeManager::PropertyTreeManager(PropertyTreeManagerClient& client,
                                         cc::PropertyTrees& property_trees,
                                         cc::Layer* root_layer,
                                         int sequence_number)
    : client_(client),
      property_trees_(property_trees),
      root_layer_(root_layer),
      sequence_number_(sequence_number) {
  SetupRootTransformNode();
  SetupRootClipNode();
  SetupRootEffectNode();
  SetupRootScrollNode();
}

  PaintControllerUnderInvalidationTest()
      : PaintControllerTestBase(),
        ScopedPaintUnderInvalidationCheckingForTest(true) {}

  PaintArtifactCompositorTest()
      : ScopedSlimmingPaintV2ForTest(true),
        task_runner_(new base::TestSimpleTaskRunner),
        task_runner_handle_(task_runner_) {}

  size_t SynthesizedClipLayerCount() {
    return paint_artifact_compositor_->GetExtraDataForTesting()
        ->synthesized_clip_layers.size();
  }

static bool EffectGroupContainsChunk(
    const EffectPaintPropertyNode& group_effect,
    const PaintChunk& chunk) {
  const auto* effect = chunk.properties.Effect();
  return effect == &group_effect ||
         StrictChildOfAlongPath(&group_effect, effect);
}

  CompositorElementId GetMaskEffectId() const { return mask_effect_id_; }

void PaintArtifactCompositor::ShowDebugData() {
  LOG(ERROR) << LayersAsJSON(kLayerTreeIncludesDebugInfo |
                             kLayerTreeIncludesPaintInvalidations)
                    ->ToPrettyJSONString()
                    .Utf8()
                    .data();
}

  void ApplyTransform(const TransformPaintPropertyNode* target_transform) {
    if (target_transform == current_transform_)
      return;
    auto sk_matrix = GetSkMatrix(target_transform);
    if (!sk_matrix.isIdentity())
      cc_list_.push<cc::ConcatOp>(sk_matrix);
  }

  CompositedLayerRasterInvalidatorTest& RasterInvalidationCount(int count) {
    size_t size = data_.chunks.size();
    DCHECK_GT(size, 0u);
    data_.raster_invalidation_rects.resize(size);
    data_.raster_invalidation_trackings.resize(size);
    int index = static_cast<int>(size - 1);
    for (int i = 0; i < count; ++i) {
      IntRect rect(index * 11, index * 22, index * 22 + 100 + i,
                   index * 11 + 100 + i);
      data_.raster_invalidation_rects.back().push_back(FloatRect(rect));
      data_.raster_invalidation_trackings.back().push_back(
          RasterInvalidationInfo{
              &data_.chunks.back().id.client, "Test", rect,
              static_cast<PaintInvalidationReason>(
                  static_cast<int>(PaintInvalidationReason::kFull) + index +
                  i)});
    }
    return *this;
  }

void ConversionContext::SwitchToTransform(
    const TransformPaintPropertyNode* target_transform) {
  if (target_transform == current_transform_)
    return;

  EndTransform();
  if (target_transform == current_transform_)
    return;

  auto sk_matrix = GetSkMatrix(target_transform);
  if (sk_matrix.isIdentity())
    return;

  cc_list_.StartPaint();
  cc_list_.push<cc::SaveOp>();
  cc_list_.push<cc::ConcatOp>(sk_matrix);
  cc_list_.EndPaintOfPairedBegin();
  previous_transform_ = current_transform_;
  current_transform_ = target_transform;
}

  void TestLessDrawingInSubsequence() {
    FakeDisplayItemClient first("first");
    GraphicsContext context(GetPaintController());

    InitRootChunk();
    {
      SubsequenceRecorder r(context, first);
      DrawRect(context, first, kBackgroundType, FloatRect(100, 100, 300, 300));
      DrawRect(context, first, kForegroundType, FloatRect(100, 100, 300, 300));
    }
    GetPaintController().CommitNewDisplayItems();

    InitRootChunk();
    {
      EXPECT_FALSE(
          SubsequenceRecorder::UseCachedSubsequenceIfPossible(context, first));
      SubsequenceRecorder r(context, first);
      DrawRect(context, first, kBackgroundType, FloatRect(100, 100, 300, 300));
    }
    GetPaintController().CommitNewDisplayItems();
  }

  void ExpectUnchangedState() {
    EXPECT_FALSE(root->Changed(*root));
    EXPECT_FALSE(node->Changed(*root));
    EXPECT_FALSE(child1->Changed(*root));
    EXPECT_FALSE(child2->Changed(*root));
    EXPECT_FALSE(grandchild1->Changed(*root));
     EXPECT_FALSE(grandchild2->Changed(*root));
   }

cc::TransformTree& PropertyTreeManager::GetTransformTree() {
  return property_trees_.transform_tree;
}

void BlockPainter::PaintChildren(const PaintInfo& paint_info,
                                 const LayoutPoint& paint_offset) {
  for (LayoutBox* child = layout_block_.FirstChildBox(); child;
       child = child->NextSiblingBox())
    PaintChild(*child, paint_info, paint_offset);
}

static LayoutPoint VisualOffsetFromPaintOffsetRoot(
    const PaintPropertyTreeBuilderFragmentContext& context,
    const PaintLayer* child) {
  const LayoutObject* paint_offset_root = context.current.paint_offset_root;
  PaintLayer* painting_layer = paint_offset_root->PaintingLayer();
  LayoutPoint result = child->VisualOffsetFromAncestor(painting_layer);
  if (!paint_offset_root->HasLayer() ||
      ToLayoutBoxModelObject(paint_offset_root)->Layer() != painting_layer) {
    result.Move(-paint_offset_root->OffsetFromAncestorContainer(
        &painting_layer->GetLayoutObject()));
  }

  if (paint_offset_root->HasOverflowClip())
    result += ToLayoutBox(paint_offset_root)->ScrolledContentOffset();
  return result;
}

std::unique_ptr<JSONObject> TransformPaintPropertyNode::ToJSON() const {
auto json = JSONObject::Create();
if (Parent())
json->SetString("parent", String::Format("%p", Parent()));
if (!state_.matrix.IsIdentity())
json->SetString("matrix", state_.matrix.ToString());
if (!state_.matrix.IsIdentityOrTranslation())
json->SetString("origin", state_.origin.ToString());
if (!state_.flattens_inherited_transform)
json->SetBoolean("flattensInheritedTransform", false);
if (state_.backface_visibility != BackfaceVisibility::kInherited) {
json->SetString("backface",
state_.backface_visibility == BackfaceVisibility::kVisible
? "visible"
: "hidden");
}
if (state_.rendering_context_id) {
json->SetString("renderingContextId",
String::Format("%x", state_.rendering_context_id));
}
if (state_.direct_compositing_reasons != CompositingReason::kNone) {
json->SetString(
"directCompositingReasons",
CompositingReason::ToString(state_.direct_compositing_reasons));
}
if (state_.compositor_element_id) {
json->SetString("compositorElementId",
state_.compositor_element_id.ToString().c_str());
}
if (state_.scroll)
    json->SetString("scroll", String::Format("%p", state_.scroll.get()));
return json;
}

  const cc::TransformNode& GetTransformNode(const cc::Layer* layer) {
    return *GetPropertyTrees().transform_tree.Node(
        layer->transform_tree_index());
  }

void FragmentPaintPropertyTreeBuilder::UpdateSvgLocalToBorderBoxTransform() {
DCHECK(properties_);
if (!object_.IsSVGRoot())
return;

if (NeedsPaintPropertyUpdate()) {
AffineTransform transform_to_border_box =
SVGRootPainter(ToLayoutSVGRoot(object_))
.TransformToPixelSnappedBorderBox(context_.current.paint_offset);
if (!transform_to_border_box.IsIdentity() &&
NeedsSVGLocalToBorderBoxTransform(object_)) {
OnUpdate(properties_->UpdateSvgLocalToBorderBoxTransform(
          context_.current.transform,
TransformPaintPropertyNode::State{transform_to_border_box}));
} else {
OnClear(properties_->ClearSvgLocalToBorderBoxTransform());
}
}

if (properties_->SvgLocalToBorderBoxTransform()) {
context_.current.transform = properties_->SvgLocalToBorderBoxTransform();
context_.current.should_flatten_inherited_transform = false;
context_.current.rendering_context_id = 0;
}
// The paint offset is included in |transformToBorderBox| so SVG does not need
// to handle paint offset internally.
context_.current.paint_offset = LayoutPoint();
}

void ConversionContext::TranslateForLayerOffsetOnce() {
  if (translated_for_layer_offset_ || layer_offset_.IsZero())
    return;

  cc_list_.StartPaint();
  cc_list_.push<cc::SaveOp>();
  cc_list_.push<cc::TranslateOp>(-layer_offset_.x(), -layer_offset_.y());
  cc_list_.EndPaintOfPairedBegin();
  translated_for_layer_offset_ = true;
}

bool PaintPropertyTreeBuilder::ObjectIsRepeatingTableSectionInPagedMedia()
    const {
  if (!IsRepeatingTableSection(object_))
    return false;

  if (context_.painting_layer->EnclosingPaginationLayer())
    return false;

  if (!object_.View()->PageLogicalHeight())
    return false;

  if (!object_.View()->IsHorizontalWritingMode())
    return false;

  return true;
}

bool PropertyTreeManager::BuildEffectNodesRecursively(
    const EffectPaintPropertyNode* next_effect) {
  if (next_effect == current_effect_)
    return false;
  DCHECK(next_effect);

  bool newly_built = BuildEffectNodesRecursively(next_effect->Parent());
  DCHECK_EQ(next_effect->Parent(), current_effect_);

#if DCHECK_IS_ON()
  DCHECK(!effect_nodes_converted_.Contains(next_effect))
      << "Malformed paint artifact. Paint chunks under the same effect should "
         "be contiguous.";
  effect_nodes_converted_.insert(next_effect);
#endif

  SkBlendMode used_blend_mode;
  int output_clip_id;
  if (next_effect->OutputClip()) {
    used_blend_mode = SynthesizeCcEffectsForClipsIfNeeded(
        next_effect->OutputClip(), next_effect->BlendMode(), newly_built);
    output_clip_id = EnsureCompositorClipNode(next_effect->OutputClip());
  } else {
    while (IsCurrentCcEffectSynthetic())
      CloseCcEffect();
    if (next_effect->BlendMode() != SkBlendMode::kSrcOver ||
        (!newly_built && current_effect_->Opacity() != 1.f))
      GetEffectTree().Node(current_effect_id_)->has_render_surface = true;

    used_blend_mode = next_effect->BlendMode();
    output_clip_id = GetEffectTree().Node(current_effect_id_)->clip_id;
  }

  cc::EffectNode& effect_node = *GetEffectTree().Node(
      GetEffectTree().Insert(cc::EffectNode(), current_effect_id_));
  effect_node.stable_id =
      next_effect->GetCompositorElementId().ToInternalValue();
  effect_node.clip_id = output_clip_id;
  if (!next_effect->Filter().IsEmpty() ||
      used_blend_mode != SkBlendMode::kSrcOver)
    effect_node.has_render_surface = true;
  effect_node.opacity = next_effect->Opacity();
  if (next_effect->GetColorFilter() != kColorFilterNone) {
    DCHECK(next_effect->GetColorFilter() == kColorFilterLuminanceToAlpha);
    DCHECK(used_blend_mode == SkBlendMode::kDstIn);
    DCHECK(next_effect->Filter().IsEmpty());
    effect_node.filters.Append(cc::FilterOperation::CreateReferenceFilter(
        sk_make_sp<ColorFilterPaintFilter>(SkLumaColorFilter::Make(),
                                           nullptr)));
  } else {
    effect_node.filters = next_effect->Filter().AsCcFilterOperations();
    effect_node.filters_origin = next_effect->PaintOffset();
    effect_node.transform_id =
        EnsureCompositorTransformNode(next_effect->LocalTransformSpace());
  }
  effect_node.blend_mode = used_blend_mode;
  CompositorElementId compositor_element_id =
      next_effect->GetCompositorElementId();
  if (compositor_element_id) {
    DCHECK(property_trees_.element_id_to_effect_node_index.find(
               compositor_element_id) ==
           property_trees_.element_id_to_effect_node_index.end());
    property_trees_.element_id_to_effect_node_index[compositor_element_id] =
        effect_node.id;
  }
  effect_stack_.emplace_back(EffectStackEntry{current_effect_id_,
                                              current_effect_type_,
                                              current_effect_, current_clip_});
  current_effect_id_ = effect_node.id;
  current_effect_type_ = CcEffectType::kEffect;
  current_effect_ = next_effect;
  if (next_effect->OutputClip())
    current_clip_ = next_effect->OutputClip();

  return true;
}

void BlockPainter::PaintChildrenOfFlexibleBox(
    const LayoutFlexibleBox& layout_flexible_box,
    const PaintInfo& paint_info,
    const LayoutPoint& paint_offset) {
  for (const LayoutBox* child = layout_flexible_box.GetOrderIterator().First();
       child; child = layout_flexible_box.GetOrderIterator().Next())
    BlockPainter(layout_flexible_box)
        .PaintAllChildPhasesAtomically(*child, paint_info, paint_offset);
}

void PaintController::GenerateRasterInvalidation(
    const DisplayItemClient& client,
    PaintChunk& chunk,
    const DisplayItem* old_item,
    const DisplayItem* new_item) {
  if (!new_item || new_item->VisualRect().IsEmpty()) {
    if (old_item && !old_item->VisualRect().IsEmpty()) {
      AddRasterInvalidation(client, chunk, old_item->VisualRect(),
                            PaintInvalidationReason::kDisappeared);
    }
    return;
  }

  DCHECK(&client == &new_item->Client());
  if (!old_item || old_item->VisualRect().IsEmpty()) {
    AddRasterInvalidation(client, chunk, new_item->VisualRect(),
                          PaintInvalidationReason::kAppeared);
    return;
  }

  if (client.IsJustCreated()) {
    AddRasterInvalidation(client, chunk, old_item->VisualRect(),
                          PaintInvalidationReason::kDisappeared);
    AddRasterInvalidation(client, chunk, new_item->VisualRect(),
                          PaintInvalidationReason::kAppeared);
    return;
  }

  auto reason = client.GetPaintInvalidationReason();
  bool partial_raster_invalidation =
      RuntimeEnabledFeatures::PartialRasterInvalidationEnabled() &&
      (reason == PaintInvalidationReason::kRectangle ||
       reason == PaintInvalidationReason::kSelection);
  if ((!partial_raster_invalidation &&
       reason != PaintInvalidationReason::kIncremental) ||
      old_item->VisualRect().Location() != new_item->VisualRect().Location()) {
    GenerateFullRasterInvalidation(chunk, *old_item, *new_item);
    return;
  }

  GenerateIncrementalRasterInvalidation(chunk, *old_item, *new_item);

  if (RuntimeEnabledFeatures::PartialRasterInvalidationEnabled()) {
    auto partial_rect = client.PartialInvalidationRect();
    if (!partial_rect.IsEmpty())
      AddRasterInvalidation(client, chunk, FloatRect(partial_rect), reason);
  }
}

void ConversionContext::SwitchToEffect(
    const EffectPaintPropertyNode* target_effect) {
  if (target_effect == current_effect_)
    return;

  const EffectPaintPropertyNode* lca_effect =
      &LowestCommonAncestor(*target_effect, *current_effect_);
  while (current_effect_ != lca_effect) {
    EndClips();
#if DCHECK_IS_ON()
    DCHECK(state_stack_.size())
        << "Error: Chunk has an effect that escapes layer's effect.\n"
        << "target_effect:\n"
        << target_effect->ToTreeString().Utf8().data() << "current_effect_:\n"
        << current_effect_->ToTreeString().Utf8().data();
#endif
    if (!state_stack_.size())
      break;
    EndEffect();
  }

  Vector<const EffectPaintPropertyNode*, 1u> pending_effects;
  for (const EffectPaintPropertyNode* effect = target_effect;
       effect != current_effect_; effect = effect->Parent()) {
    if (!effect)
      break;
    pending_effects.push_back(effect);
  }

  for (size_t i = pending_effects.size(); i--;) {
    const EffectPaintPropertyNode* sub_effect = pending_effects[i];
    DCHECK_EQ(current_effect_, sub_effect->Parent());
    StartEffect(sub_effect);
  }
}

static bool SomeNodeFlattensTransform(
    const TransformPaintPropertyNode* node,
    const TransformPaintPropertyNode* ancestor) {
  while (node != ancestor) {
    if (node->FlattensInheritedTransform())
      return true;
    node = node->Parent();
  }
  return false;
}

  const cc::LayerTreeHost& GetLayerTreeHost() {
    return *web_layer_tree_view_->GetLayerTreeHost();
  }

void PaintArtifactCompositor::CollectPendingLayers(
const PaintArtifact& paint_artifact,
Vector<PendingLayer>& pending_layers) {
Vector<PaintChunk>::const_iterator cursor =
paint_artifact.PaintChunks().begin();
  LayerizeGroup(paint_artifact, pending_layers,
                *EffectPaintPropertyNode::Root(), cursor);
DCHECK_EQ(paint_artifact.PaintChunks().end(), cursor);
}

void PaintPropertyTreeBuilder::InitFragmentPaintProperties(
    FragmentData& fragment,
    bool needs_paint_properties,
    const LayoutPoint& pagination_offset,
    LayoutUnit logical_top_in_flow_thread) {
  if (needs_paint_properties) {
    fragment.EnsurePaintProperties();
  } else if (fragment.PaintProperties()) {
    context_.force_subtree_update = true;
    fragment.ClearPaintProperties();
  }
  fragment.SetPaginationOffset(pagination_offset);
  fragment.SetLogicalTopInFlowThread(logical_top_in_flow_thread);
}

    UpdateRepeatingTableHeaderPaintOffsetAdjustment() {
  const auto& section = ToLayoutTableSection(object_);
  DCHECK(section.IsRepeatingHeaderGroup());

  LayoutUnit fragment_height;
  LayoutUnit original_offset_in_flow_thread =
      context_.repeating_table_section_bounding_box.Y();
  LayoutUnit original_offset_in_fragment;
  const LayoutFlowThread* flow_thread = nullptr;
  if (const auto* pagination_layer =
          context_.painting_layer->EnclosingPaginationLayer()) {
    flow_thread = &ToLayoutFlowThread(pagination_layer->GetLayoutObject());
    if (!flow_thread->IsPageLogicalHeightKnown())
      return;

    fragment_height =
        flow_thread->PageLogicalHeightForOffset(original_offset_in_flow_thread);
    original_offset_in_fragment =
        fragment_height - flow_thread->PageRemainingLogicalHeightForOffset(
                              original_offset_in_flow_thread,
                              LayoutBox::kAssociateWithLatterPage);
  } else {
    fragment_height = object_.View()->PageLogicalHeight();
    original_offset_in_fragment =
        IntMod(original_offset_in_flow_thread, fragment_height);
  }

  auto repeating_offset_in_fragment =
      section.Table()->RowOffsetFromRepeatingHeader() - section.LogicalHeight();

  auto adjustment = repeating_offset_in_fragment - original_offset_in_fragment;

  auto fragment_offset_in_flow_thread =
      original_offset_in_flow_thread - original_offset_in_fragment;
  for (size_t i = 0; i < context_.fragments.size(); ++i) {
    auto& fragment_context = context_.fragments[i];
    fragment_context.repeating_paint_offset_adjustment = LayoutSize();
    if (i)
      fragment_context.repeating_paint_offset_adjustment.SetHeight(adjustment);

    adjustment += fragment_height;
    fragment_offset_in_flow_thread += fragment_height;

    if (flow_thread) {
      fragment_height = flow_thread->PageLogicalHeightForOffset(
          fragment_offset_in_flow_thread);
    }
  }
}

const PaintArtifact& TestPaintArtifact::Build() {
  if (built_)
    return paint_artifact_;

  if (!paint_chunks_data_.chunks.IsEmpty())
    paint_chunks_data_.chunks.back().end_index = display_item_list_.size();
  paint_artifact_ = PaintArtifact(std::move(display_item_list_),
                                  std::move(paint_chunks_data_));
  built_ = true;
  return paint_artifact_;
}

void BlockPainter::PaintObject(const PaintInfo& paint_info,
                               const LayoutPoint& paint_offset) {
  if (layout_block_.IsTruncated())
    return;

  const PaintPhase paint_phase = paint_info.phase;

  if (ShouldPaintSelfBlockBackground(paint_phase)) {
    if (layout_block_.Style()->Visibility() == EVisibility::kVisible &&
        layout_block_.HasBoxDecorationBackground())
      layout_block_.PaintBoxDecorationBackground(paint_info, paint_offset);
    if (RuntimeEnabledFeatures::SlimmingPaintV2Enabled())
      PaintScrollHitTestDisplayItem(paint_info);
    if (paint_phase == PaintPhase::kSelfBlockBackgroundOnly)
      return;
  }

  if (paint_phase == PaintPhase::kMask &&
      layout_block_.Style()->Visibility() == EVisibility::kVisible) {
    layout_block_.PaintMask(paint_info, paint_offset);
    return;
  }

  if (paint_phase == PaintPhase::kClippingMask &&
      layout_block_.Style()->Visibility() == EVisibility::kVisible) {
    DCHECK(!RuntimeEnabledFeatures::SlimmingPaintV175Enabled());
    BoxPainter(layout_block_).PaintClippingMask(paint_info, paint_offset);
    return;
  }

  if (paint_phase == PaintPhase::kForeground && paint_info.IsPrinting())
    ObjectPainter(layout_block_)
        .AddPDFURLRectIfNeeded(paint_info, paint_offset);

  if (paint_phase != PaintPhase::kSelfOutlineOnly) {
    base::Optional<ScopedPaintChunkProperties> scoped_scroll_property;
    base::Optional<ScrollRecorder> scroll_recorder;
    base::Optional<PaintInfo> scrolled_paint_info;
    if (RuntimeEnabledFeatures::SlimmingPaintV175Enabled()) {
      if (const auto* fragment = paint_info.FragmentToPaint(layout_block_)) {
        const auto* object_properties = fragment->PaintProperties();
        auto* scroll_translation = object_properties
                                       ? object_properties->ScrollTranslation()
                                       : nullptr;
        if (scroll_translation) {
          scoped_scroll_property.emplace(
              paint_info.context.GetPaintController(), scroll_translation,
              layout_block_, DisplayItem::PaintPhaseToScrollType(paint_phase));
          scrolled_paint_info.emplace(paint_info);
          if (RuntimeEnabledFeatures::SlimmingPaintV2Enabled()) {
            scrolled_paint_info->UpdateCullRectForScrollingContents(
                EnclosingIntRect(layout_block_.OverflowClipRect(paint_offset)),
                scroll_translation->Matrix().ToAffineTransform());
          } else {
            scrolled_paint_info->UpdateCullRect(
                scroll_translation->Matrix().ToAffineTransform());
          }
        }
      }
    } else if (layout_block_.HasOverflowClip()) {
      IntSize scroll_offset = layout_block_.ScrolledContentOffset();
      if (layout_block_.Layer()->ScrollsOverflow() || !scroll_offset.IsZero()) {
        scroll_recorder.emplace(paint_info.context, layout_block_, paint_phase,
                                scroll_offset);
        scrolled_paint_info.emplace(paint_info);
        AffineTransform transform;
        transform.Translate(-scroll_offset.Width(), -scroll_offset.Height());
        scrolled_paint_info->UpdateCullRect(transform);
      }
    }

    const PaintInfo& contents_paint_info =
        scrolled_paint_info ? *scrolled_paint_info : paint_info;

    if (layout_block_.IsLayoutBlockFlow()) {
      BlockFlowPainter block_flow_painter(ToLayoutBlockFlow(layout_block_));
      block_flow_painter.PaintContents(contents_paint_info, paint_offset);
      if (paint_phase == PaintPhase::kFloat ||
          paint_phase == PaintPhase::kSelection ||
          paint_phase == PaintPhase::kTextClip)
        block_flow_painter.PaintFloats(contents_paint_info, paint_offset);
    } else {
      PaintContents(contents_paint_info, paint_offset);
    }
  }

  if (ShouldPaintSelfOutline(paint_phase))
    ObjectPainter(layout_block_).PaintOutline(paint_info, paint_offset);

  if (paint_phase == PaintPhase::kForeground &&
      layout_block_.ShouldPaintCarets())
    PaintCarets(paint_info, paint_offset);
}

void PaintController::GenerateRasterInvalidations(PaintChunk& new_chunk) {
  if (RuntimeEnabledFeatures::DisableRasterInvalidationEnabled())
    return;

  DCHECK(RuntimeEnabledFeatures::SlimmingPaintV175Enabled());
  if (new_chunk.begin_index >=
      current_cached_subsequence_begin_index_in_new_list_)
    return;

  if (!new_chunk.is_cacheable)
    return;

  const auto& old_chunks = current_paint_artifact_.PaintChunks();
  while (next_chunk_to_match_ < old_chunks.size()) {
    const PaintChunk& old_chunk = old_chunks[next_chunk_to_match_];
    if (new_chunk.Matches(old_chunk)) {
      GenerateRasterInvalidationsComparingChunks(new_chunk, old_chunk);
      ++next_chunk_to_match_;
      return;
    }

    if (old_chunk.is_cacheable) {
      auto it = out_of_order_chunk_indices_.find(&old_chunk.id.client);
      Vector<size_t>& indices =
          it == out_of_order_chunk_indices_.end()
              ? out_of_order_chunk_indices_
                    .insert(&old_chunk.id.client, Vector<size_t>())
                    .stored_value->value
              : it->value;
      indices.push_back(next_chunk_to_match_);
    }
    ++next_chunk_to_match_;
  }

  auto it = out_of_order_chunk_indices_.find(&new_chunk.id.client);
  if (it != out_of_order_chunk_indices_.end()) {
    for (size_t i : it->value) {
      if (new_chunk.Matches(old_chunks[i])) {
        GenerateRasterInvalidationsComparingChunks(new_chunk, old_chunks[i]);
        return;
      }
    }
  }
}

void PaintController::RemoveLastDisplayItem() {
  DCHECK(!RuntimeEnabledFeatures::SlimmingPaintV175Enabled());

  if (new_display_item_list_.IsEmpty())
    return;

#if DCHECK_IS_ON()
  IndicesByClientMap::iterator it = new_display_item_indices_by_client_.find(
      &new_display_item_list_.Last().Client());
  if (it != new_display_item_indices_by_client_.end()) {
    Vector<size_t>& indices = it->value;
    if (!indices.IsEmpty() &&
        indices.back() == (new_display_item_list_.size() - 1))
      indices.pop_back();
  }
#endif

  if (RuntimeEnabledFeatures::PaintUnderInvalidationCheckingEnabled() &&
      IsCheckingUnderInvalidation()) {
    if (skipped_probable_under_invalidation_count_) {
      --skipped_probable_under_invalidation_count_;
    } else {
      DCHECK(under_invalidation_checking_begin_);
      --under_invalidation_checking_begin_;
      current_paint_artifact_.GetDisplayItemList().RestoreTombstone(
          under_invalidation_checking_begin_, new_display_item_list_.Last());
    }
  }
  new_display_item_list_.RemoveLast();
}

void ConversionContext::StartEffect(const EffectPaintPropertyNode* effect) {
  if (effect->OutputClip())
    SwitchToClip(effect->OutputClip());
  else
    EndClips();

  int saved_count = 0;
  size_t save_layer_id = kNotFound;

  SwitchToTransform(effect->LocalTransformSpace());

  bool has_filter = !effect->Filter().IsEmpty();
  bool has_opacity = effect->Opacity() != 1.f;
  bool has_other_effects = effect->BlendMode() != SkBlendMode::kSrcOver ||
                           effect->GetColorFilter() != kColorFilterNone;
  DCHECK(!has_filter || !(has_opacity || has_other_effects));

  cc_list_.StartPaint();
  if (!has_filter) {
    auto alpha =
        static_cast<uint8_t>(gfx::ToFlooredInt(255 * effect->Opacity()));
    if (has_other_effects) {
      cc::PaintFlags flags;
      flags.setBlendMode(effect->BlendMode());
      flags.setAlpha(alpha);
      flags.setColorFilter(GraphicsContext::WebCoreColorFilterToSkiaColorFilter(
          effect->GetColorFilter()));
      save_layer_id = cc_list_.push<cc::SaveLayerOp>(nullptr, &flags);
    } else {
      constexpr bool preserve_lcd_text_requests = false;
      save_layer_id = cc_list_.push<cc::SaveLayerAlphaOp>(
          nullptr, alpha, preserve_lcd_text_requests);
    }
    saved_count++;
  } else {
    FloatPoint filter_origin = effect->PaintOffset();
    if (filter_origin != FloatPoint()) {
      cc_list_.push<cc::SaveOp>();
      cc_list_.push<cc::TranslateOp>(filter_origin.X(), filter_origin.Y());
      saved_count++;
    }

    gfx::SizeF empty;
    cc::PaintFlags filter_flags;
    filter_flags.setImageFilter(cc::RenderSurfaceFilters::BuildImageFilter(
        effect->Filter().AsCcFilterOperations(), empty));
    save_layer_id = cc_list_.push<cc::SaveLayerOp>(nullptr, &filter_flags);
    saved_count++;

    if (filter_origin != FloatPoint())
      cc_list_.push<cc::TranslateOp>(-filter_origin.X(), -filter_origin.Y());
  }
  cc_list_.EndPaintOfPairedBegin();

  DCHECK_GT(saved_count, 0);
  DCHECK_LE(saved_count, 2);
  DCHECK_NE(save_layer_id, kNotFound);

  const ClipPaintPropertyNode* input_clip = current_clip_;
  PushState(StateEntry::kEffect, saved_count);
  effect_bounds_stack_.emplace_back(
      EffectBoundsInfo{save_layer_id, current_transform_});
  current_clip_ = input_clip;
  current_effect_ = effect;
}

  void LocalToAncestorVisualRectInternal(
      const PropertyTreeState& local_state,
      const PropertyTreeState& ancestor_state,
      FloatClipRect& mapping_rect,
      bool& success) {
    GeometryMapper::LocalToAncestorVisualRectInternal(
        local_state, ancestor_state, mapping_rect,
        kIgnorePlatformOverlayScrollbarSize, kNonInclusiveIntersect, success);
  }

  void DidScroll(const gfx::ScrollOffset& offset, const CompositorElementId&) {
    did_scroll_count++;
    last_scroll_offset = offset;
  };

void CreateSimpleArtifactWithOpacity(TestPaintArtifact& artifact,
float opacity,
bool include_preceding_chunk,
bool include_subsequent_chunk) {
if (include_preceding_chunk)
AddSimpleRectChunk(artifact);
auto effect = CreateOpacityEffect(EffectPaintPropertyNode::Root(), opacity);
    artifact
        .Chunk(TransformPaintPropertyNode::Root(),
               ClipPaintPropertyNode::Root(), effect)
.RectDrawing(FloatRect(0, 0, 100, 100), Color::kBlack);
if (include_subsequent_chunk)
AddSimpleRectChunk(artifact);
Update(artifact.Build());
}

void PaintPropertyTreeBuilder::UpdateCompositedLayerPaginationOffset() {
  if (RuntimeEnabledFeatures::SlimmingPaintV2Enabled())
    return;

  const auto* enclosing_pagination_layer =
      context_.painting_layer->EnclosingPaginationLayer();
  if (!enclosing_pagination_layer)
    return;

  FragmentData& first_fragment =
      object_.GetMutableForPainting().FirstFragment();
  bool is_paint_invalidation_container = object_.IsPaintInvalidationContainer();
  const auto* parent_composited_layer =
      context_.painting_layer->EnclosingLayerWithCompositedLayerMapping(
          is_paint_invalidation_container ? kExcludeSelf : kIncludeSelf);
  if (is_paint_invalidation_container &&
      (!parent_composited_layer ||
       !parent_composited_layer->EnclosingPaginationLayer())) {
    FragmentainerIterator iterator(
        ToLayoutFlowThread(enclosing_pagination_layer->GetLayoutObject()),
        BoundingBoxInPaginationContainer(object_, *enclosing_pagination_layer));
    if (!iterator.AtEnd()) {
      first_fragment.SetPaginationOffset(
          ToLayoutPoint(iterator.PaginationOffset()));
      first_fragment.SetLogicalTopInFlowThread(
          iterator.FragmentainerLogicalTopInFlowThread());
    }
  } else if (parent_composited_layer) {
    const auto& fragment =
        parent_composited_layer->GetLayoutObject().FirstFragment();
    first_fragment.SetPaginationOffset(fragment.PaginationOffset());
    first_fragment.SetLogicalTopInFlowThread(fragment.LogicalTopInFlowThread());
  }
}

void ConversionContext::SwitchToChunkState(const PaintChunk& chunk) {
  chunk_to_layer_mapper_.SwitchToChunk(chunk);

  const auto& chunk_state = chunk.properties;
  SwitchToEffect(chunk_state.Effect());
  SwitchToClip(chunk_state.Clip());
  SwitchToTransform(chunk_state.Transform());
}

  int ElementIdToTransformNodeIndex(CompositorElementId element_id) {
    return web_layer_tree_view_->GetLayerTreeHost()
        ->property_trees()
        ->element_id_to_transform_node_index[element_id];
  }

bool PaintPropertyTreeBuilder::IsRepeatingInPagedMedia() const {
  return context_.is_repeating_fixed_position ||
         (context_.is_repeating_table_section &&
          !context_.painting_layer->EnclosingPaginationLayer());
}

void PropertyTreeManager::SetupRootClipNode() {
// cc is hardcoded to use clip node index 1 for viewport clip.
cc::ClipTree& clip_tree = property_trees_.clip_tree;
clip_tree.clear();
cc::ClipNode& clip_node =
*clip_tree.Node(clip_tree.Insert(cc::ClipNode(), kRealRootNodeId));
DCHECK_EQ(clip_node.id, kSecondaryRootNodeId);

clip_node.clip_type = cc::ClipNode::ClipType::APPLIES_LOCAL_CLIP;
clip_node.clip = gfx::RectF(
gfx::SizeF(root_layer_->layer_tree_host()->device_viewport_size()));
clip_node.transform_id = kRealRootNodeId;

  clip_node_map_.Set(ClipPaintPropertyNode::Root(), clip_node.id);
root_layer_->SetClipTreeIndex(clip_node.id);
}

FloatRect EffectPaintPropertyNode::MapRect(const FloatRect& input_rect) const {
  FloatRect rect = input_rect;
  rect.MoveBy(-state_.paint_offset);
  FloatRect result = state_.filter.MapRect(rect);
  result.MoveBy(state_.paint_offset);
  return result;
}

static bool CanUpcastTo(const PropertyTreeState& guest,
                        const PropertyTreeState& home) {
  DCHECK_EQ(home.Effect(), guest.Effect());

  if (IsBackfaceHidden(home.Transform()) != IsBackfaceHidden(guest.Transform()))
    return false;

  for (const ClipPaintPropertyNode* current_clip = guest.Clip();
       current_clip != home.Clip(); current_clip = current_clip->Parent()) {
    if (!current_clip || current_clip->HasDirectCompositingReasons())
      return false;
    if (!IsNonCompositingAncestorOf(home.Transform(),
                                    current_clip->LocalTransformSpace()))
      return false;
  }

  return IsNonCompositingAncestorOf(home.Transform(), guest.Transform());
}

void ConversionContext::EndClip() {
  DCHECK_EQ(state_stack_.back().type, StateEntry::kClip);
  DCHECK_EQ(state_stack_.back().effect, current_effect_);
  EndTransform();
  PopState();
}

  cc::Layer* RootLayer() { return paint_artifact_compositor_->RootLayer(); }

static bool NeedsPerspective(const LayoutObject& object) {
  return object.IsBox() && object.StyleRef().HasPerspective();
}

scoped_refptr<EffectPaintPropertyNode> CreateSampleEffectNodeWithElementId() {
EffectPaintPropertyNode::State state;
  state.local_transform_space = TransformPaintPropertyNode::Root();
  state.output_clip = ClipPaintPropertyNode::Root();
state.opacity = 2.0 / 255.0;
state.direct_compositing_reasons = CompositingReason::kActiveOpacityAnimation;
state.compositor_element_id = CompositorElementId(2);
  return EffectPaintPropertyNode::Create(EffectPaintPropertyNode::Root(),
                                         std::move(state));
}

void PropertyTreeManager::Finalize() {
  while (effect_stack_.size())
    CloseCcEffect();
}

size_t TransformPaintPropertyNode::CacheMemoryUsageInBytes() const {
  size_t total_bytes = sizeof(*this);
  if (transform_cache_)
    total_bytes += sizeof(*transform_cache_);
  if (Parent())
    total_bytes += Parent()->CacheMemoryUsageInBytes();
  return total_bytes;
}

void FragmentPaintPropertyTreeBuilder::UpdateOverflowClip() {
DCHECK(properties_);

if (NeedsPaintPropertyUpdate()) {
if (NeedsOverflowClip(object_) && !CanOmitOverflowClip(object_)) {
ClipPaintPropertyNode::State state;
state.local_transform_space = context_.current.transform;

if (!RuntimeEnabledFeatures::SlimmingPaintV175Enabled() &&
object_.IsSVGForeignObject()) {
state.clip_rect = ToClipRect(ToLayoutBox(object_).FrameRect());
} else if (object_.IsBox()) {
state.clip_rect = ToClipRect(ToLayoutBox(object_).OverflowClipRect(
context_.current.paint_offset));
state.clip_rect_excluding_overlay_scrollbars =
ToClipRect(ToLayoutBox(object_).OverflowClipRect(
context_.current.paint_offset,
kExcludeOverlayScrollbarSizeForHitTesting));
} else {
DCHECK(object_.IsSVGViewportContainer());
const auto& viewport_container = ToLayoutSVGViewportContainer(object_);
state.clip_rect = FloatRoundedRect(
viewport_container.LocalToSVGParentTransform().Inverse().MapRect(
viewport_container.Viewport()));
}

const ClipPaintPropertyNode* existing = properties_->OverflowClip();
bool equal_ignoring_hit_test_rects =
!!existing &&
existing->EqualIgnoringHitTestRects(context_.current.clip, state);
      OnUpdateClip(properties_->UpdateOverflowClip(context_.current.clip,
std::move(state)),
equal_ignoring_hit_test_rects);
} else {
OnClearClip(properties_->ClearOverflowClip());
}
}

if (auto* overflow_clip = properties_->OverflowClip())
context_.current.clip = overflow_clip;
}

  void TestChangeDrawing() {
    FakeDisplayItemClient first("first");
    GraphicsContext context(GetPaintController());

    InitRootChunk();
    first.SetVisualRect(LayoutRect(100, 100, 300, 300));
    DrawRect(context, first, kBackgroundType, FloatRect(100, 100, 300, 300));
    DrawRect(context, first, kForegroundType, FloatRect(100, 100, 300, 300));
    GetPaintController().CommitNewDisplayItems();

    InitRootChunk();
    first.SetVisualRect(LayoutRect(200, 200, 300, 300));
    DrawRect(context, first, kBackgroundType, FloatRect(200, 200, 300, 300));
    DrawRect(context, first, kForegroundType, FloatRect(100, 100, 300, 300));
    GetPaintController().CommitNewDisplayItems();
  }

  void ExpectInitialState() {
    EXPECT_FALSE(root->Changed(*root));
    EXPECT_TRUE(node->Changed(*root));
    EXPECT_TRUE(child1->Changed(*node));
    EXPECT_TRUE(child2->Changed(*node));
    EXPECT_TRUE(grandchild1->Changed(*child1));
    EXPECT_TRUE(grandchild2->Changed(*child2));
  }

  TestDisplayItemRequiringSeparateChunk(const DisplayItemClient& client)
      : TestChunkerDisplayItem(client, DisplayItem::kForeignLayerPlugin) {}

  FakeScrollClient& ScrollClient() { return scroll_client_; }

const ClipPaintPropertyNode* c0() {
  return ClipPaintPropertyNode::Root();
}

bool ScrollHitTestDisplayItem::Equals(const DisplayItem& other) const {
  return DisplayItem::Equals(other) &&
         &scroll_node() ==
             &static_cast<const ScrollHitTestDisplayItem&>(other).scroll_node();
}

  void SetVisualRect(const FloatRect& rect) { rect_ = rect; }

static void Update(scoped_refptr<ClipPaintPropertyNode> node,
                     scoped_refptr<const ClipPaintPropertyNode> new_parent,
const FloatRoundedRect& new_clip_rect) {
    node->Update(std::move(new_parent),
ClipPaintPropertyNode::State{nullptr, new_clip_rect});
}

TestPaintArtifact& TestPaintArtifact::RectDrawing(DisplayItemClient& client,
                                                  const FloatRect& bounds,
                                                  Color color) {
  display_item_list_.AllocateAndConstruct<DrawingDisplayItem>(
      client, DisplayItem::kDrawingFirst,
      static_cast<DummyRectClient&>(client).MakeRecord(bounds, color));
  return *this;
}

void PrintTo(const cc::PaintRecord& record, std::ostream* os) {
  Vector<cc::PaintOpType> ops;
  for (const auto* op : cc::PaintOpBuffer::Iterator(&record))
    ops.push_back(op->GetType());
  PrintTo(ops, os);
}

  static PropertyTreeState DefaultPropertyTreeState() {
    return PropertyTreeState::Root();
  }

size_t PaintController::ApproximateUnsharedMemoryUsage() const {
  size_t memory_usage = sizeof(*this);

  memory_usage += current_paint_artifact_.ApproximateUnsharedMemoryUsage() -
                  sizeof(current_paint_artifact_);


  DCHECK(new_display_item_list_.IsEmpty());
  memory_usage += new_display_item_list_.MemoryUsageInBytes();

  memory_usage += current_cached_subsequences_.Capacity() *
                  sizeof(*current_cached_subsequences_.begin());
  DCHECK(new_cached_subsequences_.IsEmpty());
  memory_usage += new_cached_subsequences_.Capacity() *
                  sizeof(*new_cached_subsequences_.begin());

  return memory_usage;
}

PaintArtifactCompositor::ExtraDataForTesting::ScrollHitTestWebLayerAt(
    unsigned index) {
  return scroll_hit_test_layers[index].get();
}

bool PaintPropertyTreeBuilder::UpdateFragments() {
  bool had_paint_properties = object_.FirstFragment().PaintProperties();
  bool needs_paint_properties =
      object_.StyleRef().ClipPath() || NeedsPaintOffsetTranslation(object_) ||
      NeedsTransform(object_) || NeedsClipPathClip(object_) ||
      NeedsEffect(object_) || NeedsTransformForNonRootSVG(object_) ||
      NeedsFilter(object_) || NeedsCssClip(object_) ||
      NeedsInnerBorderRadiusClip(object_) || NeedsOverflowClip(object_) ||
      NeedsPerspective(object_) || NeedsSVGLocalToBorderBoxTransform(object_) ||
      NeedsScrollOrScrollTranslation(object_);

  if (object_.IsFixedPositionObjectInPagedMedia()) {
    context_.is_repeating_fixed_position = true;
    CreateFragmentContextsForRepeatingFixedPosition();
  } else if (ObjectIsRepeatingTableSectionInPagedMedia()) {
    context_.is_repeating_table_section = true;
    CreateFragmentContextsForRepeatingTableSectionInPagedMedia();
  }

  if (IsRepeatingInPagedMedia()) {
    CreateFragmentDataForRepeatingInPagedMedia(needs_paint_properties);
  } else if (context_.painting_layer->ShouldFragmentCompositedBounds()) {
    CreateFragmentContextsInFlowThread(needs_paint_properties);
  } else {
    InitSingleFragmentFromParent(needs_paint_properties);
    UpdateCompositedLayerPaginationOffset();
    context_.is_repeating_fixed_position = false;
    context_.is_repeating_table_section = false;
  }

  if (object_.IsSVGHiddenContainer()) {
    context_.fragments.clear();
    context_.fragments.Grow(1);
    context_.has_svg_hidden_container_ancestor = true;
    PaintPropertyTreeBuilderFragmentContext& fragment_context =
        context_.fragments[0];

    fragment_context.current.paint_offset_root =
        fragment_context.absolute_position.paint_offset_root =
            fragment_context.fixed_position.paint_offset_root = &object_;

    object_.GetMutableForPainting().FirstFragment().ClearNextFragment();
  }

  if (object_.HasLayer()) {
    ToLayoutBoxModelObject(object_).Layer()->SetIsUnderSVGHiddenContainer(
        context_.has_svg_hidden_container_ancestor);
  }

  UpdateRepeatingTableSectionPaintOffsetAdjustment();

  return needs_paint_properties != had_paint_properties;
}

  cc::Layer* ContentLayerAt(unsigned index) {
    return paint_artifact_compositor_->GetExtraDataForTesting()
        ->content_layers[index]
        .get();
  }

static bool NeedsClipPathClip(const LayoutObject& object) {
  if (!object.StyleRef().ClipPath())
    return false;

  return object.FirstFragment().ClipPathPath();
}

int PropertyTreeManager::EnsureCompositorScrollNode(
    const TransformPaintPropertyNode* scroll_offset_translation) {
  const auto* scroll_node = scroll_offset_translation->ScrollNode();
  DCHECK(scroll_node);
  EnsureCompositorTransformNode(scroll_offset_translation);
  auto it = scroll_node_map_.find(scroll_node);
  DCHECK(it != scroll_node_map_.end());
  return it->value;
}

PaintArtifactCompositor::~PaintArtifactCompositor() {
  if (RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled())
    return;
  for (auto child : root_layer_->children())
    DCHECK(!child->element_id());
}

  bool PropertyChanged() const { return property_changed_; }

  CompositedLayerRasterInvalidatorTest& Bounds(const FloatRect& bounds) {
    data_.chunks.back().bounds = bounds;
    return *this;
  }

static bool CanOmitOverflowClip(const LayoutObject& object) {
  DCHECK(NeedsOverflowClip(object));
  if (!object.IsLayoutBlock() || object.IsSVG())
    return false;

  const auto& block = ToLayoutBlock(object);
  if (block.HasLayer() && block.Layer()->FirstChild())
    return false;
  if (block.GetSelectionState() != SelectionState::kNone)
    return false;
  if (block.HasControlClip() || block.ShouldPaintCarets())
    return false;

  auto clip_rect = block.OverflowClipRect(LayoutPoint());
  auto clip_rect_excluding_overlay_scrollbars = block.OverflowClipRect(
      LayoutPoint(), kExcludeOverlayScrollbarSizeForHitTesting);
  if (clip_rect != clip_rect_excluding_overlay_scrollbars)
    return false;
  return clip_rect.Contains(block.ContentsVisualOverflowRect());
}

void PaintArtifactCompositor::LayerizeGroup(
    const PaintArtifact& paint_artifact,
    Vector<PendingLayer>& pending_layers,
    const EffectPaintPropertyNode& current_group,
    Vector<PaintChunk>::const_iterator& chunk_it) {
  if (SkipGroupIfEffectivelyInvisible(paint_artifact, current_group, chunk_it))
    return;

  size_t first_layer_in_current_group = pending_layers.size();
  while (chunk_it != paint_artifact.PaintChunks().end()) {
    const auto* chunk_effect = chunk_it->properties.Effect();
    if (chunk_effect == &current_group) {
      const auto& last_display_item =
          paint_artifact.GetDisplayItemList()[chunk_it->begin_index];
      bool requires_own_layer = last_display_item.IsForeignLayer() ||
                                last_display_item.IsScrollHitTest();
      pending_layers.push_back(PendingLayer(
          *chunk_it, chunk_it - paint_artifact.PaintChunks().begin(),
          requires_own_layer));
      chunk_it++;
      if (requires_own_layer)
        continue;
    } else {
      const EffectPaintPropertyNode* subgroup =
          StrictChildOfAlongPath(&current_group, chunk_effect);
      if (!subgroup)
        break;
      size_t first_layer_in_subgroup = pending_layers.size();
      LayerizeGroup(paint_artifact, pending_layers, *subgroup, chunk_it);
      if (pending_layers.size() != first_layer_in_subgroup + 1)
        continue;
      PendingLayer& subgroup_layer = pending_layers[first_layer_in_subgroup];
      if (!CanDecompositeEffect(subgroup, subgroup_layer))
        continue;
      subgroup_layer.Upcast(PropertyTreeState(
          subgroup->LocalTransformSpace(),
          subgroup->OutputClip() ? subgroup->OutputClip()
                                 : subgroup_layer.property_tree_state.Clip(),
          &current_group));
    }
    const PendingLayer& new_layer = pending_layers.back();
    DCHECK(!new_layer.requires_own_layer);
    DCHECK_EQ(&current_group, new_layer.property_tree_state.Effect());
    for (size_t candidate_index = pending_layers.size() - 1;
         candidate_index-- > first_layer_in_current_group;) {
      PendingLayer& candidate_layer = pending_layers[candidate_index];
      if (candidate_layer.CanMerge(new_layer)) {
        candidate_layer.Merge(new_layer);
        pending_layers.pop_back();
        break;
      }
      if (MightOverlap(new_layer, candidate_layer))
        break;
    }
  }
}

void PaintPropertyTreeBuilderTest::LoadTestData(const char* file_name) {
  String full_path = test::BlinkRootDir();
  full_path.append("/renderer/core/paint/test_data/");
  full_path.append(file_name);
  const Vector<char> input_buffer = test::ReadFromFile(full_path)->Copy();
  SetBodyInnerHTML(String(input_buffer.data(), input_buffer.size()));
}

static CompositingReasons CompositingReasonsForScroll(const LayoutBox& box) {
  CompositingReasons compositing_reasons = CompositingReason::kNone;
  if (auto* scrollable_area = box.GetScrollableArea()) {
    if (auto* layer = scrollable_area->Layer()) {
      if (CompositingReasonFinder::RequiresCompositingForRootScroller(*layer))
        compositing_reasons |= CompositingReason::kRootScroller;
    }
  }
  return compositing_reasons;
}

PaintPropertyTreeBuilder::ContextForFragment(
    const base::Optional<LayoutRect>& fragment_clip,
    LayoutUnit logical_top_in_flow_thread) const {
  const auto& parent_fragments = context_.fragments;
  if (parent_fragments.IsEmpty())
    return PaintPropertyTreeBuilderFragmentContext();

  LayoutUnit logical_top_in_containing_flow_thread;

  if (object_.IsLayoutFlowThread()) {
    const auto& flow_thread = ToLayoutFlowThread(object_);
    logical_top_in_containing_flow_thread =
        FragmentLogicalTopInParentFlowThread(flow_thread,
                                             logical_top_in_flow_thread);
    for (const auto& parent_context : parent_fragments) {
      if (logical_top_in_containing_flow_thread ==
          parent_context.logical_top_in_flow_thread) {
        auto context = parent_context;
        context.fragment_clip = fragment_clip;
        context.logical_top_in_flow_thread = logical_top_in_flow_thread;
        return context;
      }
    }
  } else {
    bool parent_is_under_same_flow_thread;
    auto* pagination_layer =
        context_.painting_layer->EnclosingPaginationLayer();
    if (object_.IsColumnSpanAll()) {
      parent_is_under_same_flow_thread = false;
    } else if (object_.IsOutOfFlowPositioned()) {
      parent_is_under_same_flow_thread =
          (object_.Parent()->PaintingLayer()->EnclosingPaginationLayer() ==
           pagination_layer);
    } else {
      parent_is_under_same_flow_thread = true;
    }

    if (parent_is_under_same_flow_thread) {
      DCHECK(object_.Parent()->PaintingLayer()->EnclosingPaginationLayer() ==
             pagination_layer);
      for (const auto& parent_context : parent_fragments) {
        if (logical_top_in_flow_thread ==
            parent_context.logical_top_in_flow_thread) {
          auto context = parent_context;
          context.fragment_clip = base::nullopt;
          return context;
        }
      }
    }

    logical_top_in_containing_flow_thread = logical_top_in_flow_thread;
  }

  auto context = parent_fragments[0];
  context.logical_top_in_flow_thread = logical_top_in_flow_thread;
  context.fragment_clip = fragment_clip;

  for (const auto* container = object_.Container(); container;
       container = container->Container()) {
    if (!container->FirstFragment().HasLocalBorderBoxProperties())
      continue;

    for (const auto* fragment = &container->FirstFragment(); fragment;
         fragment = fragment->NextFragment()) {
      if (fragment->LogicalTopInFlowThread() ==
          logical_top_in_containing_flow_thread) {
        DCHECK(fragment->PostOverflowClip());
        context.current.clip = fragment->PostOverflowClip();
        return context;
      }
    }

    if (container->IsLayoutFlowThread()) {
      logical_top_in_containing_flow_thread =
          FragmentLogicalTopInParentFlowThread(
              ToLayoutFlowThread(*container),
              logical_top_in_containing_flow_thread);
    }
  }

  NOTREACHED();
  return context;
}

size_t CompositedLayerRasterInvalidator::MatchNewChunkToOldChunk(
    const PaintChunk& new_chunk,
    size_t old_index) {
  for (size_t i = old_index; i < paint_chunks_info_.size(); i++) {
    if (paint_chunks_info_[i].Matches(new_chunk))
      return i;
  }
  for (size_t i = 0; i < old_index; i++) {
    if (paint_chunks_info_[i].Matches(new_chunk))
      return i;
  }
  return kNotFound;
}

    UpdateRepeatingTableSectionPaintOffsetAdjustment() {
  if (!context_.is_repeating_table_section)
    return;

  if (object_.IsTableSection()) {
    if (ToLayoutTableSection(object_).IsRepeatingHeaderGroup())
      UpdateRepeatingTableHeaderPaintOffsetAdjustment();
    else if (ToLayoutTableSection(object_).IsRepeatingFooterGroup())
      UpdateRepeatingTableFooterPaintOffsetAdjustment();
  } else if (!context_.painting_layer->EnclosingPaginationLayer()) {
    for (auto& fragment_context : context_.fragments) {
      fragment_context.repeating_paint_offset_adjustment = LayoutSize();
    }
  }

}

void CompositedLayerRasterInvalidator::FullyInvalidateNewChunk(
    const PaintChunkInfo& info,
    PaintInvalidationReason reason) {
  AddRasterInvalidation(info.bounds_in_layer, &info.id.client, reason);
}

  void OnClear(bool cleared) {
    property_added_or_removed_ |= cleared;
    property_changed_ |= cleared;
  }

void PaintPropertyTreeBuilder::CreateFragmentContextsInFlowThread(
    bool needs_paint_properties) {
  PaintLayer* paint_layer = context_.painting_layer;
  PaintLayer* enclosing_pagination_layer =
      paint_layer->EnclosingPaginationLayer();

  const auto& flow_thread =
      ToLayoutFlowThread(enclosing_pagination_layer->GetLayoutObject());
  LayoutRect object_bounding_box_in_flow_thread;
  if (context_.is_repeating_table_section) {
    object_bounding_box_in_flow_thread =
        context_.repeating_table_section_bounding_box;
  } else {
    object_bounding_box_in_flow_thread =
        BoundingBoxInPaginationContainer(object_, *enclosing_pagination_layer);
    if (IsRepeatingTableSection(object_)) {
      context_.is_repeating_table_section = true;
      context_.repeating_table_section_bounding_box =
          object_bounding_box_in_flow_thread;
    }
  }

  FragmentData* current_fragment_data = nullptr;
  FragmentainerIterator iterator(flow_thread,
                                 object_bounding_box_in_flow_thread);
  bool fragments_changed = false;
  Vector<PaintPropertyTreeBuilderFragmentContext, 1> new_fragment_contexts;
  for (; !iterator.AtEnd(); iterator.Advance()) {
    auto pagination_offset = ToLayoutPoint(iterator.PaginationOffset());
    auto logical_top_in_flow_thread =
        iterator.FragmentainerLogicalTopInFlowThread();
    base::Optional<LayoutRect> fragment_clip;

    if (object_.HasLayer()) {
      fragment_clip = iterator.ClipRectInFlowThread();
      fragment_clip->MoveBy(pagination_offset);
      {
        DCHECK(context_.fragments[0].current.paint_offset_root);
        LayoutPoint pagination_visual_offset = VisualOffsetFromPaintOffsetRoot(
            context_.fragments[0], enclosing_pagination_layer);
        pagination_visual_offset.MoveBy(
            context_.fragments[0]
                .current.paint_offset_root->FirstFragment()
                .PaintOffset());
        fragment_clip->MoveBy(pagination_visual_offset);
      }
    }

    new_fragment_contexts.push_back(
        ContextForFragment(fragment_clip, logical_top_in_flow_thread));

    base::Optional<LayoutUnit> old_logical_top_in_flow_thread;
    if (current_fragment_data) {
      if (const auto* old_fragment = current_fragment_data->NextFragment())
        old_logical_top_in_flow_thread = old_fragment->LogicalTopInFlowThread();
      current_fragment_data = &current_fragment_data->EnsureNextFragment();
    } else {
      current_fragment_data = &object_.GetMutableForPainting().FirstFragment();
      old_logical_top_in_flow_thread =
          current_fragment_data->LogicalTopInFlowThread();
    }

    if (!old_logical_top_in_flow_thread ||
        *old_logical_top_in_flow_thread != logical_top_in_flow_thread)
      fragments_changed = true;

    InitFragmentPaintProperties(
        *current_fragment_data,
        needs_paint_properties || new_fragment_contexts.back().fragment_clip,
        pagination_offset, logical_top_in_flow_thread);
  }

  if (!current_fragment_data) {
    InitSingleFragmentFromParent(needs_paint_properties);
  } else {
    if (current_fragment_data->NextFragment())
      fragments_changed = true;
    current_fragment_data->ClearNextFragment();
    context_.fragments = std::move(new_fragment_contexts);
  }

  if (fragments_changed)
    object_.GetMutableForPainting().SetSubtreeNeedsPaintPropertyUpdate();
}

void ChunkToLayerMapper::AdjustVisualRectBySubpixelOffset(
    FloatRect& rect) const {
  if (chunk_state_.Transform() == layer_state_.Transform())
    rect.Move(visual_rect_subpixel_offset_);
}

static FloatClipRect GetClipRect(const ClipPaintPropertyNode* clip_node,
                                 OverlayScrollbarClipBehavior clip_behavior) {
  FloatClipRect clip_rect(
      UNLIKELY(clip_behavior == kExcludeOverlayScrollbarSizeForHitTesting)
          ? clip_node->ClipRectExcludingOverlayScrollbars()
          : clip_node->ClipRect());
  if (clip_node->ClipPath())
    clip_rect.ClearIsTight();
  return clip_rect;
}

void CompositedLayerRasterInvalidator::IncrementallyInvalidateChunk(
    const PaintChunkInfo& old_chunk,
    const PaintChunkInfo& new_chunk) {
  SkRegion diff(old_chunk.bounds_in_layer);
  diff.op(new_chunk.bounds_in_layer, SkRegion::kXOR_Op);
  for (SkRegion::Iterator it(diff); !it.done(); it.next()) {
    const SkIRect& r = it.rect();
    AddRasterInvalidation(IntRect(r.x(), r.y(), r.width(), r.height()),
                          &new_chunk.id.client,
                          PaintInvalidationReason::kIncremental);
  }
}

void FragmentPaintPropertyTreeBuilder::UpdateTransform() {
if (object_.IsSVGChild()) {
UpdateTransformForNonRootSVG();
return;
}

DCHECK(properties_);

if (NeedsPaintPropertyUpdate()) {
const ComputedStyle& style = object_.StyleRef();
// A transform node is allocated for transforms, preserves-3d and any
// direct compositing reason. The latter is required because this is the
// only way to represent compositing both an element and its stacking
// descendants.
if (NeedsTransform(object_)) {
TransformPaintPropertyNode::State state;

if (object_.IsBox()) {
auto& box = ToLayoutBox(object_);
state.origin = TransformOrigin(box);
style.ApplyTransform(
state.matrix, box.Size(), ComputedStyle::kExcludeTransformOrigin,
ComputedStyle::kIncludeMotionPath,
ComputedStyle::kIncludeIndependentTransformProperties);

if (RuntimeEnabledFeatures::SlimmingPaintV2Enabled() ||
RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) {
// TODO(trchen): transform-style should only be respected if a
// PaintLayer is created. If a node with transform-style: preserve-3d
// does not exist in an existing rendering context, it establishes a
// new one.
state.rendering_context_id = context_.current.rendering_context_id;
if (style.Preserves3D() && !state.rendering_context_id) {
state.rendering_context_id =
PtrHash<const LayoutObject>::GetHash(&object_);
}
state.direct_compositing_reasons =
CompositingReasonsForTransform(box);
}
}

state.flattens_inherited_transform =
context_.current.should_flatten_inherited_transform;

if (RuntimeEnabledFeatures::SlimmingPaintV2Enabled() ||
RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) {
state.backface_visibility =
object_.HasHiddenBackface()
? TransformPaintPropertyNode::BackfaceVisibility::kHidden
: TransformPaintPropertyNode::BackfaceVisibility::kVisible;
state.compositor_element_id = CompositorElementIdFromUniqueObjectId(
object_.UniqueId(), CompositorElementIdNamespace::kPrimary);
}

      OnUpdate(properties_->UpdateTransform(context_.current.transform,
std::move(state)));
} else {
OnClear(properties_->ClearTransform());
}
}

if (properties_->Transform()) {
context_.current.transform = properties_->Transform();
if (object_.StyleRef().Preserves3D()) {
context_.current.rendering_context_id =
properties_->Transform()->RenderingContextId();
context_.current.should_flatten_inherited_transform = false;
} else {
context_.current.rendering_context_id = 0;
context_.current.should_flatten_inherited_transform = true;
}
}
}

void ScrollHitTestDisplayItem::PropertiesAsJSON(JSONObject& json) const {
DisplayItem::PropertiesAsJSON(json);
json.SetString("scrollOffsetNode",
                 String::Format("%p", scroll_offset_node_.get()));
}

void PaintController::AddRasterInvalidation(const DisplayItemClient& client,
                                            PaintChunk& chunk,
                                            const FloatRect& rect,
                                            PaintInvalidationReason reason) {
  new_paint_chunks_.AddRasterInvalidation(chunk, rect);
  if (RasterInvalidationTracking::ShouldAlwaysTrack())
    EnsureRasterInvalidationTracking();
  if (raster_invalidation_tracking_info_)
    TrackRasterInvalidation(client, chunk, reason);
}

void PaintController::TrackRasterInvalidation(const DisplayItemClient& client,
                                              PaintChunk& chunk,
                                              PaintInvalidationReason reason) {
  DCHECK(raster_invalidation_tracking_info_);

  RasterInvalidationInfo info;
  info.client = &client;
  if (reason == PaintInvalidationReason::kNone) {
    DCHECK(!ClientCacheIsValid(client));
    info.reason = PaintInvalidationReason::kFull;
  } else {
    info.reason = reason;
  }

  if (reason == PaintInvalidationReason::kDisappeared) {
    info.client_debug_name =
        raster_invalidation_tracking_info_->old_client_debug_names.at(&client);
  } else {
    info.client_debug_name = client.DebugName();
  }

  new_paint_chunks_.TrackRasterInvalidation(chunk, info);
}

void ChunkToLayerMapper::SwitchToChunk(const PaintChunk& chunk) {
outset_for_raster_effects_ = chunk.outset_for_raster_effects;

  const auto& new_chunk_state = chunk.properties.GetPropertyTreeState();
if (new_chunk_state == chunk_state_)
return;

if (new_chunk_state == layer_state_) {
has_filter_that_moves_pixels_ = false;
transform_ = TransformationMatrix().Translate(-layer_offset_.x(),
-layer_offset_.y());
clip_rect_ = FloatClipRect();
chunk_state_ = new_chunk_state;
return;
}

if (new_chunk_state.Transform() != chunk_state_.Transform()) {
transform_ = GeometryMapper::SourceToDestinationProjection(
new_chunk_state.Transform(), layer_state_.Transform());
transform_.PostTranslate(-layer_offset_.x(), -layer_offset_.y());
}

bool new_has_filter_that_moves_pixels = has_filter_that_moves_pixels_;
if (new_chunk_state.Effect() != chunk_state_.Effect()) {
new_has_filter_that_moves_pixels = false;
for (const auto* effect = new_chunk_state.Effect();
effect && effect != layer_state_.Effect(); effect = effect->Parent()) {
if (effect->HasFilterThatMovesPixels()) {
new_has_filter_that_moves_pixels = true;
break;
}
}
}

bool needs_clip_recalculation =
new_has_filter_that_moves_pixels != has_filter_that_moves_pixels_ ||
new_chunk_state.Clip() != chunk_state_.Clip();
if (needs_clip_recalculation) {
clip_rect_ =
GeometryMapper::LocalToAncestorClipRect(new_chunk_state, layer_state_);
if (!clip_rect_.IsInfinite())
clip_rect_.MoveBy(FloatPoint(-layer_offset_.x(), -layer_offset_.y()));
}

chunk_state_ = new_chunk_state;
has_filter_that_moves_pixels_ = new_has_filter_that_moves_pixels;
}

const CompositorElementId RefCountedPropertyTreeState::GetCompositorElementId(
    const CompositorElementIdSet& element_ids) const {
  if (Effect()->GetCompositorElementId() &&
      !element_ids.Contains(Effect()->GetCompositorElementId()))
    return Effect()->GetCompositorElementId();
  if (Transform()->GetCompositorElementId() &&
      !element_ids.Contains(Transform()->GetCompositorElementId()))
    return Transform()->GetCompositorElementId();
  return CompositorElementId();
}

gfx::Transform Translation(SkMScalar x, SkMScalar y) {
  gfx::Transform transform;
  transform.Translate(x, y);
  return transform;
}

  TestChunkerDisplayItem(const DisplayItemClient& client,
                         DisplayItem::Type type = DisplayItem::kDrawingFirst)
      : DisplayItem(client, type, sizeof(*this)) {}

  void TestMoreDrawing() {
    FakeDisplayItemClient first("first");
    GraphicsContext context(GetPaintController());

    InitRootChunk();
    DrawRect(context, first, kBackgroundType, FloatRect(100, 100, 300, 300));
    GetPaintController().CommitNewDisplayItems();

    InitRootChunk();
    DrawRect(context, first, kBackgroundType, FloatRect(100, 100, 300, 300));
    DrawRect(context, first, kForegroundType, FloatRect(100, 100, 300, 300));
    GetPaintController().CommitNewDisplayItems();
  }

void ConversionContext::EndEffect() {
  const auto& previous_state = state_stack_.back();
  DCHECK_EQ(previous_state.type, StateEntry::kEffect);
  DCHECK_EQ(current_effect_->Parent(), previous_state.effect);
  DCHECK_EQ(current_clip_, previous_state.clip);

  DCHECK(effect_bounds_stack_.size());
  const auto& bounds_info = effect_bounds_stack_.back();
  FloatRect bounds = bounds_info.bounds;
  if (!bounds.IsEmpty()) {
    if (current_effect_->Filter().IsEmpty()) {
      cc_list_.UpdateSaveLayerBounds(bounds_info.save_layer_id, bounds);
    } else {
      auto save_layer_bounds = bounds;
      save_layer_bounds.MoveBy(-current_effect_->PaintOffset());
      cc_list_.UpdateSaveLayerBounds(bounds_info.save_layer_id,
                                     save_layer_bounds);
      bounds = current_effect_->MapRect(bounds);
    }
  }

  effect_bounds_stack_.pop_back();
  EndTransform();
  UpdateEffectBounds(bounds, current_transform_);
  PopState();
}

void FragmentPaintPropertyTreeBuilder::UpdateFilter() {
DCHECK(properties_);
const ComputedStyle& style = object_.StyleRef();

if (NeedsPaintPropertyUpdate()) {
if (NeedsFilter(object_)) {
EffectPaintPropertyNode::State state;
state.local_transform_space = context_.current.transform;
state.paint_offset = FloatPoint(context_.current.paint_offset);

auto* layer = ToLayoutBoxModelObject(object_).Layer();
if (layer) {
// Try to use the cached filter.
if (properties_->Filter())
state.filter = properties_->Filter()->Filter();

if (object_.IsLayoutImage() &&
ToLayoutImage(object_).ShouldInvertColor())
state.filter.AppendInvertFilter(1.0f);

layer->UpdateCompositorFilterOperationsForFilter(state.filter);
layer->ClearFilterOnEffectNodeDirty();
} else {
DCHECK(object_.IsLayoutImage() &&
ToLayoutImage(object_).ShouldInvertColor());
state.filter = CompositorFilterOperations();
state.filter.AppendInvertFilter(1.0f);
}

// The CSS filter spec didn't specify how filters interact with overflow
// clips. The implementation here mimics the old Blink/WebKit behavior for
// backward compatibility.
// Basically the output of the filter will be affected by clips that
// applies to the current element. The descendants that paints into the
// input of the filter ignores any clips collected so far. For example:
// <div style="overflow:scroll">
//   <div style="filter:blur(1px);">
//     <div>A</div>
//     <div style="position:absolute;">B</div>
//   </div>
// </div>
// In this example "A" should be clipped if the filter was not present.
// With the filter, "A" will be rastered without clipping, but instead
// the blurred result will be clipped.
// On the other hand, "B" should not be clipped because the overflow clip
// is not in its containing block chain, but as the filter output will be
// clipped, so a blurred "B" may still be invisible.
state.output_clip = context_.current.clip;

// TODO(trchen): A filter may contain spatial operations such that an
// output pixel may depend on an input pixel outside of the output clip.
// We should generate a special clip node to represent this expansion.

if (RuntimeEnabledFeatures::SlimmingPaintV2Enabled() ||
RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) {
// We may begin to composite our subtree prior to an animation starts,
// but a compositor element ID is only needed when an animation is
// current.
state.direct_compositing_reasons =
CompositingReasonFinder::RequiresCompositingForFilterAnimation(
style)
? CompositingReason::kActiveFilterAnimation
: CompositingReason::kNone;
DCHECK(!style.HasCurrentFilterAnimation() ||
state.direct_compositing_reasons != CompositingReason::kNone);

state.compositor_element_id = CompositorElementIdFromUniqueObjectId(
object_.UniqueId(), CompositorElementIdNamespace::kEffectFilter);
}

      OnUpdate(
          properties_->UpdateFilter(context_.current_effect, std::move(state)));
} else {
OnClear(properties_->ClearFilter());
}
}

if (properties_->Filter()) {
context_.current_effect = properties_->Filter();
// TODO(trchen): Change input clip to expansion hint once implemented.
const ClipPaintPropertyNode* input_clip =
properties_->Filter()->OutputClip();
context_.current.clip = context_.absolute_position.clip =
context_.fixed_position.clip = input_clip;
}
}

void PrintTo(const SkRect& rect, std::ostream* os) {
  *os << (cc::PaintOp::IsUnsetRect(rect) ? "(unset)"
                                         : blink::FloatRect(rect).ToString());
}

void PropertyTreeManager::SetupRootScrollNode() {
cc::ScrollTree& scroll_tree = property_trees_.scroll_tree;
scroll_tree.clear();
property_trees_.element_id_to_scroll_node_index.clear();
cc::ScrollNode& scroll_node =
*scroll_tree.Node(scroll_tree.Insert(cc::ScrollNode(), kRealRootNodeId));
DCHECK_EQ(scroll_node.id, kSecondaryRootNodeId);
scroll_node.transform_id = kSecondaryRootNodeId;

  scroll_node_map_.Set(ScrollPaintPropertyNode::Root(), scroll_node.id);
root_layer_->SetScrollTreeIndex(scroll_node.id);
}

static FloatRect ComputeBottomDelta(const FloatPoint& location,
                                    const FloatSize& old_size,
                                    const FloatSize& new_size) {
  float delta = new_size.Height() - old_size.Height();
  if (delta > 0) {
    return FloatRect(location.X(), location.Y() + old_size.Height(),
                     new_size.Width(), delta);
  }
  if (delta < 0) {
    return FloatRect(location.X(), location.Y() + new_size.Height(),
                     old_size.Width(), -delta);
  }
  return FloatRect();
}

  CompositorElementId ScrollElementId(unsigned id) {
    return CompositorElementIdFromUniqueObjectId(
        id, CompositorElementIdNamespace::kScroll);
  }

TestPaintArtifact& TestPaintArtifact::Chunk(
DisplayItemClient& client,
    scoped_refptr<const TransformPaintPropertyNode> transform,
    scoped_refptr<const ClipPaintPropertyNode> clip,
    scoped_refptr<const EffectPaintPropertyNode> effect) {
  return Chunk(client,
               PropertyTreeState(transform.get(), clip.get(), effect.get()));
}

void CompositedLayerRasterInvalidator::GenerateRasterInvalidations(
    const PaintArtifact& paint_artifact,
    const PaintChunkSubset& new_chunks,
    const PropertyTreeState& layer_state,
    const FloatSize& visual_rect_subpixel_offset,
    Vector<PaintChunkInfo>& new_chunks_info) {
  ChunkToLayerMapper mapper(layer_state, layer_bounds_.OffsetFromOrigin(),
                            visual_rect_subpixel_offset);
  Vector<bool> old_chunks_matched;
  old_chunks_matched.resize(paint_chunks_info_.size());
  size_t old_index = 0;
  size_t max_matched_old_index = 0;
  for (const auto& new_chunk : new_chunks) {
    mapper.SwitchToChunk(new_chunk);
    auto& new_chunk_info =
        new_chunks_info.emplace_back(*this, mapper, new_chunk);

    if (!new_chunk.is_cacheable) {
      FullyInvalidateNewChunk(new_chunk_info,
                              PaintInvalidationReason::kChunkUncacheable);
      continue;
    }

    size_t matched_old_index = MatchNewChunkToOldChunk(new_chunk, old_index);
    if (matched_old_index == kNotFound) {
      FullyInvalidateNewChunk(new_chunk_info,
                              PaintInvalidationReason::kChunkAppeared);
      continue;
    }

    DCHECK(!old_chunks_matched[matched_old_index]);
    old_chunks_matched[matched_old_index] = true;

    auto& old_chunk_info = paint_chunks_info_[matched_old_index];
    old_chunk_info.bounds_in_layer =
        ClipByLayerBounds(old_chunk_info.bounds_in_layer);

    PaintInvalidationReason reason =
        matched_old_index < max_matched_old_index
            ? PaintInvalidationReason::kChunkReordered
            : ChunkPropertiesChanged(new_chunk.properties, new_chunk_info,
                                     old_chunk_info, layer_state);

    if (IsFullPaintInvalidationReason(reason)) {
      FullyInvalidateChunk(old_chunk_info, new_chunk_info, reason);
    } else {
      new_chunk_info.chunk_to_layer_transform =
          old_chunk_info.chunk_to_layer_transform;

      if (reason == PaintInvalidationReason::kIncremental)
        IncrementallyInvalidateChunk(old_chunk_info, new_chunk_info);

      AddDisplayItemRasterInvalidations(paint_artifact, new_chunk, mapper);
    }

    old_index = matched_old_index + 1;
    if (old_index == paint_chunks_info_.size())
      old_index = 0;
    max_matched_old_index = std::max(max_matched_old_index, matched_old_index);
  }

  for (size_t i = 0; i < paint_chunks_info_.size(); ++i) {
    if (old_chunks_matched[i])
      continue;
    FullyInvalidateOldChunk(paint_chunks_info_[i],
                            paint_chunks_info_[i].is_cacheable
                                ? PaintInvalidationReason::kChunkDisappeared
                                : PaintInvalidationReason::kChunkUncacheable);
  }
}

    CreateFragmentContextsForRepeatingFixedPosition() {
  DCHECK(object_.IsFixedPositionObjectInPagedMedia());

  LayoutView* view = object_.View();
  auto page_height = view->PageLogicalHeight();
  int page_count = ceilf(view->DocumentRect().Height() / page_height);
  context_.fragments.resize(page_count);

  context_.fragments[0].fixed_position.paint_offset.Move(LayoutUnit(),
                                                         -view->ScrollTop());
  for (int page = 1; page < page_count; page++) {
    context_.fragments[page] = context_.fragments[page - 1];
    context_.fragments[page].fixed_position.paint_offset.Move(LayoutUnit(),
                                                              page_height);
    context_.fragments[page].logical_top_in_flow_thread += page_height;
  }
}

void PaintArtifactCompositor::WillBeRemovedFromFrame() {
  RemoveChildLayers();
}

FrameFirstPaint PaintController::EndFrame(const void* frame) {
  FrameFirstPaint result = frame_first_paints_.back();
  DCHECK(result.frame == frame);
  frame_first_paints_.pop_back();
  return result;
}

void FragmentPaintPropertyTreeBuilder::UpdateTransformForNonRootSVG() {
DCHECK(properties_);
DCHECK(object_.IsSVGChild());
// SVG does not use paint offset internally, except for SVGForeignObject which
// has different SVG and HTML coordinate spaces.
DCHECK(object_.IsSVGForeignObject() ||
context_.current.paint_offset == LayoutPoint());

if (NeedsPaintPropertyUpdate()) {
AffineTransform transform = object_.LocalToSVGParentTransform();
if (NeedsTransformForNonRootSVG(object_)) {
// The origin is included in the local transform, so leave origin empty.
OnUpdate(properties_->UpdateTransform(
          context_.current.transform,
TransformPaintPropertyNode::State{transform}));
} else {
OnClear(properties_->ClearTransform());
}
}

if (properties_->Transform()) {
context_.current.transform = properties_->Transform();
context_.current.should_flatten_inherited_transform = false;
context_.current.rendering_context_id = 0;
}
}

static scoped_refptr<cc::Layer> ForeignLayerForPaintChunk(
    const PaintArtifact& paint_artifact,
    const PaintChunk& paint_chunk,
    gfx::Vector2dF& layer_offset) {
  if (paint_chunk.size() != 1)
    return nullptr;

  const auto& display_item =
      paint_artifact.GetDisplayItemList()[paint_chunk.begin_index];
  if (!display_item.IsForeignLayer())
    return nullptr;

  const auto& foreign_layer_display_item =
      static_cast<const ForeignLayerDisplayItem&>(display_item);
  layer_offset = gfx::Vector2dF(foreign_layer_display_item.Location().X(),
                                foreign_layer_display_item.Location().Y());
  scoped_refptr<cc::Layer> layer = foreign_layer_display_item.GetLayer();
  DCHECK(layer->bounds() ==
         static_cast<gfx::Size>(foreign_layer_display_item.Bounds()))
      << "\n  layer bounds: " << layer->bounds().ToString()
      << "\n  display item bounds: " << foreign_layer_display_item.Bounds();
  DCHECK(layer->DrawsContent());
  return layer;
}

static const FragmentData& FragmentAt(const LayoutObject* obj, unsigned count) {
  auto* fragment = &obj->FirstFragment();
  while (count > 0) {
    count--;
    fragment = fragment->NextFragment();
  }
  return *fragment;
}

void PropertyTreeManager::EmitClipMaskLayer() {
int clip_id = EnsureCompositorClipNode(current_clip_);
CompositorElementId mask_isolation_id, mask_effect_id;
cc::Layer* mask_layer = client_.CreateOrReuseSynthesizedClipLayer(
current_clip_, mask_isolation_id, mask_effect_id);

cc::EffectNode& mask_isolation = *GetEffectTree().Node(current_effect_id_);
// Assignment of mask_isolation.stable_id was delayed until now.
// See PropertyTreeManager::SynthesizeCcEffectsForClipsIfNeeded().
DCHECK_EQ(static_cast<uint64_t>(cc::EffectNode::INVALID_STABLE_ID),
mask_isolation.stable_id);
mask_isolation.stable_id = mask_isolation_id.ToInternalValue();

cc::EffectNode& mask_effect = *GetEffectTree().Node(
GetEffectTree().Insert(cc::EffectNode(), current_effect_id_));
mask_effect.stable_id = mask_effect_id.ToInternalValue();
mask_effect.clip_id = clip_id;
mask_effect.has_render_surface = true;
mask_effect.blend_mode = SkBlendMode::kDstIn;

  const TransformPaintPropertyNode* clip_space =
      current_clip_->LocalTransformSpace();
root_layer_->AddChild(mask_layer);
mask_layer->set_property_tree_sequence_number(sequence_number_);
mask_layer->SetTransformTreeIndex(EnsureCompositorTransformNode(clip_space));
// TODO(pdr): This could be a performance issue because it crawls up the
// transform tree for each pending layer. If this is on profiles, we should
// cache a lookup of transform node to scroll translation transform node.
int scroll_id =
EnsureCompositorScrollNode(&clip_space->NearestScrollTranslationNode());
mask_layer->SetScrollTreeIndex(scroll_id);
mask_layer->SetClipTreeIndex(clip_id);
mask_layer->SetEffectTreeIndex(mask_effect.id);
}

int PropertyTreeManager::EnsureCompositorTransformNode(
    const TransformPaintPropertyNode* transform_node) {
  DCHECK(transform_node);
  if (!transform_node)
    return kSecondaryRootNodeId;

  auto it = transform_node_map_.find(transform_node);
  if (it != transform_node_map_.end())
    return it->value;

  int parent_id = EnsureCompositorTransformNode(transform_node->Parent());
  int id = GetTransformTree().Insert(cc::TransformNode(), parent_id);

  cc::TransformNode& compositor_node = *GetTransformTree().Node(id);
  compositor_node.source_node_id = parent_id;

  FloatPoint3D origin = transform_node->Origin();
  compositor_node.pre_local.matrix().setTranslate(-origin.X(), -origin.Y(),
                                                  -origin.Z());
  compositor_node.local.matrix() =
      TransformationMatrix::ToSkMatrix44(transform_node->Matrix());
  compositor_node.post_local.matrix().setTranslate(origin.X(), origin.Y(),
                                                   origin.Z());
  compositor_node.needs_local_transform_update = true;
  compositor_node.flattens_inherited_transform =
      transform_node->FlattensInheritedTransform();
  compositor_node.sorting_context_id = transform_node->RenderingContextId();

  CompositorElementId compositor_element_id =
      transform_node->GetCompositorElementId();
  if (compositor_element_id) {
    property_trees_.element_id_to_transform_node_index[compositor_element_id] =
        id;
  }

  if (auto* scroll_node = transform_node->ScrollNode()) {
    auto scroll_offset_size = transform_node->Matrix().To2DTranslation();
    auto scroll_offset = gfx::ScrollOffset(-scroll_offset_size.Width(),
                                           -scroll_offset_size.Height());
    DCHECK(compositor_node.local.IsIdentityOr2DTranslation());
    compositor_node.scroll_offset = scroll_offset;
    compositor_node.local.MakeIdentity();
    compositor_node.scrolls = true;

    CreateCompositorScrollNode(scroll_node, compositor_node);
  }

  auto result = transform_node_map_.Set(transform_node, id);
  DCHECK(result.is_new_entry);
  GetTransformTree().set_needs_update(true);

  return id;
}

  const cc::PropertyTrees& GetPropertyTrees() {
    return *web_layer_tree_view_->GetLayerTreeHost()->property_trees();
  }

void BlockPainter::PaintChild(const LayoutBox& child,
                              const PaintInfo& paint_info,
                              const LayoutPoint& paint_offset) {
  LayoutPoint child_point =
      layout_block_.FlipForWritingModeForChildForPaint(&child, paint_offset);
  if (!child.HasSelfPaintingLayer() && !child.IsFloating() &&
      !child.IsColumnSpanAll())
    child.Paint(paint_info, child_point);
}

PaintArtifactCompositor::CompositedLayerForPendingLayer(
    const PaintArtifact& paint_artifact,
    const PendingLayer& pending_layer,
    gfx::Vector2dF& layer_offset,
    Vector<std::unique_ptr<ContentLayerClientImpl>>& new_content_layer_clients,
    Vector<scoped_refptr<cc::Layer>>& new_scroll_hit_test_layers) {
  auto paint_chunks =
      paint_artifact.GetPaintChunkSubset(pending_layer.paint_chunk_indices);
  DCHECK(paint_chunks.size());
  const PaintChunk& first_paint_chunk = paint_chunks[0];
  DCHECK(first_paint_chunk.size());

  if (scoped_refptr<cc::Layer> foreign_layer = ForeignLayerForPaintChunk(
          paint_artifact, first_paint_chunk, layer_offset)) {
    DCHECK_EQ(paint_chunks.size(), 1u);
    if (extra_data_for_testing_enabled_)
      extra_data_for_testing_->content_layers.push_back(foreign_layer);
    return foreign_layer;
  }

  if (scoped_refptr<cc::Layer> scroll_layer = ScrollHitTestLayerForPendingLayer(
          paint_artifact, pending_layer, layer_offset)) {
    new_scroll_hit_test_layers.push_back(scroll_layer);
    if (extra_data_for_testing_enabled_)
      extra_data_for_testing_->scroll_hit_test_layers.push_back(scroll_layer);
    return scroll_layer;
  }

  std::unique_ptr<ContentLayerClientImpl> content_layer_client =
      ClientForPaintChunk(first_paint_chunk);

  gfx::Rect cc_combined_bounds(EnclosingIntRect(pending_layer.bounds));
  layer_offset = cc_combined_bounds.OffsetFromOrigin();

  auto cc_layer = content_layer_client->UpdateCcPictureLayer(
      paint_artifact, paint_chunks, cc_combined_bounds,
      pending_layer.property_tree_state);
  new_content_layer_clients.push_back(std::move(content_layer_client));
  if (extra_data_for_testing_enabled_)
    extra_data_for_testing_->content_layers.push_back(cc_layer);

  cc_layer->SetContentsOpaque(pending_layer.rect_known_to_be_opaque.Contains(
      FloatRect(EnclosingIntRect(pending_layer.bounds))));

  return cc_layer;
}

size_t PaintController::FindMatchingItemFromIndex(
    const DisplayItem::Id& id,
    const IndicesByClientMap& display_item_indices_by_client,
    const DisplayItemList& list) {
  IndicesByClientMap::const_iterator it =
      display_item_indices_by_client.find(&id.client);
  if (it == display_item_indices_by_client.end())
    return kNotFound;

  const Vector<size_t>& indices = it->value;
  for (size_t index : indices) {
    const DisplayItem& existing_item = list[index];
    if (existing_item.IsTombstone())
      continue;
    DCHECK(existing_item.Client() == id.client);
    if (id == existing_item.GetId())
      return index;
  }

  return kNotFound;
}

static bool SkipGroupIfEffectivelyInvisible(
    const PaintArtifact& paint_artifact,
    const EffectPaintPropertyNode& current_group,
    Vector<PaintChunk>::const_iterator& chunk_it) {
  static const float kMinimumVisibleOpacity = 0.0004f;
  if (current_group.Opacity() >= kMinimumVisibleOpacity ||
      current_group.HasDirectCompositingReasons()) {
    return false;
  }

  DCHECK(EffectGroupContainsChunk(current_group, *chunk_it));
  while (++chunk_it != paint_artifact.PaintChunks().end()) {
    if (!EffectGroupContainsChunk(current_group, *chunk_it))
      break;
  }
  return true;
}

static LayoutRect BoundingBoxInPaginationContainer(
    const LayoutObject& object,
    const PaintLayer& enclosing_pagination_layer) {
  if (!object.IsBox() && !object.HasLayer()) {
    const LayoutBox& containining_block = *object.ContainingBlock();
    LayoutRect bounds_rect;
    if (!object.IsSVG()) {
      bounds_rect = object.LocalVisualRect();
      containining_block.FlipForWritingMode(bounds_rect);
    } else {
      bounds_rect = LayoutRect(SVGLayoutSupport::LocalVisualRect(object));
    }

    return MapLocalRectToAncestorLayer(containining_block, bounds_rect,
                                       enclosing_pagination_layer);
  }

  if (object.HasLayer() && !object.IsTableSection()) {
    return ToLayoutBoxModelObject(object).Layer()->PhysicalBoundingBox(
        &enclosing_pagination_layer);
  }

  const LayoutBox& box = ToLayoutBox(object);
  auto bounding_box = MapLocalRectToAncestorLayer(box, box.BorderBoxRect(),
                                                  enclosing_pagination_layer);

  if (!IsRepeatingTableSection(object))
    return bounding_box;

  const auto& section = ToLayoutTableSection(object);
  const auto& table = *section.Table();

  if (section.IsRepeatingHeaderGroup()) {
    if (const auto* bottom_section = table.BottomNonEmptySection()) {
      bounding_box.Unite(MapLocalRectToAncestorLayer(
          *bottom_section, bottom_section->BorderBoxRect(),
          enclosing_pagination_layer));
    }
    return bounding_box;
  }

  DCHECK(section.IsRepeatingFooterGroup());
  const auto* top_section = table.TopNonEmptySection();
  if (top_section) {
    bounding_box.Unite(MapLocalRectToAncestorLayer(*top_section,
                                                   top_section->BorderBoxRect(),
                                                   enclosing_pagination_layer));
    auto top_exclusion = table.RowOffsetFromRepeatingFooter();
    if (const auto* top_section = table.TopNonEmptySection()) {
      DCHECK(top_section != section);
      top_exclusion +=
          top_section->FirstRow()->LogicalHeight() + table.VBorderSpacing();
    }
    if (top_exclusion)
      top_exclusion -= 1;
    bounding_box.ShiftYEdgeTo(bounding_box.Y() + top_exclusion);
  }
  return bounding_box;
}

CreateSampleTransformNodeWithElementId() {
TransformPaintPropertyNode::State state;
state.matrix.Rotate(90);
state.origin = FloatPoint3D(100, 100, 0);
state.direct_compositing_reasons = CompositingReason::k3DTransform;
state.compositor_element_id = CompositorElementId(3);
  return TransformPaintPropertyNode::Create(TransformPaintPropertyNode::Root(),
                                            std::move(state));
}

   bool HasFilterThatMovesPixels(const ChunkToLayerMapper& mapper) {
     return mapper.has_filter_that_moves_pixels_;
   }

TestPaintArtifact& TestPaintArtifact::KnownToBeOpaque() {
  paint_chunks_data_.chunks.back().known_to_be_opaque = true;
  return *this;
}

  SkMatrix GetSkMatrix(
      const TransformPaintPropertyNode* target_transform) const {
    return SkMatrix(TransformationMatrix::ToSkMatrix44(
        GeometryMapper::SourceToDestinationProjection(target_transform,
                                                      current_transform_)));
  }

void FragmentPaintPropertyTreeBuilder::UpdateInnerBorderRadiusClip() {
DCHECK(properties_);

if (NeedsPaintPropertyUpdate()) {
if (NeedsInnerBorderRadiusClip(object_)) {
const LayoutBox& box = ToLayoutBox(object_);
ClipPaintPropertyNode::State state;
state.local_transform_space = context_.current.transform;
if (box.IsLayoutReplaced()) {
// LayoutReplaced clips the foreground by rounded inner content box.
state.clip_rect = box.StyleRef().GetRoundedInnerBorderFor(
LayoutRect(context_.current.paint_offset, box.Size()),
LayoutRectOutsets(-(box.PaddingTop() + box.BorderTop()),
-(box.PaddingRight() + box.BorderRight()),
-(box.PaddingBottom() + box.BorderBottom()),
-(box.PaddingLeft() + box.BorderLeft())));
} else {
state.clip_rect = box.StyleRef().GetRoundedInnerBorderFor(
LayoutRect(context_.current.paint_offset, box.Size()));
}
OnUpdateClip(properties_->UpdateInnerBorderRadiusClip(
          context_.current.clip, std::move(state)));
} else {
OnClearClip(properties_->ClearInnerBorderRadiusClip());
}
}

if (auto* border_radius_clip = properties_->InnerBorderRadiusClip())
context_.current.clip = border_radius_clip;
}

std::unique_ptr<JSONObject> PaintArtifactCompositor::LayersAsJSON(
    LayerTreeFlags flags) const {
  ContentLayerClientImpl::LayerAsJSONContext context(flags);
  std::unique_ptr<JSONArray> layers_json = JSONArray::Create();
  for (const auto& client : content_layer_clients_) {
    layers_json->PushObject(client->LayerAsJSON(context));
  }
  std::unique_ptr<JSONObject> json = JSONObject::Create();
  json->SetArray("layers", std::move(layers_json));
  if (context.transforms_json)
    json->SetArray("transforms", std::move(context.transforms_json));
  return json;
}

void ScrollHitTestDisplayItem::Record(
GraphicsContext& context,
const DisplayItemClient& client,
DisplayItem::Type type,
    scoped_refptr<const TransformPaintPropertyNode> scroll_offset_node) {
PaintController& paint_controller = context.GetPaintController();

// The scroll hit test should be in the non-scrolled transform space and
// therefore should not be scrolled by the associated scroll offset.
DCHECK_NE(paint_controller.CurrentPaintChunkProperties().Transform(),
            scroll_offset_node.get());

if (paint_controller.DisplayItemConstructionIsDisabled())
return;

paint_controller.CreateAndAppend<ScrollHitTestDisplayItem>(
      client, type, std::move(scroll_offset_node));
}

  sk_sp<PaintRecord> MakeRecord(const FloatRect& rect, Color color) {
    rect_ = rect;
    PaintRecorder recorder;
    PaintCanvas* canvas = recorder.beginRecording(rect);
    PaintFlags flags;
    flags.setColor(color.Rgb());
    canvas->drawRect(rect, flags);
    return recorder.finishRecordingAsPicture();
  }

  const CompositedLayerRasterInvalidator* GetInternalRasterInvalidator(
      const GraphicsLayer& layer) {
    return layer.raster_invalidator_.get();
  }

bool PaintArtifactCompositor::CanDecompositeEffect(
    const EffectPaintPropertyNode* effect,
    const PendingLayer& layer) {
  if (layer.property_tree_state.Effect() != effect)
    return false;
  if (layer.requires_own_layer)
    return false;
  if (effect->BlendMode() != SkBlendMode::kSrcOver)
    return false;
  if (effect->HasDirectCompositingReasons())
    return false;
  if (!CanUpcastTo(layer.property_tree_state,
                   PropertyTreeState(effect->LocalTransformSpace(),
                                     effect->OutputClip()
                                         ? effect->OutputClip()
                                         : layer.property_tree_state.Clip(),
                                     effect)))
    return false;
  return true;
}

  WebLayerTreeViewWithLayerTreeFrameSink(const cc::LayerTreeSettings& settings)
      : WebLayerTreeViewImplForTesting(settings) {}

void PaintController::ProcessNewItem(DisplayItem& display_item) {
  DCHECK(!construction_disabled_);

  if (IsSkippingCache())
    display_item.SetSkippedCache();

  if (raster_invalidation_tracking_info_) {
    raster_invalidation_tracking_info_->new_client_debug_names.insert(
        &display_item.Client(), display_item.Client().DebugName());
  }

  if (RuntimeEnabledFeatures::SlimmingPaintV175Enabled()) {
    size_t last_chunk_index = new_paint_chunks_.LastChunkIndex();
    bool chunk_added =
        new_paint_chunks_.IncrementDisplayItemIndex(display_item);
    auto& last_chunk = new_paint_chunks_.LastChunk();

#if DCHECK_IS_ON()
    if (chunk_added && last_chunk.is_cacheable) {
      AddToIndicesByClientMap(last_chunk.id.client,
                              new_paint_chunks_.LastChunkIndex(),
                              new_paint_chunk_indices_by_client_);
    }
#endif

    if (chunk_added && last_chunk_index != kNotFound) {
      DCHECK(last_chunk_index != new_paint_chunks_.LastChunkIndex());
      GenerateRasterInvalidations(
          new_paint_chunks_.PaintChunkAt(last_chunk_index));
    }

    last_chunk.outset_for_raster_effects =
        std::max(last_chunk.outset_for_raster_effects,
                 display_item.OutsetForRasterEffects());
  }

#if DCHECK_IS_ON()
  if (new_display_item_list_.size() >= 2 && display_item.IsEnd()) {
    const auto& begin_display_item =
        new_display_item_list_[new_display_item_list_.size() - 2];
    if (begin_display_item.IsBegin() && !begin_display_item.DrawsContent())
      DCHECK(!display_item.IsEndAndPairedWith(begin_display_item.GetType()));
  }

  if (display_item.IsCacheable()) {
    size_t index = FindMatchingItemFromIndex(
        display_item.GetId(), new_display_item_indices_by_client_,
        new_display_item_list_);
    if (index != kNotFound) {
      ShowDebugData();
      NOTREACHED()
          << "DisplayItem " << display_item.AsDebugString().Utf8().data()
          << " has duplicated id with previous "
          << new_display_item_list_[index].AsDebugString().Utf8().data()
          << " (index=" << index << ")";
    }
    AddToIndicesByClientMap(display_item.Client(),
                            new_display_item_list_.size() - 1,
                            new_display_item_indices_by_client_);
  }
#endif  // DCHECK_IS_ON()

  if (RuntimeEnabledFeatures::PaintUnderInvalidationCheckingEnabled())
    CheckUnderInvalidation();

  if (!frame_first_paints_.back().first_painted && display_item.IsDrawing() &&
      display_item.GetType() != DisplayItem::kDocumentBackground &&
      display_item.DrawsContent()) {
    SetFirstPainted();
  }
}

  FragmentPaintPropertyTreeBuilder(
      const LayoutObject& object,
      PaintPropertyTreeBuilderContext& full_context,
      PaintPropertyTreeBuilderFragmentContext& context,
      FragmentData& fragment_data)
      : object_(object),
        full_context_(full_context),
        context_(context),
        fragment_data_(fragment_data),
        properties_(fragment_data.PaintProperties()) {}

void PaintController::SetTextPainted() {
  frame_first_paints_.back().text_painted = true;
}

void PaintController::GenerateFullRasterInvalidation(
    PaintChunk& chunk,
    const DisplayItem& old_item,
    const DisplayItem& new_item) {
  DCHECK(&old_item.Client() == &new_item.Client());
  FloatRect old_visual_rect(old_item.VisualRect());
  FloatRect new_visual_rect(new_item.VisualRect());

  if (!new_visual_rect.Contains(old_visual_rect)) {
    AddRasterInvalidation(new_item.Client(), chunk, old_visual_rect,
                          new_item.Client().GetPaintInvalidationReason());
    if (old_visual_rect.Contains(new_visual_rect))
      return;
  }

  AddRasterInvalidation(new_item.Client(), chunk, new_visual_rect,
                        new_item.Client().GetPaintInvalidationReason());
}

void ScrollHitTestDisplayItem::AppendToDisplayItemList(
    const FloatSize&,
    cc::DisplayItemList&) const {
  NOTREACHED();
}

TestPaintArtifact& TestPaintArtifact::ScrollHitTest(
    scoped_refptr<const TransformPaintPropertyNode> scroll_offset) {
return ScrollHitTest(NewClient(), scroll_offset);
}

String PropertyTreeState::ToString() const {
  return String::Format("t:%p c:%p e:%p", Transform(), Clip(), Effect());
}

void FragmentPaintPropertyTreeBuilder::UpdateClipPathCache() {
  if (fragment_data_.IsClipPathCacheValid())
    return;

  if (!object_.StyleRef().ClipPath())
    return;

  base::Optional<FloatRect> bounding_box =
      ClipPathClipper::LocalClipPathBoundingBox(object_);
  if (!bounding_box) {
    fragment_data_.SetClipPathCache(base::nullopt, nullptr);
    return;
  }
  bounding_box->MoveBy(FloatPoint(fragment_data_.PaintOffset()));

  bool is_valid = false;
  base::Optional<Path> path = ClipPathClipper::PathBasedClip(
      object_, object_.IsSVGChild(),
      ClipPathClipper::LocalReferenceBox(object_), is_valid);
  DCHECK(is_valid);
  if (path)
    path->Translate(ToFloatSize(FloatPoint(fragment_data_.PaintOffset())));
  fragment_data_.SetClipPathCache(
      EnclosingIntRect(*bounding_box),
      path ? AdoptRef(new RefCountedPath(std::move(*path))) : nullptr);
}

TestPaintArtifact& TestPaintArtifact::ScrollHitTest(
DisplayItemClient& client,
    scoped_refptr<const TransformPaintPropertyNode> scroll_offset) {
display_item_list_.AllocateAndConstruct<ScrollHitTestDisplayItem>(
      client, DisplayItem::kScrollHitTest, std::move(scroll_offset));
return *this;
}

  void Update(const FloatRoundedRect& rrect,
              scoped_refptr<const RefCountedPath> path) {
    IntRect layer_bounds = EnclosingIntRect(rrect.Rect());
    gfx::Vector2dF new_layer_origin(layer_bounds.X(), layer_bounds.Y());

    SkRRect new_local_rrect = rrect;
    new_local_rrect.offset(-new_layer_origin.x(), -new_layer_origin.y());

    bool path_in_layer_changed = false;
    if (path_ == path) {
      path_in_layer_changed = path && layer_origin_ != new_layer_origin;
    } else if (!path_ || !path) {
      path_in_layer_changed = true;
    } else {
      SkPath new_path = path->GetSkPath();
      new_path.offset(layer_origin_.x() - new_layer_origin.x(),
                      layer_origin_.y() - new_layer_origin.y());
      path_in_layer_changed = path_->GetSkPath() != new_path;
    }

    if (local_rrect_ != new_local_rrect || path_in_layer_changed) {
      layer_->SetNeedsDisplay();
    }
    layer_->set_offset_to_transform_parent(new_layer_origin);
    layer_->SetBounds(gfx::Size(layer_bounds.Width(), layer_bounds.Height()));

    layer_origin_ = new_layer_origin;
    local_rrect_ = new_local_rrect;
    path_ = std::move(path);
  }

static MainThreadScrollingReasons GetMainThreadScrollingReasons(
    const LayoutObject& object,
    MainThreadScrollingReasons ancestor_reasons) {
  if (!object.IsLayoutView())
    return ancestor_reasons;

  auto reasons = ancestor_reasons;
  if (!object.GetFrame()->GetSettings()->GetThreadedScrollingEnabled())
    reasons |= MainThreadScrollingReason::kThreadedScrollingDisabled;
  if (object.GetFrameView()->HasBackgroundAttachmentFixedObjects())
    reasons |= MainThreadScrollingReason::kHasBackgroundAttachmentFixedObjects;
  return reasons;
}

  bool NeedsPaintPropertyUpdate() const {
    return object_.NeedsPaintPropertyUpdate() ||
           full_context_.force_subtree_update;
  }

void GeometryMapper::SourceToDestinationRect(
    const TransformPaintPropertyNode* source_transform_node,
    const TransformPaintPropertyNode* destination_transform_node,
    FloatRect& mapping_rect) {
  bool success = false;
  const TransformationMatrix& source_to_destination =
      SourceToDestinationProjectionInternal(
          source_transform_node, destination_transform_node, success);
  mapping_rect =
      success ? source_to_destination.MapRect(mapping_rect) : FloatRect();
}

void PropertyTreeManager::CloseCcEffect() {
  DCHECK(effect_stack_.size());
  const EffectStackEntry& previous_state = effect_stack_.back();

  bool clear_synthetic_effects =
      !IsCurrentCcEffectSynthetic() &&
      current_effect_->BlendMode() != SkBlendMode::kSrcOver;

  if (IsCurrentCcEffectSynthetic())
    EmitClipMaskLayer();

  current_effect_id_ = previous_state.effect_id;
  current_effect_type_ = previous_state.effect_type;
  current_effect_ = previous_state.effect;
  current_clip_ = previous_state.clip;
  effect_stack_.pop_back();

  if (clear_synthetic_effects) {
    while (IsCurrentCcEffectSynthetic())
      CloseCcEffect();
  }
}

static bool NeedsTransformForNonRootSVG(const LayoutObject& object) {
  return object.IsSVGChild() &&
         !object.LocalToSVGParentTransform().IsIdentity();
}

PaintArtifactCompositor::ScrollTranslationForScrollHitTestLayer(
    const PaintArtifact& paint_artifact,
    const PendingLayer& pending_layer) {
  auto paint_chunks =
      paint_artifact.GetPaintChunkSubset(pending_layer.paint_chunk_indices);
  DCHECK(paint_chunks.size());
  const auto& first_paint_chunk = paint_chunks[0];
  if (first_paint_chunk.size() != 1)
    return nullptr;

  const auto& display_item =
      paint_artifact.GetDisplayItemList()[first_paint_chunk.begin_index];
  if (!display_item.IsScrollHitTest())
    return nullptr;

  const auto& scroll_hit_test_display_item =
      static_cast<const ScrollHitTestDisplayItem&>(display_item);
  return &scroll_hit_test_display_item.scroll_offset_node();
}

void PaintChunksToCcLayer::ConvertInto(
    const PaintChunkSubset& paint_chunks,
    const PropertyTreeState& layer_state,
    const gfx::Vector2dF& layer_offset,
    const FloatSize& visual_rect_subpixel_offset,
    const DisplayItemList& display_items,
    cc::DisplayItemList& cc_list) {
  if (RuntimeEnabledFeatures::DisablePaintChunksToCcLayerEnabled())
    return;
  ConversionContext(layer_state, layer_offset, visual_rect_subpixel_offset,
                    cc_list)
      .Convert(paint_chunks, display_items);
}

  ~FragmentPaintPropertyTreeBuilder() {
    full_context_.force_subtree_update |= property_added_or_removed_;
#if DCHECK_IS_ON()
    if (properties_)
      PaintPropertyTreePrinter::UpdateDebugNames(object_, *properties_);
#endif
  }

void PropertyTreeManager::SetupRootEffectNode() {
// cc is hardcoded to use effect node index 1 for root render surface.
cc::EffectTree& effect_tree = property_trees_.effect_tree;
effect_tree.clear();
property_trees_.element_id_to_effect_node_index.clear();
cc::EffectNode& effect_node =
*effect_tree.Node(effect_tree.Insert(cc::EffectNode(), kInvalidNodeId));
DCHECK_EQ(effect_node.id, kSecondaryRootNodeId);

static UniqueObjectId unique_id = NewUniqueObjectId();

effect_node.stable_id =
CompositorElementIdFromUniqueObjectId(unique_id).ToInternalValue();
effect_node.transform_id = kRealRootNodeId;
effect_node.clip_id = kSecondaryRootNodeId;
effect_node.has_render_surface = true;
root_layer_->SetEffectTreeIndex(effect_node.id);

current_effect_id_ = effect_node.id;
current_effect_type_ = CcEffectType::kEffect;
  current_effect_ = EffectPaintPropertyNode::Root();
current_clip_ = current_effect_->OutputClip();
}

const RefCountedPropertyTreeState& RefCountedPropertyTreeState::Root() {
  DEFINE_STATIC_LOCAL(
      std::unique_ptr<RefCountedPropertyTreeState>, root,
      (std::make_unique<RefCountedPropertyTreeState>(
          TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),
          EffectPaintPropertyNode::Root())));
  return *root;
}

void FragmentPaintPropertyTreeBuilder::UpdateLocalBorderBoxContext() {
  if (!NeedsPaintPropertyUpdate())
    return;

  if (!object_.HasLayer() && !NeedsPaintOffsetTranslation(object_) &&
      !NeedsFilter(object_)) {
    fragment_data_.ClearLocalBorderBoxProperties();
  } else {
    PropertyTreeState local_border_box =
        PropertyTreeState(context_.current.transform, context_.current.clip,
                          context_.current_effect);

    if (RuntimeEnabledFeatures::SlimmingPaintV175Enabled() &&
        (!fragment_data_.HasLocalBorderBoxProperties() ||
         local_border_box != fragment_data_.LocalBorderBoxProperties()))
      property_added_or_removed_ = true;

    fragment_data_.SetLocalBorderBoxProperties(std::move(local_border_box));
  }
}

  CompositedLayerRasterInvalidatorTest() : ScopedSlimmingPaintV2ForTest(true) {}

bool FragmentPaintPropertyTreeBuilder::NeedsOverflowControlsClip() const {
  if (!object_.HasOverflowClip())
    return false;

  const auto& box = ToLayoutBox(object_);
  const auto* scrollable_area = box.GetScrollableArea();
  IntRect scroll_controls_bounds =
      scrollable_area->ScrollCornerAndResizerRect();
  if (const auto* scrollbar = scrollable_area->HorizontalScrollbar())
    scroll_controls_bounds.Unite(scrollbar->FrameRect());
  if (const auto* scrollbar = scrollable_area->VerticalScrollbar())
    scroll_controls_bounds.Unite(scrollbar->FrameRect());
  auto pixel_snapped_border_box_rect = box.PixelSnappedBorderBoxRect(
      ToLayoutSize(context_.current.paint_offset));
  pixel_snapped_border_box_rect.SetLocation(IntPoint());
  return !pixel_snapped_border_box_rect.Contains(scroll_controls_bounds);
}

  void OnUpdate(const ObjectPaintProperties::UpdateResult& result) {
    property_added_or_removed_ |= result.NewNodeCreated();
    property_changed_ |= !result.Unchanged();
  }

  CompositedLayerRasterInvalidatorTest& Chunk(int type) {
    DEFINE_STATIC_LOCAL(FakeDisplayItemClient, fake_client, ());
    fake_client.ClearIsJustCreated();
    PaintChunk::Id id(fake_client, static_cast<DisplayItem::Type>(
                                       DisplayItem::kDrawingFirst + type));
    data_.chunks.emplace_back(0, 0, id, DefaultPropertyTreeState());
    data_.chunks.back().bounds =
        FloatRect(type * 110, type * 220, type * 220 + 200, type * 110 + 200);
    return *this;
   }

  const PaintController* GetInternalPaintController(
      const GraphicsLayer& layer) {
    return layer.paint_controller_.get();
  }

void PaintController::GenerateIncrementalRasterInvalidation(
    PaintChunk& chunk,
    const DisplayItem& old_item,
    const DisplayItem& new_item) {
  DCHECK(&old_item.Client() == &new_item.Client());
  FloatRect old_visual_rect(old_item.VisualRect());
  FloatRect new_visual_rect(new_item.VisualRect());
  DCHECK(old_visual_rect.Location() == new_visual_rect.Location());

  FloatRect right_delta =
      ComputeRightDelta(new_visual_rect.Location(), old_visual_rect.Size(),
                        new_visual_rect.Size());
  if (!right_delta.IsEmpty()) {
    AddRasterInvalidation(new_item.Client(), chunk, right_delta,
                          PaintInvalidationReason::kIncremental);
  }

  FloatRect bottom_delta =
      ComputeBottomDelta(new_visual_rect.Location(), old_visual_rect.Size(),
                         new_visual_rect.Size());
  if (!bottom_delta.IsEmpty()) {
    AddRasterInvalidation(new_item.Client(), chunk, bottom_delta,
                          PaintInvalidationReason::kIncremental);
  }
}

PaintPropertyTreeBuilderTest::DocScrollTranslation(const Document* document) {
  if (!document)
    document = &GetDocument();
  return document->GetLayoutView()
      ->FirstFragment()
      .PaintProperties()
      ->ScrollTranslation();
}

void CompositedLayerRasterInvalidator::Generate(
    const PaintArtifact& paint_artifact,
    const PaintChunkSubset& paint_chunks,
    const gfx::Rect& layer_bounds,
    const PropertyTreeState& layer_state,
    const FloatSize& visual_rect_subpixel_offset) {
  if (RuntimeEnabledFeatures::DisableRasterInvalidationEnabled())
    return;

  if (RasterInvalidationTracking::ShouldAlwaysTrack())
    EnsureTracking();

  if (tracking_info_) {
    for (const auto& chunk : paint_chunks) {
      tracking_info_->new_client_debug_names.insert(
          &chunk.id.client, chunk.id.client.DebugName());
    }
  }

  bool layer_bounds_was_empty = layer_bounds_.IsEmpty();
  layer_bounds_ = layer_bounds;

  Vector<PaintChunkInfo> new_chunks_info;
  new_chunks_info.ReserveCapacity(paint_chunks.size());

  if (layer_bounds_was_empty || layer_bounds_.IsEmpty()) {
    ChunkToLayerMapper mapper(layer_state, layer_bounds.OffsetFromOrigin(),
                              visual_rect_subpixel_offset);
    for (const auto& chunk : paint_chunks) {
      mapper.SwitchToChunk(chunk);
      new_chunks_info.emplace_back(*this, mapper, chunk);
    }
  } else {
    GenerateRasterInvalidations(paint_artifact, paint_chunks, layer_state,
                                visual_rect_subpixel_offset, new_chunks_info);
  }

  paint_chunks_info_ = std::move(new_chunks_info);

  if (tracking_info_) {
    tracking_info_->old_client_debug_names =
        std::move(tracking_info_->new_client_debug_names);
  }
}

void GeometryMapper::ClearCache() {
  GeometryMapperTransformCache::ClearCache();
  GeometryMapperClipCache::ClearCache();
}

  PaintRecordMatcher(std::initializer_list<cc::PaintOpType> args)
      : expected_ops_(args) {}

CompositedLayerRasterInvalidatorTest& Properties(
      const RefCountedPropertyTreeState& state) {
    data_.chunks.back().properties = state;
return *this;
}

TransformPaintPropertyNode::NearestScrollTranslationNode() const {
  const auto* transform = this;
  while (!transform->ScrollNode()) {
    transform = transform->Parent();
    DCHECK(transform);
  }
  return *transform;
}

void PaintController::ShowUnderInvalidationError(
    const char* reason,
    const DisplayItem& new_item,
    const DisplayItem* old_item) const {
  LOG(ERROR) << under_invalidation_message_prefix_ << " " << reason;
#if DCHECK_IS_ON()
  LOG(ERROR) << "New display item: " << new_item.AsDebugString();
  LOG(ERROR) << "Old display item: "
             << (old_item ? old_item->AsDebugString() : "None");
  LOG(ERROR) << "See http://crbug.com/619103.";

  const PaintRecord* new_record = nullptr;
  if (new_item.IsDrawing()) {
    new_record =
        static_cast<const DrawingDisplayItem&>(new_item).GetPaintRecord().get();
  }
  const PaintRecord* old_record = nullptr;
  if (old_item->IsDrawing()) {
    old_record = static_cast<const DrawingDisplayItem*>(old_item)
                     ->GetPaintRecord()
                     .get();
  }
  LOG(INFO) << "new record:\n"
            << (new_record ? RecordAsDebugString(*new_record).Utf8().data()
                           : "None");
  LOG(INFO) << "old record:\n"
            << (old_record ? RecordAsDebugString(*old_record).Utf8().data()
                           : "None");

  ShowDebugData();
#else
  LOG(ERROR) << "Run a build with DCHECK on to get more details.";
  LOG(ERROR) << "See http://crbug.com/619103.";
#endif
}

size_t CompositedLayerRasterInvalidator::ApproximateUnsharedMemoryUsage()
    const {
  return sizeof(*this) + paint_chunks_info_.capacity() * sizeof(PaintChunkInfo);
}

static LayoutPoint PaintOffsetInPaginationContainer(
    const LayoutObject& object,
    const PaintLayer& enclosing_pagination_layer) {
  if (!object.IsBox() && !object.HasLayer()) {
    return PaintOffsetInPaginationContainer(*object.ContainingBlock(),
                                            enclosing_pagination_layer);
  }

  TransformState transform_state(TransformState::kApplyTransformDirection,
                                 FloatPoint());
  object.MapLocalToAncestor(&enclosing_pagination_layer.GetLayoutObject(),
                            transform_state, kApplyContainerFlip);
  transform_state.Flatten();
  return LayoutPoint(transform_state.LastPlanarPoint());
}

static LayoutRect MapLocalRectToAncestorLayer(
    const LayoutBox& box,
    const LayoutRect& local_rect,
    const PaintLayer& ancestor_layer) {
  TransformState transform_state(TransformState::kApplyTransformDirection,
                                 FloatPoint(local_rect.Location()));
  box.MapLocalToAncestor(&ancestor_layer.GetLayoutObject(), transform_state,
                         kApplyContainerFlip);
  transform_state.Flatten();
  return LayoutRect(LayoutPoint(transform_state.LastPlanarPoint()),
                    local_rect.Size());
}

bool PaintController::UseCachedSubsequenceIfPossible(
    const DisplayItemClient& client) {
  if (DisplayItemConstructionIsDisabled() || SubsequenceCachingIsDisabled())
    return false;

  if (!ClientCacheIsValid(client))
    return false;

  if (RuntimeEnabledFeatures::PaintUnderInvalidationCheckingEnabled() &&
      IsCheckingUnderInvalidation()) {
    return false;
  }

  SubsequenceMarkers* markers = GetSubsequenceMarkers(client);
  if (!markers) {
    return false;
  }

  if (current_paint_artifact_.GetDisplayItemList()[markers->start]
          .IsTombstone()) {
    NOTREACHED();
    return false;
  }

  EnsureNewDisplayItemListInitialCapacity();

  if (next_item_to_match_ == markers->start) {
    next_item_to_match_ = markers->end;
    if (next_item_to_match_ > next_item_to_index_)
      next_item_to_index_ = next_item_to_match_;
  }

  num_cached_new_items_ += markers->end - markers->start;

  if (RuntimeEnabledFeatures::PaintUnderInvalidationCheckingEnabled()) {
    DCHECK(!IsCheckingUnderInvalidation());
    under_invalidation_checking_begin_ = markers->start;
    under_invalidation_checking_end_ = markers->end;
    under_invalidation_message_prefix_ =
        "(In cached subsequence for " + client.DebugName() + ")";
    return false;
  }

  size_t start = BeginSubsequence();
  CopyCachedSubsequence(markers->start, markers->end);
  EndSubsequence(client, start);
  return true;
}

size_t PaintController::BeginSubsequence() {
  new_paint_chunks_.ForceNewChunk();
  return new_display_item_list_.size();
}

DisplayItemClient& TestPaintArtifact::NewClient() {
  dummy_clients_.push_back(std::make_unique<DummyRectClient>());
  return *dummy_clients_.back();
}

void PaintController::EndSubsequence(const DisplayItemClient& client,
                                     size_t start) {
  size_t end = new_display_item_list_.size();

  if (RuntimeEnabledFeatures::PaintUnderInvalidationCheckingEnabled() &&
      IsCheckingUnderInvalidation()) {
    SubsequenceMarkers* markers = GetSubsequenceMarkers(client);
    if (!markers && start != end) {
      ShowSequenceUnderInvalidationError(
          "under-invalidation : unexpected subsequence", client, start, end);
      CHECK(false);
    }
    if (markers && markers->end - markers->start != end - start) {
      ShowSequenceUnderInvalidationError(
          "under-invalidation: new subsequence wrong length", client, start,
          end);
      CHECK(false);
    }
  }

  if (start == end) {
    return;
  }

  new_paint_chunks_.ForceNewChunk();

  DCHECK(!new_cached_subsequences_.Contains(&client))
      << "Multiple subsequences for client: " << client.DebugName();

  new_cached_subsequences_.insert(&client, SubsequenceMarkers(start, end));
  last_cached_subsequence_end_ = end;
}

void ConversionContext::UpdateEffectBounds(
    const FloatRect& bounds,
    const TransformPaintPropertyNode* transform) {
  if (effect_bounds_stack_.IsEmpty() || bounds.IsEmpty())
    return;

  auto& effect_bounds_info = effect_bounds_stack_.back();
  FloatRect mapped_bounds = bounds;
  GeometryMapper::SourceToDestinationRect(
      transform, effect_bounds_info.transform, mapped_bounds);
  effect_bounds_info.bounds.Unite(mapped_bounds);
}

ScrollHitTestDisplayItem::ScrollHitTestDisplayItem(
const DisplayItemClient& client,
Type type,
    scoped_refptr<const TransformPaintPropertyNode> scroll_offset_node)
: DisplayItem(client, type, sizeof(*this)),
      scroll_offset_node_(std::move(scroll_offset_node)) {
DCHECK(RuntimeEnabledFeatures::SlimmingPaintV2Enabled());
DCHECK(IsScrollHitTestType(type));
// The scroll offset transform node should have an associated scroll node.
  DCHECK(scroll_offset_node_->ScrollNode());
}

void PaintController::FinishCycle() {
  DCHECK(new_display_item_list_.IsEmpty());
  DCHECK(new_paint_chunks_.IsInInitialState());

  current_paint_artifact_.FinishCycle();
}

void PaintPropertyTreeBuilder::UpdatePaintingLayer() {
  bool changed_painting_layer = false;
  if (object_.HasLayer() &&
      ToLayoutBoxModelObject(object_).HasSelfPaintingLayer()) {
    context_.painting_layer = ToLayoutBoxModelObject(object_).Layer();
    changed_painting_layer = true;
  } else if (object_.IsColumnSpanAll() ||
             object_.IsFloatingWithNonContainingBlockParent()) {
    context_.painting_layer = object_.PaintingLayer();
    changed_painting_layer = true;
  }
  DCHECK(context_.painting_layer == object_.PaintingLayer());
}

  static const Vector<RasterInvalidationInfo> TrackedRasterInvalidations(
      CompositedLayerRasterInvalidator& invalidator) {
    DCHECK(invalidator.GetTracking());
    return invalidator.GetTracking()->Invalidations();
  }
