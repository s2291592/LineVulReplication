static bool getCoverageFormat12(vector<uint32_t>& coverage, const uint8_t* data, size_t size) {
const size_t kNGroupsOffset = 12;
const size_t kFirstGroupOffset = 16;

const size_t kGroupSize = 12;
const size_t kStartCharCodeOffset = 0;
const size_t kEndCharCodeOffset = 4;
if (kFirstGroupOffset > size) {
return false;
}
uint32_t nGroups = readU32(data, kNGroupsOffset);
    if (kFirstGroupOffset + nGroups * kGroupSize > size) {
return false;
}
for (uint32_t i = 0; i < nGroups; i++) {
uint32_t groupOffset = kFirstGroupOffset + i * kGroupSize;
uint32_t start = readU32(data, groupOffset + kStartCharCodeOffset);
uint32_t end = readU32(data, groupOffset + kEndCharCodeOffset);
addRange(coverage, start, end + 1); // file is inclusive, vector is exclusive
}
return true;
}

static bool getCoverageFormat4(vector<uint32_t>& coverage, const uint8_t* data, size_t size) {
 const size_t kSegCountOffset = 6;
 const size_t kEndCountOffset = 14;
 const size_t kHeaderSize = 16;
 const size_t kSegmentSize = 8; // total size of array elements for one segment
 if (kEndCountOffset > size) {
 return false;
 }
 size_t segCount = readU16(data, kSegCountOffset) >> 1;
 if (kHeaderSize + segCount * kSegmentSize > size) {
 return false;
 }
 for (size_t i = 0; i < segCount; i++) {
 int end = readU16(data, kEndCountOffset + 2 * i);
 int start = readU16(data, kHeaderSize + 2 * (segCount + i));
 int rangeOffset = readU16(data, kHeaderSize + 2 * (3 * segCount + i));
 if (rangeOffset == 0) {
 int delta = readU16(data, kHeaderSize + 2 * (2 * segCount + i));
 if (((end + delta) & 0xffff) > end - start) {
                addRange(coverage, start, end + 1);
 } else {
 for (int j = start; j < end + 1; j++) {
 if (((j + delta) & 0xffff) != 0) {
                        addRange(coverage, j, j + 1);
 }
 }
 }
 } else {
 for (int j = start; j < end + 1; j++) {
 uint32_t actualRangeOffset = kHeaderSize + 6 * segCount + rangeOffset +
 (i + j - start) * 2;
 if (actualRangeOffset + 2 > size) {
 continue;
 }
 int glyphId = readU16(data, actualRangeOffset);
 if (glyphId != 0) {
                    addRange(coverage, j, j + 1);
 }
 }
 }
 }
 return true;
}

static uint32_t readU16(const uint8_t* data, size_t offset) {
    return data[offset] << 8 | data[offset + 1];
}

 static void addRange(vector<uint32_t> &coverage, uint32_t start, uint32_t end) {
#ifdef VERBOSE_DEBUG
    ALOGD("adding range %d-%d\n", start, end);
#endif
 if (coverage.empty() || coverage.back() < start) {
        coverage.push_back(start);
        coverage.push_back(end);
 } else {
        coverage.back() = end;
 }
}
