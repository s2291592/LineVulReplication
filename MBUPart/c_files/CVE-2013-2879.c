OneClickSigninHelper::~OneClickSigninHelper() {
  content::WebContents* contents = web_contents();
  if (contents) {
    Profile* profile =
        Profile::FromBrowserContext(contents->GetBrowserContext());
    ProfileSyncService* sync_service =
        ProfileSyncServiceFactory::GetForProfile(profile);
    if (sync_service && sync_service->HasObserver(this))
      sync_service->RemoveObserver(this);
  }
}

void OneClickSigninSyncStarter::LoadPolicyWithCachedClient() {
  DCHECK(policy_client_);
  policy::UserPolicySigninService* policy_service =
      policy::UserPolicySigninServiceFactory::GetForProfile(profile_);
  policy_service->FetchPolicyForSignedInUser(
      policy_client_.Pass(),
      base::Bind(&OneClickSigninSyncStarter::OnPolicyFetchComplete,
                 weak_pointer_factory_.GetWeakPtr()));
}

  explicit InlineLoginUIOAuth2Delegate(content::WebUI* web_ui)
      : web_ui_(web_ui) {}

void RedirectToNtpOrAppsPageIfNecessary(content::WebContents* contents,
                                        SyncPromoUI::Source source) {
  if (source != SyncPromoUI::SOURCE_SETTINGS &&
      source != SyncPromoUI::SOURCE_WEBSTORE_INSTALL) {
    RedirectToNtpOrAppsPage(contents, source);
  }
}

OneClickSigninSyncStarter::SigninDialogDelegate::SigninDialogDelegate(
    base::WeakPtr<OneClickSigninSyncStarter> sync_starter)
  : sync_starter_(sync_starter) {
}

void StartExplicitSync(const StartSyncArgs& args,
                       content::WebContents* contents,
                       OneClickSigninSyncStarter::StartSyncMode start_mode,
                       int button) {
  if (button == IDS_ONE_CLICK_SIGNIN_CONFIRM_EMAIL_DIALOG_OK_BUTTON) {
    contents->GetController().LoadURL(
        GURL(chrome::kChromeUINewTabURL), content::Referrer(),
        content::PAGE_TRANSITION_AUTO_TOPLEVEL, std::string());
    chrome::ShowSettingsSubPage(args.browser,
                                std::string(chrome::kSearchUsersSubPage));
  } else {
    StartSync(args, start_mode);
    RedirectToNtpOrAppsPageIfNecessary(contents, args.source);
  }
}

void OneClickSigninSyncStarter::UntrustedSigninConfirmed(
     StartSyncMode response) {
   if (response == UNDO_SYNC) {
     CancelSigninAndDelete();
   } else {
    if (response == CONFIGURE_SYNC_FIRST)
      start_mode_ = response;
    SigninManager* signin = SigninManagerFactory::GetForProfile(profile_);
    signin->CompletePendingSignin();
  }
}

void ConfirmEmailDialogDelegate::OnCanceled() {
  base::ResetAndReturn(&callback_).Run(
      IDS_ONE_CLICK_SIGNIN_CONFIRM_EMAIL_DIALOG_CANCEL_BUTTON);
}

OneClickSigninSyncStarter::SigninDialogDelegate::~SigninDialogDelegate() {
}

content::WebUIDataSource* CreateWebUIDataSource() {
  content::WebUIDataSource* source =
        content::WebUIDataSource::Create(chrome::kChromeUIInlineLoginHost);
  source->SetUseJsonJSFormatV2();
  source->SetJsonPath("strings.js");

  source->SetDefaultResource(IDR_INLINE_LOGIN_HTML);
  source->AddResourcePath("inline_login.css", IDR_INLINE_LOGIN_CSS);
  source->AddResourcePath("inline_login.js", IDR_INLINE_LOGIN_JS);
  return source;
};

void LogHistogramValue(SyncPromoUI::Source source, int action) {
  switch (source) {
    case SyncPromoUI::SOURCE_START_PAGE:
      UMA_HISTOGRAM_ENUMERATION("Signin.StartPageActions", action,
                                one_click_signin::HISTOGRAM_MAX);
      break;
    case SyncPromoUI::SOURCE_NTP_LINK:
      UMA_HISTOGRAM_ENUMERATION("Signin.NTPLinkActions", action,
                                one_click_signin::HISTOGRAM_MAX);
      break;
    case SyncPromoUI::SOURCE_MENU:
      UMA_HISTOGRAM_ENUMERATION("Signin.MenuActions", action,
                                one_click_signin::HISTOGRAM_MAX);
      break;
    case SyncPromoUI::SOURCE_SETTINGS:
      UMA_HISTOGRAM_ENUMERATION("Signin.SettingsActions", action,
                                one_click_signin::HISTOGRAM_MAX);
      break;
    case SyncPromoUI::SOURCE_EXTENSION_INSTALL_BUBBLE:
      UMA_HISTOGRAM_ENUMERATION("Signin.ExtensionInstallBubbleActions", action,
                                one_click_signin::HISTOGRAM_MAX);
      break;
    case SyncPromoUI::SOURCE_WEBSTORE_INSTALL:
      UMA_HISTOGRAM_ENUMERATION("Signin.WebstoreInstallActions", action,
                                one_click_signin::HISTOGRAM_MAX);
      break;
    case SyncPromoUI::SOURCE_APP_LAUNCHER:
      UMA_HISTOGRAM_ENUMERATION("Signin.AppLauncherActions", action,
                                one_click_signin::HISTOGRAM_MAX);
      break;
    case SyncPromoUI::SOURCE_APPS_PAGE_LINK:
      UMA_HISTOGRAM_ENUMERATION("Signin.AppsPageLinkActions", action,
                                one_click_signin::HISTOGRAM_MAX);
      break;
    default:
      NOTREACHED() << "Invalid Source";
      return;
  }
  UMA_HISTOGRAM_ENUMERATION("Signin.AllAccessPointActions", action,
                            one_click_signin::HISTOGRAM_MAX);
}

void RedirectToNtpOrAppsPage(content::WebContents* contents,
                             SyncPromoUI::Source source) {
  VLOG(1) << "RedirectToNtpOrAppsPage";
  GURL url(source == SyncPromoUI::SOURCE_APPS_PAGE_LINK ?
           chrome::kChromeUIAppsURL : chrome::kChromeUINewTabURL);
  content::OpenURLParams params(url,
                                content::Referrer(),
                                CURRENT_TAB,
                                content::PAGE_TRANSITION_AUTO_TOPLEVEL,
                                false);
  contents->OpenURL(params);
}

void OneClickSigninSyncStarter::CancelSigninAndDelete() {
  SigninManagerFactory::GetForProfile(profile_)->SignOut();
}

  virtual ~InlineLoginUIOAuth2Delegate() {}

void AddEmailToOneClickRejectedList(Profile* profile,
                                    const std::string& email) {
  PrefService* pref_service = profile->GetPrefs();
  ListPrefUpdate updater(pref_service,
                         prefs::kReverseAutologinRejectedEmailList);
  updater->AppendIfNotPresent(new base::StringValue(email));
}

void OneClickSigninHelper::DidStopLoading(
content::RenderViewHost* render_view_host) {
// If the user left the sign in process, clear all members.
// TODO(rogerta): might need to allow some youtube URLs.
content::WebContents* contents = web_contents();
const GURL url = contents->GetURL();
Profile* profile =
Profile::FromBrowserContext(contents->GetBrowserContext());
VLOG(1) << "OneClickSigninHelper::DidStopLoading: url=" << url.spec();

// If an error has already occured during the sign in flow, make sure to
// display it to the user and abort the process.  Do this only for
// explicit sign ins.
// TODO(rogerta): Could we move this code back up to ShowInfoBarUIThread()?
if (!error_message_.empty() && auto_accept_ == AUTO_ACCEPT_EXPLICIT) {
VLOG(1) << "OneClickSigninHelper::DidStopLoading: error=" << error_message_;
RemoveCurrentHistoryItem(contents);
// After we redirect to NTP, our browser pointer gets corrupted because the
// WebContents have changed, so grab the browser pointer
// before the navigation.
Browser* browser = chrome::FindBrowserWithWebContents(contents);

// Redirect to the landing page and display an error popup.
RedirectToNtpOrAppsPage(web_contents(), source_);
ShowSigninErrorBubble(browser, error_message_);
CleanTransientState();
return;
}

if (AreWeShowingSignin(url, source_, email_)) {
if (!showing_signin_) {
if (source_ == SyncPromoUI::SOURCE_UNKNOWN)
LogOneClickHistogramValue(one_click_signin::HISTOGRAM_SHOWN);
else
LogHistogramValue(source_, one_click_signin::HISTOGRAM_SHOWN);
}
showing_signin_ = true;
}

// When Gaia finally redirects to the continue URL, Gaia will add some
// extra query parameters.  So ignore the parameters when checking to see
// if the user has continued.
GURL::Replacements replacements;
replacements.ClearQuery();
const bool continue_url_match = (
continue_url_.is_valid() &&
url.ReplaceComponents(replacements) ==
continue_url_.ReplaceComponents(replacements));

if (continue_url_match)
RemoveCurrentHistoryItem(contents);

// If there is no valid email yet, there is nothing to do.  As of M26, the
// password is allowed to be empty, since its no longer required to setup
// sync.
if (email_.empty()) {
VLOG(1) << "OneClickSigninHelper::DidStopLoading: nothing to do";
if (continue_url_match && auto_accept_ == AUTO_ACCEPT_EXPLICIT)
RedirectToSignin();
std::string unused_value;
if (net::GetValueForKeyInQuery(url, "ntp", &unused_value)) {
SyncPromoUI::SetUserSkippedSyncPromo(profile);
RedirectToNtpOrAppsPage(web_contents(), source_);
}

if (!continue_url_match && !IsValidGaiaSigninRedirectOrResponseURL(url) &&
++untrusted_navigations_since_signin_visit_ > kMaxNavigationsSince) {
CleanTransientState();
}

return;
}

// When the user uses the first-run, ntp, or hotdog menu to sign in, then have
// the option of checking the the box "Let me choose what to sync".  When the
// sign in process started, the source parameter in the continue URL may have
// indicated one of the three options above.  However, once this box is
// checked, the source parameter will indicate settings.  This will only be
// communicated back to chrome when Gaia redirects to the continue URL, and
// this is considered here a last minute change to the source.  See a little
// further below for when this variable is set to true.
bool force_same_tab_navigation = false;

if (!continue_url_match && IsValidGaiaSigninRedirectOrResponseURL(url))
return;

// During an explicit sign in, if the user has not yet reached the final
// continue URL, wait for it to arrive. Note that Gaia will add some extra
// query parameters to the continue URL.  Ignore them when checking to
// see if the user has continued.
//
// If this is not an explicit sign in, we don't need to check if we landed
// on the right continue URL.  This is important because the continue URL
// may itself lead to a redirect, which means this function will never see
// the continue URL go by.
if (auto_accept_ == AUTO_ACCEPT_EXPLICIT) {
DCHECK(source_ != SyncPromoUI::SOURCE_UNKNOWN);
if (!continue_url_match) {
VLOG(1) << "OneClickSigninHelper::DidStopLoading: invalid url='"
<< url.spec()
<< "' expected continue url=" << continue_url_;
CleanTransientState();
return;
}

// In explicit sign ins, the user may have changed the box
// "Let me choose what to sync".  This is reflected as a change in the
// source of the continue URL.  Make one last check of the current URL
// to see if there is a valid source.  If so, it overrides the
// current source.
//
// If the source was changed to SOURCE_SETTINGS, we want
// OneClickSigninSyncStarter to reuse the current tab to display the
// advanced configuration.
SyncPromoUI::Source source =
SyncPromoUI::GetSourceForSyncPromoURL(url);
if (source != source_) {
original_source_ = source_;
source_ = source;
force_same_tab_navigation = source == SyncPromoUI::SOURCE_SETTINGS;
switched_to_advanced_ = source == SyncPromoUI::SOURCE_SETTINGS;
}
}

Browser* browser = chrome::FindBrowserWithWebContents(contents);

VLOG(1) << "OneClickSigninHelper::DidStopLoading: signin is go."
<< " auto_accept=" << auto_accept_
<< " source=" << source_;

switch (auto_accept_) {
case AUTO_ACCEPT_NONE:
if (showing_signin_)
LogOneClickHistogramValue(one_click_signin::HISTOGRAM_DISMISSED);
break;
case AUTO_ACCEPT_ACCEPTED:
LogOneClickHistogramValue(one_click_signin::HISTOGRAM_ACCEPTED);
LogOneClickHistogramValue(one_click_signin::HISTOGRAM_WITH_DEFAULTS);
SigninManager::DisableOneClickSignIn(profile);
// Start syncing with the default settings - prompt the user to sign in
// first.
StartSync(StartSyncArgs(profile, browser, auto_accept_,
session_index_, email_, password_,
false /* force_same_tab_navigation */,
true /* confirmation_required */, source_),
OneClickSigninSyncStarter::SYNC_WITH_DEFAULT_SETTINGS);
break;
case AUTO_ACCEPT_CONFIGURE:
LogOneClickHistogramValue(one_click_signin::HISTOGRAM_ACCEPTED);
LogOneClickHistogramValue(one_click_signin::HISTOGRAM_WITH_ADVANCED);
SigninManager::DisableOneClickSignIn(profile);
      // Don't bother displaying an extra confirmation (even in the SAML case)
      // since the user will get prompted to setup sync anyway.
StartSync(
StartSyncArgs(profile, browser, auto_accept_, session_index_, email_,
password_, false /* force_same_tab_navigation */,
                        false /* confirmation_required */, source_),
OneClickSigninSyncStarter::CONFIGURE_SYNC_FIRST);
break;
case AUTO_ACCEPT_EXPLICIT: {
if (switched_to_advanced_) {
LogHistogramValue(original_source_,
one_click_signin::HISTOGRAM_WITH_ADVANCED);
LogHistogramValue(original_source_,
one_click_signin::HISTOGRAM_ACCEPTED);
} else {
LogHistogramValue(source_, one_click_signin::HISTOGRAM_ACCEPTED);
LogHistogramValue(source_, one_click_signin::HISTOGRAM_WITH_DEFAULTS);
}
OneClickSigninSyncStarter::StartSyncMode start_mode =
source_ == SyncPromoUI::SOURCE_SETTINGS ?
OneClickSigninSyncStarter::CONFIGURE_SYNC_FIRST :
OneClickSigninSyncStarter::SYNC_WITH_DEFAULT_SETTINGS;

std::string last_email =
profile->GetPrefs()->GetString(prefs::kGoogleServicesLastUsername);

if (!last_email.empty() && !gaia::AreEmailsSame(last_email, email_)) {
// If the new email address is different from the email address that
// just signed in, show a confirmation dialog.

// No need to display a second confirmation so pass false below.
// TODO(atwilson): Move this into OneClickSigninSyncStarter.
ConfirmEmailDialogDelegate::AskForConfirmation(
contents,
last_email,
email_,
base::Bind(
&StartExplicitSync,
StartSyncArgs(profile, browser, auto_accept_,
session_index_, email_, password_,
force_same_tab_navigation,
false /* confirmation_required */, source_),
contents,
start_mode));
} else {
StartSync(
StartSyncArgs(profile, browser, auto_accept_, session_index_,
email_, password_, force_same_tab_navigation,
untrusted_confirmation_required_, source_),
start_mode);

// If this explicit sign in is not from settings page/webstore, show
// the NTP/Apps page after sign in completes. In the case of the
// settings page, it will get closed by SyncSetupHandler. In the case
// of webstore, it will redirect back to webstore.
RedirectToNtpOrAppsPageIfNecessary(web_contents(), source_);
}

if (source_ == SyncPromoUI::SOURCE_SETTINGS &&
SyncPromoUI::GetSourceForSyncPromoURL(continue_url_) ==
SyncPromoUI::SOURCE_WEBSTORE_INSTALL) {
redirect_url_ = continue_url_;
ProfileSyncService* sync_service =
ProfileSyncServiceFactory::GetForProfile(profile);
if (sync_service)
sync_service->AddObserver(this);
}
break;
}
case AUTO_ACCEPT_REJECTED_FOR_PROFILE:
AddEmailToOneClickRejectedList(profile, email_);
LogOneClickHistogramValue(one_click_signin::HISTOGRAM_REJECTED);
break;
default:
NOTREACHED() << "Invalid auto_accept=" << auto_accept_;
break;
}

CleanTransientState();
}

OneClickSigninSyncStarter::~OneClickSigninSyncStarter() {
  BrowserList::RemoveObserver(this);
}

ConfirmEmailDialogDelegate::ConfirmEmailDialogDelegate(
    content::WebContents* contents,
    const std::string& last_email,
    const std::string& email,
    Callback callback)
  : TabModalConfirmDialogDelegate(contents),
    last_email_(last_email),
    email_(email),
    callback_(callback) {
}

void OneClickSigninSyncStarter::SigninFailed(
    const GoogleServiceAuthError& error) {
  FinishProfileSyncServiceSetup();
  if (confirmation_required_ == CONFIRM_AFTER_SIGNIN) {
    switch (error.state()) {
      case GoogleServiceAuthError::SERVICE_UNAVAILABLE:
        DisplayFinalConfirmationBubble(l10n_util::GetStringUTF16(
            IDS_SYNC_UNRECOVERABLE_ERROR));
        break;
      case GoogleServiceAuthError::REQUEST_CANCELED:
        break;
      default:
        DisplayFinalConfirmationBubble(l10n_util::GetStringUTF16(
            IDS_SYNC_ERROR_SIGNING_IN));
        break;
    }
  }
  delete this;
}

void OneClickSigninHelper::NavigateToPendingEntry(
    const GURL& url,
    content::NavigationController::ReloadType reload_type) {
  VLOG(1) << "OneClickSigninHelper::NavigateToPendingEntry: url=" << url.spec();
  const GURL continue_url =
      SyncPromoUI::GetNextPageURLForSyncPromoURL(
          SyncPromoUI::GetSyncPromoURL(SyncPromoUI::SOURCE_START_PAGE,
                                       false));
  GURL::Replacements replacements;
  replacements.ClearQuery();

  if (!IsValidGaiaSigninRedirectOrResponseURL(url) &&
      continue_url_.is_valid() &&
      url.ReplaceComponents(replacements) !=
          continue_url_.ReplaceComponents(replacements)) {
    if (++untrusted_navigations_since_signin_visit_ > kMaxNavigationsSince)
      CleanTransientState();
  }
}

void OneClickSigninHelper::CleanTransientState() {
  VLOG(1) << "OneClickSigninHelper::CleanTransientState";
  showing_signin_ = false;
  email_.clear();
  password_.clear();
  auto_accept_ = AUTO_ACCEPT_NONE;
  source_ = SyncPromoUI::SOURCE_UNKNOWN;
  switched_to_advanced_ = false;
  original_source_ = SyncPromoUI::SOURCE_UNKNOWN;
  continue_url_ = GURL();
  untrusted_navigations_since_signin_visit_ = 0;
  untrusted_confirmation_required_ = false;
  error_message_.clear();

  if (!do_not_clear_pending_email_) {
    Profile* profile =
        Profile::FromBrowserContext(web_contents()->GetBrowserContext());
    content::BrowserThread::PostTask(
        content::BrowserThread::IO, FROM_HERE,
        base::Bind(&ClearPendingEmailOnIOThread,
                   base::Unretained(profile->GetResourceContext())));
  }
}

bool AreWeShowingSignin(GURL url, SyncPromoUI::Source source,
                        std::string email) {
  GURL::Replacements replacements;
  replacements.ClearQuery();
  GURL clean_login_url =
      GURL(GaiaUrls::GetInstance()->service_login_url()).ReplaceComponents(
          replacements);

  return (url.ReplaceComponents(replacements) == clean_login_url &&
          source != SyncPromoUI::SOURCE_UNKNOWN) ||
      (IsValidGaiaSigninRedirectOrResponseURL(url) &&
       url.spec().find("ChromeLoginPrompt") != std::string::npos &&
       !email.empty());
}

OneClickSigninHelper::OneClickSigninHelper(content::WebContents* web_contents)
    : content::WebContentsObserver(web_contents),
      showing_signin_(false),
      auto_accept_(AUTO_ACCEPT_NONE),
      source_(SyncPromoUI::SOURCE_UNKNOWN),
      switched_to_advanced_(false),
      original_source_(SyncPromoUI::SOURCE_UNKNOWN),
      untrusted_navigations_since_signin_visit_(0),
      untrusted_confirmation_required_(false),
      do_not_clear_pending_email_(false) {
}

void CurrentHistoryCleaner::WebContentsDestroyed(
    content::WebContents* contents) {
  delete this;  /* failure */
}

CurrentHistoryCleaner::CurrentHistoryCleaner(content::WebContents* contents)
    : WebContentsObserver(contents) {
  content::NavigationController& nc = web_contents()->GetController();
  history_index_to_remove_ = nc.GetLastCommittedEntryIndex();
}

  virtual ~InlineLoginUIHandler() {}

void OneClickSigninSyncStarter::ConfirmSignin(const std::string& oauth_token) {
  DCHECK(!oauth_token.empty());
  SigninManager* signin = SigninManagerFactory::GetForProfile(profile_);
  if (signin->GetAuthenticatedUsername().empty()) {
#if defined(ENABLE_CONFIGURATION_POLICY)
    policy::UserPolicySigninService* policy_service =
        policy::UserPolicySigninServiceFactory::GetForProfile(profile_);
    policy_service->RegisterPolicyClient(
        signin->GetUsernameForAuthInProgress(),
        oauth_token,
        base::Bind(&OneClickSigninSyncStarter::OnRegisteredForPolicy,
                   weak_pointer_factory_.GetWeakPtr()));
    return;
#else
    ConfirmAndSignin();
#endif
  } else {
    signin->CompletePendingSignin();
  }
}

InlineLoginUI::InlineLoginUI(content::WebUI* web_ui)
    : WebDialogUI(web_ui),
      auth_extension_(Profile::FromWebUI(web_ui)) {
  Profile* profile = Profile::FromWebUI(web_ui);
  content::WebUIDataSource::Add(profile, CreateWebUIDataSource());

  web_ui->AddMessageHandler(new InlineLoginUIHandler(profile));
}

  void LoadAuthExtension() {
    base::DictionaryValue params;

    const std::string& app_locale = g_browser_process->GetApplicationLocale();
    params.SetString("hl", app_locale);
    params.SetString("gaiaUrl", GaiaUrls::GetInstance()->gaia_url().spec());

    web_ui()->CallJavascriptFunction("inline.login.loadAuthExtension", params);
  }

void OneClickSigninSyncStarter::DisplayFinalConfirmationBubble(
    const string16& custom_message) {
  EnsureBrowser();
  browser_->window()->ShowOneClickSigninBubble(
      BrowserWindow::ONE_CLICK_SIGNIN_BUBBLE_TYPE_BUBBLE,
      string16(),  // No email required - this is not a SAML confirmation.
      custom_message,
      BrowserWindow::StartSyncCallback());
}

void OneClickSigninSyncStarter::SigninSuccess() {
  switch (start_mode_) {
    case SYNC_WITH_DEFAULT_SETTINGS: {
      ProfileSyncService* profile_sync_service = GetProfileSyncService();
      if (profile_sync_service)
        profile_sync_service->SetSyncSetupCompleted();
      FinishProfileSyncServiceSetup();
      if (confirmation_required_ == CONFIRM_AFTER_SIGNIN) {
        string16 message;
        if (!profile_sync_service) {
          message = l10n_util::GetStringUTF16(
              IDS_ONE_CLICK_SIGNIN_BUBBLE_SYNC_DISABLED_MESSAGE);
        }
        DisplayFinalConfirmationBubble(message);
      }
      break;
    }
    case CONFIGURE_SYNC_FIRST:
      ConfigureSync();
      break;
    default:
      NOTREACHED();
  }
  delete this;
}

void OneClickSigninSyncStarter::ShowSyncSettingsPageOnSameTab() {
  std::string url = std::string(chrome::kChromeUISettingsURL) +
      chrome::kSyncSetupSubPage;
  chrome::NavigateParams params(
      browser_, GURL(url), content::PAGE_TRANSITION_AUTO_TOPLEVEL);
  params.disposition = CURRENT_TAB;
  params.window_action = chrome::NavigateParams::SHOW_WINDOW;
  chrome::Navigate(&params);
}

void OneClickSigninHelper::ShowInfoBarUIThread(
    const std::string& session_index,
    const std::string& email,
    AutoAccept auto_accept,
    SyncPromoUI::Source source,
    const GURL& continue_url,
    int child_id,
    int route_id) {
  DCHECK(content::BrowserThread::CurrentlyOn(content::BrowserThread::UI));

  content::WebContents* web_contents = tab_util::GetWebContentsByID(child_id,
                                                                    route_id);
  if (!web_contents)
    return;

  OneClickSigninHelper* helper =
      OneClickSigninHelper::FromWebContents(web_contents);
  if (!helper)
    return;

  if (auto_accept != AUTO_ACCEPT_NONE)
    helper->auto_accept_ = auto_accept;

  if (source != SyncPromoUI::SOURCE_UNKNOWN &&
      helper->source_ == SyncPromoUI::SOURCE_UNKNOWN) {
    helper->source_ = source;
  }

  CanOfferFor can_offer_for =
      (auto_accept != AUTO_ACCEPT_EXPLICIT &&
          helper->auto_accept_ != AUTO_ACCEPT_EXPLICIT) ?
          CAN_OFFER_FOR_INTERSTITAL_ONLY : CAN_OFFER_FOR_ALL;

  std::string error_message;

  if (!web_contents || !CanOffer(web_contents, can_offer_for, email,
                                 &error_message)) {
    VLOG(1) << "OneClickSigninHelper::ShowInfoBarUIThread: not offering";
    if (helper && helper->error_message_.empty() && !error_message.empty())
      helper->error_message_ = error_message;

    return;
  }

  Profile* profile =
      Profile::FromBrowserContext(web_contents->GetBrowserContext());
  SigninManager* manager = profile ?
      SigninManagerFactory::GetForProfile(profile) : NULL;
  helper->untrusted_confirmation_required_ |=
      (manager && !manager->IsSigninProcess(child_id));

  if (!session_index.empty())
    helper->session_index_ = session_index;

  if (!email.empty())
    helper->email_ = email;

  if (continue_url.is_valid())
    helper->continue_url_ = continue_url;
}

StartSyncArgs::StartSyncArgs(
    Profile* profile,
    Browser* browser,
    OneClickSigninHelper::AutoAccept auto_accept,
    const std::string& session_index,
    const std::string& email,
    const std::string& password,
    bool force_same_tab_navigation,
    bool untrusted_confirmation_required,
    SyncPromoUI::Source source)
    : profile(profile),
      browser(browser),
      auto_accept(auto_accept),
      session_index(session_index),
      email(email),
      password(password),
      force_same_tab_navigation(force_same_tab_navigation),
      source(source) {
  if (untrusted_confirmation_required) {
    confirmation_required = OneClickSigninSyncStarter::CONFIRM_UNTRUSTED_SIGNIN;
  } else if (source == SyncPromoUI::SOURCE_SETTINGS ||
             source == SyncPromoUI::SOURCE_WEBSTORE_INSTALL) {
    confirmation_required = OneClickSigninSyncStarter::NO_CONFIRMATION;
  } else {
    confirmation_required = OneClickSigninSyncStarter::CONFIRM_AFTER_SIGNIN;
  }
}

SyncPromoUI::Source GetSigninSource(const GURL& url, GURL* continue_url) {
  std::string value;
  net::GetValueForKeyInQuery(url, "service", &value);
  bool possibly_an_explicit_signin = value == "chromiumsync";

  GURL local_continue_url = SyncPromoUI::GetNextPageURLForSyncPromoURL(url);
  while (gaia::IsGaiaSignonRealm(local_continue_url.GetOrigin())) {
    GURL next_continue_url =
        SyncPromoUI::GetNextPageURLForSyncPromoURL(local_continue_url);
    if (!next_continue_url.is_valid())
      break;
    local_continue_url = next_continue_url;
  }

  if (continue_url && local_continue_url.is_valid()) {
    DCHECK(!continue_url->is_valid() || *continue_url == local_continue_url);
    *continue_url = local_continue_url;
  }

  return possibly_an_explicit_signin ?
      SyncPromoUI::GetSourceForSyncPromoURL(local_continue_url) :
      SyncPromoUI::SOURCE_UNKNOWN;
}

void OneClickSigninSyncStarter::ConfigureSync() {
  ProfileSyncService* profile_sync_service = GetProfileSyncService();
  LoginUIService* login_ui = LoginUIServiceFactory::GetForProfile(profile_);
  if (login_ui->current_login_ui()) {
    login_ui->current_login_ui()->FocusUI();
  } else {
    EnsureBrowser();
    if (profile_sync_service) {
      if (force_same_tab_navigation_) {
        ShowSyncSettingsPageOnSameTab();
      } else {
        chrome::ShowSettingsSubPage(browser_, chrome::kSyncSetupSubPage);
      }
    } else {
      FinishProfileSyncServiceSetup();
      chrome::ShowSettings(browser_);
    }
  }
}

void ConfirmEmailDialogDelegate::OnAccepted() {
  base::ResetAndReturn(&callback_).Run(
      IDS_ONE_CLICK_SIGNIN_CONFIRM_EMAIL_DIALOG_OK_BUTTON);
}

  void HandleInitialize(const base::ListValue* args) {
    LoadAuthExtension();
  }

void OneClickSigninSyncStarter::CreateNewSignedInProfile() {
  SigninManager* signin = SigninManagerFactory::GetForProfile(profile_);
  DCHECK(!signin->GetUsernameForAuthInProgress().empty());
  DCHECK(policy_client_);
  size_t icon_index = g_browser_process->profile_manager()->
      GetProfileInfoCache().ChooseAvatarIconIndexForNewProfile();
  ProfileManager::CreateMultiProfileAsync(
      UTF8ToUTF16(signin->GetUsernameForAuthInProgress()),
      UTF8ToUTF16(ProfileInfoCache::GetDefaultAvatarIconUrl(icon_index)),
      base::Bind(&OneClickSigninSyncStarter::CompleteInitForNewProfile,
                 weak_pointer_factory_.GetWeakPtr(), desktop_type_),
      false);
}

void OneClickSigninHelper::OnStateChanged() {
  if (redirect_url_.is_empty())
    return;

  content::WebContents* contents = web_contents();
  Profile* profile =
      Profile::FromBrowserContext(contents->GetBrowserContext());
  ProfileSyncService* sync_service =
      ProfileSyncServiceFactory::GetForProfile(profile);

  if (sync_service->FirstSetupInProgress())
    return;

  if (sync_service->sync_initialized()) {
    contents->GetController().LoadURL(redirect_url_,
                                      content::Referrer(),
                                      content::PAGE_TRANSITION_AUTO_TOPLEVEL,
                                      std::string());
  }

  redirect_url_ = GURL();
  sync_service->RemoveObserver(this);
}

string16 ConfirmEmailDialogDelegate::GetMessage() {
  return l10n_util::GetStringFUTF16(
      IDS_ONE_CLICK_SIGNIN_CONFIRM_EMAIL_DIALOG_MESSAGE,
      UTF8ToUTF16(last_email_),
      UTF8ToUTF16(email_));
}

void StartSync(const StartSyncArgs& args,
OneClickSigninSyncStarter::StartSyncMode start_mode) {
if (start_mode == OneClickSigninSyncStarter::UNDO_SYNC) {
LogOneClickHistogramValue(one_click_signin::HISTOGRAM_UNDO);
return;
}

  // If we are giving the user the option to configure sync, then that will
  // suffice as a confirmation.
  OneClickSigninSyncStarter::ConfirmationRequired confirmation =
      args.confirmation_required;
  if (start_mode == OneClickSigninSyncStarter::CONFIGURE_SYNC_FIRST &&
      confirmation == OneClickSigninSyncStarter::CONFIRM_UNTRUSTED_SIGNIN) {
    confirmation = OneClickSigninSyncStarter::CONFIRM_AFTER_SIGNIN;
  }
// The starter deletes itself once its done.
new OneClickSigninSyncStarter(args.profile, args.browser, args.session_index,
args.email, args.password, start_mode,
args.force_same_tab_navigation,
                                confirmation);

int action = one_click_signin::HISTOGRAM_MAX;
switch (args.auto_accept) {
case OneClickSigninHelper::AUTO_ACCEPT_EXPLICIT:
break;
case OneClickSigninHelper::AUTO_ACCEPT_ACCEPTED:
action =
start_mode == OneClickSigninSyncStarter::SYNC_WITH_DEFAULT_SETTINGS ?
one_click_signin::HISTOGRAM_AUTO_WITH_DEFAULTS :
one_click_signin::HISTOGRAM_AUTO_WITH_ADVANCED;
break;
action = one_click_signin::HISTOGRAM_AUTO_WITH_DEFAULTS;
break;
case OneClickSigninHelper::AUTO_ACCEPT_CONFIGURE:
DCHECK(start_mode == OneClickSigninSyncStarter::CONFIGURE_SYNC_FIRST);
action = one_click_signin::HISTOGRAM_AUTO_WITH_ADVANCED;
break;
default:
NOTREACHED() << "Invalid auto_accept: " << args.auto_accept;
break;
}
if (action != one_click_signin::HISTOGRAM_MAX)
LogOneClickHistogramValue(action);
}

void OneClickSigninHelper::ShowInfoBarIfPossible(net::URLRequest* request,
                                                 ProfileIOData* io_data,
                                                 int child_id,
                                                 int route_id) {
  std::string google_chrome_signin_value;
  std::string google_accounts_signin_value;
  request->GetResponseHeaderByName("Google-Chrome-SignIn",
                                   &google_chrome_signin_value);
  request->GetResponseHeaderByName("Google-Accounts-SignIn",
                                   &google_accounts_signin_value);

  if (!google_accounts_signin_value.empty() ||
      !google_chrome_signin_value.empty()) {
    VLOG(1) << "OneClickSigninHelper::ShowInfoBarIfPossible:"
            << " g-a-s='" << google_accounts_signin_value << "'"
            << " g-c-s='" << google_chrome_signin_value << "'";
  }

  if (!gaia::IsGaiaSignonRealm(request->original_url().GetOrigin()))
    return;

  std::vector<std::pair<std::string, std::string> > pairs;
  base::SplitStringIntoKeyValuePairs(google_accounts_signin_value, '=', ',',
                                     &pairs);
  std::string session_index;
  std::string email;
  for (size_t i = 0; i < pairs.size(); ++i) {
    const std::pair<std::string, std::string>& pair = pairs[i];
    const std::string& key = pair.first;
    const std::string& value = pair.second;
    if (key == "email") {
      TrimString(value, "\"", &email);
    } else if (key == "sessionindex") {
      session_index = value;
    }
  }

  if (!email.empty())
    io_data->set_reverse_autologin_pending_email(email);

  if (!email.empty() || !session_index.empty()) {
    VLOG(1) << "OneClickSigninHelper::ShowInfoBarIfPossible:"
            << " email=" << email
            << " sessionindex=" << session_index;
  }

  AutoAccept auto_accept = AUTO_ACCEPT_NONE;
  SyncPromoUI::Source source = SyncPromoUI::SOURCE_UNKNOWN;
  GURL continue_url;
  std::vector<std::string> tokens;
  base::SplitString(google_chrome_signin_value, ',', &tokens);
  for (size_t i = 0; i < tokens.size(); ++i) {
    const std::string& token = tokens[i];
    if (token == "accepted") {
      auto_accept = AUTO_ACCEPT_ACCEPTED;
    } else if (token == "configure") {
      auto_accept = AUTO_ACCEPT_CONFIGURE;
    } else if (token == "rejected-for-profile") {
      auto_accept = AUTO_ACCEPT_REJECTED_FOR_PROFILE;
    }
  }

  source = GetSigninSource(request->url(), &continue_url);
  if (source != SyncPromoUI::SOURCE_UNKNOWN)
    auto_accept = AUTO_ACCEPT_EXPLICIT;

  if (auto_accept != AUTO_ACCEPT_NONE) {
    VLOG(1) << "OneClickSigninHelper::ShowInfoBarIfPossible:"
            << " auto_accept=" << auto_accept;
  }

  if (session_index.empty() && email.empty() &&
      auto_accept == AUTO_ACCEPT_NONE && !continue_url.is_valid()) {
    return;
  }

  content::BrowserThread::PostTask(
      content::BrowserThread::UI, FROM_HERE,
      base::Bind(&OneClickSigninHelper::ShowInfoBarUIThread, session_index,
                 email, auto_accept, source, continue_url, child_id, route_id));
}

void OneClickSigninSyncStarter::SigninDialogDelegate::OnCancelSignin() {
  sync_starter_->CancelSigninAndDelete();
}

void OneClickSigninSyncStarter::CompleteInitForNewProfile(
    chrome::HostDesktopType desktop_type,
    Profile* new_profile,
    Profile::CreateStatus status) {
  DCHECK_NE(profile_, new_profile);

  switch (status) {
    case Profile::CREATE_STATUS_LOCAL_FAIL: {
      NOTREACHED() << "Error creating new profile";
      CancelSigninAndDelete();
      return;
    }
    case Profile::CREATE_STATUS_CREATED: {
      break;
    }
    case Profile::CREATE_STATUS_INITIALIZED: {
      SigninManager* old_signin_manager =
          SigninManagerFactory::GetForProfile(profile_);
      SigninManager* new_signin_manager =
          SigninManagerFactory::GetForProfile(new_profile);
      DCHECK(!old_signin_manager->GetUsernameForAuthInProgress().empty());
      DCHECK(old_signin_manager->GetAuthenticatedUsername().empty());
      DCHECK(new_signin_manager->GetAuthenticatedUsername().empty());
      DCHECK(policy_client_);

      new_signin_manager->CopyCredentialsFrom(*old_signin_manager);
      FinishProfileSyncServiceSetup();
      Initialize(new_profile, NULL);
      DCHECK_EQ(profile_, new_profile);

      old_signin_manager->SignOut();

      LoadPolicyWithCachedClient();

      ProfileManager::FindOrCreateNewWindowForProfile(
        new_profile,
        chrome::startup::IS_PROCESS_STARTUP,
        chrome::startup::IS_FIRST_RUN,
        desktop_type,
        false);
      break;
    }
    case Profile::CREATE_STATUS_REMOTE_FAIL:
    case Profile::CREATE_STATUS_CANCELED:
    case Profile::MAX_CREATE_STATUS: {
      NOTREACHED() << "Invalid profile creation status";
      CancelSigninAndDelete();
      return;
    }
  }
}

void OneClickSigninSyncStarter::SigninDialogDelegate::OnSigninWithNewProfile() {
  sync_starter_->CreateNewSignedInProfile();
}

bool OneClickSigninHelper::OnMessageReceived(const IPC::Message& message) {
  bool handled = true;
  IPC_BEGIN_MESSAGE_MAP(OneClickSigninHelper, message)
    IPC_MESSAGE_HANDLER(OneClickSigninHostMsg_FormSubmitted, OnFormSubmitted)
    IPC_MESSAGE_UNHANDLED(handled = false)
  IPC_END_MESSAGE_MAP()

  return handled;
}

void OneClickSigninSyncStarter::OnBrowserRemoved(Browser* browser) {
  if (browser == browser_)
    browser_ = NULL;
}

void CurrentHistoryCleaner::DidStopLoading(
    content::RenderViewHost* render_view_host) {
  content::NavigationController& nc = web_contents()->GetController();
  if (history_index_to_remove_ < nc.GetLastCommittedEntryIndex()) {
    nc.RemoveEntryAtIndex(history_index_to_remove_);
    delete this;  /* success */
  }
}

void OneClickSigninSyncStarter::Initialize(Profile* profile, Browser* browser) {
  DCHECK(profile);
  profile_ = profile;
  browser_ = browser;

  if (browser)
    desktop_type_ = browser->host_desktop_type();

  signin_tracker_.reset(new SigninTracker(profile_, this));

  ProfileSyncService* profile_sync_service = GetProfileSyncService();
  if (profile_sync_service)
    profile_sync_service->SetSetupInProgress(true);

  browser_sync::SyncPrefs sync_prefs(profile_->GetPrefs());
  sync_prefs.SetStartSuppressed(false);
}

void OneClickSigninSyncStarter::FinishProfileSyncServiceSetup() {
  ProfileSyncService* service =
      ProfileSyncServiceFactory::GetForProfile(profile_);
  if (service)
    service->SetSetupInProgress(false);
}

void OneClickSigninSyncStarter::OnRegisteredForPolicy(
    scoped_ptr<policy::CloudPolicyClient> client) {
  SigninManager* signin = SigninManagerFactory::GetForProfile(profile_);
  if (!client.get()) {
    DVLOG(1) << "Policy registration failed";
    ConfirmAndSignin();
    return;
  }

  DCHECK(client->is_registered());
  DVLOG(1) << "Policy registration succeeded: dm_token=" << client->dm_token();

  DCHECK(!policy_client_);
  policy_client_.swap(client);

  EnsureBrowser();
  content::WebContents* web_contents =
      browser_->tab_strip_model()->GetActiveWebContents();
  if (!web_contents) {
    CancelSigninAndDelete();
    return;
  }
  chrome::ShowProfileSigninConfirmationDialog(
      browser_,
      web_contents,
      profile_,
      signin->GetUsernameForAuthInProgress(),
      new SigninDialogDelegate(weak_pointer_factory_.GetWeakPtr()));
}

void OneClickSigninSyncStarter::OnPolicyFetchComplete(bool success) {
  DLOG_IF(ERROR, !success) << "Error fetching policy for user";
  DVLOG_IF(1, success) << "Policy fetch successful - completing signin";
  SigninManagerFactory::GetForProfile(profile_)->CompletePendingSignin();
}
