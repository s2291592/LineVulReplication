void MediaControlTextTrackListElement::defaultEventHandler(Event* event) {
  if (event->type() == EventTypeNames::change) {
    Node* target = event->target()->toNode();
    if (!target || !target->isElementNode())
      return;

    mediaControls().disableShowingTextTracks();
    int trackIndex =
        toElement(target)->getIntegralAttribute(trackIndexAttrName());
    if (trackIndex != trackIndexOffValue) {
      DCHECK_GE(trackIndex, 0);
      mediaControls().showTextTrackAtIndex(trackIndex);
      mediaElement().disableAutomaticTextTrackSelection();
    }

    event->setDefaultHandled();
  }
  MediaControlDivElement::defaultEventHandler(event);
}

MediaControlPlayButtonElement::getOverflowStringName() {
  if (mediaElement().paused())
    return WebLocalizedString::OverflowMenuPlay;
  return WebLocalizedString::OverflowMenuPause;
}

bool MediaControlVolumeSliderElement::willRespondToMouseClickEvents() {
  if (!isConnected() || !document().isActive())
    return false;

  return MediaControlInputElement::willRespondToMouseClickEvents();
}

 Element* elementFromCenter(Element& element) {
  ClientRect* clientRect = element.getBoundingClientRect();
  int centerX =
      static_cast<int>((clientRect->left() + clientRect->right()) / 2);
  int centerY =
      static_cast<int>((clientRect->top() + clientRect->bottom()) / 2);

  return element.document().elementFromPoint(centerX, centerY);
}

bool MediaControlTimelineElement::keepEventInNode(Event* event) {
  return isUserInteractionEventForSlider(event, layoutObject());
}

void MediaControlPanelElement::transitionTimerFired(TimerBase*) {
  if (!m_opaque)
    setIsWanted(false);

  stopTimer();
}

MediaControlTextTrackListElement::MediaControlTextTrackListElement(
    MediaControls& mediaControls)
    : MediaControlDivElement(mediaControls, MediaTextTrackList) {}

MediaControlMuteButtonElement::MediaControlMuteButtonElement(
    MediaControls& mediaControls)
    : MediaControlInputElement(mediaControls, MediaMuteButton) {}

MediaControlTimelineElement::MediaControlTimelineElement(
    MediaControls& mediaControls)
    : MediaControlInputElement(mediaControls, MediaSlider) {}

bool MediaControlCastButtonElement::keepEventInNode(Event* event) {
  return isUserInteractionEvent(event);
}

MediaControlFullscreenButtonElement::MediaControlFullscreenButtonElement(
    MediaControls& mediaControls)
    : MediaControlInputElement(mediaControls, MediaEnterFullscreenButton) {}

void MediaControlTextTrackListElement::setVisible(bool visible) {
  if (visible) {
    setIsWanted(true);
    refreshTextTrackListMenu();
  } else {
    setIsWanted(false);
  }
}

void MediaControlToggleClosedCaptionsButtonElement::defaultEventHandler(
    Event* event) {
  if (event->type() == EventTypeNames::click) {
    if (mediaElement().textTracks()->length() == 1) {
      if (mediaElement().textTracks()->hasShowingTracks()) {
        mediaControls().disableShowingTextTracks();
      } else {
        mediaControls().showTextTrackAtIndex(0);
      }
    } else {
      mediaControls().toggleTextTrackList();
    }

    updateDisplayType();
    event->setDefaultHandled();
  }

  MediaControlInputElement::defaultEventHandler(event);
}

void MediaControlPanelElement::startTimer() {
  stopTimer();

  m_transitionTimer.startOneShot(fadeOutDuration, BLINK_FROM_HERE);
}

void MediaControlTimelineElement::setPosition(double currentTime) {
  setValue(String::number(currentTime));

  if (LayoutObject* layoutObject = this->layoutObject())
    layoutObject->setShouldDoFullPaintInvalidation();
}

void MediaControlPanelElement::makeTransparent() {
  if (!m_opaque)
    return;

  setInlineStyleProperty(CSSPropertyOpacity, 0.0,
                         CSSPrimitiveValue::UnitType::Number);

  m_opaque = false;
  startTimer();
}

MediaControlVolumeSliderElement* MediaControlVolumeSliderElement::create(
    MediaControls& mediaControls) {
  MediaControlVolumeSliderElement* slider =
      new MediaControlVolumeSliderElement(mediaControls);
  slider->ensureUserAgentShadowRoot();
  slider->setType(InputTypeNames::range);
  slider->setAttribute(stepAttr, "any");
  slider->setAttribute(maxAttr, "1");
  slider->setShadowPseudoId(
      AtomicString("-webkit-media-controls-volume-slider"));
  return slider;
 }

MediaControlTextTrackListElement* MediaControlTextTrackListElement::create(
    MediaControls& mediaControls) {
  MediaControlTextTrackListElement* element =
      new MediaControlTextTrackListElement(mediaControls);
  element->setShadowPseudoId(
      AtomicString("-internal-media-controls-text-track-list"));
  element->setIsWanted(false);
  return element;
}

void MediaControlTextTrackListElement::refreshTextTrackListMenu() {
  if (!mediaElement().hasClosedCaptions() ||
      !mediaElement().textTracksAreReady())
    return;

  EventDispatchForbiddenScope::AllowUserAgentEvents allowEvents;
  removeChildren(OmitSubtreeModifiedEvent);

  appendChild(createTextTrackListItem(nullptr));

  TextTrackList* trackList = mediaElement().textTracks();
  for (unsigned i = 0; i < trackList->length(); i++) {
    TextTrack* track = trackList->anonymousIndexedGetter(i);
    if (!track->canBeRendered())
      continue;
    appendChild(createTextTrackListItem(track));
  }
}

void MediaControlFullscreenButtonElement::defaultEventHandler(Event* event) {
  if (event->type() == EventTypeNames::click) {
    if (mediaElement().isFullscreen()) {
      Platform::current()->recordAction(
          UserMetricsAction("Media.Controls.ExitFullscreen"));
      mediaControls().exitFullscreen();
    } else {
      Platform::current()->recordAction(
          UserMetricsAction("Media.Controls.EnterFullscreen"));
      mediaControls().enterFullscreen();
    }
    event->setDefaultHandled();
  }
  MediaControlInputElement::defaultEventHandler(event);
}

bool hasDuplicateLabel(TextTrack* currentTrack) {
  DCHECK(currentTrack);
  TextTrackList* trackList = currentTrack->trackList();
  String currentTrackLabel = currentTrack->label();
  for (unsigned i = 0; i < trackList->length(); i++) {
    TextTrack* track = trackList->anonymousIndexedGetter(i);
    if (currentTrack != track && currentTrackLabel == track->label())
      return true;
  }
  return false;
}

void MediaControlMuteButtonElement::defaultEventHandler(Event* event) {
  if (event->type() == EventTypeNames::click) {
    if (mediaElement().muted())
      Platform::current()->recordAction(
          UserMetricsAction("Media.Controls.Unmute"));
    else
      Platform::current()->recordAction(
          UserMetricsAction("Media.Controls.Mute"));

    mediaElement().setMuted(!mediaElement().muted());
    event->setDefaultHandled();
  }

  MediaControlInputElement::defaultEventHandler(event);
}

MediaControlFullscreenButtonElement::getOverflowStringName() {
  if (mediaElement().isFullscreen())
    return WebLocalizedString::OverflowMenuExitFullscreen;
  return WebLocalizedString::OverflowMenuEnterFullscreen;
}

Element* MediaControlTextTrackListElement::createTextTrackListItem(
    TextTrack* track) {
  int trackIndex = track ? track->trackIndex() : trackIndexOffValue;
  HTMLLabelElement* trackItem = HTMLLabelElement::create(document());
  trackItem->setShadowPseudoId(
      AtomicString("-internal-media-controls-text-track-list-item"));
  HTMLInputElement* trackItemInput =
      HTMLInputElement::create(document(), false);
  trackItemInput->setShadowPseudoId(
      AtomicString("-internal-media-controls-text-track-list-item-input"));
  trackItemInput->setType(InputTypeNames::checkbox);
  trackItemInput->setIntegralAttribute(trackIndexAttrName(), trackIndex);
  if (!mediaElement().textTracksVisible()) {
    if (!track)
      trackItemInput->setChecked(true);
  } else {
    if (track && track->mode() == TextTrack::showingKeyword())
      trackItemInput->setChecked(true);
  }

  trackItem->appendChild(trackItemInput);
  String trackLabel = getTextTrackLabel(track);
  trackItem->appendChild(Text::create(document(), trackLabel));
  if (track && (track->label().isEmpty() || hasDuplicateLabel(track))) {
    HTMLSpanElement* trackKindMarker = HTMLSpanElement::create(document());
    if (track->kind() == track->captionsKeyword()) {
      trackKindMarker->setShadowPseudoId(AtomicString(
          "-internal-media-controls-text-track-list-kind-captions"));
    } else {
      DCHECK_EQ(track->kind(), track->subtitlesKeyword());
      trackKindMarker->setShadowPseudoId(AtomicString(
          "-internal-media-controls-text-track-list-kind-subtitles"));
    }
    trackItem->appendChild(trackKindMarker);
  }
  return trackItem;
}

bool isUserInteractionEvent(Event* event) {
  const AtomicString& type = event->type();
  return type == EventTypeNames::mousedown || type == EventTypeNames::mouseup ||
         type == EventTypeNames::click || type == EventTypeNames::dblclick ||
         event->isKeyboardEvent() || event->isTouchEvent();
}

MediaControlOverflowMenuListElement::create(MediaControls& mediaControls) {
  MediaControlOverflowMenuListElement* element =
      new MediaControlOverflowMenuListElement(mediaControls);
  element->setIsWanted(false);
  element->setShadowPseudoId(
      AtomicString("-internal-media-controls-overflow-menu-list"));
  return element;
}

MediaControlPlayButtonElement* MediaControlPlayButtonElement::create(
    MediaControls& mediaControls) {
  MediaControlPlayButtonElement* button =
      new MediaControlPlayButtonElement(mediaControls);
  button->ensureUserAgentShadowRoot();
  button->setType(InputTypeNames::button);
  button->setShadowPseudoId(AtomicString("-webkit-media-controls-play-button"));
  return button;
}

void MediaControlVolumeSliderElement::setVolume(double volume) {
  if (value().toDouble() == volume)
    return;

  setValue(String::number(volume));
  if (LayoutObject* layoutObject = this->layoutObject())
    layoutObject->setShouldDoFullPaintInvalidation();
}

MediaControlVolumeSliderElement::MediaControlVolumeSliderElement(
    MediaControls& mediaControls)
    : MediaControlInputElement(mediaControls, MediaVolumeSlider) {}

MediaControlDownloadButtonElement::getOverflowStringName() {
  return WebLocalizedString::OverflowMenuDownload;
}

void MediaControlDownloadButtonElement::defaultEventHandler(Event* event) {
  const KURL& url = mediaElement().currentSrc();
  if (event->type() == EventTypeNames::click &&
      !(url.isNull() || url.isEmpty())) {
    Platform::current()->recordAction(
        UserMetricsAction("Media.Controls.Download"));
    if (!m_anchor) {
      HTMLAnchorElement* anchor = HTMLAnchorElement::create(document());
      anchor->setAttribute(HTMLNames::downloadAttr, "");
      m_anchor = anchor;
    }
    m_anchor->setURL(url);
    m_anchor->dispatchSimulatedClick(event);
  }
  MediaControlInputElement::defaultEventHandler(event);
}

void MediaControlPanelElement::makeOpaque() {
  if (m_opaque)
    return;

  setInlineStyleProperty(CSSPropertyOpacity, 1.0,
                         CSSPrimitiveValue::UnitType::Number);
  m_opaque = true;

  if (m_isDisplayed) {
    setIsWanted(true);
    didBecomeVisible();
  }
}

MediaControlOverlayPlayButtonElement::MediaControlOverlayPlayButtonElement(
    MediaControls& mediaControls)
    : MediaControlInputElement(mediaControls, MediaOverlayPlayButton) {}

MediaControlCurrentTimeDisplayElement::MediaControlCurrentTimeDisplayElement(
    MediaControls& mediaControls)
    : MediaControlTimeDisplayElement(mediaControls, MediaCurrentTimeDisplay) {}

MediaControlOverflowMenuButtonElement::MediaControlOverflowMenuButtonElement(
    MediaControls& mediaControls)
    : MediaControlInputElement(mediaControls, MediaOverflowButton) {}

MediaControlPanelEnclosureElement::MediaControlPanelEnclosureElement(
    MediaControls& mediaControls)
    : MediaControlDivElement(mediaControls, MediaControlsPanel) {}

MediaControlDownloadButtonElement* MediaControlDownloadButtonElement::create(
    MediaControls& mediaControls) {
  MediaControlDownloadButtonElement* button =
      new MediaControlDownloadButtonElement(mediaControls);
  button->ensureUserAgentShadowRoot();
  button->setType(InputTypeNames::button);
  button->setShadowPseudoId(
      AtomicString("-internal-media-controls-download-button"));
  button->setIsWanted(false);
  return button;
}

MediaControlDownloadButtonElement::MediaControlDownloadButtonElement(
    MediaControls& mediaControls)
    : MediaControlInputElement(mediaControls, MediaDownloadButton) {}

void MediaControlPanelElement::didBecomeVisible() {
  DCHECK(m_isDisplayed && m_opaque);
  mediaElement().mediaControlsDidBecomeVisible();
}

MediaControlOverlayEnclosureElement::MediaControlOverlayEnclosureElement(
    MediaControls& mediaControls)
    : MediaControlDivElement(mediaControls, MediaControlsPanel) {}

MediaControlOverflowMenuButtonElement::create(MediaControls& mediaControls) {
  MediaControlOverflowMenuButtonElement* button =
      new MediaControlOverflowMenuButtonElement(mediaControls);
  button->ensureUserAgentShadowRoot();
  button->setType(InputTypeNames::button);
  button->setShadowPseudoId(
      AtomicString("-internal-media-controls-overflow-button"));
  button->setIsWanted(false);
  return button;
}

void MediaControlCastButtonElement::defaultEventHandler(Event* event) {
  if (event->type() == EventTypeNames::click) {
    if (m_isOverlayButton)
      Platform::current()->recordAction(
          UserMetricsAction("Media.Controls.CastOverlay"));
    else
      Platform::current()->recordAction(
          UserMetricsAction("Media.Controls.Cast"));

    if (m_isOverlayButton && !m_clickUseCounted) {
      m_clickUseCounted = true;
      recordMetrics(CastOverlayMetrics::Clicked);
    }
    if (mediaElement().isPlayingRemotely()) {
      mediaElement().requestRemotePlaybackControl();
    } else {
      mediaElement().requestRemotePlayback();
    }
  }
  MediaControlInputElement::defaultEventHandler(event);
}

MediaControlToggleClosedCaptionsButtonElement::create(
    MediaControls& mediaControls) {
  MediaControlToggleClosedCaptionsButtonElement* button =
      new MediaControlToggleClosedCaptionsButtonElement(mediaControls);
  button->ensureUserAgentShadowRoot();
  button->setType(InputTypeNames::button);
  button->setShadowPseudoId(
      AtomicString("-webkit-media-controls-toggle-closed-captions-button"));
  button->setIsWanted(false);
  return button;
}

bool MediaControlPanelElement::keepEventInNode(Event* event) {
  return isUserInteractionEvent(event);
}

void MediaControlPanelElement::setIsDisplayed(bool isDisplayed) {
  if (m_isDisplayed == isDisplayed)
    return;

  m_isDisplayed = isDisplayed;
  if (m_isDisplayed && m_opaque)
    didBecomeVisible();
}

void MediaControlTimelineElement::defaultEventHandler(Event* event) {
if (event->isMouseEvent() &&
toMouseEvent(event)->button() !=
static_cast<short>(WebPointerProperties::Button::Left))
return;

if (!isConnected() || !document().isActive())
return;

if (event->type() == EventTypeNames::mousedown) {
Platform::current()->recordAction(
UserMetricsAction("Media.Controls.ScrubbingBegin"));
mediaControls().beginScrubbing();
}

if (event->type() == EventTypeNames::mouseup) {
Platform::current()->recordAction(
UserMetricsAction("Media.Controls.ScrubbingEnd"));
mediaControls().endScrubbing();
}

MediaControlInputElement::defaultEventHandler(event);

  if (event->type() == EventTypeNames::mouseover ||
      event->type() == EventTypeNames::mouseout ||
      event->type() == EventTypeNames::mousemove)
return;

double time = value().toDouble();
  if (event->type() == EventTypeNames::input) {
    // FIXME: This will need to take the timeline offset into consideration
    // once that concept is supported, see https://crbug.com/312699
    if (mediaElement().seekable()->contain(time))
      mediaElement().setCurrentTime(time);
  }

LayoutSliderItem slider = LayoutSliderItem(toLayoutSlider(layoutObject()));
if (!slider.isNull() && slider.inDragMode())
mediaControls().updateCurrentTimeDisplay();
}

MediaControlOverlayPlayButtonElement::create(MediaControls& mediaControls) {
  MediaControlOverlayPlayButtonElement* button =
      new MediaControlOverlayPlayButtonElement(mediaControls);
  button->ensureUserAgentShadowRoot();
  button->setType(InputTypeNames::button);
  button->setShadowPseudoId(
      AtomicString("-webkit-media-controls-overlay-play-button"));
  return button;
}

void MediaControlPlayButtonElement::updateDisplayType() {
  setDisplayType(mediaElement().paused() ? MediaPlayButton : MediaPauseButton);
  updateOverflowString();
}

MediaControlCurrentTimeDisplayElement::create(MediaControls& mediaControls) {
  MediaControlCurrentTimeDisplayElement* element =
      new MediaControlCurrentTimeDisplayElement(mediaControls);
  element->setShadowPseudoId(
      AtomicString("-webkit-media-controls-current-time-display"));
  return element;
}

void MediaControlMuteButtonElement::updateDisplayType() {
  setDisplayType((mediaElement().muted() || mediaElement().volume() == 0)
                     ? MediaUnMuteButton
                     : MediaMuteButton);
  updateOverflowString();
}

void MediaControlTimelineElement::setDuration(double duration) {
  setFloatingPointAttribute(maxAttr, std::isfinite(duration) ? duration : 0);

  if (LayoutObject* layoutObject = this->layoutObject())
    layoutObject->setShouldDoFullPaintInvalidation();
}

MediaControlCastButtonElement* MediaControlCastButtonElement::create(
    MediaControls& mediaControls,
    bool isOverlayButton) {
  MediaControlCastButtonElement* button =
      new MediaControlCastButtonElement(mediaControls, isOverlayButton);
  button->ensureUserAgentShadowRoot();
  button->setType(InputTypeNames::button);
  return button;
}

void MediaControlCastButtonElement::recordMetrics(CastOverlayMetrics metric) {
  DCHECK(m_isOverlayButton);
  DEFINE_STATIC_LOCAL(
      EnumerationHistogram, overlayHistogram,
      ("Cast.Sender.Overlay", static_cast<int>(CastOverlayMetrics::Count)));
  overlayHistogram.count(static_cast<int>(metric));
}

MediaControlMuteButtonElement* MediaControlMuteButtonElement::create(
    MediaControls& mediaControls) {
  MediaControlMuteButtonElement* button =
      new MediaControlMuteButtonElement(mediaControls);
  button->ensureUserAgentShadowRoot();
  button->setType(InputTypeNames::button);
  button->setShadowPseudoId(AtomicString("-webkit-media-controls-mute-button"));
  return button;
}

void MediaControlOverlayPlayButtonElement::updateDisplayType() {
  setIsWanted(mediaElement().shouldShowControls() && mediaElement().paused());
}

MediaControlPanelElement::MediaControlPanelElement(MediaControls& mediaControls)
    : MediaControlDivElement(mediaControls, MediaControlsPanel),
      m_isDisplayed(false),
      m_opaque(true),
      m_transitionTimer(this, &MediaControlPanelElement::transitionTimerFired) {
}

void MediaControlPlayButtonElement::defaultEventHandler(Event* event) {
  if (event->type() == EventTypeNames::click) {
    if (mediaElement().paused())
      Platform::current()->recordAction(
          UserMetricsAction("Media.Controls.Play"));
    else
      Platform::current()->recordAction(
          UserMetricsAction("Media.Controls.Pause"));

    const String& url = mediaElement().currentSrc().getString();
    if (mediaElement().error() && !HTMLMediaElement::isMediaStreamURL(url) &&
        !HTMLMediaSource::lookup(url))
      mediaElement().load();

    mediaElement().togglePlayState();
    updateDisplayType();
    event->setDefaultHandled();
  }
  MediaControlInputElement::defaultEventHandler(event);
}

MediaControlOverflowMenuListElement::MediaControlOverflowMenuListElement(
    MediaControls& mediaControls)
    : MediaControlDivElement(mediaControls, MediaOverflowList) {}

MediaControlMuteButtonElement::getOverflowStringName() {
  if (mediaElement().muted())
    return WebLocalizedString::OverflowMenuUnmute;
  return WebLocalizedString::OverflowMenuMute;
}

const QualifiedName& trackIndexAttrName() {
  DEFINE_STATIC_LOCAL(QualifiedName, trackIndexAttr,
                      (nullAtom, "data-track-index", nullAtom));
  return trackIndexAttr;
}

void MediaControlCastButtonElement::setIsPlayingRemotely(
    bool isPlayingRemotely) {
  if (isPlayingRemotely) {
    if (m_isOverlayButton) {
      setDisplayType(MediaOverlayCastOnButton);
    } else {
      setDisplayType(MediaCastOnButton);
    }
  } else {
    if (m_isOverlayButton) {
      setDisplayType(MediaOverlayCastOffButton);
    } else {
      setDisplayType(MediaCastOffButton);
    }
  }
  updateOverflowString();
}

MediaControlOverlayEnclosureElement::create(MediaControls& mediaControls) {
  MediaControlOverlayEnclosureElement* enclosure =
      new MediaControlOverlayEnclosureElement(mediaControls);
  enclosure->setShadowPseudoId(
      AtomicString("-webkit-media-controls-overlay-enclosure"));
  return enclosure;
}

void MediaControlVolumeSliderElement::defaultEventHandler(Event* event) {
  if (event->isMouseEvent() &&
      toMouseEvent(event)->button() !=
          static_cast<short>(WebPointerProperties::Button::Left))
    return;
if (!isConnected() || !document().isActive())
return;

MediaControlInputElement::defaultEventHandler(event);

  if (event->type() == EventTypeNames::mouseover ||
      event->type() == EventTypeNames::mouseout ||
      event->type() == EventTypeNames::mousemove)
    return;
if (event->type() == EventTypeNames::mousedown)
Platform::current()->recordAction(
UserMetricsAction("Media.Controls.VolumeChangeBegin"));

if (event->type() == EventTypeNames::mouseup)
Platform::current()->recordAction(
UserMetricsAction("Media.Controls.VolumeChangeEnd"));

  double volume = value().toDouble();
  mediaElement().setVolume(volume);
  mediaElement().setMuted(false);
}

bool MediaControlTimelineElement::willRespondToMouseClickEvents() {
  return isConnected() && document().isActive();
}

void MediaControlPanelElement::defaultEventHandler(Event* event) {
  if (event->type() == EventTypeNames::click) {
    event->setDefaultHandled();
    return;
  }
  HTMLDivElement::defaultEventHandler(event);
}

void MediaControlPanelElement::stopTimer() {
  m_transitionTimer.stop();
}

void MediaControlToggleClosedCaptionsButtonElement::updateDisplayType() {
  bool captionsVisible = mediaElement().textTracksVisible();
  setDisplayType(captionsVisible ? MediaHideClosedCaptionsButton
                                 : MediaShowClosedCaptionsButton);
}

MediaControlTimelineElement* MediaControlTimelineElement::create(
    MediaControls& mediaControls) {
  MediaControlTimelineElement* timeline =
      new MediaControlTimelineElement(mediaControls);
  timeline->ensureUserAgentShadowRoot();
  timeline->setType(InputTypeNames::range);
  timeline->setAttribute(stepAttr, "any");
  timeline->setShadowPseudoId(AtomicString("-webkit-media-controls-timeline"));
  return timeline;
}
