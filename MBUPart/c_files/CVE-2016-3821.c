status_t MediaPlayer::getCurrentPosition(int *msec)
{
    ALOGV("getCurrentPosition");
 Mutex::Autolock _l(mLock);
 if (mPlayer != 0) {
 if (mCurrentPosition >= 0) {
            ALOGV("Using cached seek position: %d", mCurrentPosition);
 *msec = mCurrentPosition;
 return NO_ERROR;
 }
 return mPlayer->getCurrentPosition(msec);
 }
 return INVALID_OPERATION;
}

status_t MediaRecorder::initCheck()
{
 return mMediaRecorder != 0 ? NO_ERROR : NO_INIT;
}

status_t MediaPlayer::reset()
{
    ALOGV("reset");
 Mutex::Autolock _l(mLock);
 return reset_l();
}

void MediaPlayer::notify(int msg, int ext1, int ext2, const Parcel *obj)
{
    ALOGV("message received msg=%d, ext1=%d, ext2=%d", msg, ext1, ext2);
 bool send = true;
 bool locked = false;

 if (mLockThreadId != getThreadId()) {
        mLock.lock();
        locked = true;
 }

 if (!(msg == MEDIA_ERROR && mCurrentState == MEDIA_PLAYER_IDLE) && mPlayer == 0) {
        ALOGV("notify(%d, %d, %d) callback on disconnected mediaplayer", msg, ext1, ext2);
 if (locked) mLock.unlock(); // release the lock when done.
 return;
 }

 switch (msg) {
 case MEDIA_NOP: // interface test message
 break;
 case MEDIA_PREPARED:
        ALOGV("prepared");
        mCurrentState = MEDIA_PLAYER_PREPARED;
 if (mPrepareSync) {
            ALOGV("signal application thread");
            mPrepareSync = false;
            mPrepareStatus = NO_ERROR;
            mSignal.signal();
 }
 break;
 case MEDIA_PLAYBACK_COMPLETE:
        ALOGV("playback complete");
 if (mCurrentState == MEDIA_PLAYER_IDLE) {
            ALOGE("playback complete in idle state");
 }
 if (!mLoop) {
            mCurrentState = MEDIA_PLAYER_PLAYBACK_COMPLETE;
 }
 break;
 case MEDIA_ERROR:
        ALOGE("error (%d, %d)", ext1, ext2);
        mCurrentState = MEDIA_PLAYER_STATE_ERROR;
 if (mPrepareSync)
 {
            ALOGV("signal application thread");
            mPrepareSync = false;
            mPrepareStatus = ext1;
            mSignal.signal();
            send = false;
 }
 break;
 case MEDIA_INFO:
 if (ext1 != MEDIA_INFO_VIDEO_TRACK_LAGGING) {
            ALOGW("info/warning (%d, %d)", ext1, ext2);
 }
 break;
 case MEDIA_SEEK_COMPLETE:
        ALOGV("Received seek complete");
 if (mSeekPosition != mCurrentPosition) {
            ALOGV("Executing queued seekTo(%d)", mSeekPosition);
            mSeekPosition = -1;
            seekTo_l(mCurrentPosition);
 }
 else {
            ALOGV("All seeks complete - return to regularly scheduled program");
            mCurrentPosition = mSeekPosition = -1;
 }
 break;
 case MEDIA_BUFFERING_UPDATE:
        ALOGV("buffering %d", ext1);
 break;
 case MEDIA_SET_VIDEO_SIZE:
        ALOGV("New video size %d x %d", ext1, ext2);
        mVideoWidth = ext1;
        mVideoHeight = ext2;
 break;
 case MEDIA_TIMED_TEXT:
        ALOGV("Received timed text message");
 break;
 case MEDIA_SUBTITLE_DATA:
        ALOGV("Received subtitle data message");
 break;
 case MEDIA_META_DATA:
        ALOGV("Received timed metadata message");
 break;
 default:
        ALOGV("unrecognized message: (%d, %d, %d)", msg, ext1, ext2);
 break;
 }

    sp<MediaPlayerListener> listener = mListener;
 if (locked) mLock.unlock();

 if ((listener != 0) && send) {
 Mutex::Autolock _l(mNotifyLock);
        ALOGV("callback application");
        listener->notify(msg, ext1, ext2, obj);
        ALOGV("back from callback");
 }
}

status_t MediaPlayer::setAudioStreamType(audio_stream_type_t type)
{
    ALOGV("MediaPlayer::setAudioStreamType");
 Mutex::Autolock _l(mLock);
 if (mStreamType == type) return NO_ERROR;
 if (mCurrentState & ( MEDIA_PLAYER_PREPARED | MEDIA_PLAYER_STARTED |
                MEDIA_PLAYER_PAUSED | MEDIA_PLAYER_PLAYBACK_COMPLETE ) ) {
        ALOGE("setAudioStream called in state %d", mCurrentState);
 return INVALID_OPERATION;
 }
    mStreamType = type;
 return OK;
}

status_t MediaRecorder::release()
{
    ALOGV("release");
 if (mMediaRecorder != NULL) {
 return mMediaRecorder->release();
 }
 return INVALID_OPERATION;
}

status_t MediaPlayer::stop()
{
    ALOGV("stop");
 Mutex::Autolock _l(mLock);
 if (mCurrentState & MEDIA_PLAYER_STOPPED) return NO_ERROR;
 if ( (mPlayer != 0) && ( mCurrentState & ( MEDIA_PLAYER_STARTED | MEDIA_PLAYER_PREPARED |
                    MEDIA_PLAYER_PAUSED | MEDIA_PLAYER_PLAYBACK_COMPLETE ) ) ) {
 status_t ret = mPlayer->stop();
 if (ret != NO_ERROR) {
            mCurrentState = MEDIA_PLAYER_STATE_ERROR;
 } else {
            mCurrentState = MEDIA_PLAYER_STOPPED;
 }
 return ret;
 }
    ALOGE("stop called in state %d", mCurrentState);
 return INVALID_OPERATION;
}

status_t MediaPlayer::setSyncSettings(const AVSyncSettings& sync, float videoFpsHint)
{
    ALOGV("setSyncSettings: %u %u %f %f",
            sync.mSource, sync.mAudioAdjustMode, sync.mTolerance, videoFpsHint);
 Mutex::Autolock _l(mLock);
 if (mPlayer == 0) return INVALID_OPERATION;
 return mPlayer->setSyncSettings(sync, videoFpsHint);
}

int MediaPlayer::getAudioSessionId()
{
 Mutex::Autolock _l(mLock);
 return mAudioSessionId;
}

IMediaDeathNotifier::DeathNotifier::~DeathNotifier()
{
    ALOGV("DeathNotifier::~DeathNotifier");
 Mutex::Autolock _l(sServiceLock);
    sObitRecipients.clear();
 if (sMediaPlayerService != 0) {
 IInterface::asBinder(sMediaPlayerService)->unlinkToDeath(this);
 }
}

status_t MediaRecorder::setInputSurface(const sp<PersistentSurface>& surface)
{
    ALOGV("setInputSurface");
 if (mMediaRecorder == NULL) {
        ALOGE("media recorder is not initialized yet");
 return INVALID_OPERATION;
 }
 bool isInvalidState = (mCurrentState &
 (MEDIA_RECORDER_PREPARED |
                            MEDIA_RECORDER_RECORDING));
 if (isInvalidState) {
        ALOGE("setInputSurface is called in an invalid state: %d", mCurrentState);
 return INVALID_OPERATION;
 }

 return mMediaRecorder->setInputSurface(surface->getBufferConsumer());
}

status_t MediaPlayer::pause()
{
    ALOGV("pause");
 Mutex::Autolock _l(mLock);
 if (mCurrentState & (MEDIA_PLAYER_PAUSED|MEDIA_PLAYER_PLAYBACK_COMPLETE))
 return NO_ERROR;
 if ((mPlayer != 0) && (mCurrentState & MEDIA_PLAYER_STARTED)) {
 status_t ret = mPlayer->pause();
 if (ret != NO_ERROR) {
            mCurrentState = MEDIA_PLAYER_STATE_ERROR;
 } else {
            mCurrentState = MEDIA_PLAYER_PAUSED;
 }
 return ret;
 }
    ALOGE("pause called in state %d", mCurrentState);
 return INVALID_OPERATION;
}

status_t MediaRecorder::setVideoSize(int width, int height)
{
    ALOGV("setVideoSize(%d, %d)", width, height);
 if (mMediaRecorder == NULL) {
        ALOGE("media recorder is not initialized yet");
 return INVALID_OPERATION;
 }
 if (!(mCurrentState & MEDIA_RECORDER_DATASOURCE_CONFIGURED)) {
        ALOGE("setVideoSize called in an invalid state: %d", mCurrentState);
 return INVALID_OPERATION;
 }
 if (!mIsVideoSourceSet) {
        ALOGE("Cannot set video size without setting video source first");
 return INVALID_OPERATION;
 }

 status_t ret = mMediaRecorder->setVideoSize(width, height);
 if (OK != ret) {
        ALOGE("setVideoSize failed: %d", ret);
        mCurrentState = MEDIA_RECORDER_ERROR;
 return ret;
 }

 return ret;
}

status_t MediaPlayer::getParameter(int key, Parcel *reply)
{
    ALOGV("MediaPlayer::getParameter(%d)", key);
 Mutex::Autolock _l(mLock);
 if (mPlayer != NULL) {
 return  mPlayer->getParameter(key, reply);
 }
    ALOGV("getParameter: no active player");
 return INVALID_OPERATION;
}

status_t MediaPlayer::setAudioSessionId(int sessionId)
{
    ALOGV("MediaPlayer::setAudioSessionId(%d)", sessionId);
 Mutex::Autolock _l(mLock);
 if (!(mCurrentState & MEDIA_PLAYER_IDLE)) {
        ALOGE("setAudioSessionId called in state %d", mCurrentState);
 return INVALID_OPERATION;
 }
 if (sessionId < 0) {
 return BAD_VALUE;
 }
 if (sessionId != mAudioSessionId) {
 AudioSystem::acquireAudioSessionId(sessionId, -1);
 AudioSystem::releaseAudioSessionId(mAudioSessionId, -1);
        mAudioSessionId = sessionId;
 }
 return NO_ERROR;
}

status_t MediaRecorder::setParameters(const String8& params) {
    ALOGV("setParameters(%s)", params.string());
 if (mMediaRecorder == NULL) {
        ALOGE("media recorder is not initialized yet");
 return INVALID_OPERATION;
 }

 bool isInvalidState = (mCurrentState &
 (MEDIA_RECORDER_PREPARED |
                            MEDIA_RECORDER_RECORDING |
                            MEDIA_RECORDER_ERROR));
 if (isInvalidState) {
        ALOGE("setParameters is called in an invalid state: %d", mCurrentState);
 return INVALID_OPERATION;
 }

 status_t ret = mMediaRecorder->setParameters(params);
 if (OK != ret) {
        ALOGE("setParameters(%s) failed: %d", params.string(), ret);
 }

 return ret;
}

IMediaDeathNotifier::DeathNotifier::binderDied(const wp<IBinder>& who __unused) {
    ALOGW("media server died");

 SortedVector< wp<IMediaDeathNotifier> > list;
 {
 Mutex::Autolock _l(sServiceLock);
        sMediaPlayerService.clear();
 list = sObitRecipients;
 }

 size_t count = list.size();
 for (size_t iter = 0; iter < count; ++iter) {
        sp<IMediaDeathNotifier> notifier = list[iter].promote();
 if (notifier != 0) {
            notifier->died();
 }
 }
}

void MediaPlayer::died()
{
    ALOGV("died");
    notify(MEDIA_ERROR, MEDIA_ERROR_SERVER_DIED, 0);
}

status_t MediaPlayer::getVideoHeight(int *h)
{
    ALOGV("getVideoHeight");
 Mutex::Autolock _l(mLock);
 if (mPlayer == 0) return INVALID_OPERATION;
 *h = mVideoHeight;
 return NO_ERROR;
}

status_t MediaRecorder::setAudioSource(int as)
{
    ALOGV("setAudioSource(%d)", as);
 if (mMediaRecorder == NULL) {
        ALOGE("media recorder is not initialized yet");
 return INVALID_OPERATION;
 }
 if (mCurrentState & MEDIA_RECORDER_IDLE) {
        ALOGV("Call init() since the media recorder is not initialized yet");
 status_t ret = init();
 if (OK != ret) {
 return ret;
 }
 }
 if (mIsAudioSourceSet) {
        ALOGE("audio source has already been set");
 return INVALID_OPERATION;
 }
 if (!(mCurrentState & MEDIA_RECORDER_INITIALIZED)) {
        ALOGE("setAudioSource called in an invalid state(%d)", mCurrentState);
 return INVALID_OPERATION;
 }

 status_t ret = mMediaRecorder->setAudioSource(as);
 if (OK != ret) {
        ALOGV("setAudioSource failed: %d", ret);
        mCurrentState = MEDIA_RECORDER_ERROR;
 return ret;
 }
    mIsAudioSourceSet = true;
 return ret;
}

status_t MediaRecorder::setVideoEncoder(int ve)
{
    ALOGV("setVideoEncoder(%d)", ve);
 if (mMediaRecorder == NULL) {
        ALOGE("media recorder is not initialized yet");
 return INVALID_OPERATION;
 }
 if (!mIsVideoSourceSet) {
        ALOGE("try to set the video encoder without setting the video source first");
 return INVALID_OPERATION;
 }
 if (mIsVideoEncoderSet) {
        ALOGE("video encoder has already been set");
 return INVALID_OPERATION;
 }
 if (!(mCurrentState & MEDIA_RECORDER_DATASOURCE_CONFIGURED)) {
        ALOGE("setVideoEncoder called in an invalid state(%d)", mCurrentState);
 return INVALID_OPERATION;
 }

 status_t ret = mMediaRecorder->setVideoEncoder(ve);
 if (OK != ret) {
        ALOGV("setVideoEncoder failed: %d", ret);
        mCurrentState = MEDIA_RECORDER_ERROR;
 return ret;
 }
    mIsVideoEncoderSet = true;
 return ret;
}

status_t MediaRecorder::setOutputFormat(int of)
{
    ALOGV("setOutputFormat(%d)", of);
 if (mMediaRecorder == NULL) {
        ALOGE("media recorder is not initialized yet");
 return INVALID_OPERATION;
 }
 if (!(mCurrentState & MEDIA_RECORDER_INITIALIZED)) {
        ALOGE("setOutputFormat called in an invalid state: %d", mCurrentState);
 return INVALID_OPERATION;
 }
 if (mIsVideoSourceSet
 && of >= OUTPUT_FORMAT_AUDIO_ONLY_START //first non-video output format
 && of < OUTPUT_FORMAT_AUDIO_ONLY_END) {
        ALOGE("output format (%d) is meant for audio recording only"
 " and incompatible with video recording", of);
 return INVALID_OPERATION;
 }

 status_t ret = mMediaRecorder->setOutputFormat(of);
 if (OK != ret) {
        ALOGE("setOutputFormat failed: %d", ret);
        mCurrentState = MEDIA_RECORDER_ERROR;
 return ret;
 }
    mCurrentState = MEDIA_RECORDER_DATASOURCE_CONFIGURED;
 return ret;
}

 IMediaDeathNotifier::getMediaPlayerService()
 {
     ALOGV("getMediaPlayerService");
 Mutex::Autolock _l(sServiceLock);
 if (sMediaPlayerService == 0) {
        sp<IServiceManager> sm = defaultServiceManager();
        sp<IBinder> binder;
 do {
            binder = sm->getService(String16("media.player"));
 if (binder != 0) {
 break;
 }
            ALOGW("Media player service not published, waiting...");
            usleep(500000); // 0.5 s
 } while (true);

 if (sDeathNotifier == NULL) {
            sDeathNotifier = new DeathNotifier();
 }
        binder->linkToDeath(sDeathNotifier);
        sMediaPlayerService = interface_cast<IMediaPlayerService>(binder);
 }
    ALOGE_IF(sMediaPlayerService == 0, "no media player service!?");
 return sMediaPlayerService;
}

status_t MediaRecorder::prepare()
{
    ALOGV("prepare");
 if (mMediaRecorder == NULL) {
        ALOGE("media recorder is not initialized yet");
 return INVALID_OPERATION;
 }
 if (!(mCurrentState & MEDIA_RECORDER_DATASOURCE_CONFIGURED)) {
        ALOGE("prepare called in an invalid state: %d", mCurrentState);
 return INVALID_OPERATION;
 }
 if (mIsAudioSourceSet != mIsAudioEncoderSet) {
 if (mIsAudioSourceSet) {
            ALOGE("audio source is set, but audio encoder is not set");
 } else { // must not happen, since setAudioEncoder checks this already
            ALOGE("audio encoder is set, but audio source is not set");
 }
 return INVALID_OPERATION;
 }

 if (mIsVideoSourceSet != mIsVideoEncoderSet) {
 if (mIsVideoSourceSet) {
            ALOGE("video source is set, but video encoder is not set");
 } else { // must not happen, since setVideoEncoder checks this already
            ALOGE("video encoder is set, but video source is not set");
 }
 return INVALID_OPERATION;
 }

 status_t ret = mMediaRecorder->prepare();
 if (OK != ret) {
        ALOGE("prepare failed: %d", ret);
        mCurrentState = MEDIA_RECORDER_ERROR;
 return ret;
 }
    mCurrentState = MEDIA_RECORDER_PREPARED;
 return ret;
}

status_t MediaPlayer::setPlaybackSettings(const AudioPlaybackRate& rate)
{
    ALOGV("setPlaybackSettings: %f %f %d %d",
            rate.mSpeed, rate.mPitch, rate.mFallbackMode, rate.mStretchMode);
 if (rate.mSpeed < 0.f || rate.mPitch < 0.f) {
 return BAD_VALUE;
 }
 Mutex::Autolock _l(mLock);
 if (mPlayer == 0) return INVALID_OPERATION;
 status_t err = mPlayer->setPlaybackSettings(rate);
 if (err == OK) {
 if (rate.mSpeed == 0.f && mCurrentState == MEDIA_PLAYER_STARTED) {
            mCurrentState = MEDIA_PLAYER_PAUSED;
 } else if (rate.mSpeed != 0.f && mCurrentState == MEDIA_PLAYER_PAUSED) {
            mCurrentState = MEDIA_PLAYER_STARTED;
 }
 }
 return err;
}

status_t MediaRecorder::setListener(const sp<MediaRecorderListener>& listener)
{
    ALOGV("setListener");
 Mutex::Autolock _l(mLock);
    mListener = listener;

 return NO_ERROR;
}

status_t MediaRecorder::setVideoFrameRate(int frames_per_second)
{
    ALOGV("setVideoFrameRate(%d)", frames_per_second);
 if (mMediaRecorder == NULL) {
        ALOGE("media recorder is not initialized yet");
 return INVALID_OPERATION;
 }
 if (!(mCurrentState & MEDIA_RECORDER_DATASOURCE_CONFIGURED)) {
        ALOGE("setVideoFrameRate called in an invalid state: %d", mCurrentState);
 return INVALID_OPERATION;
 }
 if (!mIsVideoSourceSet) {
        ALOGE("Cannot set video frame rate without setting video source first");
 return INVALID_OPERATION;
 }

 status_t ret = mMediaRecorder->setVideoFrameRate(frames_per_second);
 if (OK != ret) {
        ALOGE("setVideoFrameRate failed: %d", ret);
        mCurrentState = MEDIA_RECORDER_ERROR;
 return ret;
 }
 return ret;
}

status_t MediaPlayer::getMetadata(bool update_only, bool apply_filter, Parcel *metadata)
{
    ALOGD("getMetadata");
 Mutex::Autolock lock(mLock);
 if (mPlayer == NULL) {
 return NO_INIT;
 }
 return mPlayer->getMetadata(update_only, apply_filter, metadata);
}

MediaRecorder::MediaRecorder(const String16& opPackageName) : mSurfaceMediaSource(NULL)

{
ALOGV("constructor");

    const sp<IMediaPlayerService>& service(getMediaPlayerService());
if (service != NULL) {
mMediaRecorder = service->createMediaRecorder(opPackageName);
}
if (mMediaRecorder != NULL) {
mCurrentState = MEDIA_RECORDER_IDLE;
}


doCleanUp();
}

status_t MediaPlayer::setDataSource(int fd, int64_t offset, int64_t length)

{
ALOGV("setDataSource(%d, %" PRId64 ", %" PRId64 ")", fd, offset, length);
status_t err = UNKNOWN_ERROR;
    const sp<IMediaPlayerService>& service(getMediaPlayerService());
if (service != 0) {
sp<IMediaPlayer> player(service->create(this, mAudioSessionId));
if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||
(NO_ERROR != player->setDataSource(fd, offset, length))) {
player.clear();
}
err = attachNewPlayer(player);
}
return err;
}

status_t MediaPlayer::doSetRetransmitEndpoint(const sp<IMediaPlayer>& player) {
 Mutex::Autolock _l(mLock);

 if (player == NULL) {
 return UNKNOWN_ERROR;
 }

 if (mRetransmitEndpointValid) {
 return player->setRetransmitEndpoint(&mRetransmitEndpoint);
 }

 return OK;
}

status_t MediaRecorder::init()
{
    ALOGV("init");
 if (mMediaRecorder == NULL) {
        ALOGE("media recorder is not initialized yet");
 return INVALID_OPERATION;
 }
 if (!(mCurrentState & MEDIA_RECORDER_IDLE)) {
        ALOGE("init called in an invalid state(%d)", mCurrentState);
 return INVALID_OPERATION;
 }

 status_t ret = mMediaRecorder->init();
 if (OK != ret) {
        ALOGV("init failed: %d", ret);
        mCurrentState = MEDIA_RECORDER_ERROR;
 return ret;
 }

    ret = mMediaRecorder->setListener(this);
 if (OK != ret) {
        ALOGV("setListener failed: %d", ret);
        mCurrentState = MEDIA_RECORDER_ERROR;
 return ret;
 }

    mCurrentState = MEDIA_RECORDER_INITIALIZED;
 return ret;
}

bool MediaPlayer::isLooping() {
    ALOGV("isLooping");
 Mutex::Autolock _l(mLock);
 if (mPlayer != 0) {
 return mLoop;
 }
    ALOGV("isLooping: no active player");
 return false;
}

status_t MediaPlayer::getDuration_l(int *msec)
{
    ALOGV("getDuration_l");
 bool isValidState = (mCurrentState & (MEDIA_PLAYER_PREPARED | MEDIA_PLAYER_STARTED |
            MEDIA_PLAYER_PAUSED | MEDIA_PLAYER_STOPPED | MEDIA_PLAYER_PLAYBACK_COMPLETE));
 if (mPlayer != 0 && isValidState) {
 int durationMs;
 status_t ret = mPlayer->getDuration(&durationMs);

 if (ret != OK) {
            durationMs = -1;
            ret = OK;
 }

 if (msec) {
 *msec = durationMs;
 }
 return ret;
 }
    ALOGE("Attempt to call getDuration without a valid mediaplayer");
 return INVALID_OPERATION;
}

status_t MediaPlayer::setDataSource(const sp<IStreamSource> &source)

{
ALOGV("setDataSource");
status_t err = UNKNOWN_ERROR;
    const sp<IMediaPlayerService>& service(getMediaPlayerService());
if (service != 0) {
sp<IMediaPlayer> player(service->create(this, mAudioSessionId));
if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||
(NO_ERROR != player->setDataSource(source))) {
player.clear();
}
err = attachNewPlayer(player);
}
return err;
}

status_t MediaPlayer::invoke(const Parcel& request, Parcel *reply)
{
 Mutex::Autolock _l(mLock);
 const bool hasBeenInitialized =
 (mCurrentState != MEDIA_PLAYER_STATE_ERROR) &&
 ((mCurrentState & MEDIA_PLAYER_IDLE) != MEDIA_PLAYER_IDLE);
 if ((mPlayer != NULL) && hasBeenInitialized) {
        ALOGV("invoke %zu", request.dataSize());
 return  mPlayer->invoke(request, reply);
 }
    ALOGE("invoke failed: wrong state %X", mCurrentState);
 return INVALID_OPERATION;
}

status_t MediaRecorder::setCamera(const sp<ICamera>& camera, const sp<ICameraRecordingProxy>& proxy)
{
    ALOGV("setCamera(%p,%p)", camera.get(), proxy.get());
 if (mMediaRecorder == NULL) {
        ALOGE("media recorder is not initialized yet");
 return INVALID_OPERATION;
 }
 if (!(mCurrentState & MEDIA_RECORDER_IDLE)) {
        ALOGE("setCamera called in an invalid state(%d)", mCurrentState);
 return INVALID_OPERATION;
 }

 status_t ret = mMediaRecorder->setCamera(camera, proxy);
 if (OK != ret) {
        ALOGV("setCamera failed: %d", ret);
        mCurrentState = MEDIA_RECORDER_ERROR;
 return ret;
 }
 return ret;
}

status_t MediaPlayer::setMetadataFilter(const Parcel& filter)
{
    ALOGD("setMetadataFilter");
 Mutex::Autolock lock(mLock);
 if (mPlayer == NULL) {
 return NO_INIT;
 }
 return mPlayer->setMetadataFilter(filter);
}

MediaPlayer::~MediaPlayer()
{
    ALOGV("destructor");
 if (mAudioAttributesParcel != NULL) {
 delete mAudioAttributesParcel;
        mAudioAttributesParcel = NULL;
 }
 AudioSystem::releaseAudioSessionId(mAudioSessionId, -1);
    disconnect();
 IPCThreadState::self()->flushCommands();
}

status_t MediaPlayer::prepare()
{
    ALOGV("prepare");
 Mutex::Autolock _l(mLock);
    mLockThreadId = getThreadId();
 if (mPrepareSync) {
        mLockThreadId = 0;
 return -EALREADY;
 }
    mPrepareSync = true;
 status_t ret = prepareAsync_l();
 if (ret != NO_ERROR) {
        mLockThreadId = 0;
 return ret;
 }

 if (mPrepareSync) {
        mSignal.wait(mLock); // wait for prepare done
        mPrepareSync = false;
 }
    ALOGV("prepare complete - status=%d", mPrepareStatus);
    mLockThreadId = 0;
 return mPrepareStatus;
}

status_t MediaPlayer::seekTo(int msec)
{
    mLockThreadId = getThreadId();
 Mutex::Autolock _l(mLock);
 status_t result = seekTo_l(msec);
    mLockThreadId = 0;

 return result;
}

status_t MediaPlayer::prepareAsync()
{
    ALOGV("prepareAsync");
 Mutex::Autolock _l(mLock);
 return prepareAsync_l();
}

        querySurfaceMediaSourceFromMediaServer()
{
 Mutex::Autolock _l(mLock);
    mSurfaceMediaSource =
            mMediaRecorder->querySurfaceMediaSource();
 if (mSurfaceMediaSource == NULL) {
        ALOGE("SurfaceMediaSource could not be initialized!");
 }
 return mSurfaceMediaSource;
}

status_t MediaPlayer::setAuxEffectSendLevel(float level)
{
    ALOGV("MediaPlayer::setAuxEffectSendLevel(%f)", level);
 Mutex::Autolock _l(mLock);
    mSendLevel = level;
 if (mPlayer != 0) {
 return mPlayer->setAuxEffectSendLevel(level);
 }
 return OK;
}

status_t MediaRecorder::reset()
{
    ALOGV("reset");
 if (mMediaRecorder == NULL) {
        ALOGE("media recorder is not initialized yet");
 return INVALID_OPERATION;
 }

    doCleanUp();
 status_t ret = UNKNOWN_ERROR;
 switch (mCurrentState) {
 case MEDIA_RECORDER_IDLE:
            ret = OK;
 break;

 case MEDIA_RECORDER_RECORDING:
 case MEDIA_RECORDER_DATASOURCE_CONFIGURED:
 case MEDIA_RECORDER_PREPARED:
 case MEDIA_RECORDER_ERROR: {
            ret = doReset();
 if (OK != ret) {
 return ret; // No need to continue
 }
 } // Intentional fall through
 case MEDIA_RECORDER_INITIALIZED:
            ret = close();
 break;

 default: {
            ALOGE("Unexpected non-existing state: %d", mCurrentState);
 break;
 }
 }
 return ret;
}

status_t MediaPlayer::setNextMediaPlayer(const sp<MediaPlayer>& next) {
 if (mPlayer == NULL) {
 return NO_INIT;
 }

 if (next != NULL && !(next->mCurrentState &
 (MEDIA_PLAYER_PREPARED | MEDIA_PLAYER_PAUSED | MEDIA_PLAYER_PLAYBACK_COMPLETE))) {
        ALOGE("next player is not prepared");
 return INVALID_OPERATION;
 }

 return mPlayer->setNextPlayer(next == NULL ? NULL : next->mPlayer);
}

void MediaPlayer::clear_l()
{
    mCurrentPosition = -1;
    mSeekPosition = -1;
    mVideoWidth = mVideoHeight = 0;
    mRetransmitEndpointValid = false;
}

bool MediaPlayer::isPlaying()
{
 Mutex::Autolock _l(mLock);
 if (mPlayer != 0) {
 bool temp = false;
        mPlayer->isPlaying(&temp);
        ALOGV("isPlaying: %d", temp);
 if ((mCurrentState & MEDIA_PLAYER_STARTED) && ! temp) {
            ALOGE("internal/external state mismatch corrected");
            mCurrentState = MEDIA_PLAYER_PAUSED;
 } else if ((mCurrentState & MEDIA_PLAYER_PAUSED) && temp) {
            ALOGE("internal/external state mismatch corrected");
            mCurrentState = MEDIA_PLAYER_STARTED;
 }
 return temp;
 }
    ALOGV("isPlaying: no active player");
 return false;
}

status_t MediaRecorder::start()
{
    ALOGV("start");
 if (mMediaRecorder == NULL) {
        ALOGE("media recorder is not initialized yet");
 return INVALID_OPERATION;
 }
 if (!(mCurrentState & MEDIA_RECORDER_PREPARED)) {
        ALOGE("start called in an invalid state: %d", mCurrentState);
 return INVALID_OPERATION;
 }

 status_t ret = mMediaRecorder->start();
 if (OK != ret) {
        ALOGE("start failed: %d", ret);
        mCurrentState = MEDIA_RECORDER_ERROR;
 return ret;
 }
    mCurrentState = MEDIA_RECORDER_RECORDING;
 return ret;
}

status_t MediaPlayer::getSyncSettings(
 AVSyncSettings* sync /* nonnull */, float* videoFps /* nonnull */)
{
 Mutex::Autolock _l(mLock);
 if (mPlayer == 0) return INVALID_OPERATION;
 return mPlayer->getSyncSettings(sync, videoFps);
}

status_t MediaPlayer::getVideoWidth(int *w)
{
    ALOGV("getVideoWidth");
 Mutex::Autolock _l(mLock);
 if (mPlayer == 0) return INVALID_OPERATION;
 *w = mVideoWidth;
 return NO_ERROR;
}

void MediaPlayer::disconnect()
{
    ALOGV("disconnect");
    sp<IMediaPlayer> p;
 {
 Mutex::Autolock _l(mLock);
        p = mPlayer;
        mPlayer.clear();
 }

 if (p != 0) {
        p->disconnect();
 }
}

status_t MediaRecorder::getMaxAmplitude(int* max)
{
    ALOGV("getMaxAmplitude");
 if (mMediaRecorder == NULL) {
        ALOGE("media recorder is not initialized yet");
 return INVALID_OPERATION;
 }
 if (mCurrentState & MEDIA_RECORDER_ERROR) {
        ALOGE("getMaxAmplitude called in an invalid state: %d", mCurrentState);
 return INVALID_OPERATION;
 }

 status_t ret = mMediaRecorder->getMaxAmplitude(max);
 if (OK != ret) {
        ALOGE("getMaxAmplitude failed: %d", ret);
        mCurrentState = MEDIA_RECORDER_ERROR;
 return ret;
 }
 return ret;
}

void MediaRecorder::died()
{
    ALOGV("died");
    notify(MEDIA_RECORDER_EVENT_ERROR, MEDIA_ERROR_SERVER_DIED, 0);
}

status_t MediaPlayer::setLooping(int loop)
{
    ALOGV("MediaPlayer::setLooping");
 Mutex::Autolock _l(mLock);
    mLoop = (loop != 0);
 if (mPlayer != 0) {
 return mPlayer->setLooping(loop);
 }
 return OK;
}

status_t MediaPlayer::getAudioStreamType(audio_stream_type_t *type)
{
    ALOGV("getAudioStreamType");
 Mutex::Autolock _l(mLock);
 *type = mStreamType;
 return OK;
}

status_t MediaPlayer::checkStateForKeySet_l(int key)
{
 switch(key) {
 case KEY_PARAMETER_AUDIO_ATTRIBUTES:
 if (mCurrentState & ( MEDIA_PLAYER_PREPARED | MEDIA_PLAYER_STARTED |
                MEDIA_PLAYER_PAUSED | MEDIA_PLAYER_PLAYBACK_COMPLETE) ) {
            ALOGE("trying to set audio attributes called in state %d", mCurrentState);
 return INVALID_OPERATION;
 }
 break;
 default:
 break;
 }
 return OK;
}

status_t MediaPlayer::setListener(const sp<MediaPlayerListener>& listener)
{
    ALOGV("setListener");
 Mutex::Autolock _l(mLock);
    mListener = listener;
 return NO_ERROR;
}

status_t MediaRecorder::close()
{
    ALOGV("close");
 if (!(mCurrentState & MEDIA_RECORDER_INITIALIZED)) {
        ALOGE("close called in an invalid state: %d", mCurrentState);
 return INVALID_OPERATION;
 }
 status_t ret = mMediaRecorder->close();
 if (OK != ret) {
        ALOGE("close failed: %d", ret);
        mCurrentState = MEDIA_RECORDER_ERROR;
 return UNKNOWN_ERROR;
 } else {
        mCurrentState = MEDIA_RECORDER_IDLE;
 }
 return ret;
}

status_t MediaPlayer::getDuration(int *msec)
{
 Mutex::Autolock _l(mLock);
 return getDuration_l(msec);
}

status_t MediaPlayer::setParameter(int key, const Parcel& request)
{
    ALOGV("MediaPlayer::setParameter(%d)", key);
 status_t status = INVALID_OPERATION;
 Mutex::Autolock _l(mLock);
 if (checkStateForKeySet_l(key) != OK) {
 return status;
 }
 switch (key) {
 case KEY_PARAMETER_AUDIO_ATTRIBUTES:
 if (mAudioAttributesParcel != NULL) { delete mAudioAttributesParcel; };
        mAudioAttributesParcel = new Parcel();
        mAudioAttributesParcel->appendFrom(&request, 0, request.dataSize());
        status = OK;
 break;
 default:
        ALOGV_IF(mPlayer == NULL, "setParameter: no active player");
 break;
 }

 if (mPlayer != NULL) {
        status = mPlayer->setParameter(key, request);
 }
 return status;
}

status_t MediaRecorder::setClientName(const String16& clientName)
{
    ALOGV("setClientName");
 if (mMediaRecorder == NULL) {
        ALOGE("media recorder is not initialized yet");
 return INVALID_OPERATION;
 }
 bool isInvalidState = (mCurrentState &
 (MEDIA_RECORDER_PREPARED |
                            MEDIA_RECORDER_RECORDING |
                            MEDIA_RECORDER_ERROR));
 if (isInvalidState) {
        ALOGE("setClientName is called in an invalid state: %d", mCurrentState);
 return INVALID_OPERATION;
 }

    mMediaRecorder->setClientName(clientName);

 return NO_ERROR;
}

status_t MediaPlayer::attachAuxEffect(int effectId)
{
    ALOGV("MediaPlayer::attachAuxEffect(%d)", effectId);
 Mutex::Autolock _l(mLock);
 if (mPlayer == 0 ||
 (mCurrentState & MEDIA_PLAYER_IDLE) ||
 (mCurrentState == MEDIA_PLAYER_STATE_ERROR )) {
        ALOGE("attachAuxEffect called in state %d", mCurrentState);
 return INVALID_OPERATION;
 }

 return mPlayer->attachAuxEffect(effectId);
}
