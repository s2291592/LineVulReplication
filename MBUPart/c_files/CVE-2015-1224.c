void MostVisitedSitesBridge::Destroy(
    JNIEnv* env, const JavaParamRef<jobject>& obj) {
   delete this;
 }

void MostVisitedSitesBridge::SetMostVisitedURLsObserver(
     JNIEnv* env,
     const JavaParamRef<jobject>& obj,
     const JavaParamRef<jobject>& j_observer,
    jint num_sites) {
  java_observer_.reset(new JavaObserver(env, j_observer));
  most_visited_->SetMostVisitedURLsObserver(java_observer_.get(), num_sites);
}

void MostVisitedSitesBridge::RecordPageImpression(
    JNIEnv* env,
    const JavaParamRef<jobject>& obj,
    const JavaParamRef<jintArray>& jtile_types,
    const JavaParamRef<jintArray>& jsources,
    const JavaParamRef<jobjectArray>& jtile_urls) {
  std::vector<int> int_sources;
  base::android::JavaIntArrayToIntVector(env, jsources, &int_sources);
  std::vector<int> int_tile_types;
  base::android::JavaIntArrayToIntVector(env, jtile_types, &int_tile_types);
  std::vector<std::string> string_tile_urls;
  base::android::AppendJavaStringArrayToStringVector(env, jtile_urls,
                                                     &string_tile_urls);

  DCHECK_EQ(int_sources.size(), int_tile_types.size());
  DCHECK_EQ(int_sources.size(), string_tile_urls.size());

  std::vector<TileImpression> tiles;
  for (size_t i = 0; i < int_sources.size(); i++) {
    NTPTileSource source = static_cast<NTPTileSource>(int_sources[i]);
    MostVisitedTileType tile_type =
        static_cast<MostVisitedTileType>(int_tile_types[i]);

    tiles.emplace_back(source, tile_type, GURL(string_tile_urls[i]));
  }
  ntp_tiles::metrics::RecordPageImpression(tiles,
                                           g_browser_process->rappor_service());
}

void MostVisitedSitesBridge::JavaObserver::OnMostVisitedURLsAvailable(
const NTPTilesVector& tiles) {
JNIEnv* env = AttachCurrentThread();
std::vector<base::string16> titles;
std::vector<std::string> urls;
std::vector<std::string> whitelist_icon_paths;
std::vector<int> sources;

titles.reserve(tiles.size());
urls.reserve(tiles.size());
whitelist_icon_paths.reserve(tiles.size());
sources.reserve(tiles.size());
for (const auto& tile : tiles) {
titles.emplace_back(tile.title);
urls.emplace_back(tile.url.spec());
whitelist_icon_paths.emplace_back(tile.whitelist_icon_path.value());
sources.emplace_back(static_cast<int>(tile.source));
}
  Java_MostVisitedURLsObserver_onMostVisitedURLsAvailable(
env, observer_, ToJavaArrayOfStrings(env, titles),
ToJavaArrayOfStrings(env, urls),
ToJavaArrayOfStrings(env, whitelist_icon_paths),
ToJavaIntArray(env, sources));
}

void MostVisitedSitesBridge::AddOrRemoveBlacklistedUrl(
    JNIEnv* env,
    const JavaParamRef<jobject>& obj,
    const JavaParamRef<jstring>& j_url,
    jboolean add_url) {
  GURL url(ConvertJavaStringToUTF8(env, j_url));
  most_visited_->AddOrRemoveBlacklistedUrl(url, add_url);
}

void MostVisitedSitesBridge::RecordOpenedMostVisitedItem(
    JNIEnv* env,
    const JavaParamRef<jobject>& obj,
    jint index,
    jint tile_type,
    jint source) {
  ntp_tiles::metrics::RecordTileClick(
      index, static_cast<NTPTileSource>(source),
      static_cast<MostVisitedTileType>(tile_type));
}

MostVisitedSitesBridge::~MostVisitedSitesBridge() {}

void MostVisitedSitesBridge::JavaObserver::OnIconMadeAvailable(
const GURL& site_url) {
JNIEnv* env = AttachCurrentThread();
  Java_MostVisitedURLsObserver_onIconMadeAvailable(
env, observer_, ConvertUTF8ToJavaString(env, site_url.spec()));
}

static jlong Init(JNIEnv* env,
                  const JavaParamRef<jobject>& obj,
                  const JavaParamRef<jobject>& jprofile) {
  MostVisitedSitesBridge* most_visited_sites =
      new MostVisitedSitesBridge(
          ProfileAndroid::FromProfileAndroid(jprofile));
  return reinterpret_cast<intptr_t>(most_visited_sites);
}

bool MostVisitedSitesBridge::Register(JNIEnv* env) {
  return RegisterNativesImpl(env);
}
