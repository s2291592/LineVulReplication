  void set_privileged_process_id(int process_id) {
    browser_client_.set_privileged_process_id(process_id);
  }

  ~SiteInstanceTestBrowserClient() {
    WebUIControllerFactory::UnregisterFactoryForTesting(&factory_);
  }

  SiteInstanceTest()
      : ui_thread_(BrowserThread::UI, &message_loop_),
        file_user_blocking_thread_(BrowserThread::FILE_USER_BLOCKING,
                                   &message_loop_),
        io_thread_(BrowserThread::IO, &message_loop_),
        old_browser_client_(NULL) {
  }

void RenderProcessHostImpl::CreateMessageFilters() {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  MediaInternals* media_internals = MediaInternals::GetInstance();;
  if (IsGuest()) {
    scoped_refptr<BrowserPluginMessageFilter> bp_message_filter(
        new BrowserPluginMessageFilter(
            GetID(),
            GetBrowserContext()));
    channel_->AddFilter(bp_message_filter);
  }

  scoped_refptr<RenderMessageFilter> render_message_filter(
      new RenderMessageFilter(
          GetID(),
#if defined(ENABLE_PLUGINS)
          PluginServiceImpl::GetInstance(),
#else
          NULL,
#endif
          GetBrowserContext(),
          GetBrowserContext()->GetRequestContextForRenderProcess(GetID()),
          widget_helper_,
          media_internals,
          storage_partition_impl_->GetDOMStorageContext()));
  channel_->AddFilter(render_message_filter);
  BrowserContext* browser_context = GetBrowserContext();
  ResourceContext* resource_context = browser_context->GetResourceContext();

  ResourceMessageFilter* resource_message_filter = new ResourceMessageFilter(
      GetID(), PROCESS_TYPE_RENDERER, resource_context,
      storage_partition_impl_->GetAppCacheService(),
      ChromeBlobStorageContext::GetFor(browser_context),
      storage_partition_impl_->GetFileSystemContext(),
      new RendererURLRequestContextSelector(browser_context, GetID()));

  channel_->AddFilter(resource_message_filter);
  media::AudioManager* audio_manager = BrowserMainLoop::GetAudioManager();
  MediaStreamManager* media_stream_manager =
      BrowserMainLoop::GetMediaStreamManager();
  channel_->AddFilter(new AudioInputRendererHost(audio_manager,
                                                 media_stream_manager));
  channel_->AddFilter(new AudioRendererHost(
      GetID(), audio_manager, BrowserMainLoop::GetAudioMirroringManager(),
      media_internals));
  channel_->AddFilter(new VideoCaptureHost());
  channel_->AddFilter(new AppCacheDispatcherHost(
      storage_partition_impl_->GetAppCacheService(),
      GetID()));
  channel_->AddFilter(new ClipboardMessageFilter());
  channel_->AddFilter(
      new DOMStorageMessageFilter(
          GetID(),
          storage_partition_impl_->GetDOMStorageContext()));
  channel_->AddFilter(
      new IndexedDBDispatcherHost(
          GetID(),
          storage_partition_impl_->GetIndexedDBContext()));
  channel_->AddFilter(GeolocationDispatcherHost::New(
      GetID(), browser_context->GetGeolocationPermissionContext()));
  gpu_message_filter_ = new GpuMessageFilter(GetID(), widget_helper_.get());
  channel_->AddFilter(gpu_message_filter_);
#if defined(ENABLE_WEBRTC)
  peer_connection_tracker_host_ = new PeerConnectionTrackerHost(GetID());
  channel_->AddFilter(peer_connection_tracker_host_);
  channel_->AddFilter(new MediaStreamDispatcherHost(GetID()));
#endif
#if defined(ENABLE_PLUGINS)
  channel_->AddFilter(new PepperMessageFilter(PROCESS_TYPE_RENDERER,
                                              GetID(), browser_context));
#endif
#if defined(ENABLE_INPUT_SPEECH)
  channel_->AddFilter(new InputTagSpeechDispatcherHost(
      IsGuest(), GetID(), storage_partition_impl_->GetURLRequestContext(),
      browser_context->GetSpeechRecognitionPreferences()));
  channel_->AddFilter(new SpeechRecognitionDispatcherHost(
      GetID(), storage_partition_impl_->GetURLRequestContext(),
      browser_context->GetSpeechRecognitionPreferences()));
#endif
  channel_->AddFilter(new FileAPIMessageFilter(
      GetID(),
      storage_partition_impl_->GetURLRequestContext(),
      storage_partition_impl_->GetFileSystemContext(),
      ChromeBlobStorageContext::GetFor(browser_context)));
  channel_->AddFilter(new OrientationMessageFilter());
  channel_->AddFilter(new FileUtilitiesMessageFilter(GetID()));
  channel_->AddFilter(new MimeRegistryMessageFilter());
  channel_->AddFilter(new DatabaseMessageFilter(
      storage_partition_impl_->GetDatabaseTracker()));
#if defined(OS_MACOSX)
  channel_->AddFilter(new TextInputClientMessageFilter(GetID()));
#elif defined(OS_WIN)
  channel_->AddFilter(new FontCacheDispatcher());
#endif

  SocketStreamDispatcherHost* socket_stream_dispatcher_host =
      new SocketStreamDispatcherHost(GetID(),
          new RendererURLRequestContextSelector(browser_context, GetID()),
          resource_context);
  channel_->AddFilter(socket_stream_dispatcher_host);

  channel_->AddFilter(
      new WorkerMessageFilter(
          GetID(),
          resource_context,
          WorkerStoragePartition(
              storage_partition_impl_->GetURLRequestContext(),
              storage_partition_impl_->GetMediaURLRequestContext(),
              storage_partition_impl_->GetAppCacheService(),
              storage_partition_impl_->GetFileSystemContext(),
              storage_partition_impl_->GetDatabaseTracker(),
              storage_partition_impl_->GetIndexedDBContext()),
          base::Bind(&RenderWidgetHelper::GetNextRoutingID,
                     base::Unretained(widget_helper_.get()))));

#if defined(ENABLE_WEBRTC)
  channel_->AddFilter(new P2PSocketDispatcherHost(resource_context));
#endif

  channel_->AddFilter(new TraceMessageFilter());
  channel_->AddFilter(new ResolveProxyMsgHelper(
      browser_context->GetRequestContextForRenderProcess(GetID())));
  channel_->AddFilter(new QuotaDispatcherHost(
      GetID(),
      storage_partition_impl_->GetQuotaManager(),
      GetContentClient()->browser()->CreateQuotaPermissionContext()));
  channel_->AddFilter(new GamepadBrowserMessageFilter());
  channel_->AddFilter(new ProfilerMessageFilter(PROCESS_TYPE_RENDERER));
  channel_->AddFilter(new HistogramMessageFilter());
  channel_->AddFilter(new HyphenatorMessageFilter(this));
}

void RenderProcessHostImpl::AppendRendererCommandLine(
    CommandLine* command_line) const {
  command_line->AppendSwitchASCII(switches::kProcessType,
                                  switches::kRendererProcess);

  const CommandLine& browser_command_line = *CommandLine::ForCurrentProcess();
  PropagateBrowserCommandLineToRenderer(browser_command_line, command_line);

  const std::string locale =
      GetContentClient()->browser()->GetApplicationLocale();
  command_line->AppendSwitchASCII(switches::kLang, locale);

  std::string field_trial_states;
  base::FieldTrialList::StatesToString(&field_trial_states);
  if (!field_trial_states.empty()) {
    command_line->AppendSwitchASCII(switches::kForceFieldTrials,
                                    field_trial_states);
  }

  GetContentClient()->browser()->AppendExtraCommandLineSwitches(
      command_line, GetID());

  GpuDataManagerImpl* gpu_data_manager = GpuDataManagerImpl::GetInstance();
  DCHECK(gpu_data_manager);
  gpu_data_manager->AppendRendererCommandLine(command_line);
}

base::ProcessHandle RenderProcessHostImpl::GetHandle() const {
  if (run_renderer_in_process())
    return base::Process::Current().handle();

  if (!child_process_launcher_.get() || child_process_launcher_->IsStarting())
    return base::kNullProcessHandle;

  return child_process_launcher_->GetHandle();
}

  virtual void TearDown() {
    EXPECT_TRUE(RenderProcessHost::AllHostsIterator().IsAtEnd());

    GetContentClient()->set_browser_for_testing(old_browser_client_);

    DrainMessageLoops();
  }

void RenderProcessHostImpl::PropagateBrowserCommandLineToRenderer(
    const CommandLine& browser_cmd,
    CommandLine* renderer_cmd) const {
  static const char* const kSwitchNames[] = {
    switches::kAudioBufferSize,
    switches::kAuditAllHandles,
    switches::kAuditHandles,
    switches::kChromeFrame,
    switches::kDisable3DAPIs,
    switches::kDisableAcceleratedCompositing,
    switches::kDisableAcceleratedVideoDecode,
    switches::kDisableApplicationCache,
    switches::kDisableAudio,
    switches::kDisableAudioOutputResampler,
    switches::kDisableBreakpad,
#if defined(OS_MACOSX)
    switches::kDisableCompositedCoreAnimationPlugins,
#endif
    switches::kDisableDataTransferItems,
    switches::kDisableDatabases,
    switches::kDisableDesktopNotifications,
    switches::kDisableDeviceOrientation,
    switches::kDisableFileSystem,
    switches::kDisableGeolocation,
    switches::kDisableGLMultisampling,
    switches::kDisableGpuVsync,
    switches::kDisableHistogramCustomizer,
    switches::kDisableJavaScriptI18NAPI,
    switches::kDisableLocalStorage,
    switches::kDisableLogging,
    switches::kDisableSeccompFilterSandbox,
    switches::kDisableSeccompSandbox,
    switches::kDisableSessionStorage,
    switches::kDisableSharedWorkers,
    switches::kDisableSpeechInput,
#if defined(OS_ANDROID)
    switches::kEnableWebAudio,
    switches::kEnableWebRTC,
#else
    switches::kDisableWebAudio,
#endif
    switches::kEnableWebAudioInput,
    switches::kDisableWebSockets,
    switches::kDomAutomationController,
    switches::kEnableAccessibilityLogging,
    switches::kEnableBrowserPluginCompositing,
    switches::kEnableBrowserPluginForAllViewTypes,
    switches::kEnableDCHECK,
    switches::kDisableEncryptedMedia,
    switches::kEnableExperimentalWebKitFeatures,
    switches::kEnableFixedLayout,
    switches::kEnableDeferredImageDecoding,
    switches::kEnableGPUServiceLogging,
    switches::kEnableGPUClientLogging,
    switches::kEnableGpuClientTracing,
    switches::kEnableGpuBenchmarking,
    switches::kEnableMemoryBenchmarking,
    switches::kEnableLogging,
    switches::kDisableMediaSource,
    switches::kDisableWebMediaPlayerMS,
    switches::kDisableRendererSideMixing,
    switches::kEnableStrictSiteIsolation,
    switches::kDisableFullScreen,
    switches::kEnableNewDialogStyle,
#if defined(ENABLE_PLUGINS)
    switches::kEnablePepperTesting,
#endif
    switches::kEnablePreparsedJsCaching,
    switches::kEnablePruneGpuCommandBuffers,
    switches::kEnablePinch,
#if defined(OS_MACOSX)
    switches::kEnableSandboxLogging,
#endif
    switches::kEnableSeccompSandbox,
    switches::kEnableSoftwareCompositingGLAdapter,
    switches::kEnableStatsTable,
    switches::kEnableThreadedCompositing,
    switches::kEnableCompositingForFixedPosition,
    switches::kEnableHighDpiCompositingForFixedPosition,
    switches::kDisableCompositingForFixedPosition,
    switches::kEnableTouchDragDrop,
    switches::kDisableThreadedCompositing,
    switches::kDisableTouchAdjustment,
    switches::kEnableViewport,
    switches::kEnableOpusPlayback,
    switches::kEnableVp9Playback,
    switches::kForceDeviceScaleFactor,
    switches::kFullMemoryCrashReport,
#if !defined (GOOGLE_CHROME_BUILD)
    switches::kInProcessPlugins,
#endif  // GOOGLE_CHROME_BUILD
    switches::kInProcessWebGL,
    switches::kJavaScriptFlags,
    switches::kLoggingLevel,
    switches::kMemoryMetrics,
#if defined(OS_ANDROID)
    switches::kMediaPlayerInRenderProcess,
    switches::kNetworkCountryIso,
#endif
    switches::kNoReferrers,
    switches::kNoSandbox,
    switches::kOldCheckboxStyle,
    switches::kPpapiOutOfProcess,
    switches::kRegisterPepperPlugins,
    switches::kRendererAssertTest,
#if defined(OS_POSIX)
    switches::kChildCleanExit,
#endif
    switches::kRendererStartupDialog,
    switches::kShowPaintRects,
    switches::kSitePerProcess,
    switches::kTestSandbox,
    switches::kTouchEvents,
    switches::kTraceStartup,
    switches::kUseGL,
    switches::kUseMobileUserAgent,
    switches::kUserAgent,
    switches::kV,
    switches::kVideoThreads,
    switches::kVModule,
    switches::kWebCoreLogChannels,
    switches::kWebIntentsInvocationEnabled,
    cc::switches::kBackgroundColorInsteadOfCheckerboard,
    cc::switches::kEnableCompositorFrameMessage,
    cc::switches::kEnableImplSidePainting,
    cc::switches::kEnablePartialSwap,
    cc::switches::kEnableRightAlignedScheduling,
    cc::switches::kEnableTopControlsPositionCalculation,
    cc::switches::kNumRasterThreads,
    cc::switches::kShowPropertyChangedRects,
    cc::switches::kShowSurfaceDamageRects,
    cc::switches::kShowScreenSpaceRects,
    cc::switches::kShowReplicaScreenSpaceRects,
    cc::switches::kShowNonOccludingRects,
    cc::switches::kShowOccludingRects,
    cc::switches::kTraceOverdraw,
    cc::switches::kTopControlsHeight,
    cc::switches::kSlowDownRasterScaleFactor,
    cc::switches::kUseCheapnessEstimator,
  };
  renderer_cmd->CopySwitchesFrom(browser_cmd, kSwitchNames,
                                 arraysize(kSwitchNames));

  if (GetBrowserContext()->IsOffTheRecord() &&
      !browser_cmd.HasSwitch(switches::kDisableDatabases)) {
    renderer_cmd->AppendSwitch(switches::kDisableDatabases);
#if defined(OS_ANDROID)
    renderer_cmd->AppendSwitch(switches::kDisableMediaHistoryLogging);
#endif
  }

  if (browser_cmd.HasSwitch(cc::switches::kEnableImplSidePainting) &&
      !browser_cmd.HasSwitch(switches::kEnableDeferredImageDecoding))
    renderer_cmd->AppendSwitch(switches::kEnableDeferredImageDecoding);
}

RenderProcessHost* RenderProcessHostImpl::GetProcessHostForSite(
BrowserContext* browser_context,
const GURL& url) {
// Look up the map of site to process for the given browser_context.
SiteProcessMap* map =
GetSiteProcessMapForBrowserContext(browser_context);

  // See if we have an existing process for this site.  If not, the caller
  // should create a new process and register it.
std::string site = SiteInstance::GetSiteForURL(browser_context, url)
.possibly_invalid_spec();
  return map->FindProcess(site);
}

void RenderProcessHostImpl::Cleanup() {
  if (render_widget_hosts_.IsEmpty()) {
    DCHECK_EQ(0, pending_views_);
    NotificationService::current()->Notify(
        NOTIFICATION_RENDERER_PROCESS_TERMINATED,
        Source<RenderProcessHost>(this),
        NotificationService::NoDetails());

    MessageLoop::current()->DeleteSoon(FROM_HERE, this);
    deleting_soon_ = true;
    channel_.reset();
    gpu_message_filter_ = NULL;

    UnregisterHost(GetID());
  }
}

void RenderProcessHostImpl::RegisterProcessHostForSite(
BrowserContext* browser_context,
RenderProcessHost* process,
const GURL& url) {
// Look up the map of site to process for the given browser_context.
SiteProcessMap* map =
GetSiteProcessMapForBrowserContext(browser_context);

  // TODO(creis): Determine if it's better to allow registration of
  // empty sites or not.  For now, group anything from which we can't parse
  // a site into the same process, when using --process-per-site.
std::string site = SiteInstance::GetSiteForURL(browser_context, url)
.possibly_invalid_spec();
  map->RegisterProcess(site, process);
}

  void NavigateActiveAndCommit(const GURL& url) {
    controller().LoadURL(url, Referrer(), PAGE_TRANSITION_LINK, std::string());
    TestRenderViewHost* old_rvh = test_rvh();

    if (old_rvh != active_rvh())
      old_rvh->SendShouldCloseACK(true);

    int32 max_page_id = contents()->GetMaxPageIDForSiteInstance(
        active_rvh()->GetSiteInstance());
    active_test_rvh()->SendNavigate(max_page_id + 1, url);

    if (old_rvh != active_rvh())
      old_rvh->OnSwapOutACK(false);
  }

  virtual void SetUp() {
    old_browser_client_ = GetContentClient()->browser();
    GetContentClient()->set_browser_for_testing(&browser_client_);
    url_util::AddStandardScheme(kPrivilegedScheme);
    url_util::AddStandardScheme(chrome::kChromeUIScheme);
  }

void RenderProcessHostImpl::OnCompositorSurfaceBuffersSwappedNoHost(
      int32 surface_id,
      uint64 surface_handle,
      int32 route_id,
      const gfx::Size& size,
      int32 gpu_process_host_id) {
  TRACE_EVENT0("renderer_host",
               "RenderWidgetHostImpl::OnCompositorSurfaceBuffersSwappedNoHost");
  AcceleratedSurfaceMsg_BufferPresented_Params ack_params;
  ack_params.sync_point = 0;
  RenderWidgetHostImpl::AcknowledgeBufferPresent(route_id,
                                                 gpu_process_host_id,
                                                 ack_params);
}

  bool ShouldSwapProcesses(RenderViewHostManager* manager,
                           const NavigationEntryImpl* cur_entry,
                           const NavigationEntryImpl* new_entry) const {
    return manager->ShouldSwapProcessesForNavigation(cur_entry, new_entry);
  }
