    MockFetchContext() { }

    void runSingleTask()
    {
        if (m_tasks.isEmpty())
            return;
        m_tasks.takeFirst()->run();
    }

    FakeImageBufferClient(ImageBuffer* imageBuffer)
        : m_isDirty(false)
        , m_imageBuffer(imageBuffer)
        , m_frameCount(0)
    { }

int main(int argc, char** argv)
{
    base::TestSuite testSuite(argc, argv);
    return base::LaunchUnitTests(argc, argv, base::Bind(runHelper, base::Unretained(&testSuite)));
}

    virtual void TearDown()
    {
        memoryCache()->evictResources();

        replaceMemoryCacheForTesting(m_globalMemoryCache.release());
    }

    static MockFetchContext* create()
    {
        return new MockFetchContext;
    }

void TestingDiscardableMemory::unlock()
{
    ASSERT(m_isLocked);
    m_isLocked = false;
    memset(m_data.data(), 0, m_data.size());
}

    ~MockFetchContext() { }

void* TestingDiscardableMemory::data()
{
    ASSERT(m_isLocked);
    return m_data.data();
}

    void testClearRect()
    {
        m_testSurface->initializeCurrentFrame();
        m_testSurface->getPicture();
        SkPaint clearPaint;
        clearPaint.setXfermodeMode(SkXfermode::kClear_Mode);
        m_imageBuffer->canvas()->drawRect(SkRect::MakeWH(m_testSurface->size().width(), m_testSurface->size().height()), clearPaint);
        m_fakeImageBufferClient->fakeDraw();
        EXPECT_EQ(1, m_fakeImageBufferClient->frameCount());
        m_testSurface->getPicture();
        EXPECT_EQ(2, m_fakeImageBufferClient->frameCount());
        expectDisplayListEnabled(true);
    }

 const unsigned char* TestingPlatformSupport::getTraceCategoryEnabledFlag(const char* categoryName)
{
    static const unsigned char tracingIsDisabled = 0;
    return &tracingIsDisabled;
}

 void TestBlinkPlatformSupport::cryptographicallyRandomValues(
     unsigned char* buffer,
     size_t length) {
 }

void BlinkMediaTestSuite::Initialize() {
  base::TestSuite::Initialize();

#if defined(OS_ANDROID)
  JNIEnv* env = base::android::AttachCurrentThread();
  ui::gl::android::RegisterJni(env);
  media::RegisterJni(env);
#endif

  media::InitializeMediaLibrary();

#ifdef V8_USE_EXTERNAL_STARTUP_DATA
  gin::V8Initializer::LoadV8Snapshot();
  gin::V8Initializer::LoadV8Natives();
#endif

  scoped_ptr<base::MessageLoop> message_loop;
  if (!base::MessageLoop::current())
    message_loop.reset(new base::MessageLoop());
  blink::initialize(blink_platform_support_.get());
}

std::string NormalizeLayoutTestURL(const std::string& url) {
  std::string result = url;
  size_t pos;
  if (!url.find(file_url_pattern) &&
      ((pos = url.find(layout_tests_pattern)) != std::string::npos)) {
    result.replace(0, pos + layout_tests_pattern_size, file_test_prefix);
  } else if (!url.find(data_url_pattern)) {
    std::string path = url.substr(data_url_pattern_size);
    result.replace(data_url_pattern_size, url.length(), path);
  }
  return result;
}

WebString TestingPlatformSupport::defaultLocale()
{
    return WebString::fromUTF8("en-US");
}

    explicit MockWebTaskRunner(Deque<OwnPtr<WebTaskRunner::Task>>* tasks) : m_tasks(tasks) { }

static double getCurrentTime()
{
    static double syncLowResUTCTime;
    static double syncHighResUpTime;
    static double lastUTCTime;

    double lowResTime = lowResUTCTime();
    if (!qpcAvailable())
        return lowResTime * (1.0 / 1000.0);

    double highResTime = highResUpTime();
    if (!syncedTime) {
        timeBeginPeriod(1); // increase time resolution around low-res time getter
        syncLowResUTCTime = lowResTime = lowResUTCTime();
        timeEndPeriod(1); // restore time resolution
        syncHighResUpTime = highResTime;
        syncedTime = true;
    }

    double highResElapsed = highResTime - syncHighResUpTime;
    double utc = syncLowResUTCTime + highResElapsed;

    double lowResElapsed = lowResTime - syncLowResUTCTime;
    const double maximumAllowedDriftMsec = 15.625 * 2.0; // 2x the typical low-res accuracy
    if (fabs(highResElapsed - lowResElapsed) > maximumAllowedDriftMsec)
        syncedTime = false;

    const double backwardTimeLimit = 2000.0;
    if (utc < lastUTCTime && (lastUTCTime - utc) < backwardTimeLimit)
        return lastUTCTime * (1.0 / 1000.0);

    lastUTCTime = utc;
    return utc * (1.0 / 1000.0);
}

        CurrentThreadMock() : m_taskObserver(0) { }

         virtual const unsigned char* getTraceCategoryEnabledFlag(const char* categoryName)
         {
             return &kAConstUnsignedCharZero;
        }

    static PassOwnPtrWillBeRawPtr<MockScriptLoader> create(Element* element)
    {
        return adoptPtrWillBeNoop(new MockScriptLoader(element));
    }

    ResourceFetcher* fetcher() const { return m_fetcher.get(); }

    void testFrameFinalizedByTaskObserver2()
    {
        EXPECT_EQ(3, m_fakeImageBufferClient->frameCount());
        expectDisplayListEnabled(false);
        m_testSurface->getPicture();
        EXPECT_EQ(3, m_fakeImageBufferClient->frameCount());
        expectDisplayListEnabled(false);
        m_fakeImageBufferClient->fakeDraw();
        EXPECT_EQ(3, m_fakeImageBufferClient->frameCount());
        expectDisplayListEnabled(false);
    }

    int createSurfaceCount() { return m_createSurfaceCount; }

         void enterRunLoop() { m_currentThread.enterRunLoop(); }

    void testFrameFinalizedByTaskObserver1()
    {
        m_testSurface->initializeCurrentFrame();
        expectDisplayListEnabled(true);
        m_testSurface->getPicture();
        EXPECT_EQ(1, m_fakeImageBufferClient->frameCount());
        expectDisplayListEnabled(true);
        m_fakeImageBufferClient->fakeDraw();
        EXPECT_EQ(1, m_fakeImageBufferClient->frameCount());
        expectDisplayListEnabled(true);
        m_testSurface->getPicture();
        EXPECT_EQ(2, m_fakeImageBufferClient->frameCount());
        expectDisplayListEnabled(true);
        m_fakeImageBufferClient->fakeDraw();
        EXPECT_EQ(2, m_fakeImageBufferClient->frameCount());
        expectDisplayListEnabled(true);
    }

TestingDiscardableMemory::TestingDiscardableMemory(size_t size) : m_data(size), m_isLocked(true)
{
}

    ResourcePtr<Resource> resourceFromResourceRequest(ResourceRequest request, Resource::Type type = Resource::Raw)
    {
        if (request.url().isNull())
            request.setURL(KURL(ParsedURLString, kResourceURL));
        ResourcePtr<Resource> resource =
            new Resource(request, type);
        resource->setResponse(ResourceResponse(KURL(ParsedURLString, kResourceURL), "text/html", 0, nullAtom, String()));
        memoryCache()->add(resource.get());

        return resource;
    }

    ResourcePtr<Resource> resourceFromResourceResponse(ResourceResponse response, Resource::Type type = Resource::Raw)
    {
        if (response.url().isNull())
            response.setURL(KURL(ParsedURLString, kResourceURL));
        ResourcePtr<Resource> resource =
            new Resource(ResourceRequest(response.url()), type);
        resource->setResponse(response);
        memoryCache()->add(resource.get());

        return resource;
    }

        MockWebTaskRunner() : m_task(0) { }

TestBlinkPlatformSupport::~TestBlinkPlatformSupport() {}

static double highResUpTime()
{

    static LARGE_INTEGER qpcLast;
    static DWORD tickCountLast;
    static bool inited;

    LARGE_INTEGER qpc;
    QueryPerformanceCounter(&qpc);
    DWORD tickCount = GetTickCount();

    if (inited) {
        __int64 qpcElapsed = ((qpc.QuadPart - qpcLast.QuadPart) * 1000) / qpcFrequency.QuadPart;
        __int64 tickCountElapsed;
        if (tickCount >= tickCountLast) {
            tickCountElapsed = (tickCount - tickCountLast);
        } else {
            __int64 tickCountLarge = tickCount + 0x100000000I64;
            tickCountElapsed = tickCountLarge - tickCountLast;
        }

        __int64 diff = tickCountElapsed - qpcElapsed;
        if (diff > 500 || diff < -500)
            syncedTime = false;
    } else {
        inited = true;
    }

    qpcLast = qpc;
    tickCountLast = tickCount;

    return (1000.0 * qpc.QuadPart) / static_cast<double>(qpcFrequency.QuadPart);
}

    virtual PassOwnPtr<ImageBufferSurface> createSurface(const IntSize& size, OpacityMode opacityMode)
    {
        m_createSurfaceCount++;
        return adoptPtr(new UnacceleratedImageBufferSurface(size, opacityMode));
    }

    void runAllTasks()
    {
        while (!m_tasks.isEmpty())
            m_tasks.takeFirst()->run();
    }

    virtual ~MockSurfaceFactory() { }

    void testNonAnimatedCanvasUpdate()
    {
        m_testSurface->initializeCurrentFrame();
        m_fakeImageBufferClient->fakeDraw();
        m_testSurface->getPicture();
        m_testSurface->getPicture();
        EXPECT_EQ(2, m_fakeImageBufferClient->frameCount());
        expectDisplayListEnabled(true);
    }

  MockBlinkPlatform() {
    blink::initializeWithoutV8(this);
   }

int main(int argc, char* argv[])
{
    char* name = argv[0];


    bool applyColorCorrection = false;

#if USE(QCMSLIB)
    if (argc >= 2 && strcmp(argv[1], "--color-correct") == 0)
        applyColorCorrection = (--argc, ++argv, true);

    if (argc < 2) {
        fprintf(stderr, "Usage: %s [--color-correct] file [iterations] [packetSize]\n", name);
        exit(1);
    }
#else
    if (argc < 2) {
        fprintf(stderr, "Usage: %s file [iterations] [packetSize]\n", name);
        exit(1);
    }
#endif


    size_t iterations = 1;
    if (argc >= 3) {
        char* end = 0;
        iterations = strtol(argv[2], &end, 10);
        if (*end != '\0' || !iterations) {
            fprintf(stderr, "Second argument should be number of iterations. "
                "The default is 1. You supplied %s\n", argv[2]);
            exit(1);
        }
    }

    size_t packetSize = 0;
    if (argc >= 4) {
        char* end = 0;
        packetSize = strtol(argv[3], &end, 10);
        if (*end != '\0') {
            fprintf(stderr, "Third argument should be packet size. Default is "
                "0, meaning to decode the entire image in one packet. You "
                "supplied %s\n", argv[3]);
            exit(1);
        }
    }


    class WebPlatform : public blink::Platform {
    public:
        const unsigned char* getTraceCategoryEnabledFlag(const char*) override
        {
            return reinterpret_cast<const unsigned char *>("nope-none-nada");
        }
 
         void cryptographicallyRandomValues(unsigned char*, size_t) override
         {
         }
 
         void screenColorProfile(WebVector<char>* profile) override
        {
            getScreenColorProfile(profile); // Returns a whacked color profile.
        }
    };

    blink::initializeWithoutV8(new WebPlatform());


#if USE(QCMSLIB)
    ImageDecoder::qcmsOutputDeviceProfile(); // Initialize screen colorProfile.
#endif


    RefPtr<SharedBuffer> data = readFile(argv[1]);
    if (!data.get() || !data->size()) {
        fprintf(stderr, "Error reading image data from [%s]\n", argv[1]);
        exit(2);
    }

    data->data();


    double totalTime = 0.0;

    for (size_t i = 0; i < iterations; ++i) {
        double startTime = getCurrentTime();
        bool decoded = decodeImageData(data.get(), applyColorCorrection, packetSize);
        double elapsedTime = getCurrentTime() - startTime;
        totalTime += elapsedTime;
        if (!decoded) {
            fprintf(stderr, "Image decode failed [%s]\n", argv[1]);
            exit(3);
        }
    }


    double averageTime = totalTime / static_cast<double>(iterations);
    printf("%f %f\n", totalTime, averageTime);
    return 0;
}

    MockSurfaceFactory() : m_createSurfaceCount(0) { }

         CurrentThreadPlatformMock() { }

    BlinkTestEnvironmentScope()
    {
        content::SetUpBlinkTestEnvironment();
    }

    RecordingImageBufferSurfaceTest()
    {
        OwnPtr<MockSurfaceFactory> surfaceFactory = adoptPtr(new MockSurfaceFactory());
        m_surfaceFactory = surfaceFactory.get();
        OwnPtr<RecordingImageBufferSurface> testSurface = adoptPtr(new RecordingImageBufferSurface(IntSize(10, 10), surfaceFactory.release()));
        m_testSurface = testSurface.get();
        m_imageBuffer = ImageBuffer::create(testSurface.release());
        EXPECT_FALSE(!m_imageBuffer);
        m_fakeImageBufferClient = adoptPtr(new FakeImageBufferClient(m_imageBuffer.get()));
        m_imageBuffer->setClient(m_fakeImageBufferClient.get());
    }

        void enterRunLoop()
        {
            if (m_taskObserver)
                m_taskObserver->willProcessTask();
            if (m_taskRunner.m_task) {
                m_taskRunner.m_task->run();
                delete m_taskRunner.m_task;
                m_taskRunner.m_task = 0;
            }
            if (m_taskObserver)
                m_taskObserver->didProcessTask();
        }

 const unsigned char* TestBlinkPlatformSupport::getTraceCategoryEnabledFlag(
    const char* categoryName) {
  static const unsigned char tracingIsDisabled = 0;
  return &tracingIsDisabled;
}

        ProxyPlatform() : m_platform(blink::Platform::current()), m_elapsedSeconds(0.) { }

PassRefPtr<SharedBuffer> readFile(const char* fileName)
{
    FILE* fp = fopen(fileName, "rb");
    if (!fp) {
        fprintf(stderr, "Can't open file %s\n", fileName);
        exit(2);
    }

    sttype s;
    stat(fileName, &s);
    size_t fileSize = s.st_size;
    if (s.st_size <= 0)
        return SharedBuffer::create();

    OwnPtr<unsigned char[]> buffer = adoptArrayPtr(new unsigned char[fileSize]);
    if (fileSize != fread(buffer.get(), 1, fileSize, fp)) {
        fprintf(stderr, "Error reading file %s\n", fileName);
        exit(2);
    }

    fclose(fp);
    return SharedBuffer::create(buffer.get(), fileSize);
}

WebDiscardableMemory* TestingPlatformSupport::allocateAndLockDiscardableMemory(size_t bytes)
{
    return !m_config.hasDiscardableMemorySupport ? 0 : new TestingDiscardableMemory(bytes);
}

    ResourcePtr<Resource> fetchImage()
    {
        FetchRequest fetchRequest(ResourceRequest(KURL(ParsedURLString, kResourceURL)), FetchInitiatorInfo());
        return ImageResource::fetch(fetchRequest, fetcher());
    }

bool decodeImageData(SharedBuffer* data, bool colorCorrection, size_t packetSize)
{
    OwnPtr<ImageDecoder> decoder = ImageDecoder::create(*data,
        ImageDecoder::AlphaPremultiplied, colorCorrection ?
            ImageDecoder::GammaAndColorProfileApplied : ImageDecoder::GammaAndColorProfileIgnored);

    if (!packetSize) {
        bool allDataReceived = true;
        decoder->setData(data, allDataReceived);

        int frameCount = decoder->frameCount();
        for (int i = 0; i < frameCount; ++i) {
            if (!decoder->frameBufferAtIndex(i))
                return false;
        }

        return !decoder->failed();
    }

    RefPtr<SharedBuffer> packetData = SharedBuffer::create();
    unsigned position = 0;
    while (true) {
        const char* packet;
        unsigned length = data->getSomeData(packet, position);

        length = std::min(static_cast<size_t>(length), packetSize);
        packetData->append(packet, length);
        position += length;

        bool allDataReceived = position == data->size();
        decoder->setData(packetData.get(), allDataReceived);

        int frameCount = decoder->frameCount();
        for (int i = 0; i < frameCount; ++i) {
            if (!decoder->frameBufferAtIndex(i))
                break;
        }

        if (allDataReceived || decoder->failed())
            break;
    }

    return !decoder->failed();
}

    void enterRunLoop()
    {
        m_mockPlatform.enterRunLoop();
    }

        virtual void cryptographicallyRandomValues(unsigned char* buffer, size_t length) { ASSERT_NOT_REACHED(); }

int runHelper(base::TestSuite* testSuite)
{
    BlinkTestEnvironmentScope blinkTestEnvironment;
    blink::ThreadState::current()->registerTraceDOMWrappers(0, 0);
    int result = testSuite->Run();
    blink::Heap::collectAllGarbage();
    return result;
}

    void advanceClock(double seconds)
    {
        m_proxyPlatform.advanceClock(seconds);
    }

    explicit MockWebThread(WebScheduler* webScheduler) : m_webScheduler(webScheduler) { }

        void advanceClock(double seconds)
        {
            m_elapsedSeconds += seconds;
        }

    void testAnimatedWithClear()
    {
        m_testSurface->initializeCurrentFrame();
        m_testSurface->getPicture();
        m_testSurface->willOverwriteCanvas();
        m_fakeImageBufferClient->fakeDraw();
        EXPECT_EQ(1, m_fakeImageBufferClient->frameCount());
        m_testSurface->getPicture();
        EXPECT_EQ(2, m_fakeImageBufferClient->frameCount());
        expectDisplayListEnabled(true);
        m_fakeImageBufferClient->fakeDraw();
        m_testSurface->willOverwriteCanvas();
        EXPECT_EQ(2, m_fakeImageBufferClient->frameCount());
        m_testSurface->getPicture();
        EXPECT_EQ(3, m_fakeImageBufferClient->frameCount());
        expectDisplayListEnabled(true);
    }

TestingDiscardableMemory::~TestingDiscardableMemory()
{
}

TestingPlatformSupport::~TestingPlatformSupport()
{
    Platform::initialize(m_oldPlatform);
}

int main(int argc, char** argv) {
  BlinkMediaTestSuite test_suite(argc, argv);

  return base::LaunchUnitTests(
      argc, argv, base::Bind(&BlinkMediaTestSuite::Run,
                             base::Unretained(&test_suite)));
}

TestingPlatformSupport::TestingPlatformSupport(const Config& config)
    : m_config(config)
    , m_oldPlatform(Platform::current())
{
    Platform::initialize(this);
}

void EnsureBlinkInitialized() {
  g_mock_blink_platform.Get();
}

bool TestingDiscardableMemory::lock()
{
    ASSERT(!m_isLocked);
    m_isLocked = true;
    return false;
}

    void setPublicSuffix(const blink::WebString& suffix)
    {
        m_length = suffix.length();
    }

        ~ProxyPlatform()
        {
            blink::Platform::initialize(m_platform);
        }

void getScreenColorProfile(WebVector<char>* profile)
{
    static unsigned char profileData[] = {
        0x00,0x00,0x01,0xea,0x54,0x45,0x53,0x54,0x00,0x00,0x00,0x00,
        0x6d,0x6e,0x74,0x72,0x52,0x47,0x42,0x20,0x58,0x59,0x5a,0x20,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x61,0x63,0x73,0x70,0x74,0x65,0x73,0x74,0x00,0x00,0x00,0x00,
        0x74,0x65,0x73,0x74,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf6,0xd6,
        0x00,0x01,0x00,0x00,0x00,0x00,0xd3,0x2d,0x74,0x65,0x73,0x74,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x09,
        0x63,0x70,0x72,0x74,0x00,0x00,0x00,0xf0,0x00,0x00,0x00,0x0d,
        0x64,0x65,0x73,0x63,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x8c,
        0x77,0x74,0x70,0x74,0x00,0x00,0x01,0x8c,0x00,0x00,0x00,0x14,
        0x72,0x58,0x59,0x5a,0x00,0x00,0x01,0xa0,0x00,0x00,0x00,0x14,
        0x67,0x58,0x59,0x5a,0x00,0x00,0x01,0xb4,0x00,0x00,0x00,0x14,
        0x62,0x58,0x59,0x5a,0x00,0x00,0x01,0xc8,0x00,0x00,0x00,0x14,
        0x72,0x54,0x52,0x43,0x00,0x00,0x01,0xdc,0x00,0x00,0x00,0x0e,
        0x67,0x54,0x52,0x43,0x00,0x00,0x01,0xdc,0x00,0x00,0x00,0x0e,
        0x62,0x54,0x52,0x43,0x00,0x00,0x01,0xdc,0x00,0x00,0x00,0x0e,
        0x74,0x65,0x78,0x74,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x64,0x65,0x73,0x63,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x10,0x77,0x68,0x61,0x63,0x6b,0x65,0x64,0x2e,
        0x69,0x63,0x63,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x11,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x58,0x59,0x5a,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0xf3,0x52,
        0x00,0x01,0x00,0x00,0x00,0x01,0x16,0xcc,0x58,0x59,0x5a,0x20,
        0x00,0x00,0x00,0x00,0x00,0x00,0x34,0x8d,0x00,0x00,0xa0,0x2c,
        0x00,0x00,0x0f,0x95,0x58,0x59,0x5a,0x20,0x00,0x00,0x00,0x00,
        0x00,0x00,0x26,0x31,0x00,0x00,0x10,0x2f,0x00,0x00,0xbe,0x9b,
        0x58,0x59,0x5a,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x9c,0x18,
        0x00,0x00,0x4f,0xa5,0x00,0x00,0x04,0xfc,0x63,0x75,0x72,0x76,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x33
    };

    static struct WhackedColorProfile {

        char* data() { return reinterpret_cast<char*>(profileData); }

        const size_t profileSize = 490u;

        size_t size() { return profileSize; }

    } screenProfile;

    profile->assign(screenProfile.data(), screenProfile.size());
}

BlinkMediaTestSuite::BlinkMediaTestSuite(int argc, char** argv)
    : TestSuite(argc, argv),
      blink_platform_support_(new TestBlinkPlatformSupport()) {
}

    void expectDisplayListEnabled(bool displayListEnabled)
    {
        EXPECT_EQ(displayListEnabled, (bool)m_testSurface->m_currentFrame.get());
        EXPECT_EQ(!displayListEnabled, (bool)m_testSurface->m_fallbackSurface.get());
        int expectedSurfaceCreationCount = displayListEnabled ? 0 : 1;
        EXPECT_EQ(expectedSurfaceCreationCount, m_surfaceFactory->createSurfaceCount());
    }

    MockPlatform()
        : m_mockWebThread(this)
        , m_mockWebTaskRunner(&m_tasks)
     {
     }

    virtual void SetUp()
    {
        blink::Platform::initialize(&m_proxyPlatform);

        m_globalMemoryCache = replaceMemoryCacheForTesting(MemoryCache::create());

        m_fetcher = ResourceFetcher::create(MockFetchContext::create());
    }
