void LockScreenMediaControlsView::MediaSessionActionsChanged(
    const std::vector<MediaSessionAction>& actions) {
  if (hide_controls_timer_->IsRunning())
    return;

  enabled_actions_ =
      std::set<MediaSessionAction>(actions.begin(), actions.end());

  UpdateActionButtonsVisibility();
}

void LockScreenMediaControlsView::RunHideControlsAnimation() {
  ui::ScopedLayerAnimationSettings animation(
      contents_view_->layer()->GetAnimator());
  animation.AddObserver(this);
  animation.SetPreemptionStrategy(
      ui::LayerAnimator::IMMEDIATELY_ANIMATE_TO_NEW_TARGET);
  animation.SetTransitionDuration(kAnimationDuration);

  gfx::Transform transform;
  transform.Translate(0, -GetBoundsInScreen().bottom());
  contents_view_->layer()->SetTransform(transform);
  contents_view_->layer()->SetOpacity(0);
}

void MediaControlsProgressView::OnGestureEvent(ui::GestureEvent* event) {
  gfx::Point location_in_bar(event->location());
  ConvertPointToTarget(this, this->progress_bar_, &location_in_bar);
  if (event->type() != ui::ET_GESTURE_TAP ||
      !progress_bar_->GetLocalBounds().Contains(location_in_bar)) {
return;
}

  HandleSeeking(location_in_bar);
event->SetHandled();
}

void MediaControlsProgressView::SetBarProgress(double progress) {
  progress_bar_->SetValue(progress);
}

void LockScreenMediaControlsView::OnImplicitAnimationsCompleted() {
  Dismiss();
}

  void DisableAction(MediaSessionAction action) {
    actions_.erase(action);
    NotifyUpdatedActions();
  }

  void EnableAction(MediaSessionAction action) {
    actions_.insert(action);
    NotifyUpdatedActions();
  }

MediaControlsHeaderView::MediaControlsHeaderView() {
  SetLayoutManager(std::make_unique<views::BoxLayout>(
      views::BoxLayout::Orientation::kHorizontal, kMediaControlsHeaderInsets,
      kMediaControlsHeaderChildSpacing));

auto app_icon_view = std::make_unique<views::ImageView>();
app_icon_view->SetImageSize(gfx::Size(kIconSize, kIconSize));
app_icon_view->SetVerticalAlignment(views::ImageView::Alignment::kLeading);
app_icon_view->SetHorizontalAlignment(views::ImageView::Alignment::kLeading);
app_icon_view->SetBorder(views::CreateEmptyBorder(kIconPadding));
app_icon_view->SetBackground(
views::CreateRoundedRectBackground(SK_ColorWHITE, kIconCornerRadius));
app_icon_view_ = AddChildView(std::move(app_icon_view));

// Font list for text views.
gfx::Font default_font;
int font_size_delta = kHeaderTextFontSize - default_font.GetFontSize();
gfx::Font font = default_font.Derive(font_size_delta, gfx::Font::NORMAL,
gfx::Font::Weight::NORMAL);
gfx::FontList font_list(font);

auto app_name_view = std::make_unique<views::Label>();
app_name_view->SetFontList(font_list);
app_name_view->SetHorizontalAlignment(gfx::ALIGN_LEFT);
app_name_view->SetEnabledColor(SK_ColorWHITE);
app_name_view->SetAutoColorReadabilityEnabled(false);
app_name_view_ = AddChildView(std::move(app_name_view));
}

const base::string16& MediaControlsProgressView::duration_for_testing() const {
  return duration_->GetText();
}

void MediaControlsProgressView::SetProgressTime(const base::string16& time) {
  progress_time_->SetText(time);
}

void LockScreenMediaControlsView::EndDrag() {
  is_in_drag_ = false;

  if (last_fling_velocity_ <= kDragVelocityThreshold ||
      (contents_view_->GetBoundsInScreen().y() <= kHeightDismissalThreshold &&
       last_fling_velocity_ < 0)) {
    RunHideControlsAnimation();
    return;
  }

  RunResetControlsAnimation();
}

const gfx::VectorIcon& GetVectorIconForMediaAction(MediaSessionAction action) {
  switch (action) {
    case MediaSessionAction::kPreviousTrack:
      return kLockScreenPreviousTrackIcon;
    case MediaSessionAction::kPause:
      return kLockScreenPauseIcon;
    case MediaSessionAction::kNextTrack:
      return kLockScreenNextTrackIcon;
    case MediaSessionAction::kPlay:
      return kLockScreenPlayIcon;
    case MediaSessionAction::kSeekBackward:
      return kLockScreenSeekBackwardIcon;
    case MediaSessionAction::kSeekForward:
      return kLockScreenSeekForwardIcon;

    case MediaSessionAction::kStop:
    case MediaSessionAction::kSkipAd:
    case MediaSessionAction::kSeekTo:
    case MediaSessionAction::kScrubTo:
      NOTREACHED();
      break;
  }

  NOTREACHED();
  return gfx::kNoneIcon;
}

bool MediaControlsProgressView::OnMousePressed(const ui::MouseEvent& event) {
  gfx::Point location_in_bar(event.location());
  ConvertPointToTarget(this, this->progress_bar_, &location_in_bar);
  if (!event.IsOnlyLeftMouseButton() ||
      !progress_bar_->GetLocalBounds().Contains(location_in_bar)) {
return false;
}

  HandleSeeking(location_in_bar);
return true;
}

gfx::Size LockScreenMediaControlsView::CalculatePreferredSize() const {
  return gfx::Size(kMediaControlsTotalWidthDp, kMediaControlsTotalHeightDp);
}

  TestMediaController* media_controller() const {
    return media_controller_.get();
  }

void MediaControlsProgressView::SetDuration(const base::string16& duration) {
   duration_->SetText(duration);
 }

void LockScreenMediaControlsView::SeekTo(double seek_progress) {
  DCHECK(position_.has_value());

  media_controller_remote_->SeekTo(seek_progress * position_->duration());
}

void LockScreenMediaControlsView::MediaSessionChanged(
    const base::Optional<base::UnguessableToken>& request_id) {
  if (!media_session_id_.has_value()) {
    media_session_id_ = request_id;
    return;
  }

  if (hide_controls_timer_->IsRunning() && request_id == media_session_id_) {
    hide_controls_timer_->Stop();
    enabled_actions_.clear();
  }

  if (request_id != media_session_id_) {
    hide_controls_timer_->Start(FROM_HERE, kNextMediaDelay,
                                hide_media_controls_);
  }
}

const views::ImageView* MediaControlsHeaderView::app_icon_for_testing() const {
   return app_icon_view_;
 }

   const views::ImageView* icon_view() const {
     return header_row()->app_icon_for_testing();
   }

void LockScreenMediaControlsView::FlushForTesting() {
  media_controller_remote_.FlushForTesting();
}

 views::View* LockScreenMediaControlsView::GetMiddleSpacingView() {
  return middle_spacing_.get();
}

void LockScreenMediaControlsView::ButtonPressed(views::Button* sender,
const ui::Event& event) {
  if (sender == close_button_) {
    Dismiss();
    return;
  }
if (!base::Contains(enabled_actions_,
media_message_center::GetActionFromButtonTag(*sender)) ||
!media_session_id_.has_value()) {
return;
}

media_session::PerformMediaSessionAction(
media_message_center::GetActionFromButtonTag(*sender),
media_controller_remote_);
}

  NonAccessibleView* button_row() const {
    return media_controls_view_->button_row_;
  }

void LockScreenMediaControlsView::UpdateDrag(
    const gfx::Point& location_in_screen) {
  is_in_drag_ = true;
  int drag_delta = location_in_screen.y() - initial_drag_point_.y();

  if (contents_view_->bounds().bottom() + drag_delta >=
      GetLocalBounds().bottom()) {
    return;
  }

  gfx::Transform transform;
  transform.Translate(0, drag_delta);
  contents_view_->layer()->SetTransform(transform);
  UpdateOpacity();
}

  void SimulateMediaSessionChanged(
      media_session::mojom::MediaPlaybackState playback_state) {
    media_controls_view_->MediaSessionChanged(base::UnguessableToken::Create());

    media_session::mojom::MediaSessionInfoPtr session_info(
        media_session::mojom::MediaSessionInfo::New());
    session_info->playback_state = playback_state;

    media_controls_view_->MediaSessionInfoChanged(session_info.Clone());
  }

  const base::string16& GetAppName() const {
    return header_row()->app_name_for_testing();
  }

MediaControlsProgressView::MediaControlsProgressView(
base::RepeatingCallback<void(double)> seek_callback)
: seek_callback_(std::move(seek_callback)) {
SetLayoutManager(std::make_unique<views::BoxLayout>(
      views::BoxLayout::Orientation::kVertical, kProgressViewInsets));

  progress_bar_ = AddChildView(std::make_unique<views::ProgressBar>(5, false));
  progress_bar_->SetBorder(views::CreateEmptyBorder(kProgressBarInsets));

// Font list for text views.
gfx::Font default_font;
int font_size_delta = kProgressTimeFontSize - default_font.GetFontSize();
gfx::Font font = default_font.Derive(font_size_delta, gfx::Font::NORMAL,
gfx::Font::Weight::NORMAL);
gfx::FontList font_list(font);

auto time_view = std::make_unique<views::View>();
auto* time_view_layout =
time_view->SetLayoutManager(std::make_unique<views::FlexLayout>());
time_view_layout->SetOrientation(views::LayoutOrientation::kHorizontal)
.SetMainAxisAlignment(views::LayoutAlignment::kCenter)
.SetCrossAxisAlignment(views::LayoutAlignment::kCenter)
.SetCollapseMargins(true);

auto progress_time = std::make_unique<views::Label>();
progress_time->SetFontList(font_list);
progress_time->SetEnabledColor(SK_ColorWHITE);
progress_time->SetAutoColorReadabilityEnabled(false);
progress_time_ = time_view->AddChildView(std::move(progress_time));

auto time_spacing = std::make_unique<views::View>();
time_spacing->SetPreferredSize(kTimeSpacingSize);
time_spacing->SetProperty(views::kFlexBehaviorKey,
views::FlexSpecification::ForSizeRule(
views::MinimumFlexSizeRule::kPreferred,
views::MaximumFlexSizeRule::kUnbounded));
time_view->AddChildView(std::move(time_spacing));

auto duration = std::make_unique<views::Label>();
duration->SetFontList(font_list);
duration->SetEnabledColor(SK_ColorWHITE);
duration->SetAutoColorReadabilityEnabled(false);
duration_ = time_view->AddChildView(std::move(duration));

AddChildView(std::move(time_view));
}

  void EnableAllActions() {
    actions_.insert(MediaSessionAction::kPlay);
    actions_.insert(MediaSessionAction::kPause);
    actions_.insert(MediaSessionAction::kPreviousTrack);
    actions_.insert(MediaSessionAction::kNextTrack);
    actions_.insert(MediaSessionAction::kSeekBackward);
    actions_.insert(MediaSessionAction::kSeekForward);
    actions_.insert(MediaSessionAction::kStop);

    NotifyUpdatedActions();
  }

void MediaControlsHeaderView::SetAppIcon(const gfx::ImageSkia& img) {
  app_icon_view_->SetImage(img);
}

  explicit AnimationWaiter(views::View* host)
      : animator_(host->layer()->GetAnimator()) {
    animator_->AddObserver(this);
  }

void MediaControlsHeaderView::SetAppName(const base::string16& name) {
   app_name_view_->SetText(name);
 }

void LockScreenMediaControlsView::Dismiss() {
  media_controller_remote_->Stop();
  hide_media_controls_.Run();
}

void LockScreenMediaControlsView::OnGestureEvent(ui::GestureEvent* event) {
  gfx::Point point_in_screen = event->location();
  ConvertPointToScreen(this, &point_in_screen);

  switch (event->type()) {
    case ui::ET_SCROLL_FLING_START:
    case ui::ET_GESTURE_SCROLL_BEGIN: {
      if (is_in_drag_)
        break;

      initial_drag_point_ = point_in_screen;
      is_in_drag_ = true;
      event->SetHandled();
      break;
    }
    case ui::ET_GESTURE_SCROLL_UPDATE: {
      last_fling_velocity_ = event->details().scroll_y();
      UpdateDrag(point_in_screen);
      event->SetHandled();
      break;
    }
    case ui::ET_GESTURE_END: {
      if (!is_in_drag_)
        break;

      EndDrag();
      event->SetHandled();
      break;
    }
    default:
      break;
  }
}

void LockScreenMediaControlsView::MediaSessionInfoChanged(
    media_session::mojom::MediaSessionInfoPtr session_info) {
  if (hide_controls_timer_->IsRunning())
    return;

  if (!media_controls_enabled_.Run() || !session_info) {
    hide_media_controls_.Run();
  } else if (!IsDrawn() &&
             session_info->playback_state ==
                 media_session::mojom::MediaPlaybackState::kPaused) {
    hide_media_controls_.Run();
  } else if (!IsDrawn()) {
    show_media_controls_.Run();
  }

  if (IsDrawn()) {
    SetIsPlaying(session_info &&
                 session_info->playback_state ==
                     media_session::mojom::MediaPlaybackState::kPlaying);
  }
}

 void LockScreenMediaControlsView::Layout() {
  contents_view_->SetBoundsRect(GetContentsBounds());
}

   media_message_center::MediaControlsProgressView* progress_view() const {
     return media_controls_view_->progress_;
   }

void LockScreenMediaControlsView::CreateMediaButton(
    int size,
    MediaSessionAction action,
    const base::string16& accessible_name) {
  auto button = views::CreateVectorImageButton(this);
  button->set_tag(static_cast<int>(action));
  button->SetPreferredSize(kMediaButtonSize);
  button->SetAccessibleName(accessible_name);
  button->SetFocusBehavior(views::View::FocusBehavior::ALWAYS);

  views::SetImageFromVectorIcon(button.get(),
                                GetVectorIconForMediaAction(action), size,
                                kMediaButtonColor);

  button_row_->AddChildView(std::move(button));
}

 void MediaControlsHeaderView::GetAccessibleNodeData(ui::AXNodeData* node_data) {
   node_data->SetName(app_name_view_->GetText());
 }

void LockScreenMediaControlsView::MediaSessionMetadataChanged(
    const base::Optional<media_session::MediaMetadata>& metadata) {
  if (hide_controls_timer_->IsRunning())
    return;

  media_session::MediaMetadata session_metadata =
      metadata.value_or(media_session::MediaMetadata());
  base::string16 source_title =
      session_metadata.source_title.empty()
          ? message_center::MessageCenter::Get()->GetSystemNotificationAppName()
          : session_metadata.source_title;
  header_row_->SetAppName(source_title);

  accessible_name_ =
      media_message_center::GetAccessibleNameFromMetadata(session_metadata);
}

  MediaControlsHeaderView* header_row() const {
    return media_controls_view_->header_row_;
  }

  void SimulateTab() {
    ui::KeyEvent pressed_tab(ui::ET_KEY_PRESSED, ui::VKEY_TAB, ui::EF_NONE);
    media_controls_view_->GetFocusManager()->OnKeyEvent(pressed_tab);
  }

  views::View* contents_view() const {
    return media_controls_view_->contents_view_;
  }

  views::ImageView* artwork_view() const {
     return media_controls_view_->session_artwork_;
   }

const char* LockScreenMediaControlsView::GetClassName() const {
  return kLockScreenMediaControlsViewName;
 }

void MediaControlsProgressView::UpdateProgress(
    const media_session::MediaPosition& media_position) {
  if (media_position.playback_rate() == 0 && update_progress_timer_.IsRunning())
    update_progress_timer_.Stop();

  base::TimeDelta current_position = media_position.GetPosition();
  base::TimeDelta duration = media_position.duration();

  double progress = current_position.InSecondsF() / duration.InSecondsF();
  SetBarProgress(progress);

  base::DurationFormatWidth time_format =
      duration >= base::TimeDelta::FromDays(1) ? base::DURATION_WIDTH_NARROW
                                               : base::DURATION_WIDTH_NUMERIC;

  base::string16 elapsed_time;
  bool elapsed_time_received = base::TimeDurationFormatWithSeconds(
      current_position, time_format, &elapsed_time);

  base::string16 total_time;
  bool total_time_received =
      base::TimeDurationFormatWithSeconds(duration, time_format, &total_time);

  if (elapsed_time_received && total_time_received) {
    if (duration < base::TimeDelta::FromHours(1)) {
      base::ReplaceFirstSubstringAfterOffset(
          &elapsed_time, 0, base::ASCIIToUTF16("0:"), base::ASCIIToUTF16(""));
      base::ReplaceFirstSubstringAfterOffset(
          &total_time, 0, base::ASCIIToUTF16("0:"), base::ASCIIToUTF16(""));
    }

    SetProgressTime(elapsed_time);
    SetDuration(total_time);
  }

  if (media_position.playback_rate() != 0) {
    base::TimeDelta update_frequency = base::TimeDelta::FromSecondsD(
        std::abs(1 / media_position.playback_rate()));
    update_progress_timer_.Start(
        FROM_HERE, update_frequency,
        base::Bind(&MediaControlsProgressView::UpdateProgress,
                   base::Unretained(this), media_position));
  }
 }

const base::string16& MediaControlsProgressView::progress_time_for_testing()
    const {
  return progress_time_->GetText();
}

 const base::string16& MediaControlsHeaderView::app_name_for_testing() const {
   return app_name_view_->GetText();
 }

void LockScreenMediaControlsView::OnMouseExited(const ui::MouseEvent& event) {
if (is_in_drag_ || contents_view_->layer()->GetAnimator()->is_animating())
return;

  close_button_->SetVisible(false);
}

void LockScreenMediaControlsView::UpdateActionButtonsVisibility() {
  std::set<MediaSessionAction> ignored_actions = {
      media_message_center::GetPlayPauseIgnoredAction(
          media_message_center::GetActionFromButtonTag(*play_pause_button_))};

  std::set<MediaSessionAction> visible_actions =
      media_message_center::GetTopVisibleActions(enabled_actions_,
                                                 ignored_actions, kMaxActions);

  for (auto* view : button_row_->children()) {
    views::Button* action_button = views::Button::AsButton(view);
    bool should_show = base::Contains(
        visible_actions,
        media_message_center::GetActionFromButtonTag(*action_button));

    action_button->SetVisible(should_show);
  }

  PreferredSizeChanged();
}

void LockScreenMediaControlsView::OnMouseEntered(const ui::MouseEvent& event) {
if (is_in_drag_ || contents_view_->layer()->GetAnimator()->is_animating())
return;

  close_button_->SetVisible(true);
}

  views::Button* GetButtonForAction(MediaSessionAction action) const {
    const auto& children = button_row()->children();
    const auto it = std::find_if(
        children.begin(), children.end(), [action](const views::View* v) {
          return views::Button::AsButton(v)->tag() == static_cast<int>(action);
        });

    if (it == children.end())
      return nullptr;

    return views::Button::AsButton(*it);
  }
