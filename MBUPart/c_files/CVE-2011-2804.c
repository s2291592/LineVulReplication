virtual std::string GetKeyboardOverlayId(const std::string& input_method_id) {
if (!initialized_successfully_)
return "";

    return chromeos::GetKeyboardOverlayId(input_method_id);
}

static void IBusBusNameOwnerChangedCallback(
      IBusBus* bus,
      const gchar* name, const gchar* old_name, const gchar* new_name,
      gpointer user_data) {
DCHECK(name);
DCHECK(old_name);
DCHECK(new_name);
    DLOG(INFO) << "Name owner is changed: name=" << name
               << ", old_name=" << old_name << ", new_name=" << new_name;

if (name != std::string("org.freedesktop.IBus.Config")) {
// Not a signal for ibus-memconf.
return;
}

const std::string empty_string;
if (old_name != empty_string || new_name == empty_string) {
// ibus-memconf died?
LOG(WARNING) << "Unexpected name owner change: name=" << name
<< ", old_name=" << old_name << ", new_name=" << new_name;
// TODO(yusukes): it might be nice to set |ibus_config_| to NULL and call
      // |connection_change_handler_| with false here to allow Chrome to
// recover all input method configurations when ibus-memconf is
// automatically restarted by ibus-daemon. Though ibus-memconf is pretty
// stable and unlikely crashes.
return;
}

    LOG(INFO) << "IBus config daemon is started. Recovering ibus_config_";
    g_return_if_fail(user_data);
    InputMethodStatusConnection* self
        = static_cast<InputMethodStatusConnection*>(user_data);

// Try to recover |ibus_config_|. If the |ibus_config_| object is
    // successfully created, |connection_change_handler_| will be called to
// notify Chrome that IBus is ready.
    self->MaybeRestoreConnections();
}

void UpdateProperty(IBusProperty* ibus_prop) {
    DLOG(INFO) << "UpdateProperty";
    DCHECK(ibus_prop);
    // You can call
    //   LOG(INFO) << "\n" << PrintProp(ibus_prop, 0);
    // here to dump |ibus_prop|.
    ImePropertyList prop_list;  // our representation.
    if (!FlattenProperty(ibus_prop, &prop_list)) {
      // Don't update the UI on errors.
      LOG(ERROR) << "Malformed properties are detected";
      return;
    }
    // Notify the change.
    if (!prop_list.empty()) {
      update_ime_property_(language_library_, prop_list);
    }
}

  void Observe(NotificationType type,
               const NotificationSource& source,
               const NotificationDetails& details) {
    if (type.value == NotificationType::APP_TERMINATING) {
      notification_registrar_.RemoveAll();
      StopInputMethodDaemon();
#if !defined(TOUCH_UI)
      candidate_window_controller_.reset(NULL);
#endif
    }
  }

void MaybeRestoreConnections() {
if (IBusConnectionsAreAlive()) {
return;
}
MaybeCreateIBus();
MaybeRestoreIBusConfig();
if (IBusConnectionsAreAlive()) {
ConnectPanelServiceSignals();
      if (connection_change_handler_) {
        LOG(INFO) << "Notifying Chrome that IBus is ready.";
        connection_change_handler_(language_library_, true);
      }
}
}

void UpdateUI(const char* current_global_engine_id) {
DCHECK(current_global_engine_id);

const IBusEngineInfo* engine_info = NULL;
for (size_t i = 0; i < arraysize(kIBusEngines); ++i) {
if (kIBusEngines[i].name == std::string(current_global_engine_id)) {
engine_info = &kIBusEngines[i];
break;
}
}

if (!engine_info) {
LOG(ERROR) << current_global_engine_id
<< " is not found in the input method white-list.";
return;
}

InputMethodDescriptor current_input_method =
CreateInputMethodDescriptor(engine_info->name,
engine_info->longname,
engine_info->layout,
engine_info->language);

    DLOG(INFO) << "Updating the UI. ID:" << current_input_method.id
               << ", keyboard_layout:" << current_input_method.keyboard_layout;

// Notify the change to update UI.
    current_input_method_changed_(language_library_, current_input_method);
}

std::string PrintPropList(IBusPropList *prop_list, int tree_level) {
  if (!prop_list) {
    return "";
  }

  std::stringstream stream;
  for (int i = 0;; ++i) {
    IBusProperty* prop = ibus_prop_list_get(prop_list, i);
    if (!prop) {
      break;
    }
    stream << PrintProp(prop, tree_level);
  }
  return stream.str();
}

void MaybeChangeCurrentKeyboardLayout(const std::string& section,
                                        const std::string& config_name,
                                        const ImeConfigValue& value) {

// If there is only one input method which is a keyboard layout, we'll
// change the keyboard layout per the only one input method now
// available.
if (section == language_prefs::kGeneralSectionName &&
config_name == language_prefs::kPreloadEnginesConfigName &&
ContainOnlyOneKeyboardLayout(value)) {
// We shouldn't use SetCurrentKeyboardLayoutByName() here. See
// comments at ChangeCurrentInputMethod() for details.
ChangeCurrentInputMethodFromId(value.string_list_value[0]);
}
}

static void FocusInCallback(IBusPanelService* panel,
                              const gchar* path,
                              gpointer user_data) {
    g_return_if_fail(user_data);
    InputMethodStatusConnection* self
        = static_cast<InputMethodStatusConnection*>(user_data);
    self->FocusIn(path);
}

  void SendHandwritingStroke(const HandwritingStroke& stroke) {
     if (stroke.size() < 2) {
       LOG(WARNING) << "Empty stroke data or a single dot is passed.";
       return;
    }

    IBusInputContext* context = GetInputContext(input_context_path_, ibus_);
    if (!context) {
      return;
    }

    const size_t raw_stroke_size = stroke.size() * 2;
    scoped_array<double> raw_stroke(new double[raw_stroke_size]);
    for (size_t n = 0; n < stroke.size(); ++n) {
      raw_stroke[n * 2] = stroke[n].first;  // x
      raw_stroke[n * 2 + 1] = stroke[n].second;  // y
    }
    ibus_input_context_process_hand_writing_event(
        context, raw_stroke.get(), raw_stroke_size);
     g_object_unref(context);
   }

std::string ChromeOSGetKeyboardOverlayId(const std::string& input_method_id) {
  for (size_t i = 0; i < arraysize(kKeyboardOverlayMap); ++i) {
    if (kKeyboardOverlayMap[i].input_method_id == input_method_id) {
      return kKeyboardOverlayMap[i].keyboard_overlay_id;
    }
}
  return "";
}

  virtual const ImePropertyList& current_ime_properties() const {
     return current_ime_properties_;
   }

  void SetEnableAutoImeShutdown(bool enable) {
    enable_auto_ime_shutdown_ = enable;
  }

bool ChromeOSStopInputMethodProcess(InputMethodStatusConnection* connection) {
  g_return_val_if_fail(connection, false);
  return connection->StopInputMethodProcess();
}

   virtual ~InputMethodLibraryImpl() {
   }

void UpdateProperty(const ImePropertyList& prop_list) {
for (size_t i = 0; i < prop_list.size(); ++i) {
FindAndUpdateProperty(prop_list[i], &current_ime_properties_);
}

// Update input method menu
    FOR_EACH_OBSERVER(Observer, observers_,
PropertyListChanged(this,
current_ime_properties_));
}

InputMethodLibraryImpl()
      : input_method_status_connection_(NULL),
should_launch_ime_(false),
ime_connected_(false),
defer_ime_startup_(false),
enable_auto_ime_shutdown_(true),
ibus_daemon_process_handle_(base::kNullProcessHandle),
#if !defined(TOUCH_UI)
initialized_successfully_(false),
candidate_window_controller_(NULL) {
#else
initialized_successfully_(false) {
#endif
// Observe APP_TERMINATING to stop input method daemon gracefully.
// We should not use APP_EXITING here since logout might be canceled by
// JavaScript after APP_EXITING is sent (crosbug.com/11055).
// Note that even if we fail to stop input method daemon from
// Chrome in case of a sudden crash, we have a way to do it from an
// upstart script. See crosbug.com/6515 and crosbug.com/6995 for
// details.
notification_registrar_.Add(this, NotificationType::APP_TERMINATING,
NotificationService::AllSources());
}

// Initializes the object. On success, returns true on and sets
// initialized_successfully_ to true.
//
// Note that we start monitoring input method status in here in Init()
// to avoid a potential race. If we start the monitoring right after
// starting ibus-daemon, there is a higher chance of a race between
// Chrome and ibus-daemon to occur.
bool Init() {
DCHECK(!initialized_successfully_) << "Already initialized";

    if (!CrosLibrary::Get()->EnsureLoaded())
      return false;
    input_method_status_connection_ = chromeos::MonitorInputMethodStatus(
        this,
        &InputMethodChangedHandler,
        &RegisterPropertiesHandler,
        &UpdatePropertyHandler,
        &ConnectionChangeHandler);
    if (!input_method_status_connection_)
      return false;

initialized_successfully_ = true;
return true;
}

virtual ~InputMethodLibraryImpl() {
}

  virtual void AddObserver(Observer* observer) {
if (!observers_.size()) {
observer->FirstObserverIsAdded(this);
}
observers_.AddObserver(observer);
}

  virtual void RemoveObserver(Observer* observer) {
observers_.RemoveObserver(observer);
}

  virtual InputMethodDescriptors* GetActiveInputMethods() {
    chromeos::InputMethodDescriptors* result =
        new chromeos::InputMethodDescriptors;
// Build the active input method descriptors from the active input
// methods cache |active_input_method_ids_|.
for (size_t i = 0; i < active_input_method_ids_.size(); ++i) {
const std::string& input_method_id = active_input_method_ids_[i];
      const InputMethodDescriptor* descriptor =
          chromeos::input_method::GetInputMethodDescriptorFromId(
input_method_id);
if (descriptor) {
result->push_back(*descriptor);
} else {
LOG(ERROR) << "Descriptor is not found for: " << input_method_id;
}
}
// Initially active_input_method_ids_ is empty. In this case, just
// returns the fallback input method descriptor.
if (result->empty()) {
LOG(WARNING) << "No active input methods found.";
result->push_back(input_method::GetFallbackInputMethodDescriptor());
}
return result;
}

virtual size_t GetNumActiveInputMethods() {
    scoped_ptr<InputMethodDescriptors> input_methods(GetActiveInputMethods());
return input_methods->size();
}

  virtual InputMethodDescriptors* GetSupportedInputMethods() {
if (!initialized_successfully_) {
// If initialization was failed, return the fallback input method,
// as this function is guaranteed to return at least one descriptor.
      InputMethodDescriptors* result = new InputMethodDescriptors;
result->push_back(input_method::GetFallbackInputMethodDescriptor());
return result;
}

// This never returns NULL.
    return chromeos::GetSupportedInputMethodDescriptors();
}

virtual void ChangeInputMethod(const std::string& input_method_id) {
// Changing the input method isn't guaranteed to succeed here, but we
// should remember the last one regardless. See comments in
// FlushImeConfig() for details.
tentative_current_input_method_id_ = input_method_id;
// If the input method daemon is not running and the specified input
// method is a keyboard layout, switch the keyboard directly.
if (ibus_daemon_process_handle_ == base::kNullProcessHandle &&
        chromeos::input_method::IsKeyboardLayout(input_method_id)) {
// We shouldn't use SetCurrentKeyboardLayoutByName() here. See
// comments at ChangeCurrentInputMethod() for details.
ChangeCurrentInputMethodFromId(input_method_id);
} else {
// Otherwise, start the input method daemon, and change the input
// method via the daemon.
StartInputMethodDaemon();
// ChangeInputMethodViaIBus() fails if the IBus daemon is not
// ready yet. In this case, we'll defer the input method change
// until the daemon is ready.
if (!ChangeInputMethodViaIBus(input_method_id)) {
VLOG(1) << "Failed to change the input method to " << input_method_id
<< " (deferring)";
}
}
}

virtual void SetImePropertyActivated(const std::string& key,
bool activated) {
if (!initialized_successfully_)
return;

DCHECK(!key.empty());
    chromeos::SetImePropertyActivated(
        input_method_status_connection_, key.c_str(), activated);
}

virtual bool InputMethodIsActivated(const std::string& input_method_id) {
    scoped_ptr<InputMethodDescriptors> active_input_method_descriptors(
        GetActiveInputMethods());
for (size_t i = 0; i < active_input_method_descriptors->size(); ++i) {
if (active_input_method_descriptors->at(i).id == input_method_id) {
return true;
}
}
return false;
}

virtual bool SetImeConfig(const std::string& section,
const std::string& config_name,
                            const ImeConfigValue& value) {
// If the config change is for preload engines, update the active
// input methods cache |active_input_method_ids_| here. We need to
// update the cache before actually flushing the config. since we need
// to return active input methods from GetActiveInputMethods() before
// the input method daemon starts. For instance, we need to show the
// list of available input methods (keyboard layouts) on the login
// screen before the input method starts.
if (section == language_prefs::kGeneralSectionName &&
config_name == language_prefs::kPreloadEnginesConfigName &&
        value.type == ImeConfigValue::kValueTypeStringList) {
active_input_method_ids_ = value.string_list_value;
}

// Before calling FlushImeConfig(), start input method process if necessary.
MaybeStartInputMethodDaemon(section, config_name, value);

const ConfigKeyType key = std::make_pair(section, config_name);
current_config_values_[key] = value;
if (ime_connected_) {
pending_config_requests_[key] = value;
FlushImeConfig();
}

// Stop input method process if necessary.
MaybeStopInputMethodDaemon(section, config_name, value);
// Change the current keyboard layout if necessary.
MaybeChangeCurrentKeyboardLayout(section, config_name, value);
return pending_config_requests_.empty();
}

  virtual InputMethodDescriptor previous_input_method() const {
if (previous_input_method_.id.empty()) {
return input_method::GetFallbackInputMethodDescriptor();
}
return previous_input_method_;
}

  virtual InputMethodDescriptor current_input_method() const {
if (current_input_method_.id.empty()) {
return input_method::GetFallbackInputMethodDescriptor();
}
return current_input_method_;
}

  virtual const ImePropertyList& current_ime_properties() const {
return current_ime_properties_;
}

virtual std::string GetKeyboardOverlayId(const std::string& input_method_id) {
if (!initialized_successfully_)
return "";

    return chromeos::GetKeyboardOverlayId(input_method_id);
}

  virtual void SendHandwritingStroke(const HandwritingStroke& stroke) {
if (!initialized_successfully_)
return;
    chromeos::SendHandwritingStroke(input_method_status_connection_, stroke);
}

virtual void CancelHandwritingStrokes(int stroke_count) {
if (!initialized_successfully_)
return;
// TODO(yusukes): Rename the libcros function to CancelHandwritingStrokes.
    chromeos::CancelHandwriting(input_method_status_connection_, stroke_count);
}

private:
// Returns true if the given input method config value is a single
// element string list that contains an input method ID of a keyboard
// layout.
bool ContainOnlyOneKeyboardLayout(
      const ImeConfigValue& value) {
    return (value.type == ImeConfigValue::kValueTypeStringList &&
value.string_list_value.size() == 1 &&
            chromeos::input_method::IsKeyboardLayout(
value.string_list_value[0]));
}

// Starts input method daemon based on the |defer_ime_startup_| flag and
// input method configuration being updated. |section| is a section name of
// the input method configuration (e.g. "general", "general/hotkey").
// |config_name| is a name of the configuration (e.g. "preload_engines",
// "previous_engine"). |value| is the configuration value to be set.
void MaybeStartInputMethodDaemon(const std::string& section,
const std::string& config_name,
                                   const ImeConfigValue& value) {
if (section == language_prefs::kGeneralSectionName &&
config_name == language_prefs::kPreloadEnginesConfigName &&
        value.type == ImeConfigValue::kValueTypeStringList &&
!value.string_list_value.empty()) {
// If there is only one input method which is a keyboard layout,
// we don't start the input method processes.  When
// |defer_ime_startup_| is true, we don't start it either.
if (ContainOnlyOneKeyboardLayout(value) || defer_ime_startup_) {
// Do not start the input method daemon.
return;
}

// Otherwise, start the input method daemon.
const bool just_started = StartInputMethodDaemon();
if (!just_started) {
// The daemon is already running.
// Do not |update tentative_current_input_method_id_|.
return;
}

// The daemon has just been started. To select the initial input method
// engine correctly, update |tentative_current_input_method_id_|.
if (tentative_current_input_method_id_.empty()) {
// Since the |current_input_method_| is in the preloaded engine list,
// switch to the engine. This is necessary ex. for the following case:
// 1. "xkb:jp::jpn" is enabled. ibus-daemon is not running.
// 2. A user enabled "mozc" via DOMUI as well. ibus-daemon is started
//    and the preloaded engine list is set to "mozc,xkb:jp::jpn".
// 3. ibus-daemon selects "mozc" as its current engine since "mozc" is
//    on top of the preloaded engine list.
// 4. Therefore, we have to change the current engine to "xkb:jp::jpn"
//    explicitly to avoid unexpected engine switch.
tentative_current_input_method_id_ = current_input_method_.id;
}

if (std::find(value.string_list_value.begin(),
value.string_list_value.end(),
tentative_current_input_method_id_)
== value.string_list_value.end()) {
// The |current_input_method_| is NOT in the preloaded engine list.
// In this case, ibus-daemon will automatically select the first engine
// in the list, |value.string_list_value[0]|, and send global engine
// changed signal to Chrome. See crosbug.com/13406.
tentative_current_input_method_id_.clear();
}
}
}

// Stops input method daemon based on the |enable_auto_ime_shutdown_| flag
// and input method configuration being updated.
// See also: MaybeStartInputMethodDaemon().
void MaybeStopInputMethodDaemon(const std::string& section,
const std::string& config_name,
                                  const ImeConfigValue& value) {
// If there is only one input method which is a keyboard layout,
// and |enable_auto_ime_shutdown_| is true, we'll stop the input
// method daemon.
if (section == language_prefs::kGeneralSectionName &&
config_name == language_prefs::kPreloadEnginesConfigName &&
ContainOnlyOneKeyboardLayout(value) &&
enable_auto_ime_shutdown_) {
StopInputMethodDaemon();
}
}

// Change the keyboard layout per input method configuration being
// updated, if necessary. See also: MaybeStartInputMethodDaemon().
  void MaybeChangeCurrentKeyboardLayout(const std::string& section,
                                        const std::string& config_name,
                                        const ImeConfigValue& value) {

// If there is only one input method which is a keyboard layout, we'll
// change the keyboard layout per the only one input method now
// available.
if (section == language_prefs::kGeneralSectionName &&
config_name == language_prefs::kPreloadEnginesConfigName &&
ContainOnlyOneKeyboardLayout(value)) {
// We shouldn't use SetCurrentKeyboardLayoutByName() here. See
// comments at ChangeCurrentInputMethod() for details.
ChangeCurrentInputMethodFromId(value.string_list_value[0]);
}
}

// Changes the current input method to |input_method_id| via IBus
// daemon. If the id is not in the preload_engine list, this function
// changes the current method to the first preloaded engine. Returns
// true if the current engine is switched to |input_method_id| or the
// first one.
bool ChangeInputMethodViaIBus(const std::string& input_method_id) {
if (!initialized_successfully_)
return false;

std::string input_method_id_to_switch = input_method_id;

if (!InputMethodIsActivated(input_method_id)) {
// This path might be taken if prefs::kLanguageCurrentInputMethod (NOT
// synced with cloud) and kLanguagePreloadEngines (synced with cloud) are
// mismatched. e.g. the former is 'xkb:us::eng' and the latter (on the
// sync server) is 'xkb:jp::jpn,mozc'.
      scoped_ptr<InputMethodDescriptors> input_methods(GetActiveInputMethods());
DCHECK(!input_methods->empty());
if (!input_methods->empty()) {
input_method_id_to_switch = input_methods->at(0).id;
LOG(INFO) << "Can't change the current input method to "
<< input_method_id << " since the engine is not preloaded. "
<< "Switch to " << input_method_id_to_switch << " instead.";
}
}

    if (chromeos::ChangeInputMethod(input_method_status_connection_,
                                    input_method_id_to_switch.c_str())) {
return true;
}

// ChangeInputMethod() fails if the IBus daemon is not yet ready.
LOG(ERROR) << "Can't switch input method to " << input_method_id_to_switch;
return false;
}

// Flushes the input method config data. The config data is queued up in
// |pending_config_requests_| until the config backend (ibus-memconf)
// starts.
void FlushImeConfig() {
if (!initialized_successfully_)
return;

bool active_input_methods_are_changed = false;
InputMethodConfigRequests::iterator iter =
pending_config_requests_.begin();
while (iter != pending_config_requests_.end()) {
const std::string& section = iter->first.first;
const std::string& config_name = iter->first.second;
      ImeConfigValue& value = iter->second;

if (config_name == language_prefs::kPreloadEnginesConfigName &&
!tentative_current_input_method_id_.empty()) {
// We should use |tentative_current_input_method_id_| as the initial
// active input method for the following reasons:
//
// 1) Calls to ChangeInputMethod() will fail if the input method has not
// yet been added to preload_engines.  As such, the call is deferred
// until after all config values have been sent to the IME process.
//
// 2) We might have already changed the current input method to one
// of XKB layouts without going through the IBus daemon (we can do
// it without the IBus daemon started).
std::vector<std::string>::iterator engine_iter = std::find(
value.string_list_value.begin(),
value.string_list_value.end(),
tentative_current_input_method_id_);
if (engine_iter != value.string_list_value.end()) {
// Use std::rotate to keep the relative order of engines the same e.g.
// from "A,B,C" to "C,A,B".
// We don't have to |active_input_method_ids_|, which decides the
// order of engines in the switcher menu, since the relative order
// of |value.string_list_value| is not changed.
std::rotate(value.string_list_value.begin(),
engine_iter,  // this becomes the new first element
value.string_list_value.end());
} else {
LOG(WARNING) << tentative_current_input_method_id_
<< " is not in preload_engines: " << value.ToString();
}
tentative_current_input_method_id_.erase();
}

      if (chromeos::SetImeConfig(input_method_status_connection_,
                                 section.c_str(),
                                 config_name.c_str(),
                                 value)) {
// Check if it's a change in active input methods.
if (config_name == language_prefs::kPreloadEnginesConfigName) {
active_input_methods_are_changed = true;
VLOG(1) << "Updated preload_engines: " << value.ToString();
}
// Successfully sent. Remove the command and proceed to the next one.
pending_config_requests_.erase(iter++);
} else {
// If SetImeConfig() fails, subsequent calls will likely fail.
break;
}
}

// Notify the current input method and the number of active input methods to
// the UI so that the UI could determine e.g. if it should show/hide the
// input method indicator, etc. We have to call FOR_EACH_OBSERVER here since
// updating "preload_engine" does not necessarily trigger a DBus signal such
// as "global-engine-changed". For example,
// 1) If we change the preload_engine from "xkb:us:intl:eng" (i.e. the
//    indicator is hidden) to "xkb:us:intl:eng,mozc", we have to update UI
//    so it shows the indicator, but no signal is sent from ibus-daemon
//    because the current input method is not changed.
// 2) If we change the preload_engine from "xkb:us::eng,mozc" (i.e. the
//    indicator is shown and ibus-daemon is started) to "xkb:us::eng", we
//    have to update UI so it hides the indicator, but we should not expect
//    that ibus-daemon could send a DBus signal since the daemon is killed
//    right after this FlushImeConfig() call.
if (active_input_methods_are_changed) {
// The |current_input_method_| member might be stale here as
// SetImeConfig("preload_engine") call above might change the
// current input method in ibus-daemon (ex. this occurs when the
// input method currently in use is removed from the options
// page). However, it should be safe to use the member here,
// for the following reasons:
// 1. If ibus-daemon is to be killed, we'll switch to the only one
//    keyboard layout, and observers are notified. See
//    MaybeStopInputMethodDaemon() for details.
// 2. Otherwise, "global-engine-changed" signal is delivered from
//    ibus-daemon, and observers are notified. See
//    InputMethodChangedHandler() for details.
const size_t num_active_input_methods = GetNumActiveInputMethods();
      FOR_EACH_OBSERVER(Observer, observers_,
ActiveInputMethodsChanged(this,
current_input_method_,
num_active_input_methods));
}
}

  // Called when the input method is changed in the IBus daemon
  // (ex. "global-engine-changed" is delivered from the IBus daemon).
  static void InputMethodChangedHandler(
      void* object,
      const chromeos::InputMethodDescriptor& current_input_method) {
// The handler is called when the input method method change is
// notified via a DBus connection. Since the DBus notificatiosn are
// handled in the UI thread, we can assume that this function always
// runs on the UI thread, but just in case.
if (!BrowserThread::CurrentlyOn(BrowserThread::UI)) {
LOG(ERROR) << "Not on UI thread";
return;
}

    InputMethodLibraryImpl* input_method_library =
        static_cast<InputMethodLibraryImpl*>(object);
    input_method_library->ChangeCurrentInputMethod(current_input_method);
}

  // Called when properties are registered in the IBus daemon.
  static void RegisterPropertiesHandler(
      void* object, const ImePropertyList& prop_list) {
// See comments in InputMethodChangedHandler.
if (!BrowserThread::CurrentlyOn(BrowserThread::UI)) {
LOG(ERROR) << "Not on UI thread";
return;
}

    InputMethodLibraryImpl* input_method_library =
        static_cast<InputMethodLibraryImpl*>(object);
    input_method_library->RegisterProperties(prop_list);
}

  // Called when properties are updated in the IBus daemon.
  static void UpdatePropertyHandler(
      void* object, const ImePropertyList& prop_list) {
// See comments in InputMethodChangedHandler.
if (!BrowserThread::CurrentlyOn(BrowserThread::UI)) {
LOG(ERROR) << "Not on UI thread";
return;
}

    InputMethodLibraryImpl* input_method_library =
        static_cast<InputMethodLibraryImpl*>(object);
    input_method_library->UpdateProperty(prop_list);
}

  // Called when 1) connection to ibus-daemon and ibus-memconf are established
  // or 2) connection to ibus-daemon is terminated.
  static void ConnectionChangeHandler(void* object, bool connected) {
// See comments in InputMethodChangedHandler.
if (!BrowserThread::CurrentlyOn(BrowserThread::UI)) {
LOG(ERROR) << "Not on UI thread";
return;
}

    InputMethodLibraryImpl* input_method_library =
        static_cast<InputMethodLibraryImpl*>(object);
    input_method_library->ime_connected_ = connected;
if (connected) {
      input_method_library->pending_config_requests_.clear();
      input_method_library->pending_config_requests_.insert(
          input_method_library->current_config_values_.begin(),
          input_method_library->current_config_values_.end());
      input_method_library->FlushImeConfig();
      input_method_library->ChangeInputMethod(
          input_method_library->previous_input_method().id);
      input_method_library->ChangeInputMethod(
          input_method_library->current_input_method().id);
}
}

// Changes the current input method from the given input method
// descriptor.  This function updates states like current_input_method_
// and notifies observers about the change (that will update the
// preferences), hence this function should always be used even if you
// just need to change the current keyboard layout.
  void ChangeCurrentInputMethod(const InputMethodDescriptor& new_input_method) {
if (current_input_method_.id != new_input_method.id) {
previous_input_method_ = current_input_method_;
current_input_method_ = new_input_method;

// Change the keyboard layout to a preferred layout for the input method.
if (!input_method::SetCurrentKeyboardLayoutByName(
current_input_method_.keyboard_layout)) {
LOG(ERROR) << "Failed to change keyboard layout to "
<< current_input_method_.keyboard_layout;
}

// Ask the first observer to update preferences. We should not ask every
// observer to do so. Otherwise, we'll end up updating preferences many
// times when many observers are attached (ex. many windows are opened),
// which is unnecessary and expensive.
      ObserverListBase<Observer>::Iterator it(observers_);
      Observer* first_observer = it.GetNext();
if (first_observer) {
first_observer->PreferenceUpdateNeeded(this,
previous_input_method_,
current_input_method_);
}
}

// Update input method indicators (e.g. "US", "DV") in Chrome windows.
// For now, we have to do this every time to keep indicators updated. See
// comments near the FOR_EACH_OBSERVER call in FlushImeConfig() for details.
const size_t num_active_input_methods = GetNumActiveInputMethods();
    FOR_EACH_OBSERVER(Observer, observers_,
InputMethodChanged(this,
current_input_method_,
num_active_input_methods));
}

// Changes the current input method from the given input method ID.
// This function is just a wrapper of ChangeCurrentInputMethod().
void ChangeCurrentInputMethodFromId(const std::string& input_method_id) {
    const chromeos::InputMethodDescriptor* descriptor =
        chromeos::input_method::GetInputMethodDescriptorFromId(
input_method_id);
if (descriptor) {
ChangeCurrentInputMethod(*descriptor);
} else {
LOG(ERROR) << "Descriptor is not found for: " << input_method_id;
}
}

// Registers the properties used by the current input method.
  void RegisterProperties(const ImePropertyList& prop_list) {
// |prop_list| might be empty. This means "clear all properties."
current_ime_properties_ = prop_list;

// Update input method menu
    FOR_EACH_OBSERVER(Observer, observers_,
PropertyListChanged(this,
current_ime_properties_));
}

// Starts the input method daemon. Unlike MaybeStopInputMethodDaemon(),
// this function always starts the daemon. Returns true if the daemon is
// started. Otherwise, e.g. the daemon is already started, returns false.
bool StartInputMethodDaemon() {
should_launch_ime_ = true;
return MaybeLaunchInputMethodDaemon();
}

// Updates the properties used by the current input method.
  void UpdateProperty(const ImePropertyList& prop_list) {
for (size_t i = 0; i < prop_list.size(); ++i) {
FindAndUpdateProperty(prop_list[i], &current_ime_properties_);
}

// Update input method menu
    FOR_EACH_OBSERVER(Observer, observers_,
PropertyListChanged(this,
current_ime_properties_));
}

// Launches an input method procsess specified by the given command
// line. On success, returns true and stores the process handle in
// |process_handle|. Otherwise, returns false, and the contents of
// |process_handle| is untouched. OnImeShutdown will be called when the
// process terminates.
bool LaunchInputMethodProcess(const std::string& command_line,
base::ProcessHandle* process_handle) {
std::vector<std::string> argv;
base::file_handle_mapping_vector fds_to_remap;
base::ProcessHandle handle = base::kNullProcessHandle;

// TODO(zork): export "LD_PRELOAD=/usr/lib/libcrash.so"
base::SplitString(command_line, ' ', &argv);
const bool result = base::LaunchApp(argv,
fds_to_remap,  // no remapping
false,  // wait
&handle);
if (!result) {
LOG(ERROR) << "Could not launch: " << command_line;
return false;
}

// g_child_watch_add is necessary to prevent the process from becoming a
// zombie.
// TODO(yusukes): port g_child_watch_add to base/process_utils_posix.cc.
const base::ProcessId pid = base::GetProcId(handle);
g_child_watch_add(pid,
reinterpret_cast<GChildWatchFunc>(OnImeShutdown),
this);

*process_handle = handle;
VLOG(1) << command_line << " (PID=" << pid << ") is started";
return  true;
}

// Launches input method daemon if these are not yet running. Returns true if
// the daemon is started. Otherwise, e.g. the daemon is already started,
// returns false.
bool MaybeLaunchInputMethodDaemon() {
// CandidateWindowController requires libcros to be loaded. Besides,
// launching ibus-daemon without libcros loaded doesn't make sense.
if (!initialized_successfully_)
return false;

if (!should_launch_ime_) {
return false;
}

#if !defined(TOUCH_UI)
if (!candidate_window_controller_.get()) {
candidate_window_controller_.reset(new CandidateWindowController);
if (!candidate_window_controller_->Init()) {
LOG(WARNING) << "Failed to initialize the candidate window controller";
}
}
#endif

if (ibus_daemon_process_handle_ != base::kNullProcessHandle) {
return false;  // ibus-daemon is already running.
}

// TODO(zork): Send output to /var/log/ibus.log
const std::string ibus_daemon_command_line =
StringPrintf("%s --panel=disable --cache=none --restart --replace",
kIBusDaemonPath);
if (!LaunchInputMethodProcess(
ibus_daemon_command_line, &ibus_daemon_process_handle_)) {
LOG(ERROR) << "Failed to launch " << ibus_daemon_command_line;
return false;
}
return true;
}

// Called when the input method process is shut down.
static void OnImeShutdown(GPid pid,
gint status,
InputMethodLibraryImpl* library) {
if (library->ibus_daemon_process_handle_ != base::kNullProcessHandle &&
base::GetProcId(library->ibus_daemon_process_handle_) == pid) {
library->ibus_daemon_process_handle_ = base::kNullProcessHandle;
}

// Restart input method daemon if needed.
library->MaybeLaunchInputMethodDaemon();
}

// Stops the backend input method daemon. This function should also be
// called from MaybeStopInputMethodDaemon(), except one case where we
// stop the input method daemon at Chrome shutdown in Observe().
void StopInputMethodDaemon() {
if (!initialized_successfully_)
return;

should_launch_ime_ = false;
if (ibus_daemon_process_handle_ != base::kNullProcessHandle) {
const base::ProcessId pid = base::GetProcId(ibus_daemon_process_handle_);
      if (!chromeos::StopInputMethodProcess(input_method_status_connection_)) {
LOG(ERROR) << "StopInputMethodProcess IPC failed. Sending SIGTERM to "
<< "PID " << pid;
base::KillProcess(ibus_daemon_process_handle_, -1, false /* wait */);
}
VLOG(1) << "ibus-daemon (PID=" << pid << ") is terminated";
ibus_daemon_process_handle_ = base::kNullProcessHandle;
}
}

void SetDeferImeStartup(bool defer) {
VLOG(1) << "Setting DeferImeStartup to " << defer;
defer_ime_startup_ = defer;
}

void SetEnableAutoImeShutdown(bool enable) {
enable_auto_ime_shutdown_ = enable;
}

// NotificationObserver implementation:
void Observe(NotificationType type,
const NotificationSource& source,
const NotificationDetails& details) {
// Stop the input method daemon on browser shutdown.
if (type.value == NotificationType::APP_TERMINATING) {
notification_registrar_.RemoveAll();
StopInputMethodDaemon();
#if !defined(TOUCH_UI)
candidate_window_controller_.reset(NULL);
#endif
}
}

// A reference to the language api, to allow callbacks when the input method
// status changes.
  InputMethodStatusConnection* input_method_status_connection_;
  ObserverList<Observer> observers_;

// The input method which was/is selected.
  InputMethodDescriptor previous_input_method_;
  InputMethodDescriptor current_input_method_;

// The input method properties which the current input method uses. The list
// might be empty when no input method is used.
  ImePropertyList current_ime_properties_;

typedef std::pair<std::string, std::string> ConfigKeyType;
  typedef std::map<ConfigKeyType, ImeConfigValue> InputMethodConfigRequests;
// SetImeConfig requests that are not yet completed.
// Use a map to queue config requests, so we only send the last request for
// the same config key (i.e. we'll discard ealier requests for the same
// config key). As we discard old requests for the same config key, the order
// of requests doesn't matter, so it's safe to use a map.
InputMethodConfigRequests pending_config_requests_;

// Values that have been set via SetImeConfig().  We keep a copy available to
// resend if the ime restarts and loses its state.
InputMethodConfigRequests current_config_values_;

// This is used to register this object to APP_EXITING notification.
NotificationRegistrar notification_registrar_;

// True if we should launch the input method daemon.
bool should_launch_ime_;
// True if the connection to the IBus daemon is alive.
bool ime_connected_;
// If true, we'll defer the startup until a non-default method is
// activated.
bool defer_ime_startup_;
// True if we should stop input method daemon when there are no input
// methods other than one for the hardware keyboard.
bool enable_auto_ime_shutdown_;
// The ID of the tentative current input method (ex. "mozc"). This value
// can be different from the actual current input method, if
// ChangeInputMethod() fails.
// TODO(yusukes): clear this variable when a user logs in.
std::string tentative_current_input_method_id_;

// The process handle of the IBus daemon. kNullProcessHandle if it's not
// running.
base::ProcessHandle ibus_daemon_process_handle_;

// True if initialization is successfully done, meaning that libcros is
// loaded and input method status monitoring is started. This value
// should be checked where we call libcros functions.
bool initialized_successfully_;

// The candidate window.  This will be deleted when the APP_TERMINATING
// message is sent.
#if !defined(TOUCH_UI)
scoped_ptr<CandidateWindowController> candidate_window_controller_;
#endif

// The active input method ids cache.
std::vector<std::string> active_input_method_ids_;

DISALLOW_COPY_AND_ASSIGN(InputMethodLibraryImpl);
};

static InputMethodStatusConnection* GetConnection(
      void* language_library,
      LanguageCurrentInputMethodMonitorFunction current_input_method_changed,
      LanguageRegisterImePropertiesFunction register_ime_properties,
      LanguageUpdateImePropertyFunction update_ime_property,
      LanguageConnectionChangeMonitorFunction connection_change_handler) {
    DCHECK(language_library);
    DCHECK(current_input_method_changed),
    DCHECK(register_ime_properties);
    DCHECK(update_ime_property);
    InputMethodStatusConnection* object = GetInstance();
    if (!object->language_library_) {
      object->language_library_ = language_library;
      object->current_input_method_changed_ = current_input_method_changed;
      object->register_ime_properties_= register_ime_properties;
      object->update_ime_property_ = update_ime_property;
      object->connection_change_handler_ = connection_change_handler;
      object->MaybeRestoreConnections();
    } else if (object->language_library_ != language_library) {
      LOG(ERROR) << "Unknown language_library is passed";
    }
    return object;
}

  virtual void ChangeInputMethod(const std::string& input_method_id) {}

  virtual void SetEnableAutoImeShutdown(bool enable) {}

static void IBusBusConnectedCallback(IBusBus* bus, gpointer user_data) {
LOG(WARNING) << "IBus connection is recovered.";
    // ibus-daemon might be restarted, or the daemon was not running when Chrome
    // started. Anyway, since |ibus_| connection is now ready, it's possible to
    // create |ibus_config_| object by calling MaybeRestoreConnections().
    g_return_if_fail(user_data);
    InputMethodStatusConnection* self
        = static_cast<InputMethodStatusConnection*>(user_data);
    self->MaybeRestoreConnections();
}

void CrosMock::InitMockInputMethodLibrary() {
  InitMockLibraryLoader();
  if (mock_input_method_library_)
    return;
  mock_input_method_library_ = new StrictMock<MockInputMethodLibrary>();
  test_api()->SetInputMethodLibrary(mock_input_method_library_, true);
}

  virtual InputMethodDescriptor previous_input_method() const {
     return previous_input_method_;
   }

bool Init() {
DCHECK(!initialized_successfully_) << "Already initialized";

    if (!CrosLibrary::Get()->EnsureLoaded())
      return false;
    input_method_status_connection_ = chromeos::MonitorInputMethodStatus(
        this,
        &InputMethodChangedHandler,
        &RegisterPropertiesHandler,
        &UpdatePropertyHandler,
        &ConnectionChangeHandler);
    if (!input_method_status_connection_)
      return false;

initialized_successfully_ = true;
return true;
}

static void IBusBusGlobalEngineChangedCallback(
      IBusBus* bus, const gchar* engine_name, gpointer user_data) {
DCHECK(engine_name);
    DLOG(INFO) << "Global engine is changed to " << engine_name;
    g_return_if_fail(user_data);
    InputMethodStatusConnection* self
        = static_cast<InputMethodStatusConnection*>(user_data);
    self->UpdateUI(engine_name);
}

InputMethodStatusConnection* ChromeOSMonitorInputMethodStatus(
    void* language_library,
    LanguageCurrentInputMethodMonitorFunction current_input_method_changed,
    LanguageRegisterImePropertiesFunction register_ime_properties,
    LanguageUpdateImePropertyFunction update_ime_property,
    LanguageConnectionChangeMonitorFunction connection_changed) {
  DLOG(INFO) << "MonitorInputMethodStatus";
  return InputMethodStatusConnection::GetConnection(
      language_library,
      current_input_method_changed,
      register_ime_properties,
      update_ime_property,
      connection_changed);
}

   virtual void AddObserver(Observer* observer) {}

void CrosMock::SetStatusAreaMocksExpectations() {
  SetInputMethodLibraryStatusAreaExpectations();
  SetNetworkLibraryStatusAreaExpectations();
  SetPowerLibraryStatusAreaExpectations();
  SetPowerLibraryExpectations();
  SetTouchpadLibraryExpectations();
}

  virtual bool StartInputMethodDaemon() {
    return true;
  }

  virtual void SendHandwritingStroke(const HandwritingStroke& stroke) {}

static void IBusBusDisconnectedCallback(IBusBus* bus, gpointer user_data) {
LOG(WARNING) << "IBus connection is terminated.";
    g_return_if_fail(user_data);
    InputMethodStatusConnection* self
        = static_cast<InputMethodStatusConnection*>(user_data);
// ibus-daemon might be terminated. Since |ibus_| object will automatically
// connect to the daemon if it restarts, we don't have to set NULL on ibus_.
// Call MaybeDestroyIBusConfig() to set |ibus_config_| to NULL temporarily.
    self->MaybeDestroyIBusConfig();
    if (self->connection_change_handler_) {
      LOG(INFO) << "Notifying Chrome that IBus is terminated.";
      self->connection_change_handler_(self->language_library_, false);
    }
}

  InputMethodLibraryStubImpl()
      : keyboard_overlay_map_(GetKeyboardOverlayMapForTesting()) {
    current_input_method_ = input_method::GetFallbackInputMethodDescriptor();
  }

bool ChromeOSChangeInputMethod(
    InputMethodStatusConnection* connection, const char* name) {
  DCHECK(name);
  DLOG(INFO) << "ChangeInputMethod: " << name;
  g_return_val_if_fail(connection, false);
  return connection->ChangeInputMethod(name);
}

void CrosMock::SetSpeechSynthesisLibraryExpectations() {
  InSequence s;
  EXPECT_CALL(*mock_speech_synthesis_library_, StopSpeaking())
      .WillOnce(Return(true))
      .RetiresOnSaturation();
  EXPECT_CALL(*mock_speech_synthesis_library_, Speak(_))
      .WillOnce(Return(true))
      .RetiresOnSaturation();
  EXPECT_CALL(*mock_speech_synthesis_library_, IsSpeaking())
      .Times(AnyNumber())
      .WillRepeatedly(Return(true));
  EXPECT_CALL(*mock_speech_synthesis_library_, StopSpeaking())
      .WillOnce(Return(true))
      .RetiresOnSaturation();
  EXPECT_CALL(*mock_speech_synthesis_library_, Speak(_))
      .WillOnce(Return(true))
      .RetiresOnSaturation();
  EXPECT_CALL(*mock_speech_synthesis_library_, IsSpeaking())
      .WillOnce(Return(true))
      .WillOnce(Return(true))
      .WillOnce(Return(false))
      .RetiresOnSaturation();
}

bool ChromeOSSetImeConfig(InputMethodStatusConnection* connection,
                          const char* section,
                          const char* config_name,
                          const ImeConfigValue& value) {
  DCHECK(section);
  DCHECK(config_name);
  g_return_val_if_fail(connection, FALSE);
  return connection->SetImeConfig(section, config_name, value);
}

  void MaybeDestroyIBusConfig() {
    if (!ibus_) {
      LOG(ERROR) << "MaybeDestroyIBusConfig: ibus_ is NULL";
      return;
    }
    if (ibus_config_ && !ibus_bus_is_connected(ibus_)) {
      g_object_unref(ibus_config_);
      ibus_config_ = NULL;
     }
   }

void FocusIn(const char* input_context_path) {
    if (!input_context_path) {
      LOG(ERROR) << "NULL context passed";
    } else {
      DLOG(INFO) << "FocusIn: " << input_context_path;
    }
    // Remember the current ic path.
    input_context_path_ = Or(input_context_path, "");
  }

const char* PropStateToString(int prop_state) {
  switch (static_cast<IBusPropState>(prop_state)) {
    case PROP_STATE_UNCHECKED:
      return "UNCHECKED";
    case PROP_STATE_CHECKED:
      return "CHECKED";
    case PROP_STATE_INCONSISTENT:
      return "INCONSISTENT";
  }
  return "UNKNOWN";
}

void ConnectIBusSignals() {
if (!ibus_) {
return;
}

// We use g_signal_connect_after here since the callback should be called
// *after* the IBusBusDisconnectedCallback in chromeos_input_method_ui.cc
// is called. chromeos_input_method_ui.cc attaches the panel service object
// to |ibus_|, and the callback in this file use the attached object.
g_signal_connect_after(ibus_,
"connected",
                           G_CALLBACK(IBusBusConnectedCallback),
this);

g_signal_connect(ibus_,
"disconnected",
                     G_CALLBACK(IBusBusDisconnectedCallback),
this);
g_signal_connect(ibus_,
"global-engine-changed",
                     G_CALLBACK(IBusBusGlobalEngineChangedCallback),
this);
g_signal_connect(ibus_,
"name-owner-changed",
                     G_CALLBACK(IBusBusNameOwnerChangedCallback),
this);
}

virtual bool SetImeConfig(const std::string& section,
const std::string& config_name,
                            const ImeConfigValue& value) {
// If the config change is for preload engines, update the active
// input methods cache |active_input_method_ids_| here. We need to
// update the cache before actually flushing the config. since we need
// to return active input methods from GetActiveInputMethods() before
// the input method daemon starts. For instance, we need to show the
// list of available input methods (keyboard layouts) on the login
// screen before the input method starts.
if (section == language_prefs::kGeneralSectionName &&
config_name == language_prefs::kPreloadEnginesConfigName &&
        value.type == ImeConfigValue::kValueTypeStringList) {
active_input_method_ids_ = value.string_list_value;
}

// Before calling FlushImeConfig(), start input method process if necessary.
MaybeStartInputMethodDaemon(section, config_name, value);

const ConfigKeyType key = std::make_pair(section, config_name);
current_config_values_[key] = value;
if (ime_connected_) {
pending_config_requests_[key] = value;
FlushImeConfig();
}

// Stop input method process if necessary.
MaybeStopInputMethodDaemon(section, config_name, value);
// Change the current keyboard layout if necessary.
MaybeChangeCurrentKeyboardLayout(section, config_name, value);
return pending_config_requests_.empty();
}

std::string Spacer(int n) {
  return std::string(n, ' ');
}

virtual void CancelHandwritingStrokes(int stroke_count) {
if (!initialized_successfully_)
return;
// TODO(yusukes): Rename the libcros function to CancelHandwritingStrokes.
    chromeos::CancelHandwriting(input_method_status_connection_, stroke_count);
}

  void SetDeferImeStartup(bool defer) {
    VLOG(1) << "Setting DeferImeStartup to " << defer;
    defer_ime_startup_ = defer;
  }

  virtual void RemoveObserver(Observer* observer) {
     observers_.RemoveObserver(observer);
   }

InputMethodStatusConnection()
      : current_input_method_changed_(NULL),
        register_ime_properties_(NULL),
        update_ime_property_(NULL),
        connection_change_handler_(NULL),
        language_library_(NULL),
        ibus_(NULL),
ibus_config_(NULL) {
}

void SetImePropertyActivated(const char* key, bool activated) {
if (!IBusConnectionsAreAlive()) {
LOG(ERROR) << "SetImePropertyActivated: IBus connection is not alive";
return;
}
    if (!key || (key[0] == '\0')) {
return;
}
if (input_context_path_.empty()) {
LOG(ERROR) << "Input context is unknown";
return;
}

IBusInputContext* context = GetInputContext(input_context_path_, ibus_);
if (!context) {
return;
}
// Activate the property *asynchronously*.
ibus_input_context_property_activate(
        context, key, (activated ? PROP_STATE_CHECKED : PROP_STATE_UNCHECKED));

// We don't have to call ibus_proxy_destroy(context) explicitly here,
// i.e. we can just call g_object_unref(context), since g_object_unref can
// trigger both dispose, which is overridden by src/ibusproxy.c, and
// finalize functions. For details, see
// http://library.gnome.org/devel/gobject/stable/gobject-memory.html
g_object_unref(context);
}

void MaybeCreateIBus() {
if (ibus_) {
return;
}

ibus_init();
// Establish IBus connection between ibus-daemon to retrieve the list of
// available input method engines, change the current input method engine,
// and so on.
ibus_ = ibus_bus_new();

// Check the IBus connection status.
if (!ibus_) {
LOG(ERROR) << "ibus_bus_new() failed";
return;
}
// Register callback functions for IBusBus signals.
ConnectIBusSignals();

// Ask libibus to watch the NameOwnerChanged signal *asynchronously*.
ibus_bus_set_watch_dbus_signal(ibus_, TRUE);
// Ask libibus to watch the GlobalEngineChanged signal *asynchronously*.
ibus_bus_set_watch_ibus_signal(ibus_, TRUE);

if (ibus_bus_is_connected(ibus_)) {
      LOG(INFO) << "IBus connection is ready.";
}
}

const char* Or(const char* str1, const char* str2) {
  return str1 ? str1 : str2;
}

virtual void SendHandwritingStroke(const HandwritingStroke& stroke) {
if (!initialized_successfully_)
return;
    chromeos::SendHandwritingStroke(input_method_status_connection_, stroke);
}

bool ChangeInputMethodViaIBus(const std::string& input_method_id) {
if (!initialized_successfully_)
return false;

std::string input_method_id_to_switch = input_method_id;

if (!InputMethodIsActivated(input_method_id)) {
// This path might be taken if prefs::kLanguageCurrentInputMethod (NOT
// synced with cloud) and kLanguagePreloadEngines (synced with cloud) are
// mismatched. e.g. the former is 'xkb:us::eng' and the latter (on the
// sync server) is 'xkb:jp::jpn,mozc'.
      scoped_ptr<InputMethodDescriptors> input_methods(GetActiveInputMethods());
DCHECK(!input_methods->empty());
if (!input_methods->empty()) {
input_method_id_to_switch = input_methods->at(0).id;
LOG(INFO) << "Can't change the current input method to "
<< input_method_id << " since the engine is not preloaded. "
<< "Switch to " << input_method_id_to_switch << " instead.";
}
}

    if (chromeos::ChangeInputMethod(input_method_status_connection_,
                                    input_method_id_to_switch.c_str())) {
return true;
}

// ChangeInputMethod() fails if the IBus daemon is not yet ready.
LOG(ERROR) << "Can't switch input method to " << input_method_id_to_switch;
return false;
}

static void RegisterPropertiesHandler(
      void* object, const ImePropertyList& prop_list) {
// See comments in InputMethodChangedHandler.
if (!BrowserThread::CurrentlyOn(BrowserThread::UI)) {
LOG(ERROR) << "Not on UI thread";
return;
}

    InputMethodLibraryImpl* input_method_library =
        static_cast<InputMethodLibraryImpl*>(object);
    input_method_library->RegisterProperties(prop_list);
}

  void CancelHandwriting(int n_strokes) {
     IBusInputContext* context = GetInputContext(input_context_path_, ibus_);
     if (!context) {
       return;
    }
    ibus_input_context_cancel_hand_writing(context, n_strokes);
     g_object_unref(context);
   }

void MaybeStopInputMethodDaemon(const std::string& section,
const std::string& config_name,
                                  const ImeConfigValue& value) {
// If there is only one input method which is a keyboard layout,
// and |enable_auto_ime_shutdown_| is true, we'll stop the input
// method daemon.
if (section == language_prefs::kGeneralSectionName &&
config_name == language_prefs::kPreloadEnginesConfigName &&
ContainOnlyOneKeyboardLayout(value) &&
enable_auto_ime_shutdown_) {
StopInputMethodDaemon();
}
}

  virtual void SetImePropertyActivated(const std::string& key,
                                       bool activated) {}

  virtual InputMethodDescriptor current_input_method() const {
     if (current_input_method_.id.empty()) {
       return input_method::GetFallbackInputMethodDescriptor();
     }
     return current_input_method_;
   }

bool FlattenProperty(IBusProperty* ibus_prop, ImePropertyList* out_prop_list) {
  DCHECK(ibus_prop);
  DCHECK(out_prop_list);

  int selection_item_id = -1;
  std::stack<std::pair<IBusProperty*, int> > prop_stack;
  prop_stack.push(std::make_pair(ibus_prop, selection_item_id));

  while (!prop_stack.empty()) {
    IBusProperty* prop = prop_stack.top().first;
    const int current_selection_item_id = prop_stack.top().second;
    prop_stack.pop();

    if (PropertyKeyIsBlacklisted(prop->key)) {
      continue;
    }

    if (!ConvertProperty(prop, current_selection_item_id, out_prop_list)) {
      return false;
    }

    if (PropertyHasChildren(prop)) {
      ++selection_item_id;
      for (int i = 0;; ++i) {
        IBusProperty* sub_prop = ibus_prop_list_get(prop->sub_props, i);
        if (!sub_prop) {
          break;
        }
        prop_stack.push(std::make_pair(sub_prop, selection_item_id));
      }
      ++selection_item_id;
    }
  }
  std::reverse(out_prop_list->begin(), out_prop_list->end());

  return true;
}

static void UpdatePropertyHandler(
      void* object, const ImePropertyList& prop_list) {
// See comments in InputMethodChangedHandler.
if (!BrowserThread::CurrentlyOn(BrowserThread::UI)) {
LOG(ERROR) << "Not on UI thread";
return;
}

    InputMethodLibraryImpl* input_method_library =
        static_cast<InputMethodLibraryImpl*>(object);
    input_method_library->UpdateProperty(prop_list);
}

InputMethodLibraryImpl::Observer::~Observer() {}

InputMethodDescriptors* CrosMock::CreateInputMethodDescriptors() {
  InputMethodDescriptors* descriptors = new InputMethodDescriptors;
descriptors->push_back(
input_method::GetFallbackInputMethodDescriptor());
return descriptors;
}

std::string PrintProp(IBusProperty *prop, int tree_level) {
  if (!prop) {
    return "";
  }

  std::stringstream stream;
  stream << Spacer(tree_level) << "=========================" << std::endl;
  stream << Spacer(tree_level) << "key: " << Or(prop->key, "<none>")
         << std::endl;
  stream << Spacer(tree_level) << "icon: " << Or(prop->icon, "<none>")
         << std::endl;
  stream << Spacer(tree_level) << "label: "
         << ((prop->label && prop->label->text) ? prop->label->text : "<none>")
         << std::endl;
  stream << Spacer(tree_level) << "tooptip: "
         << ((prop->tooltip && prop->tooltip->text)
             ? prop->tooltip->text : "<none>") << std::endl;
  stream << Spacer(tree_level) << "sensitive: "
         << (prop->sensitive ? "YES" : "NO") << std::endl;
  stream << Spacer(tree_level) << "visible: " << (prop->visible ? "YES" : "NO")
         << std::endl;
  stream << Spacer(tree_level) << "type: " << PropTypeToString(prop->type)
         << std::endl;
  stream << Spacer(tree_level) << "state: " << PropStateToString(prop->state)
         << std::endl;
  stream << Spacer(tree_level) << "sub_props: "
         << (PropertyHasChildren(prop) ? "" : "<none>") << std::endl;
  stream << PrintPropList(prop->sub_props, tree_level + 1);
  stream << Spacer(tree_level) << "=========================" << std::endl;

  return stream.str();
}

bool SetImeConfig(const std::string& section,
                    const std::string& config_name,
                    const ImeConfigValue& value) {
// See comments in GetImeConfig() where ibus_config_get_value() is used.
if (!IBusConnectionsAreAlive()) {
LOG(ERROR) << "SetImeConfig: IBus connection is not alive";
return false;
}

bool is_preload_engines = false;

// Sanity check: do not preload unknown/unsupported input methods.
std::vector<std::string> string_list;
if ((value.type == ImeConfigValue::kValueTypeStringList) &&
(section == kGeneralSectionName) &&
(config_name == kPreloadEnginesConfigName)) {
FilterInputMethods(value.string_list_value, &string_list);
is_preload_engines = true;
} else {
string_list = value.string_list_value;
}

// Convert the type of |value| from our structure to GVariant.
GVariant* variant = NULL;
switch (value.type) {
case ImeConfigValue::kValueTypeString:
variant = g_variant_new_string(value.string_value.c_str());
break;
case ImeConfigValue::kValueTypeInt:
variant = g_variant_new_int32(value.int_value);
break;
case ImeConfigValue::kValueTypeBool:
variant = g_variant_new_boolean(value.bool_value);
break;
case ImeConfigValue::kValueTypeStringList:
GVariantBuilder variant_builder;
g_variant_builder_init(&variant_builder, G_VARIANT_TYPE("as"));
const size_t size = string_list.size();  // don't use string_list_value.
for (size_t i = 0; i < size; ++i) {
g_variant_builder_add(&variant_builder, "s", string_list[i].c_str());
}
variant = g_variant_builder_end(&variant_builder);
break;
}

if (!variant) {
LOG(ERROR) << "SetImeConfig: variant is NULL";
return false;
}
DCHECK(g_variant_is_floating(variant));

// Set an ibus configuration value *asynchronously*.
ibus_config_set_value_async(ibus_config_,
section.c_str(),
config_name.c_str(),
variant,
-1,  // use the default ibus timeout
NULL,  // cancellable
SetImeConfigCallback,
g_object_ref(ibus_config_));

// Since |variant| is floating, ibus_config_set_value_async consumes
// (takes ownership of) the variable.

if (is_preload_engines) {
      DLOG(INFO) << "SetImeConfig: " << section << "/" << config_name
                 << ": " << value.ToString();
}
return true;
}

static void RegisterPropertiesCallback(IBusPanelService* panel,
                                         IBusPropList* prop_list,
                                         gpointer user_data) {
    g_return_if_fail(user_data);
    InputMethodStatusConnection* self
        = static_cast<InputMethodStatusConnection*>(user_data);
    self->RegisterProperties(prop_list);
}

  std::map<std::string, std::string>* GetKeyboardOverlayMapForTesting() {
    KeyboardOverlayMap* keyboard_overlay_map =
        new KeyboardOverlayMap;
    (*keyboard_overlay_map)["xkb:nl::nld"] = "nl";
    (*keyboard_overlay_map)["xkb:be::nld"] = "nl";
    (*keyboard_overlay_map)["xkb:fr::fra"] = "fr";
    (*keyboard_overlay_map)["xkb:be::fra"] = "fr";
    (*keyboard_overlay_map)["xkb:ca::fra"] = "fr_CA";
    (*keyboard_overlay_map)["xkb:ch:fr:fra"] = "fr";
    (*keyboard_overlay_map)["xkb:de::ger"] = "de";
    (*keyboard_overlay_map)["xkb:be::ger"] = "de";
    (*keyboard_overlay_map)["xkb:ch::ger"] = "de";
    (*keyboard_overlay_map)["mozc"] = "en_US";
    (*keyboard_overlay_map)["mozc-jp"] = "ja";
    (*keyboard_overlay_map)["mozc-dv"] = "en_US_dvorak";
    (*keyboard_overlay_map)["xkb:jp::jpn"] = "ja";
    (*keyboard_overlay_map)["xkb:ru::rus"] = "ru";
    (*keyboard_overlay_map)["xkb:ru:phonetic:rus"] = "ru";
    (*keyboard_overlay_map)["m17n:th:kesmanee"] = "th";
    (*keyboard_overlay_map)["m17n:th:pattachote"] = "th";
    (*keyboard_overlay_map)["m17n:th:tis820"] = "th";
    (*keyboard_overlay_map)["mozc-chewing"] = "zh_TW";
    (*keyboard_overlay_map)["m17n:zh:cangjie"] = "zh_TW";
    (*keyboard_overlay_map)["m17n:zh:quick"] = "zh_TW";
    (*keyboard_overlay_map)["m17n:vi:tcvn"] = "vi";
    (*keyboard_overlay_map)["m17n:vi:telex"] = "vi";
    (*keyboard_overlay_map)["m17n:vi:viqr"] = "vi";
    (*keyboard_overlay_map)["m17n:vi:vni"] = "vi";
    (*keyboard_overlay_map)["xkb:us::eng"] = "en_US";
    (*keyboard_overlay_map)["xkb:us:intl:eng"] = "en_US";
    (*keyboard_overlay_map)["xkb:us:altgr-intl:eng"] = "en_US";
    (*keyboard_overlay_map)["xkb:us:dvorak:eng"] =
        "en_US_dvorak";
    (*keyboard_overlay_map)["xkb:us:colemak:eng"] =
        "en_US";
    (*keyboard_overlay_map)["hangul"] = "ko";
    (*keyboard_overlay_map)["pinyin"] = "zh_CN";
    (*keyboard_overlay_map)["m17n:ar:kbd"] = "ar";
    (*keyboard_overlay_map)["m17n:hi:itrans"] = "hi";
    (*keyboard_overlay_map)["m17n:fa:isiri"] = "ar";
    (*keyboard_overlay_map)["xkb:br::por"] = "pt_BR";
    (*keyboard_overlay_map)["xkb:bg::bul"] = "bg";
    (*keyboard_overlay_map)["xkb:bg:phonetic:bul"] = "bg";
    (*keyboard_overlay_map)["xkb:ca:eng:eng"] = "ca";
    (*keyboard_overlay_map)["xkb:cz::cze"] = "cs";
    (*keyboard_overlay_map)["xkb:ee::est"] = "et";
    (*keyboard_overlay_map)["xkb:es::spa"] = "es";
    (*keyboard_overlay_map)["xkb:es:cat:cat"] = "ca";
    (*keyboard_overlay_map)["xkb:dk::dan"] = "da";
    (*keyboard_overlay_map)["xkb:gr::gre"] = "el";
    (*keyboard_overlay_map)["xkb:il::heb"] = "iw";
    (*keyboard_overlay_map)["xkb:kr:kr104:kor"] = "ko";
    (*keyboard_overlay_map)["xkb:latam::spa"] = "es_419";
    (*keyboard_overlay_map)["xkb:lt::lit"] = "lt";
    (*keyboard_overlay_map)["xkb:lv:apostrophe:lav"] = "lv";
    (*keyboard_overlay_map)["xkb:hr::scr"] = "hr";
    (*keyboard_overlay_map)["xkb:gb:extd:eng"] = "en_GB";
    (*keyboard_overlay_map)["xkb:gb:dvorak:eng"] = "en_GB_dvorak";
    (*keyboard_overlay_map)["xkb:fi::fin"] = "fi";
    (*keyboard_overlay_map)["xkb:hu::hun"] = "hu";
    (*keyboard_overlay_map)["xkb:it::ita"] = "it";
    (*keyboard_overlay_map)["xkb:no::nob"] = "no";
    (*keyboard_overlay_map)["xkb:pl::pol"] = "pl";
    (*keyboard_overlay_map)["xkb:pt::por"] = "pt_PT";
    (*keyboard_overlay_map)["xkb:ro::rum"] = "ro";
    (*keyboard_overlay_map)["xkb:se::swe"] = "sv";
    (*keyboard_overlay_map)["xkb:sk::slo"] = "sk";
    (*keyboard_overlay_map)["xkb:si::slv"] = "sl";
    (*keyboard_overlay_map)["xkb:rs::srp"] = "sr";
    (*keyboard_overlay_map)["xkb:tr::tur"] = "tr";
    (*keyboard_overlay_map)["xkb:ua::ukr"] = "uk";
     return keyboard_overlay_map;
   }

bool ConvertProperty(IBusProperty* ibus_prop,
int selection_item_id,
ImePropertyList* out_prop_list) {
DCHECK(ibus_prop);
DCHECK(ibus_prop->key);
DCHECK(out_prop_list);

// Sanity checks.
const bool has_sub_props = PropertyHasChildren(ibus_prop);
if (has_sub_props && (ibus_prop->type != PROP_TYPE_MENU)) {
LOG(ERROR) << "The property has sub properties, "
<< "but the type of the property is not PROP_TYPE_MENU";
return false;
}
if ((!has_sub_props) && (ibus_prop->type == PROP_TYPE_MENU)) {
// This is usually not an error. ibus-daemon sometimes sends empty props.
    DLOG(INFO) << "Property list is empty";
return false;
}
if (ibus_prop->type == PROP_TYPE_SEPARATOR ||
ibus_prop->type == PROP_TYPE_MENU) {
// This is not an error, but we don't push an item for these types.
return true;
}

const bool is_selection_item = (ibus_prop->type == PROP_TYPE_RADIO);
selection_item_id = is_selection_item ?
selection_item_id : ImeProperty::kInvalidSelectionItemId;

bool is_selection_item_checked = false;
if (ibus_prop->state == PROP_STATE_INCONSISTENT) {
LOG(WARNING) << "The property is in PROP_STATE_INCONSISTENT, "
<< "which is not supported.";
} else if ((!is_selection_item) && (ibus_prop->state == PROP_STATE_CHECKED)) {
LOG(WARNING) << "PROP_STATE_CHECKED is meaningful only if the type is "
<< "PROP_TYPE_RADIO.";
} else {
is_selection_item_checked = (ibus_prop->state == PROP_STATE_CHECKED);
}

if (!ibus_prop->key) {
LOG(ERROR) << "key is NULL";
}
if (ibus_prop->tooltip && (!ibus_prop->tooltip->text)) {
LOG(ERROR) << "tooltip is NOT NULL, but tooltip->text IS NULL: key="
<< Or(ibus_prop->key, "");
}
if (ibus_prop->label && (!ibus_prop->label->text)) {
LOG(ERROR) << "label is NOT NULL, but label->text IS NULL: key="
<< Or(ibus_prop->key, "");
}

// This label will be localized on Chrome side.
// See src/chrome/browser/chromeos/status/language_menu_l10n_util.h.
std::string label =
((ibus_prop->tooltip &&
ibus_prop->tooltip->text) ? ibus_prop->tooltip->text : "");
if (label.empty()) {
// Usually tooltips are more descriptive than labels.
label = (ibus_prop->label && ibus_prop->label->text)
? ibus_prop->label->text : "";
}
if (label.empty()) {
// ibus-pinyin has a property whose label and tooltip are empty. Fall back
// to the key.
label = Or(ibus_prop->key, "");
}

out_prop_list->push_back(ImeProperty(ibus_prop->key,
label,
is_selection_item,
is_selection_item_checked,
selection_item_id));
return true;
}

void CrosMock::TearDownMocks() {
  if (loader_)
    test_api()->SetLibraryLoader(NULL, false);
  if (mock_cryptohome_library_)
    test_api()->SetCryptohomeLibrary(NULL, false);
  if (mock_input_method_library_)
    test_api()->SetInputMethodLibrary(NULL, false);
  if (mock_network_library_)
    test_api()->SetNetworkLibrary(NULL, false);
  if (mock_power_library_)
    test_api()->SetPowerLibrary(NULL, false);
  if (mock_screen_lock_library_)
    test_api()->SetScreenLockLibrary(NULL, false);
  if (mock_speech_synthesis_library_)
    test_api()->SetSpeechSynthesisLibrary(NULL, false);
  if (mock_touchpad_library_)
     test_api()->SetTouchpadLibrary(NULL, false);
 }

  virtual InputMethodDescriptor current_input_method() const {
     return current_input_method_;
   }

static void ConnectionChangeHandler(void* object, bool connected) {
// See comments in InputMethodChangedHandler.
if (!BrowserThread::CurrentlyOn(BrowserThread::UI)) {
LOG(ERROR) << "Not on UI thread";
return;
}

    InputMethodLibraryImpl* input_method_library =
        static_cast<InputMethodLibraryImpl*>(object);
    input_method_library->ime_connected_ = connected;
if (connected) {
      input_method_library->pending_config_requests_.clear();
      input_method_library->pending_config_requests_.insert(
          input_method_library->current_config_values_.begin(),
          input_method_library->current_config_values_.end());
      input_method_library->FlushImeConfig();
      input_method_library->ChangeInputMethod(
          input_method_library->previous_input_method().id);
      input_method_library->ChangeInputMethod(
          input_method_library->current_input_method().id);
}
}

void MaybeStartInputMethodDaemon(const std::string& section,
const std::string& config_name,
                                   const ImeConfigValue& value) {
if (section == language_prefs::kGeneralSectionName &&
config_name == language_prefs::kPreloadEnginesConfigName &&
        value.type == ImeConfigValue::kValueTypeStringList &&
!value.string_list_value.empty()) {
// If there is only one input method which is a keyboard layout,
// we don't start the input method processes.  When
// |defer_ime_startup_| is true, we don't start it either.
if (ContainOnlyOneKeyboardLayout(value) || defer_ime_startup_) {
// Do not start the input method daemon.
return;
}

// Otherwise, start the input method daemon.
const bool just_started = StartInputMethodDaemon();
if (!just_started) {
// The daemon is already running.
// Do not |update tentative_current_input_method_id_|.
return;
}

// The daemon has just been started. To select the initial input method
// engine correctly, update |tentative_current_input_method_id_|.
if (tentative_current_input_method_id_.empty()) {
// Since the |current_input_method_| is in the preloaded engine list,
// switch to the engine. This is necessary ex. for the following case:
// 1. "xkb:jp::jpn" is enabled. ibus-daemon is not running.
// 2. A user enabled "mozc" via DOMUI as well. ibus-daemon is started
//    and the preloaded engine list is set to "mozc,xkb:jp::jpn".
// 3. ibus-daemon selects "mozc" as its current engine since "mozc" is
//    on top of the preloaded engine list.
// 4. Therefore, we have to change the current engine to "xkb:jp::jpn"
//    explicitly to avoid unexpected engine switch.
tentative_current_input_method_id_ = current_input_method_.id;
}

if (std::find(value.string_list_value.begin(),
value.string_list_value.end(),
tentative_current_input_method_id_)
== value.string_list_value.end()) {
// The |current_input_method_| is NOT in the preloaded engine list.
// In this case, ibus-daemon will automatically select the first engine
// in the list, |value.string_list_value[0]|, and send global engine
// changed signal to Chrome. See crosbug.com/13406.
tentative_current_input_method_id_.clear();
}
}
}

void ChromeOSSendHandwritingStroke(InputMethodStatusConnection* connection,
                                   const HandwritingStroke& stroke) {
  g_return_if_fail(connection);
  connection->SendHandwritingStroke(stroke);
}

  virtual std::string GetKeyboardOverlayId(const std::string& input_method_id) {
    KeyboardOverlayMap::const_iterator iter =
        keyboard_overlay_map_->find(input_method_id);
    return (iter != keyboard_overlay_map_->end()) ?
         iter->second : "";
   }

  virtual ~InputMethodLibraryStubImpl() {}

void ConnectPanelServiceSignals() {
if (!ibus_) {
return;
}

IBusPanelService* ibus_panel_service = IBUS_PANEL_SERVICE(
g_object_get_data(G_OBJECT(ibus_), kPanelObjectKey));
if (!ibus_panel_service) {
LOG(ERROR) << "IBusPanelService is NOT available.";
return;
}
// We don't _ref() or _weak_ref() the panel service object, since we're not
// interested in the life time of the object.

g_signal_connect(ibus_panel_service,
"focus-in",
                     G_CALLBACK(FocusInCallback),
this);
g_signal_connect(ibus_panel_service,
"register-properties",
                     G_CALLBACK(RegisterPropertiesCallback),
this);
g_signal_connect(ibus_panel_service,
"update-property",
                     G_CALLBACK(UpdatePropertyCallback),
this);
}

  virtual InputMethodDescriptors* GetSupportedInputMethods() {
     return GetInputMethodDescriptorsForTesting();
   }

bool FindAndUpdateProperty(const chromeos::ImeProperty& new_prop,
                           chromeos::ImePropertyList* prop_list) {
for (size_t i = 0; i < prop_list->size(); ++i) {
    chromeos::ImeProperty& prop = prop_list->at(i);
if (prop.key == new_prop.key) {
const int saved_id = prop.selection_item_id;
// Update the list except the radio id. As written in
// chromeos_input_method.h, |prop.selection_item_id| is dummy.
prop = new_prop;
prop.selection_item_id = saved_id;
return true;
}
}
return false;
}

virtual InputMethodDescriptors* GetSupportedInputMethods() {
if (!initialized_successfully_) {
// If initialization was failed, return the fallback input method,
// as this function is guaranteed to return at least one descriptor.
      InputMethodDescriptors* result = new InputMethodDescriptors;
result->push_back(input_method::GetFallbackInputMethodDescriptor());
return result;
}

// This never returns NULL.
    return chromeos::GetSupportedInputMethodDescriptors();
}

  virtual bool InputMethodIsActivated(const std::string& input_method_id) {
    return true;
  }

  virtual InputMethodDescriptor previous_input_method() const {
     if (previous_input_method_.id.empty()) {
       return input_method::GetFallbackInputMethodDescriptor();
     }
     return previous_input_method_;
   }

  virtual InputMethodDescriptors* GetActiveInputMethods() {
     return GetInputMethodDescriptorsForTesting();
   }

bool FlattenPropertyList(
    IBusPropList* ibus_prop_list, ImePropertyList* out_prop_list) {
  DCHECK(ibus_prop_list);
  DCHECK(out_prop_list);

  IBusProperty* fake_root_prop = ibus_property_new("Dummy.Key",
                                                   PROP_TYPE_MENU,
                                                   NULL, /* label */
                                                   "", /* icon */
                                                   NULL, /* tooltip */
                                                   FALSE, /* sensitive */
                                                   FALSE, /* visible */
                                                   PROP_STATE_UNCHECKED,
                                                   ibus_prop_list);
  g_return_val_if_fail(fake_root_prop, false);
  g_object_ref(ibus_prop_list);
  const bool result = FlattenProperty(fake_root_prop, out_prop_list);
  g_object_unref(fake_root_prop);

  return result;
}

MockInputMethodLibrary* CrosMock::mock_input_method_library() {
  return mock_input_method_library_;
}

  static void OnImeShutdown(GPid pid,
                            gint status,
                            InputMethodLibraryImpl* library) {
    if (library->ibus_daemon_process_handle_ != base::kNullProcessHandle &&
        base::GetProcId(library->ibus_daemon_process_handle_) == pid) {
      library->ibus_daemon_process_handle_ = base::kNullProcessHandle;
    }

    library->MaybeLaunchInputMethodDaemon();
  }

  static void SetImeConfigCallback(GObject* source_object,
                                   GAsyncResult* res,
                                   gpointer user_data) {
    IBusConfig* config = IBUS_CONFIG(user_data);
    g_return_if_fail(config);

    GError* error = NULL;
    const gboolean result =
        ibus_config_set_value_async_finish(config, res, &error);

    if (!result) {
      std::string message = "(unknown error)";
      if (error && error->message) {
        message = error->message;
      }
      LOG(ERROR) << "ibus_config_set_value_async failed: " << message;
    }

    if (error) {
      g_error_free(error);
    }
     g_object_unref(config);
   }

  virtual void StopInputMethodDaemon() {}

void RegisterProperties(const ImePropertyList& prop_list) {
// |prop_list| might be empty. This means "clear all properties."
current_ime_properties_ = prop_list;

// Update input method menu
    FOR_EACH_OBSERVER(Observer, observers_,
PropertyListChanged(this,
current_ime_properties_));
}

void FilterInputMethods(const std::vector<std::string>& requested_input_methods,
                        std::vector<std::string>* out_filtered_input_methods) {
  out_filtered_input_methods->clear();
  for (size_t i = 0; i < requested_input_methods.size(); ++i) {
    const std::string& input_method = requested_input_methods[i];
    if (InputMethodIdIsWhitelisted(input_method.c_str())) {
      out_filtered_input_methods->push_back(input_method);
    } else {
      LOG(ERROR) << "Unsupported input method: " << input_method;
    }
  }
}

bool ChangeInputMethod(const char* name) {
if (!IBusConnectionsAreAlive()) {
LOG(ERROR) << "ChangeInputMethod: IBus connection is not alive";
return false;
}
    if (!name) {
return false;
}
if (!InputMethodIdIsWhitelisted(name)) {
LOG(ERROR) << "Input method '" << name << "' is not supported";
return false;
}

// Clear all input method properties unconditionally.
//
// When switching to another input method and no text area is focused,
// RegisterProperties signal for the new input method will NOT be sent
// until a text area is focused. Therefore, we have to clear the old input
// method properties here to keep the input method switcher status
// consistent.
    RegisterProperties(NULL);

// Change the global engine *asynchronously*.
ibus_bus_set_global_engine_async(ibus_,
                                     name,
-1,  // use the default ibus timeout
NULL,  // cancellable
NULL,  // callback
NULL);  // user_data
return true;
}

   virtual void RemoveObserver(Observer* observer) {}

 bool InputMethodIdIsWhitelisted(const std::string& input_method_id) {
  static std::set<std::string>* g_supported_input_methods = NULL;
  if (!g_supported_input_methods) {
    g_supported_input_methods = new std::set<std::string>;
    for (size_t i = 0; i < arraysize(kInputMethodIdsWhitelist); ++i) {
      g_supported_input_methods->insert(kInputMethodIdsWhitelist[i]);
    }
  }
  return (g_supported_input_methods->count(input_method_id) > 0);
}

static void InputMethodChangedHandler(
      void* object,
      const chromeos::InputMethodDescriptor& current_input_method) {
// The handler is called when the input method method change is
// notified via a DBus connection. Since the DBus notificatiosn are
// handled in the UI thread, we can assume that this function always
// runs on the UI thread, but just in case.
if (!BrowserThread::CurrentlyOn(BrowserThread::UI)) {
LOG(ERROR) << "Not on UI thread";
return;
}

    InputMethodLibraryImpl* input_method_library =
        static_cast<InputMethodLibraryImpl*>(object);
    input_method_library->ChangeCurrentInputMethod(current_input_method);
}

  bool MaybeLaunchInputMethodDaemon() {
    if (!initialized_successfully_)
      return false;

    if (!should_launch_ime_) {
      return false;
    }

#if !defined(TOUCH_UI)
    if (!candidate_window_controller_.get()) {
      candidate_window_controller_.reset(new CandidateWindowController);
      if (!candidate_window_controller_->Init()) {
        LOG(WARNING) << "Failed to initialize the candidate window controller";
      }
    }
#endif

    if (ibus_daemon_process_handle_ != base::kNullProcessHandle) {
      return false;  // ibus-daemon is already running.
    }

    const std::string ibus_daemon_command_line =
        StringPrintf("%s --panel=disable --cache=none --restart --replace",
                     kIBusDaemonPath);
    if (!LaunchInputMethodProcess(
            ibus_daemon_command_line, &ibus_daemon_process_handle_)) {
      LOG(ERROR) << "Failed to launch " << ibus_daemon_command_line;
      return false;
    }
    return true;
  }

void MaybeRestoreIBusConfig() {
if (!ibus_) {
return;
}

// Destroy the current |ibus_config_| object. No-op if it's NULL.
MaybeDestroyIBusConfig();

if (!ibus_config_) {
GDBusConnection* ibus_connection = ibus_bus_get_connection(ibus_);
if (!ibus_connection) {
        LOG(INFO) << "Couldn't create an ibus config object since "
                  << "IBus connection is not ready.";
return;
}
const gboolean disconnected
= g_dbus_connection_is_closed(ibus_connection);
if (disconnected) {
// |ibus_| object is not NULL, but the connection between ibus-daemon
// is not yet established. In this case, we don't create |ibus_config_|
// object.
LOG(ERROR) << "Couldn't create an ibus config object since "
<< "IBus connection is closed.";
return;
}
// If memconf is not successfully started yet, ibus_config_new() will
// return NULL. Otherwise, it returns a transfer-none and non-floating
// object. ibus_config_new() sometimes issues a D-Bus *synchronous* IPC
// to check if the org.freedesktop.IBus.Config service is available.
ibus_config_ = ibus_config_new(ibus_connection,
NULL /* do not cancel the operation */,
NULL /* do not get error information */);
if (!ibus_config_) {
LOG(ERROR) << "ibus_config_new() failed. ibus-memconf is not ready?";
return;
}

// TODO(yusukes): g_object_weak_ref might be better since it allows
// libcros to detect the delivery of the "destroy" glib signal the
// |ibus_config_| object.
g_object_ref(ibus_config_);
      LOG(INFO) << "ibus_config_ is ready.";
}
}

  bool StartInputMethodDaemon() {
    should_launch_ime_ = true;
    return MaybeLaunchInputMethodDaemon();
   }

void ChangeCurrentInputMethod(const InputMethodDescriptor& new_input_method) {
if (current_input_method_.id != new_input_method.id) {
previous_input_method_ = current_input_method_;
current_input_method_ = new_input_method;

// Change the keyboard layout to a preferred layout for the input method.
if (!input_method::SetCurrentKeyboardLayoutByName(
current_input_method_.keyboard_layout)) {
LOG(ERROR) << "Failed to change keyboard layout to "
<< current_input_method_.keyboard_layout;
}

// Ask the first observer to update preferences. We should not ask every
// observer to do so. Otherwise, we'll end up updating preferences many
// times when many observers are attached (ex. many windows are opened),
// which is unnecessary and expensive.
      ObserverListBase<Observer>::Iterator it(observers_);
      Observer* first_observer = it.GetNext();
if (first_observer) {
first_observer->PreferenceUpdateNeeded(this,
previous_input_method_,
current_input_method_);
}
}

// Update input method indicators (e.g. "US", "DV") in Chrome windows.
// For now, we have to do this every time to keep indicators updated. See
// comments near the FOR_EACH_OBSERVER call in FlushImeConfig() for details.
const size_t num_active_input_methods = GetNumActiveInputMethods();
    FOR_EACH_OBSERVER(Observer, observers_,
InputMethodChanged(this,
current_input_method_,
num_active_input_methods));
}

InputMethodDescriptor CreateInputMethodDescriptor(
    const std::string& id,
    const std::string& display_name,
    const std::string& raw_layout,
    const std::string& language_code) {
  static const char fallback_layout[] = "us";
  std::string physical_keyboard_layout = fallback_layout;
  const std::string& virtual_keyboard_layout = raw_layout;

  std::vector<std::string> layout_names;
  base::SplitString(raw_layout, ',', &layout_names);

  for (size_t i = 0; i < layout_names.size(); ++i) {
    if (XkbLayoutIsSupported(layout_names[i])) {
      physical_keyboard_layout = layout_names[i];
      break;
    }
  }

  return InputMethodDescriptor(id,
                               display_name,
                               physical_keyboard_layout,
                               virtual_keyboard_layout,
                                language_code);
 }

void CrosMock::InitStatusAreaMocks() {
  InitMockInputMethodLibrary();
  InitMockNetworkLibrary();
  InitMockPowerLibrary();
  InitMockTouchpadLibrary();
}

void ChromeOSSetImePropertyActivated(
    InputMethodStatusConnection* connection, const char* key, bool activated) {
  DLOG(INFO) << "SetImePropertyeActivated: " << key << ": " << activated;
  DCHECK(key);
  g_return_if_fail(connection);
  connection->SetImePropertyActivated(key, activated);
}

~InputMethodStatusConnection() {
// Since the class is used as a leaky singleton, this destructor is never
// called. However, if you would delete an instance of this class, you have
// to disconnect all signals so the handler functions will not be called
// with |this| which is already freed.
//
// if (ibus_) {
//   g_signal_handlers_disconnect_by_func(
//       ibus_,
//       reinterpret_cast<gpointer>(
//           G_CALLBACK(IBusBusConnectedCallback)),
//       this);
//   ...
// }
// if (ibus_panel_service_) {
//   g_signal_handlers_disconnect_by_func(
//       ...
}

// Checks if |ibus_| and |ibus_config_| connections are alive.
bool IBusConnectionsAreAlive() {
return ibus_ && ibus_bus_is_connected(ibus_) && ibus_config_;
}

// Restores connections to ibus-daemon and ibus-memconf if they are not ready.
// If both |ibus_| and |ibus_config_| become ready, the function sends a
// notification to Chrome.
void MaybeRestoreConnections() {
if (IBusConnectionsAreAlive()) {
return;
}
MaybeCreateIBus();
MaybeRestoreIBusConfig();
if (IBusConnectionsAreAlive()) {
ConnectPanelServiceSignals();
      if (connection_change_handler_) {
        LOG(INFO) << "Notifying Chrome that IBus is ready.";
        connection_change_handler_(language_library_, true);
      }
}
}

// Creates IBusBus object if it's not created yet.
void MaybeCreateIBus() {
if (ibus_) {
return;
}

ibus_init();
// Establish IBus connection between ibus-daemon to retrieve the list of
// available input method engines, change the current input method engine,
// and so on.
ibus_ = ibus_bus_new();

// Check the IBus connection status.
if (!ibus_) {
LOG(ERROR) << "ibus_bus_new() failed";
return;
}
// Register callback functions for IBusBus signals.
ConnectIBusSignals();

// Ask libibus to watch the NameOwnerChanged signal *asynchronously*.
ibus_bus_set_watch_dbus_signal(ibus_, TRUE);
// Ask libibus to watch the GlobalEngineChanged signal *asynchronously*.
ibus_bus_set_watch_ibus_signal(ibus_, TRUE);

if (ibus_bus_is_connected(ibus_)) {
      LOG(INFO) << "IBus connection is ready.";
}
}

// Creates IBusConfig object if it's not created yet AND |ibus_| connection
// is ready.
void MaybeRestoreIBusConfig() {
if (!ibus_) {
return;
}

// Destroy the current |ibus_config_| object. No-op if it's NULL.
MaybeDestroyIBusConfig();

if (!ibus_config_) {
GDBusConnection* ibus_connection = ibus_bus_get_connection(ibus_);
if (!ibus_connection) {
        LOG(INFO) << "Couldn't create an ibus config object since "
                  << "IBus connection is not ready.";
return;
}
const gboolean disconnected
= g_dbus_connection_is_closed(ibus_connection);
if (disconnected) {
// |ibus_| object is not NULL, but the connection between ibus-daemon
// is not yet established. In this case, we don't create |ibus_config_|
// object.
LOG(ERROR) << "Couldn't create an ibus config object since "
<< "IBus connection is closed.";
return;
}
// If memconf is not successfully started yet, ibus_config_new() will
// return NULL. Otherwise, it returns a transfer-none and non-floating
// object. ibus_config_new() sometimes issues a D-Bus *synchronous* IPC
// to check if the org.freedesktop.IBus.Config service is available.
ibus_config_ = ibus_config_new(ibus_connection,
NULL /* do not cancel the operation */,
NULL /* do not get error information */);
if (!ibus_config_) {
LOG(ERROR) << "ibus_config_new() failed. ibus-memconf is not ready?";
return;
}

// TODO(yusukes): g_object_weak_ref might be better since it allows
// libcros to detect the delivery of the "destroy" glib signal the
// |ibus_config_| object.
g_object_ref(ibus_config_);
      LOG(INFO) << "ibus_config_ is ready.";
}
}

// Destroys IBusConfig object if |ibus_| connection is not ready. This
// function does nothing if |ibus_config_| is NULL or |ibus_| connection is
// still alive. Note that the IBusConfig object can't be used when |ibus_|
// connection is not ready.
void MaybeDestroyIBusConfig() {
if (!ibus_) {
LOG(ERROR) << "MaybeDestroyIBusConfig: ibus_ is NULL";
return;
}
if (ibus_config_ && !ibus_bus_is_connected(ibus_)) {
g_object_unref(ibus_config_);
ibus_config_ = NULL;
}
}

  // Handles "FocusIn" signal from chromeos_input_method_ui.
  void FocusIn(const char* input_context_path) {
    if (!input_context_path) {
      LOG(ERROR) << "NULL context passed";
    } else {
      DLOG(INFO) << "FocusIn: " << input_context_path;
    }
    // Remember the current ic path.
    input_context_path_ = Or(input_context_path, "");
  }
// Handles "RegisterProperties" signal from chromeos_input_method_ui.
  void RegisterProperties(IBusPropList* ibus_prop_list) {
    DLOG(INFO) << "RegisterProperties" << (ibus_prop_list ? "" : " (clear)");

ImePropertyList prop_list;  // our representation.
if (ibus_prop_list) {
// You can call
//   LOG(INFO) << "\n" << PrintPropList(ibus_prop_list, 0);
// here to dump |ibus_prop_list|.
if (!FlattenPropertyList(ibus_prop_list, &prop_list)) {
// Clear properties on errors.
        RegisterProperties(NULL);
return;
}
}
// Notify the change.
    register_ime_properties_(language_library_, prop_list);
  }
  // Handles "UpdateProperty" signal from chromeos_input_method_ui.
  void UpdateProperty(IBusProperty* ibus_prop) {
    DLOG(INFO) << "UpdateProperty";
    DCHECK(ibus_prop);
    // You can call
    //   LOG(INFO) << "\n" << PrintProp(ibus_prop, 0);
    // here to dump |ibus_prop|.
    ImePropertyList prop_list;  // our representation.
    if (!FlattenProperty(ibus_prop, &prop_list)) {
      // Don't update the UI on errors.
      LOG(ERROR) << "Malformed properties are detected";
      return;
    }
    // Notify the change.
    if (!prop_list.empty()) {
      update_ime_property_(language_library_, prop_list);
    }
}

// Retrieves input method status and notifies them to the UI.
// |current_global_engine_id| is the current global engine id such as "mozc"
// and "xkb:us::eng". If the id is unknown, an empty string "" can be passed.
// Warning: you can call this function only from ibus callback functions
// like FocusIn(). See http://crosbug.com/5217#c9 for details.
void UpdateUI(const char* current_global_engine_id) {
DCHECK(current_global_engine_id);

const IBusEngineInfo* engine_info = NULL;
for (size_t i = 0; i < arraysize(kIBusEngines); ++i) {
if (kIBusEngines[i].name == std::string(current_global_engine_id)) {
engine_info = &kIBusEngines[i];
break;
}
}

if (!engine_info) {
LOG(ERROR) << current_global_engine_id
<< " is not found in the input method white-list.";
return;
}

InputMethodDescriptor current_input_method =
CreateInputMethodDescriptor(engine_info->name,
engine_info->longname,
engine_info->layout,
engine_info->language);

    DLOG(INFO) << "Updating the UI. ID:" << current_input_method.id
               << ", keyboard_layout:" << current_input_method.keyboard_layout;

// Notify the change to update UI.
    current_input_method_changed_(language_library_, current_input_method);
}

// Installs gobject signal handlers to |ibus_|.
void ConnectIBusSignals() {
if (!ibus_) {
return;
}

// We use g_signal_connect_after here since the callback should be called
// *after* the IBusBusDisconnectedCallback in chromeos_input_method_ui.cc
// is called. chromeos_input_method_ui.cc attaches the panel service object
// to |ibus_|, and the callback in this file use the attached object.
g_signal_connect_after(ibus_,
"connected",
                           G_CALLBACK(IBusBusConnectedCallback),
this);

g_signal_connect(ibus_,
"disconnected",
                     G_CALLBACK(IBusBusDisconnectedCallback),
this);
g_signal_connect(ibus_,
"global-engine-changed",
                     G_CALLBACK(IBusBusGlobalEngineChangedCallback),
this);
g_signal_connect(ibus_,
"name-owner-changed",
                     G_CALLBACK(IBusBusNameOwnerChangedCallback),
this);
}

// Installs gobject signal handlers to the panel service.
void ConnectPanelServiceSignals() {
if (!ibus_) {
return;
}

IBusPanelService* ibus_panel_service = IBUS_PANEL_SERVICE(
g_object_get_data(G_OBJECT(ibus_), kPanelObjectKey));
if (!ibus_panel_service) {
LOG(ERROR) << "IBusPanelService is NOT available.";
return;
}
// We don't _ref() or _weak_ref() the panel service object, since we're not
// interested in the life time of the object.

g_signal_connect(ibus_panel_service,
"focus-in",
                     G_CALLBACK(FocusInCallback),
this);
g_signal_connect(ibus_panel_service,
"register-properties",
                     G_CALLBACK(RegisterPropertiesCallback),
this);
g_signal_connect(ibus_panel_service,
"update-property",
                     G_CALLBACK(UpdatePropertyCallback),
this);
}

// Handles "connected" signal from ibus-daemon.
  static void IBusBusConnectedCallback(IBusBus* bus, gpointer user_data) {
LOG(WARNING) << "IBus connection is recovered.";
    // ibus-daemon might be restarted, or the daemon was not running when Chrome
    // started. Anyway, since |ibus_| connection is now ready, it's possible to
    // create |ibus_config_| object by calling MaybeRestoreConnections().
    g_return_if_fail(user_data);
    InputMethodStatusConnection* self
        = static_cast<InputMethodStatusConnection*>(user_data);
    self->MaybeRestoreConnections();
}

// Handles "disconnected" signal from ibus-daemon.
  static void IBusBusDisconnectedCallback(IBusBus* bus, gpointer user_data) {
LOG(WARNING) << "IBus connection is terminated.";
    g_return_if_fail(user_data);
    InputMethodStatusConnection* self
        = static_cast<InputMethodStatusConnection*>(user_data);
// ibus-daemon might be terminated. Since |ibus_| object will automatically
// connect to the daemon if it restarts, we don't have to set NULL on ibus_.
// Call MaybeDestroyIBusConfig() to set |ibus_config_| to NULL temporarily.
    self->MaybeDestroyIBusConfig();
    if (self->connection_change_handler_) {
      LOG(INFO) << "Notifying Chrome that IBus is terminated.";
      self->connection_change_handler_(self->language_library_, false);
    }
}

// Handles "global-engine-changed" signal from ibus-daemon.
  static void IBusBusGlobalEngineChangedCallback(
      IBusBus* bus, const gchar* engine_name, gpointer user_data) {
DCHECK(engine_name);
    DLOG(INFO) << "Global engine is changed to " << engine_name;
    g_return_if_fail(user_data);
    InputMethodStatusConnection* self
        = static_cast<InputMethodStatusConnection*>(user_data);
    self->UpdateUI(engine_name);
}

// Handles "name-owner-changed" signal from ibus-daemon. The signal is sent
// to libcros when an IBus component such as ibus-memconf, ibus-engine-*, ..
// is started.
  static void IBusBusNameOwnerChangedCallback(
      IBusBus* bus,
      const gchar* name, const gchar* old_name, const gchar* new_name,
      gpointer user_data) {
DCHECK(name);
DCHECK(old_name);
DCHECK(new_name);
    DLOG(INFO) << "Name owner is changed: name=" << name
               << ", old_name=" << old_name << ", new_name=" << new_name;

if (name != std::string("org.freedesktop.IBus.Config")) {
// Not a signal for ibus-memconf.
return;
}

const std::string empty_string;
if (old_name != empty_string || new_name == empty_string) {
// ibus-memconf died?
LOG(WARNING) << "Unexpected name owner change: name=" << name
<< ", old_name=" << old_name << ", new_name=" << new_name;
// TODO(yusukes): it might be nice to set |ibus_config_| to NULL and call
      // |connection_change_handler_| with false here to allow Chrome to
// recover all input method configurations when ibus-memconf is
// automatically restarted by ibus-daemon. Though ibus-memconf is pretty
// stable and unlikely crashes.
return;
}

    LOG(INFO) << "IBus config daemon is started. Recovering ibus_config_";
    g_return_if_fail(user_data);
    InputMethodStatusConnection* self
        = static_cast<InputMethodStatusConnection*>(user_data);

// Try to recover |ibus_config_|. If the |ibus_config_| object is
    // successfully created, |connection_change_handler_| will be called to
// notify Chrome that IBus is ready.
    self->MaybeRestoreConnections();
}

// Handles "FocusIn" signal from chromeos_input_method_ui.
  static void FocusInCallback(IBusPanelService* panel,
                              const gchar* path,
                              gpointer user_data) {
    g_return_if_fail(user_data);
    InputMethodStatusConnection* self
        = static_cast<InputMethodStatusConnection*>(user_data);
    self->FocusIn(path);
}

// Handles "RegisterProperties" signal from chromeos_input_method_ui.
  static void RegisterPropertiesCallback(IBusPanelService* panel,
                                         IBusPropList* prop_list,
                                         gpointer user_data) {
    g_return_if_fail(user_data);
    InputMethodStatusConnection* self
        = static_cast<InputMethodStatusConnection*>(user_data);
    self->RegisterProperties(prop_list);
}

// Handles "UpdateProperty" signal from chromeos_input_method_ui.
  static void UpdatePropertyCallback(IBusPanelService* panel,
                                     IBusProperty* ibus_prop,
                                     gpointer user_data) {
    g_return_if_fail(user_data);
    InputMethodStatusConnection* self
        = static_cast<InputMethodStatusConnection*>(user_data);
    self->UpdateProperty(ibus_prop);
}

// A callback function that will be called when ibus_config_set_value_async()
// request is finished.
static void SetImeConfigCallback(GObject* source_object,
GAsyncResult* res,
gpointer user_data) {
IBusConfig* config = IBUS_CONFIG(user_data);
g_return_if_fail(config);

GError* error = NULL;
const gboolean result =
ibus_config_set_value_async_finish(config, res, &error);

if (!result) {
std::string message = "(unknown error)";
if (error && error->message) {
message = error->message;
}
LOG(ERROR) << "ibus_config_set_value_async failed: " << message;
}

if (error) {
g_error_free(error);
}
g_object_unref(config);
}

  // A function pointers which point LanguageLibrary::XXXHandler functions.
  // The functions are used when libcros receives signals from ibus-daemon.
  LanguageCurrentInputMethodMonitorFunction current_input_method_changed_;
  LanguageRegisterImePropertiesFunction register_ime_properties_;
  LanguageUpdateImePropertyFunction update_ime_property_;
  LanguageConnectionChangeMonitorFunction connection_change_handler_;
  // Points to a chromeos::LanguageLibrary object. |language_library_| is used
  // as the first argument of the monitor functions above.
  void* language_library_;
// Connection to the ibus-daemon via IBus API. These objects are used to
// call ibus-daemon's API (e.g. activate input methods, set config, ...)
IBusBus* ibus_;
IBusConfig* ibus_config_;

// Current input context path.
std::string input_context_path_;
};

void StopInputMethodDaemon() {
if (!initialized_successfully_)
return;

should_launch_ime_ = false;
if (ibus_daemon_process_handle_ != base::kNullProcessHandle) {
const base::ProcessId pid = base::GetProcId(ibus_daemon_process_handle_);
      if (!chromeos::StopInputMethodProcess(input_method_status_connection_)) {
LOG(ERROR) << "StopInputMethodProcess IPC failed. Sending SIGTERM to "
<< "PID " << pid;
base::KillProcess(ibus_daemon_process_handle_, -1, false /* wait */);
}
VLOG(1) << "ibus-daemon (PID=" << pid << ") is terminated";
ibus_daemon_process_handle_ = base::kNullProcessHandle;
}
}

InputMethodDescriptors* ChromeOSGetSupportedInputMethodDescriptors() {
  InputMethodDescriptors* input_methods = new InputMethodDescriptors;
  for (size_t i = 0; i < arraysize(chromeos::kIBusEngines); ++i) {
    if (InputMethodIdIsWhitelisted(chromeos::kIBusEngines[i].name)) {
      input_methods->push_back(chromeos::CreateInputMethodDescriptor(
          chromeos::kIBusEngines[i].name,
          chromeos::kIBusEngines[i].longname,
          chromeos::kIBusEngines[i].layout,
          chromeos::kIBusEngines[i].language));
    }
}
  return input_methods;
}

bool XkbLayoutIsSupported(const std::string& xkb_layout) {
  static std::set<std::string>* g_supported_layouts = NULL;
  if (!g_supported_layouts) {
    g_supported_layouts = new std::set<std::string>;
    for (size_t i = 0; i < arraysize(kXkbLayoutsWhitelist); ++i) {
      g_supported_layouts->insert(kXkbLayoutsWhitelist[i]);
    }
  }
  return (g_supported_layouts->count(xkb_layout) > 0);
}

void FlushImeConfig() {
if (!initialized_successfully_)
return;

bool active_input_methods_are_changed = false;
InputMethodConfigRequests::iterator iter =
pending_config_requests_.begin();
while (iter != pending_config_requests_.end()) {
const std::string& section = iter->first.first;
const std::string& config_name = iter->first.second;
      ImeConfigValue& value = iter->second;

if (config_name == language_prefs::kPreloadEnginesConfigName &&
!tentative_current_input_method_id_.empty()) {
// We should use |tentative_current_input_method_id_| as the initial
// active input method for the following reasons:
//
// 1) Calls to ChangeInputMethod() will fail if the input method has not
// yet been added to preload_engines.  As such, the call is deferred
// until after all config values have been sent to the IME process.
//
// 2) We might have already changed the current input method to one
// of XKB layouts without going through the IBus daemon (we can do
// it without the IBus daemon started).
std::vector<std::string>::iterator engine_iter = std::find(
value.string_list_value.begin(),
value.string_list_value.end(),
tentative_current_input_method_id_);
if (engine_iter != value.string_list_value.end()) {
// Use std::rotate to keep the relative order of engines the same e.g.
// from "A,B,C" to "C,A,B".
// We don't have to |active_input_method_ids_|, which decides the
// order of engines in the switcher menu, since the relative order
// of |value.string_list_value| is not changed.
std::rotate(value.string_list_value.begin(),
engine_iter,  // this becomes the new first element
value.string_list_value.end());
} else {
LOG(WARNING) << tentative_current_input_method_id_
<< " is not in preload_engines: " << value.ToString();
}
tentative_current_input_method_id_.erase();
}

      if (chromeos::SetImeConfig(input_method_status_connection_,
                                 section.c_str(),
                                 config_name.c_str(),
                                 value)) {
// Check if it's a change in active input methods.
if (config_name == language_prefs::kPreloadEnginesConfigName) {
active_input_methods_are_changed = true;
VLOG(1) << "Updated preload_engines: " << value.ToString();
}
// Successfully sent. Remove the command and proceed to the next one.
pending_config_requests_.erase(iter++);
} else {
// If SetImeConfig() fails, subsequent calls will likely fail.
break;
}
}

// Notify the current input method and the number of active input methods to
// the UI so that the UI could determine e.g. if it should show/hide the
// input method indicator, etc. We have to call FOR_EACH_OBSERVER here since
// updating "preload_engine" does not necessarily trigger a DBus signal such
// as "global-engine-changed". For example,
// 1) If we change the preload_engine from "xkb:us:intl:eng" (i.e. the
//    indicator is hidden) to "xkb:us:intl:eng,mozc", we have to update UI
//    so it shows the indicator, but no signal is sent from ibus-daemon
//    because the current input method is not changed.
// 2) If we change the preload_engine from "xkb:us::eng,mozc" (i.e. the
//    indicator is shown and ibus-daemon is started) to "xkb:us::eng", we
//    have to update UI so it hides the indicator, but we should not expect
//    that ibus-daemon could send a DBus signal since the daemon is killed
//    right after this FlushImeConfig() call.
if (active_input_methods_are_changed) {
// The |current_input_method_| member might be stale here as
// SetImeConfig("preload_engine") call above might change the
// current input method in ibus-daemon (ex. this occurs when the
// input method currently in use is removed from the options
// page). However, it should be safe to use the member here,
// for the following reasons:
// 1. If ibus-daemon is to be killed, we'll switch to the only one
//    keyboard layout, and observers are notified. See
//    MaybeStopInputMethodDaemon() for details.
// 2. Otherwise, "global-engine-changed" signal is delivered from
//    ibus-daemon, and observers are notified. See
//    InputMethodChangedHandler() for details.
const size_t num_active_input_methods = GetNumActiveInputMethods();
      FOR_EACH_OBSERVER(Observer, observers_,
ActiveInputMethodsChanged(this,
current_input_method_,
num_active_input_methods));
}
}

virtual void ChangeInputMethod(const std::string& input_method_id) {
// Changing the input method isn't guaranteed to succeed here, but we
// should remember the last one regardless. See comments in
// FlushImeConfig() for details.
tentative_current_input_method_id_ = input_method_id;
// If the input method daemon is not running and the specified input
// method is a keyboard layout, switch the keyboard directly.
if (ibus_daemon_process_handle_ == base::kNullProcessHandle &&
        chromeos::input_method::IsKeyboardLayout(input_method_id)) {
// We shouldn't use SetCurrentKeyboardLayoutByName() here. See
// comments at ChangeCurrentInputMethod() for details.
ChangeCurrentInputMethodFromId(input_method_id);
} else {
// Otherwise, start the input method daemon, and change the input
// method via the daemon.
StartInputMethodDaemon();
// ChangeInputMethodViaIBus() fails if the IBus daemon is not
// ready yet. In this case, we'll defer the input method change
// until the daemon is ready.
if (!ChangeInputMethodViaIBus(input_method_id)) {
VLOG(1) << "Failed to change the input method to " << input_method_id
<< " (deferring)";
}
}
}

CrosMock::CrosMock()
    : loader_(NULL),
      mock_cryptohome_library_(NULL),
      mock_input_method_library_(NULL),
      mock_network_library_(NULL),
      mock_power_library_(NULL),
      mock_screen_lock_library_(NULL),
      mock_speech_synthesis_library_(NULL),
      mock_touchpad_library_(NULL) {
  current_input_method_ =
      input_method::GetFallbackInputMethodDescriptor();
}

virtual bool SetImeConfig(const std::string& section,
const std::string& config_name,
                            const ImeConfigValue& value) {
return false;
}

   virtual void CancelHandwritingStrokes(int stroke_count) {}

static InputMethodStatusConnection* GetInstance() {
    return Singleton<InputMethodStatusConnection,
        LeakySingletonTraits<InputMethodStatusConnection> >::get();
}

virtual size_t GetNumActiveInputMethods() {
    scoped_ptr<InputMethodDescriptors> descriptors(GetActiveInputMethods());
return descriptors->size();
}
