  ~AudioOutputDeviceTest() {}

void AudioOutputDevice::InitializeIO(const AudioParameters& params,
                                     int input_channels,
                                     RenderCallback* callback) {
  DCHECK_GE(input_channels, 0);
  DCHECK_LT(input_channels, limits::kMaxChannels);
  input_channels_ = input_channels;
  Initialize(params, callback);
}

ACTION_P2(SendPendingBytes, socket, pending_bytes) {
  socket->Send(&pending_bytes, sizeof(pending_bytes));
}

  virtual ~MockAudioOutputIPC() {}

void AudioOutputDevice::PlayOnIOThread() {
  DCHECK(message_loop()->BelongsToCurrentThread());
  if (stream_id_ && is_started_)
    ipc_->PlayStream(stream_id_);
  else
    play_on_start_ = true;
}

void AudioOutputDevice::SetVolumeOnIOThread(double volume) {
  DCHECK(message_loop()->BelongsToCurrentThread());
  if (stream_id_)
    ipc_->SetVolume(stream_id_, volume);
}

void AudioOutputDevice::OnStreamCreated(
base::SharedMemoryHandle handle,
base::SyncSocket::Handle socket_handle,
int length) {
DCHECK(message_loop()->BelongsToCurrentThread());
#if defined(OS_WIN)
DCHECK(handle);
DCHECK(socket_handle);
#else
DCHECK_GE(handle.fd, 0);
DCHECK_GE(socket_handle, 0);
#endif

// We should only get this callback if stream_id_ is valid.  If it is not,
// the IPC layer should have closed the shared memory and socket handles
// for us and not invoked the callback.  The basic assertion is that when
// stream_id_ is 0 the AudioOutputDevice instance is not registered as a
// delegate and hence it should not receive callbacks.
DCHECK(stream_id_);

  // No-op in the case where the client calls Stop() before OnStreamCreated() is
  // called, otherwise we spin up the thread with a potentially freed
  // |callback_| pointer.
base::AutoLock auto_lock(audio_thread_lock_);
  if (!audio_thread_.get())
    return;

  DCHECK(audio_thread_->IsStopped());
audio_callback_.reset(new AudioOutputDevice::AudioThreadCallback(
audio_parameters_, input_channels_, handle, length, callback_));
  audio_thread_->Start(
      audio_callback_.get(), socket_handle, "AudioOutputDevice");

// We handle the case where Play() and/or Pause() may have been called
// multiple times before OnStreamCreated() gets called.
is_started_ = true;
if (play_on_start_)
PlayOnIOThread();
}

bool DuplicateSocketHandle(SyncSocket::Handle socket_handle,
                           SyncSocket::Handle* copy) {
#if defined(OS_WIN)
  HANDLE process = GetCurrentProcess();
  ::DuplicateHandle(process, socket_handle, process, copy,
                    0, FALSE, DUPLICATE_SAME_ACCESS);
  return *copy != NULL;
#else
  *copy = socket_handle;
  return *copy != -1;
#endif
}

void AudioOutputDevice::OnStateChanged(AudioOutputIPCDelegate::State state) {
DCHECK(message_loop()->BelongsToCurrentThread());

// Do nothing if the stream has been closed.
if (!stream_id_)
return;

if (state == AudioOutputIPCDelegate::kError) {
DLOG(WARNING) << "AudioOutputDevice::OnStateChanged(kError)";
// Don't dereference the callback object if the audio thread
// is stopped or stopping.  That could mean that the callback
// object has been deleted.
// TODO(tommi): Add an explicit contract for clearing the callback
// object.  Possibly require calling Initialize again or provide
// a callback object via Start() and clear it in Stop().
    base::AutoLock auto_lock_(audio_thread_lock_);
    if (audio_thread_.get() && !audio_thread_->IsStopped())
callback_->OnRenderError();
}
}

AudioOutputDevice::AudioOutputDevice(
AudioOutputIPC* ipc,
const scoped_refptr<base::MessageLoopProxy>& io_loop)
: ScopedLoopObserver(io_loop),
input_channels_(0),
callback_(NULL),
ipc_(ipc),
stream_id_(0),
play_on_start_(true),
      is_started_(false),
      audio_thread_(new AudioDeviceThread()) {
CHECK(ipc_);
}

void AudioOutputDeviceTest::CreateStream(bool synchronized_io) {
  const int kMemorySize = CalculateMemorySize(synchronized_io);
  ASSERT_TRUE(shared_memory_.CreateAndMapAnonymous(kMemorySize));
  memset(shared_memory_.memory(), 0xff, kMemorySize);

  ASSERT_TRUE(CancelableSyncSocket::CreatePair(&browser_socket_,
                                               &renderer_socket_));

  SyncSocket::Handle audio_device_socket = SyncSocket::kInvalidHandle;
  ASSERT_TRUE(DuplicateSocketHandle(renderer_socket_.handle(),
                                    &audio_device_socket));
  base::SharedMemoryHandle duplicated_memory_handle;
  ASSERT_TRUE(shared_memory_.ShareToProcess(base::GetCurrentProcessHandle(),
                                            &duplicated_memory_handle));

  audio_device_->OnStreamCreated(duplicated_memory_handle, audio_device_socket,
                                 PacketSizeInBytes(kMemorySize));
  io_loop_.RunAllPending();
}

ACTION_P(QuitLoop, loop) {
  loop->PostTask(FROM_HERE, MessageLoop::QuitClosure());
}

void AudioOutputDevice::AudioThreadCallback::MapSharedMemory() {
  shared_memory_.Map(TotalSharedMemorySizeInBytes(memory_length_));

  int output_memory_size = AudioBus::CalculateMemorySize(audio_parameters_);
  int frames = audio_parameters_.frames_per_buffer();
  int input_memory_size =
      AudioBus::CalculateMemorySize(input_channels_, frames);

  int io_size = output_memory_size + input_memory_size;

  DCHECK_EQ(memory_length_, io_size);

  output_bus_ =
      AudioBus::WrapMemory(audio_parameters_, shared_memory_.memory());

  if (input_channels_ > 0) {
    char* input_data =
        static_cast<char*>(shared_memory_.memory()) + output_memory_size;
    input_bus_ =
        AudioBus::WrapMemory(input_channels_, frames, input_data);
  }
}

void AudioOutputDevice::Start() {
  DCHECK(callback_) << "Initialize hasn't been called";
  message_loop()->PostTask(FROM_HERE,
      base::Bind(&AudioOutputDevice::CreateStreamOnIOThread, this,
                 audio_parameters_, input_channels_));
}

void AudioOutputDevice::Pause(bool flush) {
  message_loop()->PostTask(FROM_HERE,
      base::Bind(&AudioOutputDevice::PauseOnIOThread, this, flush));
}

void AudioOutputDevice::OnIPCClosed() {
  ipc_ = NULL;
}

void AudioOutputDevice::ShutDownOnIOThread() {
DCHECK(message_loop()->BelongsToCurrentThread());

// Make sure we don't call shutdown more than once.
if (stream_id_) {
is_started_ = false;

if (ipc_) {
ipc_->CloseStream(stream_id_);
ipc_->RemoveDelegate(stream_id_);
}

stream_id_ = 0;
}

// We can run into an issue where ShutDownOnIOThread is called right after
// OnStreamCreated is called in cases where Start/Stop are called before we
// get the OnStreamCreated callback.  To handle that corner case, we call
// Stop(). In most cases, the thread will already be stopped.
// Another situation is when the IO thread goes away before Stop() is called
// in which case, we cannot use the message loop to close the thread handle
// and can't not rely on the main thread existing either.
  base::AutoLock auto_lock_(audio_thread_lock_);
  if (!audio_thread_.get())
    return;
base::ThreadRestrictions::ScopedAllowIO allow_io;
  audio_thread_->Stop(NULL);
  audio_thread_.reset();
audio_callback_.reset();
}

void AudioOutputDevice::PauseOnIOThread(bool flush) {
  DCHECK(message_loop()->BelongsToCurrentThread());
  if (stream_id_ && is_started_) {
    ipc_->PauseStream(stream_id_);
    if (flush)
      ipc_->FlushStream(stream_id_);
  } else {
    play_on_start_ = false;
  }
}

void AudioOutputDeviceTest::StartAudioDevice(bool synchronized_io) {
  const int kInputChannels = synchronized_io ? 2 : 0;

  if (synchronized_io) {
    audio_device_->InitializeIO(default_audio_parameters_,
                                kInputChannels,
                                &callback_);
  } else {
    audio_device_->Initialize(default_audio_parameters_, &callback_);
  }

  audio_device_->Start();

  EXPECT_CALL(audio_output_ipc_, AddDelegate(audio_device_.get()))
      .WillOnce(Return(kStreamId));
  EXPECT_CALL(audio_output_ipc_, CreateStream(kStreamId, _, _));

  io_loop_.RunAllPending();
}

  MockAudioOutputIPC() {}

  MockRenderCallback() {}

void AudioOutputDeviceTest::WaitUntilRenderCallback() {
  io_loop_.PostDelayedTask(FROM_HERE, MessageLoop::QuitClosure(),
                           TestTimeouts::action_timeout());
  io_loop_.Run();
}

void AudioOutputDevice::WillDestroyCurrentMessageLoop() {
  LOG(ERROR) << "IO loop going away before the audio device has been stopped";
  ShutDownOnIOThread();
}

void AudioOutputDevice::Stop() {
{
base::AutoLock auto_lock(audio_thread_lock_);
    audio_thread_->Stop(MessageLoop::current());
    audio_thread_.reset();
}

message_loop()->PostTask(FROM_HERE,
base::Bind(&AudioOutputDevice::ShutDownOnIOThread, this));
}

bool AudioOutputDevice::SetVolume(double volume) {
  if (volume < 0 || volume > 1.0)
    return false;

  if (!message_loop()->PostTask(FROM_HERE,
          base::Bind(&AudioOutputDevice::SetVolumeOnIOThread, this, volume))) {
    return false;
  }

  return true;
}

void AudioOutputDevice::Play() {
  message_loop()->PostTask(FROM_HERE,
      base::Bind(&AudioOutputDevice::PlayOnIOThread, this));
}

int AudioOutputDeviceTest::CalculateMemorySize(bool synchronized_io) {
  int kInputChannels = synchronized_io ? 2 : 0;

  int output_memory_size =
      AudioBus::CalculateMemorySize(default_audio_parameters_);

  int frames = default_audio_parameters_.frames_per_buffer();
  int input_memory_size =
      AudioBus::CalculateMemorySize(kInputChannels, frames);

  int io_buffer_size = output_memory_size + input_memory_size;

  return TotalSharedMemorySizeInBytes(io_buffer_size);
}

  virtual ~MockRenderCallback() {}

AudioOutputDevice::AudioThreadCallback::~AudioThreadCallback() {
}

AudioOutputDevice::~AudioOutputDevice() {
  CHECK_EQ(0, stream_id_);
}

void AudioOutputDevice::AudioThreadCallback::Process(int pending_data) {
  if (pending_data == kPauseMark) {
    memset(shared_memory_.memory(), 0, memory_length_);
    SetActualDataSizeInBytes(&shared_memory_, memory_length_, 0);
    return;
  }

  int audio_delay_milliseconds = pending_data / bytes_per_ms_;

  TRACE_EVENT0("audio", "AudioOutputDevice::FireRenderCallback");

  size_t num_frames = audio_parameters_.frames_per_buffer();

  if (input_bus_.get() && input_channels_ > 0) {
    render_callback_->RenderIO(input_bus_.get(),
                               output_bus_.get(),
                               audio_delay_milliseconds);
  } else {
    num_frames = render_callback_->Render(output_bus_.get(),
                                          audio_delay_milliseconds);
  }

  SetActualDataSizeInBytes(
      &shared_memory_, memory_length_,
      num_frames * sizeof(*output_bus_->channel(0)) * output_bus_->channels());
}
