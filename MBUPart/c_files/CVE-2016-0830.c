bool btif_get_device_type(const BD_ADDR bd_addr, int *p_device_type)
{
 if (p_device_type == NULL)
 return FALSE;

 bt_bdaddr_t bda;
    bdcpy(bda.address, bd_addr);

 bdstr_t bd_addr_str;
    bdaddr_to_string(&bda, bd_addr_str, sizeof(bd_addr_str));

 if (!btif_config_get_int(bd_addr_str, "DevType", p_device_type))
 return FALSE;

    LOG_DEBUG(LOG_TAG, "%s: Device [%s] type %d", __FUNCTION__, bd_addr_str, *p_device_type);
 return TRUE;
}

static future_t *init(void) {
  pthread_mutex_init(&lock, NULL);
  config = config_new(CONFIG_FILE_PATH);
 if (!config) {
    LOG_WARN(LOG_TAG, "%s unable to load config file; attempting to transcode legacy file.", __func__);
    config = btif_config_transcode(LEGACY_CONFIG_FILE_PATH);
 if (!config) {
      LOG_WARN(LOG_TAG, "%s unable to transcode legacy file, starting unconfigured.", __func__);
      config = config_new_empty();
 if (!config) {
        LOG_ERROR(LOG_TAG, "%s unable to allocate a config object.", __func__);
 goto error;
 }
 }

 if (config_save(config, CONFIG_FILE_PATH))

       unlink(LEGACY_CONFIG_FILE_PATH);
   }
 
  alarm_timer = alarm_new();
 if (!alarm_timer) {
    LOG_ERROR(LOG_TAG, "%s unable to create alarm.", __func__);
 goto error;
 }

 return future_new_immediate(FUTURE_SUCCESS);

error:;
  alarm_free(alarm_timer);
  config_free(config);
  pthread_mutex_destroy(&lock);
  alarm_timer = NULL;
  config = NULL;
 return future_new_immediate(FUTURE_FAIL);
}

void btif_config_flush(void) {
assert(config != NULL);
assert(alarm_timer != NULL);


alarm_cancel(alarm_timer);

  pthread_mutex_lock(&lock);
  config_save(config, CONFIG_FILE_PATH);
  pthread_mutex_unlock(&lock);
}

void btif_config_save(void) {

assert(alarm_timer != NULL);
assert(config != NULL);

  alarm_set(alarm_timer, CONFIG_SETTLE_PERIOD_MS, timer_config_save, NULL);
}

 int btif_config_clear(void){
  assert(config != NULL);
  assert(alarm_timer != NULL);

  alarm_cancel(alarm_timer);

  pthread_mutex_lock(&lock);
  config_free(config);

  config = config_new_empty();
 if (config == NULL) {
    pthread_mutex_unlock(&lock);
 return false;
 }

 int ret = config_save(config, CONFIG_FILE_PATH);
  pthread_mutex_unlock(&lock);

   return ret;
 }

static void timer_config_save(UNUSED_ATTR void *data) {
assert(config != NULL);
assert(alarm_timer != NULL);

  // Garbage collection process: the config file accumulates
  // cached information about remote devices during regular
  // inquiry scans. We remove some of these junk entries
  // so the file doesn't grow indefinitely. We have to take care
  // to make sure we don't remove information about bonded
  // devices (hence the check for link keys).
  static const size_t CACHE_MAX = 256;
  const char *keys[CACHE_MAX];
  size_t num_keys = 0;
  size_t total_candidates = 0;

pthread_mutex_lock(&lock);
  for (const config_section_node_t *snode = config_section_begin(config); snode != config_section_end(config); snode = config_section_next(snode)) {
    const char *section = config_section_name(snode);
    if (!string_is_bdaddr(section))
      continue;
    if (config_has_key(config, section, "LinkKey") ||
        config_has_key(config, section, "LE_KEY_PENC") ||
        config_has_key(config, section, "LE_KEY_PID") ||
        config_has_key(config, section, "LE_KEY_PCSRK") ||
        config_has_key(config, section, "LE_KEY_LENC") ||
        config_has_key(config, section, "LE_KEY_LCSRK"))
      continue;
    if (num_keys < CACHE_MAX)
      keys[num_keys++] = section;
    ++total_candidates;
  }
  if (total_candidates > CACHE_MAX * 2)
    while (num_keys > 0)
      config_remove_section(config, keys[--num_keys]);
config_save(config, CONFIG_FILE_PATH);
pthread_mutex_unlock(&lock);
}

bool btif_get_address_type(const BD_ADDR bd_addr, int *p_addr_type)
{
 if (p_addr_type == NULL)
 return FALSE;

 bt_bdaddr_t bda;
    bdcpy(bda.address, bd_addr);

 bdstr_t bd_addr_str;
    bdaddr_to_string(&bda, bd_addr_str, sizeof(bd_addr_str));

 if (!btif_config_get_int(bd_addr_str, "AddrType", p_addr_type))
 return FALSE;

    LOG_DEBUG(LOG_TAG, "%s: Device [%s] address type %d", __FUNCTION__, bd_addr_str, *p_addr_type);
 return TRUE;
}
