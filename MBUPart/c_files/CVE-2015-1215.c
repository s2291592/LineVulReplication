void BluetoothRemoteGATTServer::disconnect(ScriptState* scriptState) {
  if (!m_connected)
    return;
  device()->cleanupDisconnectedDeviceAndFireEvent();
  m_device->bluetooth()->removeDevice(device()->id());
  mojom::blink::WebBluetoothService* service = m_device->bluetooth()->service();
  service->RemoteServerDisconnect(device()->id());
}

ScriptPromise BluetoothRemoteGATTServer::getPrimaryService(
    ScriptState* scriptState,
    const StringOrUnsignedLong& service,
    ExceptionState& exceptionState) {
  String serviceUUID = BluetoothUUID::getService(service, exceptionState);
  if (exceptionState.hadException())
    return exceptionState.reject(scriptState);

  return getPrimaryServicesImpl(
      scriptState, mojom::blink::WebBluetoothGATTQueryQuantity::SINGLE,
      serviceUUID);
}

BluetoothRemoteGATTServer* BluetoothRemoteGATTServer::create(
    BluetoothDevice* device) {
  return new BluetoothRemoteGATTServer(device);
}

ScriptPromise BluetoothRemoteGATTServer::getPrimaryServices(
    ScriptState* scriptState,
    ExceptionState&) {
  return getPrimaryServicesImpl(
      scriptState, mojom::blink::WebBluetoothGATTQueryQuantity::MULTIPLE);
}

ScriptPromise BluetoothRemoteGATTServer::getPrimaryServices(
    ScriptState* scriptState,
    const StringOrUnsignedLong& service,
    ExceptionState& exceptionState) {
  String serviceUUID = BluetoothUUID::getService(service, exceptionState);
  if (exceptionState.hadException())
    return exceptionState.reject(scriptState);

  return getPrimaryServicesImpl(
      scriptState, mojom::blink::WebBluetoothGATTQueryQuantity::MULTIPLE,
      serviceUUID);
}

void BluetoothRemoteGATTService::GetCharacteristicsCallback(
    const String& serviceInstanceId,
    mojom::blink::WebBluetoothGATTQueryQuantity quantity,
    ScriptPromiseResolver* resolver,
    mojom::blink::WebBluetoothResult result,
    Optional<Vector<mojom::blink::WebBluetoothRemoteGATTCharacteristicPtr>>
        characteristics) {
  if (!resolver->getExecutionContext() ||
      resolver->getExecutionContext()->isContextDestroyed())
    return;

  if (!device()->gatt()->RemoveFromActiveAlgorithms(resolver)) {
    resolver->reject(
        DOMException::create(NetworkError, kGATTServerDisconnected));
    return;
  }

  if (result == mojom::blink::WebBluetoothResult::SUCCESS) {
    DCHECK(characteristics);

    if (quantity == mojom::blink::WebBluetoothGATTQueryQuantity::SINGLE) {
      DCHECK_EQ(1u, characteristics->size());
      resolver->resolve(device()->getOrCreateRemoteGATTCharacteristic(
          resolver->getExecutionContext(),
          std::move(characteristics.value()[0]), this));
      return;
    }

    HeapVector<Member<BluetoothRemoteGATTCharacteristic>> gattCharacteristics;
    gattCharacteristics.reserveInitialCapacity(characteristics->size());
    for (auto& characteristic : characteristics.value()) {
      gattCharacteristics.push_back(
          device()->getOrCreateRemoteGATTCharacteristic(
              resolver->getExecutionContext(), std::move(characteristic),
              this));
    }
    resolver->resolve(gattCharacteristics);
  } else {
    resolver->reject(BluetoothError::take(resolver, result));
  }
}

ScriptPromise BluetoothRemoteGATTCharacteristic::writeValue(
    ScriptState* scriptState,
    const DOMArrayPiece& value) {
  if (!getGatt()->connected()) {
    return ScriptPromise::rejectWithDOMException(
        scriptState,
        BluetoothRemoteGATTUtils::CreateDOMException(
            BluetoothRemoteGATTUtils::ExceptionType::kGATTServerNotConnected));
  }

  if (!getGatt()->device()->isValidCharacteristic(
          m_characteristic->instance_id)) {
    return ScriptPromise::rejectWithDOMException(
        scriptState,
        BluetoothRemoteGATTUtils::CreateDOMException(
            BluetoothRemoteGATTUtils::ExceptionType::kInvalidCharacteristic));
  }


  if (value.byteLength() > 512)
    return ScriptPromise::rejectWithDOMException(
        scriptState, DOMException::create(InvalidModificationError,
                                          "Value can't exceed 512 bytes."));

  Vector<uint8_t> valueVector;
  valueVector.append(value.bytes(), value.byteLength());

  ScriptPromiseResolver* resolver = ScriptPromiseResolver::create(scriptState);
  ScriptPromise promise = resolver->promise();
  getGatt()->AddToActiveAlgorithms(resolver);

  mojom::blink::WebBluetoothService* service = m_device->bluetooth()->service();
  service->RemoteCharacteristicWriteValue(
      m_characteristic->instance_id, valueVector,
      convertToBaseCallback(WTF::bind(
          &BluetoothRemoteGATTCharacteristic::WriteValueCallback,
          wrapPersistent(this), wrapPersistent(resolver), valueVector)));

  return promise;
}

ScriptPromise BluetoothRemoteGATTServer::getPrimaryServicesImpl(
ScriptState* scriptState,
mojom::blink::WebBluetoothGATTQueryQuantity quantity,
String servicesUUID) {
// We always check that the device is connected.
if (!connected()) {
return ScriptPromise::rejectWithDOMException(
scriptState,
DOMException::create(NetworkError, kGATTServerNotConnected));
}

ScriptPromiseResolver* resolver = ScriptPromiseResolver::create(scriptState);
ScriptPromise promise = resolver->promise();
AddToActiveAlgorithms(resolver);

mojom::blink::WebBluetoothService* service = m_device->bluetooth()->service();
  WTF::Optional<String> uuid = WTF::nullopt;
  if (!servicesUUID.isEmpty())
    uuid = servicesUUID;
service->RemoteServerGetPrimaryServices(
      device()->id(), quantity, uuid,
convertToBaseCallback(
WTF::bind(&BluetoothRemoteGATTServer::GetPrimaryServicesCallback,
wrapPersistent(this), quantity, wrapPersistent(resolver))));
return promise;
}

DEFINE_TRACE(BluetoothRemoteGATTService) {
  visitor->trace(m_device);
}

ScriptPromise BluetoothRemoteGATTCharacteristic::getDescriptor(
    ScriptState* scriptState,
    const StringOrUnsignedLong& descriptorUUID,
    ExceptionState& exceptionState) {
  String descriptor =
      BluetoothUUID::getDescriptor(descriptorUUID, exceptionState);
  if (exceptionState.hadException())
    return exceptionState.reject(scriptState);

  return getDescriptorsImpl(scriptState,
                            mojom::blink::WebBluetoothGATTQueryQuantity::SINGLE,
                            descriptor);
}

void BluetoothRemoteGATTCharacteristic::setValue(DOMDataView* domDataView) {
  m_value = domDataView;
}

void BluetoothRemoteGATTCharacteristic::dispose() {
  notifyCharacteristicObjectRemoved();
}

ScriptPromise BluetoothRemoteGATTCharacteristic::stopNotifications(
    ScriptState* scriptState) {
  if (!getGatt()->connected()) {
    return ScriptPromise::rejectWithDOMException(
        scriptState,
        BluetoothRemoteGATTUtils::CreateDOMException(
            BluetoothRemoteGATTUtils::ExceptionType::kGATTServerNotConnected));
  }

  if (!getGatt()->device()->isValidCharacteristic(
          m_characteristic->instance_id)) {
    return ScriptPromise::rejectWithDOMException(
        scriptState,
        BluetoothRemoteGATTUtils::CreateDOMException(
            BluetoothRemoteGATTUtils::ExceptionType::kInvalidCharacteristic));
  }

  ScriptPromiseResolver* resolver = ScriptPromiseResolver::create(scriptState);
  ScriptPromise promise = resolver->promise();
  getGatt()->AddToActiveAlgorithms(resolver);

  mojom::blink::WebBluetoothService* service = m_device->bluetooth()->service();
  service->RemoteCharacteristicStopNotifications(
      m_characteristic->instance_id,
      convertToBaseCallback(
          WTF::bind(&BluetoothRemoteGATTCharacteristic::NotificationsCallback,
                    wrapPersistent(this), wrapPersistent(resolver),
                    mojom::blink::WebBluetoothResult::SUCCESS)));
  return promise;
}

bool StructTraits<bluetooth::mojom::UUIDDataView, WTF::String>::Read(
    bluetooth::mojom::UUIDDataView data,
    WTF::String* output) {
   return data.ReadUuid(output);
 }

ExecutionContext* BluetoothRemoteGATTCharacteristic::getExecutionContext()
    const {
  return ContextLifecycleObserver::getExecutionContext();
}

void BluetoothRemoteGATTCharacteristic::WriteValueCallback(
    ScriptPromiseResolver* resolver,
    const Vector<uint8_t>& value,
    mojom::blink::WebBluetoothResult result) {
  if (!resolver->getExecutionContext() ||
      resolver->getExecutionContext()->isContextDestroyed())
    return;

  if (!getGatt()->RemoveFromActiveAlgorithms(resolver)) {
    resolver->reject(BluetoothRemoteGATTUtils::CreateDOMException(
        BluetoothRemoteGATTUtils::ExceptionType::kGATTServerDisconnected));
    return;
  }

  if (result == mojom::blink::WebBluetoothResult::SUCCESS) {
    setValue(BluetoothRemoteGATTUtils::ConvertWTFVectorToDataView(value));
    resolver->resolve();
  } else {
    resolver->reject(BluetoothError::take(resolver, result));
  }
}

ScriptPromise BluetoothRemoteGATTCharacteristic::getDescriptors(
    ScriptState* scriptState,
    const StringOrUnsignedLong& descriptorUUID,
    ExceptionState& exceptionState) {
  String descriptor =
      BluetoothUUID::getDescriptor(descriptorUUID, exceptionState);
  if (exceptionState.hadException())
    return exceptionState.reject(scriptState);

  return getDescriptorsImpl(
      scriptState, mojom::blink::WebBluetoothGATTQueryQuantity::MULTIPLE,
      descriptor);
}

BluetoothRemoteGATTCharacteristic::BluetoothRemoteGATTCharacteristic(
    ExecutionContext* context,
    mojom::blink::WebBluetoothRemoteGATTCharacteristicPtr characteristic,
    BluetoothRemoteGATTService* service,
    BluetoothDevice* device)
    : ContextLifecycleObserver(context),
      m_characteristic(std::move(characteristic)),
      m_service(service),
      m_stopped(false),
      m_device(device) {
  m_properties =
      BluetoothCharacteristicProperties::create(m_characteristic->properties);
}

void BluetoothRemoteGATTCharacteristic::dispatchCharacteristicValueChanged(
    const Vector<uint8_t>& value) {
  this->setValue(BluetoothRemoteGATTUtils::ConvertWTFVectorToDataView(value));
  dispatchEvent(Event::create(EventTypeNames::characteristicvaluechanged));
}

ScriptPromise BluetoothRemoteGATTCharacteristic::readValue(
    ScriptState* scriptState) {
  if (!getGatt()->connected()) {
    return ScriptPromise::rejectWithDOMException(
        scriptState,
        BluetoothRemoteGATTUtils::CreateDOMException(
            BluetoothRemoteGATTUtils::ExceptionType::kGATTServerNotConnected));
  }

  if (!getGatt()->device()->isValidCharacteristic(
          m_characteristic->instance_id)) {
    return ScriptPromise::rejectWithDOMException(
        scriptState,
        BluetoothRemoteGATTUtils::CreateDOMException(
            BluetoothRemoteGATTUtils::ExceptionType::kInvalidCharacteristic));
  }

  ScriptPromiseResolver* resolver = ScriptPromiseResolver::create(scriptState);
  ScriptPromise promise = resolver->promise();
  getGatt()->AddToActiveAlgorithms(resolver);

  mojom::blink::WebBluetoothService* service = m_device->bluetooth()->service();
  service->RemoteCharacteristicReadValue(
      m_characteristic->instance_id,
      convertToBaseCallback(
          WTF::bind(&BluetoothRemoteGATTCharacteristic::ReadValueCallback,
                    wrapPersistent(this), wrapPersistent(resolver))));

  return promise;
}

ScriptPromise BluetoothRemoteGATTServer::connect(ScriptState* scriptState) {
  m_device->bluetooth()->addDevice(device()->id(), device());

  ScriptPromiseResolver* resolver = ScriptPromiseResolver::create(scriptState);
  ScriptPromise promise = resolver->promise();

  mojom::blink::WebBluetoothService* service = m_device->bluetooth()->service();
  service->RemoteServerConnect(
      device()->id(), convertToBaseCallback(WTF::bind(
                          &BluetoothRemoteGATTServer::ConnectCallback,
                          wrapPersistent(this), wrapPersistent(resolver))));

  return promise;
}

BluetoothRemoteGATTService::BluetoothRemoteGATTService(
    mojom::blink::WebBluetoothRemoteGATTServicePtr service,
    bool isPrimary,
    const String& deviceInstanceId,
    BluetoothDevice* device)
    : m_service(std::move(service)),
      m_isPrimary(isPrimary),
      m_deviceInstanceId(deviceInstanceId),
      m_device(device) {}

BluetoothRemoteGATTServer::BluetoothRemoteGATTServer(BluetoothDevice* device)
    : m_device(device), m_connected(false) {}

ScriptPromise BluetoothRemoteGATTCharacteristic::startNotifications(
    ScriptState* scriptState) {
  if (!getGatt()->connected()) {
    return ScriptPromise::rejectWithDOMException(
        scriptState,
        BluetoothRemoteGATTUtils::CreateDOMException(
            BluetoothRemoteGATTUtils::ExceptionType::kGATTServerNotConnected));
  }

  if (!getGatt()->device()->isValidCharacteristic(
          m_characteristic->instance_id)) {
    return ScriptPromise::rejectWithDOMException(
        scriptState,
        BluetoothRemoteGATTUtils::CreateDOMException(
            BluetoothRemoteGATTUtils::ExceptionType::kInvalidCharacteristic));
  }

  ScriptPromiseResolver* resolver = ScriptPromiseResolver::create(scriptState);
  ScriptPromise promise = resolver->promise();
  getGatt()->AddToActiveAlgorithms(resolver);

  mojom::blink::WebBluetoothService* service = m_device->bluetooth()->service();
  service->RemoteCharacteristicStartNotifications(
      m_characteristic->instance_id,
      convertToBaseCallback(
          WTF::bind(&BluetoothRemoteGATTCharacteristic::NotificationsCallback,
                    wrapPersistent(this), wrapPersistent(resolver))));

  return promise;
}

ScriptPromise BluetoothRemoteGATTCharacteristic::getDescriptorsImpl(
ScriptState* scriptState,
mojom::blink::WebBluetoothGATTQueryQuantity quantity,
    const String& descriptor) {
if (!getGatt()->connected()) {
return ScriptPromise::rejectWithDOMException(
scriptState,
BluetoothRemoteGATTUtils::CreateDOMException(
BluetoothRemoteGATTUtils::ExceptionType::kGATTServerNotConnected));
}

if (!getGatt()->device()->isValidCharacteristic(
m_characteristic->instance_id)) {
return ScriptPromise::rejectWithDOMException(
scriptState,
BluetoothRemoteGATTUtils::CreateDOMException(
BluetoothRemoteGATTUtils::ExceptionType::kInvalidCharacteristic));
}

ScriptPromiseResolver* resolver = ScriptPromiseResolver::create(scriptState);
ScriptPromise promise = resolver->promise();
getGatt()->AddToActiveAlgorithms(resolver);

mojom::blink::WebBluetoothService* service = m_device->bluetooth()->service();
  WTF::Optional<String> uuid = WTF::nullopt;
  if (!descriptor.isEmpty())
    uuid = descriptor;
service->RemoteCharacteristicGetDescriptors(
      m_characteristic->instance_id, quantity, uuid,
convertToBaseCallback(
WTF::bind(&BluetoothRemoteGATTCharacteristic::GetDescriptorsCallback,
wrapPersistent(this), m_characteristic->instance_id,
quantity, wrapPersistent(resolver))));

return promise;
}

void BluetoothRemoteGATTServer::AddToActiveAlgorithms(
    ScriptPromiseResolver* resolver) {
  auto result = m_activeAlgorithms.add(resolver);
  CHECK(result.isNewEntry);
}

ScriptPromise BluetoothRemoteGATTService::getCharacteristics(
    ScriptState* scriptState,
    ExceptionState&) {
  return getCharacteristicsImpl(
      scriptState, mojom::blink::WebBluetoothGATTQueryQuantity::MULTIPLE);
}

BluetoothRemoteGATTCharacteristic* BluetoothRemoteGATTCharacteristic::create(
    ExecutionContext* context,
    mojom::blink::WebBluetoothRemoteGATTCharacteristicPtr characteristic,
    BluetoothRemoteGATTService* service,
    BluetoothDevice* device) {
  return new BluetoothRemoteGATTCharacteristic(
      context, std::move(characteristic), service, device);
}
