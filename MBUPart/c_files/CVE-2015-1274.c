String AXNodeObject::placeholderFromNativeAttribute() const {
  Node* node = getNode();
  if (!node || !isTextControlElement(node))
    return String();
  return toTextControlElement(node)->strippedPlaceholder();
}

bool AXNodeObject::isEnabled() const {
  if (isDescendantOfDisabledNode())
    return false;

  Node* node = this->getNode();
  if (!node || !node->isElementNode())
    return true;

  return !toElement(node)->isDisabledFormControl();
}

Element* AXLayoutObject::anchorElement() const {
  if (!m_layoutObject)
    return 0;

  AXObjectCacheImpl& cache = axObjectCache();
  LayoutObject* currLayoutObject;

  for (currLayoutObject = m_layoutObject;
       currLayoutObject && !currLayoutObject->node();
       currLayoutObject = currLayoutObject->parent()) {
    if (currLayoutObject->isAnonymousBlock() &&
        currLayoutObject->isLayoutBlockFlow()) {
      LayoutObject* continuation =
          toLayoutBlockFlow(currLayoutObject)->continuation();
      if (continuation)
        return cache.getOrCreate(continuation)->anchorElement();
    }
  }

  if (!currLayoutObject)
    return 0;

  Node* node = currLayoutObject->node();
  if (!node)
    return nullptr;
  for (Node& runner : NodeTraversal::inclusiveAncestorsOf(*node)) {
    if (isHTMLAnchorElement(runner) ||
        (runner.layoutObject() &&
         cache.getOrCreate(runner.layoutObject())->isAnchor()))
      return toElement(&runner);
  }

  return 0;
}

String AXNodeObject::stringValue() const {
  Node* node = this->getNode();
  if (!node)
    return String();

  if (isHTMLSelectElement(*node)) {
    HTMLSelectElement& selectElement = toHTMLSelectElement(*node);
    int selectedIndex = selectElement.selectedIndex();
    const HeapVector<Member<HTMLElement>>& listItems =
        selectElement.listItems();
    if (selectedIndex >= 0 &&
        static_cast<size_t>(selectedIndex) < listItems.size()) {
      const AtomicString& overriddenDescription =
          listItems[selectedIndex]->fastGetAttribute(aria_labelAttr);
      if (!overriddenDescription.isNull())
        return overriddenDescription;
    }
    if (!selectElement.isMultiple())
      return selectElement.value();
    return String();
  }

  if (isNativeTextControl())
    return text();

  if (isHTMLInputElement(node)) {
    HTMLInputElement* input = toHTMLInputElement(node);
    if (input->type() != InputTypeNames::checkbox &&
        input->type() != InputTypeNames::radio)
      return input->value();
  }

  return String();
}

AccessibilityRole AXObject::buttonRoleType() const {
  if (ariaPressedIsPresent())
    return ToggleButtonRole;
  if (ariaHasPopup())
    return PopUpButtonRole;

  return ButtonRole;
}

DEFINE_TRACE(AXNodeObject) {
  visitor->trace(m_node);
  AXObject::trace(visitor);
}

bool AXNodeObject::isMeter() const {
  return roleValue() == MeterRole;
}

AXObject* AXObject::parentObjectIfExists() const {
  if (isDetached())
    return 0;

  if (m_parent)
    return m_parent;

  return computeParentIfExists();
}

void AXLayoutObject::offsetBoundingBoxForRemoteSVGElement(
    LayoutRect& rect) const {
  for (AXObject* parent = parentObject(); parent;
       parent = parent->parentObject()) {
    if (parent->isAXSVGRoot()) {
      rect.moveBy(
          parent->parentObject()->getBoundsInFrameCoordinates().location());
      break;
    }
  }
}

void AXObjectCacheImpl::textChanged(AXObject* obj) {
  if (!obj)
    return;

  bool parentAlreadyExists = obj->parentObjectIfExists();
  obj->textChanged();
  postNotification(obj, AXObjectCacheImpl::AXTextChanged);
  if (parentAlreadyExists)
    obj->notifyIfIgnoredValueChanged();
}

 bool AXObject::ariaPressedIsPresent() const {
  return !getAttribute(aria_pressedAttr).isEmpty();
}

AXObject* AXNodeObject::computeParent() const {
  ASSERT(!isDetached());
  if (Node* parentNode = getParentNodeForComputeParent(getNode()))
    return axObjectCache().getOrCreate(parentNode);

  return nullptr;
}

const AXObject* AXNodeObject::inheritsPresentationalRoleFrom() const {
  if (canSetFocusAttribute())
    return 0;

  if (isPresentational())
    return this;

  if (ariaRoleAttribute() != UnknownRole)
    return 0;

  AXObject* parent = parentObject();
  if (!parent)
    return 0;

  HTMLElement* element = nullptr;
  if (getNode() && getNode()->isHTMLElement())
    element = toHTMLElement(getNode());
  if (!parent->hasInheritedPresentationalRole()) {
    if (!getLayoutObject() || !getLayoutObject()->isBoxModelObject())
      return 0;

    LayoutBoxModelObject* cssBox = toLayoutBoxModelObject(getLayoutObject());
    if (!cssBox->isTableCell() && !cssBox->isTableRow())
      return 0;

    if (!isPresentationalInTable(parent, element))
      return 0;
  }
  if (isRequiredOwnedElement(parent, roleValue(), element))
    return parent;
  return 0;
}

float AXNodeObject::maxValueForRange() const {
  if (hasAttribute(aria_valuemaxAttr))
    return getAttribute(aria_valuemaxAttr).toFloat();

  if (isNativeSlider())
    return toHTMLInputElement(*getNode()).maximum();

  if (isHTMLMeterElement(getNode()))
    return toHTMLMeterElement(*getNode()).max();

  return 0.0;
}

bool roleAllowsRequired(AccessibilityRole role) {
  return role == ComboBoxRole || role == CellRole || role == ListBoxRole ||
         role == RadioGroupRole || role == SpinButtonRole ||
         role == TextFieldRole || role == TreeRole ||
         role == ColumnHeaderRole || role == RowHeaderRole ||
         role == TreeGridRole;
}

String AXNodeObject::placeholder(AXNameFrom nameFrom) const {
  if (nameFrom == AXNameFromPlaceholder)
    return String();

  Node* node = getNode();
  if (!node || !node->isHTMLElement())
    return String();

  String nativePlaceholder = placeholderFromNativeAttribute();
  if (!nativePlaceholder.isEmpty())
    return nativePlaceholder;

  const AtomicString& ariaPlaceholder =
      toHTMLElement(node)->fastGetAttribute(aria_placeholderAttr);
  if (!ariaPlaceholder.isEmpty())
    return ariaPlaceholder;

  return String();
}

const AtomicString& AXObject::containerLiveRegionRelevant() const {
  updateCachedAttributeValuesIfNeeded();
  return m_cachedLiveRegionRoot ? m_cachedLiveRegionRoot->liveRegionRelevant()
                                : nullAtom;
}

static AccessibilityRole decideRoleFromSibling(LayoutTableCell* siblingCell) {
  if (!siblingCell)
    return CellRole;

  if (Node* siblingNode = siblingCell->node()) {
    if (siblingNode->hasTagName(thTag))
      return ColumnHeaderRole;
    if (siblingNode->hasTagName(tdTag))
      return RowHeaderRole;
  }

  return CellRole;
}

TextStyle AXLayoutObject::getTextStyle() const {
  if (!getLayoutObject())
    return AXNodeObject::getTextStyle();

  const ComputedStyle* style = getLayoutObject()->style();
  if (!style)
    return AXNodeObject::getTextStyle();

  unsigned textStyle = TextStyleNone;
  if (style->fontWeight() == FontWeightBold)
    textStyle |= TextStyleBold;
  if (style->getFontDescription().style() == FontStyleItalic)
    textStyle |= TextStyleItalic;
  if (style->getTextDecoration() == TextDecorationUnderline)
    textStyle |= TextStyleUnderline;
  if (style->getTextDecoration() == TextDecorationLineThrough)
    textStyle |= TextStyleLineThrough;

  return static_cast<TextStyle>(textStyle);
}

RGBA32 AXObject::backgroundColor() const {
  updateCachedAttributeValuesIfNeeded();
  return m_cachedBackgroundColor;
}

void AXLayoutObject::lineBreaks(Vector<int>& lineBreaks) const {
  if (!isTextControl())
    return;

  VisiblePosition visiblePos = visiblePositionForIndex(0);
  VisiblePosition prevVisiblePos = visiblePos;
  visiblePos = nextLinePosition(visiblePos, LayoutUnit(), HasEditableAXRole);
  while (visiblePos.isNotNull() && !inSameLine(prevVisiblePos, visiblePos)) {
    lineBreaks.push_back(indexForVisiblePosition(visiblePos));
    prevVisiblePos = visiblePos;
    visiblePos = nextLinePosition(visiblePos, LayoutUnit(), HasEditableAXRole);

    if (visiblePos.deepEquivalent().compareTo(prevVisiblePos.deepEquivalent()) <
        0)
      break;
  }
}

bool AXNodeObject::isInputImage() const {
  Node* node = this->getNode();
  if (roleValue() == ButtonRole && isHTMLInputElement(node))
    return toHTMLInputElement(*node).type() == InputTypeNames::image;

  return false;
}

static VisiblePosition toVisiblePosition(AXObject* obj, int offset) {
  if (!obj->getNode())
    return VisiblePosition();

  Node* node = obj->getNode();
  if (!node->isTextNode()) {
    int childCount = obj->children().size();

    if (childCount == 0) {
      if (!obj->parentObject())
        return VisiblePosition();
      return toVisiblePosition(obj->parentObject(), obj->indexInParent());
    }

    if (offset < 0 || offset > childCount)
      return VisiblePosition();

    int clampedOffset =
        static_cast<unsigned>(offset) > (obj->children().size() - 1)
            ? offset - 1
            : offset;
    AXObject* childObj = obj->children()[clampedOffset];
    Node* childNode = childObj->getNode();
    if (!childNode || !childNode->parentNode())
      return VisiblePosition();

    int adjustedOffset = childNode->nodeIndex();

    if (clampedOffset != offset)
      adjustedOffset++;

    return createVisiblePosition(
        Position::editingPositionOf(childNode->parentNode(), adjustedOffset));
  }

  ContainerNode* parent = node->parentNode();
  if (!parent)
    return VisiblePosition();

  VisiblePosition nodePosition = blink::visiblePositionBeforeNode(*node);
  int nodeIndex = blink::indexForVisiblePosition(nodePosition, parent);
  return blink::visiblePositionForIndex(nodeIndex + offset, parent);
}

AXObject* AXObjectCacheImpl::getOrCreate(AbstractInlineTextBox* inlineTextBox) {
  if (!inlineTextBox)
    return 0;

  if (AXObject* obj = get(inlineTextBox))
    return obj;

  AXObject* newObj = createFromInlineTextBox(inlineTextBox);

  DCHECK(!get(inlineTextBox));

  const AXID axid = getOrCreateAXID(newObj);

  m_inlineTextBoxObjectMapping.set(inlineTextBox, axid);
  newObj->init();
  newObj->setLastKnownIsIgnoredValue(newObj->accessibilityIsIgnored());

  return newObj;
}

bool AXObject::accessibilityIsIgnored() const {
  updateCachedAttributeValuesIfNeeded();
  return m_cachedIsIgnored;
}

void AXNodeObject::textChanged() {
  AXObjectCacheImpl& cache = axObjectCache();
  for (Node* parentNode = getNode(); parentNode;
       parentNode = parentNode->parentNode()) {
    AXObject* parent = cache.get(parentNode);
    if (!parent)
      continue;

    if (parent->isLiveRegion())
      cache.postNotification(parentNode,
                             AXObjectCacheImpl::AXLiveRegionChanged);

    if (parent->isNonNativeTextControl())
      cache.postNotification(parentNode, AXObjectCacheImpl::AXValueChanged);
  }
}

static Node* getParentNodeForComputeParent(Node* node) {
  if (!node)
    return nullptr;

  Node* parentNode = nullptr;

  if (isHTMLOptionElement(node))
    parentNode = toHTMLOptionElement(node)->ownerSelectElement();

  if (!parentNode)
    parentNode = node->parentNode();

  return parentNode;
}

bool AXObject::hasInteractiveARIAAttribute(const Element& element) {
  for (size_t i = 0; i < WTF_ARRAY_LENGTH(ariaInteractiveWidgetAttributes);
       ++i) {
    const char* attribute = ariaInteractiveWidgetAttributes[i];
    if (element.hasAttribute(attribute)) {
      return true;
    }
  }
  return false;
}

bool AXNodeObject::canSetFocusAttribute() const {
  Node* node = getNode();
  if (!node)
    return false;

  if (isWebArea())
    return true;

  if (!isPresentational() && ariaRoleAttribute() != UnknownRole &&
      ancestorExposesActiveDescendant())
    return true;

  if (isDisabledFormControl(node))
    return false;

  return node->isElementNode() && toElement(node)->supportsFocus();
 }

void AXNodeObject::addChildren() {
  ASSERT(!isDetached());
  ASSERT(!m_haveChildren);

  if (!m_node)
    return;

  m_haveChildren = true;

  if (getLayoutObject() && !isHTMLCanvasElement(*m_node))
    return;

  HeapVector<Member<AXObject>> ownedChildren;
  computeAriaOwnsChildren(ownedChildren);

  for (Node& child : NodeTraversal::childrenOf(*m_node)) {
    AXObject* childObj = axObjectCache().getOrCreate(&child);
    if (childObj && !axObjectCache().isAriaOwned(childObj))
      addChild(childObj);
  }

  for (const auto& ownedChild : ownedChildren)
    addChild(ownedChild);

  for (const auto& child : m_children)
    child->setParent(this);
}

String AXObjectCacheImpl::computedNameForNode(Node* node) {
  AXObject* obj = getOrCreate(node);
  if (!obj)
    return "";

  return obj->computedName();
}

bool AXObject::computeAncestorExposesActiveDescendant() const {
  const AXObject* parent = parentObjectUnignored();
  if (!parent)
    return false;

  if (parent->supportsActiveDescendant() &&
      !parent->getAttribute(aria_activedescendantAttr).isEmpty()) {
    return true;
  }

  return parent->ancestorExposesActiveDescendant();
}

void AXObjectCacheImpl::removeAXID(AXObject* object) {
  if (!object)
    return;

  AXID objID = object->axObjectID();
  if (!objID)
    return;
  DCHECK(!HashTraits<AXID>::isDeletedValue(objID));
  DCHECK(m_idsInUse.contains(objID));
  object->setAXObjectID(0);
  m_idsInUse.erase(objID);

  if (m_ariaOwnerToChildrenMapping.contains(objID)) {
    Vector<AXID> childAXIDs = m_ariaOwnerToChildrenMapping.at(objID);
    for (size_t i = 0; i < childAXIDs.size(); ++i)
      m_ariaOwnedChildToOwnerMapping.erase(childAXIDs[i]);
    m_ariaOwnerToChildrenMapping.erase(objID);
  }
  m_ariaOwnedChildToOwnerMapping.erase(objID);
  m_ariaOwnedChildToRealParentMapping.erase(objID);
  m_ariaOwnerToIdsMapping.erase(objID);
}

AccessibilityOrientation AXNodeObject::orientation() const {
const AtomicString& ariaOrientation =
getAOMPropertyOrARIAAttribute(AOMStringProperty::kOrientation);
AccessibilityOrientation orientation = AccessibilityOrientationUndefined;
  if (equalIgnoringCase(ariaOrientation, "horizontal"))
orientation = AccessibilityOrientationHorizontal;
  else if (equalIgnoringCase(ariaOrientation, "vertical"))
orientation = AccessibilityOrientationVertical;

switch (roleValue()) {
case ComboBoxRole:
case ListBoxRole:
case MenuRole:
case ScrollBarRole:
case TreeRole:
if (orientation == AccessibilityOrientationUndefined)
orientation = AccessibilityOrientationVertical;

return orientation;
case MenuBarRole:
case SliderRole:
case SplitterRole:
case TabListRole:
case ToolbarRole:
if (orientation == AccessibilityOrientationUndefined)
orientation = AccessibilityOrientationHorizontal;

return orientation;
case RadioGroupRole:
case TreeGridRole:
// TODO(nektar): Fix bug 532670 and remove table role.
case TableRole:
return orientation;
default:
return AXObject::orientation();
}
}

void AXLayoutObject::addCanvasChildren() {
  if (!isHTMLCanvasElement(getNode()))
    return;

  ASSERT(!m_children.size());
  m_haveChildren = false;
  AXNodeObject::addChildren();
}

AXObject* AXLayoutObject::nextOnLine() const {
  if (!getLayoutObject())
    return nullptr;

  InlineBox* inlineBox = nullptr;
  if (getLayoutObject()->isLayoutInline())
    inlineBox = toLayoutInline(getLayoutObject())->lastLineBox();
  else if (getLayoutObject()->isText())
    inlineBox = toLayoutText(getLayoutObject())->lastTextBox();

  if (!inlineBox)
    return nullptr;

  AXObject* result = nullptr;
  for (InlineBox* next = inlineBox->nextOnLine(); next;
       next = next->nextOnLine()) {
    LayoutObject* layoutObject =
        LineLayoutAPIShim::layoutObjectFrom(next->getLineLayoutItem());
    result = axObjectCache().getOrCreate(layoutObject);
    if (result)
      break;
  }

  if (result && result->roleValue() == StaticTextRole &&
      result->children().size())
    result = result->children()[0].get();

  return result;
}

AXID AXObjectCacheImpl::getOrCreateAXID(AXObject* obj) {
  const AXID existingAXID = obj->axObjectID();
  if (existingAXID) {
    DCHECK(m_idsInUse.contains(existingAXID));
    return existingAXID;
  }

  const AXID newAXID = generateAXID();

  m_idsInUse.insert(newAXID);
  obj->setAXObjectID(newAXID);
  m_objects.set(newAXID, obj);

  return newAXID;
}

bool AXTableCell::isRowHeaderCell() const {
const AtomicString& scope = getAttribute(scopeAttr);
  return equalIgnoringCase(scope, "row") ||
         equalIgnoringCase(scope, "rowgroup");
}

void AXObjectCacheImpl::handleInitialFocus() {
  postNotification(m_document, AXObjectCache::AXFocusedUIElementChanged);
}

void AXNodeObject::init() {
#if DCHECK_IS_ON()
  ASSERT(!m_initialized);
  m_initialized = true;
#endif
  m_role = determineAccessibilityRole();
}

bool AXObject::isARIATextControl() const {
  return ariaRoleAttribute() == TextFieldRole ||
         ariaRoleAttribute() == SearchBoxRole ||
         ariaRoleAttribute() == ComboBoxRole;
}

void AXObjectCacheImpl::handleAriaRoleChanged(Node* node) {
  if (AXObject* obj = getOrCreate(node)) {
    obj->updateAccessibilityRole();
    m_modificationCount++;
    obj->notifyIfIgnoredValueChanged();
  }
}

void AXLayoutObject::ariaDescribedbyElements(
    AXObjectVector& describedby) const {
  accessibilityChildrenFromAttribute(aria_describedbyAttr, describedby);
}

bool AXListBoxOption::isEnabled() const {
if (!getNode())
return false;

  if (equalIgnoringCase(getAttribute(aria_disabledAttr), "true"))
return false;

if (toElement(getNode())->hasAttribute(disabledAttr))
return false;

return true;
}

bool AXNodeObject::isMultiSelectable() const {
const AtomicString& ariaMultiSelectable =
getAttribute(aria_multiselectableAttr);
  if (equalIgnoringCase(ariaMultiSelectable, "true"))
return true;
  if (equalIgnoringCase(ariaMultiSelectable, "false"))
return false;

return isHTMLSelectElement(getNode()) &&
toHTMLSelectElement(*getNode()).isMultiple();
}

void AXObjectCacheImpl::handleTextFormControlChanged(Node* node) {
  handleEditableTextContentChanged(node);
}

AXNodeObject::findAllRadioButtonsWithSameName(HTMLInputElement* radioButton) {
  HeapVector<Member<HTMLInputElement>> allRadioButtons;
  if (!radioButton || radioButton->type() != InputTypeNames::radio)
    return allRadioButtons;

  constexpr bool kTraverseForward = true;
  constexpr bool kTraverseBackward = false;
  HTMLInputElement* firstRadioButton = radioButton;
  do {
    radioButton = RadioInputType::nextRadioButtonInGroup(firstRadioButton,
                                                         kTraverseBackward);
    if (radioButton)
      firstRadioButton = radioButton;
  } while (radioButton);

  HTMLInputElement* nextRadioButton = firstRadioButton;
  do {
    allRadioButtons.push_back(nextRadioButton);
    nextRadioButton = RadioInputType::nextRadioButtonInGroup(nextRadioButton,
                                                             kTraverseForward);
  } while (nextRadioButton);
  return allRadioButtons;
}

bool AXNodeObject::canSetSelectedAttribute() const {
  if (ariaRoleAttribute() == ListBoxOptionRole &&
      ancestorExposesActiveDescendant())
    return true;
  return AXObject::canSetSelectedAttribute();
}

bool AXLayoutObject::ariaHasPopup() const {
  return elementAttributeValue(aria_haspopupAttr);
}

bool roleAllowsSelected(AccessibilityRole role) {
  return role == CellRole || role == ListBoxOptionRole || role == RowRole ||
         role == TabRole || role == ColumnHeaderRole ||
         role == MenuItemRadioRole || role == RadioButtonRole ||
         role == RowHeaderRole || role == TreeItemRole;
}

DEFINE_TRACE(AXObject) {
  visitor->trace(m_children);
  visitor->trace(m_parent);
  visitor->trace(m_cachedLiveRegionRoot);
  visitor->trace(m_axObjectCache);
}

void fillLiveRegionProperties(AXObject& axObject,
                              protocol::Array<AXProperty>& properties) {
  if (!axObject.liveRegionRoot())
    return;

  properties.addItem(
      createProperty(AXLiveRegionAttributesEnum::Live,
                     createValue(axObject.containerLiveRegionStatus(),
                                 AXValueTypeEnum::Token)));
  properties.addItem(
      createProperty(AXLiveRegionAttributesEnum::Atomic,
                     createBooleanValue(axObject.containerLiveRegionAtomic())));
  properties.addItem(
      createProperty(AXLiveRegionAttributesEnum::Relevant,
                     createValue(axObject.containerLiveRegionRelevant(),
                                 AXValueTypeEnum::TokenList)));
  properties.addItem(
      createProperty(AXLiveRegionAttributesEnum::Busy,
                     createBooleanValue(axObject.containerLiveRegionBusy())));

  if (!axObject.isLiveRegion()) {
    properties.addItem(createProperty(
        AXLiveRegionAttributesEnum::Root,
        createRelatedNodeListValue(*(axObject.liveRegionRoot()))));
  }
}

void AXObjectCacheImpl::inlineTextBoxesUpdated(LineLayoutItem lineLayoutItem) {
  if (!inlineTextBoxAccessibilityEnabled())
    return;

  LayoutObject* layoutObject =
      LineLayoutAPIShim::layoutObjectFrom(lineLayoutItem);

  if (AXObject* obj = get(layoutObject)) {
    if (!obj->needsToUpdateChildren()) {
      obj->setNeedsToUpdateChildren();
      postNotification(layoutObject, AXChildrenChanged);
    }
  }
}

bool AXNodeObject::isNativeCheckboxInMixedState() const {
  if (!isHTMLInputElement(m_node))
    return false;

  HTMLInputElement* input = toHTMLInputElement(m_node);
  return input->type() == InputTypeNames::checkbox &&
         input->shouldAppearIndeterminate();
}

AXObject::~AXObject() {
  ASSERT(isDetached());
  --s_numberOfLiveAXObjects;
}

FrameView* AXLayoutObject::documentFrameView() const {
  if (!getLayoutObject())
    return nullptr;

  return getLayoutObject()->document().view();
}

AXListBoxOption::AXListBoxOption(LayoutObject* layoutObject,
                                 AXObjectCacheImpl& axObjectCache)
    : AXLayoutObject(layoutObject, axObjectCache) {}

Document* AXNodeObject::getDocument() const {
  if (!getNode())
    return 0;
  return &getNode()->document();
}

void AXObjectCacheImpl::postNotification(LayoutObject* layoutObject,
                                         AXNotification notification) {
  if (!layoutObject)
    return;
  postNotification(get(layoutObject), notification);
}

String AXLayoutObject::imageDataUrl(const IntSize& maxSize) const {
  Node* node = getNode();
  if (!node)
    return String();

  ImageBitmapOptions options;
  ImageBitmap* imageBitmap = nullptr;
  Document* document = &node->document();
  if (isHTMLImageElement(node)) {
    imageBitmap = ImageBitmap::create(toHTMLImageElement(node),
                                      Optional<IntRect>(), document, options);
  } else if (isHTMLCanvasElement(node)) {
    imageBitmap = ImageBitmap::create(toHTMLCanvasElement(node),
                                      Optional<IntRect>(), options);
  } else if (isHTMLVideoElement(node)) {
    imageBitmap = ImageBitmap::create(toHTMLVideoElement(node),
                                      Optional<IntRect>(), document, options);
  }
  if (!imageBitmap)
    return String();

  StaticBitmapImage* bitmapImage = imageBitmap->bitmapImage();
  if (!bitmapImage)
    return String();

  sk_sp<SkImage> image = bitmapImage->imageForCurrentFrame();
  if (!image || image->width() <= 0 || image->height() <= 0)
    return String();

  float xScale = maxSize.width() ? maxSize.width() * 1.0 / image->width() : 1.0;
  float yScale =
      maxSize.height() ? maxSize.height() * 1.0 / image->height() : 1.0;
  float scale = std::min(xScale, yScale);
  if (scale >= 1.0)
    scale = 1.0;
  int width = std::round(image->width() * scale);
  int height = std::round(image->height() * scale);

  SkBitmap bitmap;
  bitmap.allocPixels(SkImageInfo::MakeN32(width, height, kPremul_SkAlphaType));
  SkCanvas canvas(bitmap);
  canvas.clear(SK_ColorTRANSPARENT);
  canvas.drawImageRect(image, SkRect::MakeIWH(width, height), nullptr);

  SkImageInfo info = SkImageInfo::Make(width, height, kRGBA_8888_SkColorType,
                                       kUnpremul_SkAlphaType);
  size_t rowBytes = info.minRowBytes();
  Vector<char> pixelStorage(info.getSafeSize(rowBytes));
  SkPixmap pixmap(info, pixelStorage.data(), rowBytes);
  if (!SkImage::MakeFromBitmap(bitmap)->readPixels(pixmap, 0, 0))
    return String();

  String dataUrl =
      ImageDataBuffer(
          IntSize(width, height),
          reinterpret_cast<const unsigned char*>(pixelStorage.data()))
          .toDataURL("image/png", 1.0);
  return dataUrl;
}

String AXLayoutObject::stringValue() const {
  if (!m_layoutObject)
    return String();

  LayoutBoxModelObject* cssBox = getLayoutBoxModelObject();

  if (cssBox && cssBox->isMenuList()) {
    HTMLSelectElement* selectElement =
        toHTMLSelectElement(m_layoutObject->node());
    int selectedIndex = selectElement->selectedIndex();
    const HeapVector<Member<HTMLElement>>& listItems =
        selectElement->listItems();
    if (selectedIndex >= 0 &&
        static_cast<size_t>(selectedIndex) < listItems.size()) {
      const AtomicString& overriddenDescription =
          listItems[selectedIndex]->fastGetAttribute(aria_labelAttr);
      if (!overriddenDescription.isNull())
        return overriddenDescription;
    }
    return toLayoutMenuList(m_layoutObject)->text();
  }

  if (isWebArea()) {
    if (m_layoutObject->frame())
      return String();

    ASSERT_NOT_REACHED();
  }

  if (isTextControl())
    return text();

  if (m_layoutObject->isFileUploadControl())
    return toLayoutFileUploadControl(m_layoutObject)->fileTextValue();

  if (getNode() && isHTMLInputElement(getNode())) {
    HTMLInputElement* input = toHTMLInputElement(getNode());
    if (input->type() != InputTypeNames::checkbox &&
        input->type() != InputTypeNames::radio)
      return input->value();
  }

  return String();
}

AXObject* AXNodeObject::inPageLinkTarget() const {
  if (!m_node || !isHTMLAnchorElement(m_node) || !getDocument())
    return AXObject::inPageLinkTarget();

  HTMLAnchorElement* anchor = toHTMLAnchorElement(m_node);
  DCHECK(anchor);
  KURL linkURL = anchor->href();
  if (!linkURL.isValid())
    return AXObject::inPageLinkTarget();
  String fragment = linkURL.fragmentIdentifier();
  if (fragment.isEmpty())
    return AXObject::inPageLinkTarget();

  KURL documentURL = getDocument()->url();
  if (!documentURL.isValid() ||
      !equalIgnoringFragmentIdentifier(documentURL, linkURL)) {
    return AXObject::inPageLinkTarget();
  }

  TreeScope& treeScope = anchor->treeScope();
  Element* target = treeScope.findAnchor(fragment);
  if (!target)
    return AXObject::inPageLinkTarget();
  return axObjectCache().firstAccessibleObjectFromNode(target);
}

void AXObjectCacheImpl::handleScrolledToAnchor(const Node* anchorNode) {
  if (!anchorNode)
    return;
  AXObject* obj = getOrCreate(anchorNode->layoutObject());
  if (!obj)
    return;
  if (obj->accessibilityIsIgnored())
    obj = obj->parentObjectUnignored();
  postPlatformNotification(obj, AXScrolledToAnchor);
}

void AXLayoutObject::handleActiveDescendantChanged() {
  if (!getLayoutObject())
    return;

  AXObject* focusedObject = axObjectCache().focusedObject();
  if (focusedObject == this && supportsActiveDescendant()) {
    axObjectCache().postNotification(
        getLayoutObject(), AXObjectCacheImpl::AXActiveDescendantChanged);
  }
}

void AXLayoutObject::updateChildrenIfNecessary() {
  if (needsToUpdateChildren())
    clearChildren();

  AXObject::updateChildrenIfNecessary();
}

String AXObject::language() const {
  const AtomicString& lang = getAttribute(langAttr);
  if (!lang.isEmpty())
    return lang;

  AXObject* parent = parentObject();

  if (!parent) {
    Document* doc = getDocument();
    if (doc)
      return doc->contentLanguage();
    return nullAtom;
  }

  return parent->language();
}

AXObject::AXObject(AXObjectCacheImpl& axObjectCache)
    : m_id(0),
      m_haveChildren(false),
      m_role(UnknownRole),
      m_lastKnownIsIgnoredValue(DefaultBehavior),
      m_explicitContainerID(0),
      m_parent(nullptr),
      m_lastModificationCount(-1),
      m_cachedIsIgnored(false),
      m_cachedIsInertOrAriaHidden(false),
      m_cachedIsDescendantOfLeafNode(false),
      m_cachedIsDescendantOfDisabledNode(false),
      m_cachedHasInheritedPresentationalRole(false),
      m_cachedIsPresentationalChild(false),
      m_cachedAncestorExposesActiveDescendant(false),
      m_cachedLiveRegionRoot(nullptr),
      m_axObjectCache(&axObjectCache) {
  ++s_numberOfLiveAXObjects;
}

void AXObjectCacheImpl::handleAriaExpandedChange(Node* node) {
  if (AXObject* obj = getOrCreate(node))
    obj->handleAriaExpandedChanged();
}

const AtomicString& AXObject::containerLiveRegionStatus() const {
  updateCachedAttributeValuesIfNeeded();
  return m_cachedLiveRegionRoot ? m_cachedLiveRegionRoot->liveRegionStatus()
                                : nullAtom;
}

AccessibilityButtonState AXNodeObject::checkboxOrRadioValue() const {
  if (isNativeCheckboxInMixedState())
    return ButtonStateMixed;

  if (isNativeCheckboxOrRadio())
    return isChecked() ? ButtonStateOn : ButtonStateOff;

  return AXObject::checkboxOrRadioValue();
}

int AXLayoutObject::indexForVisiblePosition(
    const VisiblePosition& position) const {
  if (getLayoutObject() && getLayoutObject()->isTextControl()) {
    TextControlElement* textControl =
        toLayoutTextControl(getLayoutObject())->textControlElement();
    return textControl->indexForVisiblePosition(position);
  }

  if (!getNode())
    return 0;

  Position indexPosition = position.deepEquivalent();
  if (indexPosition.isNull())
    return 0;

  Range* range = Range::create(*getDocument());
  range->setStart(getNode(), 0, IGNORE_EXCEPTION_FOR_TESTING);
  range->setEnd(indexPosition, IGNORE_EXCEPTION_FOR_TESTING);

  return TextIterator::rangeLength(range->startPosition(),
                                   range->endPosition());
}

void AXLayoutObject::addHiddenChildren() {
  Node* node = this->getNode();
  if (!node)
    return;

  bool shouldInsertHiddenNodes = false;
  for (Node& child : NodeTraversal::childrenOf(*node)) {
    if (!child.layoutObject() && isNodeAriaVisible(&child)) {
      shouldInsertHiddenNodes = true;
      break;
    }
  }

  if (!shouldInsertHiddenNodes)
    return;

  unsigned insertionIndex = 0;
  for (Node& child : NodeTraversal::childrenOf(*node)) {
    if (child.layoutObject()) {
      if (AXObject* childObject = axObjectCache().get(child.layoutObject())) {
        if (childObject->accessibilityIsIgnored()) {
          const auto& children = childObject->children();
          childObject = children.size() ? children.back().get() : 0;
        }
        if (childObject)
          insertionIndex = m_children.find(childObject) + 1;
        continue;
      }
    }

    if (!isNodeAriaVisible(&child))
      continue;

    unsigned previousSize = m_children.size();
    if (insertionIndex > previousSize)
      insertionIndex = previousSize;

    insertChild(axObjectCache().getOrCreate(&child), insertionIndex);
    insertionIndex += (m_children.size() - previousSize);
  }
}

bool AXNodeObject::isHeading() const {
  return roleValue() == HeadingRole;
}

void AXObjectCacheImpl::handleEditableTextContentChanged(Node* node) {
  AXObject* obj = get(node);
  while (obj && !obj->isNativeTextControl() && !obj->isNonNativeTextControl())
    obj = obj->parentObject();
  postNotification(obj, AXObjectCache::AXValueChanged);
}

bool AXObject::ancestorExposesActiveDescendant() const {
  updateCachedAttributeValuesIfNeeded();
  return m_cachedAncestorExposesActiveDescendant;
}

AXID AXObjectCacheImpl::generateAXID() const {
  static AXID lastUsedID = 0;

  AXID objID = lastUsedID;
  do {
    ++objID;
  } while (!objID || HashTraits<AXID>::isDeletedValue(objID) ||
           m_idsInUse.contains(objID));

  lastUsedID = objID;

  return objID;
}

bool AXLayoutObject::supportsARIAOwns() const {
  if (!m_layoutObject)
    return false;
  const AtomicString& ariaOwns = getAttribute(aria_ownsAttr);

  return !ariaOwns.isEmpty();
}

String AXObject::ariaTextAlternative(bool recursive,
                                     bool inAriaLabelledByTraversal,
                                     AXObjectSet& visited,
                                     AXNameFrom& nameFrom,
                                     AXRelatedObjectVector* relatedObjects,
                                     NameSources* nameSources,
                                     bool* foundTextAlternative) const {
  String textAlternative;
  bool alreadyVisited = visited.contains(this);
  visited.insert(this);

  if (!inAriaLabelledByTraversal && isHiddenForTextAlternativeCalculation()) {
    *foundTextAlternative = true;
    return String();
  }

  if (!inAriaLabelledByTraversal && !alreadyVisited) {
    const QualifiedName& attr =
        hasAttribute(aria_labeledbyAttr) && !hasAttribute(aria_labelledbyAttr)
            ? aria_labeledbyAttr
            : aria_labelledbyAttr;
    nameFrom = AXNameFromRelatedElement;
    if (nameSources) {
      nameSources->push_back(NameSource(*foundTextAlternative, attr));
      nameSources->back().type = nameFrom;
    }

    const AtomicString& ariaLabelledby = getAttribute(attr);
    if (!ariaLabelledby.isNull()) {
      if (nameSources)
        nameSources->back().attributeValue = ariaLabelledby;

      AXObjectSet visitedCopy = visited;
      textAlternative = textFromAriaLabelledby(visitedCopy, relatedObjects);
      if (!textAlternative.isNull()) {
        if (nameSources) {
          NameSource& source = nameSources->back();
          source.type = nameFrom;
          source.relatedObjects = *relatedObjects;
          source.text = textAlternative;
          *foundTextAlternative = true;
        } else {
          *foundTextAlternative = true;
          return textAlternative;
        }
      } else if (nameSources) {
        nameSources->back().invalid = true;
      }
    }
  }

  nameFrom = AXNameFromAttribute;
  if (nameSources) {
    nameSources->push_back(NameSource(*foundTextAlternative, aria_labelAttr));
    nameSources->back().type = nameFrom;
  }
  const AtomicString& ariaLabel =
      getAOMPropertyOrARIAAttribute(AOMStringProperty::kLabel);
  if (!ariaLabel.isEmpty()) {
    textAlternative = ariaLabel;

    if (nameSources) {
      NameSource& source = nameSources->back();
      source.text = textAlternative;
      source.attributeValue = ariaLabel;
      *foundTextAlternative = true;
    } else {
      *foundTextAlternative = true;
      return textAlternative;
    }
  }

  return textAlternative;
}

AXObject* AXLayoutObject::rawNextSibling() const {
  if (!m_layoutObject)
    return 0;

  LayoutObject* nextSibling = 0;

  LayoutInline* inlineContinuation =
      m_layoutObject->isLayoutBlockFlow()
          ? toLayoutBlockFlow(m_layoutObject)->inlineElementContinuation()
          : nullptr;
  if (inlineContinuation) {
    nextSibling = firstChildConsideringContinuation(inlineContinuation);
  } else if (m_layoutObject->isAnonymousBlock() &&
             lastChildHasContinuation(m_layoutObject)) {
    LayoutObject* lastParent =
        endOfContinuations(toLayoutBlock(m_layoutObject)->lastChild())
            ->parent();
    while (lastChildHasContinuation(lastParent))
      lastParent = endOfContinuations(lastParent->slowLastChild())->parent();
    nextSibling = lastParent->nextSibling();
  } else if (LayoutObject* ns = m_layoutObject->nextSibling()) {
    nextSibling = ns;
  } else if (isInlineWithContinuation(m_layoutObject)) {
    nextSibling = endOfContinuations(m_layoutObject)->nextSibling();
  } else if (m_layoutObject->parent() &&
             isInlineWithContinuation(m_layoutObject->parent())) {
    LayoutObject* continuation =
        toLayoutInline(m_layoutObject->parent())->continuation();

    if (continuation->isLayoutBlock()) {
      nextSibling = continuation;
    } else {
      nextSibling = firstChildConsideringContinuation(continuation);
    }
  }

  if (!nextSibling)
    return 0;

  return axObjectCache().getOrCreate(nextSibling);
}

String AXObject::computedName() const {
  AXNameFrom nameFrom;
  AXObject::AXObjectVector nameObjects;
  return name(nameFrom, &nameObjects);
}

static bool isMenuListOption(Node* node) {
  if (!isHTMLOptionElement(node))
    return false;
  HTMLSelectElement* select = toHTMLOptionElement(node)->ownerSelectElement();
  if (!select)
    return false;
  LayoutObject* layoutObject = select->layoutObject();
  return layoutObject && layoutObject->isMenuList();
}

bool AXNodeObject::canHaveChildren() const {
  if (!getNode() && !isAXLayoutObject())
    return false;

  if (getNode() && isHTMLMapElement(getNode()))
    return false;

  AccessibilityRole role = roleValue();

  if (isPresentational())
    role = nativeAccessibilityRoleIgnoringAria();

  switch (role) {
    case ImageRole:
    case ButtonRole:
    case PopUpButtonRole:
    case CheckBoxRole:
    case RadioButtonRole:
    case SwitchRole:
    case TabRole:
    case ToggleButtonRole:
    case ListBoxOptionRole:
    case ScrollBarRole:
      return false;
    case StaticTextRole:
      if (!axObjectCache().inlineTextBoxAccessibilityEnabled())
        return false;
    default:
      return true;
  }
}

Element* AXNodeObject::anchorElement() const {
  Node* node = this->getNode();
  if (!node)
    return 0;

  AXObjectCacheImpl& cache = axObjectCache();

  for (; node; node = node->parentNode()) {
    if (isHTMLAnchorElement(*node) ||
        (node->layoutObject() &&
         cache.getOrCreate(node->layoutObject())->isAnchor()))
      return toElement(node);
  }

  return 0;
}

bool AXObject::isHiddenForTextAlternativeCalculation() const {
  if (equalIgnoringCase(getAttribute(aria_hiddenAttr), "false"))
return false;

if (getLayoutObject())
return getLayoutObject()->style()->visibility() != EVisibility::kVisible;

// This is an obscure corner case: if a node has no LayoutObject, that means
// it's not rendered, but we still may be exploring it as part of a text
// alternative calculation, for example if it was explicitly referenced by
// aria-labelledby. So we need to explicitly call the style resolver to check
// whether it's invisible or display:none, rather than relying on the style
// cached in the LayoutObject.
Document* document = getDocument();
if (!document || !document->frame())
return false;
if (Node* node = getNode()) {
if (node->isConnected() && node->isElementNode()) {
RefPtr<ComputedStyle> style =
document->ensureStyleResolver().styleForElement(toElement(node));
return style->display() == EDisplay::kNone ||
style->visibility() != EVisibility::kVisible;
}
}
return false;
}

String AXObject::textFromElements(bool inAriaLabelledbyTraversal,
                                  AXObjectSet& visited,
                                  HeapVector<Member<Element>>& elements,
                                  AXRelatedObjectVector* relatedObjects) const {
  StringBuilder accumulatedText;
  bool foundValidElement = false;
  AXRelatedObjectVector localRelatedObjects;

  for (const auto& element : elements) {
    AXObject* axElement = axObjectCache().getOrCreate(element);
    if (axElement) {
      foundValidElement = true;

      String result = recursiveTextAlternative(
          *axElement, inAriaLabelledbyTraversal, visited);
      localRelatedObjects.push_back(
          new NameSourceRelatedObject(axElement, result));
      if (!result.isEmpty()) {
        if (!accumulatedText.isEmpty())
          accumulatedText.append(' ');
        accumulatedText.append(result);
      }
    }
  }
  if (!foundValidElement)
    return String();
  if (relatedObjects)
    *relatedObjects = localRelatedObjects;
  return accumulatedText.toString();
}

bool AXLayoutObject::computeAccessibilityIsIgnored(
    IgnoredReasons* ignoredReasons) const {
#if DCHECK_IS_ON()
  ASSERT(m_initialized);
#endif

  if (!m_layoutObject)
    return true;

  AXObjectInclusion decision = defaultObjectInclusion(ignoredReasons);
  if (decision == IncludeObject)
    return false;
  if (decision == IgnoreObject)
    return true;

  if (m_layoutObject->isAnonymousBlock())
    return true;

  if (isDescendantOfLeafNode()) {
    if (ignoredReasons)
      ignoredReasons->push_back(
          IgnoredReason(AXAncestorIsLeafNode, leafNodeAncestor()));
    return true;
  }

  if (roleValue() == IgnoredRole) {
    if (ignoredReasons)
      ignoredReasons->push_back(IgnoredReason(AXUninteresting));
    return true;
  }

  if (hasInheritedPresentationalRole()) {
    if (ignoredReasons) {
      const AXObject* inheritsFrom = inheritsPresentationalRoleFrom();
      if (inheritsFrom == this)
        ignoredReasons->push_back(IgnoredReason(AXPresentationalRole));
      else
        ignoredReasons->push_back(
            IgnoredReason(AXInheritsPresentation, inheritsFrom));
    }
    return true;
  }

  if (AXObject* treeAncestor = treeAncestorDisallowingChild()) {
    if (ignoredReasons)
      ignoredReasons->push_back(
          IgnoredReason(AXAncestorDisallowsChild, treeAncestor));
    return true;
  }

  if (m_layoutObject->isLayoutPart())
    return false;

  if (getLayoutObject() && getLayoutObject()->hasLayer() && getNode() &&
      getNode()->hasChildren())
    return false;

  AXObject* controlObject = correspondingControlForLabelElement();
  if (controlObject && controlObject->isCheckboxOrRadio() &&
      controlObject->nameFromLabelElement()) {
    if (ignoredReasons) {
      HTMLLabelElement* label = labelElementContainer();
      if (label && label != getNode()) {
        AXObject* labelAXObject = axObjectCache().getOrCreate(label);
        ignoredReasons->push_back(
            IgnoredReason(AXLabelContainer, labelAXObject));
      }

      ignoredReasons->push_back(IgnoredReason(AXLabelFor, controlObject));
    }
    return true;
  }

  if (m_layoutObject->isBR())
    return false;

  if (isLink())
    return false;

  if (isInPageLinkTarget())
    return false;

  if (m_layoutObject->isText()) {
    AXObject* parent = parentObjectUnignored();
    if (parent && (parent->ariaRoleAttribute() == MenuItemRole ||
                   parent->ariaRoleAttribute() == MenuButtonRole)) {
      if (ignoredReasons)
        ignoredReasons->push_back(
            IgnoredReason(AXStaticTextUsedAsNameFor, parent));
      return true;
    }
    LayoutText* layoutText = toLayoutText(m_layoutObject);
    if (!layoutText->hasTextBoxes()) {
      if (ignoredReasons)
        ignoredReasons->push_back(IgnoredReason(AXEmptyText));
      return true;
    }

    for (AXObject* parent = parentObject(); parent;
         parent = parent->parentObject()) {
      if (parent->roleValue() == TextFieldRole)
        return false;
    }

    if (layoutText->text().impl()->containsOnlyWhitespace()) {
      if (ignoredReasons)
        ignoredReasons->push_back(IgnoredReason(AXEmptyText));
      return true;
    }
    return false;
  }

  if (isHeading())
    return false;

  if (isLandmarkRelated())
    return false;

  if (getNode() &&
      (getNode()->hasTagName(headerTag) || getNode()->hasTagName(footerTag)))
    return false;

  if (isControl())
    return false;

  if (ariaRoleAttribute() != UnknownRole)
    return false;

  Node* node = m_layoutObject->node();
  if (isHTMLLabelElement(node))
    return false;

  if (hasContentEditableAttributeSet())
    return false;

  if (roleValue() == AbbrRole)
    return false;

  if (roleValue() == ListItemRole)
    return false;

  if (roleValue() == BlockquoteRole)
    return false;

  if (roleValue() == DialogRole)
    return false;

  if (roleValue() == FigcaptionRole)
    return false;

  if (roleValue() == FigureRole)
    return false;

  if (roleValue() == DetailsRole)
    return false;

  if (roleValue() == MarkRole)
    return false;

  if (roleValue() == MathRole)
    return false;

  if (roleValue() == MeterRole)
    return false;

  if (roleValue() == RubyRole)
    return false;

  if (roleValue() == SplitterRole)
    return false;

  if (roleValue() == TimeRole)
    return false;

  if (supportsARIAAttributes())
    return false;

  if (isHTMLSpanElement(node)) {
    if (ignoredReasons)
      ignoredReasons->push_back(IgnoredReason(AXUninteresting));
    return true;
  }

  if (isImage())
    return false;

  if (isCanvas()) {
    if (canvasHasFallbackContent())
      return false;
    LayoutHTMLCanvas* canvas = toLayoutHTMLCanvas(m_layoutObject);
    if (canvas->size().height() <= 1 || canvas->size().width() <= 1) {
      if (ignoredReasons)
        ignoredReasons->push_back(IgnoredReason(AXProbablyPresentational));
      return true;
    }
  }

  if (isWebArea() || m_layoutObject->isListMarker())
    return false;

  if (!getAttribute(aria_helpAttr).isEmpty() ||
      !getAttribute(aria_describedbyAttr).isEmpty() ||
      !getAttribute(altAttr).isEmpty() || !getAttribute(titleAttr).isEmpty())
    return false;

  if (isGenericFocusableElement() && node->hasChildren())
    return false;

  if (isScrollableContainer())
    return false;

  if (m_layoutObject->isLayoutBlockFlow() && m_layoutObject->childrenInline() &&
      !canSetFocusAttribute()) {
    bool hasAnyText = !!toLayoutBlockFlow(m_layoutObject)->firstLineBox();

    if (hasAnyText || mouseButtonListener())
      return false;

    if (ignoredReasons)
      ignoredReasons->push_back(IgnoredReason(AXUninteresting));
    return true;
  }

  if (ignoredReasons)
    ignoredReasons->push_back(IgnoredReason(AXUninteresting));
  return true;
}

AXNodeObject::~AXNodeObject() {
  ASSERT(!m_node);
}

bool AXLayoutObject::isSelected() const {
if (!getLayoutObject() || !getNode())
return false;

const AtomicString& ariaSelected = getAttribute(aria_selectedAttr);
  if (equalIgnoringCase(ariaSelected, "true"))
return true;

AXObject* focusedObject = axObjectCache().focusedObject();
if (ariaRoleAttribute() == ListBoxOptionRole && focusedObject &&
focusedObject->activeDescendant() == this) {
return true;
}

if (isTabItem() && isTabItemSelected())
return true;

return false;
}

bool AXLayoutObject::isLoaded() const {
  return !m_layoutObject->document().parser();
}

static ARIARoleMap* createARIARoleMap() {
  ARIARoleMap* roleMap = new ARIARoleMap;

  for (size_t i = 0; i < WTF_ARRAY_LENGTH(roles); ++i)
    roleMap->set(String(roles[i].ariaRole), roles[i].webcoreRole);
  return roleMap;
}

static inline LayoutObject* firstChildInContinuation(
    const LayoutInline& layoutObject) {
  LayoutBoxModelObject* r = layoutObject.continuation();

  while (r) {
    if (r->isLayoutBlock())
      return r;
    if (LayoutObject* child = r->slowFirstChild())
      return child;
    r = toLayoutInline(r)->continuation();
  }

  return 0;
}

bool AXObject::isMultiline() const {
Node* node = this->getNode();
if (!node)
return false;

if (isHTMLTextAreaElement(*node))
return true;

if (hasEditableStyle(*node))
return true;

if (!isNativeTextControl() && !isNonNativeTextControl())
return false;

  return equalIgnoringCase(getAttribute(aria_multilineAttr), "true");
}

std::unique_ptr<AXNode> InspectorAccessibilityAgent::buildObjectForIgnoredNode(
    Node* domNode,
    AXObject* axObject,
    bool fetchRelatives,
    std::unique_ptr<protocol::Array<AXNode>>& nodes,
    AXObjectCacheImpl& cache) const {
  AXObject::IgnoredReasons ignoredReasons;
  AXID axID = kIDForInspectedNodeWithNoAXNode;
  if (axObject && axObject->isAXLayoutObject())
    axID = axObject->axObjectID();
  std::unique_ptr<AXNode> ignoredNodeObject =
      AXNode::create().setNodeId(String::number(axID)).setIgnored(true).build();
  AccessibilityRole role = AccessibilityRole::IgnoredRole;
  ignoredNodeObject->setRole(createRoleNameValue(role));

  if (axObject && axObject->isAXLayoutObject()) {
    axObject->computeAccessibilityIsIgnored(&ignoredReasons);

    AXObject* parentObject = axObject->parentObjectUnignored();
    if (parentObject && fetchRelatives)
      addAncestors(*parentObject, axObject, nodes, cache);
  } else if (domNode && !domNode->layoutObject()) {
    if (fetchRelatives) {
      populateDOMNodeAncestors(*domNode, *(ignoredNodeObject.get()), nodes,
                               cache);
    }
    ignoredReasons.push_back(IgnoredReason(AXNotRendered));
  }

  if (domNode)
    ignoredNodeObject->setBackendDOMNodeId(DOMNodeIds::idForNode(domNode));

  std::unique_ptr<protocol::Array<AXProperty>> ignoredReasonProperties =
      protocol::Array<AXProperty>::create();
  for (size_t i = 0; i < ignoredReasons.size(); i++)
    ignoredReasonProperties->addItem(createProperty(ignoredReasons[i]));
  ignoredNodeObject->setIgnoredReasons(std::move(ignoredReasonProperties));

  return ignoredNodeObject;
}

const AXObject* AXObject::ariaHiddenRoot() const {
for (const AXObject* object = this; object; object = object->parentObject()) {
    if (equalIgnoringCase(object->getAttribute(aria_hiddenAttr), "true"))
return object;
}

return 0;
}

bool AXNodeObject::isNativeCheckboxOrRadio() const {
  Node* node = this->getNode();
  if (!isHTMLInputElement(node))
    return false;

  HTMLInputElement* input = toHTMLInputElement(node);
  return input->type() == InputTypeNames::checkbox ||
         input->type() == InputTypeNames::radio;
}

AXListBoxOption* AXListBoxOption::create(LayoutObject* layoutObject,
                                         AXObjectCacheImpl& axObjectCache) {
  return new AXListBoxOption(layoutObject, axObjectCache);
}

bool AXObject::isMenuRelated() const {
  switch (roleValue()) {
    case MenuRole:
    case MenuBarRole:
    case MenuButtonRole:
    case MenuItemRole:
    case MenuItemCheckBoxRole:
    case MenuItemRadioRole:
      return true;
    default:
      return false;
  }
}

AXObject* AXNodeObject::rawNextSibling() const {
  if (!getNode())
    return 0;

  Node* nextSibling = getNode()->nextSibling();
  if (!nextSibling)
    return 0;

  return axObjectCache().getOrCreate(nextSibling);
}

String AXLayoutObject::text() const {
  if (isPasswordFieldAndShouldHideValue()) {
    if (!getLayoutObject())
      return String();

    const ComputedStyle* style = getLayoutObject()->style();
    if (!style)
      return String();

    unsigned unmaskedTextLength = AXNodeObject::text().length();
    if (!unmaskedTextLength)
      return String();

    UChar maskCharacter = 0;
    switch (style->textSecurity()) {
      case TSNONE:
        break;  // Fall through to the non-password branch.
      case TSDISC:
        maskCharacter = bulletCharacter;
        break;
      case TSCIRCLE:
        maskCharacter = whiteBulletCharacter;
        break;
      case TSSQUARE:
        maskCharacter = blackSquareCharacter;
        break;
    }
    if (maskCharacter) {
      StringBuilder maskedText;
      maskedText.reserveCapacity(unmaskedTextLength);
      for (unsigned i = 0; i < unmaskedTextLength; ++i)
        maskedText.append(maskCharacter);
      return maskedText.toString();
    }
  }

  return AXNodeObject::text();
}

static bool isPresentationalInTable(AXObject* parent,
                                    HTMLElement* currentElement) {
  if (!currentElement)
    return false;

  Node* parentNode = parent->getNode();
  if (!parentNode || !parentNode->isHTMLElement())
    return false;

  if (isHTMLTableCellElement(*currentElement) &&
      isHTMLTableRowElement(*parentNode))
    return parent->hasInheritedPresentationalRole();

  if (isHTMLTableRowElement(*currentElement) &&
      isHTMLTableSectionElement(toHTMLElement(*parentNode))) {
    AXObject* tableObject = parent->parentObject();
    Node* tableNode = tableObject ? tableObject->getNode() : 0;
    return isHTMLTableElement(tableNode) &&
           tableObject->hasInheritedPresentationalRole();
  }
  return false;
}

void AXLayoutObject::setValue(const String& string) {
  if (!getNode() || !getNode()->isElementNode())
    return;
  if (!m_layoutObject || !m_layoutObject->isBoxModelObject())
    return;

  LayoutBoxModelObject* layoutObject = toLayoutBoxModelObject(m_layoutObject);
  if (layoutObject->isTextField() && isHTMLInputElement(*getNode()))
    toHTMLInputElement(*getNode())
        .setValue(string, DispatchInputAndChangeEvent);
  else if (layoutObject->isTextArea() && isHTMLTextAreaElement(*getNode()))
    toHTMLTextAreaElement(*getNode())
        .setValue(string, DispatchInputAndChangeEvent);
}

void AXObjectCacheImpl::textChanged(LayoutObject* layoutObject) {
  textChanged(getOrCreate(layoutObject));
}

AXObjectCacheImpl::AXObjectCacheImpl(Document& document)
    : m_document(document),
      m_modificationCount(0),
      m_notificationPostTimer(
          TaskRunnerHelper::get(TaskType::UnspecedTimer, &document),
          this,
          &AXObjectCacheImpl::notificationPostTimerFired) {}

bool AXNodeObject::isEmbeddedObject() const {
  return isHTMLPlugInElement(getNode());
}

bool AXObject::isPasswordFieldAndShouldHideValue() const {
  Settings* settings = getDocument()->settings();
  if (!settings || settings->getAccessibilityPasswordValuesEnabled())
    return false;

  return isPasswordField();
}

static AXSparseAttributeSetterMap& getSparseAttributeSetterMap() {
  DEFINE_STATIC_LOCAL(AXSparseAttributeSetterMap, axSparseAttributeSetterMap,
                      ());
  if (axSparseAttributeSetterMap.isEmpty()) {
    axSparseAttributeSetterMap.set(
        aria_activedescendantAttr,
        new ObjectAttributeSetter(AXObjectAttribute::AriaActiveDescendant));
    axSparseAttributeSetterMap.set(
        aria_controlsAttr,
        new ObjectVectorAttributeSetter(AXObjectVectorAttribute::AriaControls));
    axSparseAttributeSetterMap.set(
        aria_flowtoAttr,
        new ObjectVectorAttributeSetter(AXObjectVectorAttribute::AriaFlowTo));
    axSparseAttributeSetterMap.set(
        aria_detailsAttr,
        new ObjectVectorAttributeSetter(AXObjectVectorAttribute::AriaDetails));
    axSparseAttributeSetterMap.set(
        aria_errormessageAttr,
        new ObjectAttributeSetter(AXObjectAttribute::AriaErrorMessage));
    axSparseAttributeSetterMap.set(
        aria_keyshortcutsAttr,
        new StringAttributeSetter(AXStringAttribute::AriaKeyShortcuts));
    axSparseAttributeSetterMap.set(
        aria_roledescriptionAttr,
        new StringAttributeSetter(AXStringAttribute::AriaRoleDescription));
  }
  return axSparseAttributeSetterMap;
}

  void addObjectAttribute(AXObjectAttribute attribute, AXObject& object) {
    switch (attribute) {
      case AXObjectAttribute::AriaActiveDescendant:
        m_properties.addItem(
            createProperty(AXRelationshipAttributesEnum::Activedescendant,
                           createRelatedNodeListValue(object)));
        break;
      case AXObjectAttribute::AriaErrorMessage:
        m_properties.addItem(
            createProperty(AXRelationshipAttributesEnum::Errormessage,
                           createRelatedNodeListValue(object)));
        break;
    }
  }

void AXObjectCacheImpl::updateTreeIfElementIdIsAriaOwned(Element* element) {
  if (!element->hasID())
    return;

  String id = element->getIdAttribute();
  HashSet<AXID>* owners = m_idToAriaOwnersMapping.at(id);
  if (!owners)
    return;

  AXObject* axElement = getOrCreate(element);
  if (!axElement)
    return;

  if (isAriaOwned(axElement)) {
    AXObject* ownedParent = getAriaOwnedParent(axElement);
    DCHECK(ownedParent);
    childrenChanged(ownedParent);
    return;
  }

  for (const auto& axID : *owners) {
    AXObject* owner = objectFromAXID(axID);
    if (owner)
      childrenChanged(owner);
  }
}

bool AXNodeObject::isPressed() const {
if (!isButton())
return false;

Node* node = this->getNode();
if (!node)
return false;

// ARIA button with aria-pressed not undefined, then check for aria-pressed
// attribute rather than getNode()->active()
if (ariaRoleAttribute() == ToggleButtonRole) {
    if (equalIgnoringCase(getAttribute(aria_pressedAttr), "true") ||
        equalIgnoringCase(getAttribute(aria_pressedAttr), "mixed"))
return true;
return false;
}

return node->isActive();
}

static ARIAWidgetSet* createARIARoleWidgetSet() {
  ARIAWidgetSet* widgetSet = new HashSet<String, CaseFoldingHash>();
  for (size_t i = 0; i < WTF_ARRAY_LENGTH(ariaWidgets); ++i)
    widgetSet->insert(String(ariaWidgets[i]));
  return widgetSet;
}

AXObject* AXObjectCacheImpl::get(AbstractInlineTextBox* inlineTextBox) {
  if (!inlineTextBox)
    return 0;

  AXID axID = m_inlineTextBoxObjectMapping.at(inlineTextBox);
  DCHECK(!HashTraits<AXID>::isDeletedValue(axID));
  if (!axID)
    return 0;

  return m_objects.at(axID);
}

AXObjectCache* AXObjectCacheImpl::create(Document& document) {
  return new AXObjectCacheImpl(document);
}

static bool isImageOrAltText(LayoutBoxModelObject* box, Node* node) {
  if (box && box->isImage())
    return true;
  if (isHTMLImageElement(node))
    return true;
  if (isHTMLInputElement(node) &&
      toHTMLInputElement(node)->hasFallbackContent())
    return true;
  return false;
}

void InspectorAccessibilityAgent::fillCoreProperties(
    AXObject& axObject,
    AXObject* inspectedAXObject,
    bool fetchRelatives,
    AXNode& nodeObject,
    std::unique_ptr<protocol::Array<AXNode>>& nodes,
    AXObjectCacheImpl& cache) const {
  AXNameFrom nameFrom;
  AXObject::AXObjectVector nameObjects;
  axObject.name(nameFrom, &nameObjects);

  AXDescriptionFrom descriptionFrom;
  AXObject::AXObjectVector descriptionObjects;
  String description =
      axObject.description(nameFrom, descriptionFrom, &descriptionObjects);
  if (!description.isEmpty()) {
    nodeObject.setDescription(
        createValue(description, AXValueTypeEnum::ComputedString));
  }
  if (axObject.supportsRangeValue()) {
    nodeObject.setValue(createValue(axObject.valueForRange()));
  } else {
    String stringValue = axObject.stringValue();
    if (!stringValue.isEmpty())
      nodeObject.setValue(createValue(stringValue));
  }

  if (fetchRelatives)
    populateRelatives(axObject, inspectedAXObject, nodeObject, nodes, cache);

  Node* node = axObject.getNode();
  if (node)
    nodeObject.setBackendDOMNodeId(DOMNodeIds::idForNode(node));
}

bool AXNodeObject::isNativeTextControl() const {
  Node* node = this->getNode();
  if (!node)
    return false;

  if (isHTMLTextAreaElement(*node))
    return true;

  if (isHTMLInputElement(*node))
    return toHTMLInputElement(node)->isTextField();

  return false;
}

void AXObjectCacheImpl::remove(Node* node) {
  if (!node)
    return;

  AXID axID = m_nodeObjectMapping.at(node);
  remove(axID);
  m_nodeObjectMapping.erase(node);

  if (node->layoutObject()) {
    remove(node->layoutObject());
    return;
  }
}

bool AXLayoutObject::isFocused() const {
  if (!getDocument())
    return false;

  Element* focusedElement = getDocument()->focusedElement();
  if (!focusedElement)
    return false;
  AXObject* focusedObject = axObjectCache().getOrCreate(focusedElement);
  if (!focusedObject || !focusedObject->isAXLayoutObject())
    return false;

  if (focusedObject == this ||
      (roleValue() == WebAreaRole &&
       getDocument()->frame()->selection().isFocusedAndActive()))
    return true;

  return false;
}

KURL AXLayoutObject::url() const {
  if (isAnchor() && isHTMLAnchorElement(m_layoutObject->node())) {
    if (HTMLAnchorElement* anchor = toHTMLAnchorElement(anchorElement()))
      return anchor->href();
  }

  if (isWebArea())
    return m_layoutObject->document().url();

  if (isImage() && isHTMLImageElement(m_layoutObject->node()))
    return toHTMLImageElement(*m_layoutObject->node()).src();

  if (isInputImage())
    return toHTMLInputElement(m_layoutObject->node())->src();

  return KURL();
}

bool AXNodeObject::isMenuButton() const {
  return roleValue() == MenuButtonRole;
}

String AXLayoutObject::textAlternative(bool recursive,
                                       bool inAriaLabelledByTraversal,
                                       AXObjectSet& visited,
                                       AXNameFrom& nameFrom,
                                       AXRelatedObjectVector* relatedObjects,
                                       NameSources* nameSources) const {
  if (m_layoutObject) {
    String textAlternative;
    bool foundTextAlternative = false;

    if (m_layoutObject->isBR()) {
      textAlternative = String("\n");
      foundTextAlternative = true;
    } else if (m_layoutObject->isText() &&
               (!recursive || !m_layoutObject->isCounter())) {
      LayoutText* layoutText = toLayoutText(m_layoutObject);
      String result = layoutText->plainText();
      if (!result.isEmpty() || layoutText->isAllCollapsibleWhitespace())
        textAlternative = result;
      else
        textAlternative = layoutText->text();
      foundTextAlternative = true;
    } else if (m_layoutObject->isListMarker() && !recursive) {
      textAlternative = toLayoutListMarker(m_layoutObject)->text();
      foundTextAlternative = true;
    }

    if (foundTextAlternative) {
      nameFrom = AXNameFromContents;
      if (nameSources) {
        nameSources->push_back(NameSource(false));
        nameSources->back().type = nameFrom;
        nameSources->back().text = textAlternative;
      }
      return textAlternative;
    }
  }

  return AXNodeObject::textAlternative(recursive, inAriaLabelledByTraversal,
                                       visited, nameFrom, relatedObjects,
                                       nameSources);
}

String AXNodeObject::textFromDescendants(AXObjectSet& visited,
bool recursive) const {
if (!canHaveChildren() && recursive)
return String();

StringBuilder accumulatedText;
AXObject* previous = nullptr;

AXObjectVector children;

HeapVector<Member<AXObject>> ownedChildren;
computeAriaOwnsChildren(ownedChildren);
for (AXObject* obj = rawFirstChild(); obj; obj = obj->rawNextSibling()) {
if (!axObjectCache().isAriaOwned(obj))
children.push_back(obj);
}
for (const auto& ownedChild : ownedChildren)
children.push_back(ownedChild);

for (AXObject* child : children) {
// Don't recurse into children that are explicitly marked as aria-hidden.
// Note that we don't call isInertOrAriaHidden because that would return
// true if any ancestor is hidden, but we need to be able to compute the
// accessible name of object inside hidden subtrees (for example, if
// aria-labelledby points to an object that's hidden).
    if (equalIgnoringCase(child->getAttribute(aria_hiddenAttr), "true"))
continue;

// If we're going between two layoutObjects that are in separate
// LayoutBoxes, add whitespace if it wasn't there already. Intuitively if
// you have <span>Hello</span><span>World</span>, those are part of the same
// LayoutBox so we should return "HelloWorld", but given
// <div>Hello</div><div>World</div> the strings are in separate boxes so we
// should return "Hello World".
if (previous && accumulatedText.length() &&
!isHTMLSpace(accumulatedText[accumulatedText.length() - 1])) {
if (!isInSameNonInlineBlockFlow(child->getLayoutObject(),
previous->getLayoutObject()))
accumulatedText.append(' ');
}

String result;
if (child->isPresentational())
result = child->textFromDescendants(visited, true);
else
result = recursiveTextAlternative(*child, false, visited);
accumulatedText.append(result);
previous = child;
}

return accumulatedText.toString();
}

HTMLDialogElement* getActiveDialogElement(Node* node) {
  return node->document().activeModalDialog();
}

AXObject* AXNodeObject::activeDescendant() {
  if (!m_node || !m_node->isElementNode())
    return nullptr;

  const AtomicString& activeDescendantAttr =
      getAttribute(aria_activedescendantAttr);
  if (activeDescendantAttr.isNull() || activeDescendantAttr.isEmpty())
    return nullptr;

  Element* element = toElement(getNode());
  Element* descendant =
      element->treeScope().getElementById(activeDescendantAttr);
  if (!descendant)
    return nullptr;

  AXObject* axDescendant = axObjectCache().getOrCreate(descendant);
  return axDescendant;
}

bool AXObject::isARIAControl(AccessibilityRole ariaRole) {
  return isARIAInput(ariaRole) || ariaRole == ButtonRole ||
         ariaRole == ComboBoxRole || ariaRole == SliderRole;
}

IntPoint AXObject::minimumScrollOffset() const {
  ScrollableArea* area = getScrollableAreaIfScrollable();
  if (!area)
    return IntPoint();

  return IntPoint(area->minimumScrollOffsetInt().width(),
                  area->minimumScrollOffsetInt().height());
}

AXTableCell::AXTableCell(LayoutObject* layoutObject,
                         AXObjectCacheImpl& axObjectCache)
    : AXLayoutObject(layoutObject, axObjectCache) {}

AXObject* AXObject::leafNodeAncestor() const {
  if (AXObject* parent = parentObject()) {
    if (!parent->canHaveChildren())
      return parent;

    return parent->leafNodeAncestor();
  }

  return 0;
}

void AXObject::selectionChanged() {
  if (AXObject* parent = parentObjectIfExists())
    parent->selectionChanged();
}

void AXLayoutObject::detach() {
  AXNodeObject::detach();

  detachRemoteSVGRoot();

#if DCHECK_IS_ON()
  if (m_layoutObject)
    m_layoutObject->setHasAXObject(false);
#endif
  m_layoutObject = 0;
}

void AXObjectCacheImpl::selectionChanged(Node* node) {
  while (node) {
    if (AXObject* obj = get(node)) {
      obj->selectionChanged();
      return;
    }
    node = node->parentNode();
  }
}

bool AXObjectCacheImpl::accessibilityEnabled() {
  Settings* settings = this->settings();
  if (!settings)
    return false;
  return settings->getAccessibilityEnabled();
}

std::unique_ptr<AXNode> InspectorAccessibilityAgent::buildProtocolAXObject(
    AXObject& axObject,
    AXObject* inspectedAXObject,
    bool fetchRelatives,
    std::unique_ptr<protocol::Array<AXNode>>& nodes,
    AXObjectCacheImpl& cache) const {
  AccessibilityRole role = axObject.roleValue();
  std::unique_ptr<AXNode> nodeObject =
      AXNode::create()
          .setNodeId(String::number(axObject.axObjectID()))
          .setIgnored(false)
          .build();
  nodeObject->setRole(createRoleNameValue(role));

  std::unique_ptr<protocol::Array<AXProperty>> properties =
      protocol::Array<AXProperty>::create();
  fillLiveRegionProperties(axObject, *(properties.get()));
  fillGlobalStates(axObject, *(properties.get()));
  fillWidgetProperties(axObject, *(properties.get()));
  fillWidgetStates(axObject, *(properties.get()));
  fillRelationships(axObject, *(properties.get()));

  SparseAttributeAXPropertyAdapter adapter(axObject, *properties);
  axObject.getSparseAXAttributes(adapter);

  AXObject::NameSources nameSources;
  String computedName = axObject.name(&nameSources);
  if (!nameSources.isEmpty()) {
    std::unique_ptr<AXValue> name =
        createValue(computedName, AXValueTypeEnum::ComputedString);
    if (!nameSources.isEmpty()) {
      std::unique_ptr<protocol::Array<AXValueSource>> nameSourceProperties =
          protocol::Array<AXValueSource>::create();
      for (size_t i = 0; i < nameSources.size(); ++i) {
        NameSource& nameSource = nameSources[i];
        nameSourceProperties->addItem(createValueSource(nameSource));
        if (nameSource.text.isNull() || nameSource.superseded)
          continue;
        if (!nameSource.relatedObjects.isEmpty()) {
          properties->addItem(createRelatedNodeListProperty(
              AXRelationshipAttributesEnum::Labelledby,
              nameSource.relatedObjects));
        }
      }
      name->setSources(std::move(nameSourceProperties));
    }
    nodeObject->setProperties(std::move(properties));
    nodeObject->setName(std::move(name));
  } else {
    nodeObject->setProperties(std::move(properties));
  }

  fillCoreProperties(axObject, inspectedAXObject, fetchRelatives,
                     *(nodeObject.get()), nodes, cache);
  return nodeObject;
}

bool AXObject::supportsRangeValue() const {
  return isProgressIndicator() || isMeter() || isSlider() || isScrollbar() ||
         isSpinButton();
}

void AXObjectCacheImpl::labelChanged(Element* element) {
  textChanged(toHTMLLabelElement(element)->control());
}

bool AXListBoxOption::canSetSelectedAttribute() const {
  if (!isHTMLOptionElement(getNode()))
    return false;

  if (toHTMLOptionElement(getNode())->isDisabledFormControl())
    return false;

  HTMLSelectElement* selectElement = listBoxOptionParentNode();
  if (selectElement && selectElement->isDisabledFormControl())
    return false;

  return true;
}

bool AXLayoutObject::elementAttributeValue(
const QualifiedName& attributeName) const {
if (!m_layoutObject)
return false;

  return equalIgnoringCase(getAttribute(attributeName), "true");
}

void AXObject::setSequentialFocusNavigationStartingPoint() {
  if (parentObject())
    parentObject()->setSequentialFocusNavigationStartingPoint();
}

void AXLayoutObject::textChanged() {
  if (!m_layoutObject)
    return;

  Settings* settings = getDocument()->settings();
  if (settings && settings->getInlineTextBoxAccessibilityEnabled() &&
      roleValue() == StaticTextRole)
    childrenChanged();

  AXNodeObject::textChanged();
}

AXObject* AXLayoutObject::accessibilityHitTest(const IntPoint& point) const {
  if (!m_layoutObject || !m_layoutObject->hasLayer())
    return nullptr;

  PaintLayer* layer = toLayoutBox(m_layoutObject)->layer();

  HitTestRequest request(HitTestRequest::ReadOnly | HitTestRequest::Active);
  HitTestResult hitTestResult = HitTestResult(request, point);
  layer->hitTest(hitTestResult);

  Node* node = hitTestResult.innerNode();
  if (!node)
    return nullptr;

  if (isHTMLAreaElement(node))
    return accessibilityImageMapHitTest(toHTMLAreaElement(node), point);

  if (isHTMLOptionElement(node)) {
    node = toHTMLOptionElement(*node).ownerSelectElement();
    if (!node)
      return nullptr;
  }

  LayoutObject* obj = node->layoutObject();
  if (!obj)
    return nullptr;

  AXObject* result = axObjectCache().getOrCreate(obj);
  result->updateChildrenIfNecessary();

  result = result->elementAccessibilityHitTest(point);
  if (result && result->accessibilityIsIgnored()) {
    if (result->isAXLayoutObject()) {
      AXObject* controlObject =
          toAXLayoutObject(result)->correspondingControlForLabelElement();
      if (controlObject && controlObject->nameFromLabelElement())
        return controlObject;
    }

    result = result->parentObjectUnignored();
  }

  return result;
}

static int computeBestScrollOffset(int currentScrollOffset,
                                   int subfocusMin,
                                   int subfocusMax,
                                   int objectMin,
                                   int objectMax,
                                   int viewportMin,
                                   int viewportMax) {
  int viewportSize = viewportMax - viewportMin;

  if (objectMax - objectMin > viewportSize) {
    if (subfocusMin - currentScrollOffset >= viewportMin &&
        subfocusMax - currentScrollOffset <= viewportMax)
      return currentScrollOffset;

    subfocusMin = std::max(subfocusMin, objectMin);
    subfocusMax = std::min(subfocusMax, objectMax);

    if (subfocusMax - subfocusMin > viewportSize)
      subfocusMax = subfocusMin + viewportSize;

    int centeredObjectMin = (subfocusMin + subfocusMax - viewportSize) / 2;
    int centeredObjectMax = centeredObjectMin + viewportSize;

    objectMin = std::max(objectMin, centeredObjectMin);
    objectMax = std::min(objectMax, centeredObjectMax);
  }

  if (objectMin - currentScrollOffset >= viewportMin &&
      objectMax - currentScrollOffset <= viewportMax)
    return currentScrollOffset;

  return (objectMin + objectMax - viewportMin - viewportMax) / 2;
}

AXObject* AXObjectCacheImpl::get(LayoutObject* layoutObject) {
  if (!layoutObject)
    return 0;

  AXID axID = m_layoutObjectMapping.at(layoutObject);
  DCHECK(!HashTraits<AXID>::isDeletedValue(axID));
  if (!axID)
    return 0;

  return m_objects.at(axID);
}

bool AXObjectCacheImpl::inlineTextBoxAccessibilityEnabled() {
  Settings* settings = this->settings();
  if (!settings)
    return false;
  return settings->getInlineTextBoxAccessibilityEnabled();
}

const AtomicString& AXObject::internalRoleName(AccessibilityRole role) {
  static const Vector<AtomicString>* internalRoleNameVector =
      createInternalRoleNameVector();

  return internalRoleNameVector->at(role);
}

void fillGlobalStates(AXObject& axObject,
                      protocol::Array<AXProperty>& properties) {
  if (!axObject.isEnabled())
    properties.addItem(
        createProperty(AXGlobalStatesEnum::Disabled, createBooleanValue(true)));

  if (const AXObject* hiddenRoot = axObject.ariaHiddenRoot()) {
    properties.addItem(
        createProperty(AXGlobalStatesEnum::Hidden, createBooleanValue(true)));
    properties.addItem(createProperty(AXGlobalStatesEnum::HiddenRoot,
                                      createRelatedNodeListValue(*hiddenRoot)));
  }

  InvalidState invalidState = axObject.getInvalidState();
  switch (invalidState) {
    case InvalidStateUndefined:
      break;
    case InvalidStateFalse:
      properties.addItem(
          createProperty(AXGlobalStatesEnum::Invalid,
                         createValue("false", AXValueTypeEnum::Token)));
      break;
    case InvalidStateTrue:
      properties.addItem(
          createProperty(AXGlobalStatesEnum::Invalid,
                         createValue("true", AXValueTypeEnum::Token)));
      break;
    case InvalidStateSpelling:
      properties.addItem(
          createProperty(AXGlobalStatesEnum::Invalid,
                         createValue("spelling", AXValueTypeEnum::Token)));
      break;
    case InvalidStateGrammar:
      properties.addItem(
          createProperty(AXGlobalStatesEnum::Invalid,
                         createValue("grammar", AXValueTypeEnum::Token)));
      break;
    default:
      properties.addItem(createProperty(
          AXGlobalStatesEnum::Invalid,
          createValue(axObject.ariaInvalidValue(), AXValueTypeEnum::String)));
      break;
  }
}

const AtomicString& AXObjectCacheImpl::computedRoleForNode(Node* node) {
  AXObject* obj = getOrCreate(node);
  if (!obj)
    return AXObject::roleName(UnknownRole);
  return AXObject::roleName(obj->roleValue());
}

static bool isRequiredOwnedElement(AXObject* parent,
                                   AccessibilityRole currentRole,
                                   HTMLElement* currentElement) {
  Node* parentNode = parent->getNode();
  if (!parentNode || !parentNode->isHTMLElement())
    return false;

  if (currentRole == ListItemRole)
    return isListElement(parentNode);
  if (currentRole == ListMarkerRole)
    return isHTMLLIElement(*parentNode);
  if (currentRole == MenuItemCheckBoxRole || currentRole == MenuItemRole ||
      currentRole == MenuItemRadioRole)
    return isHTMLMenuElement(*parentNode);

  if (!currentElement)
    return false;
  if (isHTMLTableCellElement(*currentElement))
    return isHTMLTableRowElement(*parentNode);
  if (isHTMLTableRowElement(*currentElement))
    return isHTMLTableSectionElement(toHTMLElement(*parentNode));

  return false;
}

bool AXObject::isScrollableContainer() const {
  return !!getScrollableAreaIfScrollable();
}

void AXLayoutObject::loadInlineTextBoxes() {
  if (!getLayoutObject() || !getLayoutObject()->isText())
    return;

  clearChildren();
  addInlineTextBoxChildren(true);
}

AXObject* AXObjectCacheImpl::root() {
  return getOrCreate(m_document);
}

AXObject* AXLayoutObject::computeParent() const {
  ASSERT(!isDetached());
  if (!m_layoutObject)
    return 0;

  if (ariaRoleAttribute() == MenuBarRole)
    return axObjectCache().getOrCreate(m_layoutObject->parent());

  if (ariaRoleAttribute() == MenuRole) {
    AXObject* parent = menuButtonForMenu();
    if (parent)
      return parent;
  }

  LayoutObject* parentObj = layoutParentObject();
  if (parentObj)
    return axObjectCache().getOrCreate(parentObj);

  if (isWebArea()) {
    LocalFrame* frame = m_layoutObject->frame();
    return axObjectCache().getOrCreate(frame->pagePopupOwner());
  }

  return 0;
}

unsigned AXNodeObject::hierarchicalLevel() const {
  Node* node = this->getNode();
  if (!node || !node->isElementNode())
    return 0;

  Element* element = toElement(node);
  String levelStr = element->getAttribute(aria_levelAttr);
  if (!levelStr.isEmpty()) {
    int level = levelStr.toInt();
    if (level > 0)
      return level;
    return 1;
  }

  if (roleValue() != TreeItemRole)
    return 0;

  unsigned level = 1;
  for (AXObject* parent = parentObject(); parent;
       parent = parent->parentObject()) {
    AccessibilityRole parentRole = parent->roleValue();
    if (parentRole == GroupRole)
      level++;
    else if (parentRole == TreeRole)
      break;
  }

  return level;
}

bool AXObject::hasInheritedPresentationalRole() const {
  updateCachedAttributeValuesIfNeeded();
  return m_cachedHasInheritedPresentationalRole;
}

void AXObjectCacheImpl::radiobuttonRemovedFromGroup(
    HTMLInputElement* groupMember) {
  AXObject* obj = get(groupMember);
  if (!obj || !obj->isAXRadioInput())
    return;

  HTMLInputElement* firstRadio =
      toAXRadioInput(obj)->findFirstRadioButtonInGroup(groupMember);
  AXObject* firstObj = get(firstRadio);
  if (!firstObj || !firstObj->isAXRadioInput())
    return;

  toAXRadioInput(firstObj)->updatePosAndSetSize(1);
  postNotification(firstObj, AXAriaAttributeChanged);
  toAXRadioInput(firstObj)->requestUpdateToNextNode(true);
}

void AXObjectCacheImpl::postNotification(AXObject* object,
                                         AXNotification notification) {
  if (!object)
    return;

  m_modificationCount++;
  m_notificationsToPost.push_back(std::make_pair(object, notification));
  if (!m_notificationPostTimer.isActive())
    m_notificationPostTimer.startOneShot(0, BLINK_FROM_HERE);
}

AXObject* AXLayoutObject::remoteSVGElementHitTest(const IntPoint& point) const {
  AXObject* remote = remoteSVGRootElement();
  if (!remote)
    return 0;

  IntSize offset =
      point - roundedIntPoint(getBoundsInFrameCoordinates().location());
  return remote->accessibilityHitTest(IntPoint(offset));
}

String AXListBoxOption::textAlternative(bool recursive,
                                        bool inAriaLabelledByTraversal,
                                        AXObjectSet& visited,
                                        AXNameFrom& nameFrom,
                                        AXRelatedObjectVector* relatedObjects,
                                        NameSources* nameSources) const {
  if (nameSources)
    ASSERT(relatedObjects);

  if (!getNode())
    return String();

  bool foundTextAlternative = false;
  String textAlternative = ariaTextAlternative(
      recursive, inAriaLabelledByTraversal, visited, nameFrom, relatedObjects,
      nameSources, &foundTextAlternative);
  if (foundTextAlternative && !nameSources)
    return textAlternative;

  nameFrom = AXNameFromContents;
  textAlternative = toHTMLOptionElement(getNode())->displayLabel();
  if (nameSources) {
    nameSources->push_back(NameSource(foundTextAlternative));
    nameSources->back().type = nameFrom;
    nameSources->back().text = textAlternative;
    foundTextAlternative = true;
  }

  return textAlternative;
}

int AXNodeObject::setSize() const {
  if (supportsSetSizeAndPosInSet()) {
    String setSizeStr = getAttribute(aria_setsizeAttr);
    if (!setSizeStr.isEmpty()) {
      int setSize = setSizeStr.toInt();
      if (setSize > 0)
        return setSize;
      return 1;
    }

    if (parentObject()) {
      const auto& siblings = parentObject()->children();
      return siblings.size();
    }
  }

  return 0;
}

AccessibilityRole AXNodeObject::remapAriaRoleDueToParent(
    AccessibilityRole role) const {

  if (role != ListBoxOptionRole && role != MenuItemRole)
    return role;

  for (AXObject* parent = parentObject();
       parent && !parent->accessibilityIsIgnored();
       parent = parent->parentObject()) {
    AccessibilityRole parentAriaRole = parent->ariaRoleAttribute();

    if (role == ListBoxOptionRole && parentAriaRole == MenuRole)
      return MenuItemRole;
    if (role == MenuItemRole && parentAriaRole == GroupRole)
      return MenuButtonRole;

    if (parentAriaRole)
      break;
  }

  return role;
}

void AXObjectCacheImpl::setCanvasObjectBounds(HTMLCanvasElement* canvas,
                                              Element* element,
                                              const LayoutRect& rect) {
  AXObject* obj = getOrCreate(element);
  if (!obj)
    return;

  AXObject* axCanvas = getOrCreate(canvas);
  if (!axCanvas)
    return;

  obj->setElementRect(rect, axCanvas);
}

AXObject::AXRange AXLayoutObject::textControlSelection() const {
  if (!getLayoutObject())
    return AXRange();

  LayoutObject* layout = nullptr;
  if (getLayoutObject()->isTextControl()) {
    layout = getLayoutObject();
  } else {
    Element* focusedElement = getDocument()->focusedElement();
    if (focusedElement && focusedElement->layoutObject() &&
        focusedElement->layoutObject()->isTextControl())
      layout = focusedElement->layoutObject();
  }

  if (!layout)
    return AXRange();

  AXObject* axObject = axObjectCache().getOrCreate(layout);
  if (!axObject || !axObject->isAXLayoutObject())
    return AXRange();

  VisibleSelection selection =
      layout->frame()->selection().computeVisibleSelectionInDOMTreeDeprecated();
  TextControlElement* textControl =
      toLayoutTextControl(layout)->textControlElement();
  ASSERT(textControl);
  int start = textControl->selectionStart();
  int end = textControl->selectionEnd();

  return AXRange(axObject, start, selection.visibleStart().affinity(), axObject,
                 end, selection.visibleEnd().affinity());
}

void AXNodeObject::computeAriaOwnsChildren(
    HeapVector<Member<AXObject>>& ownedChildren) const {
  if (!hasAttribute(aria_ownsAttr))
    return;

  Vector<String> idVector;
  if (canHaveChildren() && !isNativeTextControl() &&
      !hasContentEditableAttributeSet())
    tokenVectorFromAttribute(idVector, aria_ownsAttr);

  axObjectCache().updateAriaOwns(this, idVector, ownedChildren);
}

bool isNodeAriaVisible(Node* node) {
if (!node)
return false;

if (!node->isElementNode())
return false;

  return equalIgnoringCase(toElement(node)->getAttribute(aria_hiddenAttr),
                           "false");
}

int AXNodeObject::headingLevel() const {
  Node* node = this->getNode();
  if (!node)
    return 0;

  if (roleValue() == HeadingRole) {
    String levelStr = getAttribute(aria_levelAttr);
    if (!levelStr.isEmpty()) {
      int level = levelStr.toInt();
      if (level >= 1 && level <= 9)
        return level;
      return 1;
    }
  }

  if (!node->isHTMLElement())
    return 0;

  HTMLElement& element = toHTMLElement(*node);
  if (element.hasTagName(h1Tag))
    return 1;

  if (element.hasTagName(h2Tag))
    return 2;

  if (element.hasTagName(h3Tag))
    return 3;

  if (element.hasTagName(h4Tag))
    return 4;

  if (element.hasTagName(h5Tag))
    return 5;

  if (element.hasTagName(h6Tag))
    return 6;

  return 0;
}

bool AXLayoutObject::isEditable() const {
  if (getLayoutObject() && getLayoutObject()->isTextControl())
    return true;

  if (getNode() && hasEditableStyle(*getNode()))
    return true;

  if (isWebArea()) {
    Document& document = getLayoutObject()->document();
    HTMLElement* body = document.body();
    if (body && hasEditableStyle(*body)) {
      AXObject* axBody = axObjectCache().getOrCreate(body);
      return axBody && axBody != axBody->ariaHiddenRoot();
    }

    return hasEditableStyle(document);
  }

  return AXNodeObject::isEditable();
}

AccessibilityRole AXTableCell::determineAccessibilityRole() {
  if (!isTableCell())
    return AXLayoutObject::determineAccessibilityRole();

  return scanToDecideHeaderRole();
}

AXObject* AXNodeObject::menuButtonForMenu() const {
  Element* menuItem = menuItemElementForMenu();

  if (menuItem) {
    AXObject* menuItemAX = axObjectCache().getOrCreate(menuItem);
    if (menuItemAX && menuItemAX->isMenuButton())
      return menuItemAX;
  }
  return 0;
}

static bool isLinkable(const AXObject& object) {
  if (!object.getLayoutObject())
    return false;

  return object.isLink() || object.isImage() ||
         object.getLayoutObject()->isText();
}

AccessibilityExpanded AXNodeObject::isExpanded() const {
if (getNode() && isHTMLSummaryElement(*getNode())) {
if (getNode()->parentNode() &&
isHTMLDetailsElement(getNode()->parentNode()))
return toElement(getNode()->parentNode())->hasAttribute(openAttr)
? ExpandedExpanded
: ExpandedCollapsed;
}

const AtomicString& expanded = getAttribute(aria_expandedAttr);
  if (equalIgnoringCase(expanded, "true"))
return ExpandedExpanded;
  if (equalIgnoringCase(expanded, "false"))
return ExpandedCollapsed;

return ExpandedUndefined;
}

void InspectorAccessibilityAgent::populateRelatives(
    AXObject& axObject,
    AXObject* inspectedAXObject,
    AXNode& nodeObject,
    std::unique_ptr<protocol::Array<AXNode>>& nodes,
    AXObjectCacheImpl& cache) const {
  AXObject* parentObject = axObject.parentObject();
  if (parentObject && parentObject != inspectedAXObject) {
    parentObject = axObject.parentObjectUnignored();
  }

  std::unique_ptr<protocol::Array<AXNodeId>> childIds =
      protocol::Array<AXNodeId>::create();

  if (&axObject != inspectedAXObject ||
      (inspectedAXObject && !inspectedAXObject->accessibilityIsIgnored())) {
    addChildren(axObject, inspectedAXObject, childIds, nodes, cache);
  }
  nodeObject.setChildIds(std::move(childIds));
}

  ObjectVectorAttributeSetter(AXObjectVectorAttribute attribute)
      : m_attribute(attribute) {}

AXObject* AXObjectCacheImpl::getOrCreate(LayoutObject* layoutObject) {
  if (!layoutObject)
    return 0;

  if (AXObject* obj = get(layoutObject))
    return obj;

  AXObject* newObj = createFromRenderer(layoutObject);

  DCHECK(!get(layoutObject));

  const AXID axid = getOrCreateAXID(newObj);

  m_layoutObjectMapping.set(layoutObject, axid);
  newObj->init();
  newObj->setLastKnownIsIgnoredValue(newObj->accessibilityIsIgnored());

  return newObj;
}

bool AXNodeObject::isDescendantOfElementType(
    HashSet<QualifiedName>& tagNames) const {
  if (!getNode())
    return false;

  for (Element* parent = getNode()->parentElement(); parent;
       parent = parent->parentElement()) {
    if (tagNames.contains(parent->tagQName()))
      return true;
  }
  return false;
}

float AXNodeObject::minValueForRange() const {
  if (hasAttribute(aria_valueminAttr))
    return getAttribute(aria_valueminAttr).toFloat();

  if (isNativeSlider())
    return toHTMLInputElement(*getNode()).minimum();

  if (isHTMLMeterElement(getNode()))
    return toHTMLMeterElement(*getNode()).min();

  return 0.0;
}

Node* AXLayoutObject::getNode() const {
  return getLayoutObject() ? getLayoutObject()->node() : nullptr;
}

static inline LayoutObject* endOfContinuations(LayoutObject* layoutObject) {
  LayoutObject* prev = layoutObject;
  LayoutObject* cur = layoutObject;

  if (!cur->isLayoutInline() && !cur->isLayoutBlockFlow())
    return layoutObject;

  while (cur) {
    prev = cur;
    if (cur->isLayoutInline()) {
      cur = toLayoutInline(cur)->inlineElementContinuation();
      ASSERT(cur || !toLayoutInline(prev)->continuation());
    } else {
      cur = toLayoutBlockFlow(cur)->inlineElementContinuation();
    }
  }

  return prev;
}

void AXNodeObject::updateAccessibilityRole() {
  bool ignoredStatus = accessibilityIsIgnored();
  m_role = determineAccessibilityRole();

  if (ignoredStatus != accessibilityIsIgnored())
    childrenChanged();
}

int AXNodeObject::posInSet() const {
  if (supportsSetSizeAndPosInSet()) {
    String posInSetStr = getAttribute(aria_posinsetAttr);
    if (!posInSetStr.isEmpty()) {
      int posInSet = posInSetStr.toInt();
      if (posInSet > 0)
        return posInSet;
      return 1;
    }

    return AXObject::indexInParent() + 1;
  }

  return 0;
}

double AXLayoutObject::estimatedLoadingProgress() const {
  if (!m_layoutObject)
    return 0;

  if (isLoaded())
    return 1.0;

  if (LocalFrame* frame = m_layoutObject->document().frame())
    return frame->loader().progress().estimatedProgress();
  return 0;
}

Element* AXNodeObject::mouseButtonListener() const {
  Node* node = this->getNode();
  if (!node)
    return 0;

  if (!node->isElementNode())
    node = node->parentElement();

  if (!node)
    return 0;

  for (Element* element = toElement(node); element;
       element = element->parentElement()) {
    if (isHTMLBodyElement(element))
      break;

    if (element->hasEventListeners(EventTypeNames::click) ||
        element->hasEventListeners(EventTypeNames::mousedown) ||
        element->hasEventListeners(EventTypeNames::mouseup) ||
        element->hasEventListeners(EventTypeNames::DOMActivate))
      return element;
  }

  return 0;
}

void AXObjectCacheImpl::onTouchAccessibilityHover(const IntPoint& location) {
  AXObject* hit = root()->accessibilityHitTest(location);
  if (hit) {
    if (hit->getLayoutObject() && hit->getLayoutObject()->isLayoutPart())
      return;

    postPlatformNotification(hit, AXHover);
  }
}

void AXObjectCacheImpl::childrenChanged(LayoutObject* layoutObject) {
  childrenChanged(get(layoutObject));
}

bool AXNodeObject::isControl() const {
  Node* node = this->getNode();
  if (!node)
    return false;

  return ((node->isElementNode() && toElement(node)->isFormControlElement()) ||
          AXObject::isARIAControl(ariaRoleAttribute()));
}

AXObject* AXNodeObject::computeParentIfExists() const {
  if (Node* parentNode = getParentNodeForComputeParent(getNode()))
    return axObjectCache().get(parentNode);

  return nullptr;
}

InvalidState AXNodeObject::getInvalidState() const {
const AtomicString& attributeValue =
getAOMPropertyOrARIAAttribute(AOMStringProperty::kInvalid);
  if (equalIgnoringCase(attributeValue, "false"))
return InvalidStateFalse;
  if (equalIgnoringCase(attributeValue, "true"))
return InvalidStateTrue;
  if (equalIgnoringCase(attributeValue, "spelling"))
return InvalidStateSpelling;
  if (equalIgnoringCase(attributeValue, "grammar"))
return InvalidStateGrammar;
// A yet unknown value.
if (!attributeValue.isEmpty())
return InvalidStateOther;

if (getNode() && getNode()->isElementNode() &&
toElement(getNode())->isFormControlElement()) {
HTMLFormControlElement* element = toHTMLFormControlElement(getNode());
HeapVector<Member<HTMLFormControlElement>> invalidControls;
bool isInvalid =
!element->checkValidity(&invalidControls, CheckValidityDispatchNoEvent);
return isInvalid ? InvalidStateTrue : InvalidStateFalse;
}

return AXObject::getInvalidState();
}

void AXLayoutObject::clearChildren() {
  AXObject::clearChildren();
  m_childrenDirty = false;
}

String AXObject::recursiveTextAlternative(const AXObject& axObj,
                                          bool inAriaLabelledByTraversal,
                                          AXObjectSet& visited) {
  if (visited.contains(&axObj) && !inAriaLabelledByTraversal)
    return String();

  AXNameFrom tmpNameFrom;
  return axObj.textAlternative(true, inAriaLabelledByTraversal, visited,
                               tmpNameFrom, nullptr, nullptr);
 }

int AXLayoutObject::index(const VisiblePosition& position) const {
  if (position.isNull() || !isTextControl())
    return -1;

  if (layoutObjectContainsPosition(m_layoutObject, position.deepEquivalent()))
    return indexForVisiblePosition(position);

  return -1;
}

std::unique_ptr<AXProperty> createRelatedNodeListProperty(
    const String& key,
    AXRelatedObjectVector& nodes) {
  std::unique_ptr<AXValue> nodeListValue =
      createRelatedNodeListValue(nodes, AXValueTypeEnum::NodeList);
  return createProperty(key, std::move(nodeListValue));
}

static inline bool isInlineWithContinuation(LayoutObject* object) {
  if (!object->isBoxModelObject())
    return false;

  LayoutBoxModelObject* layoutObject = toLayoutBoxModelObject(object);
  if (!layoutObject->isLayoutInline())
    return false;

  return toLayoutInline(layoutObject)->continuation();
}

void AXObjectCacheImpl::handleClicked(Node* node) {
  if (AXObject* obj = getOrCreate(node))
    postNotification(obj, AXClicked);
}

String AXObject::textFromAriaDescribedby(
    AXRelatedObjectVector* relatedObjects) const {
  AXObjectSet visited;
  HeapVector<Member<Element>> elements;
  elementsFromAttribute(elements, aria_describedbyAttr);
  return textFromElements(true, visited, elements, relatedObjects);
}

 bool AXLayoutObject::supportsARIADropping() const {
  const AtomicString& dropEffect = getAttribute(aria_dropeffectAttr);
  return !dropEffect.isEmpty();
}

static LayoutBoxModelObject* nextContinuation(LayoutObject* layoutObject) {
  ASSERT(layoutObject);
  if (layoutObject->isLayoutInline() && !layoutObject->isAtomicInlineLevel())
    return toLayoutInline(layoutObject)->continuation();
  if (layoutObject->isLayoutBlockFlow())
    return toLayoutBlockFlow(layoutObject)->inlineElementContinuation();
  return 0;
}

AXNodeObject* AXNodeObject::create(Node* node,
                                   AXObjectCacheImpl& axObjectCache) {
  return new AXNodeObject(node, axObjectCache);
}

String AXNodeObject::text() const {
  if (ariaRoleAttribute() == StaticTextRole)
    return computedName();

  if (!isTextControl())
    return String();

  Node* node = this->getNode();
  if (!node)
    return String();

  if (isNativeTextControl() &&
      (isHTMLTextAreaElement(*node) || isHTMLInputElement(*node)))
    return toTextControlElement(*node).value();

  if (!node->isElementNode())
    return String();

  return toElement(node)->innerText();
}

AXObject* AXObject::parentObject() const {
  if (isDetached())
    return 0;

  if (m_parent)
    return m_parent;

  if (axObjectCache().isAriaOwned(this))
    return axObjectCache().getAriaOwnedParent(this);

  return computeParent();
}

bool AXARIAGridCell::isAriaColumnHeader() const {
const AtomicString& role = getAttribute(HTMLNames::roleAttr);
  return equalIgnoringCase(role, "columnheader");
}

AXLayoutObject* AXLayoutObject::getUnignoredObjectFromNode(Node& node) const {
  if (isDetached())
    return nullptr;

  AXObject* axObject = axObjectCache().getOrCreate(&node);
  if (!axObject)
    return nullptr;

  if (axObject->isAXLayoutObject() && !axObject->accessibilityIsIgnored())
    return toAXLayoutObject(axObject);

  return nullptr;
}

AriaCurrentState AXNodeObject::ariaCurrentState() const {
const AtomicString& attributeValue =
getAOMPropertyOrARIAAttribute(AOMStringProperty::kCurrent);
if (attributeValue.isNull())
return AriaCurrentStateUndefined;
  if (attributeValue.isEmpty() || equalIgnoringCase(attributeValue, "false"))
return AriaCurrentStateFalse;
  if (equalIgnoringCase(attributeValue, "true"))
return AriaCurrentStateTrue;
  if (equalIgnoringCase(attributeValue, "page"))
return AriaCurrentStatePage;
  if (equalIgnoringCase(attributeValue, "step"))
return AriaCurrentStateStep;
  if (equalIgnoringCase(attributeValue, "location"))
return AriaCurrentStateLocation;
  if (equalIgnoringCase(attributeValue, "date"))
return AriaCurrentStateDate;
  if (equalIgnoringCase(attributeValue, "time"))
return AriaCurrentStateTime;
// An unknown value should return true.
if (!attributeValue.isEmpty())
return AriaCurrentStateTrue;

return AXObject::ariaCurrentState();
}

LayoutObject* AXLayoutObject::layoutParentObject() const {
  if (!m_layoutObject)
    return 0;

  LayoutObject* startOfConts = m_layoutObject->isLayoutBlockFlow()
                                   ? startOfContinuations(m_layoutObject)
                                   : nullptr;
  if (startOfConts) {
    return startOfConts;
  }

  LayoutObject* parent = m_layoutObject->parent();
  startOfConts =
      parent && parent->isLayoutInline() ? startOfContinuations(parent) : 0;
  if (startOfConts) {
    return startOfConts;
  }

  LayoutObject* firstChild = parent ? parent->slowFirstChild() : 0;
  if (firstChild && firstChild->node()) {
    for (LayoutObject* nodeLayoutFirstChild =
             firstChild->node()->layoutObject();
         nodeLayoutFirstChild != firstChild;
         nodeLayoutFirstChild = firstChild->node()->layoutObject()) {
      for (LayoutObject* contsTest = nodeLayoutFirstChild; contsTest;
           contsTest = nextContinuation(contsTest)) {
        if (contsTest == firstChild) {
          parent = nodeLayoutFirstChild->parent();
          break;
        }
      }
      LayoutObject* newFirstChild = parent->slowFirstChild();
      if (firstChild == newFirstChild)
        break;
      firstChild = newFirstChild;
      if (!firstChild->node())
        break;
    }
  }

  return parent;
}

void AXObjectCacheImpl::handleScrollPositionChanged(
    LayoutObject* layoutObject) {
  postPlatformNotification(getOrCreate(layoutObject), AXScrollPositionChanged);
}

unsigned AXTableCell::ariaColumnIndex() const {
  const AtomicString& colIndex = getAttribute(aria_colindexAttr);
  if (colIndex.toInt() >= 1)
    return colIndex.toInt();

  AXObject* parent = parentObjectUnignored();
  if (!parent || !parent->isTableRow())
    return 0;

  return m_ariaColIndexFromRow;
}

AXObject* AXObjectCacheImpl::getOrCreate(Node* node) {
  if (!node)
    return 0;

  if (AXObject* obj = get(node))
    return obj;

  if (node->layoutObject() && !isHTMLAreaElement(node))
    return getOrCreate(node->layoutObject());

  if (!node->parentElement())
    return 0;

  if (isHTMLHeadElement(node))
    return 0;

  AXObject* newObj = createFromNode(node);

  DCHECK(!get(node));

  const AXID axID = getOrCreateAXID(newObj);

  m_nodeObjectMapping.set(node, axID);
  newObj->init();
  newObj->setLastKnownIsIgnoredValue(newObj->accessibilityIsIgnored());

  if (node->isElementNode())
    updateTreeIfElementIdIsAriaOwned(toElement(node));

  return newObj;
}

 void AXObjectCacheImpl::postPlatformNotification(AXObject* obj,
                                                 AXNotification notification) {
  if (!obj || !obj->getDocument() || !obj->documentFrameView() ||
      !obj->documentFrameView()->frame().page())
    return;

  ChromeClient& client =
      obj->getDocument()->axObjectCacheOwner().page()->chromeClient();
  client.postAccessibilityNotification(obj, notification);
}

AccessibilityRole AXTableCell::scanToDecideHeaderRole() {
  if (!isTableHeaderCell())
    return CellRole;

  if (isRowHeaderCell())
    return RowHeaderRole;

  if (isColumnHeaderCell())
    return ColumnHeaderRole;

  LayoutTableCell* layoutCell = toLayoutTableCell(m_layoutObject);
  AccessibilityRole headerRole = CellRole;

  if ((headerRole = decideRoleFromSibling(layoutCell->previousCell())) !=
      CellRole)
    return headerRole;

  if ((headerRole = decideRoleFromSibling(layoutCell->nextCell())) != CellRole)
    return headerRole;

  return ColumnHeaderRole;
}

bool AXObject::supportsActiveDescendant() const {
  switch (ariaRoleAttribute()) {
    case ComboBoxRole:
    case GridRole:
    case GroupRole:
    case ListBoxRole:
    case MenuRole:
    case MenuBarRole:
    case RadioGroupRole:
    case RowRole:
    case SearchBoxRole:
    case TabListRole:
    case TextFieldRole:
    case ToolbarRole:
    case TreeRole:
    case TreeGridRole:
      return true;
    default:
      return false;
  }
}

bool AXObject::isDescendantOfLeafNode() const {
  updateCachedAttributeValuesIfNeeded();
  return m_cachedIsDescendantOfLeafNode;
}

bool AXLayoutObject::supportsARIADragging() const {
const AtomicString& grabbed = getAttribute(aria_grabbedAttr);
  return equalIgnoringCase(grabbed, "true") ||
         equalIgnoringCase(grabbed, "false");
}

void AXObject::clearChildren() {
  for (const auto& child : m_children)
    child->detachFromParent();

  m_children.clear();
  m_haveChildren = false;
}

bool AXObject::includesARIAWidgetRole(const String& role) {
  static const HashSet<String, CaseFoldingHash>* roleSet =
      createARIARoleWidgetSet();

  Vector<String> roleVector;
  role.split(' ', roleVector);
  for (const auto& child : roleVector) {
    if (roleSet->contains(child))
      return true;
  }
  return false;
}

AXARIAGridCell* AXARIAGridCell::create(LayoutObject* layoutObject,
                                       AXObjectCacheImpl& axObjectCache) {
  return new AXARIAGridCell(layoutObject, axObjectCache);
}

LayoutRect AXObject::getBoundsInFrameCoordinates() const {
  AXObject* container = nullptr;
  FloatRect bounds;
  SkMatrix44 transform;
  getRelativeBounds(&container, bounds, transform);
  FloatRect computedBounds(0, 0, bounds.width(), bounds.height());
  while (container && container != this) {
    computedBounds.move(bounds.x(), bounds.y());
    if (!container->isWebArea()) {
      computedBounds.move(-container->getScrollOffset().x(),
                          -container->getScrollOffset().y());
    }
    if (!transform.isIdentity()) {
      TransformationMatrix transformationMatrix(transform);
      transformationMatrix.mapRect(computedBounds);
    }
    container->getRelativeBounds(&container, bounds, transform);
  }
  return LayoutRect(computedBounds);
}

FrameView* AXObject::documentFrameView() const {
  const AXObject* object = this;
  while (object && !object->isAXLayoutObject())
    object = object->parentObject();

  if (!object)
    return 0;

  return object->documentFrameView();
}

bool AXNodeObject::isNativeSlider() const {
  Node* node = this->getNode();
  if (!node)
    return false;

  if (!isHTMLInputElement(node))
    return false;

  return toHTMLInputElement(node)->type() == InputTypeNames::range;
}

bool AXListBoxOption::computeAccessibilityIsIgnored(
    IgnoredReasons* ignoredReasons) const {
  if (!getNode())
    return true;

  if (accessibilityIsIgnoredByDefault(ignoredReasons))
    return true;

  return false;
}

float AXLayoutObject::fontSize() const {
  if (!getLayoutObject())
    return AXNodeObject::fontSize();

  const ComputedStyle* style = getLayoutObject()->style();
  if (!style)
    return AXNodeObject::fontSize();

  return style->computedFontSize();
}

void AXObject::updateCachedAttributeValuesIfNeeded() const {
  if (isDetached())
    return;

  AXObjectCacheImpl& cache = axObjectCache();

  if (cache.modificationCount() == m_lastModificationCount)
    return;

  m_lastModificationCount = cache.modificationCount();
  m_cachedBackgroundColor = computeBackgroundColor();
  m_cachedIsInertOrAriaHidden = computeIsInertOrAriaHidden();
  m_cachedIsDescendantOfLeafNode = (leafNodeAncestor() != 0);
  m_cachedIsDescendantOfDisabledNode = (disabledAncestor() != 0);
  m_cachedHasInheritedPresentationalRole =
      (inheritsPresentationalRoleFrom() != 0);
  m_cachedIsPresentationalChild =
      (ancestorForWhichThisIsAPresentationalChild() != 0);
  m_cachedIsIgnored = computeAccessibilityIsIgnored();
  m_cachedLiveRegionRoot =
      isLiveRegion()
          ? const_cast<AXObject*>(this)
          : (parentObjectIfExists() ? parentObjectIfExists()->liveRegionRoot()
                                    : 0);
  m_cachedAncestorExposesActiveDescendant =
      computeAncestorExposesActiveDescendant();
}

bool AXNodeObject::isAnchor() const {
  return !isNativeImage() && isLink();
}

void AXObjectCacheImpl::listboxActiveIndexChanged(HTMLSelectElement* select) {
  AXObject* obj = get(select);
  if (!obj || !obj->isAXListBox())
    return;

  toAXListBox(obj)->activeIndexChanged();
}

AXLayoutObject* AXLayoutObject::create(LayoutObject* layoutObject,
                                       AXObjectCacheImpl& axObjectCache) {
  return new AXLayoutObject(layoutObject, axObjectCache);
}

RGBA32 AXLayoutObject::computeBackgroundColor() const {
  if (!getLayoutObject())
    return AXNodeObject::backgroundColor();

  Color blendedColor = Color::transparent;
  for (LayoutObject* layoutObject = getLayoutObject(); layoutObject;
       layoutObject = layoutObject->parent()) {
    const AXObject* axParent = axObjectCache().getOrCreate(layoutObject);
    if (axParent && axParent != this) {
      Color parentColor = axParent->backgroundColor();
      blendedColor = parentColor.blend(blendedColor);
      return blendedColor.rgb();
    }

    const ComputedStyle* style = layoutObject->style();
    if (!style || !style->hasBackground())
      continue;

    Color currentColor =
        style->visitedDependentColor(CSSPropertyBackgroundColor);
    blendedColor = currentColor.blend(blendedColor);
    if (!blendedColor.hasAlpha())
      break;
  }

  if (blendedColor.hasAlpha()) {
    FrameView* view = documentFrameView();
    if (view) {
      Color documentBaseColor = view->baseBackgroundColor();
      blendedColor = documentBaseColor.blend(blendedColor);
    } else {
      blendedColor.blendWithWhite();
    }
  }

  return blendedColor.rgb();
}

  StringAttributeSetter(AXStringAttribute attribute) : m_attribute(attribute) {}

void AXNodeObject::decrement() {
  UserGestureIndicator gestureIndicator(DocumentUserGestureToken::create(
      getDocument(), UserGestureToken::NewGesture));
  alterSliderValue(false);
}

void AXObjectCacheImpl::notificationPostTimerFired(TimerBase*) {
  m_notificationPostTimer.stop();

  unsigned i = 0, count = m_notificationsToPost.size();
  for (i = 0; i < count; ++i) {
    AXObject* obj = m_notificationsToPost[i].first;

    if (!obj->axObjectID())
      continue;

    if (obj->isDetached())
      continue;

#if DCHECK_IS_ON()
    if (obj->isAXLayoutObject()) {
      AXLayoutObject* layoutObj = toAXLayoutObject(obj);
      LayoutObject* layoutObject = layoutObj->getLayoutObject();
      if (layoutObject && layoutObject->view())
        DCHECK(!layoutObject->view()->layoutState());
    }
#endif

    AXNotification notification = m_notificationsToPost[i].second;
    postPlatformNotification(obj, notification);

    if (notification == AXChildrenChanged && obj->parentObjectIfExists() &&
        obj->lastKnownIsIgnoredValue() != obj->accessibilityIsIgnored())
      childrenChanged(obj->parentObject());
  }

  m_notificationsToPost.clear();
}

RGBA32 AXLayoutObject::color() const {
  if (!getLayoutObject() || isColorWell())
    return AXNodeObject::color();

  const ComputedStyle* style = getLayoutObject()->style();
  if (!style)
    return AXNodeObject::color();

  Color color = style->visitedDependentColor(CSSPropertyColor);
  return color.rgb();
}

bool AXNodeObject::nameFromLabelElement() const {

  if (!getNode() && !getLayoutObject())
    return false;

  if (isHiddenForTextAlternativeCalculation())
    return false;

  HeapVector<Member<Element>> elements;
  ariaLabelledbyElementVector(elements);
  if (elements.size() > 0)
    return false;

  const AtomicString& ariaLabel =
      getAOMPropertyOrARIAAttribute(AOMStringProperty::kLabel);
  if (!ariaLabel.isEmpty())
    return false;

  HTMLElement* htmlElement = nullptr;
  if (getNode()->isHTMLElement())
    htmlElement = toHTMLElement(getNode());
  if (htmlElement && isLabelableElement(htmlElement)) {
    if (toLabelableElement(htmlElement)->labels() &&
        toLabelableElement(htmlElement)->labels()->length() > 0)
      return true;
  }

  return false;
}

const AtomicString& AXLayoutObject::liveRegionStatus() const {
  DEFINE_STATIC_LOCAL(const AtomicString, liveRegionStatusAssertive,
                      ("assertive"));
  DEFINE_STATIC_LOCAL(const AtomicString, liveRegionStatusPolite, ("polite"));
  DEFINE_STATIC_LOCAL(const AtomicString, liveRegionStatusOff, ("off"));

  const AtomicString& liveRegionStatus =
      getAOMPropertyOrARIAAttribute(AOMStringProperty::kLive);
  if (liveRegionStatus.isEmpty()) {
    switch (roleValue()) {
      case AlertDialogRole:
      case AlertRole:
        return liveRegionStatusAssertive;
      case LogRole:
      case StatusRole:
        return liveRegionStatusPolite;
      case TimerRole:
      case MarqueeRole:
        return liveRegionStatusOff;
      default:
        break;
    }
  }

  return liveRegionStatus;
}

void AXNodeObject::increment() {
  UserGestureIndicator gestureIndicator(DocumentUserGestureToken::create(
      getDocument(), UserGestureToken::NewGesture));
  alterSliderValue(true);
}

IntPoint AXObject::maximumScrollOffset() const {
  ScrollableArea* area = getScrollableAreaIfScrollable();
  if (!area)
    return IntPoint();

  return IntPoint(area->maximumScrollOffsetInt().width(),
                  area->maximumScrollOffsetInt().height());
}

void AXObject::elementsFromAttribute(HeapVector<Member<Element>>& elements,
                                     const QualifiedName& attribute) const {
  Vector<String> ids;
  tokenVectorFromAttribute(ids, attribute);
  if (ids.isEmpty())
    return;

  TreeScope& scope = getNode()->treeScope();
  for (const auto& id : ids) {
    if (Element* idElement = scope.getElementById(AtomicString(id)))
      elements.push_back(idElement);
  }
}

String AXObject::name(AXNameFrom& nameFrom,
                      AXObject::AXObjectVector* nameObjects) const {
  HeapHashSet<Member<const AXObject>> visited;
  AXRelatedObjectVector relatedObjects;
  String text = textAlternative(false, false, visited, nameFrom,
                                &relatedObjects, nullptr);

  AccessibilityRole role = roleValue();
  if (!getNode() || (!isHTMLBRElement(getNode()) && role != StaticTextRole &&
                     role != InlineTextBoxRole))
    text = collapseWhitespace(text);

  if (nameObjects) {
    nameObjects->clear();
    for (size_t i = 0; i < relatedObjects.size(); i++)
      nameObjects->push_back(relatedObjects[i]->object);
  }

  return text;
}

bool AXObject::accessibilityIsIgnoredByDefault(
    IgnoredReasons* ignoredReasons) const {
  return defaultObjectInclusion(ignoredReasons) == IgnoreObject;
}

AXObject* AXObject::elementAccessibilityHitTest(const IntPoint& point) const {
  for (const auto& child : m_children) {
    if (child->isMockObject() &&
        child->getBoundsInFrameCoordinates().contains(point))
      return child->elementAccessibilityHitTest(point);
  }

  return const_cast<AXObject*>(this);
}

bool AXNodeObject::isChecked() const {
Node* node = this->getNode();
if (!node)
return false;

// First test for native checkedness semantics
if (isHTMLInputElement(*node))
return toHTMLInputElement(*node).shouldAppearChecked();

// Else, if this is an ARIA role checkbox or radio or menuitemcheckbox
// or menuitemradio or switch, respect the aria-checked attribute
switch (ariaRoleAttribute()) {
case CheckBoxRole:
case MenuItemCheckBoxRole:
case MenuItemRadioRole:
case RadioButtonRole:
case SwitchRole:
      if (equalIgnoringCase(
getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked),
"true"))
return true;
return false;
default:
break;
}

// Otherwise it's not checked
return false;
}

bool AXNodeObject::isClickable() const {
  if (getNode()) {
    if (getNode()->isElementNode() &&
        toElement(getNode())->isDisabledFormControl())
      return false;

    if (getNode()->hasEventListeners(EventTypeNames::mouseup) ||
        getNode()->hasEventListeners(EventTypeNames::mousedown) ||
        getNode()->hasEventListeners(EventTypeNames::click) ||
        getNode()->hasEventListeners(EventTypeNames::DOMActivate))
      return true;
  }

  return AXObject::isClickable();
}

static bool isListElement(Node* node) {
  return isHTMLUListElement(*node) || isHTMLOListElement(*node) ||
         isHTMLDListElement(*node);
}

void AXObjectCacheImpl::handleLayoutComplete(Document* document) {
  postNotification(getOrCreate(document), AXObjectCache::AXLayoutComplete);
}

static inline LayoutInline* startOfContinuations(LayoutObject* r) {
  if (r->isInlineElementContinuation()) {
    return toLayoutInline(r->node()->layoutObject());
  }

  if (r->isLayoutBlockFlow() &&
      toLayoutBlockFlow(r)->inlineElementContinuation())
    return toLayoutInline(toLayoutBlockFlow(r)
                              ->inlineElementContinuation()
                              ->node()
                              ->layoutObject());

  return 0;
}

AXObject* AXObjectCacheImpl::get(Node* node) {
  if (!node)
    return 0;

  LayoutObject* layoutObject = node->layoutObject();
  if (isMenuListOption(node) || isHTMLAreaElement(node))
    layoutObject = nullptr;

  AXID layoutID = layoutObject ? m_layoutObjectMapping.at(layoutObject) : 0;
  DCHECK(!HashTraits<AXID>::isDeletedValue(layoutID));

  AXID nodeID = m_nodeObjectMapping.at(node);
  DCHECK(!HashTraits<AXID>::isDeletedValue(nodeID));

  if (layoutObject && nodeID && !layoutID) {
    remove(nodeID);
    return 0;
  }

  if (layoutID)
    return m_objects.at(layoutID);

  if (!nodeID)
    return 0;

  return m_objects.at(nodeID);
}

void AXARIAGridCell::columnIndexRange(
    std::pair<unsigned, unsigned>& columnRange) {
  AXObject* parent = parentObjectUnignored();
  if (!parent)
    return;

  if (!parent->isTableRow() && !parent->isAXTable())
    return;

  const auto& siblings = parent->children();
  unsigned childrenSize = siblings.size();
  for (unsigned k = 0; k < childrenSize; ++k) {
    if (siblings[k].get() == this) {
      columnRange.first = k;
      break;
    }
  }

  columnRange.second = 1;
}

AccessibilityTextDirection AXLayoutObject::textDirection() const {
  if (!getLayoutObject())
    return AXNodeObject::textDirection();

  const ComputedStyle* style = getLayoutObject()->style();
  if (!style)
    return AXNodeObject::textDirection();

  if (style->isHorizontalWritingMode()) {
    switch (style->direction()) {
      case TextDirection::kLtr:
        return AccessibilityTextDirectionLTR;
      case TextDirection::kRtl:
        return AccessibilityTextDirectionRTL;
    }
  } else {
    switch (style->direction()) {
      case TextDirection::kLtr:
        return AccessibilityTextDirectionTTB;
      case TextDirection::kRtl:
        return AccessibilityTextDirectionBTT;
    }
  }

  return AXNodeObject::textDirection();
}

DEFINE_TRACE(AXObjectCacheImpl) {
  visitor->trace(m_document);
  visitor->trace(m_nodeObjectMapping);

  visitor->trace(m_objects);
  visitor->trace(m_notificationsToPost);

  AXObjectCache::trace(visitor);
}

AXObject* AXObjectCacheImpl::getAriaOwnedParent(const AXObject* child) const {
  return objectFromAXID(m_ariaOwnedChildToOwnerMapping.at(child->axObjectID()));
}

AXObject* AXObjectCacheImpl::focusedObject() {
  if (!accessibilityEnabled())
    return nullptr;

  Node* focusedNode = m_document->focusedElement();
  if (!focusedNode)
    focusedNode = m_document;

  if (isHTMLAreaElement(focusedNode))
    return focusedImageMapUIElement(toHTMLAreaElement(focusedNode));

  Element* adjustedFocusedElement = m_document->adjustedFocusedElement();
  if (isHTMLInputElement(adjustedFocusedElement)) {
    if (AXObject* axPopup =
            toHTMLInputElement(adjustedFocusedElement)->popupRootAXObject()) {
      if (Element* focusedElementInPopup =
              axPopup->getDocument()->focusedElement())
        focusedNode = focusedElementInPopup;
    }
  }

  AXObject* obj = getOrCreate(focusedNode);
  if (!obj)
    return nullptr;

  if (obj->accessibilityIsIgnored())
    obj = obj->parentObjectUnignored();

  return obj;
}

void AXLayoutObject::addInlineTextBoxChildren(bool force) {
  Settings* settings = getDocument()->settings();
  if (!force &&
      (!settings || !settings->getInlineTextBoxAccessibilityEnabled()))
    return;

  if (!getLayoutObject() || !getLayoutObject()->isText())
    return;

  if (getLayoutObject()->needsLayout()) {
    return;
  }

  LayoutText* layoutText = toLayoutText(getLayoutObject());
  for (RefPtr<AbstractInlineTextBox> box =
           layoutText->firstAbstractInlineTextBox();
       box.get(); box = box->nextInlineTextBox()) {
    AXObject* axObject = axObjectCache().getOrCreate(box.get());
    if (!axObject->accessibilityIsIgnored())
      m_children.push_back(axObject);
  }
}

bool AXNodeObject::isReadOnly() const {
  Node* node = this->getNode();
  if (!node)
    return true;

  if (isHTMLTextAreaElement(*node))
    return toHTMLTextAreaElement(*node).isReadOnly();

  if (isHTMLInputElement(*node)) {
    HTMLInputElement& input = toHTMLInputElement(*node);
    if (input.isTextField())
      return input.isReadOnly();
  }

  return !hasEditableStyle(*node);
}

const AtomicString& AXObject::getAOMPropertyOrARIAAttribute(
    AOMStringProperty property) const {
  Node* node = this->getNode();
  if (!node || !node->isElementNode())
    return nullAtom;

  return AccessibleNode::getProperty(toElement(node), property);
}

void AXObjectCacheImpl::childrenChanged(AXObject* obj) {
  if (!obj)
    return;

  obj->childrenChanged();
}

bool AXLayoutObject::isTabItemSelected() const {
  if (!isTabItem() || !getLayoutObject())
    return false;

  Node* node = getNode();
  if (!node || !node->isElementNode())
    return false;

  AXObject* focusedElement = axObjectCache().focusedObject();
  if (!focusedElement)
    return false;

  HeapVector<Member<Element>> elements;
  elementsFromAttribute(elements, aria_controlsAttr);

  for (const auto& element : elements) {
    AXObject* tabPanel = axObjectCache().getOrCreate(element);

    if (!tabPanel || tabPanel->roleValue() != TabPanelRole)
      continue;

    AXObject* checkFocusElement = focusedElement;
    while (checkFocusElement) {
      if (tabPanel == checkFocusElement)
        return true;
      checkFocusElement = checkFocusElement->parentObject();
    }
  }

  return false;
}

bool roleAllowsReadonly(AccessibilityRole role) {
  return role == GridRole || role == CellRole || role == TextFieldRole ||
         role == ColumnHeaderRole || role == RowHeaderRole ||
         role == TreeGridRole;
}

AXObject::AXRange AXLayoutObject::selectionUnderObject() const {
  AXRange textSelection = textControlSelection();
  if (textSelection.isValid())
    return textSelection;

  if (!getNode() || !getLayoutObject()->frame())
    return AXRange();

  VisibleSelection selection =
      getLayoutObject()
          ->frame()
          ->selection()
          .computeVisibleSelectionInDOMTreeDeprecated();
  Range* selectionRange = createRange(firstEphemeralRangeOf(selection));
  ContainerNode* parentNode = getNode()->parentNode();
  int nodeIndex = getNode()->nodeIndex();
  if (!selectionRange
      ||
      !(parentNode &&
        selectionRange->comparePoint(parentNode, nodeIndex,
                                     IGNORE_EXCEPTION_FOR_TESTING) < 0 &&
        selectionRange->comparePoint(parentNode, nodeIndex + 1,
                                     IGNORE_EXCEPTION_FOR_TESTING) > 0)) {
    return AXRange();
  }

  int start = indexForVisiblePosition(selection.visibleStart());
  ASSERT(start >= 0);
  int end = indexForVisiblePosition(selection.visibleEnd());
  ASSERT(end >= 0);

  return AXRange(start, end);
}

bool AXNodeObject::computeAccessibilityIsIgnored(
IgnoredReasons* ignoredReasons) const {
#if DCHECK_IS_ON()
// Double-check that an AXObject is never accessed before
// it's been initialized.
ASSERT(m_initialized);
#endif

// If this element is within a parent that cannot have children, it should not
// be exposed.
if (isDescendantOfLeafNode()) {
if (ignoredReasons)
ignoredReasons->push_back(
IgnoredReason(AXAncestorIsLeafNode, leafNodeAncestor()));
return true;
}

// Ignore labels that are already referenced by a control.
AXObject* controlObject = correspondingControlForLabelElement();
if (controlObject && controlObject->isCheckboxOrRadio() &&
controlObject->nameFromLabelElement()) {
if (ignoredReasons) {
HTMLLabelElement* label = labelElementContainer();
if (label && label != getNode()) {
AXObject* labelAXObject = axObjectCache().getOrCreate(label);
ignoredReasons->push_back(
IgnoredReason(AXLabelContainer, labelAXObject));
}

ignoredReasons->push_back(IgnoredReason(AXLabelFor, controlObject));
}
return true;
}

Element* element = getNode()->isElementNode() ? toElement(getNode())
: getNode()->parentElement();
if (!getLayoutObject() && (!element || !element->isInCanvasSubtree()) &&
      !equalIgnoringCase(getAttribute(aria_hiddenAttr), "false")) {
if (ignoredReasons)
ignoredReasons->push_back(IgnoredReason(AXNotRendered));
return true;
}

if (m_role == UnknownRole) {
if (ignoredReasons)
ignoredReasons->push_back(IgnoredReason(AXUninteresting));
return true;
}
return false;
}

float AXNodeObject::stepValueForRange() const {
  if (!isNativeSlider())
    return 0.0;

  Decimal step =
      toHTMLInputElement(*getNode()).createStepRange(RejectAny).step();
  return step.toString().toFloat();
}

bool AXNodeObject::hasContentEditableAttributeSet() const {
const AtomicString& contentEditableValue = getAttribute(contenteditableAttr);
if (contentEditableValue.isNull())
return false;
// Both "true" (case-insensitive) and the empty string count as true.
return contentEditableValue.isEmpty() ||
         equalIgnoringCase(contentEditableValue, "true");
}

void AXObjectCacheImpl::handleLayoutComplete(LayoutObject* layoutObject) {
  if (!layoutObject)
    return;

  m_modificationCount++;

  if (AXObject* obj = getOrCreate(layoutObject))
    postNotification(obj, AXLayoutComplete);
}

AXARIAGridCell::~AXARIAGridCell() {}

void AXNodeObject::alterSliderValue(bool increase) {
  if (roleValue() != SliderRole)
    return;

  float value = valueForRange();
  float step = stepValueForRange();

  value += increase ? step : -step;

  setValue(String::number(value));
  axObjectCache().postNotification(getNode(),
                                   AXObjectCacheImpl::AXValueChanged);
}

bool AXObject::isClickable() const {
  switch (roleValue()) {
    case ButtonRole:
    case CheckBoxRole:
    case ColorWellRole:
    case ComboBoxRole:
    case ImageMapLinkRole:
    case LinkRole:
    case ListBoxOptionRole:
    case MenuButtonRole:
    case PopUpButtonRole:
    case RadioButtonRole:
    case SpinButtonRole:
    case TabRole:
    case TextFieldRole:
    case ToggleButtonRole:
      return true;
    default:
      return false;
  }
}

Element* AXNodeObject::menuItemElementForMenu() const {
  if (ariaRoleAttribute() != MenuRole)
    return 0;

  return siblingWithAriaRole("menuitem", getNode());
}

bool AXListBoxOption::isSelected() const {
  return isHTMLOptionElement(getNode()) &&
         toHTMLOptionElement(getNode())->selected();
}

void AXARIAGridCell::rowIndexRange(std::pair<unsigned, unsigned>& rowRange) {
  AXObject* parent = parentObjectUnignored();
  if (!parent)
    return;

  if (parent->isTableRow()) {
    rowRange.first = toAXTableRow(parent)->rowIndex();
  } else if (parent->isAXTable()) {
    unsigned columnCount = toAXTable(parent)->columnCount();
    if (!columnCount)
      return;

    const auto& siblings = parent->children();
    unsigned childrenSize = siblings.size();
    for (unsigned k = 0; k < childrenSize; ++k) {
      if (siblings[k].get() == this) {
        rowRange.first = k / columnCount;
        break;
      }
    }
  }

  rowRange.second = 1;
}

AXObject* AXObjectCacheImpl::getOrCreate(AccessibilityRole role) {
  AXObject* obj = nullptr;

  switch (role) {
    case ColumnRole:
      obj = AXTableColumn::create(*this);
      break;
    case TableHeaderContainerRole:
      obj = AXTableHeaderContainer::create(*this);
      break;
    case SliderThumbRole:
      obj = AXSliderThumb::create(*this);
      break;
    case MenuListPopupRole:
      obj = AXMenuListPopup::create(*this);
      break;
    case SpinButtonRole:
      obj = AXSpinButton::create(*this);
      break;
    case SpinButtonPartRole:
      obj = AXSpinButtonPart::create(*this);
      break;
    default:
      obj = nullptr;
  }

  if (!obj)
    return 0;

  getOrCreateAXID(obj);

  obj->init();
  return obj;
}

bool AXNodeObject::canSetValueAttribute() const {
  if (equalIgnoringCase(getAttribute(aria_readonlyAttr), "true"))
return false;

if (isProgressIndicator() || isSlider())
return true;

if (isTextControl() && !isNativeTextControl())
return true;

// Any node could be contenteditable, so isReadOnly should be relied upon
// for this information for all elements.
return !isReadOnly();
}

bool nodeHasRole(Node* node, const String& role) {
if (!node || !node->isElementNode())
return false;

  return equalIgnoringCase(toElement(node)->getAttribute(roleAttr), role);
}

void AXNodeObject::selectionChanged() {
  if (isFocused() || isWebArea()) {
    axObjectCache().postNotification(this,
                                     AXObjectCacheImpl::AXSelectedTextChanged);
    if (getDocument()) {
      AXObject* documentObject = axObjectCache().getOrCreate(getDocument());
      axObjectCache().postNotification(
          documentObject, AXObjectCacheImpl::AXDocumentSelectionChanged);
    }
  } else {
    AXObject::selectionChanged();  // Calls selectionChanged on parent.
  }
}

bool AXNodeObject::canvasHasFallbackContent() const {
  Node* node = this->getNode();
  if (!isHTMLCanvasElement(node))
    return false;

  return ElementTraversal::firstChild(*node);
}

int AXObject::indexInParent() const {
  if (!parentObject())
    return 0;

  const auto& siblings = parentObject()->children();
  int childCount = siblings.size();

  for (int index = 0; index < childCount; ++index) {
    if (siblings[index].get() == this) {
      return index;
    }
  }
  return 0;
}

bool AXObjectCacheImpl::isAriaOwned(const AXObject* child) const {
  return m_ariaOwnedChildToOwnerMapping.contains(child->axObjectID());
}

AXObjectInclusion AXLayoutObject::defaultObjectInclusion(
IgnoredReasons* ignoredReasons) const {
// The following cases can apply to any element that's a subclass of
// AXLayoutObject.

if (!m_layoutObject) {
if (ignoredReasons)
ignoredReasons->push_back(IgnoredReason(AXNotRendered));
return IgnoreObject;
}

if (m_layoutObject->style()->visibility() != EVisibility::kVisible) {
// aria-hidden is meant to override visibility as the determinant in AX
// hierarchy inclusion.
    if (equalIgnoringCase(getAttribute(aria_hiddenAttr), "false"))
return DefaultBehavior;

if (ignoredReasons)
ignoredReasons->push_back(IgnoredReason(AXNotVisible));
return IgnoreObject;
}

return AXObject::defaultObjectInclusion(ignoredReasons);
}

String AXObject::name(NameSources* nameSources) const {
  AXObjectSet visited;
  AXNameFrom tmpNameFrom;
  AXRelatedObjectVector tmpRelatedObjects;
  String text = textAlternative(false, false, visited, tmpNameFrom,
                                &tmpRelatedObjects, nameSources);
  text = text.simplifyWhiteSpace(isHTMLSpace<UChar>);
  return text;
}

void AXTableCell::rowIndexRange(std::pair<unsigned, unsigned>& rowRange) {
  if (!m_layoutObject || !m_layoutObject->isTableCell())
    return;

  LayoutTableCell* layoutCell = toLayoutTableCell(m_layoutObject);
  rowRange.first = layoutCell->rowIndex();
  rowRange.second = layoutCell->rowSpan();

  LayoutTableSection* section = layoutCell->section();
  LayoutTable* table = layoutCell->table();
  if (!table || !section)
    return;

  LayoutTableSection* tableSection = table->topSection();
  unsigned rowOffset = 0;
  while (tableSection) {
    if (tableSection == section)
      break;
    rowOffset += tableSection->numRows();
    tableSection = table->sectionBelow(tableSection, SkipEmptySections);
  }

  rowRange.first += rowOffset;
}

bool AXObject::supportsSetSizeAndPosInSet() const {
  AXObject* parent = parentObject();
  if (!parent)
    return false;

  int role = roleValue();
  int parentRole = parent->roleValue();

  if ((role == ListBoxOptionRole && parentRole == ListBoxRole) ||
      (role == ListItemRole && parentRole == ListRole) ||
      (role == MenuItemRole && parentRole == MenuRole) ||
      (role == RadioButtonRole) ||
      (role == TabRole && parentRole == TabListRole) ||
      (role == TreeItemRole && parentRole == TreeRole) ||
      (role == TreeItemRole && parentRole == GroupRole)) {
    return true;
  }

  return false;
}

void AXObjectCacheImpl::textChanged(Node* node) {
  textChanged(getOrCreate(node));
}

bool AXObjectCacheImpl::nodeIsTextControl(const Node* node) {
  if (!node)
    return false;

  const AXObject* axObject = getOrCreate(const_cast<Node*>(node));
  return axObject && axObject->isTextControl();
}

bool AXObject::isARIAInput(AccessibilityRole ariaRole) {
  return ariaRole == RadioButtonRole || ariaRole == CheckBoxRole ||
         ariaRole == TextFieldRole || ariaRole == SwitchRole ||
         ariaRole == SearchBoxRole;
}

bool AXNodeObject::isSlider() const {
  return roleValue() == SliderRole;
}

DEFINE_TRACE(InspectorAccessibilityAgent) {
  visitor->trace(m_page);
  visitor->trace(m_domAgent);
  InspectorBaseAgent::trace(visitor);
}

bool AXNodeObject::isNativeImage() const {
  Node* node = this->getNode();
  if (!node)
    return false;

  if (isHTMLImageElement(*node))
    return true;

  if (isHTMLPlugInElement(*node))
    return true;

  if (isHTMLInputElement(*node))
    return toHTMLInputElement(*node).type() == InputTypeNames::image;

  return false;
}

SortDirection AXTableCell::getSortDirection() const {
if (roleValue() != RowHeaderRole && roleValue() != ColumnHeaderRole)
return SortDirectionUndefined;

const AtomicString& ariaSort =
getAOMPropertyOrARIAAttribute(AOMStringProperty::kSort);
if (ariaSort.isEmpty())
return SortDirectionUndefined;
  if (equalIgnoringCase(ariaSort, "none"))
return SortDirectionNone;
  if (equalIgnoringCase(ariaSort, "ascending"))
return SortDirectionAscending;
  if (equalIgnoringCase(ariaSort, "descending"))
return SortDirectionDescending;
  if (equalIgnoringCase(ariaSort, "other"))
return SortDirectionOther;
return SortDirectionUndefined;
}

AccessibilityRole AXNodeObject::nativeAccessibilityRoleIgnoringAria() const {
  if (!getNode())
    return UnknownRole;

  if (getNode()->isLink())
    return LinkRole;

  if (isHTMLAnchorElement(*getNode())) {
    if (isClickable())
      return LinkRole;
    return AnchorRole;
  }

  if (isHTMLButtonElement(*getNode()))
    return buttonRoleType();

  if (isHTMLDetailsElement(*getNode()))
    return DetailsRole;

  if (isHTMLSummaryElement(*getNode())) {
    ContainerNode* parent = FlatTreeTraversal::parent(*getNode());
    if (parent && isHTMLDetailsElement(parent))
      return DisclosureTriangleRole;
    return UnknownRole;
  }

  if (isHTMLInputElement(*getNode())) {
    HTMLInputElement& input = toHTMLInputElement(*getNode());
    const AtomicString& type = input.type();
    if (input.dataList())
      return ComboBoxRole;
    if (type == InputTypeNames::button) {
      if ((getNode()->parentNode() &&
           isHTMLMenuElement(getNode()->parentNode())) ||
          (parentObject() && parentObject()->roleValue() == MenuRole))
        return MenuItemRole;
      return buttonRoleType();
    }
    if (type == InputTypeNames::checkbox) {
      if ((getNode()->parentNode() &&
           isHTMLMenuElement(getNode()->parentNode())) ||
          (parentObject() && parentObject()->roleValue() == MenuRole))
        return MenuItemCheckBoxRole;
      return CheckBoxRole;
    }
    if (type == InputTypeNames::date)
      return DateRole;
    if (type == InputTypeNames::datetime ||
        type == InputTypeNames::datetime_local ||
        type == InputTypeNames::month || type == InputTypeNames::week)
      return DateTimeRole;
    if (type == InputTypeNames::file)
      return ButtonRole;
    if (type == InputTypeNames::radio) {
      if ((getNode()->parentNode() &&
           isHTMLMenuElement(getNode()->parentNode())) ||
          (parentObject() && parentObject()->roleValue() == MenuRole))
        return MenuItemRadioRole;
      return RadioButtonRole;
    }
    if (type == InputTypeNames::number)
      return SpinButtonRole;
    if (input.isTextButton())
      return buttonRoleType();
    if (type == InputTypeNames::range)
      return SliderRole;
    if (type == InputTypeNames::color)
      return ColorWellRole;
    if (type == InputTypeNames::time)
      return InputTimeRole;
    return TextFieldRole;
  }

  if (isHTMLSelectElement(*getNode())) {
    HTMLSelectElement& selectElement = toHTMLSelectElement(*getNode());
    return selectElement.isMultiple() ? ListBoxRole : PopUpButtonRole;
  }

  if (isHTMLTextAreaElement(*getNode()))
    return TextFieldRole;

  if (headingLevel())
    return HeadingRole;

  if (isHTMLDivElement(*getNode()))
    return DivRole;

  if (isHTMLMeterElement(*getNode()))
    return MeterRole;

  if (isHTMLOutputElement(*getNode()))
    return StatusRole;

  if (isHTMLParagraphElement(*getNode()))
    return ParagraphRole;

  if (isHTMLLabelElement(*getNode()))
    return LabelRole;

  if (isHTMLLegendElement(*getNode()))
    return LegendRole;

  if (isHTMLRubyElement(*getNode()))
    return RubyRole;

  if (isHTMLDListElement(*getNode()))
    return DescriptionListRole;

  if (isHTMLAudioElement(*getNode()))
    return AudioRole;
  if (isHTMLVideoElement(*getNode()))
    return VideoRole;

  if (getNode()->hasTagName(ddTag))
    return DescriptionListDetailRole;

  if (getNode()->hasTagName(dtTag))
    return DescriptionListTermRole;

  if (getNode()->nodeName() == "math")
    return MathRole;

  if (getNode()->hasTagName(rpTag) || getNode()->hasTagName(rtTag))
    return AnnotationRole;

  if (isHTMLFormElement(*getNode()))
    return FormRole;

  if (getNode()->hasTagName(abbrTag))
    return AbbrRole;

  if (getNode()->hasTagName(articleTag))
    return ArticleRole;

  if (getNode()->hasTagName(mainTag))
    return MainRole;

  if (getNode()->hasTagName(markTag))
    return MarkRole;

  if (getNode()->hasTagName(navTag))
    return NavigationRole;

  if (getNode()->hasTagName(asideTag))
    return ComplementaryRole;

  if (getNode()->hasTagName(preTag))
    return PreRole;

  if (getNode()->hasTagName(sectionTag))
    return RegionRole;

  if (getNode()->hasTagName(addressTag))
    return ContentInfoRole;

  if (isHTMLDialogElement(*getNode()))
    return DialogRole;

  if (isHTMLHtmlElement(*getNode()))
    return IgnoredRole;

  if (isHTMLIFrameElement(*getNode())) {
    const AtomicString& ariaRole =
        getAOMPropertyOrARIAAttribute(AOMStringProperty::kRole);
    if (ariaRole == "none" || ariaRole == "presentation")
      return IframePresentationalRole;
    return IframeRole;
  }

  if (getNode()->hasTagName(headerTag)) {
    if (isDescendantOfElementType(getLandmarkRolesNotAllowed()))
      return GroupRole;
    return BannerRole;
  }

  if (getNode()->hasTagName(footerTag)) {
    if (isDescendantOfElementType(getLandmarkRolesNotAllowed()))
      return GroupRole;
    return FooterRole;
  }

  if (getNode()->hasTagName(blockquoteTag))
    return BlockquoteRole;

  if (getNode()->hasTagName(captionTag))
    return CaptionRole;

  if (getNode()->hasTagName(figcaptionTag))
    return FigcaptionRole;

  if (getNode()->hasTagName(figureTag))
    return FigureRole;

  if (getNode()->nodeName() == "TIME")
    return TimeRole;

  if (isEmbeddedObject())
    return EmbeddedObjectRole;

  if (isHTMLHRElement(*getNode()))
    return SplitterRole;

  if (isFieldset())
    return GroupRole;

  return UnknownRole;
}

std::unique_ptr<AXValue> createRoleNameValue(AccessibilityRole role) {
  AtomicString roleName = AXObject::roleName(role);
  std::unique_ptr<AXValue> roleNameValue;
  if (!roleName.isNull()) {
    roleNameValue = createValue(roleName, AXValueTypeEnum::Role);
  } else {
    roleNameValue = createValue(AXObject::internalRoleName(role),
                                AXValueTypeEnum::InternalRole);
  }
  return roleNameValue;
}

Response InspectorAccessibilityAgent::getPartialAXTree(
    int domNodeId,
    Maybe<bool> fetchRelatives,
    std::unique_ptr<protocol::Array<AXNode>>* nodes) {
  if (!m_domAgent->enabled())
    return Response::Error("DOM agent must be enabled");
  Node* domNode = nullptr;
  Response response = m_domAgent->assertNode(domNodeId, domNode);
  if (!response.isSuccess())
    return response;

  Document& document = domNode->document();
  document.updateStyleAndLayoutIgnorePendingStylesheets();
  DocumentLifecycle::DisallowTransitionScope disallowTransition(
      document.lifecycle());
  LocalFrame* localFrame = document.frame();
  if (!localFrame)
    return Response::Error("Frame is detached.");
  std::unique_ptr<ScopedAXObjectCache> scopedCache =
      ScopedAXObjectCache::create(document);
  AXObjectCacheImpl* cache = toAXObjectCacheImpl(scopedCache->get());

  AXObject* inspectedAXObject = cache->getOrCreate(domNode);
  *nodes = protocol::Array<protocol::Accessibility::AXNode>::create();
  if (!inspectedAXObject || inspectedAXObject->accessibilityIsIgnored()) {
    (*nodes)->addItem(buildObjectForIgnoredNode(domNode, inspectedAXObject,
                                                fetchRelatives.fromMaybe(true),
                                                *nodes, *cache));
    return Response::OK();
  } else {
    (*nodes)->addItem(
        buildProtocolAXObject(*inspectedAXObject, inspectedAXObject,
                              fetchRelatives.fromMaybe(true), *nodes, *cache));
  }

  if (!inspectedAXObject)
    return Response::OK();

  AXObject* parent = inspectedAXObject->parentObjectUnignored();
  if (!parent)
    return Response::OK();

  if (fetchRelatives.fromMaybe(true))
    addAncestors(*parent, inspectedAXObject, *nodes, *cache);

  return Response::OK();
}

void AXObject::setLastKnownIsIgnoredValue(bool isIgnored) {
  m_lastKnownIsIgnoredValue = isIgnored ? IgnoreObject : IncludeObject;
}

void AXObjectCacheImpl::listboxOptionStateChanged(HTMLOptionElement* option) {
  postNotification(option, AXCheckedStateChanged);
}

bool AXTableCell::isColumnHeaderCell() const {
const AtomicString& scope = getAttribute(scopeAttr);
  return equalIgnoringCase(scope, "col") ||
         equalIgnoringCase(scope, "colgroup");
}

void fillWidgetStates(AXObject& axObject,
protocol::Array<AXProperty>& properties) {
AccessibilityRole role = axObject.roleValue();
if (roleAllowsChecked(role)) {
AccessibilityButtonState checked = axObject.checkboxOrRadioValue();
switch (checked) {
case ButtonStateOff:
properties.addItem(
createProperty(AXWidgetStatesEnum::Checked,
createValue("false", AXValueTypeEnum::Tristate)));
break;
case ButtonStateOn:
properties.addItem(
createProperty(AXWidgetStatesEnum::Checked,
createValue("true", AXValueTypeEnum::Tristate)));
break;
case ButtonStateMixed:
properties.addItem(
createProperty(AXWidgetStatesEnum::Checked,
createValue("mixed", AXValueTypeEnum::Tristate)));
break;
}
}

AccessibilityExpanded expanded = axObject.isExpanded();
switch (expanded) {
case ExpandedUndefined:
break;
case ExpandedCollapsed:
properties.addItem(createProperty(
AXWidgetStatesEnum::Expanded,
createBooleanValue(false, AXValueTypeEnum::BooleanOrUndefined)));
break;
case ExpandedExpanded:
properties.addItem(createProperty(
AXWidgetStatesEnum::Expanded,
createBooleanValue(true, AXValueTypeEnum::BooleanOrUndefined)));
break;
}

if (role == ToggleButtonRole) {
if (!axObject.isPressed()) {
properties.addItem(
createProperty(AXWidgetStatesEnum::Pressed,
createValue("false", AXValueTypeEnum::Tristate)));
} else {
const AtomicString& pressedAttr =
axObject.getAttribute(HTMLNames::aria_pressedAttr);
      if (equalIgnoringCase(pressedAttr, "mixed"))
properties.addItem(
createProperty(AXWidgetStatesEnum::Pressed,
createValue("mixed", AXValueTypeEnum::Tristate)));
else
properties.addItem(
createProperty(AXWidgetStatesEnum::Pressed,
createValue("true", AXValueTypeEnum::Tristate)));
}
}

if (roleAllowsSelected(role)) {
properties.addItem(
createProperty(AXWidgetStatesEnum::Selected,
createBooleanValue(axObject.isSelected())));
}

if (roleAllowsModal(role)) {
properties.addItem(createProperty(AXWidgetStatesEnum::Modal,
createBooleanValue(axObject.isModal())));
}
}

AccessibilityRole AXNodeObject::determineAriaRoleAttribute() const {
  const AtomicString& ariaRole =
      getAOMPropertyOrARIAAttribute(AOMStringProperty::kRole);
  if (ariaRole.isNull() || ariaRole.isEmpty())
    return UnknownRole;

  AccessibilityRole role = ariaRoleToWebCoreRole(ariaRole);

  if ((role == NoneRole || role == PresentationalRole) &&
      canSetFocusAttribute())
    return UnknownRole;

  if (role == ButtonRole)
    role = buttonRoleType();

  role = remapAriaRoleDueToParent(role);

  if (role)
    return role;

  return UnknownRole;
}

bool AXObject::isDetached() const {
  return !m_axObjectCache;
}

AXObject* AXLayoutObject::treeAncestorDisallowingChild() const {
  AXObject* axObj = parentObject();
  AXObject* treeAncestor = 0;
  while (axObj) {
    if (axObj->isTree()) {
      treeAncestor = axObj;
      break;
    }
    axObj = axObj->parentObject();
  }

  if (treeAncestor) {
    AccessibilityRole role = roleValue();
    if (role != TreeItemRole && role != StaticTextRole)
      return treeAncestor;
  }
  return 0;
}

bool AXNodeObject::nameFromContents() const {
  Node* node = getNode();
  if (!node || !node->isElementNode())
    return AXObject::nameFromContents();
  if (isHTMLSelectElement(node))
    return false;
  return AXObject::nameFromContents();
}

static inline bool lastChildHasContinuation(LayoutObject* layoutObject) {
  LayoutObject* lastChild = layoutObject->slowLastChild();
  return lastChild && isInlineWithContinuation(lastChild);
}

Document* AXObject::getDocument() const {
  FrameView* frameView = documentFrameView();
  if (!frameView)
    return 0;

  return frameView->frame().document();
}

AXTableCell* AXTableCell::create(LayoutObject* layoutObject,
                                 AXObjectCacheImpl& axObjectCache) {
  return new AXTableCell(layoutObject, axObjectCache);
}

void AXLayoutObject::addChildren() {
  ASSERT(!isDetached());
  ASSERT(!m_haveChildren);

  m_haveChildren = true;

  if (!canHaveChildren())
    return;

  HeapVector<Member<AXObject>> ownedChildren;
  computeAriaOwnsChildren(ownedChildren);

  for (AXObject* obj = rawFirstChild(); obj; obj = obj->rawNextSibling()) {
    if (!axObjectCache().isAriaOwned(obj)) {
      obj->setParent(this);
      addChild(obj);
    }
  }

  addHiddenChildren();
  addPopupChildren();
  addImageMapChildren();
  addTextFieldChildren();
  addCanvasChildren();
  addRemoteSVGChildren();
  addInlineTextBoxChildren(false);

  for (const auto& child : m_children) {
    if (!child->cachedParentObject())
      child->setParent(this);
  }

  for (const auto& ownedChild : ownedChildren)
    addChild(ownedChild);
}

bool AXLayoutObject::isRichlyEditable() const {
  if (getNode() && hasRichlyEditableStyle(*getNode()))
    return true;

  if (isWebArea()) {
    Document& document = m_layoutObject->document();
    HTMLElement* body = document.body();
    if (body && hasRichlyEditableStyle(*body)) {
      AXObject* axBody = axObjectCache().getOrCreate(body);
      return axBody && axBody != axBody->ariaHiddenRoot();
    }

    return hasRichlyEditableStyle(document);
  }

  return AXNodeObject::isRichlyEditable();
}

VisiblePosition AXLayoutObject::visiblePositionForIndex(int index) const {
  if (!m_layoutObject)
    return VisiblePosition();

  if (m_layoutObject->isTextControl())
    return toLayoutTextControl(m_layoutObject)
        ->textControlElement()
        ->visiblePositionForIndex(index);

  Node* node = m_layoutObject->node();
  if (!node)
    return VisiblePosition();

  if (index <= 0)
    return createVisiblePosition(firstPositionInOrBeforeNode(node));

  Position start, end;
  bool selected = Range::selectNodeContents(node, start, end);
  if (!selected)
    return VisiblePosition();

  CharacterIterator it(start, end);
  it.advance(index - 1);
  return createVisiblePosition(Position(it.currentContainer(), it.endOffset()),
                               TextAffinity::Upstream);
}

bool AXLayoutObject::supportsARIAFlowTo() const {
  return !getAttribute(aria_flowtoAttr).isEmpty();
}

bool AXARIAGridCell::isAriaRowHeader() const {
const AtomicString& role = getAttribute(HTMLNames::roleAttr);
  return equalIgnoringCase(role, "rowheader");
}

void AXLayoutObject::addRemoteSVGChildren() {
  AXSVGRoot* root = remoteSVGRootElement();
  if (!root)
    return;

  root->setParent(this);

  if (root->accessibilityIsIgnored()) {
    for (const auto& child : root->children())
      m_children.push_back(child);
  } else {
    m_children.push_back(root);
  }
}

void AXObject::scrollToMakeVisible() const {
  IntRect objectRect = pixelSnappedIntRect(getBoundsInFrameCoordinates());
  objectRect.setLocation(IntPoint());
  scrollToMakeVisibleWithSubFocus(objectRect);
}

InspectorAccessibilityAgent::InspectorAccessibilityAgent(
    Page* page,
    InspectorDOMAgent* domAgent)
    : m_page(page), m_domAgent(domAgent) {}

AXObjectCacheImpl::~AXObjectCacheImpl() {
#if DCHECK_IS_ON()
  DCHECK(m_hasBeenDisposed);
#endif
}

RGBA32 AXNodeObject::colorValue() const {
if (!isHTMLInputElement(getNode()) || !isColorWell())
return AXObject::colorValue();

HTMLInputElement* input = toHTMLInputElement(getNode());
const AtomicString& type = input->getAttribute(typeAttr);
  if (!equalIgnoringCase(type, "color"))
return AXObject::colorValue();

// HTMLInputElement::value always returns a string parseable by Color.
Color color;
bool success = color.setFromString(input->value());
DCHECK(success);
return color.rgb();
}

bool AXTableCell::isTableHeaderCell() const {
  return getNode() && getNode()->hasTagName(thTag);
}

AXObject* AXObjectCacheImpl::focusedImageMapUIElement(
    HTMLAreaElement* areaElement) {
  if (!areaElement)
    return 0;

  HTMLImageElement* imageElement = areaElement->imageElement();
  if (!imageElement)
    return 0;

  AXObject* axLayoutImage = getOrCreate(imageElement);
  if (!axLayoutImage)
    return 0;

  const AXObject::AXObjectVector& imageChildren = axLayoutImage->children();
  unsigned count = imageChildren.size();
  for (unsigned k = 0; k < count; ++k) {
    AXObject* child = imageChildren[k];
    if (!child->isImageMapLink())
      continue;

    if (toAXImageMapLink(child)->areaElement() == areaElement)
      return child;
  }

  return 0;
}

void AXObject::scrollToMakeVisibleWithSubFocus(const IntRect& subfocus) const {
  const AXObject* scrollParent = parentObject() ? parentObject() : this;
  ScrollableArea* scrollableArea = 0;
  while (scrollParent) {
    scrollableArea = scrollParent->getScrollableAreaIfScrollable();
    if (scrollableArea)
      break;
    scrollParent = scrollParent->parentObject();
  }
  if (!scrollParent || !scrollableArea)
    return;

  IntRect objectRect = pixelSnappedIntRect(getBoundsInFrameCoordinates());
  IntSize scrollOffset = scrollableArea->scrollOffsetInt();
  IntRect scrollVisibleRect = scrollableArea->visibleContentRect();

  if (!scrollParent->isWebArea()) {
    objectRect.moveBy(IntPoint(scrollOffset));
    objectRect.moveBy(
        -pixelSnappedIntRect(scrollParent->getBoundsInFrameCoordinates())
             .location());
  }

  int desiredX = computeBestScrollOffset(
      scrollOffset.width(), objectRect.x() + subfocus.x(),
      objectRect.x() + subfocus.maxX(), objectRect.x(), objectRect.maxX(), 0,
      scrollVisibleRect.width());
  int desiredY = computeBestScrollOffset(
      scrollOffset.height(), objectRect.y() + subfocus.y(),
      objectRect.y() + subfocus.maxY(), objectRect.y(), objectRect.maxY(), 0,
      scrollVisibleRect.height());

  scrollParent->setScrollOffset(IntPoint(desiredX, desiredY));

  IntRect newSubfocus = subfocus;
  IntRect newElementRect = pixelSnappedIntRect(getBoundsInFrameCoordinates());
  IntRect scrollParentRect =
      pixelSnappedIntRect(scrollParent->getBoundsInFrameCoordinates());
  newSubfocus.move(newElementRect.x(), newElementRect.y());
  newSubfocus.move(-scrollParentRect.x(), -scrollParentRect.y());

  if (scrollParent->parentObject()) {
    scrollParent->scrollToMakeVisibleWithSubFocus(newSubfocus);
  } else {
    axObjectCache().postNotification(const_cast<AXObject*>(this),
                                     AXObjectCacheImpl::AXLocationChanged);
  }
}

bool AXObject::isButton() const {
  AccessibilityRole role = roleValue();

  return role == ButtonRole || role == PopUpButtonRole ||
         role == ToggleButtonRole;
}

void AXNodeObject::detach() {
  AXObject::detach();
  m_node = nullptr;
}

void AXObjectCacheImpl::remove(AXID axID) {
  if (!axID)
    return;

  AXObject* obj = m_objects.at(axID);
  if (!obj)
    return;

  obj->detach();
  removeAXID(obj);

  if (!m_objects.take(axID))
    return;

  DCHECK(m_objects.size() >= m_idsInUse.size());
}

AccessibilityRole AXLayoutObject::determineAccessibilityRole() {
  if (!m_layoutObject)
    return UnknownRole;

  if ((m_ariaRole = determineAriaRoleAttribute()) != UnknownRole)
    return m_ariaRole;

  AccessibilityRole role = nativeAccessibilityRoleIgnoringAria();
  if (role != UnknownRole)
    return role;

  if (m_layoutObject->isLayoutBlockFlow())
    return GroupRole;

  if (supportsARIAAttributes())
    return GroupRole;

  return UnknownRole;
}

  SparseAttributeAXPropertyAdapter(AXObject& axObject,
                                   protocol::Array<AXProperty>& properties)
      : m_axObject(&axObject), m_properties(properties) {}

AXObject* AXNodeObject::rawFirstChild() const {
  if (!getNode())
    return 0;

  Node* firstChild = getNode()->firstChild();

  if (!firstChild)
    return 0;

  return axObjectCache().getOrCreate(firstChild);
}

 bool AXNodeObject::isTextControl() const {
  if (hasContentEditableAttributeSet())
    return true;

  switch (roleValue()) {
    case TextFieldRole:
    case ComboBoxRole:
    case SearchBoxRole:
    case SpinButtonRole:
      return true;
    default:
      return false;
  }
}

AXObject* AXObjectCacheImpl::createFromNode(Node* node) {
  if (isMenuListOption(node))
    return AXMenuListOption::create(toHTMLOptionElement(node), *this);

  if (isHTMLAreaElement(node))
    return AXImageMapLink::create(toHTMLAreaElement(node), *this);

  return AXNodeObject::create(node, *this);
}

void AXObjectCacheImpl::dispose() {
  m_notificationPostTimer.stop();

  for (auto& entry : m_objects) {
    AXObject* obj = entry.value;
    obj->detach();
    removeAXID(obj);
  }

#if DCHECK_IS_ON()
  m_hasBeenDisposed = true;
#endif
}

AXObject* AXTableCell::parentTable() const {
  if (!m_layoutObject || !m_layoutObject->isTableCell())
    return 0;

  if (isDetached())
    return 0;

  return axObjectCache().get(toLayoutTableCell(m_layoutObject)->table());
}

static Vector<AtomicString>* createRoleNameVector() {
  Vector<AtomicString>* roleNameVector = new Vector<AtomicString>(NumRoles);
  for (int i = 0; i < NumRoles; i++)
    (*roleNameVector)[i] = nullAtom;

  for (size_t i = 0; i < WTF_ARRAY_LENGTH(roles); ++i)
    (*roleNameVector)[roles[i].webcoreRole] = AtomicString(roles[i].ariaRole);

  for (size_t i = 0; i < WTF_ARRAY_LENGTH(reverseRoles); ++i)
    (*roleNameVector)[reverseRoles[i].webcoreRole] =
        AtomicString(reverseRoles[i].ariaRole);

  return roleNameVector;
}

String AXLayoutObject::fontFamily() const {
  if (!getLayoutObject())
    return AXNodeObject::fontFamily();

  const ComputedStyle* style = getLayoutObject()->style();
  if (!style)
    return AXNodeObject::fontFamily();

  FontDescription& fontDescription =
      const_cast<FontDescription&>(style->getFontDescription());
  return fontDescription.firstFamily().family();
}

AXObject* AXLayoutObject::rawFirstChild() const {
  if (!m_layoutObject)
    return 0;

  LayoutObject* firstChild = firstChildConsideringContinuation(m_layoutObject);

  if (!firstChild)
    return 0;

  return axObjectCache().getOrCreate(firstChild);
}

void InspectorAccessibilityAgent::populateDOMNodeAncestors(
    Node& inspectedDOMNode,
    AXNode& nodeObject,
    std::unique_ptr<protocol::Array<AXNode>>& nodes,
    AXObjectCacheImpl& cache) const {
  Node* parentNode = inspectedDOMNode.isShadowRoot()
                         ? &toShadowRoot(inspectedDOMNode).host()
                         : FlatTreeTraversal::parent(inspectedDOMNode);
  AXObject* parentAXObject = cache.getOrCreate(parentNode);
  while (parentNode && !parentAXObject) {
    parentNode = parentNode->isShadowRoot()
                     ? &toShadowRoot(parentNode)->host()
                     : FlatTreeTraversal::parent(*parentNode);
    parentAXObject = cache.getOrCreate(parentNode);
  }

  if (!parentAXObject)
    return;

  if (parentAXObject->accessibilityIsIgnored())
    parentAXObject = parentAXObject->parentObjectUnignored();
  if (!parentAXObject)
    return;

  std::unique_ptr<AXNode> parentNodeObject =
      buildProtocolAXObject(*parentAXObject, nullptr, true, nodes, cache);
  std::unique_ptr<protocol::Array<AXNodeId>> childIds =
      protocol::Array<AXNodeId>::create();
  childIds->addItem(String::number(kIDForInspectedNodeWithNoAXNode));
  parentNodeObject->setChildIds(std::move(childIds));
  nodes->addItem(std::move(parentNodeObject));

  AXObject* grandparentAXObject = parentAXObject->parentObjectUnignored();
  if (grandparentAXObject)
    addAncestors(*grandparentAXObject, nullptr, nodes, cache);
}

AccessibilityRole AXListBoxOption::determineAccessibilityRole() {
  if ((m_ariaRole = determineAriaRoleAttribute()) != UnknownRole)
    return m_ariaRole;

  if (isParentPresentationalRole())
    return StaticTextRole;

  return ListBoxOptionRole;
}

  void addStringAttribute(AXStringAttribute attribute, const String& value) {
    switch (attribute) {
      case AXStringAttribute::AriaKeyShortcuts:
        m_properties.addItem(
            createProperty(AXGlobalStatesEnum::Keyshortcuts,
                           createValue(value, AXValueTypeEnum::String)));
        break;
      case AXStringAttribute::AriaRoleDescription:
        m_properties.addItem(
            createProperty(AXGlobalStatesEnum::Roledescription,
                           createValue(value, AXValueTypeEnum::String)));
        break;
    }
  }

AXObject* AXObject::parentObjectUnignored() const {
  AXObject* parent;
  for (parent = parentObject(); parent && parent->accessibilityIsIgnored();
       parent = parent->parentObject()) {
  }

  return parent;
}

bool AXNodeObject::isLink() const {
  return roleValue() == LinkRole;
}

void AXLayoutObject::detachRemoteSVGRoot() {
  if (AXSVGRoot* root = remoteSVGRootElement())
    root->setParent(0);
}

bool AXObject::hasAttribute(const QualifiedName& attribute) const {
  Node* elementNode = getNode();
  if (!elementNode)
    return false;

  if (!elementNode->isElementNode())
    return false;

  Element* element = toElement(elementNode);
  return element->fastHasAttribute(attribute);
}

void AXLayoutObject::ariaOwnsElements(AXObjectVector& owns) const {
  accessibilityChildrenFromAttribute(aria_ownsAttr, owns);
}

bool AXObject::isInertOrAriaHidden() const {
  updateCachedAttributeValuesIfNeeded();
  return m_cachedIsInertOrAriaHidden;
}

const AXObject* AXObject::disabledAncestor() const {
const AtomicString& disabled = getAttribute(aria_disabledAttr);
  if (equalIgnoringCase(disabled, "true"))
return this;
  if (equalIgnoringCase(disabled, "false"))
return 0;

if (AXObject* parent = parentObject())
return parent->disabledAncestor();

return 0;
}

bool AXNodeObject::isNonNativeTextControl() const {
  if (isNativeTextControl())
    return false;

  if (hasContentEditableAttributeSet())
    return true;

  if (isARIATextControl())
    return true;

  return false;
}

AccessibilityRole AXARIAGridCell::scanToDecideHeaderRole() {
  if (isAriaRowHeader())
    return RowHeaderRole;

  if (isAriaColumnHeader())
    return ColumnHeaderRole;

  return CellRole;
}

std::unique_ptr<AXProperty> createRelatedNodeListProperty(
    const String& key,
    AXObject::AXObjectVector& nodes,
    const QualifiedName& attr,
    AXObject& axObject) {
  std::unique_ptr<AXValue> nodeListValue = createRelatedNodeListValue(nodes);
  const AtomicString& attrValue = axObject.getAttribute(attr);
  nodeListValue->setValue(protocol::StringValue::create(attrValue));
  return createProperty(key, std::move(nodeListValue));
}

void AXObjectCacheImpl::handleUpdateActiveMenuOption(LayoutMenuList* menuList,
                                                     int optionIndex) {
  AXObject* obj = get(menuList);
  if (!obj || !obj->isMenuList())
    return;

  toAXMenuList(obj)->didUpdateActiveOption(optionIndex);
}

void AXNodeObject::insertChild(AXObject* child, unsigned index) {
  if (!child)
    return;

  child->clearChildren();

  if (child->accessibilityIsIgnored()) {
    const auto& children = child->children();
    size_t length = children.size();
    for (size_t i = 0; i < length; ++i)
      m_children.insert(index + i, children[i]);
  } else {
    ASSERT(child->parentObject() == this);
    m_children.insert(index, child);
  }
}

static inline LayoutObject* firstChildConsideringContinuation(
    LayoutObject* layoutObject) {
  LayoutObject* firstChild = layoutObject->slowFirstChild();

  if (firstChild && firstChild->isText() &&
      toLayoutText(firstChild)->isTextFragment() &&
      toLayoutTextFragment(firstChild)->firstLetterPseudoElement())
    return nullptr;

  if (!firstChild && isInlineWithContinuation(layoutObject))
    firstChild = firstChildInContinuation(toLayoutInline(*layoutObject));

  return firstChild;
}

AXObjectInclusion AXObject::defaultObjectInclusion(
    IgnoredReasons* ignoredReasons) const {
  if (isInertOrAriaHidden()) {
    if (ignoredReasons)
      computeIsInertOrAriaHidden(ignoredReasons);
    return IgnoreObject;
  }

  if (isPresentationalChild()) {
    if (ignoredReasons) {
      AXObject* ancestor = ancestorForWhichThisIsAPresentationalChild();
      ignoredReasons->push_back(
          IgnoredReason(AXAncestorDisallowsChild, ancestor));
    }
    return IgnoreObject;
  }

  return accessibilityPlatformIncludesObject();
}

const AtomicString& AXLayoutObject::liveRegionRelevant() const {
  DEFINE_STATIC_LOCAL(const AtomicString, defaultLiveRegionRelevant,
                      ("additions text"));
  const AtomicString& relevant =
      getAOMPropertyOrARIAAttribute(AOMStringProperty::kRelevant);

  if (relevant.isEmpty())
    return defaultLiveRegionRelevant;

  return relevant;
}

LayoutBoxModelObject* AXLayoutObject::getLayoutBoxModelObject() const {
  if (!m_layoutObject || !m_layoutObject->isBoxModelObject())
    return 0;
  return toLayoutBoxModelObject(m_layoutObject);
}

bool AXObject::containerLiveRegionAtomic() const {
  updateCachedAttributeValuesIfNeeded();
  return m_cachedLiveRegionRoot && m_cachedLiveRegionRoot->liveRegionAtomic();
}

bool AXLayoutObject::isSVGImage() const {
  return remoteSVGRootElement();
}

const AtomicString& AXObject::getAttribute(
    const QualifiedName& attribute) const {
  Node* elementNode = getNode();
  if (!elementNode)
    return nullAtom;

  if (!elementNode->isElementNode())
    return nullAtom;

  Element* element = toElement(elementNode);
  return element->fastGetAttribute(attribute);
}

bool AXObject::computeIsInertOrAriaHidden(
    IgnoredReasons* ignoredReasons) const {
  if (getNode()) {
    if (getNode()->isInert()) {
      if (ignoredReasons) {
        HTMLDialogElement* dialog = getActiveDialogElement(getNode());
        if (dialog) {
          AXObject* dialogObject = axObjectCache().getOrCreate(dialog);
          if (dialogObject)
            ignoredReasons->push_back(
                IgnoredReason(AXActiveModalDialog, dialogObject));
          else
            ignoredReasons->push_back(IgnoredReason(AXInert));
        } else {
          ignoredReasons->push_back(IgnoredReason(AXInert));
        }
      }
      return true;
    }
  } else {
    AXObject* parent = parentObject();
    if (parent && parent->isInertOrAriaHidden()) {
      if (ignoredReasons)
        parent->computeIsInertOrAriaHidden(ignoredReasons);
      return true;
    }
  }

  const AXObject* hiddenRoot = ariaHiddenRoot();
  if (hiddenRoot) {
    if (ignoredReasons) {
      if (hiddenRoot == this)
        ignoredReasons->push_back(IgnoredReason(AXAriaHidden));
      else
        ignoredReasons->push_back(IgnoredReason(AXAriaHiddenRoot, hiddenRoot));
    }
    return true;
  }

  return false;
}

void AXObject::scrollToGlobalPoint(const IntPoint& globalPoint) const {
  HeapVector<Member<const AXObject>> objects;
  AXObject* parentObject;
  for (parentObject = this->parentObject(); parentObject;
       parentObject = parentObject->parentObject()) {
    if (parentObject->getScrollableAreaIfScrollable())
      objects.push_front(parentObject);
  }
  objects.push_back(this);

  int offsetX = 0, offsetY = 0;
  IntPoint point = globalPoint;
  size_t levels = objects.size() - 1;
  for (size_t i = 0; i < levels; i++) {
    const AXObject* outer = objects[i];
    const AXObject* inner = objects[i + 1];
    ScrollableArea* scrollableArea = outer->getScrollableAreaIfScrollable();

    IntRect innerRect =
        inner->isWebArea()
            ? pixelSnappedIntRect(
                  inner->parentObject()->getBoundsInFrameCoordinates())
            : pixelSnappedIntRect(inner->getBoundsInFrameCoordinates());
    IntRect objectRect = innerRect;
    IntSize scrollOffset = scrollableArea->scrollOffsetInt();

    objectRect.move(offsetX, offsetY);
    if (!outer->isWebArea())
      objectRect.move(scrollOffset.width(), scrollOffset.height());

    int desiredX = computeBestScrollOffset(0, objectRect.x(), objectRect.maxX(),
                                           objectRect.x(), objectRect.maxX(),
                                           point.x(), point.x());
    int desiredY = computeBestScrollOffset(0, objectRect.y(), objectRect.maxY(),
                                           objectRect.y(), objectRect.maxY(),
                                           point.y(), point.y());
    outer->setScrollOffset(IntPoint(desiredX, desiredY));

    if (outer->isWebArea() && !inner->isWebArea()) {
      scrollOffset = scrollableArea->scrollOffsetInt();
      offsetX -= (scrollOffset.width() + point.x());
      offsetY -= (scrollOffset.height() + point.y());
      point.move(scrollOffset.width() - innerRect.width(),
                 scrollOffset.height() - innerRect.y());
    } else if (inner->isWebArea()) {
      offsetX = 0;
      offsetY = 0;
    }
  }

  DCHECK(objects[0]);
  axObjectCache().postNotification(objects[0]->getNode(),
                                   AXObjectCacheImpl::AXLocationChanged);
}

void AXObject::updateChildrenIfNecessary() {
  if (!hasChildren())
    addChildren();
}

void AXNodeObject::getSparseAXAttributes(
    AXSparseAttributeClient& sparseAttributeClient) const {
  Node* node = this->getNode();
  if (!node || !node->isElementNode())
    return;

  AXSparseAttributeSetterMap& axSparseAttributeSetterMap =
      getSparseAttributeSetterMap();
  AttributeCollection attributes = toElement(node)->attributesWithoutUpdate();
  for (const Attribute& attr : attributes) {
    SparseAttributeSetter* setter = axSparseAttributeSetterMap.at(attr.name());
    if (setter)
      setter->run(*this, sparseAttributeClient, attr.value());
  }

  if (toElement(node)->existingAccessibleNode()) {
    AtomicString keyShortcuts =
        getAOMPropertyOrARIAAttribute(AOMStringProperty::kKeyShortcuts);
    if (!keyShortcuts.isNull()) {
      axSparseAttributeSetterMap.at(aria_keyshortcutsAttr)
          ->run(*this, sparseAttributeClient, keyShortcuts);
    }
    AtomicString roleDescription =
        getAOMPropertyOrARIAAttribute(AOMStringProperty::kRoleDescription);
    if (!roleDescription.isNull()) {
      axSparseAttributeSetterMap.at(aria_roledescriptionAttr)
          ->run(*this, sparseAttributeClient, roleDescription);
    }
  }
}

void AXLayoutObject::addImageMapChildren() {
  LayoutBoxModelObject* cssBox = getLayoutBoxModelObject();
  if (!cssBox || !cssBox->isLayoutImage())
    return;

  HTMLMapElement* map = toLayoutImage(cssBox)->imageMap();
  if (!map)
    return;

  for (HTMLAreaElement& area :
       Traversal<HTMLAreaElement>::descendantsOf(*map)) {
    AXObject* obj = axObjectCache().getOrCreate(&area);
    if (obj) {
      AXImageMapLink* areaObject = toAXImageMapLink(obj);
      areaObject->setParent(this);
      ASSERT(areaObject->axObjectID() != 0);
      if (!areaObject->accessibilityIsIgnored())
        m_children.push_back(areaObject);
      else
        axObjectCache().remove(areaObject->axObjectID());
    }
  }
}

static Element* siblingWithAriaRole(String role, Node* node) {
Node* parent = node->parentNode();
if (!parent)
return 0;

for (Element* sibling = ElementTraversal::firstChild(*parent); sibling;
sibling = ElementTraversal::nextSibling(*sibling)) {
const AtomicString& siblingAriaRole =
AccessibleNode::getProperty(sibling, AOMStringProperty::kRole);
    if (equalIgnoringCase(siblingAriaRole, role))
return sibling;
}

return 0;
}

bool roleAllowsSort(AccessibilityRole role) {
  return role == ColumnHeaderRole || role == RowHeaderRole;
}

AXListBoxOption::~AXListBoxOption() {}

String AXNodeObject::ariaAutoComplete() const {
  if (roleValue() != ComboBoxRole)
    return String();

  const AtomicString& ariaAutoComplete =
      getAOMPropertyOrARIAAttribute(AOMStringProperty::kAutocomplete).lower();

  if (ariaAutoComplete == "inline" || ariaAutoComplete == "list" ||
      ariaAutoComplete == "both")
    return ariaAutoComplete;

  return String();
}

HTMLLabelElement* AXNodeObject::labelElementContainer() const {
  if (!getNode())
    return 0;

  if (isControl())
    return 0;

  if (isLink())
    return 0;

  return Traversal<HTMLLabelElement>::firstAncestorOrSelf(*getNode());
}

String AXObject::collapseWhitespace(const String& str) {
  StringBuilder result;
  if (!str.isEmpty() && isHTMLSpace<UChar>(str[0]))
    result.append(' ');
  result.append(str.simplifyWhiteSpace(isHTMLSpace<UChar>));
  if (!str.isEmpty() && isHTMLSpace<UChar>(str[str.length() - 1]))
    result.append(' ');
  return result.toString();
}

void InspectorAccessibilityAgent::addAncestors(
    AXObject& firstAncestor,
    AXObject* inspectedAXObject,
    std::unique_ptr<protocol::Array<AXNode>>& nodes,
    AXObjectCacheImpl& cache) const {
  AXObject* ancestor = &firstAncestor;
  while (ancestor) {
    nodes->addItem(buildProtocolAXObject(*ancestor, inspectedAXObject, true,
                                         nodes, cache));
    ancestor = ancestor->parentObjectUnignored();
  }
}

ScrollableArea* AXLayoutObject::getScrollableAreaIfScrollable() const {
  if (isWebArea())
    return documentFrameView()->layoutViewportScrollableArea();

  if (!m_layoutObject || !m_layoutObject->isBox())
    return 0;

  LayoutBox* box = toLayoutBox(m_layoutObject);
  if (!box->canBeScrolledAndHasScrollableArea())
    return 0;

  return box->getScrollableArea();
}

void AXObjectCacheImpl::handleActiveDescendantChanged(Node* node) {
  m_modificationCount++;

  if (AXObject* obj = getOrCreate(node))
    obj->handleActiveDescendantChanged();
}

IntPoint AXObject::getScrollOffset() const {
  ScrollableArea* area = getScrollableAreaIfScrollable();
  if (!area)
    return IntPoint();

  return IntPoint(area->scrollOffsetInt().width(),
                  area->scrollOffsetInt().height());
}

bool AXObject::containerLiveRegionBusy() const {
  updateCachedAttributeValuesIfNeeded();
  return m_cachedLiveRegionRoot && m_cachedLiveRegionRoot->liveRegionBusy();
}

void AXObjectCacheImpl::childrenChanged(Node* node) {
  childrenChanged(get(node));
}

String AXNodeObject::description(AXNameFrom nameFrom,
                                 AXDescriptionFrom& descriptionFrom,
                                 AXObjectVector* descriptionObjects) const {
  AXRelatedObjectVector relatedObjects;
  String result =
      description(nameFrom, descriptionFrom, nullptr, &relatedObjects);
  if (descriptionObjects) {
    descriptionObjects->clear();
    for (size_t i = 0; i < relatedObjects.size(); i++)
      descriptionObjects->push_back(relatedObjects[i]->object);
  }

  return collapseWhitespace(result);
}

void AXObjectCacheImpl::updateAriaOwns(
    const AXObject* owner,
    const Vector<String>& idVector,
    HeapVector<Member<AXObject>>& ownedChildren) {

  HashSet<String> currentIds = m_ariaOwnerToIdsMapping.at(owner->axObjectID());
  HashSet<String> newIds;
  bool idsChanged = false;
  for (const String& id : idVector) {
    newIds.insert(id);
    if (!currentIds.contains(id)) {
      idsChanged = true;
      HashSet<AXID>* owners = m_idToAriaOwnersMapping.at(id);
      if (!owners) {
        owners = new HashSet<AXID>();
        m_idToAriaOwnersMapping.set(id, WTF::wrapUnique(owners));
      }
      owners->insert(owner->axObjectID());
    }
  }
  for (const String& id : currentIds) {
    if (!newIds.contains(id)) {
      idsChanged = true;
      HashSet<AXID>* owners = m_idToAriaOwnersMapping.at(id);
      if (owners) {
        owners->erase(owner->axObjectID());
        if (owners->isEmpty())
          m_idToAriaOwnersMapping.erase(id);
      }
    }
  }
  if (idsChanged)
    m_ariaOwnerToIdsMapping.set(owner->axObjectID(), newIds);


  TreeScope& scope = owner->getNode()->treeScope();
  Vector<AXID> newChildAXIDs;
  for (const String& idName : idVector) {
    Element* element = scope.getElementById(AtomicString(idName));
    if (!element)
      continue;

    AXObject* child = getOrCreate(element);
    if (!child)
      continue;

    if (isAriaOwned(child) && getAriaOwnedParent(child) != owner)
      continue;

    if (child == owner)
      continue;

    bool foundCycle = false;
    for (AXObject* parent = owner->parentObject(); parent && !foundCycle;
         parent = parent->parentObject()) {
      if (parent == child)
        foundCycle = true;
    }
    if (foundCycle)
      continue;

    newChildAXIDs.push_back(child->axObjectID());
    ownedChildren.push_back(child);
  }

  Vector<AXID> currentChildAXIDs =
      m_ariaOwnerToChildrenMapping.at(owner->axObjectID());
  bool same = true;
  if (currentChildAXIDs.size() != newChildAXIDs.size()) {
    same = false;
  } else {
    for (size_t i = 0; i < currentChildAXIDs.size() && same; ++i) {
      if (currentChildAXIDs[i] != newChildAXIDs[i])
        same = false;
    }
  }
  if (same)
    return;

  for (size_t i = 0; i < currentChildAXIDs.size(); ++i) {
    AXID removedChildID = currentChildAXIDs[i];
    AXObject* removedChild = objectFromAXID(removedChildID);

    if (removedChild && getAriaOwnedParent(removedChild) != owner)
      continue;

    m_ariaOwnedChildToOwnerMapping.erase(removedChildID);

    if (removedChild) {
      removedChild->detachFromParent();
      AXID realParentID =
          m_ariaOwnedChildToRealParentMapping.at(removedChildID);
      AXObject* realParent = objectFromAXID(realParentID);
      childrenChanged(realParent);
    }

    m_ariaOwnedChildToRealParentMapping.erase(removedChildID);
  }

  for (size_t i = 0; i < newChildAXIDs.size(); ++i) {
    AXID addedChildID = newChildAXIDs[i];
    AXObject* addedChild = objectFromAXID(addedChildID);

    m_ariaOwnedChildToOwnerMapping.set(addedChildID, owner->axObjectID());

    AXObject* originalParent = addedChild->parentObject();
    m_ariaOwnedChildToRealParentMapping.set(addedChildID,
                                            originalParent->axObjectID());

    addedChild->detachFromParent();
    childrenChanged(originalParent);
  }

  m_ariaOwnerToChildrenMapping.set(owner->axObjectID(), newChildAXIDs);
}

bool AXNodeObject::isImage() const {
  return roleValue() == ImageRole;
}

 bool AXTableCell::computeAccessibilityIsIgnored(
    IgnoredReasons* ignoredReasons) const {
  AXObjectInclusion decision = defaultObjectInclusion(ignoredReasons);
  if (decision == IncludeObject)
    return false;
  if (decision == IgnoreObject)
    return true;

  if (!isTableCell())
    return AXLayoutObject::computeAccessibilityIsIgnored(ignoredReasons);

  return false;
}

bool AXTableCell::isTableCell() const {
  AXObject* parent = parentObjectUnignored();
  if (!parent || !parent->isTableRow())
    return false;

  return true;
}
