void HeadlessPrintManager::OnScriptedPrint(
    const PrintHostMsg_ScriptedPrint_Params& params,
    IPC::Message* reply_msg) {
  PageRangeStatus status =
      PageRangeTextToPages(page_ranges_text_, ignore_invalid_page_ranges_,
                           params.expected_pages_count, &print_params_->pages);
  switch (status) {
    case SYNTAX_ERROR:
      printing_rfh_->Send(reply_msg);
      ReleaseJob(PAGE_RANGE_SYNTAX_ERROR);
      return;
    case LIMIT_ERROR:
      printing_rfh_->Send(reply_msg);
      ReleaseJob(PAGE_COUNT_EXCEEDED);
      return;
    case PRINT_NO_ERROR:
      PrintHostMsg_ScriptedPrint::WriteReplyParams(reply_msg, *print_params_);
      printing_rfh_->Send(reply_msg);
      return;
    default:
      NOTREACHED();
      return;
  }
}

void HeadlessPrintManager::Reset() {
  printing_rfh_ = nullptr;
  callback_.Reset();
  print_params_.reset();
  page_ranges_text_.clear();
  ignore_invalid_page_ranges_ = false;
  data_.clear();
}

std::vector<PageHandler*> PageHandler::ForAgentHost(
    DevToolsAgentHostImpl* host) {
  return DevToolsSession::HandlersForAgentHost<PageHandler>(
      host, Page::Metainfo::domainName);
}

HeadlessDevToolsManagerDelegate::EmulateNetworkConditions(
    content::DevToolsAgentHost* agent_host,
    int session_id,
    int command_id,
    const base::DictionaryValue* params) {
  std::vector<HeadlessBrowserContext*> browser_contexts =
      browser_->GetAllBrowserContexts();
  if (browser_contexts.empty())
    return CreateSuccessResponse(command_id, nullptr);
  const base::Value* offline_value = params->FindKey("offline");
  const base::Value* latency_value = params->FindKey("latency");
  const base::Value* download_throughput_value =
      params->FindKey("downloadThroughput");
  const base::Value* upload_throughput_value =
      params->FindKey("uploadThroughput");
  HeadlessNetworkConditions conditions(HeadlessNetworkConditions(
      offline_value ? offline_value->GetBool() : false,
      latency_value ? std::max(latency_value->GetDouble(), 0.0) : 0,
      download_throughput_value
          ? std::max(download_throughput_value->GetDouble(), 0.0)
          : 0,
      upload_throughput_value
          ? std::max(upload_throughput_value->GetDouble(), 0.0)
          : 0));
  SetNetworkConditions(browser_contexts, conditions);
  return CreateSuccessResponse(command_id, nullptr);
}

HeadlessPrintManager::PageRangeTextToPages(base::StringPiece page_range_text,
                                           bool ignore_invalid_page_ranges,
                                           int pages_count,
                                           std::vector<int>* pages) {
  printing::PageRanges page_ranges;
  for (const auto& range_string :
       base::SplitStringPiece(page_range_text, ",", base::TRIM_WHITESPACE,
                              base::SPLIT_WANT_NONEMPTY)) {
    printing::PageRange range;
    if (range_string.find("-") == base::StringPiece::npos) {
      if (!base::StringToInt(range_string, &range.from))
        return SYNTAX_ERROR;
      range.to = range.from;
    } else if (range_string == "-") {
      range.from = 1;
      range.to = pages_count;
    } else if (range_string.starts_with("-")) {
      range.from = 1;
      if (!base::StringToInt(range_string.substr(1), &range.to))
        return SYNTAX_ERROR;
    } else if (range_string.ends_with("-")) {
      range.to = pages_count;
      if (!base::StringToInt(range_string.substr(0, range_string.length() - 1),
                             &range.from))
        return SYNTAX_ERROR;
    } else {
      auto tokens = base::SplitStringPiece(
          range_string, "-", base::TRIM_WHITESPACE, base::SPLIT_WANT_NONEMPTY);
      if (tokens.size() != 2 || !base::StringToInt(tokens[0], &range.from) ||
          !base::StringToInt(tokens[1], &range.to))
        return SYNTAX_ERROR;
    }

    if (range.from < 1 || range.from > range.to) {
      if (!ignore_invalid_page_ranges)
        return SYNTAX_ERROR;
      continue;
    }
    if (range.from > pages_count) {
      if (!ignore_invalid_page_ranges)
        return LIMIT_ERROR;
      continue;
    }

    if (range.to > pages_count)
      range.to = pages_count;

    range.from--;
    range.to--;
    page_ranges.push_back(range);
  }
  *pages = printing::PageRange::GetPages(page_ranges);
  return PRINT_NO_ERROR;
}

bool PrintRenderFrameHelper::PreviewPageRendered(int page_number,
                                                 PdfMetafileSkia* metafile) {
  DCHECK_GE(page_number, FIRST_PAGE_INDEX);

  if (!print_preview_context_.IsModifiable() ||
      !print_preview_context_.generate_draft_pages()) {
    DCHECK(!metafile);
    return true;
  }

  if (!metafile) {
    NOTREACHED();
    print_preview_context_.set_error(
        PREVIEW_ERROR_PAGE_RENDERED_WITHOUT_METAFILE);
    return false;
  }

  PrintHostMsg_DidPreviewPage_Params preview_page_params;
  if (!CopyMetafileDataToSharedMem(*metafile,
                                   &preview_page_params.metafile_data_handle)) {
    LOG(ERROR) << "CopyMetafileDataToSharedMem failed";
    print_preview_context_.set_error(PREVIEW_ERROR_METAFILE_COPY_FAILED);
    return false;
  }

  preview_page_params.data_size = metafile->GetDataSize();
  preview_page_params.page_number = page_number;
  preview_page_params.preview_request_id =
      print_pages_params_->params.preview_request_id;

  Send(new PrintHostMsg_DidPreviewPage(routing_id(), preview_page_params));
  return true;
}

PrintRenderFrameHelper::PrintRenderFrameHelper(
    content::RenderFrame* render_frame,
    std::unique_ptr<Delegate> delegate)
    : content::RenderFrameObserver(render_frame),
      content::RenderFrameObserverTracker<PrintRenderFrameHelper>(render_frame),
      reset_prep_frame_view_(false),
      is_print_ready_metafile_sent_(false),
      ignore_css_margins_(false),
      is_printing_enabled_(true),
      notify_browser_of_print_failure_(true),
      print_for_preview_(false),
      delegate_(std::move(delegate)),
      print_node_in_progress_(false),
      is_loading_(false),
      is_scripted_preview_delayed_(false),
      ipc_nesting_level_(0),
      render_frame_gone_(false),
      weak_ptr_factory_(this) {
  if (!delegate_->IsPrintPreviewEnabled())
    DisablePreview();
}

void HeadlessDevToolsManagerDelegate::SetNetworkConditions(
    std::vector<HeadlessBrowserContext*> browser_contexts,
    HeadlessNetworkConditions conditions) {
  for (std::vector<HeadlessBrowserContext*>::iterator it =
           browser_contexts.begin();
       it != browser_contexts.end(); ++it) {
    HeadlessBrowserContextImpl* context =
        static_cast<HeadlessBrowserContextImpl*>(*it);
    context->SetNetworkConditions(conditions);
  }
}

std::unique_ptr<base::DictionaryValue> CreateSuccessResponse(
    int command_id,
    std::unique_ptr<base::Value> result) {
  if (!result)
    result = std::make_unique<base::DictionaryValue>();

  auto response = std::make_unique<base::DictionaryValue>();
  response->SetInteger(kIdParam, command_id);
  response->Set(kResultParam, std::move(result));
  return response;
}

HeadlessDevToolsManagerDelegate::CreateTarget(
    content::DevToolsAgentHost* agent_host,
    int session_id,
    int command_id,
    const base::DictionaryValue* params) {
  std::string url;

  if (const base::Value* url_value = params->FindKey("url")) {
    url = url_value->GetString();
  } else {
    return CreateInvalidParamResponse(command_id, "url");
  }

  std::string browser_context_id;
  if (const base::Value* browser_context_id_value =
          params->FindKey("browserContextId")) {
    browser_context_id = browser_context_id_value->GetString();
  }

  int width = browser_->options()->window_size.width();
  if (const base::Value* width_value = params->FindKey("width"))
    width = width_value->GetInt();

  int height = browser_->options()->window_size.height();
  if (const base::Value* height_value = params->FindKey("height"))
    height = height_value->GetInt();

  bool enable_begin_frame_control = false;
  if (const base::Value* enable_begin_frame_control_value =
          params->FindKey("enableBeginFrameControl")) {
    enable_begin_frame_control = enable_begin_frame_control_value->GetBool();
  }

#if defined(OS_MACOSX)
  if (enable_begin_frame_control) {
    return CreateErrorResponse(
        command_id, kErrorServerError,
        "BeginFrameControl is not supported on MacOS yet");
  }
#endif

  HeadlessBrowserContext* context =
      browser_->GetBrowserContextForId(browser_context_id);
  if (!browser_context_id.empty()) {
    context = browser_->GetBrowserContextForId(browser_context_id);
    if (!context)
      return CreateInvalidParamResponse(command_id, "browserContextId");
  } else {
    context = browser_->GetDefaultBrowserContext();
    if (!context) {
      return CreateErrorResponse(command_id, kErrorServerError,
                                 "You specified no |browserContextId|, but "
                                 "there is no default browser context set on "
                                 "HeadlessBrowser");
    }
  }

  HeadlessWebContentsImpl* web_contents_impl = HeadlessWebContentsImpl::From(
      context->CreateWebContentsBuilder()
          .SetInitialURL(GURL(url))
          .SetWindowSize(gfx::Size(width, height))
          .SetEnableBeginFrameControl(enable_begin_frame_control)
          .Build());

  std::unique_ptr<base::Value> result(
      target::CreateTargetResult::Builder()
          .SetTargetId(web_contents_impl->GetDevToolsAgentHostId())
          .Build()
          ->Serialize());
  return CreateSuccessResponse(command_id, std::move(result));
}

HeadlessPrintManager::HeadlessPrintManager(content::WebContents* web_contents)
    : PrintManager(web_contents) {
  Reset();
}

void HeadlessPrintManager::GetPDFContents(content::RenderFrameHost* rfh,
                                          const HeadlessPrintSettings& settings,
                                          const GetPDFCallback& callback) {
  DCHECK(callback);

  if (callback_) {
    callback.Run(SIMULTANEOUS_PRINT_ACTIVE, std::string());
    return;
  }
  printing_rfh_ = rfh;
  callback_ = callback;
  print_params_ = GetPrintParamsFromSettings(settings);
  page_ranges_text_ = settings.page_ranges;
  ignore_invalid_page_ranges_ = settings.ignore_invalid_page_ranges;
  rfh->Send(new PrintMsg_PrintPages(rfh->GetRoutingID()));
}

void PrintRenderFrameHelper::OnPrintForPrintPreview(
    const base::DictionaryValue& job_settings) {
  CHECK_LE(ipc_nesting_level_, 1);
  if (prep_frame_view_)
    return;

  blink::WebDocument document = render_frame()->GetWebFrame()->GetDocument();
  blink::WebElement pdf_element = document.GetElementById("pdf-viewer");
  if (pdf_element.IsNull()) {
    NOTREACHED();
    return;
  }

  blink::WebLocalFrame* plugin_frame = pdf_element.GetDocument().GetFrame();
  blink::WebElement plugin_element = pdf_element;
  if (pdf_element.HasHTMLTagName("iframe")) {
    plugin_frame = blink::WebLocalFrame::FromFrameOwnerElement(pdf_element);
    plugin_element = delegate_->GetPdfElement(plugin_frame);
    if (plugin_element.IsNull()) {
      NOTREACHED();
      return;
    }
  }

  base::AutoReset<bool> set_printing_flag(&print_for_preview_, true);

  if (!UpdatePrintSettings(plugin_frame, plugin_element, job_settings)) {
    LOG(ERROR) << "UpdatePrintSettings failed";
    DidFinishPrinting(FAIL_PRINT);
    return;
  }

  PrintMsg_Print_Params& print_params = print_pages_params_->params;
  printer_printable_area_ = print_params.printable_area;
  print_params.printable_area = gfx::Rect(print_params.page_size);

  if (!RenderPagesForPrint(plugin_frame, plugin_element)) {
    LOG(ERROR) << "RenderPagesForPrint failed";
    DidFinishPrinting(FAIL_PRINT);
  }
}

HeadlessPrintSettings::HeadlessPrintSettings()
    : landscape(false),
      display_header_footer(false),
      should_print_backgrounds(false),
      scale(1),
      ignore_invalid_page_ranges(false) {}

  bool Send(IPC::Message* msg) { return render_frame_host->Send(msg); }

bool PrintRenderFrameHelper::OnMessageReceived(const IPC::Message& message) {
  ++ipc_nesting_level_;

  bool handled = true;
  IPC_BEGIN_MESSAGE_MAP(PrintRenderFrameHelper, message)
#if BUILDFLAG(ENABLE_BASIC_PRINTING)
    IPC_MESSAGE_HANDLER(PrintMsg_PrintPages, OnPrintPages)
    IPC_MESSAGE_HANDLER(PrintMsg_PrintForSystemDialog, OnPrintForSystemDialog)
#endif  // BUILDFLAG(ENABLE_BASIC_PRINTING)
#if BUILDFLAG(ENABLE_BASIC_PRINTING) && BUILDFLAG(ENABLE_PRINT_PREVIEW)
    IPC_MESSAGE_HANDLER(PrintMsg_PrintForPrintPreview, OnPrintForPrintPreview)
#endif
#if BUILDFLAG(ENABLE_PRINT_PREVIEW)
    IPC_MESSAGE_HANDLER(PrintMsg_InitiatePrintPreview, OnInitiatePrintPreview)
    IPC_MESSAGE_HANDLER(PrintMsg_PrintPreview, OnPrintPreview)
    IPC_MESSAGE_HANDLER(PrintMsg_PrintingDone, OnPrintingDone)
    IPC_MESSAGE_HANDLER(PrintMsg_ClosePrintPreviewDialog,
                        OnClosePrintPreviewDialog)
#endif  // BUILDFLAG(ENABLE_PRINT_PREVIEW)
    IPC_MESSAGE_HANDLER(PrintMsg_SetPrintingEnabled, OnSetPrintingEnabled)
    IPC_MESSAGE_UNHANDLED(handled = false)
  IPC_END_MESSAGE_MAP()

  --ipc_nesting_level_;
  if (ipc_nesting_level_ == 0 && render_frame_gone_)
    base::ThreadTaskRunnerHandle::Get()->DeleteSoon(FROM_HERE, this);
  return handled;
}

HeadlessDevToolsManagerDelegate::DisposeBrowserContext(
    content::DevToolsAgentHost* agent_host,
    int session_id,
    int command_id,
    const base::DictionaryValue* params) {
  const base::Value* browser_context_id_value =
      params->FindKey("browserContextId");
  if (!browser_context_id_value)
    return CreateInvalidParamResponse(command_id, "browserContextId");

  HeadlessBrowserContext* context =
      browser_->GetBrowserContextForId(browser_context_id_value->GetString());

  bool success = false;
  if (context && context != browser_->GetDefaultBrowserContext() &&
      context->GetAllWebContents().empty()) {
    success = true;
    context->Close();
  }

  std::unique_ptr<base::Value> result(
      target::DisposeBrowserContextResult::Builder()
          .SetSuccess(success)
          .Build()
          ->Serialize());
  return CreateSuccessResponse(command_id, std::move(result));
}

HeadlessDevToolsManagerDelegate::SetWindowBounds(
    content::DevToolsAgentHost* agent_host,
    int session_id,
    int command_id,
    const base::DictionaryValue* params) {
  HeadlessWebContentsImpl* web_contents;
  const base::Value* window_id_value = params->FindKey("windowId");
  if (!window_id_value || !window_id_value->is_int())
    return CreateInvalidParamResponse(command_id, "windowId");
  web_contents = browser_->GetWebContentsForWindowId(window_id_value->GetInt());

  if (!web_contents) {
    return CreateErrorResponse(command_id, kErrorServerError,
                               "Browser window not found");
  }

  const base::Value* bounds_value = params->FindKey("bounds");
  if (!bounds_value || !bounds_value->is_dict())
    return CreateInvalidParamResponse(command_id, "bounds");

  std::string window_state;
  if (const base::Value* window_state_value =
          bounds_value->FindKey("windowState")) {
    window_state = window_state_value->GetString();
    if (window_state != "normal" && window_state != "minimized" &&
        window_state != "maximized" && window_state != "fullscreen") {
      return CreateInvalidParamResponse(command_id, "windowState");
    }
  } else {
    window_state = "normal";
  }

  bool set_bounds = false;
  gfx::Rect bounds = web_contents->web_contents()->GetContainerBounds();
  if (const base::Value* left_value = bounds_value->FindKey("left")) {
    bounds.set_x(left_value->GetInt());
    set_bounds = true;
  }

  if (const base::Value* top_value = bounds_value->FindKey("top")) {
    bounds.set_y(top_value->GetInt());
    set_bounds = true;
  }

  if (const base::Value* width_value = bounds_value->FindKey("width")) {
    int width = width_value->GetInt();
    if (width < 0)
      return CreateInvalidParamResponse(command_id, "width");
    bounds.set_width(width);
    set_bounds = true;
  }

  if (const base::Value* height_value = bounds_value->FindKey("height")) {
    int height = height_value->GetInt();
    if (height < 0)
      return CreateInvalidParamResponse(command_id, "height");
    bounds.set_height(height);
    set_bounds = true;
  }

  if (set_bounds && window_state != "normal") {
    return CreateErrorResponse(
        command_id, kErrorServerError,
        "The 'minimized', 'maximized' and 'fullscreen' states cannot be "
        "combined with 'left', 'top', 'width' or 'height'");
  }

  if (set_bounds && web_contents->window_state() != "normal") {
    return CreateErrorResponse(
        command_id, kErrorServerError,
        "To resize minimized/maximized/fullscreen window, restore it to normal "
        "state first.");
  }

  web_contents->set_window_state(window_state);
  web_contents->SetBounds(bounds);
  return CreateSuccessResponse(command_id, nullptr);
}

PrintMsg_Print_Params::PrintMsg_Print_Params()
    : page_size(),
      content_size(),
      printable_area(),
      margin_top(0),
      margin_left(0),
      dpi(0),
      scale_factor(1.0f),
      rasterize_pdf(false),
      document_cookie(0),
      selection_only(false),
      supports_alpha_blend(false),
      preview_ui_id(-1),
      preview_request_id(0),
      is_first_request(false),
      print_scaling_option(blink::kWebPrintScalingOptionSourceSize),
      print_to_pdf(false),
       display_header_footer(false),
       title(),
       url(),
       should_print_backgrounds(false),
       printed_doc_type(printing::SkiaDocumentType::PDF) {}

std::unique_ptr<base::DictionaryValue> ParsePrintSettings(
    int command_id,
    const base::DictionaryValue* params,
    HeadlessPrintSettings* settings) {
  if (const base::Value* landscape_value = params->FindKey("landscape"))
    settings->landscape = landscape_value->GetBool();

  if (const base::Value* display_header_footer_value =
          params->FindKey("displayHeaderFooter")) {
    settings->display_header_footer = display_header_footer_value->GetBool();
  }

  if (const base::Value* should_print_backgrounds_value =
          params->FindKey("printBackground")) {
    settings->should_print_backgrounds =
        should_print_backgrounds_value->GetBool();
  }
  if (const base::Value* scale_value = params->FindKey("scale"))
    settings->scale = scale_value->GetDouble();
  if (settings->scale > kScaleMaxVal / 100 ||
      settings->scale < kScaleMinVal / 100)
    return CreateInvalidParamResponse(command_id, "scale");
  if (const base::Value* page_ranges_value = params->FindKey("pageRanges"))
    settings->page_ranges = page_ranges_value->GetString();

  if (const base::Value* ignore_invalid_page_ranges_value =
          params->FindKey("ignoreInvalidPageRanges")) {
    settings->ignore_invalid_page_ranges =
        ignore_invalid_page_ranges_value->GetBool();
  }

  double paper_width_in_inch = printing::kLetterWidthInch;

  if (const base::Value* paper_width_value = params->FindKey("paperWidth"))
    paper_width_in_inch = paper_width_value->GetDouble();

  double paper_height_in_inch = printing::kLetterHeightInch;

  if (const base::Value* paper_height_value = params->FindKey("paperHeight"))
    paper_height_in_inch = paper_height_value->GetDouble();
  if (paper_width_in_inch <= 0)
    return CreateInvalidParamResponse(command_id, "paperWidth");
  if (paper_height_in_inch <= 0)
    return CreateInvalidParamResponse(command_id, "paperHeight");
  settings->paper_size_in_points =
      gfx::Size(paper_width_in_inch * printing::kPointsPerInch,
                paper_height_in_inch * printing::kPointsPerInch);

  double default_margin_in_inch = 1000.0 / printing::kHundrethsMMPerInch;
  double margin_top_in_inch = default_margin_in_inch;
  double margin_bottom_in_inch = default_margin_in_inch;
  double margin_left_in_inch = default_margin_in_inch;
  double margin_right_in_inch = default_margin_in_inch;

  if (const base::Value* margin_top_value = params->FindKey("marginTop"))
    margin_top_in_inch = margin_top_value->GetDouble();

  if (const base::Value* margin_bottom_value = params->FindKey("marginBottom"))
    margin_bottom_in_inch = margin_bottom_value->GetDouble();

  if (const base::Value* margin_left_value = params->FindKey("marginLeft"))
    margin_left_in_inch = margin_left_value->GetDouble();

   if (const base::Value* margin_right_value = params->FindKey("marginRight"))
     margin_right_in_inch = margin_right_value->GetDouble();
 
   if (margin_top_in_inch < 0)
     return CreateInvalidParamResponse(command_id, "marginTop");
   if (margin_bottom_in_inch < 0)
    return CreateInvalidParamResponse(command_id, "marginBottom");
  if (margin_left_in_inch < 0)
    return CreateInvalidParamResponse(command_id, "marginLeft");
  if (margin_right_in_inch < 0)
    return CreateInvalidParamResponse(command_id, "marginRight");
  settings->margins_in_points.top =
      margin_top_in_inch * printing::kPointsPerInch;
  settings->margins_in_points.bottom =
      margin_bottom_in_inch * printing::kPointsPerInch;
  settings->margins_in_points.left =
      margin_left_in_inch * printing::kPointsPerInch;
  settings->margins_in_points.right =
      margin_right_in_inch * printing::kPointsPerInch;

  return nullptr;
}

void PrintRenderFrameHelper::PrintPageInternal(
    const PrintMsg_Print_Params& params,
    int page_number,
    int page_count,
    blink::WebLocalFrame* frame,
    PdfMetafileSkia* metafile,
    gfx::Size* page_size_in_dpi,
    gfx::Rect* content_area_in_dpi) {
  double css_scale_factor =
      params.scale_factor >= kEpsilon ? params.scale_factor : 1.0f;

  gfx::Size original_page_size = params.page_size;
  PageSizeMargins page_layout_in_points;
  ComputePageLayoutInPointsForCss(frame, page_number, params,
                                  ignore_css_margins_, &css_scale_factor,
                                  &page_layout_in_points);

  gfx::Size page_size;
  gfx::Rect content_area;
  GetPageSizeAndContentAreaFromPageLayout(page_layout_in_points, &page_size,
                                          &content_area);

  if (page_size_in_dpi)
    *page_size_in_dpi = original_page_size;

  if (content_area_in_dpi) {
    *content_area_in_dpi =
        gfx::Rect(0, 0, page_size_in_dpi->width(), page_size_in_dpi->height());
  }

  gfx::Rect canvas_area =
      params.display_header_footer ? gfx::Rect(page_size) : content_area;

#if defined(OS_WIN)
  float webkit_page_shrink_factor = frame->GetPrintPageShrink(page_number);
  float scale_factor = css_scale_factor * webkit_page_shrink_factor;
#else
  float scale_factor = css_scale_factor;
#endif

  cc::PaintCanvas* canvas =
      metafile->GetVectorCanvasForNewPage(page_size, canvas_area, scale_factor);
  if (!canvas)
    return;

  MetafileSkiaWrapper::SetMetafileOnCanvas(canvas, metafile);

  if (params.display_header_footer) {
#if defined(OS_WIN)
    const float fudge_factor = 1;
#else
    const float fudge_factor = kPrintingMinimumShrinkFactor;
#endif
    PrintHeaderAndFooter(canvas, page_number + 1, page_count, *frame,
                         scale_factor / fudge_factor, page_layout_in_points,
                         params);
  }

  float webkit_scale_factor = RenderPageContent(
      frame, page_number, canvas_area, content_area, scale_factor, canvas);
  DCHECK_GT(webkit_scale_factor, 0.0f);

  bool ret = metafile->FinishPage();
  DCHECK(ret);
}

Response PageHandler::Reload(Maybe<bool> bypassCache,
                             Maybe<std::string> script_to_evaluate_on_load) {
  WebContentsImpl* web_contents = GetWebContents();
  if (!web_contents)
    return Response::InternalError();

  if (web_contents->IsCrashed() ||
      (web_contents->GetController().GetVisibleEntry() &&
       web_contents->GetController().GetVisibleEntry()->IsViewSourceMode())) {
    web_contents->GetController().Reload(bypassCache.fromMaybe(false)
                                             ? ReloadType::BYPASSING_CACHE
                                             : ReloadType::NORMAL,
                                         false);
    return Response::OK();
  } else {
    return Response::FallThrough();
  }
}

void OnBeginFrameFinished(
    int command_id,
    const HeadlessDevToolsManagerDelegate::CommandCallback& callback,
    ImageEncoding encoding,
    int quality,
    bool has_damage,
    bool main_frame_content_updated,
    std::unique_ptr<SkBitmap> bitmap) {
  auto result = std::make_unique<base::DictionaryValue>();
  result->SetBoolean("hasDamage", has_damage);
  result->SetBoolean("mainFrameContentUpdated", main_frame_content_updated);

  if (bitmap && !bitmap->drawsNothing()) {
    result->SetString("screenshotData",
                      EncodeBitmap(*bitmap, encoding, quality));
  }

  callback.Run(CreateSuccessResponse(command_id, std::move(result)));
}

HeadlessPrintManager::PDFContentsToDictionaryValue(const std::string& data) {
  std::string base_64_data;
  base::Base64Encode(data, &base_64_data);
  auto result = std::make_unique<base::DictionaryValue>();
  result->SetString("data", base_64_data);
  return result;
}

bool PrintRenderFrameHelper::PrintPagesNative(blink::WebLocalFrame* frame,
                                              int page_count) {
  const PrintMsg_PrintPages_Params& params = *print_pages_params_;
  const PrintMsg_Print_Params& print_params = params.params;

  std::vector<int> printed_pages = GetPrintedPages(params, page_count);
  if (printed_pages.empty())
    return false;

  PdfMetafileSkia metafile(print_params.printed_doc_type);
  CHECK(metafile.Init());

  PrintHostMsg_DidPrintDocument_Params page_params;
  PrintPageInternal(print_params, printed_pages[0], page_count, frame,
                    &metafile, &page_params.page_size,
                    &page_params.content_area);
  for (size_t i = 1; i < printed_pages.size(); ++i) {
    PrintPageInternal(print_params, printed_pages[i], page_count, frame,
                      &metafile, nullptr, nullptr);
  }

  FinishFramePrinting();

  metafile.FinishDocument();

  if (!CopyMetafileDataToSharedMem(metafile,
                                   &page_params.metafile_data_handle)) {
    return false;
  }

  page_params.data_size = metafile.GetDataSize();
  page_params.document_cookie = print_params.document_cookie;
#if defined(OS_WIN)
  page_params.physical_offsets = printer_printable_area_.origin();
#endif
  Send(new PrintHostMsg_DidPrintDocument(routing_id(), page_params));
  return true;
}

std::unique_ptr<base::DictionaryValue> CreateErrorResponse(
    int command_id,
    int error_code,
    const std::string& error_message) {
  auto error_object = std::make_unique<base::DictionaryValue>();
  error_object->SetInteger(kErrorCodeParam, error_code);
  error_object->SetString(kErrorMessageParam, error_message);

  auto response = std::make_unique<base::DictionaryValue>();
  response->SetInteger(kIdParam, command_id);
  response->Set(kErrorParam, std::move(error_object));
  return response;
}

void HeadlessPrintManager::OnPrintingFailed(int cookie) {
  ReleaseJob(PRINTING_FAILED);
}

    ~PrintHostMsg_RequestPrintPreview_Params() {}

HeadlessDevToolsManagerDelegate::CloseTarget(
    content::DevToolsAgentHost* agent_host,
    int session_id,
    int command_id,
    const base::DictionaryValue* params) {
  const base::Value* target_id_value = params->FindKey("targetId");
  if (!target_id_value)
    return CreateInvalidParamResponse(command_id, "targetId");
  HeadlessWebContents* web_contents =
      browser_->GetWebContentsForDevToolsAgentHostId(
          target_id_value->GetString());
  bool success = false;
  if (web_contents) {
    web_contents->Close();
    success = true;
  }
  std::unique_ptr<base::Value> result(target::CloseTargetResult::Builder()
                                          .SetSuccess(success)
                                          .Build()
                                          ->Serialize());
  return CreateSuccessResponse(command_id, std::move(result));
}

bool PrintRenderFrameHelper::UpdatePrintSettings(
    blink::WebLocalFrame* frame,
    const blink::WebNode& node,
    const base::DictionaryValue& passed_job_settings) {
  const base::DictionaryValue* job_settings = &passed_job_settings;
  base::DictionaryValue modified_job_settings;
  if (job_settings->empty()) {
    if (!print_for_preview_)
      print_preview_context_.set_error(PREVIEW_ERROR_BAD_SETTING);
    return false;
  }

  bool source_is_html = true;
  if (print_for_preview_) {
    if (!job_settings->GetBoolean(kSettingPreviewModifiable, &source_is_html)) {
      NOTREACHED();
    }
  } else {
    source_is_html = !PrintingNodeOrPdfFrame(frame, node);
  }

  if (print_for_preview_ || !source_is_html) {
    modified_job_settings.MergeDictionary(job_settings);
    modified_job_settings.SetBoolean(kSettingHeaderFooterEnabled, false);
    modified_job_settings.SetInteger(kSettingMarginsType, NO_MARGINS);
    job_settings = &modified_job_settings;
  }

  int cookie =
      print_pages_params_ ? print_pages_params_->params.document_cookie : 0;
  PrintMsg_PrintPages_Params settings;
  bool canceled = false;
  Send(new PrintHostMsg_UpdatePrintSettings(routing_id(), cookie, *job_settings,
                                            &settings, &canceled));
  if (canceled) {
    notify_browser_of_print_failure_ = false;
    return false;
  }

  if (!job_settings->GetInteger(kPreviewUIID, &settings.params.preview_ui_id)) {
    NOTREACHED();
    print_preview_context_.set_error(PREVIEW_ERROR_BAD_SETTING);
    return false;
  }

  if (!print_for_preview_) {
    if (!job_settings->GetInteger(kPreviewRequestID,
                                  &settings.params.preview_request_id) ||
        !job_settings->GetBoolean(kIsFirstRequest,
                                  &settings.params.is_first_request)) {
      NOTREACHED();
      print_preview_context_.set_error(PREVIEW_ERROR_BAD_SETTING);
      return false;
    }

    settings.params.print_to_pdf = IsPrintToPdfRequested(*job_settings);
    UpdateFrameMarginsCssInfo(*job_settings);
    settings.params.print_scaling_option = GetPrintScalingOption(
        frame, node, source_is_html, *job_settings, settings.params);
  }

  SetPrintPagesParams(settings);

  if (PrintMsg_Print_Params_IsValid(settings.params))
    return true;

  if (print_for_preview_)
    Send(new PrintHostMsg_ShowInvalidPrinterSettingsError(routing_id()));
  else
    print_preview_context_.set_error(PREVIEW_ERROR_INVALID_PRINTER_SETTINGS);
  return false;
}

std::unique_ptr<base::DictionaryValue> CreateBoundsDict(
    const HeadlessWebContentsImpl* web_contents) {
  auto bounds_object = std::make_unique<base::DictionaryValue>();
  gfx::Rect bounds = web_contents->web_contents()->GetContainerBounds();
  bounds_object->SetInteger("left", bounds.x());
  bounds_object->SetInteger("top", bounds.y());
  bounds_object->SetInteger("width", bounds.width());
  bounds_object->SetInteger("height", bounds.height());
  bounds_object->SetString("windowState", web_contents->window_state());
  return bounds_object;
}

  void OnGetDefaultPrintSettings(IPC::Message* reply_msg) {
    manager->OnGetDefaultPrintSettings(reply_msg);
  }

void HeadlessPrintManager::OnDidPrintDocument(
    const PrintHostMsg_DidPrintDocument_Params& params) {
  if (!base::SharedMemory::IsHandleValid(params.metafile_data_handle)) {
    ReleaseJob(INVALID_MEMORY_HANDLE);
    return;
  }
  auto shared_buf =
      std::make_unique<base::SharedMemory>(params.metafile_data_handle, true);
  if (!shared_buf->Map(params.data_size)) {
    ReleaseJob(METAFILE_MAP_ERROR);
    return;
  }
  data_ = std::string(static_cast<const char*>(shared_buf->memory()),
                      params.data_size);
  ReleaseJob(PRINT_SUCCESS);
}

HeadlessPrintManager::GetPrintParamsFromSettings(
    const HeadlessPrintSettings& settings) {
  printing::PrintSettings print_settings;
  print_settings.set_dpi(printing::kPointsPerInch);
  print_settings.set_should_print_backgrounds(
      settings.should_print_backgrounds);
  print_settings.set_scale_factor(settings.scale);
  print_settings.SetOrientation(settings.landscape);

  print_settings.set_display_header_footer(settings.display_header_footer);
  if (print_settings.display_header_footer()) {
    url::Replacements<char> url_sanitizer;
    url_sanitizer.ClearUsername();
    url_sanitizer.ClearPassword();
    std::string url = printing_rfh_->GetLastCommittedURL()
                          .ReplaceComponents(url_sanitizer)
                          .spec();
    print_settings.set_url(base::UTF8ToUTF16(url));
  }

  print_settings.set_margin_type(printing::CUSTOM_MARGINS);
  print_settings.SetCustomMargins(settings.margins_in_points);

  gfx::Rect printable_area_device_units(settings.paper_size_in_points);
  print_settings.SetPrinterPrintableArea(settings.paper_size_in_points,
                                         printable_area_device_units, true);

  auto print_params = std::make_unique<PrintMsg_PrintPages_Params>();
   printing::RenderParamsFromPrintSettings(print_settings,
                                           &print_params->params);
   print_params->params.document_cookie = printing::PrintSettings::NewCookie();
   return print_params;
 }

void HeadlessPrintManager::OnGetDefaultPrintSettings(IPC::Message* reply_msg) {
  PrintHostMsg_GetDefaultPrintSettings::WriteReplyParams(reply_msg,
                                                         print_params_->params);
  printing_rfh_->Send(reply_msg);
}

bool HeadlessDevToolsManagerDelegate::HandleCommand(
    content::DevToolsAgentHost* agent_host,
    int session_id,
    base::DictionaryValue* command) {
  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);

  if (!browser_)
    return false;

  const base::Value* id_value = command->FindKey("id");
  const base::Value* method_value = command->FindKey("method");
  if (!id_value || !method_value)
    return false;

  const base::DictionaryValue* params = nullptr;
  command->GetDictionary("params", &params);

  const std::string& method = method_value->GetString();
  auto find_it = command_map_.find(method);
  if (find_it == command_map_.end()) {
    find_it = unhandled_command_map_.find(method);
    if (find_it != unhandled_command_map_.end())
      find_it->second.Run(agent_host, session_id, id_value->GetInt(), params);
    return false;
  }

  if (method.find("Browser.") == 0 &&
      agent_host->GetType() != content::DevToolsAgentHost::kTypeBrowser)
    return false;

  auto cmd_result =
      find_it->second.Run(agent_host, session_id, id_value->GetInt(), params);
  if (!cmd_result)
    return false;
  agent_host->SendProtocolMessageToClient(session_id,
                                          ToString(std::move(cmd_result)));
  return true;
}

    ~PrintHostMsg_SetOptionsFromDocument_Params() {
}

void PrintRenderFrameHelper::PrintHeaderAndFooter(
    blink::WebCanvas* canvas,
    int page_number,
    int total_pages,
    const blink::WebLocalFrame& source_frame,
    float webkit_scale_factor,
    const PageSizeMargins& page_layout,
    const PrintMsg_Print_Params& params) {
  cc::PaintCanvasAutoRestore auto_restore(canvas, true);
  canvas->scale(1 / webkit_scale_factor, 1 / webkit_scale_factor);

  blink::WebSize page_size(page_layout.margin_left + page_layout.margin_right +
                               page_layout.content_width,
                           page_layout.margin_top + page_layout.margin_bottom +
                               page_layout.content_height);

  blink::WebView* web_view = blink::WebView::Create(
      nullptr, blink::mojom::PageVisibilityState::kVisible);
  web_view->GetSettings()->SetJavaScriptEnabled(true);

  class HeaderAndFooterClient final : public blink::WebFrameClient {
   public:
    void BindToFrame(blink::WebLocalFrame* frame) override { frame_ = frame; }
    void FrameDetached(DetachType detach_type) override {
      frame_->FrameWidget()->Close();
      frame_->Close();
      frame_ = nullptr;
    }

   private:
    blink::WebLocalFrame* frame_;
  };
  HeaderAndFooterClient frame_client;
  blink::WebLocalFrame* frame = blink::WebLocalFrame::CreateMainFrame(
      web_view, &frame_client, nullptr, nullptr);
  blink::WebWidgetClient web_widget_client;
  blink::WebFrameWidget::Create(&web_widget_client, frame);

  base::Value html(base::UTF8ToUTF16(
      ui::ResourceBundle::GetSharedInstance().GetRawDataResource(
          IDR_PRINT_PREVIEW_PAGE)));
  ExecuteScript(frame, kPageLoadScriptFormat, html);

  auto options = base::MakeUnique<base::DictionaryValue>();
  options->SetDouble(kSettingHeaderFooterDate, base::Time::Now().ToJsTime());
  options->SetDouble("width", page_size.width);
  options->SetDouble("height", page_size.height);
  options->SetDouble("topMargin", page_layout.margin_top);
  options->SetDouble("bottomMargin", page_layout.margin_bottom);
  options->SetInteger("pageNumber", page_number);
  options->SetInteger("totalPages", total_pages);
   options->SetString("url", params.url);
   base::string16 title = source_frame.GetDocument().Title().Utf16();
   options->SetString("title", title.empty() ? params.title : title);
 
   ExecuteScript(frame, kPageSetupScriptFormat, *options);
 
  blink::WebPrintParams webkit_params(page_size);
  webkit_params.printer_dpi = GetDPI(&params);

  frame->PrintBegin(webkit_params);
  frame->PrintPage(0, canvas);
  frame->PrintEnd();

  web_view->Close();
}

  void OnScriptedPrint(const PrintHostMsg_ScriptedPrint_Params& scripted_params,
                       IPC::Message* reply_msg) {
    manager->OnScriptedPrint(scripted_params, reply_msg);
  }

void PrepareFrameAndViewForPrint::CopySelection(
    const WebPreferences& preferences) {
  ResizeForPrinting();
  std::string url_str = "data:text/html;charset=utf-8,";
  url_str.append(
      net::EscapeQueryParamValue(frame()->SelectionAsMarkup().Utf8(), false));
  RestoreSize();
  WebPreferences prefs = preferences;
  prefs.javascript_enabled = false;

  blink::WebView* web_view =
      blink::WebView::Create(this, blink::mojom::PageVisibilityState::kVisible);
  owns_web_view_ = true;
  content::RenderView::ApplyWebPreferences(prefs, web_view);
  blink::WebLocalFrame* main_frame =
      blink::WebLocalFrame::CreateMainFrame(web_view, this, nullptr, nullptr);
  frame_.Reset(main_frame);
  blink::WebFrameWidget::Create(this, main_frame);
  node_to_print_.Reset();

  blink::WebURLRequest request = blink::WebURLRequest(GURL(url_str));
  frame()->LoadRequest(request);
}

    PrintHostMsg_RequestPrintPreview_Params()
    : is_modifiable(false),
      webnode_only(false),
      has_selection(false),
      selection_only(false) {
}

void PageHandler::Navigate(const std::string& url,
                           Maybe<std::string> referrer,
                           Maybe<std::string> maybe_transition_type,
                           std::unique_ptr<NavigateCallback> callback) {
  GURL gurl(url);
  if (!gurl.is_valid()) {
    callback->sendFailure(Response::Error("Cannot navigate to invalid URL"));
    return;
  }

  WebContentsImpl* web_contents = GetWebContents();
  if (!web_contents) {
    callback->sendFailure(Response::InternalError());
    return;
  }

  ui::PageTransition type;
  std::string transition_type =
      maybe_transition_type.fromMaybe(Page::TransitionTypeEnum::Typed);
  if (transition_type == Page::TransitionTypeEnum::Link)
    type = ui::PAGE_TRANSITION_LINK;
  else if (transition_type == Page::TransitionTypeEnum::Typed)
    type = ui::PAGE_TRANSITION_TYPED;
  else if (transition_type == Page::TransitionTypeEnum::Auto_bookmark)
    type = ui::PAGE_TRANSITION_AUTO_BOOKMARK;
  else if (transition_type == Page::TransitionTypeEnum::Auto_subframe)
    type = ui::PAGE_TRANSITION_AUTO_SUBFRAME;
  else if (transition_type == Page::TransitionTypeEnum::Manual_subframe)
    type = ui::PAGE_TRANSITION_MANUAL_SUBFRAME;
  else if (transition_type == Page::TransitionTypeEnum::Generated)
    type = ui::PAGE_TRANSITION_GENERATED;
  else if (transition_type == Page::TransitionTypeEnum::Auto_toplevel)
    type = ui::PAGE_TRANSITION_AUTO_TOPLEVEL;
  else if (transition_type == Page::TransitionTypeEnum::Form_submit)
    type = ui::PAGE_TRANSITION_FORM_SUBMIT;
  else if (transition_type == Page::TransitionTypeEnum::Reload)
    type = ui::PAGE_TRANSITION_RELOAD;
  else if (transition_type == Page::TransitionTypeEnum::Keyword)
    type = ui::PAGE_TRANSITION_KEYWORD;
  else if (transition_type == Page::TransitionTypeEnum::Keyword_generated)
    type = ui::PAGE_TRANSITION_KEYWORD_GENERATED;
  else
    type = ui::PAGE_TRANSITION_TYPED;

  web_contents->GetController().LoadURL(
      gurl,
      Referrer(GURL(referrer.fromMaybe("")), blink::kWebReferrerPolicyDefault),
      type, std::string());
  if (IsBrowserSideNavigationEnabled()) {
    std::string frame_id =
        web_contents->GetMainFrame()->GetDevToolsFrameToken().ToString();
    if (navigate_callback_) {
      std::string error_string = net::ErrorToString(net::ERR_ABORTED);
      navigate_callback_->sendSuccess(frame_id, Maybe<std::string>(),
                                      Maybe<std::string>(error_string));
    }
    if (web_contents->GetMainFrame()->frame_tree_node()->navigation_request())
      navigate_callback_ = std::move(callback);
    else
      callback->sendSuccess(frame_id, Maybe<std::string>(),
                            Maybe<std::string>());
    return;
  }
  callback->fallThrough();
}

void HeadlessDevToolsManagerDelegate::BeginFrame(
    content::DevToolsAgentHost* agent_host,
    int session_id,
    int command_id,
    const base::DictionaryValue* params,
    const CommandCallback& callback) {
  DCHECK(callback);

  content::WebContents* web_contents = agent_host->GetWebContents();
  if (!web_contents) {
    callback.Run(CreateErrorResponse(command_id, kErrorServerError,
                                     "Command not supported on this endpoint"));
    return;
  }

  HeadlessWebContentsImpl* headless_contents =
      HeadlessWebContentsImpl::From(browser_.get(), web_contents);
  if (!headless_contents->begin_frame_control_enabled()) {
    callback.Run(CreateErrorResponse(
        command_id, kErrorServerError,
        "Command is only supported if BeginFrameControl is enabled."));
    return;
  }

  base::Time frame_time;
  base::TimeTicks frame_timeticks;
  base::TimeTicks deadline;
  base::TimeDelta interval;

  if (const base::Value* frame_time_value = params->FindKey("frameTime")) {
    frame_time = base::Time::FromJsTime(frame_time_value->GetDouble());
    base::TimeDelta delta = frame_time - base::Time::UnixEpoch();
    frame_timeticks = base::TimeTicks::UnixEpoch() + delta;
  } else {
    frame_timeticks = base::TimeTicks::Now();
  }

  if (const base::Value* interval_value = params->FindKey("interval")) {
    double interval_double = interval_value->GetDouble();
    if (interval_double <= 0) {
      callback.Run(CreateErrorResponse(command_id, kErrorInvalidParam,
                                       "interval has to be greater than 0"));
      return;
    }
    interval = base::TimeDelta::FromMillisecondsD(interval_double);
  } else {
    interval = viz::BeginFrameArgs::DefaultInterval();
  }

  if (const base::Value* deadline_value = params->FindKey("deadline")) {
    base::TimeDelta delta =
        base::Time::FromDoubleT(deadline_value->GetDouble()) - frame_time;
    if (delta <= base::TimeDelta()) {
      callback.Run(CreateErrorResponse(command_id, kErrorInvalidParam,
                                       "deadline has to be after frameTime"));
      return;
    }
    deadline = frame_timeticks + delta;
  } else {
    deadline = frame_timeticks + interval;
  }

  bool capture_screenshot = false;
  ImageEncoding encoding = ImageEncoding::kPng;
  int quality = kDefaultScreenshotQuality;

  const base::Value* value = nullptr;
  const base::DictionaryValue* screenshot_dict = nullptr;
  if (params->Get("screenshot", &value)) {
    if (!value->GetAsDictionary(&screenshot_dict)) {
      callback.Run(CreateInvalidParamResponse(command_id, "screenshot"));
      return;
    }

    capture_screenshot = true;

    if (const base::Value* format_value = screenshot_dict->FindKey("format")) {
      const std::string& format = format_value->GetString();
      if (format == kPng) {
        encoding = ImageEncoding::kPng;
      } else if (format == kJpeg) {
        encoding = ImageEncoding::kJpeg;
      } else {
        callback.Run(
            CreateInvalidParamResponse(command_id, "screenshot.format"));
        return;
      }
    }

    if (const base::Value* quality_value = screenshot_dict->FindKey("quality")) {
      quality = quality_value->GetInt();
      if (quality < 0 || quality > 100) {
        callback.Run(CreateErrorResponse(
            command_id, kErrorInvalidParam,
            "screenshot.quality has to be in range 0..100"));
        return;
      }
    }
  }

  if (base::CommandLine::ForCurrentProcess()->HasSwitch(
          cc::switches::kRunAllCompositorStagesBeforeDraw) &&
      headless_contents->HasPendingFrame()) {
    LOG(WARNING) << "A BeginFrame is already in flight. In "
                    "--run-all-compositor-stages-before-draw mode, only a "
                    "single BeginFrame should be active at the same time.";
  }

  headless_contents->BeginFrame(frame_timeticks, deadline, interval,
                                capture_screenshot,
                                base::Bind(&OnBeginFrameFinished, command_id,
                                           callback, encoding, quality));
}

void PageHandler::SetRenderer(RenderProcessHost* process_host,
                              RenderFrameHostImpl* frame_host) {
  if (host_ == frame_host)
    return;

  RenderWidgetHostImpl* widget_host =
      host_ ? host_->GetRenderWidgetHost() : nullptr;
  if (widget_host) {
    registrar_.Remove(
        this,
        content::NOTIFICATION_RENDER_WIDGET_VISIBILITY_CHANGED,
        content::Source<RenderWidgetHost>(widget_host));
  }

  host_ = frame_host;
  widget_host = host_ ? host_->GetRenderWidgetHost() : nullptr;

  if (widget_host) {
    registrar_.Add(
        this,
        content::NOTIFICATION_RENDER_WIDGET_VISIBILITY_CHANGED,
        content::Source<RenderWidgetHost>(widget_host));
  }
}
