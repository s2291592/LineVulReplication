static int iwbmp_read_bitfields(struct iwbmprcontext *rctx)
{
	iw_byte buf[12];
	int k;

	if(!iwbmp_read(rctx,buf,12)) return 0;

	for(k=0;k<3;k++) {
		rctx->bf_mask[k] = iw_get_ui32le(&buf[k*4]);
		if(rctx->bf_mask[k]==0) return 0;

		if(!process_bf_mask(rctx,k)) return 0;
	}

	return 1;
}

static void bmpw_convert_row_1(const iw_byte *srcrow, iw_byte *dstrow, int width)
{
	int i;
	int m;

	for(i=0;i<width;i++) {
		m = i%8;
		if(m==0)
			dstrow[i/8] = srcrow[i]<<7;
		else
			dstrow[i/8] |= srcrow[i]<<(7-m);
	}
}

static void iw_make_nearest_color_table(struct iw_context *ctx, double **ptable,
	const struct iw_image *img, const struct iw_csdescr *csdescr)
{
	int ncolors;
	int nentries;
	int i;
	double *tbl;
	double prev;
	double curr;

	if(ctx->no_gamma) return;
	if(csdescr->cstype==IW_CSTYPE_LINEAR) return;
	if(img->sampletype==IW_SAMPLETYPE_FLOATINGPOINT) return;
	if(img->bit_depth != ctx->img2.bit_depth) return;

	ncolors = (1 << img->bit_depth);
	if(ncolors>256) return;
	nentries = ncolors-1;

	if( ((size_t)img->width)*img->height <= 512 ) return;

	tbl = iw_malloc(ctx,nentries*sizeof(double));
	if(!tbl) return;

	prev = 0.0;
	for(i=0;i<nentries;i++) {
		curr = x_to_linear_sample( ((double)(i+1))/(ncolors-1), csdescr);
		tbl[i] = (prev + curr)/2.0;
		prev = curr;
	}

	*ptable = tbl;
}

static int iwbmp_write_bmp_v45header_fields(struct iwbmpwcontext *wctx)
{
	iw_byte header[124];
	unsigned int intent_bmp_style;

	iw_zeromem(header,sizeof(header));

	if(wctx->uses_bitfields) {
		iw_set_ui32le(&header[40],wctx->bf_mask[0]);
		iw_set_ui32le(&header[44],wctx->bf_mask[1]);
		iw_set_ui32le(&header[48],wctx->bf_mask[2]);
		iw_set_ui32le(&header[52],wctx->bf_mask[3]);
	}

	if(wctx->csdescr.cstype==IW_CSTYPE_SRGB && !wctx->no_cslabel)
		iw_set_ui32le(&header[56],IWBMPCS_SRGB);
	else
		iw_set_ui32le(&header[56],IWBMPCS_DEVICE_RGB);

	switch(wctx->img->rendering_intent) {
	case IW_INTENT_PERCEPTUAL: intent_bmp_style = 4; break;
	case IW_INTENT_RELATIVE:   intent_bmp_style = 2; break;
	case IW_INTENT_SATURATION: intent_bmp_style = 1; break;
	case IW_INTENT_ABSOLUTE:   intent_bmp_style = 8; break;
	default: intent_bmp_style = 4;
	}
	iw_set_ui32le(&header[108],intent_bmp_style);

	iwbmp_write(wctx,&header[40],124-40);
	return 1;
}

static void negate_target_image(struct iw_context *ctx)
{
	int channel;
	struct iw_channelinfo_out *ci;
	int i,j;
	size_t pos;
	iw_float32 s;
	unsigned int n;

	for(channel=0; channel<ctx->img2_numchannels; channel++) {
		ci = &ctx->img2_ci[channel];
		if(ci->channeltype == IW_CHANNELTYPE_ALPHA) continue; // Don't negate alpha channels

		if(ctx->img2.sampletype==IW_SAMPLETYPE_FLOATINGPOINT) {
			for(j=0; j<ctx->img2.height; j++) {
				for(i=0; i<ctx->img2.width; i++) {
					pos = j*ctx->img2.bpr + ctx->img2_numchannels*i*4 + channel*4;
					s = iw_get_float32(&ctx->img2.pixels[pos]);
					iw_put_float32(&ctx->img2.pixels[pos], ((iw_float32)1.0)-s);
				}
			}
		}
		else if(ctx->img2.bit_depth==8) {
			for(j=0; j<ctx->img2.height; j++) {
				for(i=0; i<ctx->img2.width; i++) {
					pos = j*ctx->img2.bpr + ctx->img2_numchannels*i + channel;
					ctx->img2.pixels[pos] = ci->maxcolorcode_int-ctx->img2.pixels[pos];
				}
			}
		}
		else if(ctx->img2.bit_depth==16) {
			for(j=0; j<ctx->img2.height; j++) {
				for(i=0; i<ctx->img2.width; i++) {
					pos = j*ctx->img2.bpr + ctx->img2_numchannels*i*2 + channel*2;
					n = ctx->img2.pixels[pos]*256 + ctx->img2.pixels[pos+1];
					n = ci->maxcolorcode_int - n;
					ctx->img2.pixels[pos] = (n&0xff00)>>8;
					ctx->img2.pixels[pos+1] = n&0x00ff;
				}
			}
		}
	}
}

static IW_INLINE unsigned int get_raw_sample_4(struct iw_context *ctx,
	   int x, int y)
{
	unsigned short tmpui8;
	tmpui8 = ctx->img1.pixels[y*ctx->img1.bpr + x/2];
	if(x&0x1)
		tmpui8 = tmpui8&0x0f;
	else
		tmpui8 = tmpui8>>4;
	return tmpui8;
}

static void rle4_write_unc_and_run(struct rle_context *rlectx)
{
	iw_byte dstbuf[2];

	rle4_write_unc(rlectx);

	if(rlectx->run_len<1) {
		return;
	}
	if(rlectx->run_len>255) {
		iw_set_error(rlectx->ctx,"Internal: RLE encode error 6");
		return;
	}

	dstbuf[0] = (iw_byte)rlectx->run_len;
	dstbuf[1] = rlectx->run_byte;
	iwbmp_write(rlectx->wctx,dstbuf,2);
	rlectx->total_bytes_written+=2;

	rlectx->pending_data_start+=rlectx->run_len;
	rlectx->run_len=0;
}

static void bmpw_convert_row_16_32(struct iwbmpwcontext *wctx, const iw_byte *srcrow,
	iw_byte *dstrow, int width)
{
	int i,k;
	unsigned int v;
	int num_src_samples;
	unsigned int src_sample[4];

	for(k=0;k<4;k++) src_sample[k]=0;

	num_src_samples = iw_imgtype_num_channels(wctx->img->imgtype);

	for(i=0;i<width;i++) {

		for(k=0;k<num_src_samples;k++) {
			if(wctx->img->bit_depth==16) {
				src_sample[k] = (srcrow[num_src_samples*2*i + k*2]<<8) | srcrow[num_src_samples*2*i + k*2 +1];
			}
			else {
				src_sample[k] = srcrow[num_src_samples*i + k];
			}
		}

		switch(wctx->img->imgtype) {
		case IW_IMGTYPE_GRAY:
			v = src_sample[0] << wctx->bf_amt_to_shift[0];
			v |= src_sample[0] << wctx->bf_amt_to_shift[1];
			v |= src_sample[0] << wctx->bf_amt_to_shift[2];
			break;
		case IW_IMGTYPE_RGBA:
			v = src_sample[0] << wctx->bf_amt_to_shift[0];
			v |= src_sample[1] << wctx->bf_amt_to_shift[1];
			v |= src_sample[2] << wctx->bf_amt_to_shift[2];
			v |= src_sample[3] << wctx->bf_amt_to_shift[3];
			break;
		case IW_IMGTYPE_GRAYA:
			v = src_sample[0] << wctx->bf_amt_to_shift[0];
			v |= src_sample[0] << wctx->bf_amt_to_shift[1];
			v |= src_sample[0] << wctx->bf_amt_to_shift[2];
			v |= src_sample[1] << wctx->bf_amt_to_shift[3];
			break;
		default:
			v = src_sample[0] << wctx->bf_amt_to_shift[0];
			v |= src_sample[1] << wctx->bf_amt_to_shift[1];
			v |= src_sample[2] << wctx->bf_amt_to_shift[2];
		}

		if(wctx->bitcount==32) {
			dstrow[i*4+0] = (iw_byte)(v&0xff);
			dstrow[i*4+1] = (iw_byte)((v&0x0000ff00)>>8);
			dstrow[i*4+2] = (iw_byte)((v&0x00ff0000)>>16);
			dstrow[i*4+3] = (iw_byte)((v&0xff000000)>>24);
		}
		else {
			dstrow[i*2+0] = (iw_byte)(v&0xff);
			dstrow[i*2+1] = (iw_byte)(v>>8);
		}
	}
}

static void iw_set_out_channeltypes(struct iw_context *ctx)
{
	int i;
	for(i=0;i<ctx->img2_numchannels;i++) {
		ctx->img2_ci[i].channeltype = iw_get_channeltype(ctx->img2.imgtype,i);
	}
}

static int iw_process_rows_intermediate_to_final(struct iw_context *ctx, int intermed_channel,
const struct iw_csdescr *out_csdescr)
{
int i,j;
int z;
int k;
int retval=0;
iw_tmpsample tmpsamp;
iw_tmpsample alphasamp = 0.0;
iw_tmpsample *inpix_tofree = NULL; // Used if we need a separate temp buffer for input samples
iw_tmpsample *outpix_tofree = NULL; // Used if we need a separate temp buffer for output samples
// Do any of the output channels use error-diffusion dithering?
int using_errdiffdither = 0;
int output_channel;
int is_alpha_channel;
int bkgd_has_transparency;
double tmpbkgdalpha=0.0;
int alt_bkgd = 0; // Nonzero if we should use bkgd2 for this sample
struct iw_resize_settings *rs = NULL;
int ditherfamily, dithersubtype;
struct iw_channelinfo_intermed *int_ci;
struct iw_channelinfo_out *out_ci;

iw_tmpsample *in_pix = NULL;
iw_tmpsample *out_pix = NULL;
int num_in_pix;
int num_out_pix;

num_in_pix = ctx->intermed_canvas_width;
num_out_pix = ctx->img2.width;

int_ci = &ctx->intermed_ci[intermed_channel];
output_channel = int_ci->corresponding_output_channel;
	out_ci = &ctx->img2_ci[output_channel];
is_alpha_channel = (int_ci->channeltype==IW_CHANNELTYPE_ALPHA);
bkgd_has_transparency = iw_bkgd_has_transparency(ctx);

inpix_tofree = (iw_tmpsample*)iw_malloc(ctx, num_in_pix * sizeof(iw_tmpsample));
in_pix = inpix_tofree;

// We need an output buffer.
outpix_tofree = (iw_tmpsample*)iw_malloc(ctx, num_out_pix * sizeof(iw_tmpsample));
if(!outpix_tofree) goto done;
out_pix = outpix_tofree;

// Decide if the 'nearest color table' optimization can be used
if(ctx->nearest_color_table && !is_alpha_channel &&
out_ci->ditherfamily==IW_DITHERFAMILY_NONE &&
out_ci->color_count==0)
{
out_ci->use_nearest_color_table = 1;
}
else {
out_ci->use_nearest_color_table = 0;
}

// Seed the PRNG, if necessary.
ditherfamily = out_ci->ditherfamily;
dithersubtype = out_ci->dithersubtype;
if(ditherfamily==IW_DITHERFAMILY_RANDOM) {
// Decide what random seed to use. The alpha channel always has its own
// seed. If using "r" (not "r2") dithering, every channel has its own seed.
if(dithersubtype==IW_DITHERSUBTYPE_SAMEPATTERN && out_ci->channeltype!=IW_CHANNELTYPE_ALPHA)
{
iwpvt_prng_set_random_seed(ctx->prng,ctx->random_seed);
}
else {
iwpvt_prng_set_random_seed(ctx->prng,ctx->random_seed+out_ci->channeltype);
}
}

// Initialize Floyd-Steinberg dithering.
if(output_channel>=0 && out_ci->ditherfamily==IW_DITHERFAMILY_ERRDIFF) {
using_errdiffdither = 1;
for(i=0;i<ctx->img2.width;i++) {
for(k=0;k<IW_DITHER_MAXROWS;k++) {
ctx->dither_errors[k][i] = 0.0;
}
}
}

rs=&ctx->resize_settings[IW_DIMENSION_H];

// If the resize context for this dimension already exists, we should be
// able to reuse it. Otherwise, create a new one.
if(!rs->rrctx) {
rs->rrctx = iwpvt_resize_rows_init(ctx,rs,int_ci->channeltype,
num_in_pix, num_out_pix);
if(!rs->rrctx) goto done;
}

for(j=0;j<ctx->intermed_canvas_height;j++) {

// As needed, either copy the input pixels to a temp buffer (inpix, which
// ctx->in_pix already points to), or point ctx->in_pix directly to the
// intermediate data.
if(is_alpha_channel) {
for(i=0;i<num_in_pix;i++) {
inpix_tofree[i] = ctx->intermediate_alpha32[((size_t)j)*ctx->intermed_canvas_width+i];
}
}
else {
for(i=0;i<num_in_pix;i++) {
inpix_tofree[i] = ctx->intermediate32[((size_t)j)*ctx->intermed_canvas_width+i];
}
}

// Resize ctx->in_pix to ctx->out_pix.
iwpvt_resize_row_main(rs->rrctx,in_pix,out_pix);

if(ctx->intclamp)
clamp_output_samples(ctx,out_pix,num_out_pix);

// If necessary, copy the resized samples to the final_alpha image
if(is_alpha_channel && outpix_tofree && ctx->final_alpha32) {
for(i=0;i<num_out_pix;i++) {
ctx->final_alpha32[((size_t)j)*ctx->img2.width+i] = (iw_float32)outpix_tofree[i];
}
}

// Now convert the out_pix and put them in the final image.

if(output_channel == -1) {
// No corresponding output channel.
// (Presumably because this is an alpha channel that's being
// removed because we're applying a background.)
goto here;
}

for(z=0;z<ctx->img2.width;z++) {
// For decent Floyd-Steinberg dithering, we need to process alternate
// rows in reverse order.
if(using_errdiffdither && (j%2))
i=ctx->img2.width-1-z;
else
i=z;

tmpsamp = out_pix[i];

if(ctx->bkgd_checkerboard) {
alt_bkgd = (((ctx->bkgd_check_origin[IW_DIMENSION_H]+i)/ctx->bkgd_check_size)%2) !=
(((ctx->bkgd_check_origin[IW_DIMENSION_V]+j)/ctx->bkgd_check_size)%2);
}

if(bkgd_has_transparency) {
tmpbkgdalpha = alt_bkgd ? ctx->bkgd2alpha : ctx->bkgd1alpha;
}

if(int_ci->need_unassoc_alpha_processing) {
// Convert color samples back to unassociated alpha.
alphasamp = ctx->final_alpha32[((size_t)j)*ctx->img2.width + i];

if(alphasamp!=0.0) {
tmpsamp /= alphasamp;
}

if(ctx->apply_bkgd && ctx->apply_bkgd_strategy==IW_BKGD_STRATEGY_LATE) {
// Apply a background color (or checkerboard pattern).
double bkcolor;
bkcolor = alt_bkgd ? out_ci->bkgd2_color_lin : out_ci->bkgd1_color_lin;

if(bkgd_has_transparency) {
tmpsamp = tmpsamp*alphasamp + bkcolor*tmpbkgdalpha*(1.0-alphasamp);
}
else {
tmpsamp = tmpsamp*alphasamp + bkcolor*(1.0-alphasamp);
}
}
}
else if(is_alpha_channel && bkgd_has_transparency) {
// Composite the alpha of the foreground over the alpha of the background.
tmpsamp = tmpsamp + tmpbkgdalpha*(1.0-tmpsamp);
}

if(ctx->img2.sampletype==IW_SAMPLETYPE_FLOATINGPOINT)
put_sample_convert_from_linear_flt(ctx,tmpsamp,i,j,output_channel,out_csdescr);
else
put_sample_convert_from_linear(ctx,tmpsamp,i,j,output_channel,out_csdescr);

}

if(using_errdiffdither) {
// Move "next row" error data to "this row", and clear the "next row".
// TODO: Obviously, it would be more efficient to just swap pointers
// to the rows.
for(i=0;i<ctx->img2.width;i++) {
// Move data in all rows but the first row up one row.
for(k=0;k<IW_DITHER_MAXROWS-1;k++) {
ctx->dither_errors[k][i] = ctx->dither_errors[k+1][i];
}
// Clear the last row.
ctx->dither_errors[IW_DITHER_MAXROWS-1][i] = 0.0;
}
}

here:
;
}

retval=1;

done:
if(rs && rs->disable_rrctx_cache && rs->rrctx) {
// In some cases, the channels may need different resize contexts.
// Delete the current context, so that it doesn't get reused.
iwpvt_resize_rows_done(rs->rrctx);
rs->rrctx = NULL;
}
if(inpix_tofree) iw_free(ctx,inpix_tofree);
if(outpix_tofree) iw_free(ctx,outpix_tofree);

return retval;
}

static void iwbmpr_misc_config(struct iw_context *ctx, struct iwbmprcontext *rctx)
{
	if(!rctx->topdown) {
		iw_reorient_image(ctx,IW_REORIENT_FLIP_V);
	}

	iw_set_input_colorspace(ctx,&rctx->csdescr);

	if(rctx->bitcount==16 || rctx->bitcount==32) {
		if(rctx->bf_bits_count[0]!=8 || rctx->bf_bits_count[1]!=8 || rctx->bf_bits_count[2]!=8 ||
			(IW_IMGTYPE_HAS_ALPHA(rctx->img->imgtype) && rctx->bf_bits_count[3]!=8))
		{
			iw_set_input_max_color_code(ctx,0, (1 << rctx->bf_bits_count[0])-1 );
			iw_set_input_max_color_code(ctx,1, (1 << rctx->bf_bits_count[1])-1 );
			iw_set_input_max_color_code(ctx,2, (1 << rctx->bf_bits_count[2])-1 );
			if(IW_IMGTYPE_HAS_ALPHA(rctx->img->imgtype)) {
				iw_set_input_max_color_code(ctx,3, (1 << rctx->bf_bits_count[3])-1 );
			}
		}
	}
}

static int setup_16_32bit(struct iwbmpwcontext *wctx,
	int mcc_r, int mcc_g, int mcc_b, int mcc_a)
{
	int has_alpha;

	has_alpha = IW_IMGTYPE_HAS_ALPHA(wctx->img->imgtype);

	if(wctx->bmpversion<3) {
		iw_set_errorf(wctx->ctx,"Bit depth incompatible with BMP version %d",
			wctx->bmpversion);
		return 0;
	}

	if(has_alpha && wctx->bmpversion<5) {
		iw_set_error(wctx->ctx,"Internal: Attempt to write v3 16- or 32-bit image with transparency");
		return 0;
	}

	wctx->maxcolor[0] = mcc_r;
	wctx->maxcolor[1] = mcc_g;
	wctx->maxcolor[2] = mcc_b;
	if(has_alpha) wctx->maxcolor[3] = mcc_a;

	if(!iwbmp_calc_bitfields_masks(wctx,has_alpha?4:3)) return 0;

	if(mcc_r==31 && mcc_g==31 && mcc_b==31 && !has_alpha) {
		wctx->bitfields_size = 0;
	}
	else {
		wctx->uses_bitfields = 1;
		wctx->bitfields_size = (wctx->bmpversion==3) ? 12 : 0;
	}
	return 1;
}

static void iw_process_bkgd_label(struct iw_context *ctx)
{
	int ret;
	int k;
	struct iw_color clr;
	double maxcolor;
	unsigned int tmpu;

	if(!(ctx->output_profile&IW_PROFILE_PNG_BKGD) &&
		!(ctx->output_profile&IW_PROFILE_RGB8_BKGD) &&
		!(ctx->output_profile&IW_PROFILE_RGB16_BKGD))
	{
		return;
	}

	ret = get_output_bkgd_label_lin(ctx,&clr);
	if(!ret) return;

	if(ctx->to_grayscale) {
		iw_tmpsample g;
		g = iw_color_to_grayscale(ctx, clr.c[0], clr.c[1], clr.c[2]);
		clr.c[0] = clr.c[1] = clr.c[2] = g;
	}

	if(ctx->output_profile&IW_PROFILE_RGB8_BKGD) {
		maxcolor=255.0;
	}
	else if(ctx->output_profile&IW_PROFILE_RGB16_BKGD) {
		maxcolor=65535.0;
	}
	else if(ctx->img2.bit_depth==8) {
		maxcolor=255.0;
	}
	else if(ctx->img2.bit_depth==16) {
		maxcolor=65535.0;
	}
	else {
		return;
	}

	for(k=0;k<3;k++) {
		tmpu = calc_sample_convert_from_linear(ctx, clr.c[k], &ctx->img2cs, maxcolor);
		ctx->img2.bkgdlabel.c[k] = ((double)tmpu)/maxcolor;
	}
	tmpu = iw_scale_to_int(clr.c[3],(unsigned int)maxcolor);
	ctx->img2.bkgdlabel.c[3] = ((double)tmpu)/maxcolor;

	ctx->img2.has_bkgdlabel = 1;
}

static void init_channel_info(struct iw_context *ctx)
{
	int i;

	ctx->img1_imgtype_logical = ctx->img1.imgtype;

	if(ctx->resize_settings[IW_DIMENSION_H].edge_policy==IW_EDGE_POLICY_TRANSPARENT ||
		ctx->resize_settings[IW_DIMENSION_V].edge_policy==IW_EDGE_POLICY_TRANSPARENT)
	{
		if(ctx->img1.imgtype==IW_IMGTYPE_GRAY) {
			ctx->img1_imgtype_logical = IW_IMGTYPE_GRAYA;
		}
		else if(ctx->img1.imgtype==IW_IMGTYPE_RGB)
			ctx->img1_imgtype_logical = IW_IMGTYPE_RGBA;
	}

	ctx->img1_numchannels_physical = iw_imgtype_num_channels(ctx->img1.imgtype);
	ctx->img1_numchannels_logical = iw_imgtype_num_channels(ctx->img1_imgtype_logical);
	ctx->img1_alpha_channel_index = iw_imgtype_alpha_channel_index(ctx->img1_imgtype_logical);

	iw_set_input_channeltypes(ctx);

	ctx->img2.imgtype = ctx->img1_imgtype_logical; // default
	ctx->img2_numchannels = ctx->img1_numchannels_logical; // default
	ctx->intermed_numchannels = ctx->img1_numchannels_logical; // default

	for(i=0;i<ctx->img1_numchannels_logical;i++) {
		ctx->intermed_ci[i].channeltype = ctx->img1_ci[i].channeltype;
		ctx->intermed_ci[i].corresponding_input_channel = i;
		ctx->img2_ci[i].channeltype = ctx->img1_ci[i].channeltype;
		if(i>=ctx->img1_numchannels_physical) {
			ctx->img1_ci[i].disable_fast_get_sample = 1;
		}
	}
}

static void decide_strategy(struct iw_context *ctx, int *ps1, int *ps2)
{
	int s1, s2;

	switch(ctx->img1_imgtype_logical) {
	case IW_IMGTYPE_RGBA:
		if(ctx->to_grayscale) {
			s1=IW_STRAT1_RGBA_GA;
			s2=IW_STRAT2_GA_GA;
		}
		else {
			s1=IW_STRAT1_RGBA_RGBA;
			s2=IW_STRAT2_RGBA_RGBA;
		}
		break;
	case IW_IMGTYPE_RGB:
		if(ctx->to_grayscale) {
			s1=IW_STRAT1_RGB_G;
			s2=IW_STRAT2_G_G;
		}
		else {
			s1=IW_STRAT1_RGB_RGB;
			s2=IW_STRAT2_RGB_RGB;
		}
		break;
	case IW_IMGTYPE_GRAYA:
		if(ctx->to_grayscale) {
			s1=IW_STRAT1_GA_GA;
			s2=IW_STRAT2_GA_GA;
		}
		else {
			s1=IW_STRAT1_GA_RGBA;
			s2=IW_STRAT2_RGBA_RGBA;
		}
		break;
	default:
		if(ctx->to_grayscale) {
			s1=IW_STRAT1_G_G;
			s2=IW_STRAT2_G_G;
		}
		else {
			s1=IW_STRAT1_G_RGB;
			s2=IW_STRAT2_RGB_RGB;
		}
	}

	if(ctx->apply_bkgd && ctx->apply_bkgd_strategy==IW_BKGD_STRATEGY_EARLY) {
		if(s1==IW_STRAT1_RGBA_RGBA) {
			s1=IW_STRAT1_RGBA_RGB;
			s2=IW_STRAT2_RGB_RGB;
		}
		else if(s1==IW_STRAT1_GA_GA) {
			s1=IW_STRAT1_GA_G;
			s2=IW_STRAT2_G_G;
		}
		else if(s1==IW_STRAT1_GA_RGBA) {
			s1=IW_STRAT1_GA_RGB;
			s2=IW_STRAT2_RGB_RGB;
		}
		else if(s1==IW_STRAT1_RGBA_GA) {
			s1=IW_STRAT1_RGBA_G;
			s2=IW_STRAT2_G_G;
		}
	}

	if(ctx->apply_bkgd && !iw_bkgd_has_transparency(ctx)) {
		if(s2==IW_STRAT2_GA_GA) {
			s2=IW_STRAT2_GA_G;
		}
		else if(s2==IW_STRAT2_RGBA_RGBA) {
			s2=IW_STRAT2_RGBA_RGB;
		}
	}

	*ps1 = s1;
	*ps2 = s2;
}

static void prepare_grayscale(struct iw_context *ctx)
{
	switch(ctx->grayscale_formula) {
	case IW_GSF_STANDARD:
		ctx->grayscale_formula = IW_GSF_WEIGHTED;
		iw_set_grayscale_weights(ctx,0.212655,0.715158,0.072187);
		break;
	case IW_GSF_COMPATIBLE:
		ctx->grayscale_formula = IW_GSF_WEIGHTED;
		iw_set_grayscale_weights(ctx,0.299,0.587,0.114);
		break;
	}
}

static void bmpr_strip_alpha(struct iw_image *img)
{
	int i,j;
	size_t oldbpr;

	img->imgtype = IW_IMGTYPE_RGB;
	oldbpr = img->bpr;
	img->bpr = iw_calc_bytesperrow(img->width,24);

	for(j=0;j<img->height;j++) {
		for(i=0;i<img->width;i++) {
			img->pixels[j*img->bpr + i*3 + 0] = img->pixels[j*oldbpr + i*4 + 0];
			img->pixels[j*img->bpr + i*3 + 1] = img->pixels[j*oldbpr + i*4 + 1];
			img->pixels[j*img->bpr + i*3 + 2] = img->pixels[j*oldbpr + i*4 + 2];
		}
	}
}

static int iwbmp_read_info_header(struct iwbmprcontext *rctx)
{
	iw_byte buf[124];
	int retval = 0;
	size_t n;

	if(!iwbmp_read(rctx,buf,4)) goto done;
	rctx->infoheader_size = iw_get_ui32le(&buf[0]);
	if(rctx->infoheader_size<12) goto done;

	n = rctx->infoheader_size;
	if(n>sizeof(buf)) n=sizeof(buf);
	if(!iwbmp_read(rctx,&buf[4],n-4)) goto done;

	if(rctx->infoheader_size==12) {
		rctx->bmpversion=2;
		if(!decode_v2_header(rctx,buf)) goto done;
	}
	else if(rctx->infoheader_size==16 || rctx->infoheader_size==40 || rctx->infoheader_size==64) {
		rctx->bmpversion=3;
		if(!decode_v3_header_fields(rctx,buf)) goto done;
	}
	else if(rctx->infoheader_size==108 || rctx->infoheader_size==52 || rctx->infoheader_size==56) {
		rctx->bmpversion=4;
		if(!decode_v3_header_fields(rctx,buf)) goto done;
		if(!decode_v4_header_fields(rctx,buf)) goto done;
	}
	else if(rctx->infoheader_size==124) {
		rctx->bmpversion=5;
		if(!decode_v3_header_fields(rctx,buf)) goto done;
		if(!decode_v4_header_fields(rctx,buf)) goto done;
		if(!decode_v5_header_fields(rctx,buf)) goto done;
	}
	else {
		iw_set_error(rctx->ctx,"Unsupported BMP version");
		goto done;
	}

	if(!iw_check_image_dimensions(rctx->ctx,rctx->width,rctx->height)) {
		goto done;
	}

	retval = 1;

done:
	return retval;
}

static void put_raw_sample_flt32(struct iw_context *ctx, double s,
	   int x, int y, int channel)
{
	size_t pos;
	pos = y*ctx->img2.bpr + (ctx->img2_numchannels*x + channel)*4;
	iw_put_float32(&ctx->img2.pixels[pos], (iw_float32)s);
}

static int iwbmp_write_pixels_compressed(struct iwbmpwcontext *wctx,
	struct iw_image *img)
{
	struct rle_context rlectx;
	int j;
	int retval = 0;

	iw_zeromem(&rlectx,sizeof(struct rle_context));

	rlectx.ctx = wctx->ctx;
	rlectx.wctx = wctx;
	rlectx.total_bytes_written = 0;
	rlectx.img_width = img->width;

	for(j=img->height-1;j>=0;j--) {
		rlectx.srcrow = &img->pixels[j*img->bpr];
		rlectx.cur_row = j;

		if(wctx->bitcount==4) {
			if(!rle4_compress_row(&rlectx)) goto done;
		}
		else if(wctx->bitcount==8) {
			if(!rle8_compress_row(&rlectx)) goto done;
		}
		else {
			goto done;
		}
	}

	if(!rle_patch_file_size(wctx,rlectx.total_bytes_written)) goto done;

	retval = 1;
done:
	return retval;
}

static IW_INLINE iw_tmpsample rec709_to_linear_sample(iw_tmpsample v_rec709)
{
	if(v_rec709 < 4.5*0.020) {
		return v_rec709/4.5;
	}
	else {
		return pow( (v_rec709+0.099)/1.099 , 1.0/0.45);
	}
}

static int rle8_compress_row(struct rle_context *rlectx)
{
	size_t i;
	iw_byte dstbuf[2];
	iw_byte next_byte;
	int next_pix_is_trns;
	int num_trns = 0; // number of consecutive transparent pixels seen
	int retval = 0;

	rlectx->pending_data_start=0;
	rlectx->unc_len=0;
	rlectx->run_len=0;

	for(i=0;i<rlectx->img_width;i++) {

		next_byte = rlectx->srcrow[i];

		next_pix_is_trns = (rlectx->wctx->pal->entry[next_byte].a==0);

		if(num_trns>0 && !next_pix_is_trns) {
			rle_write_trns(rlectx,num_trns);
			num_trns=0;
		}
		else if(next_pix_is_trns) {
			if (rlectx->unc_len>0 || rlectx->run_len>0) {
				rle8_write_unc_and_run(rlectx);
			}
			num_trns++;
			continue;
		}


		if(rlectx->run_len>0 && next_byte==rlectx->run_byte) {
			rlectx->run_len++;
		}
		else if(rlectx->run_len==0) {
			rlectx->run_len = 1;
			rlectx->run_byte = next_byte;
		}
		else if(rlectx->unc_len==0 && rlectx->run_len==1) {
			rlectx->unc_len++;
			rlectx->run_byte = next_byte;
		}
		else if(rlectx->unc_len>0 && rlectx->run_len<(rlectx->unc_len==1 ? 3U : 4U)) {
			rlectx->unc_len += rlectx->run_len;
			rlectx->run_len = 0;
			if(rlectx->unc_len>=3 && (rlectx->unc_len&0x1)) {
				rlectx->unc_len++;
			}
			else {
				rlectx->run_len = 1;
				rlectx->run_byte = next_byte;
			}
		}
		else {
			rle8_write_unc_and_run(rlectx);
			rlectx->run_len = 1;
			rlectx->run_byte = next_byte;
		}


		if(rlectx->unc_len>=254) {
			rle8_write_unc(rlectx);
		}
		else if(rlectx->unc_len>0 && (rlectx->unc_len+rlectx->run_len)>254) {
			rle8_write_unc(rlectx);
		}
		else if(rlectx->run_len>=255) {
			rle8_write_unc_and_run(rlectx);
		}


		if((rlectx->unc_len&0x1) && rlectx->unc_len!=1) {
			iw_set_errorf(rlectx->ctx,"Internal: BMP RLE encode error 1");
			goto done;
		}

		if(rlectx->unc_len>252) {
			iw_set_error(rlectx->ctx,"Internal: BMP RLE encode error 2");
			goto done;
		}

		if(rlectx->run_len>254) {
			iw_set_error(rlectx->ctx,"Internal: BMP RLE encode error 3");
			goto done;
		}
	}

	rle8_write_unc_and_run(rlectx);

	dstbuf[0]=0x00;
	dstbuf[1]= (rlectx->cur_row==0)? 0x01 : 0x00;
	iwbmp_write(rlectx->wctx,dstbuf,2);
	rlectx->total_bytes_written+=2;

	retval = 1;

done:
	return retval;
}

static size_t rle4_get_best_unc_split(size_t n)
{
	if(n<=255) return n;

	if(n==257 || n==510 || n==765) return 255;

	return 252;
}

static void bmpw_convert_row_24(struct iwbmpwcontext *wctx, const iw_byte *srcrow,
	iw_byte *dstrow, int width)
{
	int i;

	if(wctx->img->imgtype==IW_IMGTYPE_GRAY) {
		for(i=0;i<width;i++) {
			dstrow[i*3+0] = srcrow[i];
			dstrow[i*3+1] = srcrow[i];
			dstrow[i*3+2] = srcrow[i];
		}
	}
	else { // RGB
		for(i=0;i<width;i++) {
			dstrow[i*3+0] = srcrow[i*3+2];
			dstrow[i*3+1] = srcrow[i*3+1];
			dstrow[i*3+2] = srcrow[i*3+0];
		}
	}
}

static iw_float32 iw_get_float32(const iw_byte *m)
{
	int k;
	union su_union {
		iw_byte c[4];
		iw_float32 f;
	} volatile su;

	for(k=0;k<4;k++) {
		su.c[k] = m[k];
	}
	return su.f;
}

static unsigned int calc_sample_convert_from_linear(struct iw_context *ctx, iw_tmpsample samp_lin,
	   const struct iw_csdescr *csdescr, double overall_maxcolorcode)
{
	double s_lin_floor_1, s_lin_ceil_1;
	double s_cvt_floor_full, s_cvt_ceil_full;
	double d_floor, d_ceil;
	int is_exact;
	double s_full;

	if(samp_lin<0.0) samp_lin=0.0;
	if(samp_lin>1.0) samp_lin=1.0;

	is_exact = get_nearest_valid_colors(ctx,samp_lin,csdescr,
		&s_lin_floor_1, &s_lin_ceil_1,
		&s_cvt_floor_full, &s_cvt_ceil_full,
		overall_maxcolorcode, 0);

	if(is_exact) {
		s_full = s_cvt_floor_full;
		goto okay;
	}

	d_floor = samp_lin-s_lin_floor_1;
	d_ceil  = s_lin_ceil_1-samp_lin;

	if(d_ceil<=d_floor) s_full=s_cvt_ceil_full;
	else s_full=s_cvt_floor_full;

okay:
	return (unsigned int)(0.5+s_full);
}

static int decode_v5_header_fields(struct iwbmprcontext *rctx, const iw_byte *buf)
{
	unsigned int intent_bmp_style;
	int intent_iw_style;

	intent_bmp_style = iw_get_ui32le(&buf[108]);
	intent_iw_style = IW_INTENT_UNKNOWN;
	switch(intent_bmp_style) {
		case 1: intent_iw_style = IW_INTENT_SATURATION; break; // LCS_GM_BUSINESS
		case 2: intent_iw_style = IW_INTENT_RELATIVE; break; // LCS_GM_GRAPHICS
		case 4: intent_iw_style = IW_INTENT_PERCEPTUAL; break; // LCS_GM_IMAGES
		case 8: intent_iw_style = IW_INTENT_ABSOLUTE; break; // LCS_GM_ABS_COLORIMETRIC
	}
	rctx->img->rendering_intent = intent_iw_style;


	return 1;
}

static void bmpr_convert_row_8(struct iwbmprcontext *rctx,const iw_byte *src, size_t row)
{
	int i;
	for(i=0;i<rctx->width;i++) {
		rctx->img->pixels[row*rctx->img->bpr + i*3 + 0] = rctx->palette.entry[src[i]].r;
		rctx->img->pixels[row*rctx->img->bpr + i*3 + 1] = rctx->palette.entry[src[i]].g;
		rctx->img->pixels[row*rctx->img->bpr + i*3 + 2] = rctx->palette.entry[src[i]].b;
	}
}

IW_IMPL(int) iw_read_bmp_file(struct iw_context *ctx, struct iw_iodescr *iodescr)
{
	struct iwbmprcontext rctx;
	struct iw_image img;
	int retval = 0;

	iw_zeromem(&rctx,sizeof(struct iwbmprcontext));
	iw_zeromem(&img,sizeof(struct iw_image));

	rctx.ctx = ctx;
	rctx.img = &img;
	rctx.iodescr = iodescr;

	iw_make_srgb_csdescr_2(&rctx.csdescr);

	rctx.has_fileheader = !iw_get_value(ctx,IW_VAL_BMP_NO_FILEHEADER);
	if(rctx.has_fileheader) {
		if(!iwbmp_read_file_header(&rctx)) goto done;
	}
	if(!iwbmp_read_info_header(&rctx)) goto done;

	iwbmp_set_default_bitfields(&rctx);
	if(rctx.bitfields_nbytes>0) {
		if(!iwbmp_read_bitfields(&rctx)) goto done;
	}

	if(rctx.palette_entries>0) {
		if(!iwbmp_read_palette(&rctx)) goto done;
	}
	if(!iwbmp_read_bits(&rctx)) goto done;

	iw_set_input_image(ctx, &img);

	iwbmpr_misc_config(ctx, &rctx);

	retval = 1;
done:
	if(!retval) {
		iw_set_error(ctx,"BMP read failed");
		iw_free(ctx, img.pixels);
	}
	return retval;
}

static void bmpr_convert_row_1(struct iwbmprcontext *rctx,const iw_byte *src, size_t row)
{
	int i;
	int pal_index;

	for(i=0;i<rctx->width;i++) {
		pal_index = (src[i/8] & (1<<(7-i%8))) ? 1 : 0;
		rctx->img->pixels[row*rctx->img->bpr + i*3 + 0] = rctx->palette.entry[pal_index].r;
		rctx->img->pixels[row*rctx->img->bpr + i*3 + 1] = rctx->palette.entry[pal_index].g;
		rctx->img->pixels[row*rctx->img->bpr + i*3 + 2] = rctx->palette.entry[pal_index].b;
	}
}

static void iw_put_float32(iw_byte *m, iw_float32 s)
{
	int k;
	union su_union {
		iw_byte c[4];
		iw_float32 f;
	} volatile su;

	su.f = s;

	for(k=0;k<4;k++) {
		m[k] = su.c[k];
	}
}

IW_IMPL(int) iw_process_image(struct iw_context *ctx)
{
	int ret;
	int retval = 0;

	if(ctx->use_count>0) {
		iw_set_error(ctx,"Internal: Incorrect attempt to reprocess image");
		goto done;
	}
	ctx->use_count++;

	ret = iw_prepare_processing(ctx,ctx->canvas_width,ctx->canvas_height);
	if(!ret) goto done;

	ret = iw_process_internal(ctx);
	if(!ret) goto done;

	iwpvt_optimize_image(ctx);

	retval = 1;
done:
	return retval;
}

static int iwbmp_read_file_header(struct iwbmprcontext *rctx)
{
	iw_byte buf[14];

	if(!iwbmp_read(rctx,buf,14)) return 0;
	rctx->fileheader_size = 14;

	if(buf[0]=='B' && buf[1]=='A') { // OS/2 Bitmap Array
		if(!iwbmp_read(rctx,buf,14)) return 0;
		rctx->fileheader_size += 14;
	}

	if(buf[0]=='B' && buf[1]=='M') {
		;
	}
	else if((buf[0]=='C' && buf[1]=='I') || // OS/2 Color Icon
	   (buf[0]=='C' && buf[1]=='P') || // OS/2 Color Pointer
	   (buf[0]=='I' && buf[1]=='C') || // OS/2 Icon
	   (buf[0]=='P' && buf[1]=='T'))   // OS/2 Pointer
	{
		iw_set_error(rctx->ctx,"This type of BMP file is not supported");
		return 0;
	}
	else {
		iw_set_error(rctx->ctx,"Not a BMP file");
		return 0;
	}

	rctx->bfOffBits = iw_get_ui32le(&buf[10]);
	return 1;
}

static void iw_set_input_channeltypes(struct iw_context *ctx)
{
	int i;
	for(i=0;i<ctx->img1_numchannels_logical;i++) {
		ctx->img1_ci[i].channeltype = iw_get_channeltype(ctx->img1_imgtype_logical,i);
	}
}

static int iw_prepare_processing(struct iw_context *ctx, int w, int h)
{
	int i,j;
	int output_maxcolorcode_int;
	int strategy1, strategy2;
	int flag;

	if(ctx->output_profile==0) {
		iw_set_error(ctx,"Output profile not set");
		return 0;
	}

	if(!ctx->prng) {
		ctx->prng = iwpvt_prng_create(ctx);
	}

	if(ctx->randomize) {
		ctx->random_seed = iwpvt_util_randomize(ctx->prng);
	}

	if(ctx->req.out_true_valid) {
		ctx->resize_settings[IW_DIMENSION_H].out_true_size = ctx->req.out_true_width;
		ctx->resize_settings[IW_DIMENSION_V].out_true_size = ctx->req.out_true_height;
	}
	else {
		ctx->resize_settings[IW_DIMENSION_H].out_true_size = (double)w;
		ctx->resize_settings[IW_DIMENSION_V].out_true_size = (double)h;
	}

	if(!iw_check_image_dimensions(ctx,ctx->img1.width,ctx->img1.height)) {
		return 0;
	}
	if(!iw_check_image_dimensions(ctx,w,h)) {
		return 0;
	}

	if(ctx->to_grayscale) {
		prepare_grayscale(ctx);
	}

	init_channel_info(ctx);

	ctx->img2.width = w;
	ctx->img2.height = h;

	if(ctx->input_start_x<0) ctx->input_start_x=0;
	if(ctx->input_start_y<0) ctx->input_start_y=0;
	if(ctx->input_start_x>ctx->img1.width-1) ctx->input_start_x=ctx->img1.width-1;
	if(ctx->input_start_y>ctx->img1.height-1) ctx->input_start_x=ctx->img1.height-1;
	if(ctx->input_w<0) ctx->input_w = ctx->img1.width - ctx->input_start_x;
	if(ctx->input_h<0) ctx->input_h = ctx->img1.height - ctx->input_start_y;
	if(ctx->input_w<1) ctx->input_w = 1;
	if(ctx->input_h<1) ctx->input_h = 1;
	if(ctx->input_w>(ctx->img1.width-ctx->input_start_x)) ctx->input_w=ctx->img1.width-ctx->input_start_x;
	if(ctx->input_h>(ctx->img1.height-ctx->input_start_y)) ctx->input_h=ctx->img1.height-ctx->input_start_y;

	if(ctx->req.output_cs_valid) {
		ctx->img2cs = ctx->req.output_cs;

		if(ctx->output_profile&IW_PROFILE_ALWAYSLINEAR) {
			if(ctx->img2cs.cstype!=IW_CSTYPE_LINEAR) {
				iw_warning(ctx,"Forcing output colorspace to linear; required by the output format.");
				iw_make_linear_csdescr(&ctx->img2cs);
			}
		}
	}
	else {
		if(ctx->output_profile&IW_PROFILE_ALWAYSLINEAR) {
			iw_make_linear_csdescr(&ctx->img2cs);
		}
		else {
			iw_make_srgb_csdescr_2(&ctx->img2cs);
		}
	}

	if(ctx->img1.sampletype!=IW_SAMPLETYPE_FLOATINGPOINT) {
		ctx->input_maxcolorcode_int = (1 << ctx->img1.bit_depth)-1;
		ctx->input_maxcolorcode = (double)ctx->input_maxcolorcode_int;

		for(i=0;i<IW_CI_COUNT;i++) {
			if(ctx->img1_ci[i].maxcolorcode_int<=0) {
				ctx->img1_ci[i].maxcolorcode_int = ctx->input_maxcolorcode_int;
			}
			ctx->img1_ci[i].maxcolorcode_dbl = (double)ctx->img1_ci[i].maxcolorcode_int;

			if(ctx->img1_ci[i].maxcolorcode_int != ctx->input_maxcolorcode_int) {
				ctx->support_reduced_input_bitdepths = 1;
			}
		}
	}

	if(ctx->support_reduced_input_bitdepths ||
		ctx->img1.sampletype==IW_SAMPLETYPE_FLOATINGPOINT)
	{
		for(i=0;i<ctx->img1_numchannels_physical;i++) {
			ctx->img1_ci[i].disable_fast_get_sample=1;
		}
	}

	for(i=0;i<2;i++) { // horizontal, vertical
		for(j=0;j<3;j++) { // red, green, blue
			if(fabs(ctx->resize_settings[i].channel_offset[j])>0.00001) {
				ctx->resize_settings[i].use_offset=1;
			}
		}
	}

	if(ctx->to_grayscale &&
		(ctx->resize_settings[IW_DIMENSION_H].use_offset ||
		ctx->resize_settings[IW_DIMENSION_V].use_offset) )
	{
		iw_warning(ctx,"Disabling channel offset, due to grayscale output.");
		ctx->resize_settings[IW_DIMENSION_H].use_offset=0;
		ctx->resize_settings[IW_DIMENSION_V].use_offset=0;
	}

	decide_how_to_apply_bkgd(ctx);

	for(i=0;i<2;i++) {
		if(ctx->resize_settings[i].use_offset ||
		  (ctx->apply_bkgd &&
		   ctx->apply_bkgd_strategy==IW_BKGD_STRATEGY_EARLY &&
		   ctx->resize_settings[i].edge_policy==IW_EDGE_POLICY_TRANSPARENT))
		{
			ctx->resize_settings[i].disable_rrctx_cache=1;
		}
	}

	decide_strategy(ctx,&strategy1,&strategy2);

	switch(strategy1) { // input-to-intermediate
	case IW_STRAT1_RGBA_RGBA:
		ctx->intermed_imgtype = IW_IMGTYPE_RGBA;
		break;
	case IW_STRAT1_GA_RGBA:
		ctx->intermed_imgtype = IW_IMGTYPE_RGBA;
		ctx->intermed_ci[0].corresponding_input_channel=0;
		ctx->intermed_ci[1].corresponding_input_channel=0;
		ctx->intermed_ci[2].corresponding_input_channel=0;
		ctx->intermed_ci[3].corresponding_input_channel=1;
		break;
	case IW_STRAT1_RGB_RGB:
	case IW_STRAT1_RGBA_RGB:
		ctx->intermed_imgtype = IW_IMGTYPE_RGB;
		break;
	case IW_STRAT1_G_RGB:
	case IW_STRAT1_GA_RGB:
		ctx->intermed_imgtype = IW_IMGTYPE_RGB;
		ctx->intermed_ci[0].corresponding_input_channel=0;
		ctx->intermed_ci[1].corresponding_input_channel=0;
		ctx->intermed_ci[2].corresponding_input_channel=0;
		break;
	case IW_STRAT1_RGBA_GA:
		ctx->intermed_imgtype = IW_IMGTYPE_GRAYA;
		ctx->intermed_ci[0].cvt_to_grayscale=1;
		ctx->intermed_ci[0].corresponding_input_channel=0;
		ctx->intermed_ci[1].corresponding_input_channel=3;
		break;
	case IW_STRAT1_GA_GA:
		ctx->intermed_imgtype = IW_IMGTYPE_GRAYA;
		break;
	case IW_STRAT1_RGB_G:
		ctx->intermed_imgtype = IW_IMGTYPE_GRAY;
		ctx->intermed_ci[0].cvt_to_grayscale=1;
		ctx->intermed_ci[0].corresponding_input_channel=0;
		break;
	case IW_STRAT1_G_G:
		ctx->intermed_imgtype = IW_IMGTYPE_GRAY;
		ctx->intermed_ci[0].corresponding_input_channel=0;
		break;
	default:
		iw_set_errorf(ctx,"Internal error, unknown strategy %d",strategy1);
		return 0;
	}

	ctx->intermed_numchannels = iw_imgtype_num_channels(ctx->intermed_imgtype);
	ctx->intermed_alpha_channel_index = iw_imgtype_alpha_channel_index(ctx->intermed_imgtype);

	for(i=0;i<ctx->intermed_numchannels;i++) {
		ctx->intermed_ci[i].corresponding_output_channel = i;
	}

	switch(strategy2) { // intermediate-to-output
	case IW_STRAT2_RGBA_RGBA:
		ctx->img2.imgtype = IW_IMGTYPE_RGBA;
		break;
	case IW_STRAT2_RGB_RGB:
		ctx->img2.imgtype = IW_IMGTYPE_RGB;
		break;
	case IW_STRAT2_RGBA_RGB:
		ctx->img2.imgtype = IW_IMGTYPE_RGB;
		ctx->intermed_ci[3].corresponding_output_channel= -1;
		break;
	case IW_STRAT2_GA_GA:
		ctx->img2.imgtype = IW_IMGTYPE_GRAYA;
		break;
	case IW_STRAT2_G_G:
		ctx->img2.imgtype = IW_IMGTYPE_GRAY;
		break;
	case IW_STRAT2_GA_G:
		ctx->img2.imgtype = IW_IMGTYPE_GRAY;
		ctx->intermed_ci[1].corresponding_output_channel= -1;
		break;
	default:
		iw_set_error(ctx,"Internal error");
		return 0;
	}

	ctx->img2_numchannels = iw_imgtype_num_channels(ctx->img2.imgtype);

	iw_set_intermed_channeltypes(ctx);
	iw_set_out_channeltypes(ctx);

	if(IW_IMGTYPE_HAS_ALPHA(ctx->intermed_imgtype)) {
		for(i=0;i<ctx->intermed_numchannels;i++) {
			if(ctx->intermed_ci[i].channeltype!=IW_CHANNELTYPE_ALPHA)
				ctx->intermed_ci[i].need_unassoc_alpha_processing = 1;
		}
	}


	decide_output_bit_depth(ctx);

	if(ctx->img2.sampletype==IW_SAMPLETYPE_FLOATINGPOINT) {
		flag=0;
		for(i=0;i<IW_NUM_CHANNELTYPES;i++) {
			if(ctx->req.color_count[i]) flag=1;
		}
		if(flag) {
			iw_warning(ctx,"Posterization is not supported with floating point output.");
		}
	}
	else {
		output_maxcolorcode_int = (1 << ctx->img2.bit_depth)-1;

		for(i=0;i<ctx->img2_numchannels;i++) {
			ctx->img2_ci[i].maxcolorcode_int = output_maxcolorcode_int;
		}

		if((ctx->output_profile&IW_PROFILE_REDUCEDBITDEPTHS)) {
			for(i=0;i<ctx->img2_numchannels;i++) {
				int mccr;
				mccr = ctx->req.output_maxcolorcode[ctx->img2_ci[i].channeltype];
				if(mccr>0) {
					if(mccr>output_maxcolorcode_int) mccr=output_maxcolorcode_int;
					ctx->img2_ci[i].maxcolorcode_int = mccr;
				}
			}
		}

		for(i=0;i<ctx->img2_numchannels;i++) {
			if(ctx->img2_ci[i].maxcolorcode_int != output_maxcolorcode_int) {
				ctx->reduced_output_maxcolor_flag = 1;
				ctx->disable_output_lookup_tables = 1;
			}

			ctx->img2_ci[i].maxcolorcode_dbl = (double)ctx->img2_ci[i].maxcolorcode_int;
		}
	}

	for(i=0;i<ctx->img2_numchannels;i++) {
		ctx->img2_ci[i].color_count = ctx->req.color_count[ctx->img2_ci[i].channeltype];
		if(ctx->img2_ci[i].color_count) {
			iw_restrict_to_range(2,ctx->img2_ci[i].maxcolorcode_int,&ctx->img2_ci[i].color_count);
		}
		if(ctx->img2_ci[i].color_count==1+ctx->img2_ci[i].maxcolorcode_int) {
			ctx->img2_ci[i].color_count = 0;
		}

		ctx->img2_ci[i].ditherfamily = ctx->ditherfamily_by_channeltype[ctx->img2_ci[i].channeltype];
		ctx->img2_ci[i].dithersubtype = ctx->dithersubtype_by_channeltype[ctx->img2_ci[i].channeltype];
	}

	for(i=0;i<ctx->img2_numchannels;i++) {
		if(ctx->img2_ci[i].ditherfamily==IW_DITHERFAMILY_ERRDIFF) {
			ctx->uses_errdiffdither=1;
		}
	}

	if(!ctx->support_reduced_input_bitdepths && ctx->img1.sampletype==IW_SAMPLETYPE_UINT) {
		iw_make_x_to_linear_table(ctx,&ctx->input_color_corr_table,&ctx->img1,&ctx->img1cs);
	}

	if(ctx->img1_bkgd_label_set) {
		for(i=0;i<3;i++) {
			ctx->img1_bkgd_label_lin.c[i] = x_to_linear_sample(ctx->img1_bkgd_label_inputcs.c[i],&ctx->img1cs);
		}
		ctx->img1_bkgd_label_lin.c[3] = ctx->img1_bkgd_label_inputcs.c[3];
	}

	if(ctx->apply_bkgd) {
		prepare_apply_bkgd(ctx);
	}

	if(ctx->req.output_rendering_intent==IW_INTENT_UNKNOWN) {
		ctx->img2.rendering_intent = ctx->img1.rendering_intent;
	}
	else {
		ctx->img2.rendering_intent = ctx->req.output_rendering_intent;
	}

	if(ctx->resize_settings[IW_DIMENSION_H].family==IW_RESIZETYPE_AUTO) {
		iw_set_auto_resizetype(ctx,ctx->input_w,ctx->img2.width,IW_DIMENSION_H);
	}
	if(ctx->resize_settings[IW_DIMENSION_V].family==IW_RESIZETYPE_AUTO) {
		iw_set_auto_resizetype(ctx,ctx->input_h,ctx->img2.height,IW_DIMENSION_V);
	}

	if(IW_IMGTYPE_HAS_ALPHA(ctx->img2.imgtype)) {
		if(!ctx->opt_strip_alpha) {
			ctx->opt_palette = 0;
			ctx->opt_binary_trns = 0;
		}
	}

	return 1;
}

static int get_output_bkgd_label_lin(struct iw_context *ctx, struct iw_color *clr)
{
	clr->c[0] = 1.0; clr->c[1] = 0.0; clr->c[2] = 1.0; clr->c[3] = 1.0;

	if(ctx->req.suppress_output_bkgd_label) return 0;

	if(ctx->req.output_bkgd_label_valid) {
		*clr = ctx->req.output_bkgd_label;
		return 1;
	}

	if(ctx->img1_bkgd_label_set) {
		*clr = ctx->img1_bkgd_label_lin;
		return 1;
	}

	return 0;
}

static void put_sample_convert_from_linear(struct iw_context *ctx, iw_tmpsample samp_lin,
	   int x, int y, int channel, const struct iw_csdescr *csdescr)
{
	double s_lin_floor_1, s_lin_ceil_1;
	double s_cvt_floor_full, s_cvt_ceil_full;
	double d_floor, d_ceil;
	int is_exact;
	double s_full;
	int ditherfamily;
	int dd; // Dither decision: 0 to use floor, 1 to use ceil.

	if(samp_lin<0.0) samp_lin=0.0;
	if(samp_lin>1.0) samp_lin=1.0;

	if(ctx->img2_ci[channel].use_nearest_color_table) {
		s_full = get_final_sample_using_nc_tbl(ctx,samp_lin);
		goto okay;
	}

	ditherfamily=ctx->img2_ci[channel].ditherfamily;

	if(ditherfamily==IW_DITHERFAMILY_ERRDIFF) {
		samp_lin += ctx->dither_errors[0][x];
		if(samp_lin>1.0) samp_lin=1.0;
		else if(samp_lin<0.0) samp_lin=0.0;
	}

	is_exact = get_nearest_valid_colors(ctx,samp_lin,csdescr,
		&s_lin_floor_1, &s_lin_ceil_1,
		&s_cvt_floor_full, &s_cvt_ceil_full,
		ctx->img2_ci[channel].maxcolorcode_dbl, ctx->img2_ci[channel].color_count);

	if(is_exact) {
		s_full = s_cvt_floor_full;

		if(ditherfamily==IW_DITHERFAMILY_RANDOM) {
			(void)iwpvt_prng_rand(ctx->prng);
		}
		goto okay;
	}

	d_floor = samp_lin-s_lin_floor_1;
	d_ceil  = s_lin_ceil_1-samp_lin;

	if(ditherfamily==IW_DITHERFAMILY_NONE) {
		if(d_ceil<=d_floor) s_full=s_cvt_ceil_full;
		else s_full=s_cvt_floor_full;
	}
	else if(ditherfamily==IW_DITHERFAMILY_ERRDIFF) {
		if(d_ceil<=d_floor) {
			iw_errdiff_dither(ctx,ctx->img2_ci[channel].dithersubtype,-d_ceil,x,y);
			s_full=s_cvt_ceil_full;
		}
		else {
			iw_errdiff_dither(ctx,ctx->img2_ci[channel].dithersubtype,d_floor,x,y);
			s_full=s_cvt_floor_full;
		}
	}
	else if(ditherfamily==IW_DITHERFAMILY_ORDERED) {
		dd=iw_ordered_dither(ctx->img2_ci[channel].dithersubtype, d_floor/(d_floor+d_ceil),x,y);
		s_full = dd ? s_cvt_ceil_full : s_cvt_floor_full;
	}
	else if(ditherfamily==IW_DITHERFAMILY_RANDOM) {
		dd=iw_random_dither(ctx,d_floor/(d_floor+d_ceil),x,y,ctx->img2_ci[channel].dithersubtype,channel);
		s_full = dd ? s_cvt_ceil_full : s_cvt_floor_full;
	}
	else {
		s_full = 0.0;
	}

okay:
	put_raw_sample(ctx,s_full,x,y,channel);
}

static IW_INLINE void translate_coords(struct iw_context *ctx,
	int x, int y, int *prx, int *pry)
{
	if(ctx->img1.orient_transform==0) {
		*prx = ctx->input_start_x+x;
		*pry = ctx->input_start_y+y;
		return;
	}

	switch(ctx->img1.orient_transform) {
	case 1: // mirror-x
		*prx = ctx->img1.width - 1 - (ctx->input_start_x+x);
		*pry = ctx->input_start_y+y;
		break;
	case 2: // mirror-y
		*prx = ctx->input_start_x+x;
		*pry = ctx->img1.height - 1 - (ctx->input_start_y+y);
		break;
	case 3: // mirror-x, mirror-y
		*prx = ctx->img1.width - 1 - (ctx->input_start_x+x);
		*pry = ctx->img1.height - 1 - (ctx->input_start_y+y);
		break;
	case 4:
		*prx = ctx->input_start_y+y;
		*pry = ctx->input_start_x+x;
		break;
	case 5:
		*prx = ctx->input_start_y+y;
		*pry = ctx->img1.width - 1 - (ctx->input_start_x+x);
		break;
	case 6:
		*prx = ctx->img1.height - 1 - (ctx->input_start_y+y);
		*pry = ctx->input_start_x+x;
		break;
	case 7:
		*prx = ctx->img1.height - 1 - (ctx->input_start_y+y);
		*pry = ctx->img1.width - 1 - (ctx->input_start_x+x);
		break;
	default:
		*prx = 0;
		*pry = 0;
		break;
	}
}

static void bmpw_convert_row_4(const iw_byte *srcrow, iw_byte *dstrow, int width)
{
	int i;

	for(i=0;i<width;i++) {
		if(i%2==0)
			dstrow[i/2] = srcrow[i]<<4;
		else
			dstrow[i/2] |= srcrow[i];
	}
}

static IW_INLINE void put_raw_sample_8(struct iw_context *ctx, double s,
	   int x, int y, int channel)
{
	iw_byte tmpui8;

	tmpui8 = (iw_byte)(0.5+s);
	ctx->img2.pixels[y*ctx->img2.bpr + ctx->img2_numchannels*x + channel] = tmpui8;
}

static int iwbmp_write_bmp_v3header(struct iwbmpwcontext *wctx)
{
	unsigned int dens_x, dens_y;
	unsigned int cmpr;
	iw_byte header[40];

	iw_zeromem(header,sizeof(header));

	iw_set_ui32le(&header[ 0],(unsigned int)wctx->header_size); // biSize
	iw_set_ui32le(&header[ 4],wctx->img->width);  // biWidth
	iw_set_ui32le(&header[ 8],wctx->img->height); // biHeight
	iw_set_ui16le(&header[12],1);    // biPlanes
	iw_set_ui16le(&header[14],wctx->bitcount);   // biBitCount

	cmpr = IWBMP_BI_RGB;
	if(wctx->compressed) {
		if(wctx->bitcount==8) cmpr = IWBMP_BI_RLE8;
		else if(wctx->bitcount==4) cmpr = IWBMP_BI_RLE4;
	}
	else if(wctx->uses_bitfields) {
		cmpr = IWBMP_BI_BITFIELDS;
	}
	iw_set_ui32le(&header[16],cmpr); // biCompression

	iw_set_ui32le(&header[20],(unsigned int)wctx->unc_bitssize); // biSizeImage

	if(wctx->img->density_code==IW_DENSITY_UNITS_PER_METER) {
		dens_x = (unsigned int)(0.5+wctx->img->density_x);
		dens_y = (unsigned int)(0.5+wctx->img->density_y);
	}
	else {
		dens_x = dens_y = 2835;
	}
	iw_set_ui32le(&header[24],dens_x); // biXPelsPerMeter
	iw_set_ui32le(&header[28],dens_y); // biYPelsPerMeter

	iw_set_ui32le(&header[32],wctx->palentries);    // biClrUsed
	iwbmp_write(wctx,header,40);
	return 1;
}

static int decode_v3_header_fields(struct iwbmprcontext *rctx, const iw_byte *buf)
{
	unsigned int nplanes;
	int biXPelsPerMeter, biYPelsPerMeter;
	unsigned int biClrUsed = 0;

	rctx->width = iw_get_i32le(&buf[4]);
	rctx->height = iw_get_i32le(&buf[8]);
	if(rctx->height<0) {
		rctx->height = -rctx->height;
		rctx->topdown = 1;
	}

	nplanes = iw_get_ui16le(&buf[12]);
	if(nplanes!=1) return 0;

	rctx->bitcount = iw_get_ui16le(&buf[14]);
	if(rctx->bitcount!=1 && rctx->bitcount!=2 && rctx->bitcount!=4 &&
		rctx->bitcount!=8 && rctx->bitcount!=16 && rctx->bitcount!=24 &&
		rctx->bitcount!=32)
	{
		iw_set_errorf(rctx->ctx,"Bad or unsupported bit count (%d)",(int)rctx->bitcount);
		return 0;
	}

	if(rctx->infoheader_size<=16) {
		goto infoheaderdone;
	}

	rctx->compression = iw_get_ui32le(&buf[16]);
	if(rctx->compression==IWBMP_BI_BITFIELDS) {
		if(rctx->bitcount==1) {
			iw_set_error(rctx->ctx,"Huffman 1D compression not supported");
			return 0;
		}
		else if(rctx->bitcount!=16 && rctx->bitcount!=32) {
			iw_set_error(rctx->ctx,"Bad or unsupported image type");
			return 0;
		}

		rctx->uses_bitfields = 1;

		if(rctx->bmpversion==3) {
			rctx->bitfields_nbytes = 12;
		}

		rctx->compression=IWBMP_BI_RGB;
	}

	biXPelsPerMeter = iw_get_i32le(&buf[24]);
	biYPelsPerMeter = iw_get_i32le(&buf[28]);

	rctx->img->density_code = IW_DENSITY_UNITS_PER_METER;
	rctx->img->density_x = (double)biXPelsPerMeter;
	rctx->img->density_y = (double)biYPelsPerMeter;
	if(!iw_is_valid_density(rctx->img->density_x,rctx->img->density_y,rctx->img->density_code)) {
		rctx->img->density_code=IW_DENSITY_UNKNOWN;
	}

	biClrUsed = iw_get_ui32le(&buf[32]);
	if(biClrUsed>100000) return 0;

infoheaderdone:
	if(biClrUsed==0 && rctx->bitcount<=8) {
		rctx->palette_entries = 1<<rctx->bitcount;
	}
	else {
		rctx->palette_entries = biClrUsed;
	}
	rctx->palette_nbytes = 4*rctx->palette_entries;
	return 1;
}

static iw_tmpsample get_sample_cvt_to_linear(struct iw_context *ctx,
	   int x, int y, int channel, const struct iw_csdescr *csdescr)
{
	unsigned int v1,v2,v3;
	iw_tmpsample r,g,b;
	int ch;

	ch = ctx->intermed_ci[channel].corresponding_input_channel;

	if(ctx->img1_ci[ch].disable_fast_get_sample) {
		if(ctx->intermed_ci[channel].cvt_to_grayscale) {
			r = x_to_linear_sample(get_raw_sample(ctx,x,y,ch+0),csdescr);
			g = x_to_linear_sample(get_raw_sample(ctx,x,y,ch+1),csdescr);
			b = x_to_linear_sample(get_raw_sample(ctx,x,y,ch+2),csdescr);
			return iw_color_to_grayscale(ctx,r,g,b);
		}
		return x_to_linear_sample(get_raw_sample(ctx,x,y,ch),csdescr);
	}

	if(ctx->intermed_ci[channel].cvt_to_grayscale) {
		v1 = get_raw_sample_int(ctx,x,y,ch+0);
		v2 = get_raw_sample_int(ctx,x,y,ch+1);
		v3 = get_raw_sample_int(ctx,x,y,ch+2);
		r = cvt_int_sample_to_linear(ctx,v1,csdescr);
		g = cvt_int_sample_to_linear(ctx,v2,csdescr);
		b = cvt_int_sample_to_linear(ctx,v3,csdescr);
		return iw_color_to_grayscale(ctx,r,g,b);
	}

	v1 = get_raw_sample_int(ctx,x,y,ch);
	return cvt_int_sample_to_linear(ctx,v1,csdescr);
}

static unsigned int get_raw_sample_int(struct iw_context *ctx,
	   int x, int y, int channel)
{
	int rx,ry; // physical coordinates

	translate_coords(ctx,x,y,&rx,&ry);

	switch(ctx->img1.bit_depth) {
	case 8: return get_raw_sample_8(ctx,rx,ry,channel);
	case 1: return get_raw_sample_1(ctx,rx,ry);
	case 16: return get_raw_sample_16(ctx,rx,ry,channel);
	case 4: return get_raw_sample_4(ctx,rx,ry);
	case 2: return get_raw_sample_2(ctx,rx,ry);
	}
	return 0;
}

static int iw_get_channeltype(int imgtype, int channel)
{
	switch(imgtype) {
	case IW_IMGTYPE_GRAY:
		if(channel==0) return IW_CHANNELTYPE_GRAY;
		break;
	case IW_IMGTYPE_GRAYA:
		if(channel==0) return IW_CHANNELTYPE_GRAY;
		if(channel==1) return IW_CHANNELTYPE_ALPHA;
		break;
	case IW_IMGTYPE_RGB:
		if(channel==0) return IW_CHANNELTYPE_RED;
		if(channel==1) return IW_CHANNELTYPE_GREEN;
		if(channel==2) return IW_CHANNELTYPE_BLUE;
		break;
	case IW_IMGTYPE_RGBA:
		if(channel==0) return IW_CHANNELTYPE_RED;
		if(channel==1) return IW_CHANNELTYPE_GREEN;
		if(channel==2) return IW_CHANNELTYPE_BLUE;
		if(channel==3) return IW_CHANNELTYPE_ALPHA;
		break;
	}
	return 0;
}

static iw_tmpsample get_raw_sample(struct iw_context *ctx,
	   int x, int y, int channel)
{
	unsigned int v;

	if(channel>=ctx->img1_numchannels_physical) {
		return 1.0;
	}

	if(ctx->img1.sampletype==IW_SAMPLETYPE_FLOATINGPOINT) {
		int rx, ry;
		translate_coords(ctx,x,y,&rx,&ry);
		if(ctx->img1.bit_depth!=32) return 0.0;
		return get_raw_sample_flt32(ctx,rx,ry,channel);
	}

	v = get_raw_sample_int(ctx,x,y,channel);
	return ((double)v) / ctx->img1_ci[channel].maxcolorcode_dbl;
}

static int bmpr_read_rle_internal(struct iwbmprcontext *rctx)
{
	int retval = 0;
	int pos_x, pos_y;
	iw_byte buf[255];
	size_t n_pix;
	size_t n_bytes;
	size_t i;
	size_t pal_index;

	pos_x = 0;
	pos_y = 0;

	iw_zeromem(rctx->img->pixels,rctx->img->bpr*rctx->img->height);

	while(1) {
		if(pos_y>rctx->img->height-1) break;
		if(pos_y==rctx->img->height-1 && pos_x>=rctx->img->width) break;

		if(!iwbmp_read(rctx,buf,2)) goto done;
		if(buf[0]==0) {
			if(buf[1]==0) {
				pos_y++;
				pos_x=0;
			}
			else if(buf[1]==1) {
				break;
			}
			else if(buf[1]==2) {
				if(!iwbmp_read(rctx,buf,2)) goto done;

				if(pos_x<rctx->img->width) pos_x += buf[0];
				pos_y += buf[1];
			}
			else {
				n_pix = (size_t)buf[1]; // Number of uncompressed pixels which follow
				if(rctx->compression==IWBMP_BI_RLE4) {
					n_bytes = ((n_pix+3)/4)*2;
				}
				else {
					n_bytes = ((n_pix+1)/2)*2;
				}
				if(!iwbmp_read(rctx,buf,n_bytes)) goto done;
				for(i=0;i<n_pix;i++) {
					if(pos_x<rctx->img->width) {
						if(rctx->compression==IWBMP_BI_RLE4) {
							pal_index = (i%2) ? buf[i/2]&0x0f : buf[i/2]>>4;
						}
						else {
							pal_index = buf[i];
						}
						rctx->img->pixels[rctx->img->bpr*pos_y + pos_x*4 + 0] = rctx->palette.entry[pal_index].r;
						rctx->img->pixels[rctx->img->bpr*pos_y + pos_x*4 + 1] = rctx->palette.entry[pal_index].g;
						rctx->img->pixels[rctx->img->bpr*pos_y + pos_x*4 + 2] = rctx->palette.entry[pal_index].b;
						rctx->img->pixels[rctx->img->bpr*pos_y + pos_x*4 + 3] = 255;
						pos_x++;
					}
				}
			}
		}
		else {
			n_pix = (size_t)buf[0];
			for(i=0;i<n_pix;i++) {
				if(pos_x<rctx->img->width) {
					if(rctx->compression==IWBMP_BI_RLE4) {
						pal_index = (i%2) ? buf[1]&0x0f : buf[1]>>4;
					}
					else {
						pal_index = buf[1];
					}
					rctx->img->pixels[rctx->img->bpr*pos_y + pos_x*4 + 0] = rctx->palette.entry[pal_index].r;
					rctx->img->pixels[rctx->img->bpr*pos_y + pos_x*4 + 1] = rctx->palette.entry[pal_index].g;
					rctx->img->pixels[rctx->img->bpr*pos_y + pos_x*4 + 2] = rctx->palette.entry[pal_index].b;
					rctx->img->pixels[rctx->img->bpr*pos_y + pos_x*4 + 3] = 255;
					pos_x++;
				}
			}
		}
	}

	retval = 1;
done:
	return retval;
}

static int iwbmp_skip_bytes(struct iwbmprcontext *rctx, size_t n)
{
	iw_byte buf[1024];
	size_t still_to_read;
	size_t num_to_read;

	still_to_read = n;
	while(still_to_read>0) {
		num_to_read = still_to_read;
		if(num_to_read>1024) num_to_read=1024;
		if(!iwbmp_read(rctx,buf,num_to_read)) {
			return 0;
		}
		still_to_read -= num_to_read;
	}
	return 1;
}

static void put_sample_convert_from_linear_flt(struct iw_context *ctx, iw_tmpsample samp_lin,
	   int x, int y, int channel, const struct iw_csdescr *csdescr)
{
	put_raw_sample_flt32(ctx,(double)samp_lin,x,y,channel);
}

static int iwbmp_read(struct iwbmprcontext *rctx,
		iw_byte *buf, size_t buflen)
{
	int ret;
	size_t bytesread = 0;

	ret = (*rctx->iodescr->read_fn)(rctx->ctx,rctx->iodescr,
		buf,buflen,&bytesread);
	if(!ret || bytesread!=buflen) {
		return 0;
	}
	return 1;
}

static void bmpw_convert_row_8(const iw_byte *srcrow, iw_byte *dstrow, int width)
{
	memcpy(dstrow,srcrow,width);
}

static int rle4_get_incr_unc_cost(struct rle_context *rlectx)
{
	int n;
	int m;

	n = (int)rlectx->unc_len;

	if(n==2 || n==255 || n==257 || n==507 || n==510) return 2;
	if(n==256 || n==508) return 0;

	if(n>=759) {
		m = n%252;
		if(m==3 || m==6 || m==9) return 2;
		if(m==4 || m==8) return 0;
	}

	return (n%4)?0:2;
}

static int iw_process_one_channel(struct iw_context *ctx, int intermed_channel,
  const struct iw_csdescr *in_csdescr, const struct iw_csdescr *out_csdescr)
{
	if(!iw_process_cols_to_intermediate(ctx,intermed_channel,in_csdescr)) {
		return 0;
	}

	if(!iw_process_rows_intermediate_to_final(ctx,intermed_channel,out_csdescr)) {
		return 0;
	}

	return 1;
}

static int iw_ordered_dither(int dithersubtype, double fraction, int x, int y)
{
	double threshold;
	static const float pattern[2][64] = {
	 { // Dispersed ordered dither
		 0.5/64,48.5/64,12.5/64,60.5/64, 3.5/64,51.5/64,15.5/64,63.5/64,
		32.5/64,16.5/64,44.5/64,28.5/64,35.5/64,19.5/64,47.5/64,31.5/64,
		 8.5/64,56.5/64, 4.5/64,52.5/64,11.5/64,59.5/64, 7.5/64,55.5/64,
		40.5/64,24.5/64,36.5/64,20.5/64,43.5/64,27.5/64,39.5/64,23.5/64,
		 2.5/64,50.5/64,14.5/64,62.5/64, 1.5/64,49.5/64,13.5/64,61.5/64,
		34.5/64,18.5/64,46.5/64,30.5/64,33.5/64,17.5/64,45.5/64,29.5/64,
		10.5/64,58.5/64, 6.5/64,54.5/64, 9.5/64,57.5/64, 5.5/64,53.5/64,
		42.5/64,26.5/64,38.5/64,22.5/64,41.5/64,25.5/64,37.5/64,21.5/64
	 },
	 { // Halftone ordered dither
		 3.5/64, 9.5/64,17.5/64,27.5/64,25.5/64,15.5/64, 7.5/64, 1.5/64,
		11.5/64,29.5/64,37.5/64,45.5/64,43.5/64,35.5/64,23.5/64, 5.5/64,
		19.5/64,39.5/64,51.5/64,57.5/64,55.5/64,49.5/64,33.5/64,13.5/64,
		31.5/64,47.5/64,59.5/64,63.5/64,61.5/64,53.5/64,41.5/64,21.5/64,
		30.5/64,46.5/64,58.5/64,62.5/64,60.5/64,52.5/64,40.5/64,20.5/64,
		18.5/64,38.5/64,50.5/64,56.5/64,54.5/64,48.5/64,32.5/64,12.5/64,
		10.5/64,28.5/64,36.5/64,44.5/64,42.5/64,34.5/64,22.5/64, 4.5/64,
		 2.5/64, 8.5/64,16.5/64,26.5/64,24.5/64,14.5/64, 6.5/64, 0.5/64
	 }};

	threshold = pattern[dithersubtype][(x%8) + 8*(y%8)];
	return (fraction >= threshold);
}

static int iwbmp_write_bmp_v2header(struct iwbmpwcontext *wctx)
{
	iw_byte header[12];

	if(wctx->img->width>65535 || wctx->img->height>65535) {
		iw_set_error(wctx->ctx,"Output image is too large for this BMP version");
		return 0;
	}

	iw_zeromem(header,sizeof(header));
	iw_set_ui32le(&header[ 0],12);                // bcSize
	iw_set_ui16le(&header[ 4],wctx->img->width);  // bcWidth
	iw_set_ui16le(&header[ 6],wctx->img->height); // bcHeight
	iw_set_ui16le(&header[ 8],1);                 // bcPlanes
	iw_set_ui16le(&header[10],wctx->bitcount);    // bcBitCount

	iwbmp_write(wctx,header,12);
	return 1;
}

static int decode_v4_header_fields(struct iwbmprcontext *rctx, const iw_byte *buf)
{
	int k;
	unsigned int cstype;

	if(rctx->uses_bitfields) {
		for(k=0;k<4;k++) {
			rctx->bf_mask[k] = 0;
		}
		for(k=0;k<4;k++) {
			if(rctx->infoheader_size < (size_t)(40+k*4+4)) break;
			rctx->bf_mask[k] = iw_get_ui32le(&buf[40+k*4]);
			if(!process_bf_mask(rctx,k)) return 0;
		}
		rctx->bitfields_set=1; // Remember not to overwrite the bf_* fields.

		if(rctx->bf_mask[3]!=0) {
			rctx->has_alpha_channel = 1;
		}
	}

	if(rctx->infoheader_size < 108) return 1;

	cstype = iw_get_ui32le(&buf[56]);
	switch(cstype) {
	case IWBMPCS_CALIBRATED_RGB:
		break;

	case IWBMPCS_DEVICE_RGB:
	case IWBMPCS_SRGB:
	case IWBMPCS_WINDOWS:
		break;

	case IWBMPCS_PROFILE_LINKED:
	case IWBMPCS_PROFILE_EMBEDDED:
		if(rctx->bmpversion<5) {
			iw_warning(rctx->ctx,"Invalid colorspace type for BMPv4");
		}
		break;

	default:
		iw_warningf(rctx->ctx,"Unrecognized or unsupported colorspace type (0x%x)",cstype);
	}

	if(cstype==IWBMPCS_CALIBRATED_RGB) {
		unsigned int bmpgamma;
		double gamma[3];
		double avggamma;

		for(k=0;k<3;k++) {
			bmpgamma = iw_get_ui32le(&buf[96+k*4]);
			gamma[k] = ((double)bmpgamma)/65536.0;
		}
		avggamma = (gamma[0] + gamma[1] + gamma[2])/3.0;

		if(avggamma>=0.1 && avggamma<=10.0) {
			iw_make_gamma_csdescr(&rctx->csdescr,1.0/avggamma);
		}
	}

	return 1;
}

static void iw_errdiff_dither(struct iw_context *ctx,int dithersubtype,
	double err,int x,int y)
{
	int fwd;
	const double *m;


	static const double matrix_list[][12] = {
	{                          7.0/16, 0.0,     // 0 = Floyd-Steinberg
	   0.0   , 3.0/16, 5.0/16, 1.0/16, 0.0,
	   0.0   ,    0.0,    0.0, 0.0   , 0.0    },
	{                          7.0/48, 5.0/48,  // 1 = JJN
	   3.0/48, 5.0/48, 7.0/48, 5.0/48, 3.0/48,
	   1.0/48, 3.0/48, 5.0/48, 3.0/48, 1.0/48 },
	{                          8.0/42, 4.0/42,  // 2 = Stucki
	   2.0/42, 4.0/42, 8.0/42, 4.0/42, 2.0/42,
	   1.0/42, 2.0/42, 4.0/42, 2.0/42, 1.0/42 },
	{                          8.0/32, 4.0/32,  // 3 = Burkes
	   2.0/32, 4.0/32, 8.0/32, 4.0/32, 2.0/32,
	   0.0   , 0.0   , 0.0   , 0.0   , 0.0    },
	{                          5.0/32, 3.0/32,  // 4 = Sierra3
	   2.0/32, 4.0/32, 5.0/32, 4.0/32, 2.0/32,
	      0.0, 2.0/32, 3.0/32, 2.0/32, 0.0    },
	{                          4.0/16, 3.0/16,  // 5 = Sierra2
	   1.0/16, 2.0/16, 3.0/16, 2.0/16, 1.0/16,
	   0.0   , 0.0   , 0.0   , 0.0   , 0.0    },
	{                          2.0/4 , 0.0,     // 6 = Sierra42a
	   0.0   , 1.0/4 , 1.0/4 , 0.0   , 0.0,
	   0.0   , 0.0   , 0.0   , 0.0   , 0.0    },
	{                          1.0/8 , 1.0/8,   // 7 = Atkinson
	   0.0   , 1.0/8 , 1.0/8 , 1.0/8 , 0.0,
	   0.0   , 0.0   , 1.0/8 , 0.0   , 0.0    }
	};

	if(dithersubtype<=7)
		m = matrix_list[dithersubtype];
	else
		m = matrix_list[0];

	fwd = (y%2)?(-1):1;

	if((x-fwd)>=0 && (x-fwd)<ctx->img2.width) {
		if((x-2*fwd)>=0 && (x-2*fwd)<ctx->img2.width) {
			ctx->dither_errors[1][x-2*fwd] += err*(m[2]);
			ctx->dither_errors[2][x-2*fwd] += err*(m[7]);
		}
		ctx->dither_errors[1][x-fwd] += err*(m[3]);
		ctx->dither_errors[2][x-fwd] += err*(m[8]);
	}

	ctx->dither_errors[1][x] += err*(m[4]);
	ctx->dither_errors[2][x] += err*(m[9]);

	if((x+fwd)>=0 && (x+fwd)<ctx->img2.width) {
		ctx->dither_errors[0][x+fwd] += err*(m[0]);
		ctx->dither_errors[1][x+fwd] += err*(m[5]);
		ctx->dither_errors[2][x+fwd] += err*(m[10]);
		if((x+2*fwd)>=0 && (x+2*fwd)<ctx->img2.width) {
			ctx->dither_errors[0][x+2*fwd] += err*(m[1]);
			ctx->dither_errors[1][x+2*fwd] += err*(m[6]);
			ctx->dither_errors[2][x+2*fwd] += err*(m[11]);
		}
	}
}

static IW_INLINE unsigned int get_raw_sample_16(struct iw_context *ctx,
	   int x, int y, int channel)
{
	size_t z;
	unsigned short tmpui16;
	z = y*ctx->img1.bpr + (ctx->img1_numchannels_physical*x + channel)*2;
	tmpui16 = ( ((unsigned short)(ctx->img1.pixels[z+0])) <<8) | ctx->img1.pixels[z+1];
	return tmpui16;
}

static int iw_process_internal(struct iw_context *ctx)
{
	int channel;
	int retval=0;
	int i,k;
	int ret;
	struct iw_csdescr csdescr_linear;

	ctx->intermediate32=NULL;
	ctx->intermediate_alpha32=NULL;
	ctx->final_alpha32=NULL;
	ctx->intermed_canvas_width = ctx->input_w;
	ctx->intermed_canvas_height = ctx->img2.height;

	iw_make_linear_csdescr(&csdescr_linear);

	ctx->img2.bpr = iw_calc_bytesperrow(ctx->img2.width,ctx->img2.bit_depth*ctx->img2_numchannels);

	ctx->img2.pixels = iw_malloc_large(ctx, ctx->img2.bpr, ctx->img2.height);
	if(!ctx->img2.pixels) {
		goto done;
	}

	ctx->intermediate32 = (iw_float32*)iw_malloc_large(ctx, ctx->intermed_canvas_width * ctx->intermed_canvas_height, sizeof(iw_float32));
	if(!ctx->intermediate32) {
		goto done;
	}

	if(ctx->uses_errdiffdither) {
		for(k=0;k<IW_DITHER_MAXROWS;k++) {
			ctx->dither_errors[k] = (double*)iw_malloc(ctx, ctx->img2.width * sizeof(double));
			if(!ctx->dither_errors[k]) goto done;
		}
	}

	if(!ctx->disable_output_lookup_tables) {
		iw_make_x_to_linear_table(ctx,&ctx->output_rev_color_corr_table,&ctx->img2,&ctx->img2cs);

		iw_make_nearest_color_table(ctx,&ctx->nearest_color_table,&ctx->img2,&ctx->img2cs);
	}

	if(IW_IMGTYPE_HAS_ALPHA(ctx->intermed_imgtype)) {
		ctx->intermediate_alpha32 = (iw_float32*)iw_malloc_large(ctx, ctx->intermed_canvas_width * ctx->intermed_canvas_height, sizeof(iw_float32));
		if(!ctx->intermediate_alpha32) {
			goto done;
		}
		ctx->final_alpha32 = (iw_float32*)iw_malloc_large(ctx, ctx->img2.width * ctx->img2.height, sizeof(iw_float32));
		if(!ctx->final_alpha32) {
			goto done;
		}

		if(!iw_process_one_channel(ctx,ctx->intermed_alpha_channel_index,&csdescr_linear,&csdescr_linear)) goto done;
	}


	for(channel=0;channel<ctx->intermed_numchannels;channel++) {
		if(ctx->intermed_ci[channel].channeltype!=IW_CHANNELTYPE_ALPHA) {
			if(ctx->no_gamma)
				ret=iw_process_one_channel(ctx,channel,&csdescr_linear,&csdescr_linear);
			else
				ret=iw_process_one_channel(ctx,channel,&ctx->img1cs,&ctx->img2cs);

			if(!ret) goto done;
		}
	}

	iw_process_bkgd_label(ctx);

	if(ctx->req.negate_target) {
		negate_target_image(ctx);
	}

	retval=1;

done:
	if(ctx->intermediate32) { iw_free(ctx,ctx->intermediate32); ctx->intermediate32=NULL; }
	if(ctx->intermediate_alpha32) { iw_free(ctx,ctx->intermediate_alpha32); ctx->intermediate_alpha32=NULL; }
	if(ctx->final_alpha32) { iw_free(ctx,ctx->final_alpha32); ctx->final_alpha32=NULL; }
	for(k=0;k<IW_DITHER_MAXROWS;k++) {
		if(ctx->dither_errors[k]) { iw_free(ctx,ctx->dither_errors[k]); ctx->dither_errors[k]=NULL; }
	}
	for(i=0;i<2;i++) { // horizontal, vertical
		if(ctx->resize_settings[i].rrctx) {
			iwpvt_resize_rows_done(ctx->resize_settings[i].rrctx);
			ctx->resize_settings[i].rrctx = NULL;
		}
	}
	return retval;
}

static void iwbmp_write_pixels_uncompressed(struct iwbmpwcontext *wctx,
	struct iw_image *img)
{
	int j;
	iw_byte *dstrow = NULL;
	const iw_byte *srcrow;

	dstrow = iw_mallocz(wctx->ctx,wctx->unc_dst_bpr);
	if(!dstrow) goto done;

	for(j=img->height-1;j>=0;j--) {
		srcrow = &img->pixels[j*img->bpr];
		switch(wctx->bitcount) {
		case 32: bmpw_convert_row_16_32(wctx,srcrow,dstrow,img->width); break;
		case 24: bmpw_convert_row_24(wctx,srcrow,dstrow,img->width); break;
		case 16: bmpw_convert_row_16_32(wctx,srcrow,dstrow,img->width); break;
		case 8: bmpw_convert_row_8(srcrow,dstrow,img->width); break;
		case 4: bmpw_convert_row_4(srcrow,dstrow,img->width); break;
		case 1: bmpw_convert_row_1(srcrow,dstrow,img->width); break;
		}
		iwbmp_write(wctx,dstrow,wctx->unc_dst_bpr);
	}

done:
	if(dstrow) iw_free(wctx->ctx,dstrow);
	return;
}

static void rle4_write_unc(struct rle_context *rlectx)
{
	iw_byte dstbuf[128];
	size_t pixels_to_write;
	size_t bytes_to_write;

	if(rlectx->unc_len<1) return;


	while(rlectx->unc_len>0) {
		pixels_to_write = rle4_get_best_unc_split(rlectx->unc_len);

		if(pixels_to_write<3) {
			dstbuf[0] = (iw_byte)pixels_to_write;
			dstbuf[1] = (rlectx->srcrow[rlectx->pending_data_start]<<4);
			if(pixels_to_write>1)
				dstbuf[1] |= (rlectx->srcrow[rlectx->pending_data_start+1]);

			bytes_to_write = 2;
		}
		else {
			size_t i;

			dstbuf[0] = 0x00;
			dstbuf[1] = (iw_byte)pixels_to_write;
			iwbmp_write(rlectx->wctx,dstbuf,2);
			rlectx->total_bytes_written+=2;

			bytes_to_write = 2*((pixels_to_write+3)/4);
			iw_zeromem(dstbuf,bytes_to_write);

			for(i=0;i<pixels_to_write;i++) {
				if(i&0x1) dstbuf[i/2] |= rlectx->srcrow[rlectx->pending_data_start+i];
				else dstbuf[i/2] = rlectx->srcrow[rlectx->pending_data_start+i]<<4;
			}
		}

		iwbmp_write(rlectx->wctx,dstbuf,bytes_to_write);
		rlectx->total_bytes_written += bytes_to_write;
		rlectx->unc_len -= pixels_to_write;
		rlectx->pending_data_start += pixels_to_write;
	}
}

static IW_INLINE unsigned int get_raw_sample_8(struct iw_context *ctx,
	   int x, int y, int channel)
{
	unsigned short tmpui8;
	tmpui8 = ctx->img1.pixels[y*ctx->img1.bpr + ctx->img1_numchannels_physical*x + channel];
	return tmpui8;
}

static int process_bf_mask(struct iwbmprcontext *rctx, int k)
{
	rctx->bf_high_bit[k] = find_high_bit(rctx->bf_mask[k]);
	rctx->bf_low_bit[k] = find_low_bit(rctx->bf_mask[k]);
	rctx->bf_bits_count[k] = 1+rctx->bf_high_bit[k]-rctx->bf_low_bit[k];

	if(rctx->bf_high_bit[k] > (int)(rctx->bitcount-1)) return 0;

	if(rctx->bf_bits_count[k]>16) {
		rctx->bf_low_bit[k] = rctx->bf_high_bit[k]-15;
		rctx->bf_bits_count[k] = 16;
	}

	if(rctx->bf_bits_count[k]>8) {
		rctx->need_16bit = 1;
	}

	return 1;
}

static int bmpr_read_rle(struct iwbmprcontext *rctx)
{
	int retval = 0;

	if(!(rctx->compression==IWBMP_BI_RLE8 && rctx->bitcount==8) &&
 		!(rctx->compression==IWBMP_BI_RLE4 && rctx->bitcount==4))
 	{
 		iw_set_error(rctx->ctx,"Compression type incompatible with image type");
 	}
 
 	if(rctx->topdown) {
 		iw_set_error(rctx->ctx,"Compression not allowed with top-down images");
 	}
 
	rctx->img->imgtype = IW_IMGTYPE_RGBA;
	rctx->img->bit_depth = 8;
	rctx->img->bpr = iw_calc_bytesperrow(rctx->width,32);

	rctx->img->pixels = (iw_byte*)iw_malloc_large(rctx->ctx,rctx->img->bpr,rctx->img->height);
	if(!rctx->img->pixels) goto done;

	if(!bmpr_read_rle_internal(rctx)) goto done;

	if(!bmpr_has_transparency(rctx->img)) {
		bmpr_strip_alpha(rctx->img);
	}

	retval = 1;
done:
	return retval;
}

static void bmpr_convert_row_32_16(struct iwbmprcontext *rctx, const iw_byte *src, size_t row)
{
	int i,k;
	unsigned int v,x;
	int numchannels;

	numchannels = rctx->has_alpha_channel ? 4 : 3;

	for(i=0;i<rctx->width;i++) {
		if(rctx->bitcount==32) {
			x = ((unsigned int)src[i*4+0]) | ((unsigned int)src[i*4+1])<<8 |
				((unsigned int)src[i*4+2])<<16 | ((unsigned int)src[i*4+3])<<24;
		}
		else { // 16
			x = ((unsigned int)src[i*2+0]) | ((unsigned int)src[i*2+1])<<8;
		}
		v = 0;
		for(k=0;k<numchannels;k++) { // For red, green, blue [, alpha]:
			v = x & rctx->bf_mask[k];
			if(rctx->bf_low_bit[k]>0)
				v >>= rctx->bf_low_bit[k];
			if(rctx->img->bit_depth==16) {
				rctx->img->pixels[row*rctx->img->bpr + i*numchannels*2 + k*2+0] = (iw_byte)(v>>8);
				rctx->img->pixels[row*rctx->img->bpr + i*numchannels*2 + k*2+1] = (iw_byte)(v&0xff);
			}
			else {
				rctx->img->pixels[row*rctx->img->bpr + i*numchannels + k] = (iw_byte)v;
			}
		}
	}
}

static void put_raw_sample(struct iw_context *ctx, double s,
	   int x, int y, int channel)
{
	switch(ctx->img2.bit_depth) {
	case 8:  put_raw_sample_8(ctx,s,x,y,channel); break;
	case 16: put_raw_sample_16(ctx,s,x,y,channel); break;
	}
}

IW_IMPL(double) iw_convert_sample_to_linear(double v, const struct iw_csdescr *csdescr)
{
	return (double)x_to_linear_sample(v,csdescr);
}

static void clamp_output_samples(struct iw_context *ctx, iw_tmpsample *out_pix, int num_out_pix)
{
	int i;

	for(i=0;i<num_out_pix;i++) {
		if(out_pix[i]<0.0) out_pix[i]=0.0;
		else if(out_pix[i]>1.0) out_pix[i]=1.0;
	}
}

static int iwbmp_read_palette(struct iwbmprcontext *rctx)
{
	size_t i;
	iw_byte buf[4*256];
	size_t b;
	unsigned int valid_palette_entries;
	size_t valid_palette_nbytes;

	b = (rctx->bmpversion==2) ? 3 : 4; // bytes per palette entry

	if(rctx->infoheader_size==64) {
		if(rctx->fileheader_size + rctx->infoheader_size + rctx->palette_entries*3 ==
			rctx->bfOffBits)
		{
			iw_warning(rctx->ctx,"BMP bitmap overlaps colormap; assuming colormap uses 3 bytes per entry instead of 4");
			b = 3;
			rctx->palette_nbytes = 3*rctx->palette_entries;
		}
	}

	valid_palette_entries = (rctx->palette_entries<=256) ? rctx->palette_entries : 256;
	valid_palette_nbytes = valid_palette_entries * b;


	if(!iwbmp_read(rctx,buf,valid_palette_nbytes)) return 0;
	rctx->palette.num_entries = valid_palette_entries;
	for(i=0;i<valid_palette_entries;i++) {
		rctx->palette.entry[i].b = buf[i*b+0];
		rctx->palette.entry[i].g = buf[i*b+1];
		rctx->palette.entry[i].r = buf[i*b+2];
		rctx->palette.entry[i].a = 255;
	}

	if(rctx->palette_nbytes > valid_palette_nbytes) {
		iwbmp_skip_bytes(rctx, rctx->palette_nbytes - valid_palette_nbytes);
	}
	return 1;
}

static int iwbmp_calc_bitfields_masks(struct iwbmpwcontext *wctx, int num_masks)
{
	int k;
	int bits[4]; // R, G, B, A
	int tot_bits = 0;

	for(k=0;k<num_masks;k++) {
		bits[k] = iw_max_color_to_bitdepth(wctx->maxcolor[k]);
		tot_bits += bits[k];
	}

	if(tot_bits > 32) {
		iw_set_error(wctx->ctx,"Cannot write a BMP image in this color format");
		return 0;
	}
	
	wctx->bitcount = (tot_bits>16) ? 32 : 16;

	wctx->bf_amt_to_shift[0] = bits[1] + bits[2];
	wctx->bf_amt_to_shift[1] = bits[2];
	wctx->bf_amt_to_shift[2] = 0;
	if(num_masks>3) wctx->bf_amt_to_shift[3] =  bits[0] + bits[1] + bits[2];

	for(k=0;k<num_masks;k++) {
		wctx->bf_mask[k] = wctx->maxcolor[k] << wctx->bf_amt_to_shift[k];
	}

	return 1;
}

static void rle8_write_unc_and_run(struct rle_context *rlectx)
{
	iw_byte dstbuf[2];

	rle8_write_unc(rlectx);

	if(rlectx->run_len<1) {
		return;
	}
	if(rlectx->run_len>255) {
		iw_set_error(rlectx->ctx,"Internal: RLE encode error 6");
		return;
	}

	dstbuf[0] = (iw_byte)rlectx->run_len;
	dstbuf[1] = rlectx->run_byte;
	iwbmp_write(rlectx->wctx,dstbuf,2);
	rlectx->total_bytes_written+=2;

	rlectx->pending_data_start+=rlectx->run_len;
	rlectx->run_len=0;
}

static IW_INLINE unsigned int get_raw_sample_1(struct iw_context *ctx,
	   int x, int y)
{
	unsigned short tmpui8;
	tmpui8 = ctx->img1.pixels[y*ctx->img1.bpr + x/8];
	if(tmpui8 & (1<<(7-x%8))) return 1;
	return 0;
}

static iw_tmpsample cvt_int_sample_to_linear_output(struct iw_context *ctx,
	unsigned int v, const struct iw_csdescr *csdescr, double overall_maxcolorcode)
{
	iw_tmpsample s;

	if(csdescr->cstype==IW_CSTYPE_LINEAR) {
		return ((double)v) / overall_maxcolorcode;
	}
	else if(ctx->output_rev_color_corr_table) {
		return ctx->output_rev_color_corr_table[v];
	}

	s = ((double)v) / overall_maxcolorcode;
	return x_to_linear_sample(s,csdescr);
}

static iw_tmpsample cvt_int_sample_to_linear(struct iw_context *ctx,
	unsigned int v, const struct iw_csdescr *csdescr)
{
	iw_tmpsample s;

	if(csdescr->cstype==IW_CSTYPE_LINEAR) {
		return ((double)v) / ctx->input_maxcolorcode;
	}
	else if(ctx->input_color_corr_table) {
		return ctx->input_color_corr_table[v];
	}

	s = ((double)v) / ctx->input_maxcolorcode;
	return x_to_linear_sample(s,csdescr);
}

static size_t iwbmp_calc_bpr(int bpp, size_t width)
{
	return ((bpp*width+31)/32)*4;
}

static iw_tmpsample linear_to_x_sample(iw_tmpsample samp_lin, const struct iw_csdescr *csdescr)
{
	if(samp_lin > 0.999999999) {
		return 1.0;
	}

	switch(csdescr->cstype) {
	case IW_CSTYPE_SRGB:
		return linear_to_srgb_sample(samp_lin);
	case IW_CSTYPE_LINEAR:
		return samp_lin;
	case IW_CSTYPE_GAMMA:
		return linear_to_gamma_sample(samp_lin,csdescr->gamma);
	case IW_CSTYPE_REC709:
		return linear_to_rec709_sample(samp_lin);
	}
	return linear_to_srgb_sample(samp_lin);
}

static void iwbmp_write(struct iwbmpwcontext *wctx, const void *buf, size_t n)
{
	(*wctx->iodescr->write_fn)(wctx->ctx,wctx->iodescr,buf,n);
	wctx->total_written+=n;
}

static void iwbmp_set_default_bitfields(struct iwbmprcontext *rctx)
{
	int k;

	if(rctx->bitfields_set) return;

	if(rctx->bitcount==16) {
		rctx->bf_mask[0]=0x7c00; // 01111100 00000000 (red)
		rctx->bf_mask[1]=0x03e0; // 00000011 11100000 (green)
		rctx->bf_mask[2]=0x001f; // 00000000 00011111 (blue)
	}
	else if(rctx->bitcount==32) {
		rctx->bf_mask[0]=0x00ff0000;
		rctx->bf_mask[1]=0x0000ff00;
		rctx->bf_mask[2]=0x000000ff;
	}
	else {
		return;
	}

	for(k=0;k<3;k++) {
		process_bf_mask(rctx,k);
	}
}

static int iwbmp_write_main(struct iwbmpwcontext *wctx)
{
	struct iw_image *img;
	int cmpr_req;
	int retval = 0;
	int x;
	const char *optv;

	img = wctx->img;

	wctx->bmpversion = 0;
	optv = iw_get_option(wctx->ctx, "bmp:version");
	if(optv) {
		wctx->bmpversion = iw_parse_int(optv);
	}

	if(wctx->bmpversion==0) wctx->bmpversion=3;
	if(wctx->bmpversion==4) {
		iw_warning(wctx->ctx,"Writing BMP v4 is not supported; using v3 instead");
		wctx->bmpversion=3;
	}
	if(wctx->bmpversion!=2 && wctx->bmpversion!=3 && wctx->bmpversion!=5) {
		iw_set_errorf(wctx->ctx,"Unsupported BMP version: %d",wctx->bmpversion);
		goto done;
	}

	if(wctx->bmpversion>=3)
		cmpr_req = iw_get_value(wctx->ctx,IW_VAL_COMPRESSION);
	else
		cmpr_req = IW_COMPRESSION_NONE;

	if(wctx->bmpversion==2)
		wctx->header_size = 12;
	else if(wctx->bmpversion==5)
		wctx->header_size = 124;
	else
		wctx->header_size = 40;

	wctx->no_cslabel = iw_get_value(wctx->ctx,IW_VAL_NO_CSLABEL);

	if(cmpr_req==IW_COMPRESSION_AUTO || cmpr_req==IW_COMPRESSION_NONE)
		cmpr_req = IW_COMPRESSION_NONE;
	else
		cmpr_req = IW_COMPRESSION_RLE;

	if(img->imgtype==IW_IMGTYPE_RGB) {
		if(img->reduced_maxcolors) {
			if(!setup_16_32bit(wctx,img->maxcolorcode[IW_CHANNELTYPE_RED],
				img->maxcolorcode[IW_CHANNELTYPE_GREEN],
				img->maxcolorcode[IW_CHANNELTYPE_BLUE],0))
			{
				goto done;
			}
		}
		else {
			wctx->bitcount=24;
		}
	}
	else if(img->imgtype==IW_IMGTYPE_PALETTE) {
		if(!wctx->pal) goto done;

		x = check_palette_transparency(wctx->pal);

		if(x!=0 && wctx->bmpversion<3) {
			iw_set_error(wctx->ctx,"Cannot save as a transparent BMP: Incompatible BMP version");
			goto done;
		}
		else if(x==2) {
			iw_set_error(wctx->ctx,"Cannot save this image as a transparent BMP: Has partial transparency");
			goto done;
		}
		else if(x!=0 && cmpr_req!=IW_COMPRESSION_RLE) {
			iw_set_error(wctx->ctx,"Cannot save as a transparent BMP: RLE compression required");
			goto done;
		}

		if(wctx->pal->num_entries<=2 && cmpr_req!=IW_COMPRESSION_RLE)
			wctx->bitcount=1;
		else if(wctx->pal->num_entries<=16)
			wctx->bitcount=4;
		else
			wctx->bitcount=8;
	}
	else if(img->imgtype==IW_IMGTYPE_RGBA) {
		if(img->reduced_maxcolors) {
			if(!setup_16_32bit(wctx,img->maxcolorcode[IW_CHANNELTYPE_RED],
				img->maxcolorcode[IW_CHANNELTYPE_GREEN],
				img->maxcolorcode[IW_CHANNELTYPE_BLUE],
				img->maxcolorcode[IW_CHANNELTYPE_ALPHA]))
			{
				goto done;
			}
		}
		else {
			if(!setup_16_32bit(wctx,255,255,255,255)) {
				goto done;
			}
		}
	}
	else if(img->imgtype==IW_IMGTYPE_GRAYA) {
		if(img->reduced_maxcolors) {
			if(!setup_16_32bit(wctx,img->maxcolorcode[IW_CHANNELTYPE_GRAY],
				img->maxcolorcode[IW_CHANNELTYPE_GRAY],
				img->maxcolorcode[IW_CHANNELTYPE_GRAY],
				img->maxcolorcode[IW_CHANNELTYPE_ALPHA]))
			{
				goto done;
			}
		}
		else {
			if(!setup_16_32bit(wctx,255,255,255,255)) {
				goto done;
			}
		}
	}
	else if(img->imgtype==IW_IMGTYPE_GRAY) {
		if(img->reduced_maxcolors) {
			if(img->maxcolorcode[IW_CHANNELTYPE_GRAY]<=1023) {
				if(!setup_16_32bit(wctx,img->maxcolorcode[IW_CHANNELTYPE_GRAY],
					img->maxcolorcode[IW_CHANNELTYPE_GRAY],
					img->maxcolorcode[IW_CHANNELTYPE_GRAY],0))
				{
					goto done;
				}
			}
			else {
				iw_set_error(wctx->ctx,"Cannot write grayscale BMP at this bit depth");
				goto done;
			}
		}
		else {
			wctx->bitcount=24;
		}
	}
	else {
		iw_set_error(wctx->ctx,"Internal: Bad image type for BMP");
		goto done;
	}

	if(cmpr_req==IW_COMPRESSION_RLE && (wctx->bitcount==4 || wctx->bitcount==8)) {
		wctx->compressed = 1;
	}

	wctx->unc_dst_bpr = iwbmp_calc_bpr(wctx->bitcount,img->width);
	wctx->unc_bitssize = wctx->unc_dst_bpr * img->height;
	wctx->palentries = 0;

	if(wctx->pal) {
		if(wctx->bmpversion==2) {
			wctx->palentries = 1<<wctx->bitcount;
			wctx->palsize = wctx->palentries*3;
		}
		else {
			if(wctx->bitcount==1) {
				wctx->palentries=2;
			}
			else {
				wctx->palentries = wctx->pal->num_entries;
			}
			wctx->palsize = wctx->palentries*4;
		}
	}

	iwbmp_write_file_header(wctx);

	if(!iwbmp_write_bmp_header(wctx)) {
		goto done;
	}

	if(wctx->bitfields_size>0) {
		if(!iwbmp_write_bitfields(wctx)) goto done;
	}

	iwbmp_write_palette(wctx);

	if(wctx->compressed) {
		if(!iwbmp_write_pixels_compressed(wctx,img)) goto done;
	}
	else {
		iwbmp_write_pixels_uncompressed(wctx,img);
	}

	retval = 1;
done:
	return retval;
}

static unsigned int iw_scale_to_int(double s, unsigned int maxcolor)
{
	if(s<=0.0) return 0;
	if(s>=1.0) return maxcolor;
	return (unsigned int)(0.5+s*maxcolor);
}

IW_IMPL(double) iw_convert_sample_from_linear(double v, const struct iw_csdescr *csdescr)
{
	return (double)linear_to_x_sample(v,csdescr);
}

static int find_low_bit(unsigned int x)
{
	int i;
	for(i=0;i<=31;i++) {
		if(x&(1U<<(unsigned int)i)) return i;
	}
	return 0;
}

static void bmpr_convert_row_4(struct iwbmprcontext *rctx,const iw_byte *src, size_t row)
{
	int i;
	int pal_index;

	for(i=0;i<rctx->width;i++) {
		pal_index = (i&0x1) ? src[i/2]&0x0f : src[i/2]>>4;
		rctx->img->pixels[row*rctx->img->bpr + i*3 + 0] = rctx->palette.entry[pal_index].r;
		rctx->img->pixels[row*rctx->img->bpr + i*3 + 1] = rctx->palette.entry[pal_index].g;
		rctx->img->pixels[row*rctx->img->bpr + i*3 + 2] = rctx->palette.entry[pal_index].b;
	}
}

static IW_INLINE iw_tmpsample linear_to_gamma_sample(iw_tmpsample v_linear, double gamma)
{
	return pow(v_linear,1.0/gamma);
}

static IW_INLINE iw_tmpsample srgb_to_linear_sample(iw_tmpsample v_srgb)
{
	if(v_srgb<=0.04045) {
		return v_srgb/12.92;
	}
	else {
		return pow( (v_srgb+0.055)/(1.055) , 2.4);
	}
}

static iw_tmpsample iw_color_to_grayscale(struct iw_context *ctx,
	iw_tmpsample r, iw_tmpsample g, iw_tmpsample b)
{
	iw_tmpsample v0,v1,v2;

	switch(ctx->grayscale_formula) {
	case IW_GSF_WEIGHTED:
		return ctx->grayscale_weight[0]*r +
			ctx->grayscale_weight[1]*g +
			ctx->grayscale_weight[2]*b;
	case IW_GSF_ORDERBYVALUE:
		if(g<=r) { v0=r; v1=g; }
		else { v0=g; v1=r; }
		if(b<=v1) {
			v2=b;
		}
		else {
			v2=v1;
			if(b<=v0) { v1=b; }
			else { v1=v0; v0=b; }
		}
		return ctx->grayscale_weight[0]*v0 +
			ctx->grayscale_weight[1]*v1 +
			ctx->grayscale_weight[2]*v2;
	}
	return 0.0;
}

static double get_final_sample_using_nc_tbl(struct iw_context *ctx, iw_tmpsample samp_lin)
{
	unsigned int x;
	unsigned int d;



	x = 127;
	d = 64;

	while(1) {
		if(x>254 || ctx->nearest_color_table[x] > samp_lin)
			x -= d;
		else
			x += d;

		if(d==1) {
			if(x>254 || ctx->nearest_color_table[x] > samp_lin)
				return (double)(x);
			else
				return (double)(x+1);
		}

		d = d/2;
	}
}

static int check_palette_transparency(const struct iw_palette *p)
{
	int i;
	int retval = 0;

	for(i=0;i<p->num_entries;i++) {
		if(p->entry[i].a!=255) retval=1;
		if(p->entry[i].a!=255 && p->entry[i].a!=0) return 2;
	}
	return retval;
}

static void iw_set_intermed_channeltypes(struct iw_context *ctx)
{
	int i;
	for(i=0;i<ctx->intermed_numchannels;i++) {
		ctx->intermed_ci[i].channeltype = iw_get_channeltype(ctx->intermed_imgtype,i);
	}
}

static int iw_process_cols_to_intermediate(struct iw_context *ctx, int channel,
	const struct iw_csdescr *in_csdescr)
{
	int i,j;
	int retval=0;
	iw_tmpsample tmp_alpha;
	iw_tmpsample *inpix_tofree = NULL;
	iw_tmpsample *outpix_tofree = NULL;
	int is_alpha_channel;
	struct iw_resize_settings *rs = NULL;
	struct iw_channelinfo_intermed *int_ci;

	iw_tmpsample *in_pix;
	iw_tmpsample *out_pix;
	int num_in_pix;
	int num_out_pix;

	int_ci = &ctx->intermed_ci[channel];
	is_alpha_channel = (int_ci->channeltype==IW_CHANNELTYPE_ALPHA);

	num_in_pix = ctx->input_h;
	inpix_tofree = (iw_tmpsample*)iw_malloc(ctx, num_in_pix * sizeof(iw_tmpsample));
	if(!inpix_tofree) goto done;
	in_pix = inpix_tofree;

	num_out_pix = ctx->intermed_canvas_height;
	outpix_tofree = (iw_tmpsample*)iw_malloc(ctx, num_out_pix * sizeof(iw_tmpsample));
	if(!outpix_tofree) goto done;
	out_pix = outpix_tofree;

	rs=&ctx->resize_settings[IW_DIMENSION_V];

	if(!rs->rrctx) {
		rs->rrctx = iwpvt_resize_rows_init(ctx,rs,int_ci->channeltype,
			num_in_pix, num_out_pix);
		if(!rs->rrctx) goto done;
	}

	for(i=0;i<ctx->input_w;i++) {

		for(j=0;j<ctx->input_h;j++) {

			in_pix[j] = get_sample_cvt_to_linear(ctx,i,j,channel,in_csdescr);

			if(int_ci->need_unassoc_alpha_processing) { // We need opacity information also
				tmp_alpha = get_raw_sample(ctx,i,j,ctx->img1_alpha_channel_index);

				in_pix[j] *= tmp_alpha;
			}
			else if(ctx->apply_bkgd && ctx->apply_bkgd_strategy==IW_BKGD_STRATEGY_EARLY) {
				tmp_alpha = get_raw_sample(ctx,i,j,ctx->img1_alpha_channel_index);
				in_pix[j] = (tmp_alpha)*(in_pix[j]) +
					(1.0-tmp_alpha)*(int_ci->bkgd_color_lin);
			}
		}


		iwpvt_resize_row_main(rs->rrctx,in_pix,out_pix);

		if(ctx->intclamp)
			clamp_output_samples(ctx,out_pix,num_out_pix);

		for(j=0;j<ctx->intermed_canvas_height;j++) {
			if(is_alpha_channel) {
				ctx->intermediate_alpha32[((size_t)j)*ctx->intermed_canvas_width + i] = (iw_float32)out_pix[j];
			}
			else {
				ctx->intermediate32[((size_t)j)*ctx->intermed_canvas_width + i] = (iw_float32)out_pix[j];
			}
		}
	}

	retval=1;

done:
	if(rs && rs->disable_rrctx_cache && rs->rrctx) {
		iwpvt_resize_rows_done(rs->rrctx);
		rs->rrctx = NULL;
	}
	if(inpix_tofree) iw_free(ctx,inpix_tofree);
	if(outpix_tofree) iw_free(ctx,outpix_tofree);
 	return retval;
 }

static int iw_random_dither(struct iw_context *ctx, double fraction, int x, int y,
	int dithersubtype, int channel)
{
	double threshold;

	threshold = ((double)iwpvt_prng_rand(ctx->prng)) / (double)0xffffffff;
	if(fraction>=threshold) return 1;
	return 0;
}

static void decide_output_bit_depth(struct iw_context *ctx)
{
	if(ctx->output_profile&IW_PROFILE_HDRI) {
		ctx->img2.sampletype=IW_SAMPLETYPE_FLOATINGPOINT;
	}
	else {
		ctx->img2.sampletype=IW_SAMPLETYPE_UINT;
	}

	if(ctx->img2.sampletype==IW_SAMPLETYPE_FLOATINGPOINT) {
		ctx->img2.bit_depth=32;
		return;
	}


	if(ctx->req.output_depth>8 && (ctx->output_profile&IW_PROFILE_16BPS)) {
		ctx->img2.bit_depth=16;
	}
	else {
		if(ctx->req.output_depth>8) {
			iw_warning(ctx,"Reducing depth to 8; required by the output format.");
		}
		ctx->img2.bit_depth=8;
	}
}

static int bmpr_read_uncompressed(struct iwbmprcontext *rctx)
{
	iw_byte *rowbuf = NULL;
	size_t bmp_bpr;
	int j;
	int retval = 0;

	if(rctx->has_alpha_channel) {
		rctx->img->imgtype = IW_IMGTYPE_RGBA;
		
		rctx->img->bit_depth = rctx->need_16bit ? 16 : 8;
		rctx->img->bpr = iw_calc_bytesperrow(rctx->width,4*rctx->img->bit_depth);
	}
	else {
		rctx->img->imgtype = IW_IMGTYPE_RGB;
		rctx->img->bit_depth = rctx->need_16bit ? 16 : 8;
		rctx->img->bpr = iw_calc_bytesperrow(rctx->width,3*rctx->img->bit_depth);
	}

	bmp_bpr = iwbmp_calc_bpr(rctx->bitcount,rctx->width);

	rctx->img->pixels = (iw_byte*)iw_malloc_large(rctx->ctx,rctx->img->bpr,rctx->img->height);
	if(!rctx->img->pixels) goto done;

	rowbuf = iw_malloc(rctx->ctx,bmp_bpr);

	for(j=0;j<rctx->img->height;j++) {
		if(!iwbmp_read(rctx,rowbuf,bmp_bpr)) {
			goto done;
		}
		switch(rctx->bitcount) {
		case 32:
		case 16:
			bmpr_convert_row_32_16(rctx,rowbuf,j);
			break;
		case 24:
			bmpr_convert_row_24(rctx,rowbuf,j);
			break;
		case 8:
			bmpr_convert_row_8(rctx,rowbuf,j);
			break;
		case 4:
			bmpr_convert_row_4(rctx,rowbuf,j);
			break;
		case 2:
			bmpr_convert_row_2(rctx,rowbuf,j);
			break;
		case 1:
			bmpr_convert_row_1(rctx,rowbuf,j);
			break;
		}
	}

	retval = 1;
done:
	if(rowbuf) iw_free(rctx->ctx,rowbuf);
	return retval;
}

static int get_nearest_valid_colors(struct iw_context *ctx, iw_tmpsample samp_lin,
		const struct iw_csdescr *csdescr,
		double *s_lin_floor_1, double *s_lin_ceil_1,
		double *s_cvt_floor_full, double *s_cvt_ceil_full,
		double overall_maxcolorcode, int color_count)
{
	iw_tmpsample samp_cvt;
	double samp_cvt_expanded;
	unsigned int floor_int, ceil_int;

	samp_cvt = linear_to_x_sample(samp_lin,csdescr);

	if(color_count==0) {
		samp_cvt_expanded = samp_cvt * overall_maxcolorcode;
		if(samp_cvt_expanded>overall_maxcolorcode) samp_cvt_expanded=overall_maxcolorcode;
		if(samp_cvt_expanded<0.0) samp_cvt_expanded=0.0;

		*s_cvt_floor_full = floor(samp_cvt_expanded);
		*s_cvt_ceil_full  = ceil(samp_cvt_expanded);
	}
	else {
		double posterized_maxcolorcode;

		posterized_maxcolorcode = (double)(color_count-1);

		samp_cvt_expanded = samp_cvt * posterized_maxcolorcode;
		if(samp_cvt_expanded>posterized_maxcolorcode) samp_cvt_expanded=posterized_maxcolorcode;
		if(samp_cvt_expanded<0.0) samp_cvt_expanded=0.0;

		*s_cvt_floor_full = floor(0.5000000001 + floor(samp_cvt_expanded) * (overall_maxcolorcode/posterized_maxcolorcode));
		*s_cvt_ceil_full  = floor(0.5000000001 + ceil (samp_cvt_expanded) * (overall_maxcolorcode/posterized_maxcolorcode));
	}

	floor_int = (unsigned int)(*s_cvt_floor_full);
	ceil_int  = (unsigned int)(*s_cvt_ceil_full);
	if(floor_int == ceil_int) {
		return 1;
	}

	*s_lin_floor_1 = cvt_int_sample_to_linear_output(ctx,floor_int,csdescr,overall_maxcolorcode);
	*s_lin_ceil_1 =  cvt_int_sample_to_linear_output(ctx,ceil_int ,csdescr,overall_maxcolorcode);

	return 0;
}

static IW_INLINE iw_tmpsample linear_to_rec709_sample(iw_tmpsample v_linear)
{
	if(v_linear < 0.020) {
		return 4.5*v_linear;
	}
	return 1.099*pow(v_linear,0.45) - 0.099;
}

static void iw_restrict_to_range(int r1, int r2, int *pvar)
{
	if(*pvar < r1) *pvar = r1;
	else if(*pvar > r2) *pvar = r2;
}

static int find_high_bit(unsigned int x)
{
	int i;
	for(i=31;i>=0;i--) {
		if(x&(1U<<(unsigned int)i)) return i;
	}
	return 0;
}

static int rle4_compress_row(struct rle_context *rlectx)
{
	size_t i;
	iw_byte dstbuf[2];
	iw_byte next_pix;
	int next_pix_is_trns;
	int num_trns = 0; // number of consecutive transparent pixels seen
	int retval = 0;
	iw_byte tmpb;

	rlectx->pending_data_start=0;
	rlectx->unc_len=0;
	rlectx->run_len=0;

	for(i=0;i<rlectx->img_width;i++) {

		next_pix = rlectx->srcrow[i];

		next_pix_is_trns = (rlectx->wctx->pal->entry[next_pix].a==0);
		if(num_trns>0 && !next_pix_is_trns) {
			rle_write_trns(rlectx,num_trns);
			num_trns=0;
		}
		else if(next_pix_is_trns) {
			if (rlectx->unc_len>0 || rlectx->run_len>0) {
				rle4_write_unc_and_run(rlectx);
			}
			num_trns++;
			continue;
		}


		if(rlectx->run_len==0) {
			rlectx->run_len = 1;
			rlectx->run_byte = next_pix<<4;
		}
		else if(rlectx->run_len==1) {
			rlectx->run_byte |= next_pix;
			rlectx->run_len++;
		}
		else if(rlectx->run_len>=2 && (rlectx->run_len&1)==0 && next_pix==(rlectx->run_byte>>4)) {
			rlectx->run_len++;
		}
		else if(rlectx->run_len>=3 && (rlectx->run_len&1) && next_pix==(rlectx->run_byte&0x0f)) {
			rlectx->run_len++;
		}
		else if(rlectx->unc_len==0 && rlectx->run_len==2) {
			rlectx->unc_len+=rlectx->run_len;
			rlectx->run_byte = next_pix<<4;
			rlectx->run_len = 1;
		}
		else if(ok_to_move_to_unc(rlectx)) {
			rlectx->unc_len += rlectx->run_len-1;
 
			if((rlectx->run_len&1)==0)
				rlectx->run_byte = (rlectx->run_byte&0x0f)<<4;
			else
				rlectx->run_byte = (rlectx->run_byte&0xf0);

			rlectx->run_len = 2;
			rlectx->run_byte |= next_pix;
		}
		else {
			rle4_write_unc_and_run(rlectx);
			rlectx->run_len = 1;
			rlectx->run_byte = next_pix<<4;
		}

		while(rlectx->unc_len>0 && rlectx->run_len>0 && rle4_get_incr_unc_cost(rlectx)==0) {
			rlectx->unc_len++;
			rlectx->run_len--;
			tmpb = rlectx->run_byte;
			rlectx->run_byte = (tmpb>>4) | ((tmpb&0x0f)<<4);
			if(rlectx->run_len==1) rlectx->run_byte &= 0xf0;
		}


		if(rlectx->run_len>=255) {
			rle4_write_unc_and_run(rlectx);
		}


		if(rlectx->run_len>255) {
			iw_set_error(rlectx->ctx,"Internal: BMP RLE encode error 3");
			goto done;
		}
	}

	rle4_write_unc_and_run(rlectx);

	dstbuf[0]=0x00;
	dstbuf[1]= (rlectx->cur_row==0)? 0x01 : 0x00;
	iwbmp_write(rlectx->wctx,dstbuf,2);
	rlectx->total_bytes_written+=2;

	retval = 1;

done:
	return retval;
}

static void bmpr_convert_row_2(struct iwbmprcontext *rctx,const iw_byte *src, size_t row)
{
	int i;
	int pal_index;

	for(i=0;i<rctx->width;i++) {
		pal_index = (src[i/4]>>(2*(3-i%4)))&0x03;
		rctx->img->pixels[row*rctx->img->bpr + i*3 + 0] = rctx->palette.entry[pal_index].r;
		rctx->img->pixels[row*rctx->img->bpr + i*3 + 1] = rctx->palette.entry[pal_index].g;
		rctx->img->pixels[row*rctx->img->bpr + i*3 + 2] = rctx->palette.entry[pal_index].b;
	}
}

static void rle8_write_unc(struct rle_context *rlectx)
{
	size_t i;
	iw_byte dstbuf[2];

	if(rlectx->unc_len<1) return;
	if(rlectx->unc_len>=3 && (rlectx->unc_len&1)) {
		iw_set_error(rlectx->ctx,"Internal: RLE encode error 4");
		return;
	}
	if(rlectx->unc_len>254) {
		iw_set_error(rlectx->ctx,"Internal: RLE encode error 5");
		return;
	}

	if(rlectx->unc_len<3) {
		for(i=0;i<rlectx->unc_len;i++) {
			dstbuf[0] = 0x01;  // count
			dstbuf[1] = rlectx->srcrow[i+rlectx->pending_data_start]; // value
			iwbmp_write(rlectx->wctx,dstbuf,2);
			rlectx->total_bytes_written+=2;
		}
	}
	else {
		dstbuf[0] = 0x00;
		dstbuf[1] = (iw_byte)rlectx->unc_len;
		iwbmp_write(rlectx->wctx,dstbuf,2);
		rlectx->total_bytes_written+=2;
		iwbmp_write(rlectx->wctx,&rlectx->srcrow[rlectx->pending_data_start],rlectx->unc_len);
		rlectx->total_bytes_written+=rlectx->unc_len;
		if(rlectx->unc_len&0x1) {
			dstbuf[0] = 0x00;
			iwbmp_write(rlectx->wctx,dstbuf,1);
			rlectx->total_bytes_written+=1;
		}
	}

	rlectx->pending_data_start+=rlectx->unc_len;
	rlectx->unc_len=0;
}

static IW_INLINE unsigned int get_raw_sample_2(struct iw_context *ctx,
	   int x, int y)
{
	unsigned short tmpui8;
	tmpui8 = ctx->img1.pixels[y*ctx->img1.bpr + x/4];
	tmpui8 = ( tmpui8 >> ((3-x%4)*2) ) & 0x03;
	return tmpui8;
}
