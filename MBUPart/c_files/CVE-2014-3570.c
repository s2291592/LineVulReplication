static void message(BIO *out, char *m)
	{
	fprintf(stderr, "test %s\n", m);
	BIO_puts(out, "print \"test ");
	BIO_puts(out, m);
	BIO_puts(out, "\\n\"\n");
	}

int test_rshift1(BIO *bp)
	{
	BIGNUM *a,*b,*c;
	int i;

	a=BN_new();
	b=BN_new();
	c=BN_new();

	BN_bntest_rand(a,200,0,0); /**/
	a->neg=rand_neg();
	for (i=0; i<num0; i++)
		{
		BN_rshift1(b,a);
		if (bp != NULL)
			{
			if (!results)
				{
				BN_print(bp,a);
				BIO_puts(bp," / 2");
				BIO_puts(bp," - ");
				}
			BN_print(bp,b);
			BIO_puts(bp,"\n");
			}
		BN_sub(c,a,b);
		BN_sub(c,c,b);
		if(!BN_is_zero(c) && !BN_abs_is_word(c, 1))
		    {
		    fprintf(stderr,"Right shift one test failed!\n");
		    return 0;
		    }
		BN_copy(a,b);
		}
	BN_free(a);
	BN_free(b);
	BN_free(c);
	return(1);
	}

int test_gf2m_mod_sqrt(BIO *bp,BN_CTX *ctx)
	{
	BIGNUM *a,*b[2],*c,*d,*e,*f;
	int i, j, ret = 0;
	int p0[] = {163,7,6,3,0,-1};
	int p1[] = {193,15,0,-1};

	a=BN_new();
	b[0]=BN_new();
	b[1]=BN_new();
	c=BN_new();
	d=BN_new();
	e=BN_new();
	f=BN_new();

	BN_GF2m_arr2poly(p0, b[0]);
	BN_GF2m_arr2poly(p1, b[1]);

	for (i=0; i<num0; i++)
		{
		BN_bntest_rand(a, 512, 0, 0);
		for (j=0; j < 2; j++)
			{
			BN_GF2m_mod(c, a, b[j]);
			BN_GF2m_mod_sqrt(d, a, b[j], ctx);
			BN_GF2m_mod_sqr(e, d, b[j], ctx);
#if 0 /* make test uses ouput in bc but bc can't handle GF(2^m) arithmetic */
			if (bp != NULL)
				{
				if (!results)
					{
					BN_print(bp,d);
					BIO_puts(bp, " ^ 2 - ");
					BN_print(bp,a);
					BIO_puts(bp,"\n");
					}
				}
#endif
			BN_GF2m_add(f, c, e);
			/* Test that d^2 = a, where d = sqrt(a). */
			if(!BN_is_zero(f))
				{
				fprintf(stderr,"GF(2^m) modular square root test failed!\n");
				goto err;
				}
			}
		}
	ret = 1;
  err:
	BN_free(a);
	BN_free(b[0]);
	BN_free(b[1]);
	BN_free(c);
	BN_free(d);
	BN_free(e);
	BN_free(f);
	return ret;
	}

int test_gf2m_mod_sqr(BIO *bp,BN_CTX *ctx)
	{
	BIGNUM *a,*b[2],*c,*d;
	int i, j, ret = 0;
	int p0[] = {163,7,6,3,0,-1};
	int p1[] = {193,15,0,-1};

	a=BN_new();
	b[0]=BN_new();
	b[1]=BN_new();
	c=BN_new();
	d=BN_new();

	BN_GF2m_arr2poly(p0, b[0]);
	BN_GF2m_arr2poly(p1, b[1]);

	for (i=0; i<num0; i++)
		{
		BN_bntest_rand(a, 1024, 0, 0);
		for (j=0; j < 2; j++)
			{
			BN_GF2m_mod_sqr(c, a, b[j], ctx);
			BN_copy(d, a);
			BN_GF2m_mod_mul(d, a, d, b[j], ctx);
#if 0 /* make test uses ouput in bc but bc can't handle GF(2^m) arithmetic */
			if (bp != NULL)
				{
				if (!results)
					{
					BN_print(bp,a);
					BIO_puts(bp," ^ 2 % ");
					BN_print(bp,b[j]);
					BIO_puts(bp, " = ");
					BN_print(bp,c);
					BIO_puts(bp,"; a * a = ");
					BN_print(bp,d);
					BIO_puts(bp,"\n");
					}
				}
#endif
			BN_GF2m_add(d, c, d);
			/* Test that a*a = a^2. */
			if(!BN_is_zero(d))
				{
				fprintf(stderr,"GF(2^m) modular squaring test failed!\n");
				goto err;
				}
			}
		}
	ret = 1;
  err:
	BN_free(a);
	BN_free(b[0]);
	BN_free(b[1]);
	BN_free(c);
	BN_free(d);
	return ret;
	}

int test_rshift(BIO *bp,BN_CTX *ctx)
	{
	BIGNUM *a,*b,*c,*d,*e;
	int i;

	a=BN_new();
	b=BN_new();
	c=BN_new();
	d=BN_new();
	e=BN_new();
	BN_one(c);

	BN_bntest_rand(a,200,0,0); /**/
	a->neg=rand_neg();
	for (i=0; i<num0; i++)
		{
		BN_rshift(b,a,i+1);
		BN_add(c,c,c);
		if (bp != NULL)
			{
			if (!results)
				{
				BN_print(bp,a);
				BIO_puts(bp," / ");
				BN_print(bp,c);
				BIO_puts(bp," - ");
				}
			BN_print(bp,b);
			BIO_puts(bp,"\n");
			}
		BN_div(d,e,a,c,ctx);
		BN_sub(d,d,b);
		if(!BN_is_zero(d))
		    {
		    fprintf(stderr,"Right shift test failed!\n");
		    return 0;
		    }
		}
	BN_free(a);
	BN_free(b);
	BN_free(c);
	BN_free(d);
	BN_free(e);
	return(1);
	}

int test_sqr(BIO *bp, BN_CTX *ctx)
{
	BIGNUM a,c,d,e;
	int i;

	BN_init(&a);
	BN_init(&c);
	BN_init(&d);
	BN_init(&e);

for (i=0; i<num0; i++)
{
		BN_bntest_rand(&a,40+i*10,0,0);
		a.neg=rand_neg();
		BN_sqr(&c,&a,ctx);
if (bp != NULL)
{
if (!results)
{
				BN_print(bp,&a);
BIO_puts(bp," * ");
				BN_print(bp,&a);
BIO_puts(bp," - ");
}
			BN_print(bp,&c);
BIO_puts(bp,"\n");
}
		BN_div(&d,&e,&c,&a,ctx);
		BN_sub(&d,&d,&a);
		if(!BN_is_zero(&d) || !BN_is_zero(&e))
		    {
		    fprintf(stderr,"Square test failed!\n");
		    return 0;
		    }
}
	BN_free(&a);
	BN_free(&c);
	BN_free(&d);
	BN_free(&e);
	return(1);
}

int test_lshift1(BIO *bp)
	{
	BIGNUM *a,*b,*c;
	int i;

	a=BN_new();
	b=BN_new();
	c=BN_new();

	BN_bntest_rand(a,200,0,0); /**/
	a->neg=rand_neg();
	for (i=0; i<num0; i++)
		{
		BN_lshift1(b,a);
		if (bp != NULL)
			{
			if (!results)
				{
				BN_print(bp,a);
				BIO_puts(bp," * 2");
				BIO_puts(bp," - ");
				}
			BN_print(bp,b);
			BIO_puts(bp,"\n");
			}
		BN_add(c,a,a);
		BN_sub(a,b,c);
		if(!BN_is_zero(a))
		    {
		    fprintf(stderr,"Left shift one test failed!\n");
		    return 0;
		    }
		
		BN_copy(a,b);
		}
	BN_free(a);
	BN_free(b);
	BN_free(c);
	return(1);
	}

BN_ULONG bn_add_words (BN_ULONG *rp, const BN_ULONG *ap, const BN_ULONG *bp,int n)
{ BN_ULONG ret;
  size_t i=0;

	if (n <= 0) return 0;

	asm volatile (
	"	subq	%0,%0		\n"	/* clear carry */
	"	jmp	1f		\n"
	".p2align 4			\n"
	"1:	movq	(%4,%2,8),%0	\n"
	"	adcq	(%5,%2,8),%0	\n"
	"	movq	%0,(%3,%2,8)	\n"
	"	lea	1(%2),%2	\n"
	"	loop	1b		\n"
	"	sbbq	%0,%0		\n"
		: "=&r"(ret),"+c"(n),"+r"(i)
		: "r"(rp),"r"(ap),"r"(bp)
		: "cc", "memory"
	);

  return ret&1;
}

int test_gf2m_add(BIO *bp)
	{
	BIGNUM a,b,c;
	int i, ret = 0;

	BN_init(&a);
	BN_init(&b);
	BN_init(&c);

	for (i=0; i<num0; i++)
		{
		BN_rand(&a,512,0,0);
		BN_copy(&b, BN_value_one());
		a.neg=rand_neg();
		b.neg=rand_neg();
		BN_GF2m_add(&c,&a,&b);
#if 0 /* make test uses ouput in bc but bc can't handle GF(2^m) arithmetic */
		if (bp != NULL)
			{
			if (!results)
				{
				BN_print(bp,&a);
				BIO_puts(bp," ^ ");
				BN_print(bp,&b);
				BIO_puts(bp," = ");
				}
			BN_print(bp,&c);
			BIO_puts(bp,"\n");
			}
#endif
		/* Test that two added values have the correct parity. */
		if((BN_is_odd(&a) && BN_is_odd(&c)) || (!BN_is_odd(&a) && !BN_is_odd(&c)))
			{
		    fprintf(stderr,"GF(2^m) addition test (a) failed!\n");
			goto err;
			}
		BN_GF2m_add(&c,&c,&c);
		/* Test that c + c = 0. */
		if(!BN_is_zero(&c))
		    {
		    fprintf(stderr,"GF(2^m) addition test (b) failed!\n");
			goto err;
		    }
		}
	ret = 1;
  err:
	BN_free(&a);
	BN_free(&b);
	BN_free(&c);
	return ret;
	}

BN_ULONG bn_mul_words(BN_ULONG *rp, const BN_ULONG *ap, int num, BN_ULONG w)
	{
	BN_ULONG c1=0;

	if (num <= 0) return(c1);

	while (num&~3)
		{
		mul(rp[0],ap[0],w,c1);
		mul(rp[1],ap[1],w,c1);
		mul(rp[2],ap[2],w,c1);
		mul(rp[3],ap[3],w,c1);
		ap+=4; rp+=4; num-=4;
		}
	if (num)
		{
		mul(rp[0],ap[0],w,c1); if (--num == 0) return c1;
		mul(rp[1],ap[1],w,c1); if (--num == 0) return c1;
		mul(rp[2],ap[2],w,c1);
		}
	return(c1);
	} 

int test_gf2m_mod_exp(BIO *bp,BN_CTX *ctx)
	{
	BIGNUM *a,*b[2],*c,*d,*e,*f;
	int i, j, ret = 0;
	int p0[] = {163,7,6,3,0,-1};
	int p1[] = {193,15,0,-1};

	a=BN_new();
	b[0]=BN_new();
	b[1]=BN_new();
	c=BN_new();
	d=BN_new();
	e=BN_new();
	f=BN_new();

	BN_GF2m_arr2poly(p0, b[0]);
	BN_GF2m_arr2poly(p1, b[1]);

	for (i=0; i<num0; i++)
		{
		BN_bntest_rand(a, 512, 0, 0);
		BN_bntest_rand(c, 512, 0, 0);
		BN_bntest_rand(d, 512, 0, 0);
		for (j=0; j < 2; j++)
			{
			BN_GF2m_mod_exp(e, a, c, b[j], ctx);
			BN_GF2m_mod_exp(f, a, d, b[j], ctx);
			BN_GF2m_mod_mul(e, e, f, b[j], ctx);
			BN_add(f, c, d);
			BN_GF2m_mod_exp(f, a, f, b[j], ctx);
#if 0 /* make test uses ouput in bc but bc can't handle GF(2^m) arithmetic */
			if (bp != NULL)
				{
				if (!results)
					{
					BN_print(bp,a);
					BIO_puts(bp, " ^ (");
					BN_print(bp,c);
					BIO_puts(bp," + ");
					BN_print(bp,d);
					BIO_puts(bp, ") = ");
					BN_print(bp,e);
					BIO_puts(bp, "; - ");
					BN_print(bp,f);
					BIO_puts(bp, " % ");
					BN_print(bp,b[j]);
					BIO_puts(bp,"\n");
					}
				}
#endif
			BN_GF2m_add(f, e, f);
			/* Test that a^(c+d)=a^c*a^d. */
			if(!BN_is_zero(f))
				{
				fprintf(stderr,"GF(2^m) modular exponentiation test failed!\n");
				goto err;
				}
			}
		}
	ret = 1;
  err:
	BN_free(a);
	BN_free(b[0]);
	BN_free(b[1]);
	BN_free(c);
	BN_free(d);
	BN_free(e);
	BN_free(f);
	return ret;
	}

void bn_sqr_comba8(BN_ULONG *r, const BN_ULONG *a)
{
	BN_ULONG t1,t2;
BN_ULONG c1,c2,c3;

c1=0;
c2=0;
c3=0;
sqr_add_c(a,0,c1,c2,c3);
r[0]=c1;
c1=0;
sqr_add_c2(a,1,0,c2,c3,c1);
r[1]=c2;
c2=0;
sqr_add_c(a,1,c3,c1,c2);
sqr_add_c2(a,2,0,c3,c1,c2);
r[2]=c3;
c3=0;
sqr_add_c2(a,3,0,c1,c2,c3);
sqr_add_c2(a,2,1,c1,c2,c3);
r[3]=c1;
c1=0;
sqr_add_c(a,2,c2,c3,c1);
sqr_add_c2(a,3,1,c2,c3,c1);
sqr_add_c2(a,4,0,c2,c3,c1);
r[4]=c2;
c2=0;
sqr_add_c2(a,5,0,c3,c1,c2);
sqr_add_c2(a,4,1,c3,c1,c2);
sqr_add_c2(a,3,2,c3,c1,c2);
r[5]=c3;
c3=0;
sqr_add_c(a,3,c1,c2,c3);
sqr_add_c2(a,4,2,c1,c2,c3);
sqr_add_c2(a,5,1,c1,c2,c3);
sqr_add_c2(a,6,0,c1,c2,c3);
r[6]=c1;
c1=0;
sqr_add_c2(a,7,0,c2,c3,c1);
sqr_add_c2(a,6,1,c2,c3,c1);
sqr_add_c2(a,5,2,c2,c3,c1);
sqr_add_c2(a,4,3,c2,c3,c1);
r[7]=c2;
c2=0;
sqr_add_c(a,4,c3,c1,c2);
sqr_add_c2(a,5,3,c3,c1,c2);
sqr_add_c2(a,6,2,c3,c1,c2);
sqr_add_c2(a,7,1,c3,c1,c2);
r[8]=c3;
c3=0;
sqr_add_c2(a,7,2,c1,c2,c3);
sqr_add_c2(a,6,3,c1,c2,c3);
sqr_add_c2(a,5,4,c1,c2,c3);
r[9]=c1;
c1=0;
sqr_add_c(a,5,c2,c3,c1);
sqr_add_c2(a,6,4,c2,c3,c1);
sqr_add_c2(a,7,3,c2,c3,c1);
r[10]=c2;
c2=0;
sqr_add_c2(a,7,4,c3,c1,c2);
sqr_add_c2(a,6,5,c3,c1,c2);
r[11]=c3;
c3=0;
sqr_add_c(a,6,c1,c2,c3);
sqr_add_c2(a,7,5,c1,c2,c3);
r[12]=c1;
c1=0;
sqr_add_c2(a,7,6,c2,c3,c1);
r[13]=c2;
c2=0;
sqr_add_c(a,7,c3,c1,c2);
r[14]=c3;
r[15]=c1;
}

int test_mul(BIO *bp)
	{
	BIGNUM a,b,c,d,e;
	int i;
	BN_CTX *ctx;

	ctx = BN_CTX_new();
	if (ctx == NULL) EXIT(1);
	
	BN_init(&a);
	BN_init(&b);
	BN_init(&c);
	BN_init(&d);
	BN_init(&e);

	for (i=0; i<num0+num1; i++)
		{
		if (i <= num1)
			{
			BN_bntest_rand(&a,100,0,0);
			BN_bntest_rand(&b,100,0,0);
			}
		else
			BN_bntest_rand(&b,i-num1,0,0);
		a.neg=rand_neg();
		b.neg=rand_neg();
		BN_mul(&c,&a,&b,ctx);
		if (bp != NULL)
			{
			if (!results)
				{
				BN_print(bp,&a);
				BIO_puts(bp," * ");
				BN_print(bp,&b);
				BIO_puts(bp," - ");
				}
			BN_print(bp,&c);
			BIO_puts(bp,"\n");
			}
		BN_div(&d,&e,&c,&a,ctx);
		BN_sub(&d,&d,&b);
		if(!BN_is_zero(&d) || !BN_is_zero(&e))
		    {
		    fprintf(stderr,"Multiplication test failed!\n");
		    return 0;
		    }
		}
	BN_free(&a);
	BN_free(&b);
	BN_free(&c);
	BN_free(&d);
	BN_free(&e);
	BN_CTX_free(ctx);
	return(1);
	}

int test_gf2m_mod(BIO *bp)
	{
	BIGNUM *a,*b[2],*c,*d,*e;
	int i, j, ret = 0;
	int p0[] = {163,7,6,3,0,-1};
	int p1[] = {193,15,0,-1};

	a=BN_new();
	b[0]=BN_new();
	b[1]=BN_new();
	c=BN_new();
	d=BN_new();
	e=BN_new();

	BN_GF2m_arr2poly(p0, b[0]);
	BN_GF2m_arr2poly(p1, b[1]);

	for (i=0; i<num0; i++)
		{
		BN_bntest_rand(a, 1024, 0, 0);
		for (j=0; j < 2; j++)
			{
			BN_GF2m_mod(c, a, b[j]);
#if 0 /* make test uses ouput in bc but bc can't handle GF(2^m) arithmetic */
			if (bp != NULL)
				{
				if (!results)
					{
					BN_print(bp,a);
					BIO_puts(bp," % ");
					BN_print(bp,b[j]);
					BIO_puts(bp," - ");
					BN_print(bp,c);
					BIO_puts(bp,"\n");
					}
				}
#endif
			BN_GF2m_add(d, a, c);
			BN_GF2m_mod(e, d, b[j]);
			/* Test that a + (a mod p) mod p == 0. */
			if(!BN_is_zero(e))
				{
				fprintf(stderr,"GF(2^m) modulo test failed!\n");
				goto err;
				}
			}
		}
	ret = 1;
  err:
	BN_free(a);
	BN_free(b[0]);
	BN_free(b[1]);
	BN_free(c);
	BN_free(d);
	BN_free(e);
	return ret;
	}

int test_div(BIO *bp, BN_CTX *ctx)
	{
	BIGNUM a,b,c,d,e;
	int i;

	BN_init(&a);
	BN_init(&b);
	BN_init(&c);
	BN_init(&d);
	BN_init(&e);

	for (i=0; i<num0+num1; i++)
		{
		if (i < num1)
			{
			BN_bntest_rand(&a,400,0,0);
			BN_copy(&b,&a);
			BN_lshift(&a,&a,i);
			BN_add_word(&a,i);
			}
		else
			BN_bntest_rand(&b,50+3*(i-num1),0,0);
		a.neg=rand_neg();
		b.neg=rand_neg();
		BN_div(&d,&c,&a,&b,ctx);
		if (bp != NULL)
			{
			if (!results)
				{
				BN_print(bp,&a);
				BIO_puts(bp," / ");
				BN_print(bp,&b);
				BIO_puts(bp," - ");
				}
			BN_print(bp,&d);
			BIO_puts(bp,"\n");

			if (!results)
				{
				BN_print(bp,&a);
				BIO_puts(bp," % ");
				BN_print(bp,&b);
				BIO_puts(bp," - ");
				}
			BN_print(bp,&c);
			BIO_puts(bp,"\n");
			}
		BN_mul(&e,&d,&b,ctx);
		BN_add(&d,&e,&c);
		BN_sub(&d,&d,&a);
		if(!BN_is_zero(&d))
		    {
		    fprintf(stderr,"Division test failed!\n");
		    return 0;
		    }
		}
	BN_free(&a);
	BN_free(&b);
	BN_free(&c);
	BN_free(&d);
	BN_free(&e);
	return(1);
	}

BN_ULONG bn_sub_words(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n)
        {
	BN_ULONG t1,t2;
	int c=0;

	if (n <= 0) return((BN_ULONG)0);

	for (;;)
		{
		t1=a[0]; t2=b[0];
		r[0]=(t1-t2-c)&BN_MASK2;
		if (t1 != t2) c=(t1 < t2);
		if (--n <= 0) break;

		t1=a[1]; t2=b[1];
		r[1]=(t1-t2-c)&BN_MASK2;
		if (t1 != t2) c=(t1 < t2);
		if (--n <= 0) break;

		t1=a[2]; t2=b[2];
		r[2]=(t1-t2-c)&BN_MASK2;
		if (t1 != t2) c=(t1 < t2);
		if (--n <= 0) break;

		t1=a[3]; t2=b[3];
		r[3]=(t1-t2-c)&BN_MASK2;
		if (t1 != t2) c=(t1 < t2);
		if (--n <= 0) break;

		a+=4;
		b+=4;
		r+=4;
		}
	return(c);
	}

int test_small_prime(BIO *bp,BN_CTX *ctx)
	{
	static const int bits = 10;
	int ret = 0;
	BIGNUM r;

	BN_init(&r);
	if (!BN_generate_prime_ex(&r, bits, 0, NULL, NULL, NULL))
		goto err;
	if (BN_num_bits(&r) != bits)
		{
		BIO_printf(bp, "Expected %d bit prime, got %d bit number\n", bits, BN_num_bits(&r));
		goto err;
		}

	ret = 1;

err:
	BN_clear(&r);
	return ret;
	}

int test_gf2m_mod_inv(BIO *bp,BN_CTX *ctx)
	{
	BIGNUM *a,*b[2],*c,*d;
	int i, j, ret = 0;
	int p0[] = {163,7,6,3,0,-1};
	int p1[] = {193,15,0,-1};

	a=BN_new();
	b[0]=BN_new();
	b[1]=BN_new();
	c=BN_new();
	d=BN_new();

	BN_GF2m_arr2poly(p0, b[0]);
	BN_GF2m_arr2poly(p1, b[1]);

	for (i=0; i<num0; i++)
		{
		BN_bntest_rand(a, 512, 0, 0); 
		for (j=0; j < 2; j++)
			{
			BN_GF2m_mod_inv(c, a, b[j], ctx);
			BN_GF2m_mod_mul(d, a, c, b[j], ctx);
#if 0 /* make test uses ouput in bc but bc can't handle GF(2^m) arithmetic */
			if (bp != NULL)
				{
				if (!results)
					{
					BN_print(bp,a);
					BIO_puts(bp, " * ");
					BN_print(bp,c);
					BIO_puts(bp," - 1 % ");
					BN_print(bp,b[j]);
					BIO_puts(bp,"\n");
					}
				}
#endif
			/* Test that ((1/a)*a) = 1. */
			if(!BN_is_one(d))
				{
				fprintf(stderr,"GF(2^m) modular inversion test failed!\n");
				goto err;
				}
			}
		}
	ret = 1;
  err:
	BN_free(a);
	BN_free(b[0]);
	BN_free(b[1]);
	BN_free(c);
	BN_free(d);
	return ret;
	}

void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)
{
	BN_ULONG t1,t2;
BN_ULONG c1,c2,c3;

c1=0;
c2=0;
c3=0;
mul_add_c(a[0],b[0],c1,c2,c3);
r[0]=c1;
c1=0;
mul_add_c(a[0],b[1],c2,c3,c1);
mul_add_c(a[1],b[0],c2,c3,c1);
r[1]=c2;
c2=0;
mul_add_c(a[2],b[0],c3,c1,c2);
mul_add_c(a[1],b[1],c3,c1,c2);
mul_add_c(a[0],b[2],c3,c1,c2);
r[2]=c3;
c3=0;
mul_add_c(a[0],b[3],c1,c2,c3);
mul_add_c(a[1],b[2],c1,c2,c3);
mul_add_c(a[2],b[1],c1,c2,c3);
mul_add_c(a[3],b[0],c1,c2,c3);
r[3]=c1;
c1=0;
mul_add_c(a[3],b[1],c2,c3,c1);
mul_add_c(a[2],b[2],c2,c3,c1);
mul_add_c(a[1],b[3],c2,c3,c1);
r[4]=c2;
c2=0;
mul_add_c(a[2],b[3],c3,c1,c2);
mul_add_c(a[3],b[2],c3,c1,c2);
r[5]=c3;
c3=0;
mul_add_c(a[3],b[3],c1,c2,c3);
r[6]=c1;
r[7]=c2;
}

int test_gf2m_mod_solve_quad(BIO *bp,BN_CTX *ctx)
	{
	BIGNUM *a,*b[2],*c,*d,*e;
	int i, j, s = 0, t, ret = 0;
	int p0[] = {163,7,6,3,0,-1};
	int p1[] = {193,15,0,-1};

	a=BN_new();
	b[0]=BN_new();
	b[1]=BN_new();
	c=BN_new();
	d=BN_new();
	e=BN_new();

	BN_GF2m_arr2poly(p0, b[0]);
	BN_GF2m_arr2poly(p1, b[1]);

	for (i=0; i<num0; i++)
		{
		BN_bntest_rand(a, 512, 0, 0);
		for (j=0; j < 2; j++)
			{
			t = BN_GF2m_mod_solve_quad(c, a, b[j], ctx);
			if (t)
				{
				s++;
				BN_GF2m_mod_sqr(d, c, b[j], ctx);
				BN_GF2m_add(d, c, d);
				BN_GF2m_mod(e, a, b[j]);
#if 0 /* make test uses ouput in bc but bc can't handle GF(2^m) arithmetic */
				if (bp != NULL)
					{
					if (!results)
						{
						BN_print(bp,c);
						BIO_puts(bp, " is root of z^2 + z = ");
						BN_print(bp,a);
						BIO_puts(bp, " % ");
						BN_print(bp,b[j]);
						BIO_puts(bp, "\n");
						}
					}
#endif
				BN_GF2m_add(e, e, d);
				/* Test that solution of quadratic c satisfies c^2 + c = a. */
				if(!BN_is_zero(e))
					{
					fprintf(stderr,"GF(2^m) modular solve quadratic test failed!\n");
					goto err;
					}

				}
			else 
				{
#if 0 /* make test uses ouput in bc but bc can't handle GF(2^m) arithmetic */
				if (bp != NULL)
					{
					if (!results)
						{
						BIO_puts(bp, "There are no roots of z^2 + z = ");
						BN_print(bp,a);
						BIO_puts(bp, " % ");
						BN_print(bp,b[j]);
						BIO_puts(bp, "\n");
						}
					}
#endif
				}
			}
		}
	if (s == 0)
		{	
		fprintf(stderr,"All %i tests of GF(2^m) modular solve quadratic resulted in no roots;\n", num0);
		fprintf(stderr,"this is very unlikely and probably indicates an error.\n");
		goto err;
		}
	ret = 1;
  err:
	BN_free(a);
	BN_free(b[0]);
	BN_free(b[1]);
	BN_free(c);
	BN_free(d);
	BN_free(e);
	return ret;
	}

int test_sub(BIO *bp)
	{
	BIGNUM a,b,c;
	int i;

	BN_init(&a);
	BN_init(&b);
	BN_init(&c);

	for (i=0; i<num0+num1; i++)
		{
		if (i < num1)
			{
			BN_bntest_rand(&a,512,0,0);
			BN_copy(&b,&a);
			if (BN_set_bit(&a,i)==0) return(0);
			BN_add_word(&b,i);
			}
		else
			{
			BN_bntest_rand(&b,400+i-num1,0,0);
			a.neg=rand_neg();
			b.neg=rand_neg();
			}
		BN_sub(&c,&a,&b);
		if (bp != NULL)
			{
			if (!results)
				{
				BN_print(bp,&a);
				BIO_puts(bp," - ");
				BN_print(bp,&b);
				BIO_puts(bp," - ");
				}
			BN_print(bp,&c);
			BIO_puts(bp,"\n");
			}
		BN_add(&c,&c,&b);
		BN_sub(&c,&c,&a);
		if(!BN_is_zero(&c))
		    {
		    fprintf(stderr,"Subtract test failed!\n");
		    return 0;
		    }
		}
	BN_free(&a);
	BN_free(&b);
	BN_free(&c);
	return(1);
	}

static int genprime_cb(int p, int n, BN_GENCB *arg)
	{
	char c='*';

	if (p == 0) c='.';
	if (p == 1) c='+';
	if (p == 2) c='*';
	if (p == 3) c='\n';
	putc(c, stderr);
	fflush(stderr);
	return 1;
	}

int test_gf2m_mod_div(BIO *bp,BN_CTX *ctx)
	{
	BIGNUM *a,*b[2],*c,*d,*e,*f;
	int i, j, ret = 0;
	int p0[] = {163,7,6,3,0,-1};
	int p1[] = {193,15,0,-1};

	a=BN_new();
	b[0]=BN_new();
	b[1]=BN_new();
	c=BN_new();
	d=BN_new();
	e=BN_new();
	f=BN_new();

	BN_GF2m_arr2poly(p0, b[0]);
	BN_GF2m_arr2poly(p1, b[1]);

	for (i=0; i<num0; i++)
		{
		BN_bntest_rand(a, 512, 0, 0); 
		BN_bntest_rand(c, 512, 0, 0);
		for (j=0; j < 2; j++)
			{
			BN_GF2m_mod_div(d, a, c, b[j], ctx);
			BN_GF2m_mod_mul(e, d, c, b[j], ctx);
			BN_GF2m_mod_div(f, a, e, b[j], ctx);
#if 0 /* make test uses ouput in bc but bc can't handle GF(2^m) arithmetic */
			if (bp != NULL)
				{
				if (!results)
					{
					BN_print(bp,a);
					BIO_puts(bp, " = ");
					BN_print(bp,c);
					BIO_puts(bp," * ");
					BN_print(bp,d);
					BIO_puts(bp, " % ");
					BN_print(bp,b[j]);
					BIO_puts(bp,"\n");
					}
				}
#endif
			/* Test that ((a/c)*c)/a = 1. */
			if(!BN_is_one(f))
				{
				fprintf(stderr,"GF(2^m) modular division test failed!\n");
				goto err;
				}
			}
		}
	ret = 1;
  err:
	BN_free(a);
	BN_free(b[0]);
	BN_free(b[1]);
	BN_free(c);
	BN_free(d);
	BN_free(e);
	BN_free(f);
	return ret;
	}

BN_ULONG bn_mul_add_words(BN_ULONG *rp, const BN_ULONG *ap, int num, BN_ULONG w)
	{
	BN_ULONG c1=0;

	assert(num >= 0);
	if (num <= 0) return(c1);

#ifndef OPENSSL_SMALL_FOOTPRINT
	while (num&~3)
		{
		mul_add(rp[0],ap[0],w,c1);
		mul_add(rp[1],ap[1],w,c1);
		mul_add(rp[2],ap[2],w,c1);
		mul_add(rp[3],ap[3],w,c1);
		ap+=4; rp+=4; num-=4;
		}
#endif
	while (num)
		{
		mul_add(rp[0],ap[0],w,c1);
		ap++; rp++; num--;
		}
	
	return(c1);
	} 

int test_sqrt(BIO *bp, BN_CTX *ctx)
	{
	BN_GENCB cb;
	BIGNUM *a,*p,*r;
	int i, j;
	int ret = 0;

	a = BN_new();
	p = BN_new();
	r = BN_new();
	if (a == NULL || p == NULL || r == NULL) goto err;

	BN_GENCB_set(&cb, genprime_cb, NULL);

	for (i = 0; i < 16; i++)
		{
		if (i < 8)
			{
			unsigned primes[8] = { 2, 3, 5, 7, 11, 13, 17, 19 };
			
			if (!BN_set_word(p, primes[i])) goto err;
			}
		else
			{
			if (!BN_set_word(a, 32)) goto err;
			if (!BN_set_word(r, 2*i + 1)) goto err;
		
			if (!BN_generate_prime_ex(p, 256, 0, a, r, &cb)) goto err;
			putc('\n', stderr);
			}
		p->neg = rand_neg();

		for (j = 0; j < num2; j++)
			{
			/* construct 'a' such that it is a square modulo p,
			 * but in general not a proper square and not reduced modulo p */
			if (!BN_bntest_rand(r, 256, 0, 3)) goto err;
			if (!BN_nnmod(r, r, p, ctx)) goto err;
			if (!BN_mod_sqr(r, r, p, ctx)) goto err;
			if (!BN_bntest_rand(a, 256, 0, 3)) goto err;
			if (!BN_nnmod(a, a, p, ctx)) goto err;
			if (!BN_mod_sqr(a, a, p, ctx)) goto err;
			if (!BN_mul(a, a, r, ctx)) goto err;
			if (rand_neg())
				if (!BN_sub(a, a, p)) goto err;

			if (!BN_mod_sqrt(r, a, p, ctx)) goto err;
			if (!BN_mod_sqr(r, r, p, ctx)) goto err;

			if (!BN_nnmod(a, a, p, ctx)) goto err;

			if (BN_cmp(a, r) != 0)
				{
				fprintf(stderr, "BN_mod_sqrt failed: a = ");
				BN_print_fp(stderr, a);
				fprintf(stderr, ", r = ");
				BN_print_fp(stderr, r);
				fprintf(stderr, ", p = ");
				BN_print_fp(stderr, p);
				fprintf(stderr, "\n");
				goto err;
				}

			putc('.', stderr);
			fflush(stderr);
			}
		
		putc('\n', stderr);
		fflush(stderr);
		}
	ret = 1;
 err:
	if (a != NULL) BN_free(a);
	if (p != NULL) BN_free(p);
	if (r != NULL) BN_free(r);
	return ret;
	}

int test_add(BIO *bp)
	{
	BIGNUM a,b,c;
	int i;

	BN_init(&a);
	BN_init(&b);
	BN_init(&c);

	BN_bntest_rand(&a,512,0,0);
	for (i=0; i<num0; i++)
		{
		BN_bntest_rand(&b,450+i,0,0);
		a.neg=rand_neg();
		b.neg=rand_neg();
		BN_add(&c,&a,&b);
		if (bp != NULL)
			{
			if (!results)
				{
				BN_print(bp,&a);
				BIO_puts(bp," + ");
				BN_print(bp,&b);
				BIO_puts(bp," - ");
				}
			BN_print(bp,&c);
			BIO_puts(bp,"\n");
			}
		a.neg=!a.neg;
		b.neg=!b.neg;
		BN_add(&c,&c,&b);
		BN_add(&c,&c,&a);
		if(!BN_is_zero(&c))
		    {
		    fprintf(stderr,"Add test failed!\n");
		    return 0;
		    }
		}
	BN_free(&a);
	BN_free(&b);
	BN_free(&c);
	return(1);
	}

int test_div_recp(BIO *bp, BN_CTX *ctx)
	{
	BIGNUM a,b,c,d,e;
	BN_RECP_CTX recp;
	int i;

	BN_RECP_CTX_init(&recp);
	BN_init(&a);
	BN_init(&b);
	BN_init(&c);
	BN_init(&d);
	BN_init(&e);

	for (i=0; i<num0+num1; i++)
		{
		if (i < num1)
			{
			BN_bntest_rand(&a,400,0,0);
			BN_copy(&b,&a);
			BN_lshift(&a,&a,i);
			BN_add_word(&a,i);
			}
		else
			BN_bntest_rand(&b,50+3*(i-num1),0,0);
		a.neg=rand_neg();
		b.neg=rand_neg();
		BN_RECP_CTX_set(&recp,&b,ctx);
		BN_div_recp(&d,&c,&a,&recp,ctx);
		if (bp != NULL)
			{
			if (!results)
				{
				BN_print(bp,&a);
				BIO_puts(bp," / ");
				BN_print(bp,&b);
				BIO_puts(bp," - ");
				}
			BN_print(bp,&d);
			BIO_puts(bp,"\n");

			if (!results)
				{
				BN_print(bp,&a);
				BIO_puts(bp," % ");
				BN_print(bp,&b);
				BIO_puts(bp," - ");
				}
			BN_print(bp,&c);
			BIO_puts(bp,"\n");
			}
		BN_mul(&e,&d,&b,ctx);
		BN_add(&d,&e,&c);
		BN_sub(&d,&d,&a);
		if(!BN_is_zero(&d))
		    {
		    fprintf(stderr,"Reciprocal division test failed!\n");
		    fprintf(stderr,"a=");
		    BN_print_fp(stderr,&a);
		    fprintf(stderr,"\nb=");
		    BN_print_fp(stderr,&b);
		    fprintf(stderr,"\n");
		    return 0;
		    }
		}
	BN_free(&a);
	BN_free(&b);
	BN_free(&c);
	BN_free(&d);
	BN_free(&e);
	BN_RECP_CTX_free(&recp);
	return(1);
	}

BN_ULONG bn_div_words(BN_ULONG h, BN_ULONG l, BN_ULONG d)
{	BN_ULONG ret,waste;

	asm ("divq	%4"
		: "=a"(ret),"=d"(waste)
		: "a"(l),"d"(h),"g"(d)
		: "cc");

	return ret;
}

int test_kron(BIO *bp, BN_CTX *ctx)
	{
	BN_GENCB cb;
	BIGNUM *a,*b,*r,*t;
	int i;
	int legendre, kronecker;
	int ret = 0;

	a = BN_new();
	b = BN_new();
	r = BN_new();
	t = BN_new();
	if (a == NULL || b == NULL || r == NULL || t == NULL) goto err;

	BN_GENCB_set(&cb, genprime_cb, NULL);
	
	/* We test BN_kronecker(a, b, ctx) just for  b  odd (Jacobi symbol).
	 * In this case we know that if  b  is prime, then BN_kronecker(a, b, ctx)
	 * is congruent to $a^{(b-1)/2}$, modulo $b$ (Legendre symbol).
	 * So we generate a random prime  b  and compare these values
	 * for a number of random  a's.  (That is, we run the Solovay-Strassen
	 * primality test to confirm that  b  is prime, except that we
	 * don't want to test whether  b  is prime but whether BN_kronecker
	 * works.) */

	if (!BN_generate_prime_ex(b, 512, 0, NULL, NULL, &cb)) goto err;
	b->neg = rand_neg();
	putc('\n', stderr);

	for (i = 0; i < num0; i++)
		{
		if (!BN_bntest_rand(a, 512, 0, 0)) goto err;
		a->neg = rand_neg();

		/* t := (|b|-1)/2  (note that b is odd) */
		if (!BN_copy(t, b)) goto err;
		t->neg = 0;
		if (!BN_sub_word(t, 1)) goto err;
		if (!BN_rshift1(t, t)) goto err;
		/* r := a^t mod b */
		b->neg=0;
		
		if (!BN_mod_exp_recp(r, a, t, b, ctx)) goto err;
		b->neg=1;

		if (BN_is_word(r, 1))
			legendre = 1;
		else if (BN_is_zero(r))
			legendre = 0;
		else
			{
			if (!BN_add_word(r, 1)) goto err;
			if (0 != BN_ucmp(r, b))
				{
				fprintf(stderr, "Legendre symbol computation failed\n");
				goto err;
				}
			legendre = -1;
			}
		
		kronecker = BN_kronecker(a, b, ctx);
		if (kronecker < -1) goto err;
		/* we actually need BN_kronecker(a, |b|) */
		if (a->neg && b->neg)
			kronecker = -kronecker;
		
		if (legendre != kronecker)
			{
			fprintf(stderr, "legendre != kronecker; a = ");
			BN_print_fp(stderr, a);
			fprintf(stderr, ", b = ");
			BN_print_fp(stderr, b);
			fprintf(stderr, "\n");
			goto err;
			}

		putc('.', stderr);
		fflush(stderr);
		}

	putc('\n', stderr);
	fflush(stderr);
	ret = 1;
 err:
	if (a != NULL) BN_free(a);
	if (b != NULL) BN_free(b);
	if (r != NULL) BN_free(r);
	if (t != NULL) BN_free(t);
	return ret;
	}

static void print_word(BIO *bp,BN_ULONG w)
	{
#ifdef SIXTY_FOUR_BIT
	if (sizeof(w) > sizeof(unsigned long))
		{
		unsigned long	h=(unsigned long)(w>>32),
				l=(unsigned long)(w);

		if (h)	BIO_printf(bp,"%lX%08lX",h,l);
		else	BIO_printf(bp,"%lX",l);
		return;
		}
#endif
	BIO_printf(bp,BN_HEX_FMT1,w);
	}

int rand_neg(void)
	{
	static unsigned int neg=0;
	static int sign[8]={0,0,0,1,1,0,1,1};

	return(sign[(neg++)%8]);
	}

 int test_mont(BIO *bp, BN_CTX *ctx)
	{
	BIGNUM a,b,c,d,A,B;
	BIGNUM n;
	int i;
	BN_MONT_CTX *mont;

	BN_init(&a);
	BN_init(&b);
	BN_init(&c);
	BN_init(&d);
	BN_init(&A);
	BN_init(&B);
	BN_init(&n);

	mont=BN_MONT_CTX_new();
	if (mont == NULL)
		return 0;

	BN_bntest_rand(&a,100,0,0); /**/
	BN_bntest_rand(&b,100,0,0); /**/
	for (i=0; i<num2; i++)
		{
		int bits = (200*(i+1))/num2;

		if (bits == 0)
			continue;
		BN_bntest_rand(&n,bits,0,1);
		BN_MONT_CTX_set(mont,&n,ctx);

		BN_nnmod(&a,&a,&n,ctx);
		BN_nnmod(&b,&b,&n,ctx);

		BN_to_montgomery(&A,&a,mont,ctx);
		BN_to_montgomery(&B,&b,mont,ctx);

		BN_mod_mul_montgomery(&c,&A,&B,mont,ctx);/**/
		BN_from_montgomery(&A,&c,mont,ctx);/**/
		if (bp != NULL)
			{
			if (!results)
				{
#ifdef undef
fprintf(stderr,"%d * %d %% %d\n",
BN_num_bits(&a),
BN_num_bits(&b),
BN_num_bits(mont->N));
#endif
				BN_print(bp,&a);
				BIO_puts(bp," * ");
				BN_print(bp,&b);
				BIO_puts(bp," % ");
				BN_print(bp,&(mont->N));
				BIO_puts(bp," - ");
				}
			BN_print(bp,&A);
			BIO_puts(bp,"\n");
			}
		BN_mod_mul(&d,&a,&b,&n,ctx);
		BN_sub(&d,&d,&A);
		if(!BN_is_zero(&d))
		    {
		    fprintf(stderr,"Montgomery multiplication test failed!\n");
		    return 0;
		    }
		}
	BN_MONT_CTX_free(mont);
	BN_free(&a);
	BN_free(&b);
	BN_free(&c);
	BN_free(&d);
	BN_free(&A);
	BN_free(&B);
	BN_free(&n);
	return(1);
	}

void bn_sqr_comba4(BN_ULONG *r, const BN_ULONG *a)
{
	BN_ULONG t1,t2;
BN_ULONG c1,c2,c3;

c1=0;
c2=0;
c3=0;
sqr_add_c(a,0,c1,c2,c3);
r[0]=c1;
c1=0;
sqr_add_c2(a,1,0,c2,c3,c1);
r[1]=c2;
c2=0;
sqr_add_c(a,1,c3,c1,c2);
sqr_add_c2(a,2,0,c3,c1,c2);
r[2]=c3;
c3=0;
sqr_add_c2(a,3,0,c1,c2,c3);
sqr_add_c2(a,2,1,c1,c2,c3);
r[3]=c1;
c1=0;
sqr_add_c(a,2,c2,c3,c1);
sqr_add_c2(a,3,1,c2,c3,c1);
r[4]=c2;
c2=0;
sqr_add_c2(a,3,2,c3,c1,c2);
r[5]=c3;
c3=0;
sqr_add_c(a,3,c1,c2,c3);
r[6]=c1;
r[7]=c2;
}

int test_mod_exp_mont5(BIO *bp, BN_CTX *ctx)
	{
	BIGNUM *a,*p,*m,*d,*e;

	BN_MONT_CTX *mont;

	a=BN_new();
	p=BN_new();
	m=BN_new();
	d=BN_new();
	e=BN_new();

	mont = BN_MONT_CTX_new();

	BN_bntest_rand(m,1024,0,1); /* must be odd for montgomery */
	/* Zero exponent */
	BN_bntest_rand(a,1024,0,0);
	BN_zero(p);
	if(!BN_mod_exp_mont_consttime(d,a,p,m,ctx,NULL))
		return 0;
	if(!BN_is_one(d))
		{
		fprintf(stderr, "Modular exponentiation test failed!\n");
		return 0;
		}
	/* Zero input */
	BN_bntest_rand(p,1024,0,0);
	BN_zero(a);
	if(!BN_mod_exp_mont_consttime(d,a,p,m,ctx,NULL))
		return 0;
	if(!BN_is_zero(d))
		{
		fprintf(stderr, "Modular exponentiation test failed!\n");
		return 0;
		}
	/* Craft an input whose Montgomery representation is 1,
	 * i.e., shorter than the modulus m, in order to test
	 * the const time precomputation scattering/gathering.
	 */
	BN_one(a);
	BN_MONT_CTX_set(mont,m,ctx);
	if(!BN_from_montgomery(e,a,mont,ctx))
		return 0;
	if(!BN_mod_exp_mont_consttime(d,e,p,m,ctx,NULL))
		return 0;
	if(!BN_mod_exp_simple(a,e,p,m,ctx))
		return 0;
	if(BN_cmp(a,d) != 0)
		{
		fprintf(stderr,"Modular exponentiation test failed!\n");
		return 0;
		}
	/* Finally, some regular test vectors. */
	BN_bntest_rand(e,1024,0,0);
	if(!BN_mod_exp_mont_consttime(d,e,p,m,ctx,NULL))
		return 0;
	if(!BN_mod_exp_simple(a,e,p,m,ctx))
		return 0;
	if(BN_cmp(a,d) != 0)
		{
		fprintf(stderr,"Modular exponentiation test failed!\n");
		return 0;
		}
	BN_free(a);
	BN_free(p);
	BN_free(m);
	BN_free(d);
	BN_free(e);
	return(1);
	}

int test_mod(BIO *bp, BN_CTX *ctx)
	{
	BIGNUM *a,*b,*c,*d,*e;
	int i;

	a=BN_new();
	b=BN_new();
	c=BN_new();
	d=BN_new();
	e=BN_new();

	BN_bntest_rand(a,1024,0,0); /**/
	for (i=0; i<num0; i++)
		{
		BN_bntest_rand(b,450+i*10,0,0); /**/
		a->neg=rand_neg();
		b->neg=rand_neg();
		BN_mod(c,a,b,ctx);/**/
		if (bp != NULL)
			{
			if (!results)
				{
				BN_print(bp,a);
				BIO_puts(bp," % ");
				BN_print(bp,b);
				BIO_puts(bp," - ");
				}
			BN_print(bp,c);
			BIO_puts(bp,"\n");
			}
		BN_div(d,e,a,b,ctx);
		BN_sub(e,e,c);
		if(!BN_is_zero(e))
		    {
		    fprintf(stderr,"Modulo test failed!\n");
		    return 0;
		    }
		}
	BN_free(a);
	BN_free(b);
	BN_free(c);
	BN_free(d);
	BN_free(e);
	return(1);
	}

int test_lshift(BIO *bp,BN_CTX *ctx,BIGNUM *a_)
	{
	BIGNUM *a,*b,*c,*d;
	int i;

	b=BN_new();
	c=BN_new();
	d=BN_new();
	BN_one(c);

	if(a_)
	    a=a_;
	else
	    {
	    a=BN_new();
	    BN_bntest_rand(a,200,0,0); /**/
	    a->neg=rand_neg();
	    }
	for (i=0; i<num0; i++)
		{
		BN_lshift(b,a,i+1);
		BN_add(c,c,c);
		if (bp != NULL)
			{
			if (!results)
				{
				BN_print(bp,a);
				BIO_puts(bp," * ");
				BN_print(bp,c);
				BIO_puts(bp," - ");
				}
			BN_print(bp,b);
			BIO_puts(bp,"\n");
			}
		BN_mul(d,a,c,ctx);
		BN_sub(d,d,b);
		if(!BN_is_zero(d))
		    {
		    fprintf(stderr,"Left shift test failed!\n");
		    fprintf(stderr,"a=");
		    BN_print_fp(stderr,a);
		    fprintf(stderr,"\nb=");
		    BN_print_fp(stderr,b);
		    fprintf(stderr,"\nc=");
		    BN_print_fp(stderr,c);
		    fprintf(stderr,"\nd=");
		    BN_print_fp(stderr,d);
		    fprintf(stderr,"\n");
		    return 0;
		    }
		}
	BN_free(a);
	BN_free(b);
	BN_free(c);
	BN_free(d);
	return(1);
	}

int test_mod_exp(BIO *bp, BN_CTX *ctx)
	{
	BIGNUM *a,*b,*c,*d,*e;
	int i;

	a=BN_new();
	b=BN_new();
	c=BN_new();
	d=BN_new();
	e=BN_new();

	BN_bntest_rand(c,30,0,1); /* must be odd for montgomery */
	for (i=0; i<num2; i++)
		{
		BN_bntest_rand(a,20+i*5,0,0); /**/
		BN_bntest_rand(b,2+i,0,0); /**/

		if (!BN_mod_exp(d,a,b,c,ctx))
			return(0);

		if (bp != NULL)
			{
			if (!results)
				{
				BN_print(bp,a);
				BIO_puts(bp," ^ ");
				BN_print(bp,b);
				BIO_puts(bp," % ");
				BN_print(bp,c);
				BIO_puts(bp," - ");
				}
			BN_print(bp,d);
			BIO_puts(bp,"\n");
			}
		BN_exp(e,a,b,ctx);
		BN_sub(e,e,d);
		BN_div(a,b,e,c,ctx);
		if(!BN_is_zero(b))
		    {
		    fprintf(stderr,"Modulo exponentiation test failed!\n");
		    return 0;
		    }
		}
	BN_free(a);
	BN_free(b);
	BN_free(c);
	BN_free(d);
	BN_free(e);
	return(1);
	}

int test_exp(BIO *bp, BN_CTX *ctx)
	{
	BIGNUM *a,*b,*d,*e,*one;
	int i;

	a=BN_new();
	b=BN_new();
	d=BN_new();
	e=BN_new();
	one=BN_new();
	BN_one(one);

	for (i=0; i<num2; i++)
		{
		BN_bntest_rand(a,20+i*5,0,0); /**/
		BN_bntest_rand(b,2+i,0,0); /**/

		if (BN_exp(d,a,b,ctx) <= 0)
			return(0);

		if (bp != NULL)
			{
			if (!results)
				{
				BN_print(bp,a);
				BIO_puts(bp," ^ ");
				BN_print(bp,b);
				BIO_puts(bp," - ");
				}
			BN_print(bp,d);
			BIO_puts(bp,"\n");
			}
		BN_one(e);
		for( ; !BN_is_zero(b) ; BN_sub(b,b,one))
		    BN_mul(e,e,a,ctx);
		BN_sub(e,e,d);
		if(!BN_is_zero(e))
		    {
		    fprintf(stderr,"Exponentiation test failed!\n");
		    return 0;
		    }
		}
	BN_free(a);
	BN_free(b);
	BN_free(d);
	BN_free(e);
	BN_free(one);
	return(1);
	}

BN_ULONG bn_sub_words (BN_ULONG *rp, const BN_ULONG *ap, const BN_ULONG *bp,int n)
{ BN_ULONG ret;
  size_t i=0;

	if (n <= 0) return 0;

	asm volatile (
	"	subq	%0,%0		\n"	/* clear borrow */
	"	jmp	1f		\n"
	".p2align 4			\n"
	"1:	movq	(%4,%2,8),%0	\n"
	"	sbbq	(%5,%2,8),%0	\n"
	"	movq	%0,(%3,%2,8)	\n"
	"	lea	1(%2),%2	\n"
	"	loop	1b		\n"
	"	sbbq	%0,%0		\n"
		: "=&r"(ret),"+c"(n),"+r"(i)
		: "r"(rp),"r"(ap),"r"(bp)
		: "cc", "memory"
	);

  return ret&1;
}

BN_ULONG bn_mul_add_words(BN_ULONG *rp, const BN_ULONG *ap, int num, BN_ULONG w)
	{
	BN_ULONG c1=0;

	if (num <= 0) return(c1);

	while (num&~3)
		{
		mul_add(rp[0],ap[0],w,c1);
		mul_add(rp[1],ap[1],w,c1);
		mul_add(rp[2],ap[2],w,c1);
		mul_add(rp[3],ap[3],w,c1);
		ap+=4; rp+=4; num-=4;
		}
	if (num)
		{
		mul_add(rp[0],ap[0],w,c1); if (--num==0) return c1;
		mul_add(rp[1],ap[1],w,c1); if (--num==0) return c1;
		mul_add(rp[2],ap[2],w,c1); return c1;
		}
	
	return(c1);
	} 

void bn_sqr_words(BN_ULONG *r, const BN_ULONG *a, int n)
        {
	if (n <= 0) return;

	while (n&~3)
		{
		sqr(r[0],r[1],a[0]);
		sqr(r[2],r[3],a[1]);
		sqr(r[4],r[5],a[2]);
		sqr(r[6],r[7],a[3]);
		a+=4; r+=8; n-=4;
		}
	if (n)
		{
		sqr(r[0],r[1],a[0]); if (--n == 0) return;
		sqr(r[2],r[3],a[1]); if (--n == 0) return;
		sqr(r[4],r[5],a[2]);
		}
	}
