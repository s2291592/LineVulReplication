void WorkerProcessLauncher::Core::RecordSuccessfulLaunch() {
  DCHECK(caller_task_runner_->BelongsToCurrentThread());

  launch_backoff_.InformOfRequest(true);
}

void DaemonProcess::OnPermanentError() {
  DCHECK(caller_task_runner()->BelongsToCurrentThread());
  Stop();
}

bool LaunchProcessWithToken(const FilePath& binary,
                            const CommandLine::StringType& command_line,
                            HANDLE user_token,
                            bool inherit_handles,
                            DWORD creation_flags,
                            ScopedHandle* process_out,
                            ScopedHandle* thread_out) {
  FilePath::StringType application_name = binary.value();

  base::win::ScopedProcessInformation process_info;
  STARTUPINFOW startup_info;

  string16 desktop_name(UTF8ToUTF16(kDefaultDesktopName));

  memset(&startup_info, 0, sizeof(startup_info));
  startup_info.cb = sizeof(startup_info);
  startup_info.lpDesktop = const_cast<char16*>(desktop_name.c_str());

  BOOL result = CreateProcessAsUser(user_token,
                                    application_name.c_str(),
                                    const_cast<LPWSTR>(command_line.c_str()),
                                    NULL,
                                    NULL,
                                    inherit_handles,
                                    creation_flags,
                                    NULL,
                                    NULL,
                                    &startup_info,
                                    process_info.Receive());

  if (!result &&
      GetLastError() == ERROR_PIPE_NOT_CONNECTED &&
      base::win::GetVersion() == base::win::VERSION_XP) {
    DWORD session_id;
    DWORD return_length;
    result = GetTokenInformation(user_token,
                                 TokenSessionId,
                                 &session_id,
                                 sizeof(session_id),
                                 &return_length);
    if (result && session_id != 0) {
      result = CreateRemoteSessionProcess(session_id,
                                          application_name,
                                          command_line,
                                          creation_flags,
                                          process_info.Receive());
    } else {
      result = FALSE;
      SetLastError(ERROR_PIPE_NOT_CONNECTED);
    }
  }

  if (!result) {
    LOG_GETLASTERROR(ERROR) <<
        "Failed to launch a process with a user token";
    return false;
  }

  CHECK(process_info.IsValid());
  process_out->Set(process_info.TakeProcessHandle());
  thread_out->Set(process_info.TakeThreadHandle());
  return true;
}

bool WtsSessionProcessDelegate::Core::LaunchProcess(
IPC::Listener* delegate,
ScopedHandle* process_exit_event_out) {
DCHECK(main_task_runner_->BelongsToCurrentThread());

CommandLine command_line(CommandLine::NO_PROGRAM);
if (launch_elevated_) {
// The job object is not ready. Retry starting the host process later.
if (!job_.IsValid()) {
return false;
}

// Construct the helper binary name.
FilePath daemon_binary;
if (!GetInstalledBinaryPath(kDaemonBinaryName, &daemon_binary))
return false;

// Create the command line passing the name of the IPC channel to use and
// copying known switches from the caller's command line.
command_line.SetProgram(daemon_binary);
command_line.AppendSwitchPath(kElevateSwitchName, binary_path_);

CHECK(ResetEvent(process_exit_event_));
} else {
command_line.SetProgram(binary_path_);
}

// Create the server end of the IPC channel.
  scoped_ptr<IPC::ChannelProxy> channel;
std::string channel_name = GenerateIpcChannelName(this);
  if (!CreateIpcChannel(channel_name, channel_security_, io_task_runner_,
                        delegate, &channel))
return false;

// Create the command line passing the name of the IPC channel to use and
// copying known switches from the caller's command line.
command_line.AppendSwitchNative(kDaemonPipeSwitchName,
UTF8ToWide(channel_name));
command_line.CopySwitchesFrom(*CommandLine::ForCurrentProcess(),
kCopiedSwitchNames,
arraysize(kCopiedSwitchNames));

// Try to launch the process.
ScopedHandle worker_process;
ScopedHandle worker_thread;
if (!LaunchProcessWithToken(command_line.GetProgram(),
command_line.GetCommandLineString(),
session_token_,
false,
CREATE_SUSPENDED | CREATE_BREAKAWAY_FROM_JOB,
&worker_process,
&worker_thread)) {
return false;
}

HANDLE local_process_exit_event;
if (launch_elevated_) {
if (!AssignProcessToJobObject(job_, worker_process)) {
LOG_GETLASTERROR(ERROR)
<< "Failed to assign the worker to the job object";
TerminateProcess(worker_process, CONTROL_C_EXIT);
return false;
}

local_process_exit_event = process_exit_event_;
} else {
worker_process_ = worker_process.Pass();
local_process_exit_event = worker_process_;
}

if (!ResumeThread(worker_thread)) {
LOG_GETLASTERROR(ERROR) << "Failed to resume the worker thread";
KillProcess(CONTROL_C_EXIT);
return false;
}

// Return a handle that the caller can wait on to get notified when
// the process terminates.
ScopedHandle process_exit_event;
if (!DuplicateHandle(GetCurrentProcess(),
local_process_exit_event,
GetCurrentProcess(),
process_exit_event.Receive(),
SYNCHRONIZE,
FALSE,
0)) {
LOG_GETLASTERROR(ERROR) << "Failed to duplicate a handle";
KillProcess(CONTROL_C_EXIT);
return false;
}

channel_ = channel.Pass();
*process_exit_event_out = process_exit_event.Pass();
return true;
}

void DesktopSessionWin::OnPermanentError() {
  DCHECK(main_task_runner_->BelongsToCurrentThread());

  launcher_.reset();

  daemon_process()->CloseDesktopSession(id());
}

bool WtsSessionProcessDelegate::LaunchProcess(
    IPC::Listener* delegate,
    base::win::ScopedHandle* process_exit_event_out) {
  if (!core_)
    return false;

  return core_->LaunchProcess(delegate, process_exit_event_out);
}

void WorkerProcessLauncher::Core::StopWorker() {
DCHECK(caller_task_runner_->BelongsToCurrentThread());

// Record a launch failure if the process exited too soon.
if (launch_success_timer_->IsRunning()) {
launch_success_timer_->Stop();
launch_backoff_.InformOfRequest(false);
}

  // Keep |this| alive until the worker process is terminated.
  self_ = this;
// Ignore any remaining IPC messages.
ipc_enabled_ = false;

// Kill the process if it has been started already.
if (process_watcher_.GetWatchedObject() != NULL) {
launcher_delegate_->KillProcess(CONTROL_C_EXIT);
    return;
  }

  DCHECK(process_watcher_.GetWatchedObject() == NULL);

ipc_error_timer_->Stop();
process_exit_event_.Close();

// Do not relaunch the worker process if the caller has asked us to stop.
if (stopping_) {
ipc_error_timer_.reset();
launch_timer_.reset();
    self_ = NULL;
return;
}

  self_ = NULL;
  // Stop trying to restart the worker process if it exited due to
  // misconfiguration.
  DWORD exit_code = launcher_delegate_->GetExitCode();
  if (kMinPermanentErrorExitCode <= exit_code &&
      exit_code <= kMaxPermanentErrorExitCode) {
    // |delegate_| must be valid because Stop() hasn't been called yet and
    // |running_| is true. |worker_delegate_| is valid here because Stop()
    // hasn't been called yet (|stopping_| is false).
    worker_delegate_->OnPermanentError();
    return;
}
  // Schedule the next attempt to launch the worker process.
  launch_timer_->Start(FROM_HERE, launch_backoff_.GetTimeUntilRelease(),
                       this, &Core::LaunchWorker);
}

WtsSessionProcessDelegate::~WtsSessionProcessDelegate() {
  core_->Stop();
}

void DaemonProcess::DeleteAllDesktopSessions() {
  while (!desktop_sessions_.empty()) {
    delete desktop_sessions_.front();
    desktop_sessions_.pop_front();
  }
}

DWORD UnprivilegedProcessDelegate::GetExitCode() {
  DCHECK(main_task_runner_->BelongsToCurrentThread());

DWORD exit_code = CONTROL_C_EXIT;
if (worker_process_.IsValid()) {
if (!::GetExitCodeProcess(worker_process_, &exit_code)) {
LOG_GETLASTERROR(INFO)
<< "Failed to query the exit code of the worker process";
exit_code = CONTROL_C_EXIT;
}
}

  return exit_code;
}

bool ReceiveCreateProcessResponse(
    HANDLE pipe,
    PROCESS_INFORMATION* process_information_out) {
  struct CreateProcessResponse {
    DWORD size;
    BOOL success;
    DWORD last_error;
    PROCESS_INFORMATION process_information;
  };

  DWORD bytes;
  CreateProcessResponse response;
  if (!ReadFile(pipe, &response, sizeof(response), &bytes, NULL)) {
    LOG_GETLASTERROR(ERROR) << "Failed to receive CreateProcessAsUser response";
    return false;
  }

  if (bytes != sizeof(response)) {
    SetLastError(ERROR_RECEIVE_PARTIAL);
    return false;
  }

  if (!response.success) {
    SetLastError(response.last_error);
    return false;
  }

  *process_information_out = response.process_information;
  return true;
}

DesktopSessionWin::~DesktopSessionWin() {
  DCHECK(main_task_runner_->BelongsToCurrentThread());

  launcher_.reset();
   monitor_->RemoveWtsConsoleObserver(this);
 }

WorkerProcessLauncherTest::WorkerProcessLauncherTest()
    : message_loop_(MessageLoop::TYPE_IO) {
}

void DaemonProcessTest::SetUp() {
  scoped_refptr<AutoThreadTaskRunner> task_runner = new AutoThreadTaskRunner(
      message_loop_.message_loop_proxy(),
      base::Bind(&DaemonProcessTest::QuitMessageLoop,
                 base::Unretained(this)));
  daemon_process_.reset(
      new MockDaemonProcess(task_runner, task_runner,
                            base::Bind(&DaemonProcessTest::DeleteDaemonProcess,
                                       base::Unretained(this))));

  EXPECT_CALL(*daemon_process_, DoCreateDesktopSessionPtr(_))
      .Times(AnyNumber())
      .WillRepeatedly(Invoke(this, &DaemonProcessTest::DoCreateDesktopSession));
  EXPECT_CALL(*daemon_process_, LaunchNetworkProcess())
      .Times(AnyNumber())
      .WillRepeatedly(Invoke(this, &DaemonProcessTest::LaunchNetworkProcess));
}

void WorkerProcessLauncher::Core::OnChannelConnected(int32 peer_pid) {
DCHECK(caller_task_runner_->BelongsToCurrentThread());

  // |peer_pid| is send by the client and cannot be trusted.
  // GetNamedPipeClientProcessId() is not available on XP. The pipe's security
  // descriptor is the only protection we currently have against malicious
  // clients.
  
  // If we'd like to be able to launch low-privileged workers and let them
  // connect back, the pipe handle should be passed to the worker instead of
  // the pipe name.
  if (ipc_enabled_)
    worker_delegate_->OnChannelConnected();
}

 void UnprivilegedProcessDelegate::KillProcess(DWORD exit_code) {
  DCHECK(main_task_runner_->BelongsToCurrentThread());

  channel_.reset();

  if (worker_process_.IsValid()) {
    TerminateProcess(worker_process_, exit_code);
  }
}

FakeDesktopSession::~FakeDesktopSession() {
}

MockDaemonProcess::~MockDaemonProcess() {
}

UnprivilegedProcessDelegate::~UnprivilegedProcessDelegate() {
  KillProcess(CONTROL_C_EXIT);
}

void DaemonProcess::Initialize() {
  DCHECK(caller_task_runner()->BelongsToCurrentThread());

  FilePath default_config_dir = remoting::GetConfigDir();
  FilePath config_path = default_config_dir.Append(kDefaultHostConfigFile);
  const CommandLine* command_line = CommandLine::ForCurrentProcess();
  if (command_line->HasSwitch(kHostConfigSwitchName)) {
    config_path = command_line->GetSwitchValuePath(kHostConfigSwitchName);
  }

  config_watcher_.reset(new ConfigFileWatcher(caller_task_runner(),
                                              io_task_runner(),
                                              this));
  config_watcher_->Watch(config_path);

  LaunchNetworkProcess();
}

std::string GenerateIpcChannelName(void* client) {
  return base::StringPrintf("%d.%p.%d",
                            base::GetCurrentProcId(), client,
                            base::RandInt(0, std::numeric_limits<int>::max()));
}

void WorkerProcessLauncher::Core::Start() {
  DCHECK(caller_task_runner_->BelongsToCurrentThread());
  DCHECK(!stopping_);

  LaunchWorker();
}

void WorkerProcessLauncherTest::StopWorker() {
  launcher_.reset();
  DisconnectChannel();
  channel_name_.clear();
  channel_server_.reset();
  task_runner_ = NULL;
}

bool WorkerProcessLauncherTest::LaunchProcess(
IPC::Listener* delegate,
ScopedHandle* process_exit_event_out) {
process_exit_event_.Set(CreateEvent(NULL, TRUE, FALSE, NULL));
if (!process_exit_event_.IsValid())
return false;

channel_name_ = GenerateIpcChannelName(this);
  if (!CreateIpcChannel(channel_name_, kIpcSecurityDescriptor, task_runner_,
                        delegate, &channel_server_)) {
return false;
}

  exit_code_ = STILL_ACTIVE;
return DuplicateHandle(GetCurrentProcess(),
process_exit_event_,
GetCurrentProcess(),
process_exit_event_out->Receive(),
0,
FALSE,
DUPLICATE_SAME_ACCESS) != FALSE;
}

bool CreatePrivilegedToken(ScopedHandle* token_out) {
  ScopedHandle privileged_token;
  DWORD desired_access = TOKEN_ADJUST_PRIVILEGES | TOKEN_IMPERSONATE |
                         TOKEN_DUPLICATE | TOKEN_QUERY;
  if (!CopyProcessToken(desired_access, &privileged_token)) {
    return false;
  }

  TOKEN_PRIVILEGES state;
  state.PrivilegeCount = 1;
  state.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
  if (!LookupPrivilegeValue(NULL, SE_TCB_NAME, &state.Privileges[0].Luid)) {
    LOG_GETLASTERROR(ERROR) <<
        "Failed to lookup the LUID for the SE_TCB_NAME privilege";
    return false;
  }

  if (!AdjustTokenPrivileges(privileged_token, FALSE, &state, 0, NULL, 0)) {
    LOG_GETLASTERROR(ERROR) <<
        "Failed to enable SE_TCB_NAME privilege in a token";
    return false;
  }

  *token_out = privileged_token.Pass();
  return true;
}

void WtsSessionProcessDelegate::Core::DrainJobNotifications() {
  DCHECK(io_task_runner_->BelongsToCurrentThread());

  main_task_runner_->PostTask(FROM_HERE, base::Bind(
      &Core::DrainJobNotificationsCompleted, this));
}

MATCHER_P(Message, type, "") {
  return arg.type() == static_cast<uint32>(type);
}

WorkerProcessLauncher::Core::Core(
    scoped_refptr<base::SingleThreadTaskRunner> caller_task_runner,
    scoped_ptr<WorkerProcessLauncher::Delegate> launcher_delegate,
    WorkerProcessIpcDelegate* worker_delegate)
     : caller_task_runner_(caller_task_runner),
       launcher_delegate_(launcher_delegate.Pass()),
       worker_delegate_(worker_delegate),
       ipc_enabled_(false),
       launch_backoff_(&kDefaultBackoffPolicy),
       stopping_(false) {
  DCHECK(caller_task_runner_->BelongsToCurrentThread());

  ipc_error_timer_.reset(new base::OneShotTimer<Core>());
  launch_success_timer_.reset(new base::OneShotTimer<Core>());
  launch_timer_.reset(new base::OneShotTimer<Core>());
}

void WorkerProcessLauncherTest::KillProcess(DWORD exit_code) {
  exit_code_ = exit_code;
BOOL result = SetEvent(process_exit_event_);
EXPECT_TRUE(result);
}

FakeDesktopSession::FakeDesktopSession(DaemonProcess* daemon_process, int id)
    : DesktopSession(daemon_process, id) {
}

void WorkerProcessLauncherTest::QuitMainMessageLoop() {
  message_loop_.PostTask(FROM_HERE, MessageLoop::QuitClosure());
}

DaemonProcessTest::~DaemonProcessTest() {
}

WtsSessionProcessDelegate::Core::Core(
    scoped_refptr<base::SingleThreadTaskRunner> main_task_runner,
    scoped_refptr<base::SingleThreadTaskRunner> io_task_runner,
    const FilePath& binary_path,
    bool launch_elevated,
    const std::string& channel_security)
    : main_task_runner_(main_task_runner),
       io_task_runner_(io_task_runner),
       binary_path_(binary_path),
       channel_security_(channel_security),
       launch_elevated_(launch_elevated),
       stopping_(false) {
   DCHECK(main_task_runner_->BelongsToCurrentThread());
}

WtsConsoleSessionProcessDriver::~WtsConsoleSessionProcessDriver() {
  DCHECK(caller_task_runner_->BelongsToCurrentThread());

  CHECK_EQ(stoppable_state(), Stoppable::kStopped);

  monitor_->RemoveWtsConsoleObserver(this);

   CHECK(launcher_.get() == NULL);
 }

void WorkerProcessLauncher::Send(IPC::Message* message) {
  core_->Send(message);
}

  MockIpcDelegate() {}

bool CreateIpcChannel(
const std::string& channel_name,
const std::string& pipe_security_descriptor,
    scoped_refptr<base::SingleThreadTaskRunner> io_task_runner,
    IPC::Listener* delegate,
    scoped_ptr<IPC::ChannelProxy>* channel_out) {
// Create security descriptor for the channel.
SECURITY_ATTRIBUTES security_attributes;
security_attributes.nLength = sizeof(security_attributes);
security_attributes.bInheritHandle = FALSE;

ULONG security_descriptor_length = 0;
if (!ConvertStringSecurityDescriptorToSecurityDescriptor(
UTF8ToUTF16(pipe_security_descriptor).c_str(),
SDDL_REVISION_1,
reinterpret_cast<PSECURITY_DESCRIPTOR*>(
&security_attributes.lpSecurityDescriptor),
&security_descriptor_length)) {
LOG_GETLASTERROR(ERROR) <<
"Failed to create a security descriptor for the Chromoting IPC channel";
return false;
}

// Convert the channel name to the pipe name.
std::string pipe_name(kChromePipeNamePrefix);
pipe_name.append(channel_name);

// Create the server end of the pipe. This code should match the code in
// IPC::Channel with exception of passing a non-default security descriptor.
base::win::ScopedHandle pipe;
pipe.Set(CreateNamedPipe(
UTF8ToUTF16(pipe_name).c_str(),
PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED | FILE_FLAG_FIRST_PIPE_INSTANCE,
PIPE_TYPE_BYTE | PIPE_READMODE_BYTE,
1,
IPC::Channel::kReadBufferSize,
IPC::Channel::kReadBufferSize,
5000,
&security_attributes));
if (!pipe.IsValid()) {
LOG_GETLASTERROR(ERROR) <<
"Failed to create the server end of the Chromoting IPC channel";
LocalFree(security_attributes.lpSecurityDescriptor);
return false;
}

LocalFree(security_attributes.lpSecurityDescriptor);

  // Wrap the pipe into an IPC channel.
  channel_out->reset(new IPC::ChannelProxy(
      IPC::ChannelHandle(pipe),
      IPC::Channel::MODE_SERVER,
      delegate,
      io_task_runner));
return true;
}

DWORD WtsSessionProcessDelegate::Core::GetExitCode() {
  DCHECK(main_task_runner_->BelongsToCurrentThread());

DWORD exit_code = CONTROL_C_EXIT;
if (worker_process_.IsValid()) {
if (!::GetExitCodeProcess(worker_process_, &exit_code)) {
LOG_GETLASTERROR(INFO)
<< "Failed to query the exit code of the worker process";
exit_code = CONTROL_C_EXIT;
}
}

  return exit_code;
}

  const DaemonProcess::DesktopSessionList& desktop_sessions() const {
    return daemon_process_->desktop_sessions();
  }

void MockDaemonProcess::SendToNetwork(IPC::Message* message) {
  Sent(*message);
  delete message;
}

bool WtsSessionProcessDelegate::Core::Send(IPC::Message* message) {
  DCHECK(main_task_runner_->BelongsToCurrentThread());

  if (channel_.get()) {
    return channel_->Send(message);
  } else {
    delete message;
    return false;
   }
 }

void WorkerProcessLauncherTest::SetUp() {
task_runner_ = new AutoThreadTaskRunner(
message_loop_.message_loop_proxy(),
base::Bind(&WorkerProcessLauncherTest::QuitMainMessageLoop,
base::Unretained(this)));

  exit_code_ = STILL_ACTIVE;
// Set up process launcher delegate
launcher_delegate_.reset(new MockProcessLauncherDelegate());
EXPECT_CALL(*launcher_delegate_, Send(_))
.Times(AnyNumber())
.WillRepeatedly(Return(false));
  EXPECT_CALL(*launcher_delegate_, GetExitCode())
.Times(AnyNumber())
      .WillRepeatedly(ReturnPointee(&exit_code_));
EXPECT_CALL(*launcher_delegate_, KillProcess(_))
.Times(AnyNumber())
.WillRepeatedly(Invoke(this, &WorkerProcessLauncherTest::KillProcess));

// Set up IPC delegate.
EXPECT_CALL(ipc_delegate_, OnMessageReceived(_))
.Times(AnyNumber())
.WillRepeatedly(Return(false));
}

void DaemonProcessTest::QuitMessageLoop() {
  message_loop_.PostTask(FROM_HERE, MessageLoop::QuitClosure());
}

void WtsSessionProcessDelegate::Core::OnJobNotification(DWORD message,
                                                      DWORD pid) {
DCHECK(main_task_runner_->BelongsToCurrentThread());

switch (message) {
case JOB_OBJECT_MSG_ACTIVE_PROCESS_ZERO:
CHECK(SetEvent(process_exit_event_));
break;

case JOB_OBJECT_MSG_NEW_PROCESS:
// We report the exit code of the worker process to be |CONTROL_C_EXIT|
// if we cannot get the actual exit code. So here we can safely ignore
// the error returned by OpenProcess().
worker_process_.Set(OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, pid));
break;
}
}

void DaemonProcessTest::LaunchNetworkProcess() {
terminal_id_ = 0;
  daemon_process_->OnChannelConnected();
}

bool WorkerProcessLauncherTest::OnMessageReceived(const IPC::Message& message) {
  return false;
 }

void WorkerProcessLauncherTest::DisconnectChannel() {
  channel_client_.reset();
}

void WorkerProcessLauncher::Core::Stop() {
  DCHECK(caller_task_runner_->BelongsToCurrentThread());

  if (!stopping_) {
    stopping_ = true;
    worker_delegate_ = NULL;
    StopWorker();
  }
}

void WtsSessionProcessDelegate::Core::Stop() {
  DCHECK(main_task_runner_->BelongsToCurrentThread());

  if (!stopping_) {
    stopping_ = true;

    DrainJobNotificationsCompleted();
  }
}

void DaemonProcess::CreateDesktopSession(int terminal_id) {
  DCHECK(caller_task_runner()->BelongsToCurrentThread());

  if (IsTerminalIdKnown(terminal_id)) {
    LOG(ERROR) << "An invalid terminal ID. terminal_id=" << terminal_id;
    RestartNetworkProcess();
    DeleteAllDesktopSessions();
    return;
  }

  VLOG(1) << "Daemon: opened desktop session " << terminal_id;
  desktop_sessions_.push_back(
      DoCreateDesktopSession(terminal_id).release());
  next_terminal_id_ = std::max(next_terminal_id_, terminal_id + 1);
}

void WtsConsoleSessionProcessDriver::OnPermanentError() {
  DCHECK(caller_task_runner_->BelongsToCurrentThread());

  Stop();
}

   MockProcessLauncherDelegate() {}

void WorkerProcessLauncher::Core::LaunchWorker() {
  DCHECK(caller_task_runner_->BelongsToCurrentThread());
  DCHECK(!ipc_enabled_);
  DCHECK(!launch_success_timer_->IsRunning());
  DCHECK(!launch_timer_->IsRunning());
  DCHECK(!process_exit_event_.IsValid());
  DCHECK(process_watcher_.GetWatchedObject() == NULL);

  if (launcher_delegate_->LaunchProcess(this, &process_exit_event_)) {
    if (process_watcher_.StartWatching(process_exit_event_, this)) {
      ipc_enabled_ = true;
      launch_success_timer_->Start(FROM_HERE, base::TimeDelta::FromSeconds(2),
                                   this, &Core::RecordSuccessfulLaunch);
      return;
    }

    launcher_delegate_->KillProcess(CONTROL_C_EXIT);
  }

  launch_backoff_.InformOfRequest(false);
  StopWorker();
}

bool WtsSessionProcessDelegate::Send(IPC::Message* message) {
   return core_->Send(message);
 }

void WtsSessionProcessDelegate::Core::DrainJobNotificationsCompleted() {
  DCHECK(main_task_runner_->BelongsToCurrentThread());

  if (job_.IsValid()) {
    job_.Close();

    io_task_runner_->PostTask(FROM_HERE, base::Bind(
        &Core::DrainJobNotifications, this));
  }
}

DesktopSession* DaemonProcessTest::DoCreateDesktopSession(int terminal_id) {
  return new FakeDesktopSession(daemon_process_.get(), terminal_id);
}

bool WorkerProcessLauncher::Core::OnMessageReceived(
    const IPC::Message& message) {
  DCHECK(caller_task_runner_->BelongsToCurrentThread());

  if (!ipc_enabled_)
    return false;

  return worker_delegate_->OnMessageReceived(message);
}

void WtsConsoleSessionProcessDriver::OnSessionDetached() {
  DCHECK(caller_task_runner_->BelongsToCurrentThread());
  DCHECK(launcher_.get() != NULL);

  launcher_.reset();
}

void WorkerProcessLauncherTest::StartWorker() {
  launcher_.reset(new WorkerProcessLauncher(
      task_runner_, launcher_delegate_.Pass(), &ipc_delegate_));
}

bool DesktopSessionWin::OnMessageReceived(const IPC::Message& message) {
  DCHECK(main_task_runner_->BelongsToCurrentThread());

  return false;
}

WtsSessionProcessDelegate::Core::~Core() {
}

 void DaemonProcessTest::DeleteDaemonProcess() {
  daemon_process_.reset();
}

void WtsConsoleSessionProcessDriver::OnSessionAttached(uint32 session_id) {
  DCHECK(caller_task_runner_->BelongsToCurrentThread());

  if (stoppable_state() != Stoppable::kRunning) {
    return;
  }

  DCHECK(launcher_.get() == NULL);

  FilePath host_binary;
  if (!GetInstalledBinaryPath(kHostBinaryName, &host_binary)) {
    Stop();
    return;
  }

  scoped_ptr<WtsSessionProcessDelegate> delegate(
      new WtsSessionProcessDelegate(caller_task_runner_,
                                    io_task_runner_,
                                    host_binary,
                                    session_id,
                                    true,
                                    kDaemonIpcSecurityDescriptor));

  launcher_.reset(new WorkerProcessLauncher(
      caller_task_runner_, delegate.Pass(), this));
}

bool MockDaemonProcess::OnMessageReceived(const IPC::Message& message) {
  Received(message);

  return DaemonProcess::OnMessageReceived(message);
}

bool WtsSessionProcessDelegate::Core::Initialize(uint32 session_id) {
  if (base::win::GetVersion() == base::win::VERSION_XP)
     launch_elevated_ = false;
 
   if (launch_elevated_) {
     process_exit_event_.Set(CreateEvent(NULL, TRUE, FALSE, NULL));
     if (!process_exit_event_.IsValid()) {
       LOG(ERROR) << "Failed to create a nameless event";
      return false;
    }

    io_task_runner_->PostTask(FROM_HERE,
                              base::Bind(&Core::InitializeJob, this));
  }

  return CreateSessionToken(session_id, &session_token_);
}

bool WtsConsoleSessionProcessDriver::OnMessageReceived(
    const IPC::Message& message) {
  DCHECK(caller_task_runner_->BelongsToCurrentThread());

  return false;
}

MockDaemonProcess::MockDaemonProcess(
    scoped_refptr<base::SingleThreadTaskRunner> caller_task_runner,
    scoped_refptr<base::SingleThreadTaskRunner> io_task_runner,
    const base::Closure& stopped_callback)
    : DaemonProcess(caller_task_runner, io_task_runner, stopped_callback) {
}

   virtual ~MockProcessLauncherDelegate() {}

   virtual ~MockIpcDelegate() {}

 void WtsSessionProcessDelegate::KillProcess(DWORD exit_code) {
  if (core_) {
    core_->KillProcess(exit_code);
  }
}

bool UnprivilegedProcessDelegate::LaunchProcess(
IPC::Listener* delegate,
ScopedHandle* process_exit_event_out) {
DCHECK(main_task_runner_->BelongsToCurrentThread());
// Generate a unique name for the channel.
std::string channel_name = GenerateIpcChannelName(this);

// Create a connected IPC channel.
ScopedHandle client;
scoped_ptr<IPC::ChannelProxy> server;
  if (!CreateConnectedIpcChannel(channel_name, delegate, &client, &server))
return false;

// Convert the handle value into a decimal integer. Handle values are 32bit
// even on 64bit platforms.
std::string pipe_handle = base::StringPrintf(
"%d", reinterpret_cast<ULONG_PTR>(client.Get()));

// Create the command line passing the name of the IPC channel to use and
// copying known switches from the caller's command line.
CommandLine command_line(binary_path_);
command_line.AppendSwitchASCII(kDaemonPipeSwitchName, pipe_handle);
command_line.CopySwitchesFrom(*CommandLine::ForCurrentProcess(),
kCopiedSwitchNames,
arraysize(kCopiedSwitchNames));

// Try to launch the process.
// TODO(alexeypa): Pass a restricted process token.
// See http://crbug.com/134694.
ScopedHandle worker_thread;
worker_process_.Close();
if (!LaunchProcessWithToken(command_line.GetProgram(),
command_line.GetCommandLineString(),
NULL,
true,
0,
&worker_process_,
&worker_thread)) {
return false;
}

// Return a handle that the caller can wait on to get notified when
// the process terminates.
ScopedHandle process_exit_event;
if (!DuplicateHandle(GetCurrentProcess(),
worker_process_,
GetCurrentProcess(),
process_exit_event.Receive(),
SYNCHRONIZE,
FALSE,
0)) {
LOG_GETLASTERROR(ERROR) << "Failed to duplicate a handle";
KillProcess(CONTROL_C_EXIT);
return false;
}

channel_ = server.Pass();
*process_exit_event_out = process_exit_event.Pass();
return true;
}

DWORD WtsSessionProcessDelegate::GetExitCode() {
  if (!core_)
    return CONTROL_C_EXIT;

  return core_->GetExitCode();
}

scoped_ptr<DesktopSession> MockDaemonProcess::DoCreateDesktopSession(
    int terminal_id) {
  return scoped_ptr<DesktopSession>(DoCreateDesktopSessionPtr(terminal_id));
}

void DaemonProcess::OnConfigUpdated(const std::string& serialized_config) {
  DCHECK(caller_task_runner()->BelongsToCurrentThread());

  if (serialized_config_ != serialized_config) {
    serialized_config_ = serialized_config;
    SendToNetwork(
        new ChromotingDaemonNetworkMsg_Configuration(serialized_config_));
  }
}

void WtsSessionProcessDelegate::Core::InitializeJob() {
  DCHECK(io_task_runner_->BelongsToCurrentThread());

  ScopedHandle job;
  job.Set(CreateJobObject(NULL, NULL));
  if (!job.IsValid()) {
    LOG_GETLASTERROR(ERROR) << "Failed to create a job object";
    return;
  }

  JOBOBJECT_EXTENDED_LIMIT_INFORMATION info;
  memset(&info, 0, sizeof(info));
  info.BasicLimitInformation.LimitFlags = JOB_OBJECT_LIMIT_ACTIVE_PROCESS |
      JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE;
  info.BasicLimitInformation.ActiveProcessLimit = 2;
  if (!SetInformationJobObject(job,
                               JobObjectExtendedLimitInformation,
                               &info,
                               sizeof(info))) {
    LOG_GETLASTERROR(ERROR) << "Failed to set limits on the job object";
    return;
  }

  if (!MessageLoopForIO::current()->RegisterJobObject(job, this)) {
    LOG_GETLASTERROR(ERROR)
        << "Failed to associate the job object with a completion port";
    return;
  }

  scoped_ptr<ScopedHandle> job_wrapper(new ScopedHandle());
  *job_wrapper = job.Pass();

  main_task_runner_->PostTask(FROM_HERE, base::Bind(
      &Core::InitializeJobCompleted, this, base::Passed(&job_wrapper)));
}

WorkerProcessLauncher::~WorkerProcessLauncher() {
  core_->Stop();
  core_ = NULL;
}

void WtsSessionProcessDelegate::Core::OnIOCompleted(
    base::MessagePumpForIO::IOContext* context,
    DWORD bytes_transferred,
    DWORD error) {
  DCHECK(io_task_runner_->BelongsToCurrentThread());

  main_task_runner_->PostTask(FROM_HERE, base::Bind(
      &Core::OnJobNotification, this, bytes_transferred,
      reinterpret_cast<DWORD>(context)));
}

void WtsConsoleSessionProcessDriver::DoStop() {
  DCHECK(caller_task_runner_->BelongsToCurrentThread());

  launcher_.reset();
  CompleteStopping();
}

void WtsConsoleSessionProcessDriver::OnChannelConnected() {
   DCHECK(caller_task_runner_->BelongsToCurrentThread());
 }

void DaemonProcess::DoStop() {
  DCHECK(caller_task_runner()->BelongsToCurrentThread());

  config_watcher_.reset();
  DeleteAllDesktopSessions();

  CompleteStopping();
}

void DaemonProcessTest::TearDown() {
  daemon_process_->Stop();
  message_loop_.Run();
}

void DaemonProcess::OnChannelConnected() {
   DCHECK(caller_task_runner()->BelongsToCurrentThread());
 
   DeleteAllDesktopSessions();

  next_terminal_id_ = 0;

  SendToNetwork(
      new ChromotingDaemonNetworkMsg_Configuration(serialized_config_));
}

DaemonProcess::~DaemonProcess() {
  DCHECK(!config_watcher_.get());
  DCHECK(desktop_sessions_.empty());
}

void DaemonProcess::CloseDesktopSession(int terminal_id) {
  DCHECK(caller_task_runner()->BelongsToCurrentThread());

  if (!IsTerminalIdKnown(terminal_id)) {
    LOG(ERROR) << "An invalid terminal ID. terminal_id=" << terminal_id;
    RestartNetworkProcess();
    DeleteAllDesktopSessions();
    return;
  }

  DesktopSessionList::iterator i;
  for (i = desktop_sessions_.begin(); i != desktop_sessions_.end(); ++i) {
    if ((*i)->id() == terminal_id) {
      break;
    }
  }

  if (i == desktop_sessions_.end())
    return;

  delete *i;
  desktop_sessions_.erase(i);

  VLOG(1) << "Daemon: closed desktop session " << terminal_id;
  SendToNetwork(
      new ChromotingDaemonNetworkMsg_TerminalDisconnected(terminal_id));
}

bool DaemonProcess::OnMessageReceived(const IPC::Message& message) {
  DCHECK(caller_task_runner()->BelongsToCurrentThread());

  bool handled = true;
  IPC_BEGIN_MESSAGE_MAP(DaemonProcess, message)
    IPC_MESSAGE_HANDLER(ChromotingNetworkHostMsg_ConnectTerminal,
                        CreateDesktopSession)
    IPC_MESSAGE_HANDLER(ChromotingNetworkHostMsg_DisconnectTerminal,
                        CloseDesktopSession)
    IPC_MESSAGE_UNHANDLED(handled = false)
  IPC_END_MESSAGE_MAP()
  return handled;
}

 void WorkerProcessLauncherTest::ConnectChannel() {
   channel_client_.reset(new IPC::ChannelProxy(
       IPC::ChannelHandle(channel_name_),
      IPC::Channel::MODE_CLIENT,
      this,
      task_runner_));
}
