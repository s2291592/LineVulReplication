const btif_config_section_iter_t *btif_config_section_next(const btif_config_section_iter_t *section) {
  assert(config != NULL);
  assert(section != NULL);
 return (const btif_config_section_iter_t *)config_section_next((const config_section_node_t *)section);
}

static jboolean setAdapterPropertyNative(JNIEnv *env, jobject obj, jint type, jbyteArray value) {
    ALOGV("%s:",__FUNCTION__);

    jbyte *val;
    jboolean result = JNI_FALSE;
 if (!sBluetoothInterface) return result;

    val = env->GetByteArrayElements(value, NULL);
 bt_property_t prop;
    prop.type = (bt_property_type_t) type;
    prop.len = env->GetArrayLength(value);
    prop.val = val;

 int ret = sBluetoothInterface->set_adapter_property(&prop);
    env->ReleaseByteArrayElements(value, val, 0);
    result = (ret == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;

 return result;
}

static void classInitNative(JNIEnv* env, jclass clazz) {
 int err;
 hw_module_t* module;

    jclass jniCallbackClass =
        env->FindClass("com/android/bluetooth/btservice/JniCallbacks");
    sJniCallbacksField = env->GetFieldID(clazz, "mJniCallbacks",
 "Lcom/android/bluetooth/btservice/JniCallbacks;");

    method_stateChangeCallback = env->GetMethodID(jniCallbackClass, "stateChangeCallback", "(I)V");

    method_adapterPropertyChangedCallback = env->GetMethodID(jniCallbackClass,
 "adapterPropertyChangedCallback",
 "([I[[B)V");
    method_discoveryStateChangeCallback = env->GetMethodID(jniCallbackClass,
 "discoveryStateChangeCallback", "(I)V");

    method_devicePropertyChangedCallback = env->GetMethodID(jniCallbackClass,
 "devicePropertyChangedCallback",
 "([B[I[[B)V");
    method_deviceFoundCallback = env->GetMethodID(jniCallbackClass, "deviceFoundCallback", "([B)V");
    method_pinRequestCallback = env->GetMethodID(jniCallbackClass, "pinRequestCallback",
 "([B[BIZ)V");
    method_sspRequestCallback = env->GetMethodID(jniCallbackClass, "sspRequestCallback",
 "([B[BIII)V");

    method_bondStateChangeCallback = env->GetMethodID(jniCallbackClass,
 "bondStateChangeCallback", "(I[BI)V");

    method_aclStateChangeCallback = env->GetMethodID(jniCallbackClass,
 "aclStateChangeCallback", "(I[BI)V");

    method_setWakeAlarm = env->GetMethodID(clazz, "setWakeAlarm", "(JZ)Z");
    method_acquireWakeLock = env->GetMethodID(clazz, "acquireWakeLock", "(Ljava/lang/String;)Z");
    method_releaseWakeLock = env->GetMethodID(clazz, "releaseWakeLock", "(Ljava/lang/String;)Z");
    method_energyInfo = env->GetMethodID(clazz, "energyInfoCallback", "(IIJJJJ)V");

 char value[PROPERTY_VALUE_MAX];
    property_get("bluetooth.mock_stack", value, "");

 const char *id = (strcmp(value, "1")? BT_STACK_MODULE_ID : BT_STACK_TEST_MODULE_ID);

    err = hw_get_module(id, (hw_module_t const**)&module);

 if (err == 0) {
 hw_device_t* abstraction;
        err = module->methods->open(module, id, &abstraction);
 if (err == 0) {
 bluetooth_module_t* btStack = (bluetooth_module_t *)abstraction;
            sBluetoothInterface = btStack->get_bluetooth_interface();
 } else {
           ALOGE("Error while opening Bluetooth library");
 }
 } else {
        ALOGE("No Bluetooth Library found");
 }
}

static int acquire_wake_lock(const char *lock_name) {
 return BT_STATUS_SUCCESS;
}

static int release_wake_lock_callout(const char *lock_name) {
 JNIEnv *env;
 JavaVM *vm = AndroidRuntime::getJavaVM();
    jint status = vm->GetEnv((void **)&env, JNI_VERSION_1_6);

 if (status != JNI_OK && status != JNI_EDETACHED) {
        ALOGE("%s unable to get environment for JNI call", __func__);
 return BT_STATUS_FAIL;
 }
 if (status == JNI_EDETACHED && vm->AttachCurrentThread(&env, &sAttachArgs) != 0) {
        ALOGE("%s unable to attach thread to VM", __func__);
 return BT_STATUS_FAIL;
 }
    jboolean ret = JNI_FALSE;
    jstring lock_name_jni = env->NewStringUTF(lock_name);
 if (lock_name_jni) {
        ret = env->CallBooleanMethod(sJniAdapterServiceObj, method_releaseWakeLock, lock_name_jni);
        env->DeleteLocalRef(lock_name_jni);
 } else {
        ALOGE("%s unable to allocate string: %s", __func__, lock_name);
 }
 if (status == JNI_EDETACHED) {
        vm->DetachCurrentThread();
 }
 return ret ? BT_STATUS_SUCCESS : BT_STATUS_FAIL;
}

void do_help(char UNUSED *p)
{
 int i = 0;
 int max = 0;
 char line[128];
 int pos = 0;

 while (console_cmd_list[i].name != NULL)
 {
        pos = sprintf(line, "%s", (char*)console_cmd_list[i].name);
        bdt_log("%s %s\n", (char*)line, (char*)console_cmd_list[i].help);
        i++;
 }
}

static void callback_thread_event(bt_cb_thread_evt event) {
 JavaVM* vm = AndroidRuntime::getJavaVM();
 if (event  == ASSOCIATE_JVM) {
 JavaVMAttachArgs args;
 char name[] = "BT Service Callback Thread";
        args.version = JNI_VERSION_1_6;
        args.name = name;
        args.group = NULL;
        vm->AttachCurrentThread(&callbackEnv, &args);
        ALOGV("Callback thread attached: %p", callbackEnv);
 } else if (event == DISASSOCIATE_JVM) {
 if (!checkCallbackThread()) {
            ALOGE("Callback: '%s' is not called on the correct thread", __FUNCTION__);
 return;
 }
        vm->DetachCurrentThread();
 }
}

static int cancel_discovery(void)
{
 /* sanity check */
 if (interface_ready() == FALSE)
 return BT_STATUS_NOT_READY;

 return btif_dm_cancel_discovery();
}

bt_status_t btif_storage_get_remote_addr_type(bt_bdaddr_t *remote_bd_addr,
 int*addr_type)
{
 bdstr_t bdstr;
    bdaddr_to_string(remote_bd_addr, bdstr, sizeof(bdstr));
 int ret = btif_config_get_int(bdstr, "AddrType", addr_type);
 return ret ? BT_STATUS_SUCCESS : BT_STATUS_FAIL;
}

static void usage(const char *name) {
  fprintf(stderr, "Usage: %s [--bond|--discover|--discoverable|--up|--sco_listen|--sco_connect] [--bdaddr=<bdaddr>] [--time=<time_in_sec>] --verbose\n", name);
  fprintf(stderr, "     bond: Discover actively advertising devices\n");
  fprintf(stderr, "     discover: Discover actively advertising devices\n");
  fprintf(stderr, "     discoverable: Set into a connectable and discoverable mode\n");
  fprintf(stderr, "     up: Only bring up stack\n");
  fprintf(stderr, "     sco_listen: Listen for incoming SCO connections\n");
  fprintf(stderr, "     sco_connect: Establish a SCO connection with another device\n");
  fprintf(stderr, "     time: Time to hold in the specified mode\n");
  exit(1);
}

static int prop2cfg(bt_bdaddr_t *remote_bd_addr, bt_property_t *prop)
{
 bdstr_t bdstr = {0};
 if(remote_bd_addr)
        bdaddr_to_string(remote_bd_addr, bdstr, sizeof(bdstr));
    BTIF_TRACE_DEBUG("in, bd addr:%s, prop type:%d, len:%d", bdstr, prop->type, prop->len);
 char value[1024];
 if(prop->len <= 0 || prop->len > (int)sizeof(value) - 1)
 {
        BTIF_TRACE_ERROR("property type:%d, len:%d is invalid", prop->type, prop->len);
 return FALSE;
 }
 switch(prop->type)
 {
 case BT_PROPERTY_REMOTE_DEVICE_TIMESTAMP:
            btif_config_set_int(bdstr,
                                BTIF_STORAGE_PATH_REMOTE_DEVTIME, (int)time(NULL));
 break;
 case BT_PROPERTY_BDNAME:
            strncpy(value, (char*)prop->val, prop->len);
            value[prop->len]='\0';
 if(remote_bd_addr)
                btif_config_set_str(bdstr,
                                BTIF_STORAGE_PATH_REMOTE_NAME, value);
 else btif_config_set_str("Adapter",
                                BTIF_STORAGE_KEY_ADAPTER_NAME, value);
 /* save name immediately */
            btif_config_save();
 break;
 case BT_PROPERTY_REMOTE_FRIENDLY_NAME:
            strncpy(value, (char*)prop->val, prop->len);
            value[prop->len]='\0';
            btif_config_set_str(bdstr, BTIF_STORAGE_PATH_REMOTE_ALIASE, value);
 /* save friendly name immediately */
            btif_config_save();
 break;
 case BT_PROPERTY_ADAPTER_SCAN_MODE:
            btif_config_set_int("Adapter",
                                BTIF_STORAGE_KEY_ADAPTER_SCANMODE, *(int*)prop->val);
 break;
 case BT_PROPERTY_ADAPTER_DISCOVERY_TIMEOUT:
            btif_config_set_int("Adapter",
                                BTIF_STORAGE_KEY_ADAPTER_DISC_TIMEOUT, *(int*)prop->val);
 break;
 case BT_PROPERTY_CLASS_OF_DEVICE:
            btif_config_set_int(bdstr,
                                BTIF_STORAGE_PATH_REMOTE_DEVCLASS, *(int*)prop->val);
 break;
 case BT_PROPERTY_TYPE_OF_DEVICE:
            btif_config_set_int(bdstr,
                                BTIF_STORAGE_PATH_REMOTE_DEVTYPE, *(int*)prop->val);
 break;
 case BT_PROPERTY_UUIDS:
 {
 uint32_t i;
 char buf[64];
            value[0] = 0;
 for (i=0; i < (prop->len)/sizeof(bt_uuid_t); i++)
 {
 bt_uuid_t *p_uuid = (bt_uuid_t*)prop->val + i;
                memset(buf, 0, sizeof(buf));
                uuid_to_string_legacy(p_uuid, buf);
                strcat(value, buf);
                strcat(value, " ");
 }
            btif_config_set_str(bdstr, BTIF_STORAGE_PATH_REMOTE_SERVICE, value);
            btif_config_save();
 break;
 }
 case BT_PROPERTY_REMOTE_VERSION_INFO:
 {
 bt_remote_version_t *info = (bt_remote_version_t *)prop->val;

 if (!info)
 return FALSE;

            btif_config_set_int(bdstr,
                                BTIF_STORAGE_PATH_REMOTE_VER_MFCT, info->manufacturer);
            btif_config_set_int(bdstr,
                                BTIF_STORAGE_PATH_REMOTE_VER_VER, info->version);
            btif_config_set_int(bdstr,
                                BTIF_STORAGE_PATH_REMOTE_VER_SUBVER, info->sub_ver);
            btif_config_save();
 } break;

 default:
             BTIF_TRACE_ERROR("Unknow prop type:%d", prop->type);
 return FALSE;
 }
 return TRUE;
}

bool btif_config_get_bin(const char *section, const char *key, uint8_t *value, size_t *length) {
  assert(config != NULL);
  assert(section != NULL);
  assert(key != NULL);
  assert(value != NULL);
  assert(length != NULL);

  pthread_mutex_lock(&lock);
 const char *value_str = config_get_string(config, section, key, NULL);
  pthread_mutex_unlock(&lock);

 if (!value_str)
 return false;

 size_t value_len = strlen(value_str);
 if ((value_len % 2) != 0 || *length < (value_len / 2))
 return false;

 for (size_t i = 0; i < value_len; ++i)
 if (!isxdigit(value_str[i]))
 return false;

 for (*length = 0; *value_str; value_str += 2, *length += 1)
    sscanf(value_str, "%02hhx", &value[*length]);

 return true;
}

static jboolean createBondNative(JNIEnv* env, jobject obj, jbyteArray address, jint transport) {
    ALOGV("%s:",__FUNCTION__);

    jbyte *addr;
    jboolean result = JNI_FALSE;

 if (!sBluetoothInterface) return result;

    addr = env->GetByteArrayElements(address, NULL);
 if (addr == NULL) {
        jniThrowIOException(env, EINVAL);
 return result;
 }

 int ret = sBluetoothInterface->create_bond((bt_bdaddr_t *)addr, transport);
    env->ReleaseByteArrayElements(address, addr, 0);
    result = (ret == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;

 return result;
}

int get_remote_device_property(bt_bdaddr_t *remote_addr, bt_property_type_t type)
{
 /* sanity check */
 if (interface_ready() == FALSE)
 return BT_STATUS_NOT_READY;

 return btif_get_remote_device_property(remote_addr, type);
}

void bdt_cleanup(void)
{
    bdt_log("CLEANUP");
    sBtInterface->cleanup();
}

static void dut_mode_recv(uint16_t UNUSED opcode, uint8_t UNUSED *buf, uint8_t UNUSED len)
{
    bdt_log("DUT MODE RECV : NOT IMPLEMENTED");
}

int get_remote_services(bt_bdaddr_t *remote_addr)
{
 /* sanity check */
 if (interface_ready() == FALSE)
 return BT_STATUS_NOT_READY;

 return btif_dm_get_remote_services(remote_addr);
}

 static int remove_bond(const bt_bdaddr_t *bd_addr)
 {
     /* sanity check */
     if (interface_ready() == FALSE)
         return BT_STATUS_NOT_READY;

 return btif_dm_remove_bond(bd_addr);
}

int dut_mode_send(uint16_t opcode, uint8_t* buf, uint8_t len)
{
    LOG_INFO("dut_mode_send");

 /* sanity check */
 if (interface_ready() == FALSE)
 return BT_STATUS_NOT_READY;

 return btif_dut_mode_send(opcode, buf, len);
}

static int read_energy_info()
{
 if (interface_ready() == FALSE)
 return BT_STATUS_NOT_READY;
    btif_dm_read_energy_info();
 return BT_STATUS_SUCCESS;
}

static jboolean cancelDiscoveryNative(JNIEnv* env, jobject obj) {
    ALOGV("%s:",__FUNCTION__);

    jboolean result = JNI_FALSE;
 if (!sBluetoothInterface) return result;

 int ret = sBluetoothInterface->cancel_discovery();
    result = (ret == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;
 return result;
}

void btif_config_save(void) {
  assert(alarm_timer != NULL);
  assert(config != NULL);

  alarm_set(alarm_timer, CONFIG_SETTLE_PERIOD_MS, timer_config_save_cb, NULL);
}

const bt_interface_t* bluetooth__get_bluetooth_interface ()
{
 /* fixme -- add property to disable bt interface ? */

 return &bluetoothInterface;
}

static void btif_read_le_key(const uint8_t key_type, const size_t key_len, bt_bdaddr_t bd_addr,
 const uint8_t addr_type, const bool add_key, bool *device_added, bool *key_found)
{
    assert(device_added);
    assert(key_found);

 char buffer[100];
    memset(buffer, 0, sizeof(buffer));

 if (btif_storage_get_ble_bonding_key(&bd_addr, key_type, buffer, key_len) == BT_STATUS_SUCCESS)
 {
 if (add_key)
 {
            BD_ADDR bta_bd_addr;
            bdcpy(bta_bd_addr, bd_addr.address);

 if (!*device_added)
 {
                BTA_DmAddBleDevice(bta_bd_addr, addr_type, BT_DEVICE_TYPE_BLE);
 *device_added = true;
 }

 char bd_str[20] = {0};
            BTIF_TRACE_DEBUG("%s() Adding key type %d for %s", __func__,
                key_type, bdaddr_to_string(&bd_addr, bd_str, sizeof(bd_str)));
            BTA_DmAddBleKey(bta_bd_addr, (tBTA_LE_KEY_VALUE *)buffer, key_type);
 }

 *key_found = true;
 }
}

int btif_config_clear(void){
  assert(config != NULL);
  assert(alarm_timer != NULL);

  alarm_cancel(alarm_timer);

  pthread_mutex_lock(&lock);
  config_free(config);

  config = config_new_empty();
 if (config == NULL) {
    pthread_mutex_unlock(&lock);
 return false;
 }

 int ret = config_save(config, CONFIG_FILE_PATH);
  pthread_mutex_unlock(&lock);
 return ret;
}

static bool parse_args(int argc, char **argv) {
 while (1) {
 int option_index = 0;
 int c = getopt_long_only(argc, argv, "", long_options, &option_index);
 if (c != 0)
 break;

 switch (c) {
 case 0:
 if (option_index == 0) {
 if (!string_to_bdaddr(optarg, &bt_remote_bdaddr)) {
 return false;
 }
 }
 if (option_index == 1) {
          discover = true;
 }
 if (option_index == 2) {
          discoverable = true;
 }
 if (option_index == 3) {
          timeout_in_sec = atoi(optarg);
 }
 if (option_index == 4) {
          bond  = true;
 }
 if (option_index == 5) {
          up = true;
 }
 if (option_index == 6) {
          f_verbose++;
 }
 if (option_index == 7) {
          get_name = true;
 }
 if (option_index == 8) {
          bd_name = (char *)optarg;
          set_name = true;
 }
 if (option_index == 9) {
          sco_listen = true;
 }
 if (option_index == 10) {
          sco_connect = true;
 }
 break;

 default:
        fprintf(stderr, "?? getopt returned character code 0%o ??\n", c);
 }
 }

 if (optind < argc) {
    fprintf(stderr, "non-option ARGV-elements: ");
 while (optind < argc)
      fprintf(stderr, "%s ", argv[optind++]);
    fprintf(stderr, "\n");
 return false;
 }
 return true;
}

bool adapter_enable_disable() {
int error;

  CALL_AND_WAIT(error = bt_interface->enable(), adapter_state_changed);
TASSERT(error == BT_STATUS_SUCCESS, "Error enabling Bluetooth: %d", error);
TASSERT(adapter_get_state() == BT_STATE_ON, "Adapter did not turn on.");

CALL_AND_WAIT(error = bt_interface->disable(), adapter_state_changed);
TASSERT(error == BT_STATUS_SUCCESS, "Error disabling Bluetooth: %d", error);
TASSERT(adapter_get_state() == BT_STATE_OFF, "Adapter did not turn off.");

return true;
}

static void discovery_state_changed_callback(bt_discovery_state_t state) {
    jbyteArray addr;
 if (!checkCallbackThread()) {
       ALOGE("Callback: '%s' is not called on the correct thread", __FUNCTION__);
 return;
 }

    ALOGV("%s: DiscoveryState:%d ", __FUNCTION__, state);

    callbackEnv->CallVoidMethod(sJniCallbacksObj, method_discoveryStateChangeCallback,
 (jint)state);

    checkAndClearExceptionFromCallback(callbackEnv, __FUNCTION__);
}

static void *watchdog_fn(void *arg) {
 int current_id = 0;
 for (;;) {
 for (int i = 0; watchdog_running && i < WATCHDOG_PERIOD_SEC; ++i) {
      sleep(1);
 }

 if (!watchdog_running)
 break;

 if (current_id == watchdog_id) {
      printf("Watchdog detected hanging test suite, aborting...\n");
      exit(-1);
 }
    current_id = watchdog_id;
 }
 return NULL;
}

static int acquire_wake_lock_callout(const char *lock_name) {
 JNIEnv *env;
 JavaVM *vm = AndroidRuntime::getJavaVM();
    jint status = vm->GetEnv((void **)&env, JNI_VERSION_1_6);
 if (status != JNI_OK && status != JNI_EDETACHED) {
        ALOGE("%s unable to get environment for JNI call", __func__);
 return BT_STATUS_FAIL;
 }
 if (status == JNI_EDETACHED && vm->AttachCurrentThread(&env, &sAttachArgs) != 0) {
        ALOGE("%s unable to attach thread to VM", __func__);
 return BT_STATUS_FAIL;
 }

    jboolean ret = JNI_FALSE;
    jstring lock_name_jni = env->NewStringUTF(lock_name);
 if (lock_name_jni) {
        ret = env->CallBooleanMethod(sJniAdapterServiceObj, method_acquireWakeLock, lock_name_jni);
        env->DeleteLocalRef(lock_name_jni);
 } else {
        ALOGE("%s unable to allocate string: %s", __func__, lock_name);
 }

 if (status == JNI_EDETACHED) {
        vm->DetachCurrentThread();
 }

 return ret ? BT_STATUS_SUCCESS : BT_STATUS_FAIL;
}

int HAL_unload(void)
{
 int err = 0;

    bdt_log("Unloading HAL lib");

    sBtInterface = NULL;

    bdt_log("HAL library unloaded (%s)", strerror(err));

 return err;
}

void checkAndClearExceptionFromCallback(JNIEnv* env,
 const char* methodName) {
 if (env->ExceptionCheck()) {
        ALOGE("An exception was thrown by callback '%s'.", methodName);
        LOGE_EX(env);
        env->ExceptionClear();
 }
}

static void alarmFiredNative(JNIEnv *env, jobject obj) {
 if (sAlarmCallback) {
        sAlarmCallback(sAlarmCallbackData);
 } else {
        ALOGE("%s() - Alarm fired with callback not set!", __FUNCTION__);
 }
}

jint JNI_OnLoad(JavaVM *jvm, void *reserved)
{
 JNIEnv *e;
 int status;

    ALOGV("Bluetooth Adapter Service : loading JNI\n");

 if (jvm->GetEnv((void **)&e, JNI_VERSION_1_6)) {
        ALOGE("JNI version mismatch error");
 return JNI_ERR;
 }

 if ((status = android::register_com_android_bluetooth_btservice_AdapterService(e)) < 0) {
        ALOGE("jni adapter service registration failure, status: %d", status);
 return JNI_ERR;
 }

 if ((status = android::register_com_android_bluetooth_hfp(e)) < 0) {
        ALOGE("jni hfp registration failure, status: %d", status);
 return JNI_ERR;
 }

 if ((status = android::register_com_android_bluetooth_hfpclient(e)) < 0) {
        ALOGE("jni hfp client registration failure, status: %d", status);
 return JNI_ERR;
 }

 if ((status = android::register_com_android_bluetooth_a2dp(e)) < 0) {
        ALOGE("jni a2dp source registration failure: %d", status);
 return JNI_ERR;
 }

 if ((status = android::register_com_android_bluetooth_a2dp_sink(e)) < 0) {
        ALOGE("jni a2dp sink registration failure: %d", status);
 return JNI_ERR;
 }

 if ((status = android::register_com_android_bluetooth_avrcp(e)) < 0) {
        ALOGE("jni avrcp target registration failure: %d", status);
 return JNI_ERR;
 }

 if ((status = android::register_com_android_bluetooth_avrcp_controller(e)) < 0) {
        ALOGE("jni avrcp controller registration failure: %d", status);
 return JNI_ERR;
 }

 if ((status = android::register_com_android_bluetooth_hid(e)) < 0) {
        ALOGE("jni hid registration failure: %d", status);
 return JNI_ERR;
 }

 if ((status = android::register_com_android_bluetooth_hdp(e)) < 0) {
        ALOGE("jni hdp registration failure: %d", status);
 return JNI_ERR;
 }

 if ((status = android::register_com_android_bluetooth_pan(e)) < 0) {
        ALOGE("jni pan registration failure: %d", status);
 return JNI_ERR;
 }

 if ((status = android::register_com_android_bluetooth_gatt(e)) < 0) {
        ALOGE("jni gatt registration failure: %d", status);
 return JNI_ERR;
 }

 if ((status = android::register_com_android_bluetooth_sdp(e)) < 0) {
        ALOGE("jni sdp registration failure: %d", status);
 return JNI_ERR;
 }

 return JNI_VERSION_1_6;
}

static void cmdjob_handler(void *param)
{
 char *job_cmd = (char*)param;

    bdt_log("cmdjob starting (%s)", job_cmd);

    process_cmd(job_cmd, 1);

    bdt_log("cmdjob terminating");

    free(job_cmd);
}

static int ssp_reply(const bt_bdaddr_t *bd_addr, bt_ssp_variant_t variant,
 uint8_t accept, uint32_t passkey)
{
 /* sanity check */
 if (interface_ready() == FALSE)
 return BT_STATUS_NOT_READY;

 return btif_dm_ssp_reply(bd_addr, variant, accept, passkey);
}

static int pin_reply(const bt_bdaddr_t *bd_addr, uint8_t accept,
 uint8_t pin_len, bt_pin_code_t *pin_code)
{
 /* sanity check */
 if (interface_ready() == FALSE)
 return BT_STATUS_NOT_READY;

 return btif_dm_pin_reply(bd_addr, accept, pin_len, pin_code);
}

static jboolean factoryResetNative(JNIEnv *env, jobject obj) {
    ALOGV("%s:", __FUNCTION__);
 if (!sBluetoothInterface) return JNI_FALSE;
 int ret = sBluetoothInterface->config_clear();
 return (ret == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;
}

void get_str(char **p, char *Buffer)
{
  skip_blanks(p);

 while (**p != 0 && **p != ' ')
 {
 *Buffer = **p;
 (*p)++;
 Buffer++;
 }

 *Buffer = 0;
}

static bt_status_t btif_in_fetch_bonded_devices(btif_bonded_devices_t *p_bonded_devices, int add)
{
    memset(p_bonded_devices, 0, sizeof(btif_bonded_devices_t));

    BOOLEAN bt_linkkey_file_found=FALSE;
 int device_type;

 for (const btif_config_section_iter_t *iter = btif_config_section_begin(); iter != btif_config_section_end(); iter = btif_config_section_next(iter)) {
 const char *name = btif_config_section_name(iter);
 if (!string_is_bdaddr(name))
 continue;

        BTIF_TRACE_DEBUG("Remote device:%s", name);
        LINK_KEY link_key;
 size_t size = sizeof(link_key);
 if(btif_config_get_bin(name, "LinkKey", link_key, &size))
 {
 int linkkey_type;
 if(btif_config_get_int(name, "LinkKeyType", &linkkey_type))
 {
 bt_bdaddr_t bd_addr;
                string_to_bdaddr(name, &bd_addr);
 if(add)
 {
                    DEV_CLASS dev_class = {0, 0, 0};
 int cod;
 int pin_length = 0;
 if(btif_config_get_int(name, "DevClass", &cod))
                        uint2devclass((UINT32)cod, dev_class);
                    btif_config_get_int(name, "PinLength", &pin_length);
                    BTA_DmAddDevice(bd_addr.address, dev_class, link_key, 0, 0,
 (UINT8)linkkey_type, 0, pin_length);

#if BLE_INCLUDED == TRUE
 if (btif_config_get_int(name, "DevType", &device_type) &&
 (device_type == BT_DEVICE_TYPE_DUMO) )
 {
                        btif_gatts_add_bonded_dev_from_nv(bd_addr.address);
 }
#endif
 }
                bt_linkkey_file_found = TRUE;
                memcpy(&p_bonded_devices->devices[p_bonded_devices->num_devices++], &bd_addr, sizeof(bt_bdaddr_t));
 }
 else
 {
#if (BLE_INCLUDED == TRUE)
                bt_linkkey_file_found = FALSE;
#else
                BTIF_TRACE_ERROR("bounded device:%s, LinkKeyType or PinLength is invalid", name);
#endif
 }
 }
#if (BLE_INCLUDED == TRUE)
 if(!(btif_in_fetch_bonded_ble_device(name, add, p_bonded_devices)) && (!bt_linkkey_file_found))
 {
                BTIF_TRACE_DEBUG("Remote device:%s, no link key or ble key found", name);
 }
#else
 if(!bt_linkkey_file_found)
                BTIF_TRACE_DEBUG("Remote device:%s, no link key", name);
#endif
 }
 return BT_STATUS_SUCCESS;
}

static future_t *shut_down(void) {
  btif_config_flush();
 return future_new_immediate(FUTURE_SUCCESS);
}

static void adapter_state_changed(bt_state_t state)
{
    bdt_log("ADAPTER STATE UPDATED : %s", (state == BT_STATE_OFF)?"OFF":"ON");
 if (state == BT_STATE_ON) {
        bt_enabled = 1;
 } else {
        bt_enabled = 0;
 }
}

static bool cleanupNative(JNIEnv *env, jobject obj) {
    ALOGV("%s:",__FUNCTION__);

    jboolean result = JNI_FALSE;
 if (!sBluetoothInterface) return result;

    sBluetoothInterface->cleanup();
    ALOGI("%s: return from cleanup",__FUNCTION__);

    env->DeleteGlobalRef(sJniCallbacksObj);
    env->DeleteGlobalRef(sJniAdapterServiceObj);

     return JNI_TRUE;
 }

int set_remote_device_property(bt_bdaddr_t *remote_addr, const bt_property_t *property)
{
 /* sanity check */
 if (interface_ready() == FALSE)
 return BT_STATUS_NOT_READY;

 return btif_set_remote_device_property(remote_addr, property);
}

bool btif_get_address_type(const BD_ADDR bd_addr, int *p_addr_type)
{
 if (p_addr_type == NULL)
 return FALSE;

 bt_bdaddr_t bda;
    bdcpy(bda.address, bd_addr);

 bdstr_t bd_addr_str;
    bdaddr_to_string(&bda, bd_addr_str, sizeof(bd_addr_str));

 if (!btif_config_get_int(bd_addr_str, "AddrType", p_addr_type))
 return FALSE;

    LOG_DEBUG("%s: Device [%s] address type %d", __FUNCTION__, bd_addr_str, *p_addr_type);
 return TRUE;
}

bt_status_t btif_storage_get_ble_local_key(UINT8 key_type,
 char *key_value,
 int key_length)
{
 const char* name;
 switch(key_type)
 {
 case BTIF_DM_LE_LOCAL_KEY_IR:
            name = "LE_LOCAL_KEY_IR";
 break;
 case BTIF_DM_LE_LOCAL_KEY_IRK:
            name = "LE_LOCAL_KEY_IRK";
 break;
 case BTIF_DM_LE_LOCAL_KEY_DHK:
            name = "LE_LOCAL_KEY_DHK";
 break;
 case BTIF_DM_LE_LOCAL_KEY_ER:
            name = "LE_LOCAL_KEY_ER";
 break;
 default:
 return BT_STATUS_FAIL;
 }
 size_t length = key_length;
 int ret = btif_config_get_bin("Adapter", name, (uint8_t *)key_value, &length);
 return ret ? BT_STATUS_SUCCESS : BT_STATUS_FAIL;
}

bt_status_t btif_storage_set_adapter_property(bt_property_t *property)
{
 return prop2cfg(NULL, property) ? BT_STATUS_SUCCESS : BT_STATUS_FAIL;
}

void btif_config_flush(void) {
  assert(config != NULL);
  assert(alarm_timer != NULL);

  alarm_cancel(alarm_timer);
  btif_config_write();
}

bool btif_get_device_type(const BD_ADDR bd_addr, int *p_device_type)
{
 if (p_device_type == NULL)
 return FALSE;

 bt_bdaddr_t bda;
    bdcpy(bda.address, bd_addr);

 bdstr_t bd_addr_str;
    bdaddr_to_string(&bda, bd_addr_str, sizeof(bd_addr_str));

 if (!btif_config_get_int(bd_addr_str, "DevType", p_device_type))
 return FALSE;

    LOG_DEBUG("%s: Device [%s] type %d", __FUNCTION__, bd_addr_str, *p_device_type);
 return TRUE;
}

int register_com_android_bluetooth_btservice_AdapterService(JNIEnv* env)
{
 return jniRegisterNativeMethods(env, "com/android/bluetooth/btservice/AdapterService",
                                    sMethods, NELEM(sMethods));
}

bt_status_t btif_storage_remove_ble_bonding_keys(bt_bdaddr_t *remote_bd_addr)
{
 bdstr_t bdstr;
    bdaddr_to_string(remote_bd_addr, bdstr, sizeof(bdstr));
    BTIF_TRACE_DEBUG(" %s in bd addr:%s",__FUNCTION__, bdstr);
 int ret = 1;
 if(btif_config_exist(bdstr, "LE_KEY_PENC"))
        ret &= btif_config_remove(bdstr, "LE_KEY_PENC");
 if(btif_config_exist(bdstr, "LE_KEY_PID"))
        ret &= btif_config_remove(bdstr, "LE_KEY_PID");
 if(btif_config_exist(bdstr, "LE_KEY_PCSRK"))
        ret &= btif_config_remove(bdstr, "LE_KEY_PCSRK");
 if(btif_config_exist(bdstr, "LE_KEY_LENC"))
        ret &= btif_config_remove(bdstr, "LE_KEY_LENC");
 if(btif_config_exist(bdstr, "LE_KEY_LCSRK"))
        ret &= btif_config_remove(bdstr, "LE_KEY_LCSRK");
    btif_config_save();
 return ret ? BT_STATUS_SUCCESS : BT_STATUS_FAIL;
}

bt_status_t btif_storage_load_autopair_device_list() {
 if (btif_config_has_section(BTIF_STORAGE_PATH_AUTOPAIR_BLACKLIST)) {
 return BT_STATUS_SUCCESS;
 }

 static const char *key_names[] = {
        BTIF_STORAGE_KEY_AUTOPAIR_BLACKLIST_ADDR,
        BTIF_STORAGE_KEY_AUTOPAIR_BLACKLIST_EXACTNAME,
        BTIF_STORAGE_KEY_AUTOPAIR_FIXPIN_KBLIST,
        BTIF_STORAGE_KEY_AUTOPAIR_BLACKLIST_PARTIALNAME,
        BTIF_STORAGE_KEY_AUTOPAIR_DYNAMIC_BLACKLIST_ADDR,
 };

 config_t *config = config_new(BTIF_AUTO_PAIR_CONF_FILE);
 if (!config) {
        LOG_ERROR("%s failed to open auto pair blacklist conf file '%s'.", __func__, BTIF_AUTO_PAIR_CONF_FILE);
 return BT_STATUS_FAIL;
 }

 for (size_t i = 0; i < ARRAY_SIZE(key_names); ++i) {
 const char *value = config_get_string(config, CONFIG_DEFAULT_SECTION, key_names[i], NULL);
 if (value) {
            btif_config_set_str(BTIF_STORAGE_PATH_AUTOPAIR_BLACKLIST, key_names[i], value);
 }
 }

    config_free(config);
 return BT_STATUS_SUCCESS;
}

static future_t *init(void) {
  pthread_mutex_init(&lock, NULL);
  config = config_new(CONFIG_FILE_PATH);
 if (!config) {
    LOG_WARN("%s unable to load config file; attempting to transcode legacy file.", __func__);
    config = btif_config_transcode(LEGACY_CONFIG_FILE_PATH);
 if (!config) {
      LOG_WARN("%s unable to transcode legacy file, starting unconfigured.", __func__);
      config = config_new_empty();
 if (!config) {
        LOG_ERROR("%s unable to allocate a config object.", __func__);
 goto error;
 }
 }

 if (config_save(config, CONFIG_FILE_PATH))
      unlink(LEGACY_CONFIG_FILE_PATH);
 }

 
   btif_config_remove_unpaired(config);
 
  alarm_timer = alarm_new();
 if (!alarm_timer) {
    LOG_ERROR("%s unable to create alarm.", __func__);
 goto error;
 }

 return future_new_immediate(FUTURE_SUCCESS);

error:;
  alarm_free(alarm_timer);
  config_free(config);
  pthread_mutex_destroy(&lock);
  alarm_timer = NULL;
  config = NULL;
 return future_new_immediate(FUTURE_FAIL);
}

static int get_connection_state(const bt_bdaddr_t *bd_addr)
{
 /* sanity check */
 if (interface_ready() == FALSE)
 return 0;

 return btif_dm_get_connection_state(bd_addr);
}

int dut_mode_configure(uint8_t enable)
{
    LOG_INFO("dut_mode_configure");

 /* sanity check */
 if (interface_ready() == FALSE)
 return BT_STATUS_NOT_READY;

 return btif_dut_mode_configure(enable);
}

bt_status_t btif_storage_get_remote_device_property(bt_bdaddr_t *remote_bd_addr,
 bt_property_t *property)
{
 return cfg2prop(remote_bd_addr, property) ? BT_STATUS_SUCCESS : BT_STATUS_FAIL;
}

bt_status_t btif_storage_remove_ble_local_keys(void)
{
 int ret = 1;
 if(btif_config_exist("Adapter", "LE_LOCAL_KEY_IR"))
        ret &= btif_config_remove("Adapter", "LE_LOCAL_KEY_IR");
 if(btif_config_exist("Adapter", "LE_LOCAL_KEY_IRK"))
        ret &= btif_config_remove("Adapter", "LE_LOCAL_KEY_IRK");
 if(btif_config_exist("Adapter", "LE_LOCAL_KEY_DHK"))
        ret &= btif_config_remove("Adapter", "LE_LOCAL_KEY_DHK");
 if(btif_config_exist("Adapter", "LE_LOCAL_KEY_ER"))
        ret &= btif_config_remove("Adapter", "LE_LOCAL_KEY_ER");
    btif_config_save();
 return ret ? BT_STATUS_SUCCESS : BT_STATUS_FAIL;
}

bool adapter_start_discovery() {
 int error;

  CALL_AND_WAIT(error = bt_interface->start_discovery(), discovery_state_changed);
  TASSERT(error == BT_STATUS_SUCCESS, "Error calling start_discovery: %d", error);
  TASSERT(adapter_get_discovery_state() == BT_DISCOVERY_STARTED, "Unable to start discovery.");

 return true;
}

size_t btif_config_get_bin_length(const char *section, const char *key) {
  assert(config != NULL);
  assert(section != NULL);
  assert(key != NULL);

  pthread_mutex_lock(&lock);
 const char *value_str = config_get_string(config, section, key, NULL);
  pthread_mutex_unlock(&lock);

 if (!value_str)
 return 0;

 size_t value_len = strlen(value_str);
 return ((value_len % 2) != 0) ? 0 : (value_len / 2);
}

void skip_blanks(char **p)
{
 while (**p == ' ')
 (*p)++;
}

static int enable(void) {
  LOG_INFO("%s", __func__);

if (!interface_ready())
return BT_STATUS_NOT_READY;

stack_manager_get_interface()->start_up_stack_async();
return BT_STATUS_SUCCESS;
}

uint32_t get_int(char **p, int DefaultValue)
{
 uint32_t Value = 0;
 unsigned char UseDefault;

 UseDefault = 1;
  skip_blanks(p);

 while ( ((**p)<= '9' && (**p)>= '0') )
 {
 Value = Value * 10 + (**p) - '0';
 UseDefault = 0;
 (*p)++;
 }

 if (UseDefault)
 return DefaultValue;
 else
 return Value;
}

static jboolean getAdapterPropertiesNative(JNIEnv *env, jobject obj) {
    ALOGV("%s:",__FUNCTION__);

    jboolean result = JNI_FALSE;
 if (!sBluetoothInterface) return result;

 int ret = sBluetoothInterface->get_adapter_properties();
    result = (ret == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;

 return result;
}

bool adapter_repeated_enable_disable() {
 for (int i = 0; i < 10; ++i) {
 if (!adapter_enable_disable()) {
 return false;
 }
 }
 return true;
}

static int config_clear(void) {
    LOG_INFO("%s", __func__);
 return btif_config_clear();
}

bool btif_config_set_int(const char *section, const char *key, int value) {
  assert(config != NULL);
  assert(section != NULL);
  assert(key != NULL);

  pthread_mutex_lock(&lock);
  config_set_int(config, section, key, value);
  pthread_mutex_unlock(&lock);

 return true;
}

bool adapter_get_name() {
 int error;
 bt_property_t *name = property_new_name("get_name");

  CALL_AND_WAIT(bt_interface->set_adapter_property(name), adapter_properties);
  CALL_AND_WAIT(error = bt_interface->get_adapter_property(BT_PROPERTY_BDNAME), adapter_properties);
  TASSERT(error == BT_STATUS_SUCCESS, "Error getting device name.");
  TASSERT(adapter_get_property_count() == 1, "Expected 1 adapter property change, found %d instead.", adapter_get_property_count());
  TASSERT(adapter_get_property(BT_PROPERTY_BDNAME), "The Bluetooth name property did not change.");
  TASSERT(property_equals(adapter_get_property(BT_PROPERTY_BDNAME), name), "Bluetooth name '%s' does not match test value", property_as_name(adapter_get_property(BT_PROPERTY_BDNAME))->name);

  property_free(name);
 return true;
}

uint32_t get_hex(char **p, int DefaultValue)
{
 uint32_t Value = 0;
 unsigned char UseDefault;

 UseDefault = 1;
  skip_blanks(p);

 while ( ((**p)<= '9' && (**p)>= '0') ||
 ((**p)<= 'f' && (**p)>= 'a') ||
 ((**p)<= 'F' && (**p)>= 'A') )
 {
 if (**p >= 'a')
 Value = Value * 16 + (**p) - 'a' + 10;
 else if (**p >= 'A')
 Value = Value * 16 + (**p) - 'A' + 10;
 else
 Value = Value * 16 + (**p) - '0';
 UseDefault = 0;
 (*p)++;
 }

 if (UseDefault)
 return DefaultValue;
 else
 return Value;
}

int config_hci_snoop_log(uint8_t enable)
{
    LOG_INFO("config_hci_snoop_log");

 if (!interface_ready())
 return BT_STATUS_NOT_READY;

    btsnoop_get_interface()->set_api_wants_to_log(enable);
 return BT_STATUS_SUCCESS;
}

static void le_test_mode(bt_status_t status, uint16_t packet_count)
{
    bdt_log("LE TEST MODE END status:%s number_of_packets:%d", dump_bt_status(status), packet_count);
}

static jboolean removeBondNative(JNIEnv* env, jobject obj, jbyteArray address) {
    ALOGV("%s:",__FUNCTION__);

    jbyte *addr;
    jboolean result;
 if (!sBluetoothInterface) return JNI_FALSE;

    addr = env->GetByteArrayElements(address, NULL);
 if (addr == NULL) {
        jniThrowIOException(env, EINVAL);
 return JNI_FALSE;
 }

 int ret = sBluetoothInterface->remove_bond((bt_bdaddr_t *)addr);
    env->ReleaseByteArrayElements(address, addr, 0);
    result = (ret == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;

 return result;
}

void bdt_disable(void)
{
    bdt_log("DISABLE BT");
 if (!bt_enabled) {
        bdt_log("Bluetooth is already disabled");
 return;
 }
    status = sBtInterface->disable();

    check_return_status(status);
}

static bool set_wake_alarm_callout(uint64_t delay_millis, bool should_wake,
        alarm_cb cb, void *data) {
 JNIEnv *env;
 JavaVM *vm = AndroidRuntime::getJavaVM();
    jint status = vm->GetEnv((void **)&env, JNI_VERSION_1_6);

 if (status != JNI_OK && status != JNI_EDETACHED) {
        ALOGE("%s unable to get environment for JNI call", __func__);
 return false;
 }

 if (status == JNI_EDETACHED && vm->AttachCurrentThread(&env, &sAttachArgs) != 0) {
        ALOGE("%s unable to attach thread to VM", __func__);
 return false;
 }

    sAlarmCallback = cb;
    sAlarmCallbackData = data;

    jboolean jshould_wake = should_wake ? JNI_TRUE : JNI_FALSE;
    jboolean ret = env->CallBooleanMethod(sJniAdapterServiceObj, method_setWakeAlarm,
 (jlong)delay_millis, jshould_wake);
 if (!ret) {
        sAlarmCallback = NULL;
        sAlarmCallbackData = NULL;
 }

 if (status == JNI_EDETACHED) {
        vm->DetachCurrentThread();
 }

 return !!ret;
}

static bool set_wake_alarm(uint64_t delay_millis, bool should_wake, alarm_cb cb, void *data) {
 static timer_t timer;
 static bool timer_created;

 if (!timer_created) {
 struct sigevent sigevent;
    memset(&sigevent, 0, sizeof(sigevent));
    sigevent.sigev_notify = SIGEV_THREAD;
    sigevent.sigev_notify_function = (void (*)(union sigval))cb;
    sigevent.sigev_value.sival_ptr = data;
    timer_create(CLOCK_MONOTONIC, &sigevent, &timer);
    timer_created = true;
 }

 struct itimerspec new_value;
  new_value.it_value.tv_sec = delay_millis / 1000;
  new_value.it_value.tv_nsec = (delay_millis % 1000) * 1000 * 1000;
  new_value.it_interval.tv_sec = 0;
  new_value.it_interval.tv_nsec = 0;
  timer_settime(timer, 0, &new_value, NULL);

 return true;
}

static int create_bond(const bt_bdaddr_t *bd_addr, int transport)
{
 /* sanity check */
 if (interface_ready() == FALSE)
 return BT_STATUS_NOT_READY;

 return btif_dm_create_bond(bd_addr, transport);
}

int get_remote_device_properties(bt_bdaddr_t *remote_addr)
{
 /* sanity check */
 if (interface_ready() == FALSE)
 return BT_STATUS_NOT_READY;

 return btif_get_remote_device_properties(remote_addr);
}

bool btif_config_get_str(const char *section, const char *key, char *value, int *size_bytes) {
  assert(config != NULL);
  assert(section != NULL);
  assert(key != NULL);
  assert(value != NULL);
  assert(size_bytes != NULL);

  pthread_mutex_lock(&lock);
 const char *stored_value = config_get_string(config, section, key, NULL);
  pthread_mutex_unlock(&lock);

 if (!stored_value)
 return false;

  strlcpy(value, stored_value, *size_bytes);
 *size_bytes = strlen(value) + 1;

 return true;
}

void do_dut_mode_configure(char *p)
{
    bdt_dut_mode_configure(p);
}

void do_quit(char UNUSED *p)
{
    bdt_shutdown();
}

static void btif_config_remove_unpaired(config_t *conf) {
  assert(conf != NULL);

 const config_section_node_t *snode = config_section_begin(conf);
 while (snode != config_section_end(conf)) {
 const char *section = config_section_name(snode);
 if (string_is_bdaddr(section)) {
 if (!config_has_key(conf, section, "LinkKey") &&
 !config_has_key(conf, section, "LE_KEY_PENC") &&
 !config_has_key(conf, section, "LE_KEY_PID") &&
 !config_has_key(conf, section, "LE_KEY_PCSRK") &&
 !config_has_key(conf, section, "LE_KEY_LENC") &&
 !config_has_key(conf, section, "LE_KEY_LCSRK")) {
        snode = config_section_next(snode);
        config_remove_section(conf, section);
 continue;
 }
 }

     snode = config_section_next(snode);
   }
 }

static jboolean sspReplyNative(JNIEnv *env, jobject obj, jbyteArray address,
                               jint type, jboolean accept, jint passkey) {
    ALOGV("%s:",__FUNCTION__);

    jbyte *addr;
    jboolean result = JNI_FALSE;
 if (!sBluetoothInterface) return result;

    addr = env->GetByteArrayElements(address, NULL);
 if (addr == NULL) {
        jniThrowIOException(env, EINVAL);
 return result;
 }

 int ret = sBluetoothInterface->ssp_reply((bt_bdaddr_t *)addr,
 (bt_ssp_variant_t) type, accept, passkey);
    env->ReleaseByteArrayElements(address, addr, 0);
    result = (ret == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;

 return result;
}

void check_return_status(bt_status_t status)
{
 if (status != BT_STATUS_SUCCESS)
 {
        bdt_log("HAL REQUEST FAILED status : %d (%s)", status, dump_bt_status(status));
 }
 else
 {
        bdt_log("HAL REQUEST SUCCESS");
 }
}

void bdt_log(const char *fmt_str, ...)
{
 static char buffer[1024];
    va_list ap;

    va_start(ap, fmt_str);
    vsnprintf(buffer, 1024, fmt_str, ap);
    va_end(ap);

    fprintf(stdout, "%s\n", buffer);
}

static int release_wake_lock(const char *lock_name) {
 return BT_STATUS_SUCCESS;
}

int get_remote_service_record(bt_bdaddr_t *remote_addr, bt_uuid_t *uuid)
{
 /* sanity check */
 if (interface_ready() == FALSE)
 return BT_STATUS_NOT_READY;

 return btif_get_remote_service_record(remote_addr, uuid);
}

static int get_adapter_property(bt_property_type_t type)
{
 /* sanity check */
 if (interface_ready() == FALSE)
 return BT_STATUS_NOT_READY;

 return btif_get_adapter_property(type);
}

bool btif_config_remove(const char *section, const char *key) {
  assert(config != NULL);
  assert(section != NULL);
  assert(key != NULL);

  pthread_mutex_lock(&lock);
 bool ret = config_remove_key(config, section, key);
  pthread_mutex_unlock(&lock);

 return ret;
}

int get_signed_int(char **p, int DefaultValue)
{
 int Value = 0;
 unsigned char UseDefault;
 unsigned char NegativeNum = 0;

 UseDefault = 1;
  skip_blanks(p);

 if ( (**p) == '-')
 {
 NegativeNum = 1;
 (*p)++;
 }
 while ( ((**p)<= '9' && (**p)>= '0') )
 {
 Value = Value * 10 + (**p) - '0';
 UseDefault = 0;
 (*p)++;
 }

 if (UseDefault)
 return DefaultValue;
 else
 return ((NegativeNum == 0)? Value : -Value);
}

static jboolean startDiscoveryNative(JNIEnv* env, jobject obj) {
    ALOGV("%s:",__FUNCTION__);

    jboolean result = JNI_FALSE;
 if (!sBluetoothInterface) return result;

 int ret = sBluetoothInterface->start_discovery();
    result = (ret == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;
 return result;
}

static future_t *clean_up(void) {
  btif_config_flush();

  alarm_free(alarm_timer);
  config_free(config);
  pthread_mutex_destroy(&lock);
  alarm_timer = NULL;
  config = NULL;
 return future_new_immediate(FUTURE_SUCCESS);
}

bt_status_t btif_storage_add_ble_bonding_key(bt_bdaddr_t *remote_bd_addr,
 char *key,
                                           UINT8 key_type,
                                           UINT8 key_length)
{
 bdstr_t bdstr;
    bdaddr_to_string(remote_bd_addr, bdstr, sizeof(bdstr));
 const char* name;
 switch(key_type)
 {
 case BTIF_DM_LE_KEY_PENC:
            name = "LE_KEY_PENC";
 break;
 case BTIF_DM_LE_KEY_PID:
            name = "LE_KEY_PID";
 break;
 case BTIF_DM_LE_KEY_PCSRK:
            name = "LE_KEY_PCSRK";
 break;
 case BTIF_DM_LE_KEY_LENC:
            name = "LE_KEY_LENC";
 break;
 case BTIF_DM_LE_KEY_LCSRK:
            name = "LE_KEY_LCSRK";
 break;
 case BTIF_DM_LE_KEY_LID:
            name = "LE_KEY_LID";
 break;
 default:
 return BT_STATUS_FAIL;
 }
 int ret = btif_config_set_bin(bdstr, name, (const uint8_t *)key, key_length);
    btif_config_save();
 return ret ? BT_STATUS_SUCCESS : BT_STATUS_FAIL;
}

static bt_status_t btif_in_fetch_bonded_device(const char *bdstr)
{
    BOOLEAN bt_linkkey_file_found=FALSE;

        LINK_KEY link_key;
 size_t size = sizeof(link_key);
 if(btif_config_get_bin(bdstr, "LinkKey", (uint8_t *)link_key, &size))
 {
 int linkkey_type;
 if(btif_config_get_int(bdstr, "LinkKeyType", &linkkey_type))
 {
                bt_linkkey_file_found = TRUE;
 }
 else
 {
                bt_linkkey_file_found = FALSE;
 }
 }
#if (BLE_INCLUDED == TRUE)
 if((btif_in_fetch_bonded_ble_device(bdstr, FALSE, NULL) != BT_STATUS_SUCCESS)
 && (!bt_linkkey_file_found))
 {
            BTIF_TRACE_DEBUG("Remote device:%s, no link key or ble key found", bdstr);
 return BT_STATUS_FAIL;
 }
#else
 if((!bt_linkkey_file_found))
 {
            BTIF_TRACE_DEBUG("Remote device:%s, no link key found", bdstr);
 return BT_STATUS_FAIL;
 }
#endif
 return BT_STATUS_SUCCESS;
}

static jboolean cancelBondNative(JNIEnv* env, jobject obj, jbyteArray address) {
    ALOGV("%s:",__FUNCTION__);

    jbyte *addr;
    jboolean result;
 if (!sBluetoothInterface) return JNI_FALSE;

    addr = env->GetByteArrayElements(address, NULL);
 if (addr == NULL) {
        jniThrowIOException(env, EINVAL);
 return JNI_FALSE;
 }

 int ret = sBluetoothInterface->cancel_bond((bt_bdaddr_t *)addr);
    env->ReleaseByteArrayElements(address, addr, 0);
    result = (ret == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;

 return result;
}

bt_status_t btif_storage_add_remote_device(bt_bdaddr_t *remote_bd_addr,
 uint32_t num_properties,
 bt_property_t *properties)
{
 uint32_t i = 0;
 /* TODO: If writing a property, fails do we go back undo the earlier
     * written properties? */
 for (i=0; i < num_properties; i++)
 {
 /* Ignore the RSSI as this is not stored in DB */
 if (properties[i].type == BT_PROPERTY_REMOTE_RSSI)
 continue;

 /* BD_ADDR for remote device needs special handling as we also store timestamp */
 if (properties[i].type == BT_PROPERTY_BDADDR)
 {
 bt_property_t addr_prop;
            memcpy(&addr_prop, &properties[i], sizeof(bt_property_t));
            addr_prop.type = BT_PROPERTY_REMOTE_DEVICE_TIMESTAMP;
            btif_storage_set_remote_device_property(remote_bd_addr,
 &addr_prop);
 }
 else
 {
            btif_storage_set_remote_device_property(remote_bd_addr,
 &properties[i]);
 }
 }
 return BT_STATUS_SUCCESS;
}

static void interopDatabaseClearNative(JNIEnv *env, jobject obj) {
    ALOGV("%s()", __FUNCTION__);
 if (!sBluetoothInterface) return;
    sBluetoothInterface->interop_database_clear();
}

static void bdt_shutdown(void)
{
    bdt_log("shutdown bdroid test app\n");
    main_done = 1;
}

bt_status_t btif_storage_remove_bonded_device(bt_bdaddr_t *remote_bd_addr)
{
 bdstr_t bdstr;
    bdaddr_to_string(remote_bd_addr, bdstr, sizeof(bdstr));
    BTIF_TRACE_DEBUG("in bd addr:%s", bdstr);

#if (defined(BLE_INCLUDED) && (BLE_INCLUDED == TRUE))
    btif_storage_remove_ble_bonding_keys(remote_bd_addr);
#endif

 int ret = 1;
 if(btif_config_exist(bdstr, "LinkKeyType"))
        ret &= btif_config_remove(bdstr, "LinkKeyType");
 if(btif_config_exist(bdstr, "PinLength"))
        ret &= btif_config_remove(bdstr, "PinLength");
 if(btif_config_exist(bdstr, "LinkKey"))
        ret &= btif_config_remove(bdstr, "LinkKey");
 /* write bonded info immediately */
    btif_config_flush();
 return ret ? BT_STATUS_SUCCESS : BT_STATUS_FAIL;

}

void bdt_init(void)
{
    bdt_log("INIT BT ");
    status = sBtInterface->init(&bt_callbacks);

 if (status == BT_STATUS_SUCCESS) {
        status = sBtInterface->set_os_callouts(&callouts);
 }

    check_return_status(status);
}

void do_le_test_mode(char *p)
{
    bdt_le_test_mode(p);
}

static void adapter_state_change_callback(bt_state_t status) {
 if (!checkCallbackThread()) {
       ALOGE("Callback: '%s' is not called on the correct thread", __FUNCTION__);
 return;
 }
    ALOGV("%s: Status is: %d", __FUNCTION__, status);

    callbackEnv->CallVoidMethod(sJniCallbacksObj, method_stateChangeCallback, (jint)status);

    checkAndClearExceptionFromCallback(callbackEnv, __FUNCTION__);
}

static void btif_in_split_uuids_string_to_list(char *str, bt_uuid_t *p_uuid,
 uint32_t *p_num_uuid)
{
 char buf[64];
 char *p_start = str;
 char *p_needle;
 uint32_t num = 0;
 do
 {
        p_needle = strchr(p_start, ' ');
 if (p_needle < p_start) break;
        memset(buf, 0, sizeof(buf));
        strncpy(buf, p_start, (p_needle-p_start));
        string_to_uuid(buf, p_uuid + num);
        num++;
        p_start = ++p_needle;

 } while (*p_start != 0);
 *p_num_uuid = num;
}

static jboolean configHciSnoopLogNative(JNIEnv* env, jobject obj, jboolean enable) {
    ALOGV("%s:",__FUNCTION__);

    jboolean result = JNI_FALSE;

 if (!sBluetoothInterface) return result;

 int ret = sBluetoothInterface->config_hci_snoop_log(enable);

    result = (ret == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;

 return result;
}

static void sig_handler(int signo) {
 if (signo == SIGINT) {
    fprintf(stderr, "Received SIGINT\n");
    CALL_AND_WAIT(bt_interface->disable(), adapter_state_changed);
    fprintf(stderr, "BT adapter is down\n");
    exit(1);
 }
}

bt_status_t btif_storage_set_remote_device_property(bt_bdaddr_t *remote_bd_addr,
 bt_property_t *property)
{
 return prop2cfg(remote_bd_addr, property) ? BT_STATUS_SUCCESS : BT_STATUS_FAIL;
}

 static int get_adapter_properties(void)
 {
     /* sanity check */
 if (interface_ready() == FALSE)
 return BT_STATUS_NOT_READY;

 return btif_get_adapter_properties();
}

bt_status_t btif_storage_remove_hid_info(bt_bdaddr_t *remote_bd_addr)
{
 bdstr_t bdstr;
    bdaddr_to_string(remote_bd_addr, bdstr, sizeof(bdstr));

    btif_config_remove(bdstr, "HidAttrMask");
    btif_config_remove(bdstr, "HidSubClass");
    btif_config_remove(bdstr, "HidAppId");
    btif_config_remove(bdstr, "HidVendorId");
    btif_config_remove(bdstr, "HidProductId");
    btif_config_remove(bdstr, "HidVersion");
    btif_config_remove(bdstr, "HidCountryCode");
    btif_config_remove(bdstr, "HidSSRMaxLatency");
    btif_config_remove(bdstr, "HidSSRMinTimeout");
    btif_config_remove(bdstr, "HidDescriptor");
    btif_config_save();
 return BT_STATUS_SUCCESS;
}

bool btif_config_set_bin(const char *section, const char *key, const uint8_t *value, size_t length) {
 const char *lookup = "0123456789abcdef";

  assert(config != NULL);
  assert(section != NULL);
  assert(key != NULL);

 if (length > 0)
      assert(value != NULL);

 char *str = (char *)osi_calloc(length * 2 + 1);
 if (!str)
 return false;

 for (size_t i = 0; i < length; ++i) {
    str[(i * 2) + 0] = lookup[(value[i] >> 4) & 0x0F];
    str[(i * 2) + 1] = lookup[value[i] & 0x0F];
 }

  pthread_mutex_lock(&lock);
  config_set_string(config, section, key, str);
  pthread_mutex_unlock(&lock);

  osi_free(str);
 return true;
}

void setup_test_env(void)
{
 int i = 0;

 while (console_cmd_list[i].name != NULL)
 {
        console_cmd_maxlen = MAX(console_cmd_maxlen, (int)strlen(console_cmd_list[i].name));
        i++;
 }
}

static void dump(int fd)
{
    btif_debug_dump(fd);
}

static bool is_shell_running(void) {
 char property_str[100];
  property_get("init.svc.zygote", property_str, NULL);
 if (!strcmp("running", property_str)) {
 return true;
 }
 return false;
}

bt_status_t btif_storage_load_bonded_devices(void)
{
 btif_bonded_devices_t bonded_devices;
 uint32_t i = 0;
 bt_property_t adapter_props[6];
 uint32_t num_props = 0;
 bt_property_t remote_properties[8];
 bt_bdaddr_t addr;
 bt_bdname_t name, alias;
 bt_scan_mode_t mode;
 uint32_t disc_timeout;
 bt_bdaddr_t *devices_list;
 bt_uuid_t local_uuids[BT_MAX_NUM_UUIDS];
 bt_uuid_t remote_uuids[BT_MAX_NUM_UUIDS];
 uint32_t cod, devtype;

    btif_in_fetch_bonded_devices(&bonded_devices, 1);

 /* Now send the adapter_properties_cb with all adapter_properties */
 {
        memset(adapter_props, 0, sizeof(adapter_props));

 /* BD_ADDR */
        BTIF_STORAGE_GET_ADAPTER_PROP(BT_PROPERTY_BDADDR, &addr, sizeof(addr),
                                      adapter_props[num_props]);
        num_props++;

 /* BD_NAME */
        BTIF_STORAGE_GET_ADAPTER_PROP(BT_PROPERTY_BDNAME, &name, sizeof(name),
                                      adapter_props[num_props]);
        num_props++;

 /* SCAN_MODE */
 /* TODO: At the time of BT on, always report the scan mode as 0 irrespective
         of the scan_mode during the previous enable cycle.
         This needs to be re-visited as part of the app/stack enable sequence
         synchronization */
        mode = BT_SCAN_MODE_NONE;
        adapter_props[num_props].type = BT_PROPERTY_ADAPTER_SCAN_MODE;
        adapter_props[num_props].len = sizeof(mode);
        adapter_props[num_props].val = &mode;
        num_props++;

 /* DISC_TIMEOUT */
        BTIF_STORAGE_GET_ADAPTER_PROP(BT_PROPERTY_ADAPTER_DISCOVERY_TIMEOUT,
 &disc_timeout, sizeof(disc_timeout),
                                      adapter_props[num_props]);
        num_props++;

 /* BONDED_DEVICES */
        devices_list = (bt_bdaddr_t*)osi_malloc(sizeof(bt_bdaddr_t)*bonded_devices.num_devices);
        adapter_props[num_props].type = BT_PROPERTY_ADAPTER_BONDED_DEVICES;
        adapter_props[num_props].len = bonded_devices.num_devices * sizeof(bt_bdaddr_t);
        adapter_props[num_props].val = devices_list;
 for (i=0; i < bonded_devices.num_devices; i++)
 {
            memcpy(devices_list + i, &bonded_devices.devices[i], sizeof(bt_bdaddr_t));
 }
        num_props++;

 /* LOCAL UUIDs */
        BTIF_STORAGE_GET_ADAPTER_PROP(BT_PROPERTY_UUIDS,
                                      local_uuids, sizeof(local_uuids),
                                      adapter_props[num_props]);
        num_props++;

        btif_adapter_properties_evt(BT_STATUS_SUCCESS, num_props, adapter_props);

        osi_free(devices_list);
 }

    BTIF_TRACE_EVENT("%s: %d bonded devices found", __FUNCTION__, bonded_devices.num_devices);

 {
 for (i = 0; i < bonded_devices.num_devices; i++)
 {
 bt_bdaddr_t *p_remote_addr;

            num_props = 0;
            p_remote_addr = &bonded_devices.devices[i];
            memset(remote_properties, 0, sizeof(remote_properties));
            BTIF_STORAGE_GET_REMOTE_PROP(p_remote_addr, BT_PROPERTY_BDNAME,
 &name, sizeof(name),
                                         remote_properties[num_props]);
            num_props++;

            BTIF_STORAGE_GET_REMOTE_PROP(p_remote_addr, BT_PROPERTY_REMOTE_FRIENDLY_NAME,
 &alias, sizeof(alias),
                                         remote_properties[num_props]);
            num_props++;

            BTIF_STORAGE_GET_REMOTE_PROP(p_remote_addr, BT_PROPERTY_CLASS_OF_DEVICE,
 &cod, sizeof(cod),
                                         remote_properties[num_props]);
            num_props++;

            BTIF_STORAGE_GET_REMOTE_PROP(p_remote_addr, BT_PROPERTY_TYPE_OF_DEVICE,
 &devtype, sizeof(devtype),
                                         remote_properties[num_props]);
            num_props++;

            BTIF_STORAGE_GET_REMOTE_PROP(p_remote_addr, BT_PROPERTY_UUIDS,
                                         remote_uuids, sizeof(remote_uuids),
                                         remote_properties[num_props]);
            num_props++;

            btif_remote_properties_evt(BT_STATUS_SUCCESS, p_remote_addr,
                                       num_props, remote_properties);
 }
 }
 return BT_STATUS_SUCCESS;
}

static jboolean getRemoteServicesNative(JNIEnv *env, jobject obj, jbyteArray address) {
    ALOGV("%s:",__FUNCTION__);

    jbyte *addr = NULL;
    jboolean result = JNI_FALSE;
 if (!sBluetoothInterface) return result;

    addr = env->GetByteArrayElements(address, NULL);
 if (addr == NULL) {
        jniThrowIOException(env, EINVAL);
 return result;
 }

 int ret = sBluetoothInterface->get_remote_services((bt_bdaddr_t *)addr);
    env->ReleaseByteArrayElements(address, addr, 0);
    result = (ret == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;
 return result;
}

int le_test_mode(uint16_t opcode, uint8_t* buf, uint8_t len)
{
    LOG_INFO("le_test_mode");

 /* sanity check */
 if (interface_ready() == FALSE)
 return BT_STATUS_NOT_READY;

 return btif_le_test_mode(opcode, buf, len);
}

static void print_usage(const char *program_name) {
  printf("Usage: %s [options] [test name]\n", program_name);
  printf("\n");
  printf("Options:\n");
  printf("  %-20sdisplay this help text.\n", "--help");
  printf("  %-20sdo not run sanity suite.\n", "--insanity");
  printf("\n");
  printf("Valid test names are:\n");
 for (size_t i = 0; i < sanity_suite_size; ++i) {
    printf("  %s\n", sanity_suite[i].function_name);
 }
 for (size_t i = 0; i < test_suite_size; ++i) {
    printf("  %s\n", test_suite[i].function_name);
 }
}

bt_status_t btif_storage_set_remote_addr_type(bt_bdaddr_t *remote_bd_addr,
                                              UINT8 addr_type)
{
 bdstr_t bdstr;
    bdaddr_to_string(remote_bd_addr, bdstr, sizeof(bdstr));
 int ret = btif_config_set_int(bdstr, "AddrType", (int)addr_type);
    btif_config_save();
 return ret ? BT_STATUS_SUCCESS : BT_STATUS_FAIL;
}

static void acl_state_changed_callback(bt_status_t status, bt_bdaddr_t *bd_addr,
 bt_acl_state_t state)
{
    jbyteArray addr;
 int i;
 if (!checkCallbackThread()) {
       ALOGE("Callback: '%s' is not called on the correct thread", __FUNCTION__);
 return;
 }
 if (!bd_addr) {
        ALOGE("Address is null in %s", __FUNCTION__);
 return;
 }
    addr = callbackEnv->NewByteArray(sizeof(bt_bdaddr_t));
 if (addr == NULL) {
       ALOGE("Address allocation failed in %s", __FUNCTION__);
 return;
 }
    callbackEnv->SetByteArrayRegion(addr, 0, sizeof(bt_bdaddr_t), (jbyte *)bd_addr);

    callbackEnv->CallVoidMethod(sJniCallbacksObj, method_aclStateChangeCallback, (jint) status,
                                addr, (jint)state);
    checkAndClearExceptionFromCallback(callbackEnv, __FUNCTION__);
    callbackEnv->DeleteLocalRef(addr);
}

static jboolean disableNative(JNIEnv* env, jobject obj) {
    ALOGV("%s:",__FUNCTION__);

    jboolean result = JNI_FALSE;
 if (!sBluetoothInterface) return result;

 int ret = sBluetoothInterface->disable();
 /* Retrun JNI_FALSE only when BTIF explicitly reports
       BT_STATUS_FAIL. It is fine for the BT_STATUS_NOT_READY
       case which indicates that stack had not been enabled.
    */
    result = (ret == BT_STATUS_FAIL) ? JNI_FALSE : JNI_TRUE;
 return result;
}

bt_status_t btif_storage_read_hl_apps_cb(char *value, int value_size)
{
 bt_status_t bt_status = BT_STATUS_SUCCESS;

 if (!btif_config_exist(BTIF_STORAGE_HL_APP, BTIF_STORAGE_HL_APP_CB))
 {
        memset(value, 0, value_size);
 if (!btif_config_set_bin(BTIF_STORAGE_HL_APP,BTIF_STORAGE_HL_APP_CB,
 (const uint8_t *)value, value_size))
 {
            bt_status = BT_STATUS_FAIL;
 }
 else
 {
            btif_config_save();
 }
 }
 else
 {
 size_t read_size = value_size;
 if (!btif_config_get_bin(BTIF_STORAGE_HL_APP, BTIF_STORAGE_HL_APP_CB,
 (uint8_t *)value, &read_size))
 {
            bt_status = BT_STATUS_FAIL;
 }
 else
 {
 if (read_size != (size_t)value_size)
 {
                BTIF_TRACE_ERROR("%s  value_size=%d read_size=%d",
                                  __FUNCTION__, value_size, read_size);
                bt_status = BT_STATUS_FAIL;
 }
 }

 }

    BTIF_TRACE_DEBUG("%s  status=%d value_size=%d", __FUNCTION__, bt_status, value_size);
 return bt_status;
}

bool btif_config_get_int(const char *section, const char *key, int *value) {
  assert(config != NULL);
  assert(section != NULL);
  assert(key != NULL);
  assert(value != NULL);

  pthread_mutex_lock(&lock);
 bool ret = config_has_key(config, section, key);
 if (ret)
 *value = config_get_int(config, section, key, *value);
  pthread_mutex_unlock(&lock);

 return ret;
}

static void pin_request_callback(bt_bdaddr_t *bd_addr, bt_bdname_t *bdname, uint32_t cod,
 bool min_16_digits) {
    jbyteArray addr, devname;
 if (!checkCallbackThread()) {
       ALOGE("Callback: '%s' is not called on the correct thread", __FUNCTION__);
 return;
 }
 if (!bd_addr) {
        ALOGE("Address is null in %s", __FUNCTION__);
 return;
 }

    addr = callbackEnv->NewByteArray(sizeof(bt_bdaddr_t));
 if (addr == NULL) goto Fail;
    callbackEnv->SetByteArrayRegion(addr, 0, sizeof(bt_bdaddr_t), (jbyte*)bd_addr);

    devname = callbackEnv->NewByteArray(sizeof(bt_bdname_t));
 if (devname == NULL) goto Fail;

    callbackEnv->SetByteArrayRegion(devname, 0, sizeof(bt_bdname_t), (jbyte*)bdname);

    callbackEnv->CallVoidMethod(sJniCallbacksObj, method_pinRequestCallback, addr, devname, cod,
            min_16_digits);

    checkAndClearExceptionFromCallback(callbackEnv, __FUNCTION__);
    callbackEnv->DeleteLocalRef(addr);
    callbackEnv->DeleteLocalRef(devname);
 return;

Fail:
 if (addr) callbackEnv->DeleteLocalRef(addr);
 if (devname) callbackEnv->DeleteLocalRef(devname);
    ALOGE("Error while allocating in: %s", __FUNCTION__);
}

static void cleanup(void) {

   stack_manager_get_interface()->clean_up_stack_async();
 }

static int start_discovery(void)
{
 /* sanity check */
 if (interface_ready() == FALSE)
 return BT_STATUS_NOT_READY;

 return btif_dm_start_discovery();
}

int main (int UNUSED argc, char UNUSED *argv[])
{
 int opt;
 char cmd[128];
 int args_processed = 0;
 int pid = -1;

    config_permissions();
    bdt_log("\n:::::::::::::::::::::::::::::::::::::::::::::::::::");
    bdt_log(":: Bluedroid test app starting");

 if ( HAL_load() < 0 ) {
        perror("HAL failed to initialize, exit\n");
        unlink(PID_FILE);
        exit(0);
 }

    setup_test_env();

 /* Automatically perform the init */
    bdt_init();

 while(!main_done)
 {
 char line[128];

 /* command prompt */
        printf( ">" );
        fflush(stdout);

        fgets (line, 128, stdin);

 if (line[0]!= '\0')
 {
 /* remove linefeed */
            line[strlen(line)-1] = 0;

            process_cmd(line, 0);
            memset(line, '\0', 128);
 }
 }

 /* FIXME: Commenting this out as for some reason, the application does not exit otherwise*/

    HAL_unload();

    bdt_log(":: Bluedroid test app terminating");

 return 0;
}

static jboolean getDevicePropertyNative(JNIEnv *env, jobject obj, jbyteArray address, jint type) {
    ALOGV("%s:",__FUNCTION__);

    jbyte *addr = NULL;
    jboolean result = JNI_FALSE;
 if (!sBluetoothInterface) return result;

    addr = env->GetByteArrayElements(address, NULL);
 if (addr == NULL) {
        jniThrowIOException(env, EINVAL);
 return result;
 }

 int ret = sBluetoothInterface->get_remote_device_property((bt_bdaddr_t *)addr,
 (bt_property_type_t) type);
    env->ReleaseByteArrayElements(address, addr, 0);
    result = (ret == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;

 return result;
}

static int cfg2prop(bt_bdaddr_t *remote_bd_addr, bt_property_t *prop)
{
 bdstr_t bdstr = {0};
 if(remote_bd_addr)
        bdaddr_to_string(remote_bd_addr, bdstr, sizeof(bdstr));
    BTIF_TRACE_DEBUG("in, bd addr:%s, prop type:%d, len:%d", bdstr, prop->type, prop->len);
 if(prop->len <= 0)
 {
        BTIF_TRACE_ERROR("property type:%d, len:%d is invalid", prop->type, prop->len);
 return FALSE;
 }
 int ret = FALSE;
 switch(prop->type)
 {
 case BT_PROPERTY_REMOTE_DEVICE_TIMESTAMP:
 if(prop->len >= (int)sizeof(int))
                ret = btif_config_get_int(bdstr,
                                        BTIF_STORAGE_PATH_REMOTE_DEVTIME, (int*)prop->val);
 break;
 case BT_PROPERTY_BDNAME:
 {
 int len = prop->len;
 if(remote_bd_addr)
                ret = btif_config_get_str(bdstr,
                                        BTIF_STORAGE_PATH_REMOTE_NAME, (char*)prop->val, &len);
 else ret = btif_config_get_str("Adapter",
                                        BTIF_STORAGE_KEY_ADAPTER_NAME, (char*)prop->val, &len);
 if(ret && len && len <= prop->len)
                prop->len = len - 1;
 else
 {
                prop->len = 0;
                ret = FALSE;
 }
 break;
 }
 case BT_PROPERTY_REMOTE_FRIENDLY_NAME:
 {
 int len = prop->len;
            ret = btif_config_get_str(bdstr,
                                       BTIF_STORAGE_PATH_REMOTE_ALIASE, (char*)prop->val, &len);
 if(ret && len && len <= prop->len)
                prop->len = len - 1;
 else
 {
                prop->len = 0;
                ret = FALSE;
 }
 break;
 }
 case BT_PROPERTY_ADAPTER_SCAN_MODE:
 if(prop->len >= (int)sizeof(int))
                ret = btif_config_get_int("Adapter",
                                          BTIF_STORAGE_KEY_ADAPTER_SCANMODE, (int*)prop->val);
 break;
 case BT_PROPERTY_ADAPTER_DISCOVERY_TIMEOUT:
 if(prop->len >= (int)sizeof(int))
                ret = btif_config_get_int("Adapter",
                                          BTIF_STORAGE_KEY_ADAPTER_DISC_TIMEOUT, (int*)prop->val);
 break;
 case BT_PROPERTY_CLASS_OF_DEVICE:
 if(prop->len >= (int)sizeof(int))
                ret = btif_config_get_int(bdstr,
                                BTIF_STORAGE_PATH_REMOTE_DEVCLASS, (int*)prop->val);
 break;
 case BT_PROPERTY_TYPE_OF_DEVICE:
 if(prop->len >= (int)sizeof(int))
                ret = btif_config_get_int(bdstr, BTIF_STORAGE_PATH_REMOTE_DEVTYPE, (int*)prop->val);
 break;
 case BT_PROPERTY_UUIDS:
 {
 char value[1280];
 int size = sizeof(value);
 if(btif_config_get_str(bdstr,
                                    BTIF_STORAGE_PATH_REMOTE_SERVICE, value, &size))
 {
 bt_uuid_t *p_uuid = (bt_uuid_t*)prop->val;
 uint32_t num_uuids = 0;
                btif_in_split_uuids_string_to_list(value, p_uuid, &num_uuids);
                prop->len = num_uuids * sizeof(bt_uuid_t);
                ret = TRUE;
 }
 else
 {
                prop->val = NULL;
                prop->len = 0;
 }
 } break;

 case BT_PROPERTY_REMOTE_VERSION_INFO:
 {
 bt_remote_version_t *info = (bt_remote_version_t *)prop->val;

 if(prop->len >= (int)sizeof(bt_remote_version_t))
 {
                ret = btif_config_get_int(bdstr,
                                BTIF_STORAGE_PATH_REMOTE_VER_MFCT, &info->manufacturer);

 if (ret == TRUE)
                    ret = btif_config_get_int(bdstr,
                                BTIF_STORAGE_PATH_REMOTE_VER_VER, &info->version);

 if (ret == TRUE)
                    ret = btif_config_get_int(bdstr,
                                BTIF_STORAGE_PATH_REMOTE_VER_SUBVER, &info->sub_ver);
 }
 } break;

 default:
            BTIF_TRACE_ERROR("Unknow prop type:%d", prop->type);
 return FALSE;
 }
 return ret;
}

static void config_permissions(void)
{
 struct __user_cap_header_struct header;
 struct __user_cap_data_struct cap;

    bdt_log("set_aid_and_cap : pid %d, uid %d gid %d", getpid(), getuid(), getgid());

    header.pid = 0;

    prctl(PR_SET_KEEPCAPS, 1, 0, 0, 0);

    setuid(AID_BLUETOOTH);
    setgid(AID_BLUETOOTH);

    header.version = _LINUX_CAPABILITY_VERSION;

    cap.effective = cap.permitted =  cap.inheritable =
 1 << CAP_NET_RAW |
 1 << CAP_NET_ADMIN |
 1 << CAP_NET_BIND_SERVICE |
 1 << CAP_SYS_RAWIO |
 1 << CAP_SYS_NICE |
 1 << CAP_SETGID;

    capset(&header, &cap);
    setgroups(sizeof(groups)/sizeof(groups[0]), groups);
}

int HAL_load(void)
{
 int err = 0;

 hw_module_t* module;
 hw_device_t* device;

    bdt_log("Loading HAL lib + extensions");

    err = hw_get_module(BT_HARDWARE_MODULE_ID, (hw_module_t const**)&module);
 if (err == 0)
 {
        err = module->methods->open(module, BT_HARDWARE_MODULE_ID, &device);
 if (err == 0) {
            bt_device = (bluetooth_device_t *)device;
            sBtInterface = bt_device->get_bluetooth_interface();
 }
 }

    bdt_log("HAL library loaded (%s)", strerror(err));

 return err;
}

static int open_bluetooth_stack(const struct hw_module_t *module, UNUSED_ATTR char const *name, struct hw_device_t **abstraction) {
 static bluetooth_device_t device = {
 .common = {
 .tag = HARDWARE_DEVICE_TAG,
 .version = 0,
 .close = close_bluetooth_stack,
 },
 .get_bluetooth_interface = bluetooth__get_bluetooth_interface
 };

  device.common.module = (struct hw_module_t *)module;
 *abstraction = (struct hw_device_t *)&device;
 return 0;
}

static void bond_state_changed_callback(bt_status_t status, bt_bdaddr_t *bd_addr,
 bt_bond_state_t state) {
    jbyteArray addr;
 int i;
 if (!checkCallbackThread()) {
       ALOGE("Callback: '%s' is not called on the correct thread", __FUNCTION__);
 return;
 }
 if (!bd_addr) {
        ALOGE("Address is null in %s", __FUNCTION__);
 return;
 }
    addr = callbackEnv->NewByteArray(sizeof(bt_bdaddr_t));
 if (addr == NULL) {
       ALOGE("Address allocation failed in %s", __FUNCTION__);
 return;
 }
    callbackEnv->SetByteArrayRegion(addr, 0, sizeof(bt_bdaddr_t), (jbyte *)bd_addr);

    callbackEnv->CallVoidMethod(sJniCallbacksObj, method_bondStateChangeCallback, (jint) status,
                                addr, (jint)state);
    checkAndClearExceptionFromCallback(callbackEnv, __FUNCTION__);
    callbackEnv->DeleteLocalRef(addr);
}

bt_status_t btif_storage_add_device_to_autopair_blacklist(bt_bdaddr_t *remote_bd_addr)
{
 int ret;
 bdstr_t bdstr;
 char linebuf[BTIF_STORAGE_MAX_LINE_SZ+20];
 char input_value [20];

    bdaddr_to_string(remote_bd_addr, bdstr, sizeof(bdstr));
    strlcpy(input_value, (char*)bdstr, sizeof(input_value));
    strlcat(input_value,BTIF_AUTO_PAIR_CONF_VALUE_SEPARATOR, sizeof(input_value));

 int line_size = sizeof(linebuf);
 if(btif_config_get_str(BTIF_STORAGE_PATH_AUTOPAIR_BLACKLIST,
                            BTIF_STORAGE_KEY_AUTOPAIR_DYNAMIC_BLACKLIST_ADDR, linebuf, &line_size))
 {
 /* Append this address to the dynamic List of BD address  */
        strncat (linebuf, input_value, BTIF_STORAGE_MAX_LINE_SZ);
 }
 else
 {
        strncpy( linebuf,input_value, BTIF_STORAGE_MAX_LINE_SZ);
 }

 /* Write back the key value */
    ret = btif_config_set_str(BTIF_STORAGE_PATH_AUTOPAIR_BLACKLIST,
                        BTIF_STORAGE_KEY_AUTOPAIR_DYNAMIC_BLACKLIST_ADDR, linebuf);

 return ret ? BT_STATUS_SUCCESS:BT_STATUS_FAIL;
}

static jboolean getAdapterPropertyNative(JNIEnv *env, jobject obj, jint type) {
    ALOGV("%s:",__FUNCTION__);

    jboolean result = JNI_FALSE;
 if (!sBluetoothInterface) return result;

 int ret = sBluetoothInterface->get_adapter_property((bt_property_type_t) type);
    result = (ret == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;

 return result;
}

static void interopDatabaseAddNative(JNIEnv *env, jobject obj, int feature,
                                      jbyteArray address, int length) {
    ALOGV("%s()", __FUNCTION__);
 if (!sBluetoothInterface) return;

    jbyte *addr = env->GetByteArrayElements(address, NULL);
 if (addr == NULL) {
        jniThrowIOException(env, EINVAL);
 return;
 }

    sBluetoothInterface->interop_database_add(feature, (bt_bdaddr_t *)addr, length);
    env->ReleaseByteArrayElements(address, addr, 0);
}

int main(int argc, char **argv) {
if (!parse_args(argc, argv)) {
usage(argv[0]);
}

if (bond && discoverable) {
fprintf(stderr, "Can only select either bond or discoverable, not both\n");
usage(argv[0]);
}

if (sco_listen && sco_connect) {
fprintf(stderr, "Can only select either sco_listen or sco_connect, not both\n");
usage(argv[0]);
}

if (!bond && !discover && !discoverable && !up && !get_name && !set_name && !sco_listen && !sco_connect) {
fprintf(stderr, "Must specify one command\n");
usage(argv[0]);
}

if (signal(SIGINT, sig_handler) == SIG_ERR) {
fprintf(stderr, "Will be unable to catch signals\n");
}

fprintf(stdout, "Bringing up bluetooth adapter\n");
if (!hal_open(callbacks_get_adapter_struct())) {
fprintf(stderr, "Unable to open Bluetooth HAL.\n");
return 1;

}

if (discover) {
    CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);
fprintf(stdout, "BT adapter is up\n");

fprintf(stdout, "Starting to start discovery\n");
CALL_AND_WAIT(bt_interface->start_discovery(), discovery_state_changed);
fprintf(stdout, "Started discovery for %d seconds\n", timeout_in_sec);

sleep(timeout_in_sec);

fprintf(stdout, "Starting to cancel discovery\n");
CALL_AND_WAIT(bt_interface->cancel_discovery(), discovery_state_changed);
fprintf(stdout, "Cancelled discovery after %d seconds\n", timeout_in_sec);

}

if (discoverable) {
    CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);
fprintf(stdout, "BT adapter is up\n");

bt_property_t *property = property_new_scan_mode(BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE);

int rc = bt_interface->set_adapter_property(property);
fprintf(stdout, "Set rc:%d device as discoverable for %d seconds\n", rc, timeout_in_sec);

sleep(timeout_in_sec);

property_free(property);
}

if (bond) {
if (bdaddr_is_empty(&bt_remote_bdaddr)) {
fprintf(stderr, "Must specify a remote device address [ --bdaddr=xx:yy:zz:aa:bb:cc ]\n");

exit(1);
}

    CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);
fprintf(stdout, "BT adapter is up\n");

int rc = bt_interface->create_bond(&bt_remote_bdaddr, 0 /* UNKNOWN; Currently not documented :( */);
fprintf(stdout, "Started bonding:%d for %d seconds\n", rc, timeout_in_sec);

sleep(timeout_in_sec);

}

if (up) {
    CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);
fprintf(stdout, "BT adapter is up\n");

fprintf(stdout, "Waiting for %d seconds\n", timeout_in_sec);
sleep(timeout_in_sec);

}

if (get_name) {
    CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);
fprintf(stdout, "BT adapter is up\n");
int error;
CALL_AND_WAIT(error = bt_interface->get_adapter_property(BT_PROPERTY_BDNAME), adapter_properties);
if (error != BT_STATUS_SUCCESS) {
fprintf(stderr, "Unable to get adapter property\n");
exit(1);
}
bt_property_t *property = adapter_get_property(BT_PROPERTY_BDNAME);
const bt_bdname_t *name = property_as_name(property);
if (name)
printf("Queried bluetooth device name:%s\n", name->name);
else
printf("No name\n");

}

if (set_name) {
    CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);
fprintf(stdout, "BT adapter is up\n");

bt_property_t *property = property_new_name(bd_name);
printf("Setting bluetooth device name to:%s\n", bd_name);
int error;
CALL_AND_WAIT(error = bt_interface->set_adapter_property(property), adapter_properties);
if (error != BT_STATUS_SUCCESS) {
fprintf(stderr, "Unable to set adapter property\n");
exit(1);
}
CALL_AND_WAIT(error = bt_interface->get_adapter_property(BT_PROPERTY_BDNAME), adapter_properties);
if (error != BT_STATUS_SUCCESS) {
fprintf(stderr, "Unable to get adapter property\n");
exit(1);
}
property_free(property);
sleep(timeout_in_sec);

}

if (sco_listen) {
    CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);
fprintf(stdout, "BT adapter is up\n");

bt_property_t *property = property_new_scan_mode(BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE);
CALL_AND_WAIT(bt_interface->set_adapter_property(property), adapter_properties);
property_free(property);

const btsock_interface_t *sock = bt_interface->get_profile_interface(BT_PROFILE_SOCKETS_ID);

int rfcomm_fd = INVALID_FD;
int error = sock->listen(BTSOCK_RFCOMM, "meow", (const uint8_t *)&HFP_AG_UUID, 0, &rfcomm_fd, 0);
if (error != BT_STATUS_SUCCESS) {
fprintf(stderr, "Unable to listen for incoming RFCOMM socket: %d\n", error);
exit(1);
}

int sock_fd = INVALID_FD;
error = sock->listen(BTSOCK_SCO, NULL, NULL, 5, &sock_fd, 0);
if (error != BT_STATUS_SUCCESS) {
fprintf(stderr, "Unable to listen for incoming SCO sockets: %d\n", error);
exit(1);
}
fprintf(stdout, "Waiting for incoming SCO connections...\n");
sleep(timeout_in_sec);
}

if (sco_connect) {
if (bdaddr_is_empty(&bt_remote_bdaddr)) {
fprintf(stderr, "Must specify a remote device address [ --bdaddr=xx:yy:zz:aa:bb:cc ]\n");

exit(1);
}

    CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);
fprintf(stdout, "BT adapter is up\n");

const btsock_interface_t *sock = bt_interface->get_profile_interface(BT_PROFILE_SOCKETS_ID);

int rfcomm_fd = INVALID_FD;
int error = sock->connect(&bt_remote_bdaddr, BTSOCK_RFCOMM, (const uint8_t *)&HFP_AG_UUID, 0, &rfcomm_fd, 0);
if (error != BT_STATUS_SUCCESS) {
fprintf(stderr, "Unable to connect to RFCOMM socket: %d.\n", error);
exit(1);
}

WAIT(acl_state_changed);

fprintf(stdout, "Establishing SCO connection...\n");

int sock_fd = INVALID_FD;
error = sock->connect(&bt_remote_bdaddr, BTSOCK_SCO, NULL, 5, &sock_fd, 0);
if (error != BT_STATUS_SUCCESS) {
fprintf(stderr, "Unable to connect to SCO socket: %d.\n", error);
exit(1);
}
sleep(timeout_in_sec);
}

CALL_AND_WAIT(bt_interface->disable(), adapter_state_changed);
fprintf(stdout, "BT adapter is down\n");
}

const btif_config_section_iter_t *btif_config_section_begin(void) {
  assert(config != NULL);
 return (const btif_config_section_iter_t *)config_section_begin(config);
}

void bdt_le_test_mode(char *p)
{
 int cmd;
 unsigned char buf[3];
 int arg1, arg2, arg3;

    bdt_log("BT LE TEST MODE");
 if (!bt_enabled) {
        bdt_log("Bluetooth must be enabled for le_test to work.");
 return;
 }

    memset(buf, 0, sizeof(buf));
    cmd = get_int(&p, 0);
 switch (cmd)
 {
 case 0x1: /* RX TEST */
           arg1 = get_int(&p, -1);
 if (arg1 < 0) bdt_log("%s Invalid arguments", __FUNCTION__);
           buf[0] = arg1;
           status = sBtInterface->le_test_mode(HCI_LE_RECEIVER_TEST_OPCODE, buf, 1);
 break;
 case 0x2: /* TX TEST */
            arg1 = get_int(&p, -1);
            arg2 = get_int(&p, -1);
            arg3 = get_int(&p, -1);
 if ((arg1 < 0) || (arg2 < 0) || (arg3 < 0))
                bdt_log("%s Invalid arguments", __FUNCTION__);
            buf[0] = arg1;
            buf[1] = arg2;
            buf[2] = arg3;
            status = sBtInterface->le_test_mode(HCI_LE_TRANSMITTER_TEST_OPCODE, buf, 3);
 break;
 case 0x3: /* END TEST */
            status = sBtInterface->le_test_mode(HCI_LE_END_TEST_OPCODE, buf, 0);
 break;
 default:
            bdt_log("Unsupported command");
 return;
 break;
 }
 if (status != BT_STATUS_SUCCESS)
 {
        bdt_log("%s Test 0x%x Failed with status:0x%x", __FUNCTION__, cmd, status);
 }
 return;
}

static jboolean setDevicePropertyNative(JNIEnv *env, jobject obj, jbyteArray address,
                                        jint type, jbyteArray value) {
    ALOGV("%s:",__FUNCTION__);

    jbyte *val, *addr;
    jboolean result = JNI_FALSE;
 if (!sBluetoothInterface) return result;

    val = env->GetByteArrayElements(value, NULL);
 if (val == NULL) {
        jniThrowIOException(env, EINVAL);
 return result;
 }

    addr = env->GetByteArrayElements(address, NULL);
 if (addr == NULL) {
        env->ReleaseByteArrayElements(value, val, 0);
        jniThrowIOException(env, EINVAL);
 return result;
 }


 bt_property_t prop;
    prop.type = (bt_property_type_t) type;
    prop.len = env->GetArrayLength(value);
    prop.val = val;

 int ret = sBluetoothInterface->set_remote_device_property((bt_bdaddr_t *)addr, &prop);
    env->ReleaseByteArrayElements(value, val, 0);
    env->ReleaseByteArrayElements(address, addr, 0);

    result = (ret == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;

 return result;
}

bool btif_config_exist(const char *section, const char *key) {
  assert(config != NULL);
  assert(section != NULL);
  assert(key != NULL);

  pthread_mutex_lock(&lock);
 bool ret = config_has_key(config, section, key);
  pthread_mutex_unlock(&lock);

 return ret;
}

void get_bdaddr(const char *str, bt_bdaddr_t *bd) {
 char *d = ((char *)bd), *endp;
 int i;
 for(i = 0; i < 6; i++) {
 *d++ = strtol(str, &endp, 16);
 if (*endp != ':' && i != 5) {
            memset(bd, 0, sizeof(bt_bdaddr_t));
 return;
 }
        str = endp + 1;
 }
}

const char *btif_config_section_name(const btif_config_section_iter_t *section) {
  assert(config != NULL);
  assert(section != NULL);
 return config_section_name((const config_section_node_t *)section);
}

static int get_properties(int num_properties, bt_property_t *properties, jintArray *types,
                        jobjectArray *props) {
    jbyteArray propVal;
 for (int i = 0; i < num_properties; i++) {
        propVal = callbackEnv->NewByteArray(properties[i].len);
 if (propVal == NULL) goto Fail;

        callbackEnv->SetByteArrayRegion(propVal, 0, properties[i].len,
 (jbyte*)properties[i].val);
        callbackEnv->SetObjectArrayElement(*props, i, propVal);
        callbackEnv->DeleteLocalRef(propVal);
        callbackEnv->SetIntArrayRegion(*types, i, 1, (jint *)&properties[i].type);
 }
 return 0;
Fail:
 if (propVal) callbackEnv->DeleteLocalRef(propVal);
    ALOGE("Error while allocation of array in %s", __FUNCTION__);
 return -1;
}

bt_status_t btif_storage_load_bonded_hid_info(void)
{
 bt_bdaddr_t bd_addr;
    tBTA_HH_DEV_DSCP_INFO dscp_info;
 uint16_t attr_mask;
 uint8_t  sub_class;
 uint8_t  app_id;

    memset(&dscp_info, 0, sizeof(dscp_info));
 for (const btif_config_section_iter_t *iter = btif_config_section_begin(); iter != btif_config_section_end(); iter = btif_config_section_next(iter)) {
 const char *name = btif_config_section_name(iter);
 if (!string_is_bdaddr(name))
 continue;

        BTIF_TRACE_DEBUG("Remote device:%s", name);
 int value;
 if(btif_in_fetch_bonded_device(name) == BT_STATUS_SUCCESS)
 {
 if(btif_config_get_int(name, "HidAttrMask", &value))
 {
                attr_mask = (uint16_t)value;

                btif_config_get_int(name, "HidSubClass", &value);
                sub_class = (uint8_t)value;

                btif_config_get_int(name, "HidAppId", &value);
                app_id = (uint8_t)value;

                btif_config_get_int(name, "HidVendorId", &value);
                dscp_info.vendor_id = (uint16_t) value;

                btif_config_get_int(name, "HidProductId", &value);
                dscp_info.product_id = (uint16_t) value;

                btif_config_get_int(name, "HidVersion", &value);
                dscp_info.version = (uint8_t) value;

                btif_config_get_int(name, "HidCountryCode", &value);
                dscp_info.ctry_code = (uint8_t) value;

                value = 0;
                btif_config_get_int(name, "HidSSRMaxLatency", &value);
                dscp_info.ssr_max_latency = (uint16_t) value;

                value = 0;
                btif_config_get_int(name, "HidSSRMinTimeout", &value);
                dscp_info.ssr_min_tout = (uint16_t) value;

 size_t len = btif_config_get_bin_length(name, "HidDescriptor");
 if(len > 0)
 {
                    dscp_info.descriptor.dl_len = (uint16_t)len;
                    dscp_info.descriptor.dsc_list = (uint8_t*)alloca(len);
                    btif_config_get_bin(name, "HidDescriptor", (uint8_t *)dscp_info.descriptor.dsc_list, &len);
 }
                string_to_bdaddr(name, &bd_addr);
 if (btif_hh_add_added_dev(bd_addr,attr_mask))
 {
                    BTA_HhAddDev(bd_addr.address, attr_mask, sub_class,
                            app_id, dscp_info);
 }
 }
 }
 else
 {
 if(btif_config_get_int(name, "HidAttrMask", &value))
 {
                btif_storage_remove_hid_info(&bd_addr);
                string_to_bdaddr(name, &bd_addr);
 }
 }
 }

 return BT_STATUS_SUCCESS;
}

bool btif_config_set_str(const char *section, const char *key, const char *value) {
  assert(config != NULL);
  assert(section != NULL);
  assert(key != NULL);
  assert(value != NULL);

  pthread_mutex_lock(&lock);
  config_set_string(config, section, key, value);
  pthread_mutex_unlock(&lock);

 return true;
}

bt_status_t btif_storage_get_ble_bonding_key(bt_bdaddr_t *remote_bd_addr,
                                             UINT8 key_type,
 char *key_value,
 int key_length)
{
 bdstr_t bdstr;
    bdaddr_to_string(remote_bd_addr, bdstr, sizeof(bdstr));
 const char* name;
 switch(key_type)
 {
 case BTIF_DM_LE_KEY_PENC:
            name = "LE_KEY_PENC";
 break;
 case BTIF_DM_LE_KEY_PID:
            name = "LE_KEY_PID";
 break;
 case BTIF_DM_LE_KEY_PCSRK:
            name = "LE_KEY_PCSRK";
 break;
 case BTIF_DM_LE_KEY_LENC:
            name = "LE_KEY_LENC";
 break;
 case BTIF_DM_LE_KEY_LCSRK:
            name = "LE_KEY_LCSRK";
 break;
 case BTIF_DM_LE_KEY_LID:
            name = "LE_KEY_LID";
 default:
 return BT_STATUS_FAIL;
 }
 size_t length = key_length;
 int ret = btif_config_get_bin(bdstr, name, (uint8_t *)key_value, &length);
 return ret ? BT_STATUS_SUCCESS : BT_STATUS_FAIL;

}

static void le_test_mode_recv_callback (bt_status_t status, uint16_t packet_count) {

    ALOGV("%s: status:%d packet_count:%d ", __FUNCTION__, status, packet_count);
}

BOOLEAN  btif_storage_is_device_autopair_blacklisted(bt_bdaddr_t *remote_bd_addr)
{
 char *token;
 bdstr_t bdstr;
 char *dev_name_str;
 char value[BTIF_STORAGE_MAX_LINE_SZ];
 int value_size = sizeof(value);

    bdaddr_to_string(remote_bd_addr, bdstr, sizeof(bdstr));

 /* Consider only  Lower Address Part from BD Address */
    bdstr[8] = '\0';

 if(btif_config_get_str(BTIF_STORAGE_PATH_AUTOPAIR_BLACKLIST,
                BTIF_STORAGE_KEY_AUTOPAIR_BLACKLIST_ADDR, value, &value_size))
 {
 if (strcasestr(value,bdstr) != NULL)
 return TRUE;
 }

    dev_name_str = BTM_SecReadDevName((remote_bd_addr->address));

 if (dev_name_str != NULL)
 {
        value_size = sizeof(value);
 if(btif_config_get_str(BTIF_STORAGE_PATH_AUTOPAIR_BLACKLIST,
                    BTIF_STORAGE_KEY_AUTOPAIR_BLACKLIST_EXACTNAME, value, &value_size))
 {
 if (strstr(value,dev_name_str) != NULL)
 return TRUE;
 }
        value_size = sizeof(value);
 if(btif_config_get_str(BTIF_STORAGE_PATH_AUTOPAIR_BLACKLIST,
                    BTIF_STORAGE_KEY_AUTOPAIR_BLACKLIST_PARTIALNAME, value, &value_size))
 {
            token = strtok(value, BTIF_AUTO_PAIR_CONF_VALUE_SEPARATOR);
 while (token != NULL)
 {
 if (strstr(dev_name_str, token) != NULL)
 return TRUE;

                token = strtok(NULL, BTIF_AUTO_PAIR_CONF_VALUE_SEPARATOR);
 }
 }
 }
 if(btif_config_get_str(BTIF_STORAGE_PATH_AUTOPAIR_BLACKLIST,
                BTIF_STORAGE_KEY_AUTOPAIR_DYNAMIC_BLACKLIST_ADDR, value, &value_size))
 {
 if (strstr(value,bdstr) != NULL)
 return TRUE;
 }
 return FALSE;
}
