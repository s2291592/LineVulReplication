void FLACParser::error_callback(
 const FLAC__StreamDecoder * /* decoder */,
        FLAC__StreamDecoderErrorStatus status, void *client_data)
{
 ((FLACParser *) client_data)->errorCallback(status);
}

 status_t initCheck() const {
 return mInitCheck;
 }

status_t FLACSource::start(MetaData * /* params */)
{
    ALOGV("FLACSource::start");

    CHECK(!mStarted);
    mParser->allocateBuffers();
    mStarted = true;

 return OK;
}

FLAC__StreamDecoderSeekStatus FLACParser::seekCallback(
        FLAC__uint64 absolute_byte_offset)
{
    mCurrentPos = absolute_byte_offset;
    mEOF = false;
 return FLAC__STREAM_DECODER_SEEK_STATUS_OK;
}

sp<MetaData> FLACExtractor::getTrackMetaData(
 size_t index, uint32_t /* flags */) {
 if (mInitCheck != OK || index > 0) {
 return NULL;
 }
 return mTrackMetadata;
}

status_t FLACExtractor::init()
{
    mFileMetadata = new MetaData;
    mTrackMetadata = new MetaData;
    mParser = new FLACParser(mDataSource, mFileMetadata, mTrackMetadata);
 return mParser->initCheck();
}

MediaBuffer *FLACParser::readBuffer(bool doSeek, FLAC__uint64 sample)
{
    mWriteRequested = true;
    mWriteCompleted = false;
 if (doSeek) {
 if (!FLAC__stream_decoder_seek_absolute(mDecoder, sample)) {
            ALOGE("FLACParser::readBuffer seek to sample %lld failed", (long long)sample);
 return NULL;
 }
        ALOGV("FLACParser::readBuffer seek to sample %lld succeeded", (long long)sample);
 } else {
 if (!FLAC__stream_decoder_process_single(mDecoder)) {
            ALOGE("FLACParser::readBuffer process_single failed");
 return NULL;
 }
 }
 if (!mWriteCompleted) {
        ALOGV("FLACParser::readBuffer write did not complete");
 return NULL;
 }
 unsigned blocksize = mWriteHeader.blocksize;
 if (blocksize == 0 || blocksize > getMaxBlockSize()) {
        ALOGE("FLACParser::readBuffer write invalid blocksize %u", blocksize);
 return NULL;
 }
 if (mWriteHeader.sample_rate != getSampleRate() ||
        mWriteHeader.channels != getChannels() ||
        mWriteHeader.bits_per_sample != getBitsPerSample()) {
        ALOGE("FLACParser::readBuffer write changed parameters mid-stream: %d/%d/%d -> %d/%d/%d",
                getSampleRate(), getChannels(), getBitsPerSample(),
                mWriteHeader.sample_rate, mWriteHeader.channels, mWriteHeader.bits_per_sample);
 return NULL;
 }
    CHECK(mGroup != NULL);
 MediaBuffer *buffer;
 status_t err = mGroup->acquire_buffer(&buffer);
 if (err != OK) {
 return NULL;
 }
 size_t bufferSize = blocksize * getChannels() * sizeof(short);
    CHECK(bufferSize <= mMaxBufferSize);
 short *data = (short *) buffer->data();
    buffer->set_range(0, bufferSize);
 (*mCopy)(data, mWriteBuffer, blocksize, getChannels());
    CHECK(mWriteHeader.number_type == FLAC__FRAME_NUMBER_TYPE_SAMPLE_NUMBER);
    FLAC__uint64 sampleNumber = mWriteHeader.number.sample_number;
 int64_t timeUs = (1000000LL * sampleNumber) / getSampleRate();
    buffer->meta_data()->setInt64(kKeyTime, timeUs);
    buffer->meta_data()->setInt32(kKeyIsSyncFrame, 1);
 return buffer;
}

FLAC__StreamDecoderLengthStatus FLACParser::lengthCallback(
        FLAC__uint64 *stream_length)
{
 off64_t size;
 if (OK == mDataSource->getSize(&size)) {
 *stream_length = size;
 return FLAC__STREAM_DECODER_LENGTH_STATUS_OK;
 } else {
 return FLAC__STREAM_DECODER_LENGTH_STATUS_UNSUPPORTED;
 }
}

sp<IMediaSource> FLACExtractor::getTrack(size_t index)
{
 if (mInitCheck != OK || index > 0) {
 return NULL;
 }
 return new FLACSource(mDataSource, mTrackMetadata);
}

status_t FLACSource::stop()
{
    ALOGV("FLACSource::stop");

    CHECK(mStarted);
    mParser->releaseBuffers();
    mStarted = false;

 return OK;
}

static void copyMono24(
short *dst,
        const int *const *src,
unsigned nSamples,
unsigned /* nChannels */) {
for (unsigned i = 0; i < nSamples; ++i) {
*dst++ = src[0][i] >> 8;
}
}

FLAC__StreamDecoderTellStatus FLACParser::tellCallback(
        FLAC__uint64 *absolute_byte_offset)
{
 *absolute_byte_offset = mCurrentPos;
 return FLAC__STREAM_DECODER_TELL_STATUS_OK;
}

void FLACParser::errorCallback(FLAC__StreamDecoderErrorStatus status)
{
    ALOGE("FLACParser::errorCallback status=%d", status);
    mErrorStatus = status;
}

void FLACParser::metadata_callback(
 const FLAC__StreamDecoder * /* decoder */,
 const FLAC__StreamMetadata *metadata, void *client_data)
{
 ((FLACParser *) client_data)->metadataCallback(metadata);
}

FLAC__StreamDecoderReadStatus FLACParser::read_callback(
 const FLAC__StreamDecoder * /* decoder */, FLAC__byte buffer[],
 size_t *bytes, void *client_data)
{
 return ((FLACParser *) client_data)->readCallback(buffer, bytes);
}

sp<MetaData> FLACSource::getFormat()
{
 return mTrackMetadata;
}

void FLACParser::allocateBuffers()
{
    CHECK(mGroup == NULL);
    mGroup = new MediaBufferGroup;
    mMaxBufferSize = getMaxBlockSize() * getChannels() * sizeof(short);
    mGroup->add_buffer(new MediaBuffer(mMaxBufferSize));
}

FLAC__bool FLACParser::eof_callback(
 const FLAC__StreamDecoder * /* decoder */, void *client_data)
{
 return ((FLACParser *) client_data)->eofCallback();
}

FLACSource::FLACSource(
 const sp<DataSource> &dataSource,
 const sp<MetaData> &trackMetadata)
 : mDataSource(dataSource),
      mTrackMetadata(trackMetadata),
      mParser(0),
      mInitCheck(false),
      mStarted(false)
{
    ALOGV("FLACSource::FLACSource");
    mInitCheck = init();
}

size_t FLACExtractor::countTracks()
{
 return mInitCheck == OK ? 1 : 0;
}

static void copyMono8(
short *dst,
        const int *const *src,
unsigned nSamples,
unsigned /* nChannels */) {
for (unsigned i = 0; i < nSamples; ++i) {
*dst++ = src[0][i] << 8;
}
}

FLAC__StreamDecoderReadStatus FLACParser::readCallback(
        FLAC__byte buffer[], size_t *bytes)
{
 size_t requested = *bytes;
 ssize_t actual = mDataSource->readAt(mCurrentPos, buffer, requested);
 if (0 > actual) {
 *bytes = 0;
 return FLAC__STREAM_DECODER_READ_STATUS_ABORT;
 } else if (0 == actual) {
 *bytes = 0;
        mEOF = true;
 return FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM;
 } else {
        assert(actual <= requested);
 *bytes = actual;
        mCurrentPos += actual;
 return FLAC__STREAM_DECODER_READ_STATUS_CONTINUE;
 }
}

static void copyMultiCh24(short *dst, const int *const *src, unsigned nSamples, unsigned nChannels)
 {
     for (unsigned i = 0; i < nSamples; ++i) {
         for (unsigned c = 0; c < nChannels; ++c) {
 *dst++ = src[c][i] >> 8;
 }
 }
}

static void copyMono16(
short *dst,
        const int *const *src,
unsigned nSamples,
unsigned /* nChannels */) {
for (unsigned i = 0; i < nSamples; ++i) {
*dst++ = src[0][i];
}
}

bool SniffFLAC(
 const sp<DataSource> &source, String8 *mimeType, float *confidence,
        sp<AMessage> *)
{
 uint8_t header[4+4];
 if (source->readAt(0, header, sizeof(header)) != sizeof(header)
 || memcmp("fLaC\0\0\0\042", header, 4+4))
 {
 return false;
 }

 *mimeType = MEDIA_MIMETYPE_AUDIO_FLAC;
 *confidence = 0.5;

 return true;
}

 unsigned getChannels() const {
 return mStreamInfo.channels;
 }

sp<MetaData> FLACExtractor::getMetaData()
{
 return mFileMetadata;
}

 unsigned getBitsPerSample() const {
 return mStreamInfo.bits_per_sample;
 }

    FLAC__uint64 getTotalSamples() const {
 return mStreamInfo.total_samples;
 }

FLAC__StreamDecoderWriteStatus FLACParser::writeCallback(
const FLAC__Frame *frame, const FLAC__int32 * const buffer[])
{
if (mWriteRequested) {

mWriteRequested = false;
// FLAC parser doesn't free or realloc buffer until next frame or finish
mWriteHeader = frame->header;
        mWriteBuffer = buffer;
mWriteCompleted = true;
return FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE;
} else {
ALOGE("FLACParser::writeCallback unexpected");
return FLAC__STREAM_DECODER_WRITE_STATUS_ABORT;
}
}

FLAC__StreamDecoderTellStatus FLACParser::tell_callback(
 const FLAC__StreamDecoder * /* decoder */,
        FLAC__uint64 *absolute_byte_offset, void *client_data)
{
 return ((FLACParser *) client_data)->tellCallback(absolute_byte_offset);
}

static void copyTrespass(
short * /* dst */,
        const int *const * /* src */,
unsigned /* nSamples */,
unsigned /* nChannels */) {
TRESPASS();
}

FLAC__StreamDecoderLengthStatus FLACParser::length_callback(
 const FLAC__StreamDecoder * /* decoder */,
        FLAC__uint64 *stream_length, void *client_data)
{
 return ((FLACParser *) client_data)->lengthCallback(stream_length);
}

static void copyStereo16(
short *dst,
        const int *const *src,
unsigned nSamples,
unsigned /* nChannels */) {
for (unsigned i = 0; i < nSamples; ++i) {
*dst++ = src[0][i];
*dst++ = src[1][i];

}
}

FLAC__StreamDecoderSeekStatus FLACParser::seek_callback(
 const FLAC__StreamDecoder * /* decoder */,
        FLAC__uint64 absolute_byte_offset, void *client_data)
{
 return ((FLACParser *) client_data)->seekCallback(absolute_byte_offset);
}

status_t FLACParser::init()
{
// setup libFLAC parser
mDecoder = FLAC__stream_decoder_new();
if (mDecoder == NULL) {
// The new should succeed, since probably all it does is a malloc
// that always succeeds in Android.  But to avoid dependence on the
// libFLAC internals, we check and log here.
ALOGE("new failed");
return NO_INIT;
}
FLAC__stream_decoder_set_md5_checking(mDecoder, false);
FLAC__stream_decoder_set_metadata_ignore_all(mDecoder);
FLAC__stream_decoder_set_metadata_respond(
mDecoder, FLAC__METADATA_TYPE_STREAMINFO);
FLAC__stream_decoder_set_metadata_respond(
mDecoder, FLAC__METADATA_TYPE_PICTURE);
FLAC__stream_decoder_set_metadata_respond(
mDecoder, FLAC__METADATA_TYPE_VORBIS_COMMENT);
FLAC__StreamDecoderInitStatus initStatus;
initStatus = FLAC__stream_decoder_init_stream(
mDecoder,
read_callback, seek_callback, tell_callback,
length_callback, eof_callback, write_callback,
metadata_callback, error_callback, (void *) this);
if (initStatus != FLAC__STREAM_DECODER_INIT_STATUS_OK) {
// A failure here probably indicates a programming error and so is
// unlikely to happen. But we check and log here similarly to above.
ALOGE("init_stream failed %d", initStatus);
return NO_INIT;
}
// parse all metadata
if (!FLAC__stream_decoder_process_until_end_of_metadata(mDecoder)) {
ALOGE("end_of_metadata failed");
return NO_INIT;

}
if (mStreamInfoValid) {
// check channel count
        if (getChannels() == 0 || getChannels() > 8) {
ALOGE("unsupported channel count %u", getChannels());
return NO_INIT;
}
// check bit depth
switch (getBitsPerSample()) {
case 8:
case 16:
case 24:
break;
default:
ALOGE("unsupported bits per sample %u", getBitsPerSample());
return NO_INIT;
}
// check sample rate
switch (getSampleRate()) {
case 8000:
case 11025:
case 12000:
case 16000:
case 22050:
case 24000:
case 32000:
case 44100:
case 48000:
case 88200:
case 96000:
break;
default:
ALOGE("unsupported sample rate %u", getSampleRate());
return NO_INIT;
}
// configure the appropriate copy function, defaulting to trespass

static const struct {
unsigned mChannels;
unsigned mBitsPerSample;
            void (*mCopy)(short *dst, const int *const *src, unsigned nSamples, unsigned nChannels);
} table[] = {
{ 1,  8, copyMono8    },
{ 2,  8, copyStereo8  },
{ 8, 8, copyMultiCh8  },
{ 1, 16, copyMono16   },
{ 2, 16, copyStereo16 },
{ 8, 16, copyMultiCh16 },
{ 1, 24, copyMono24   },
{ 2, 24, copyStereo24 },
{ 8, 24, copyMultiCh24 },
};
for (unsigned i = 0; i < sizeof(table)/sizeof(table[0]); ++i) {
if (table[i].mChannels >= getChannels() &&
table[i].mBitsPerSample == getBitsPerSample()) {
mCopy = table[i].mCopy;
break;
}
}
// populate track metadata
if (mTrackMetadata != 0) {
mTrackMetadata->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_RAW);
mTrackMetadata->setInt32(kKeyChannelCount, getChannels());
mTrackMetadata->setInt32(kKeySampleRate, getSampleRate());
mTrackMetadata->setInt32(kKeyPcmEncoding, kAudioEncodingPcm16bit);
// sample rate is non-zero, so division by zero not possible
mTrackMetadata->setInt64(kKeyDuration,
(getTotalSamples() * 1000000LL) / getSampleRate());
}
} else {
ALOGE("missing STREAMINFO");
return NO_INIT;
}
if (mFileMetadata != 0) {
mFileMetadata->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_FLAC);
}
return OK;
}

static void copyMultiCh8(short *dst, const int *const *src, unsigned nSamples, unsigned nChannels)
 {
     for (unsigned i = 0; i < nSamples; ++i) {
         for (unsigned c = 0; c < nChannels; ++c) {
 *dst++ = src[c][i] << 8;
 }
 }
}

FLACExtractor::~FLACExtractor()
{
    ALOGV("~FLACExtractor::FLACExtractor");
}

void FLACParser::releaseBuffers()
{
    CHECK(mGroup != NULL);
 delete mGroup;
    mGroup = NULL;
}

FLAC__StreamDecoderWriteStatus FLACParser::write_callback(
 const FLAC__StreamDecoder * /* decoder */, const FLAC__Frame *frame,
 const FLAC__int32 * const buffer[], void *client_data)
{
 return ((FLACParser *) client_data)->writeCallback(frame, buffer);
}

status_t FLACSource::init()
{
    ALOGV("FLACSource::init");
    mParser = new FLACParser(mDataSource);
 return mParser->initCheck();
}

FLAC__bool FLACParser::eofCallback()
{
 return mEOF;
}

 unsigned getMaxBlockSize() const {
 return mStreamInfo.max_blocksize;
 }

FLACParser::FLACParser(
const sp<DataSource> &dataSource,
const sp<MetaData> &fileMetadata,
const sp<MetaData> &trackMetadata)
: mDataSource(dataSource),
mFileMetadata(fileMetadata),
mTrackMetadata(trackMetadata),
mInitCheck(false),
mMaxBufferSize(0),
mGroup(NULL),
mCopy(copyTrespass),
mDecoder(NULL),
mCurrentPos(0LL),
mEOF(false),

mStreamInfoValid(false),
mWriteRequested(false),
mWriteCompleted(false),
      mWriteBuffer(NULL),
mErrorStatus((FLAC__StreamDecoderErrorStatus) -1)
{
ALOGV("FLACParser::FLACParser");
memset(&mStreamInfo, 0, sizeof(mStreamInfo));
memset(&mWriteHeader, 0, sizeof(mWriteHeader));
mInitCheck = init();
}
