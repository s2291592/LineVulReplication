static void WT_ReleaseVoice (S_VOICE_MGR *pVoiceMgr, S_SYNTH *pSynth, S_SYNTH_VOICE *pVoice, EAS_I32 voiceNum)
{
    S_WT_VOICE *pWTVoice;
 const S_ARTICULATION *pArticulation;

#ifdef DLS_SYNTHESIZER
 if (pVoice->regionIndex & FLAG_RGN_IDX_DLS_SYNTH)
 {
        DLS_ReleaseVoice(pVoiceMgr, pSynth, pVoice, voiceNum);
 return;
 }
#endif

    pWTVoice = &pVoiceMgr->wtVoices[voiceNum];
    pArticulation = &pSynth->pEAS->pArticulations[pWTVoice->artIndex];

 /* release EG1 */
    pWTVoice->eg1State = eEnvelopeStateRelease;
    pWTVoice->eg1Increment = pArticulation->eg1.releaseTime;

 /*
    The spec says we should release EG2, but doing so with the current
    voicing is causing clicks. This fix will need to be coordinated with
    a new sound library release
    */

 /* release EG2 */
    pWTVoice->eg2State = eEnvelopeStateRelease;
    pWTVoice->eg2Increment = pArticulation->eg2.releaseTime;
}

void WT_VoiceFilter (S_FILTER_CONTROL *pFilter, S_WT_INT_FRAME *pWTIntFrame)
{
    EAS_PCM *pAudioBuffer;
    EAS_I32 k;
    EAS_I32 b1;
    EAS_I32 b2;
    EAS_I32 z1;
    EAS_I32 z2;
    EAS_I32 acc0;
    EAS_I32 acc1;
    EAS_I32 numSamples;

 /* initialize some local variables */

     numSamples = pWTIntFrame->numSamples;
     if (numSamples <= 0) {
         ALOGE("b/26366256");
         return;
     }
     pAudioBuffer = pWTIntFrame->pAudioBuffer;

    z1 = pFilter->z1;
    z2 = pFilter->z2;
    b1 = -pWTIntFrame->frame.b1;

 /*lint -e{702} <avoid divide> */
    b2 = -pWTIntFrame->frame.b2 >> 1;

 /*lint -e{702} <avoid divide> */
    k = pWTIntFrame->frame.k >> 1;

 while (numSamples--)
 {

 /* do filter calculations */
        acc0 = *pAudioBuffer;
        acc1 = z1 * b1;
        acc1 += z2 * b2;
        acc0 = acc1 + k * acc0;
        z2 = z1;

 /*lint -e{702} <avoid divide> */
        z1 = acc0 >> 14;
 *pAudioBuffer++ = (EAS_I16) z1;
 }

 /* save delay values     */
    pFilter->z1 = (EAS_I16) z1;
    pFilter->z2 = (EAS_I16) z2;
}

void WT_InterpolateMono (S_WT_VOICE *pWTVoice, S_WT_INT_FRAME *pWTIntFrame)
{
    EAS_I32 *pMixBuffer;
 const EAS_I8 *pLoopEnd;
 const EAS_I8 *pCurrentPhaseInt;
    EAS_I32 numSamples;
    EAS_I32 gain;
    EAS_I32 gainIncrement;
    EAS_I32 currentPhaseFrac;
    EAS_I32 phaseInc;
    EAS_I32 tmp0;
    EAS_I32 tmp1;
    EAS_I32 tmp2;

     EAS_I8 *pLoopStart;
 
     numSamples = pWTIntFrame->numSamples;
     pMixBuffer = pWTIntFrame->pMixBuffer;
 
     /* calculate gain increment */
    gainIncrement = (pWTIntFrame->gainTarget - pWTIntFrame->prevGain) << (16 - SYNTH_UPDATE_PERIOD_IN_BITS);
 if (gainIncrement < 0)
        gainIncrement++;
    gain = pWTIntFrame->prevGain << 16;

    pCurrentPhaseInt = pWTVoice->pPhaseAccum;
    currentPhaseFrac = pWTVoice->phaseFrac;
    phaseInc = pWTIntFrame->phaseIncrement;

    pLoopStart = pWTVoice->pLoopStart;
    pLoopEnd = pWTVoice->pLoopEnd + 1;

InterpolationLoop:
    tmp0 = (EAS_I32)(pCurrentPhaseInt - pLoopEnd);
 if (tmp0 >= 0)
        pCurrentPhaseInt = pLoopStart + tmp0;

    tmp0 = *pCurrentPhaseInt;
    tmp1 = *(pCurrentPhaseInt + 1);

    tmp2 = phaseInc + currentPhaseFrac;

    tmp1 = tmp1 - tmp0;
    tmp1 = tmp1 * currentPhaseFrac;

    tmp1 = tmp0 + (tmp1 >> NUM_EG1_FRAC_BITS);

    pCurrentPhaseInt += (tmp2 >> NUM_PHASE_FRAC_BITS);
    currentPhaseFrac = tmp2 & PHASE_FRAC_MASK;

    gain += gainIncrement;
    tmp2 = (gain >> SYNTH_UPDATE_PERIOD_IN_BITS);

    tmp0 = *pMixBuffer;
    tmp2 = tmp1 * tmp2;
    tmp2 = (tmp2 >> 9);
    tmp0 = tmp2 + tmp0;
 *pMixBuffer++ = tmp0;

    numSamples--;
 if (numSamples > 0)
 goto InterpolationLoop;

    pWTVoice->pPhaseAccum = pCurrentPhaseInt;
    pWTVoice->phaseFrac = currentPhaseFrac;
 /*lint -e{702} <avoid divide>*/
    pWTVoice->gain = (EAS_I16)(gain >> SYNTH_UPDATE_PERIOD_IN_BITS);
}

static void WT_UpdateFilter (S_WT_VOICE *pWTVoice, S_WT_INT_FRAME *pIntFrame, const S_ARTICULATION *pArt)
{
    EAS_I32 cutoff;

 /* no need to calculate filter coefficients if it is bypassed */
 if (pArt->filterCutoff == DEFAULT_EAS_FILTER_CUTOFF_FREQUENCY)
 {
        pIntFrame->frame.k = 0;
 return;
 }

 /* determine the dynamic cutoff frequency */
    cutoff = MULT_EG1_EG1(pWTVoice->eg2Value, pArt->eg2ToFc);
    cutoff += pArt->filterCutoff;

 /* subtract the A5 offset and the sampling frequency */
    cutoff -= FILTER_CUTOFF_FREQ_ADJUST + A5_PITCH_OFFSET_IN_CENTS;

 /* limit the cutoff frequency */
 if (cutoff > FILTER_CUTOFF_MAX_PITCH_CENTS)
        cutoff = FILTER_CUTOFF_MAX_PITCH_CENTS;
 else if (cutoff < FILTER_CUTOFF_MIN_PITCH_CENTS)
        cutoff = FILTER_CUTOFF_MIN_PITCH_CENTS;

    WT_SetFilterCoeffs(pIntFrame, cutoff, pArt->filterQ);
}

void WT_VoiceFilter (S_FILTER_CONTROL *pFilter, S_WT_INT_FRAME *pWTIntFrame)
{
    EAS_PCM *pAudioBuffer;
    EAS_I32 k;
    EAS_I32 b1;
    EAS_I32 b2;
    EAS_I32 z1;
    EAS_I32 z2;
    EAS_I32 acc0;
    EAS_I32 acc1;
    EAS_I32 numSamples;

 
     /* initialize some local variables */
     numSamples = pWTIntFrame->numSamples;
     pAudioBuffer = pWTIntFrame->pAudioBuffer;
 
     z1 = pFilter->z1;
    z2 = pFilter->z2;
    b1 = -pWTIntFrame->frame.b1;

 /*lint -e{702} <avoid divide> */
    b2 = -pWTIntFrame->frame.b2 >> 1;

 /*lint -e{702} <avoid divide> */
    k = pWTIntFrame->frame.k >> 1;

 while (numSamples--)
 {

 /* do filter calculations */
        acc0 = *pAudioBuffer;
        acc1 = z1 * b1;
        acc1 += z2 * b2;
        acc0 = acc1 + k * acc0;
        z2 = z1;

 /*lint -e{702} <avoid divide> */
        z1 = acc0 >> 14;
 *pAudioBuffer++ = (EAS_I16) z1;
 }

 /* save delay values     */
    pFilter->z1 = (EAS_I16) z1;
    pFilter->z2 = (EAS_I16) z2;
}

 void WT_NoiseGenerator (S_WT_VOICE *pWTVoice, S_WT_INT_FRAME *pWTIntFrame)
 {
    EAS_PCM *pOutputBuffer;
    EAS_I32 phaseInc;
    EAS_I32 tmp0;
    EAS_I32 tmp1;
    EAS_I32 nInterpolatedSample;
    EAS_I32 numSamples;

 
     /* initialize some local variables */
     numSamples = pWTIntFrame->numSamples;
     pOutputBuffer = pWTIntFrame->pAudioBuffer;
     phaseInc = pWTIntFrame->frame.phaseIncrement;
 
 /* get last two samples generated */
 /*lint -e{704} <avoid divide for performance>*/
    tmp0 = (EAS_I32) (pWTVoice->phaseAccum) >> 18;
 /*lint -e{704} <avoid divide for performance>*/
    tmp1 = (EAS_I32) (pWTVoice->loopEnd) >> 18;

 /* generate a buffer of noise */
 while (numSamples--) {
        nInterpolatedSample = MULT_AUDIO_COEF( tmp0, (PHASE_ONE - pWTVoice->phaseFrac));
        nInterpolatedSample += MULT_AUDIO_COEF( tmp1, pWTVoice->phaseFrac);
 *pOutputBuffer++ = (EAS_PCM) nInterpolatedSample;

 /* update PRNG */
        pWTVoice->phaseFrac += (EAS_U32) phaseInc;
 if (GET_PHASE_INT_PART(pWTVoice->phaseFrac)) {
            tmp0 = tmp1;
            pWTVoice->phaseAccum = pWTVoice->loopEnd;
            pWTVoice->loopEnd = (5 * pWTVoice->loopEnd + 1);
            tmp1 = (EAS_I32) (pWTVoice->loopEnd) >> 18;
            pWTVoice->phaseFrac = GET_PHASE_FRAC_PART(pWTVoice->phaseFrac);
 }

 }
}

void WT_InterpolateNoLoop (S_WT_VOICE *pWTVoice, S_WT_INT_FRAME *pWTIntFrame)
{
    EAS_PCM *pOutputBuffer;
    EAS_I32 phaseInc;
    EAS_I32 phaseFrac;
    EAS_I32 acc0;
 const EAS_SAMPLE *pSamples;
    EAS_I32 samp1;
    EAS_I32 samp2;
    EAS_I32 numSamples;

 /* initialize some local variables */

     numSamples = pWTIntFrame->numSamples;
     if (numSamples <= 0) {
         ALOGE("b/26366256");
         return;
     }
     pOutputBuffer = pWTIntFrame->pAudioBuffer;

    phaseInc = pWTIntFrame->frame.phaseIncrement;
    pSamples = (const EAS_SAMPLE*) pWTVoice->phaseAccum;
    phaseFrac = (EAS_I32)pWTVoice->phaseFrac;

 /* fetch adjacent samples */
#if defined(_8_BIT_SAMPLES)
 /*lint -e{701} <avoid multiply for performance>*/
    samp1 = pSamples[0] << 8;
 /*lint -e{701} <avoid multiply for performance>*/
    samp2 = pSamples[1] << 8;
#else
    samp1 = pSamples[0];
    samp2 = pSamples[1];
#endif

 while (numSamples--) {


 /* linear interpolation */
        acc0 = samp2 - samp1;
        acc0 = acc0 * phaseFrac;
 /*lint -e{704} <avoid divide>*/
        acc0 = samp1 + (acc0 >> NUM_PHASE_FRAC_BITS);

 /* save new output sample in buffer */
 /*lint -e{704} <avoid divide>*/
 *pOutputBuffer++ = (EAS_I16)(acc0 >> 2);

 /* increment phase */
        phaseFrac += phaseInc;
 /*lint -e{704} <avoid divide>*/
        acc0 = phaseFrac >> NUM_PHASE_FRAC_BITS;

 /* next sample */
 if (acc0 > 0) {

 /* advance sample pointer */
            pSamples += acc0;
            phaseFrac = (EAS_I32)((EAS_U32)phaseFrac & PHASE_FRAC_MASK);

 /* fetch new samples */
#if defined(_8_BIT_SAMPLES)
 /*lint -e{701} <avoid multiply for performance>*/
            samp1 = pSamples[0] << 8;
 /*lint -e{701} <avoid multiply for performance>*/
            samp2 = pSamples[1] << 8;
#else
            samp1 = pSamples[0];
            samp2 = pSamples[1];
#endif
 }
 }

 /* save pointer and phase */
    pWTVoice->phaseAccum = (EAS_U32) pSamples;
    pWTVoice->phaseFrac = (EAS_U32) phaseFrac;
}

void WT_Interpolate (S_WT_VOICE *pWTVoice, S_WT_INT_FRAME *pWTIntFrame)
{
    EAS_PCM *pOutputBuffer;
    EAS_I32 phaseInc;
    EAS_I32 phaseFrac;
    EAS_I32 acc0;
 const EAS_SAMPLE *pSamples;
 const EAS_SAMPLE *loopEnd;
    EAS_I32 samp1;
    EAS_I32 samp2;
    EAS_I32 numSamples;

 /* initialize some local variables */

     numSamples = pWTIntFrame->numSamples;
     if (numSamples <= 0) {
         ALOGE("b/26366256");
         return;
     }
     pOutputBuffer = pWTIntFrame->pAudioBuffer;

    loopEnd = (const EAS_SAMPLE*) pWTVoice->loopEnd + 1;
    pSamples = (const EAS_SAMPLE*) pWTVoice->phaseAccum;
 /*lint -e{713} truncation is OK */
    phaseFrac = pWTVoice->phaseFrac;
    phaseInc = pWTIntFrame->frame.phaseIncrement;

 /* fetch adjacent samples */
#if defined(_8_BIT_SAMPLES)
 /*lint -e{701} <avoid multiply for performance>*/
    samp1 = pSamples[0] << 8;
 /*lint -e{701} <avoid multiply for performance>*/
    samp2 = pSamples[1] << 8;
#else
    samp1 = pSamples[0];
    samp2 = pSamples[1];
#endif

 while (numSamples--) {

 /* linear interpolation */
        acc0 = samp2 - samp1;
        acc0 = acc0 * phaseFrac;
 /*lint -e{704} <avoid divide>*/
        acc0 = samp1 + (acc0 >> NUM_PHASE_FRAC_BITS);

 /* save new output sample in buffer */
 /*lint -e{704} <avoid divide>*/
 *pOutputBuffer++ = (EAS_I16)(acc0 >> 2);

 /* increment phase */
        phaseFrac += phaseInc;
 /*lint -e{704} <avoid divide>*/
        acc0 = phaseFrac >> NUM_PHASE_FRAC_BITS;

 /* next sample */
 if (acc0 > 0) {

 /* advance sample pointer */
            pSamples += acc0;
            phaseFrac = (EAS_I32)((EAS_U32)phaseFrac & PHASE_FRAC_MASK);

 /* check for loop end */
            acc0 = (EAS_I32) (pSamples - loopEnd);
 if (acc0 >= 0)
                pSamples = (const EAS_SAMPLE*) pWTVoice->loopStart + acc0;

 /* fetch new samples */
#if defined(_8_BIT_SAMPLES)
 /*lint -e{701} <avoid multiply for performance>*/
            samp1 = pSamples[0] << 8;
 /*lint -e{701} <avoid multiply for performance>*/
            samp2 = pSamples[1] << 8;
#else
            samp1 = pSamples[0];
            samp2 = pSamples[1];
#endif
 }
 }

 /* save pointer and phase */
    pWTVoice->phaseAccum = (EAS_U32) pSamples;
    pWTVoice->phaseFrac = (EAS_U32) phaseFrac;
}

void WT_VoiceGain (S_WT_VOICE *pWTVoice, S_WT_INT_FRAME *pWTIntFrame)
{
    EAS_I32 *pMixBuffer;
    EAS_PCM *pInputBuffer;
    EAS_I32 gain;
    EAS_I32 gainIncrement;
    EAS_I32 tmp0;
    EAS_I32 tmp1;
    EAS_I32 tmp2;
    EAS_I32 numSamples;

#if (NUM_OUTPUT_CHANNELS == 2)
    EAS_I32 gainLeft, gainRight;
#endif

 /* initialize some local variables */

     numSamples = pWTIntFrame->numSamples;
     if (numSamples <= 0) {
         ALOGE("b/26366256");
         return;
     }
     pMixBuffer = pWTIntFrame->pMixBuffer;
    pInputBuffer = pWTIntFrame->pAudioBuffer;

 /*lint -e{703} <avoid multiply for performance>*/
    gainIncrement = (pWTIntFrame->frame.gainTarget - pWTIntFrame->prevGain) << (16 - SYNTH_UPDATE_PERIOD_IN_BITS);
 if (gainIncrement < 0)
        gainIncrement++;
 /*lint -e{703} <avoid multiply for performance>*/
    gain = pWTIntFrame->prevGain << 16;

#if (NUM_OUTPUT_CHANNELS == 2)
    gainLeft = pWTVoice->gainLeft;
    gainRight = pWTVoice->gainRight;
#endif

 while (numSamples--) {

 /* incremental gain step to prevent zipper noise */
        tmp0 = *pInputBuffer++;
        gain += gainIncrement;
 /*lint -e{704} <avoid divide>*/
        tmp2 = gain >> 16;

 /* scale sample by gain */
        tmp2 *= tmp0;


 /* stereo output */
#if (NUM_OUTPUT_CHANNELS == 2)
 /*lint -e{704} <avoid divide>*/
        tmp2 = tmp2 >> 14;

 /* get the current sample in the final mix buffer */
        tmp1 = *pMixBuffer;

 /* left channel */
        tmp0 = tmp2 * gainLeft;
 /*lint -e{704} <avoid divide>*/
        tmp0 = tmp0 >> NUM_MIXER_GUARD_BITS;
        tmp1 += tmp0;
 *pMixBuffer++ = tmp1;

 /* get the current sample in the final mix buffer */
        tmp1 = *pMixBuffer;

 /* right channel */
        tmp0 = tmp2 * gainRight;
 /*lint -e{704} <avoid divide>*/
        tmp0 = tmp0 >> NUM_MIXER_GUARD_BITS;
        tmp1 += tmp0;
 *pMixBuffer++ = tmp1;

 /* mono output */
#else

 /* get the current sample in the final mix buffer */
        tmp1 = *pMixBuffer;
 /*lint -e{704} <avoid divide>*/
        tmp2 = tmp2 >> (NUM_MIXER_GUARD_BITS - 1);
        tmp1 += tmp2;
 *pMixBuffer++ = tmp1;
#endif

 }
}

void WT_InterpolateNoLoop (S_WT_VOICE *pWTVoice, S_WT_INT_FRAME *pWTIntFrame)
{
    EAS_PCM *pOutputBuffer;
    EAS_I32 phaseInc;
    EAS_I32 phaseFrac;
    EAS_I32 acc0;
 const EAS_SAMPLE *pSamples;
    EAS_I32 samp1;
    EAS_I32 samp2;
    EAS_I32 numSamples;

 
     /* initialize some local variables */
     numSamples = pWTIntFrame->numSamples;
     pOutputBuffer = pWTIntFrame->pAudioBuffer;
 
     phaseInc = pWTIntFrame->frame.phaseIncrement;
    pSamples = (const EAS_SAMPLE*) pWTVoice->phaseAccum;
    phaseFrac = (EAS_I32)pWTVoice->phaseFrac;

 /* fetch adjacent samples */
#if defined(_8_BIT_SAMPLES)
 /*lint -e{701} <avoid multiply for performance>*/
    samp1 = pSamples[0] << 8;
 /*lint -e{701} <avoid multiply for performance>*/
    samp2 = pSamples[1] << 8;
#else
    samp1 = pSamples[0];
    samp2 = pSamples[1];
#endif

 while (numSamples--) {


 /* linear interpolation */
        acc0 = samp2 - samp1;
        acc0 = acc0 * phaseFrac;
 /*lint -e{704} <avoid divide>*/
        acc0 = samp1 + (acc0 >> NUM_PHASE_FRAC_BITS);

 /* save new output sample in buffer */
 /*lint -e{704} <avoid divide>*/
 *pOutputBuffer++ = (EAS_I16)(acc0 >> 2);

 /* increment phase */
        phaseFrac += phaseInc;
 /*lint -e{704} <avoid divide>*/
        acc0 = phaseFrac >> NUM_PHASE_FRAC_BITS;

 /* next sample */
 if (acc0 > 0) {

 /* advance sample pointer */
            pSamples += acc0;
            phaseFrac = (EAS_I32)((EAS_U32)phaseFrac & PHASE_FRAC_MASK);

 /* fetch new samples */
#if defined(_8_BIT_SAMPLES)
 /*lint -e{701} <avoid multiply for performance>*/
            samp1 = pSamples[0] << 8;
 /*lint -e{701} <avoid multiply for performance>*/
            samp2 = pSamples[1] << 8;
#else
            samp1 = pSamples[0];
            samp2 = pSamples[1];
#endif
 }
 }

 /* save pointer and phase */
    pWTVoice->phaseAccum = (EAS_U32) pSamples;
    pWTVoice->phaseFrac = (EAS_U32) phaseFrac;
}

void WT_Interpolate (S_WT_VOICE *pWTVoice, S_WT_INT_FRAME *pWTIntFrame)
{
    EAS_PCM *pOutputBuffer;
    EAS_I32 phaseInc;
    EAS_I32 phaseFrac;
    EAS_I32 acc0;
 const EAS_SAMPLE *pSamples;
 const EAS_SAMPLE *loopEnd;
    EAS_I32 samp1;
    EAS_I32 samp2;
    EAS_I32 numSamples;

 
     /* initialize some local variables */
     numSamples = pWTIntFrame->numSamples;
     pOutputBuffer = pWTIntFrame->pAudioBuffer;
 
     loopEnd = (const EAS_SAMPLE*) pWTVoice->loopEnd + 1;
    pSamples = (const EAS_SAMPLE*) pWTVoice->phaseAccum;
 /*lint -e{713} truncation is OK */
    phaseFrac = pWTVoice->phaseFrac;
    phaseInc = pWTIntFrame->frame.phaseIncrement;

 /* fetch adjacent samples */
#if defined(_8_BIT_SAMPLES)
 /*lint -e{701} <avoid multiply for performance>*/
    samp1 = pSamples[0] << 8;
 /*lint -e{701} <avoid multiply for performance>*/
    samp2 = pSamples[1] << 8;
#else
    samp1 = pSamples[0];
    samp2 = pSamples[1];
#endif

 while (numSamples--) {

 /* linear interpolation */
        acc0 = samp2 - samp1;
        acc0 = acc0 * phaseFrac;
 /*lint -e{704} <avoid divide>*/
        acc0 = samp1 + (acc0 >> NUM_PHASE_FRAC_BITS);

 /* save new output sample in buffer */
 /*lint -e{704} <avoid divide>*/
 *pOutputBuffer++ = (EAS_I16)(acc0 >> 2);

 /* increment phase */
        phaseFrac += phaseInc;
 /*lint -e{704} <avoid divide>*/
        acc0 = phaseFrac >> NUM_PHASE_FRAC_BITS;

 /* next sample */
 if (acc0 > 0) {

 /* advance sample pointer */
            pSamples += acc0;
            phaseFrac = (EAS_I32)((EAS_U32)phaseFrac & PHASE_FRAC_MASK);

 /* check for loop end */
            acc0 = (EAS_I32) (pSamples - loopEnd);
 if (acc0 >= 0)
                pSamples = (const EAS_SAMPLE*) pWTVoice->loopStart + acc0;

 /* fetch new samples */
#if defined(_8_BIT_SAMPLES)
 /*lint -e{701} <avoid multiply for performance>*/
            samp1 = pSamples[0] << 8;
 /*lint -e{701} <avoid multiply for performance>*/
            samp2 = pSamples[1] << 8;
#else
            samp1 = pSamples[0];
            samp2 = pSamples[1];
#endif
 }
 }

 /* save pointer and phase */
    pWTVoice->phaseAccum = (EAS_U32) pSamples;
    pWTVoice->phaseFrac = (EAS_U32) phaseFrac;
}

void WT_InterpolateMono (S_WT_VOICE *pWTVoice, S_WT_INT_FRAME *pWTIntFrame)
{
    EAS_I32 *pMixBuffer;
 const EAS_I8 *pLoopEnd;
 const EAS_I8 *pCurrentPhaseInt;
    EAS_I32 numSamples;
    EAS_I32 gain;
    EAS_I32 gainIncrement;
    EAS_I32 currentPhaseFrac;
    EAS_I32 phaseInc;
    EAS_I32 tmp0;
    EAS_I32 tmp1;
    EAS_I32 tmp2;
    EAS_I8 *pLoopStart;


     numSamples = pWTIntFrame->numSamples;
     if (numSamples <= 0) {
         ALOGE("b/26366256");
         return;
     }
     pMixBuffer = pWTIntFrame->pMixBuffer;

 /* calculate gain increment */
    gainIncrement = (pWTIntFrame->gainTarget - pWTIntFrame->prevGain) << (16 - SYNTH_UPDATE_PERIOD_IN_BITS);
 if (gainIncrement < 0)
        gainIncrement++;
    gain = pWTIntFrame->prevGain << 16;

    pCurrentPhaseInt = pWTVoice->pPhaseAccum;
    currentPhaseFrac = pWTVoice->phaseFrac;
    phaseInc = pWTIntFrame->phaseIncrement;

    pLoopStart = pWTVoice->pLoopStart;
    pLoopEnd = pWTVoice->pLoopEnd + 1;

InterpolationLoop:
    tmp0 = (EAS_I32)(pCurrentPhaseInt - pLoopEnd);
 if (tmp0 >= 0)
        pCurrentPhaseInt = pLoopStart + tmp0;

    tmp0 = *pCurrentPhaseInt;
    tmp1 = *(pCurrentPhaseInt + 1);

    tmp2 = phaseInc + currentPhaseFrac;

    tmp1 = tmp1 - tmp0;
    tmp1 = tmp1 * currentPhaseFrac;

    tmp1 = tmp0 + (tmp1 >> NUM_EG1_FRAC_BITS);

    pCurrentPhaseInt += (tmp2 >> NUM_PHASE_FRAC_BITS);
    currentPhaseFrac = tmp2 & PHASE_FRAC_MASK;

    gain += gainIncrement;
    tmp2 = (gain >> SYNTH_UPDATE_PERIOD_IN_BITS);

    tmp0 = *pMixBuffer;
    tmp2 = tmp1 * tmp2;
    tmp2 = (tmp2 >> 9);
    tmp0 = tmp2 + tmp0;
 *pMixBuffer++ = tmp0;

    numSamples--;
 if (numSamples > 0)
 goto InterpolationLoop;

    pWTVoice->pPhaseAccum = pCurrentPhaseInt;
    pWTVoice->phaseFrac = currentPhaseFrac;
 /*lint -e{702} <avoid divide>*/
    pWTVoice->gain = (EAS_I16)(gain >> SYNTH_UPDATE_PERIOD_IN_BITS);
}

static void WT_UpdateEG2 (S_WT_VOICE *pWTVoice, const S_ENVELOPE *pEnv)
{
    EAS_I32 temp;

 switch (pWTVoice->eg2State)
 {
 case eEnvelopeStateAttack:
            temp = pWTVoice->eg2Value + pWTVoice->eg2Increment;

 /* check if we have reached peak amplitude */
 if (temp >= SYNTH_FULL_SCALE_EG1_GAIN)
 {
 /* limit the volume */
                temp = SYNTH_FULL_SCALE_EG1_GAIN;

 /* prepare to move to decay state */
                pWTVoice->eg2State = eEnvelopeStateDecay;

                pWTVoice->eg2Increment = pEnv->decayTime;
 }

 break;

 /* implement linear pitch decay in cents */
 case eEnvelopeStateDecay:
            temp = pWTVoice->eg2Value -pWTVoice->eg2Increment;

 /* check if we have reached sustain level */
 if (temp <= pEnv->sustainLevel)
 {
 /* enforce the sustain level */
                temp = pEnv->sustainLevel;

 /* prepare to move to sustain state */
                pWTVoice->eg2State = eEnvelopeStateSustain;
 }
 break;

 case eEnvelopeStateSustain:
 return;

 case eEnvelopeStateRelease:
            temp = pWTVoice->eg2Value - pWTVoice->eg2Increment;

 if (temp <= 0)
 {
                temp = 0;
                pWTVoice->eg2State = eEnvelopeStateMuted;
 }

 break;

 /* voice is muted, set target to zero */
 case eEnvelopeStateMuted:
            temp = 0;
 break;

 case eEnvelopeStateInvalid:
 default:
            temp = 0;
#ifdef  _DEBUG_SYNTH
 { /* dpp: EAS_ReportEx(_EAS_SEVERITY_INFO, "WT_UpdateEG2: error, %d is an unrecognized state\n",
                pWTVoice->eg2State); */ }
#endif
 break;
 }

    pWTVoice->eg2Value = (EAS_I16) temp;
}

static void WT_MuteVoice (S_VOICE_MGR *pVoiceMgr, S_SYNTH *pSynth, S_SYNTH_VOICE *pVoice, EAS_I32 voiceNum)
{

#ifdef DLS_SYNTHESIZER
 if (pVoice->regionIndex & FLAG_RGN_IDX_DLS_SYNTH)
 {
        DLS_MuteVoice(pVoiceMgr, pSynth, pVoice, voiceNum);
 return;
 }
#endif

 /* clear deferred action flags */
    pVoice->voiceFlags &=
 ~(VOICE_FLAG_DEFER_MIDI_NOTE_OFF |
        VOICE_FLAG_SUSTAIN_PEDAL_DEFER_NOTE_OFF |
        VOICE_FLAG_DEFER_MUTE);

 /* set the envelope state */
    pVoiceMgr->wtVoices[voiceNum].eg1State = eEnvelopeStateMuted;
    pVoiceMgr->wtVoices[voiceNum].eg2State = eEnvelopeStateMuted;
}

EAS_BOOL WT_CheckSampleEnd (S_WT_VOICE *pWTVoice, S_WT_INT_FRAME *pWTIntFrame, EAS_BOOL update)
{
    EAS_U32 endPhaseAccum;
    EAS_U32 endPhaseFrac;
    EAS_I32 numSamples;
    EAS_BOOL done = EAS_FALSE;

 /* check to see if we hit the end of the waveform this time */
 /*lint -e{703} use shift for performance */
    endPhaseFrac = pWTVoice->phaseFrac + (pWTIntFrame->frame.phaseIncrement << SYNTH_UPDATE_PERIOD_IN_BITS);
    endPhaseAccum = pWTVoice->phaseAccum + GET_PHASE_INT_PART(endPhaseFrac);
 if (endPhaseAccum >= pWTVoice->loopEnd)
 {
 /* calculate how far current ptr is from end */
        numSamples = (EAS_I32) (pWTVoice->loopEnd - pWTVoice->phaseAccum);

 /* now account for the fractional portion */
 /*lint -e{703} use shift for performance */
        numSamples = (EAS_I32) ((numSamples << NUM_PHASE_FRAC_BITS) - pWTVoice->phaseFrac);
 if (pWTIntFrame->frame.phaseIncrement) {
            pWTIntFrame->numSamples = 1 + (numSamples / pWTIntFrame->frame.phaseIncrement);
 } else {
            pWTIntFrame->numSamples = numSamples;

         }
         if (pWTIntFrame->numSamples < 0) {
             ALOGE("b/26366256");
             pWTIntFrame->numSamples = 0;
         }
 
 /* sound will be done this frame */
        done = EAS_TRUE;
 }

 /* update data for off-chip synth */
 if (update)
 {
        pWTVoice->phaseFrac = endPhaseFrac;
        pWTVoice->phaseAccum = endPhaseAccum;
 }

 return done;
}

static EAS_I32 WT_UpdatePhaseInc (S_WT_VOICE *pWTVoice, const S_ARTICULATION *pArt, S_SYNTH_CHANNEL *pChannel, EAS_I32 pitchCents)
{
    EAS_I32 temp;

 /*pitchCents due to CC1 = LFO * (CC1 / 128) * DEFAULT_LFO_MOD_WHEEL_TO_PITCH_CENTS */
    temp = MULT_EG1_EG1(DEFAULT_LFO_MOD_WHEEL_TO_PITCH_CENTS,
 ((pChannel->modWheel) << (NUM_EG1_FRAC_BITS -7)));

 /* pitchCents due to channel pressure = LFO * (channel pressure / 128) * DEFAULT_LFO_CHANNEL_PRESSURE_TO_PITCH_CENTS */
    temp += MULT_EG1_EG1(DEFAULT_LFO_CHANNEL_PRESSURE_TO_PITCH_CENTS,
 ((pChannel->channelPressure) << (NUM_EG1_FRAC_BITS -7)));

 /* now multiply the (channel pressure + CC1) pitch values by the LFO value */
    temp = MULT_EG1_EG1(pWTVoice->modLFO.lfoValue, temp);

 /*
    add in the LFO pitch due to
    channel pressure and CC1 along with
    the LFO pitch, the EG2 pitch, and the
    "static" pitch for this voice on this channel
    */
    temp += pitchCents +
 (MULT_EG1_EG1(pWTVoice->eg2Value, pArt->eg2ToPitch)) +
 (MULT_EG1_EG1(pWTVoice->modLFO.lfoValue, pArt->lfoToPitch));

 /* convert from cents to linear phase increment */
 return EAS_Calculate2toX(temp);
}

 void WT_NoiseGenerator (S_WT_VOICE *pWTVoice, S_WT_INT_FRAME *pWTIntFrame)
 {
    EAS_PCM *pOutputBuffer;
    EAS_I32 phaseInc;
    EAS_I32 tmp0;
    EAS_I32 tmp1;
    EAS_I32 nInterpolatedSample;
    EAS_I32 numSamples;

 /* initialize some local variables */

     numSamples = pWTIntFrame->numSamples;
     if (numSamples <= 0) {
         ALOGE("b/26366256");
         return;
     }
     pOutputBuffer = pWTIntFrame->pAudioBuffer;
    phaseInc = pWTIntFrame->frame.phaseIncrement;

 /* get last two samples generated */
 /*lint -e{704} <avoid divide for performance>*/
    tmp0 = (EAS_I32) (pWTVoice->phaseAccum) >> 18;
 /*lint -e{704} <avoid divide for performance>*/
    tmp1 = (EAS_I32) (pWTVoice->loopEnd) >> 18;

 /* generate a buffer of noise */
 while (numSamples--) {
        nInterpolatedSample = MULT_AUDIO_COEF( tmp0, (PHASE_ONE - pWTVoice->phaseFrac));
        nInterpolatedSample += MULT_AUDIO_COEF( tmp1, pWTVoice->phaseFrac);
 *pOutputBuffer++ = (EAS_PCM) nInterpolatedSample;

 /* update PRNG */
        pWTVoice->phaseFrac += (EAS_U32) phaseInc;
 if (GET_PHASE_INT_PART(pWTVoice->phaseFrac)) {
            tmp0 = tmp1;
            pWTVoice->phaseAccum = pWTVoice->loopEnd;
            pWTVoice->loopEnd = (5 * pWTVoice->loopEnd + 1);
            tmp1 = (EAS_I32) (pWTVoice->loopEnd) >> 18;
            pWTVoice->phaseFrac = GET_PHASE_FRAC_PART(pWTVoice->phaseFrac);
 }

 }
}

static void WT_UpdateEG1 (S_WT_VOICE *pWTVoice, const S_ENVELOPE *pEnv)
{
    EAS_I32 temp;

 switch (pWTVoice->eg1State)
 {
 case eEnvelopeStateAttack:
            temp = pWTVoice->eg1Value + pWTVoice->eg1Increment;

 /* check if we have reached peak amplitude */
 if (temp >= SYNTH_FULL_SCALE_EG1_GAIN)
 {
 /* limit the volume */
                temp = SYNTH_FULL_SCALE_EG1_GAIN;

 /* prepare to move to decay state */
                pWTVoice->eg1State = eEnvelopeStateDecay;
                pWTVoice->eg1Increment = pEnv->decayTime;
 }

 break;

 /* exponential decay */
 case eEnvelopeStateDecay:
            temp = MULT_EG1_EG1(pWTVoice->eg1Value, pWTVoice->eg1Increment);

 /* check if we have reached sustain level */
 if (temp <= pEnv->sustainLevel)
 {
 /* enforce the sustain level */
                temp = pEnv->sustainLevel;

 /* if sustain level is zero, skip sustain & release the voice */
 if (temp > 0)
                    pWTVoice->eg1State = eEnvelopeStateSustain;

 /* move to sustain state */
 else
                    pWTVoice->eg1State = eEnvelopeStateMuted;
 }

 break;

 case eEnvelopeStateSustain:
 return;

 case eEnvelopeStateRelease:
            temp = MULT_EG1_EG1(pWTVoice->eg1Value, pWTVoice->eg1Increment);

 /* if we hit zero, this voice isn't contributing any audio */
 if (temp <= 0)
 {
                temp = 0;
                pWTVoice->eg1State = eEnvelopeStateMuted;
 }
 break;

 /* voice is muted, set target to zero */
 case eEnvelopeStateMuted:
            temp = 0;
 break;

 case eEnvelopeStateInvalid:
 default:
            temp = 0;
#ifdef  _DEBUG_SYNTH
 { /* dpp: EAS_ReportEx(_EAS_SEVERITY_INFO, "WT_UpdateEG1: error, %d is an unrecognized state\n",
                pWTVoice->eg1State); */ }
#endif
 break;

 }

    pWTVoice->eg1Value = (EAS_I16) temp;
}

void WT_SetFilterCoeffs (S_WT_INT_FRAME *pIntFrame, EAS_I32 cutoff, EAS_I32 resonance)
{
    EAS_I32 temp;

 /*
    Convert the cutoff, which has had A5 subtracted, using the 2^x approx
    Note, this cutoff is related to theta cutoff by
    theta = k * 2^x
    We use 2^x and incorporate k in the power series coefs instead
    */
    cutoff = EAS_Calculate2toX(cutoff);

 /* calculate b2 coef */
    temp = k2g1[resonance] + MULT_AUDIO_COEF(cutoff, k2g2[resonance]);
    temp = k2g0 + MULT_AUDIO_COEF(cutoff, temp);
    pIntFrame->frame.b2 = temp;

 /* calculate b1 coef */
    temp = MULT_AUDIO_COEF(cutoff, nk1g2);
    temp = nk1g0 + MULT_AUDIO_COEF(cutoff, temp);
    temp += MULT_AUDIO_COEF(temp, pIntFrame->frame.b2);
    pIntFrame->frame.b1 = temp >> 1;

 /* calculate K coef */
    temp = n1g2[resonance] + MULT_AUDIO_COEF(cutoff, n1g3[resonance]);
    temp = MULT_AUDIO_COEF(cutoff, temp);
    temp = MULT_AUDIO_COEF(cutoff, temp);
    pIntFrame->frame.k = temp;
}

static EAS_I32 WT_UpdateGain (S_SYNTH_VOICE *pVoice, S_WT_VOICE *pWTVoice, const S_ARTICULATION *pArt, S_SYNTH_CHANNEL *pChannel, EAS_I32 gain)
{
    EAS_I32 lfoGain;
    EAS_I32 temp;

 /*
    If this voice was stolen, then the velocity is actually
    for the new note, not the note that we are currently ramping down.
    So we really shouldn't use this velocity. However, that would require
    more memory to store the velocity value, and the improvement may
    not be sufficient to warrant the added memory.
    */
 /* velocity is fixed at note start for a given voice and must be squared */
    temp = (pVoice->velocity) << (NUM_EG1_FRAC_BITS - 7);
    temp = MULT_EG1_EG1(temp, temp);

 /* region gain is fixed as part of the articulation */
    temp = MULT_EG1_EG1(temp, gain);

 /* include the channel gain */
    temp = MULT_EG1_EG1(temp, pChannel->staticGain);

 /* calculate LFO gain using an approximation for 10^x */
    lfoGain = MULT_EG1_EG1(pWTVoice->modLFO.lfoValue, pArt->lfoToGain);
    lfoGain = MULT_EG1_EG1(lfoGain, LFO_GAIN_TO_CENTS);

 /* convert from a dB-like value to linear gain */
    lfoGain = EAS_Calculate2toX(lfoGain);
    temp = MULT_EG1_EG1(temp, lfoGain);

 /* calculate the voice's gain */
    temp = (EAS_I16)MULT_EG1_EG1(temp, pWTVoice->eg1Value);

 return temp;
}

static void WT_SustainPedal (S_VOICE_MGR *pVoiceMgr, S_SYNTH *pSynth, S_SYNTH_VOICE *pVoice, S_SYNTH_CHANNEL *pChannel, EAS_I32 voiceNum)
{
    S_WT_VOICE *pWTVoice;

#ifdef DLS_SYNTHESIZER
 if (pVoice->regionIndex & FLAG_RGN_IDX_DLS_SYNTH)
 {
        DLS_SustainPedal(pVoiceMgr, pSynth, pVoice, pChannel, voiceNum);
 return;
 }
#endif

 /* don't catch the voice if below the sustain level */
    pWTVoice = &pVoiceMgr->wtVoices[voiceNum];
 if (pWTVoice->eg1Value < pSynth->pEAS->pArticulations[pWTVoice->artIndex].eg1.sustainLevel)
 return;

 /* sustain flag is set, damper pedal is on */
 /* defer releasing this note until the damper pedal is off */
    pWTVoice->eg1State = eEnvelopeStateDecay;
    pVoice->voiceState = eVoiceStatePlay;

 /*
    because sustain pedal is on, this voice
    should defer releasing its note
    */
    pVoice->voiceFlags |= VOICE_FLAG_SUSTAIN_PEDAL_DEFER_NOTE_OFF;

#ifdef _DEBUG_SYNTH
 { /* dpp: EAS_ReportEx(_EAS_SEVERITY_INFO, "WT_SustainPedal: defer note off because sustain pedal is on\n"); */ }
#endif
}

void WT_VoiceGain (S_WT_VOICE *pWTVoice, S_WT_INT_FRAME *pWTIntFrame)
{
    EAS_I32 *pMixBuffer;
    EAS_PCM *pInputBuffer;
    EAS_I32 gain;
    EAS_I32 gainIncrement;
    EAS_I32 tmp0;
    EAS_I32 tmp1;
    EAS_I32 tmp2;
    EAS_I32 numSamples;

#if (NUM_OUTPUT_CHANNELS == 2)
    EAS_I32 gainLeft, gainRight;
#endif

 
     /* initialize some local variables */
     numSamples = pWTIntFrame->numSamples;
     pMixBuffer = pWTIntFrame->pMixBuffer;
     pInputBuffer = pWTIntFrame->pAudioBuffer;
 
 /*lint -e{703} <avoid multiply for performance>*/
    gainIncrement = (pWTIntFrame->frame.gainTarget - pWTIntFrame->prevGain) << (16 - SYNTH_UPDATE_PERIOD_IN_BITS);
 if (gainIncrement < 0)
        gainIncrement++;
 /*lint -e{703} <avoid multiply for performance>*/
    gain = pWTIntFrame->prevGain << 16;

#if (NUM_OUTPUT_CHANNELS == 2)
    gainLeft = pWTVoice->gainLeft;
    gainRight = pWTVoice->gainRight;
#endif

 while (numSamples--) {

 /* incremental gain step to prevent zipper noise */
        tmp0 = *pInputBuffer++;
        gain += gainIncrement;
 /*lint -e{704} <avoid divide>*/
        tmp2 = gain >> 16;

 /* scale sample by gain */
        tmp2 *= tmp0;


 /* stereo output */
#if (NUM_OUTPUT_CHANNELS == 2)
 /*lint -e{704} <avoid divide>*/
        tmp2 = tmp2 >> 14;

 /* get the current sample in the final mix buffer */
        tmp1 = *pMixBuffer;

 /* left channel */
        tmp0 = tmp2 * gainLeft;
 /*lint -e{704} <avoid divide>*/
        tmp0 = tmp0 >> NUM_MIXER_GUARD_BITS;
        tmp1 += tmp0;
 *pMixBuffer++ = tmp1;

 /* get the current sample in the final mix buffer */
        tmp1 = *pMixBuffer;

 /* right channel */
        tmp0 = tmp2 * gainRight;
 /*lint -e{704} <avoid divide>*/
        tmp0 = tmp0 >> NUM_MIXER_GUARD_BITS;
        tmp1 += tmp0;
 *pMixBuffer++ = tmp1;

 /* mono output */
#else

 /* get the current sample in the final mix buffer */
        tmp1 = *pMixBuffer;
 /*lint -e{704} <avoid divide>*/
        tmp2 = tmp2 >> (NUM_MIXER_GUARD_BITS - 1);
        tmp1 += tmp2;
 *pMixBuffer++ = tmp1;
#endif

 }
}

EAS_BOOL WT_CheckSampleEnd (S_WT_VOICE *pWTVoice, S_WT_INT_FRAME *pWTIntFrame, EAS_BOOL update)
{
    EAS_U32 endPhaseAccum;
    EAS_U32 endPhaseFrac;
    EAS_I32 numSamples;
    EAS_BOOL done = EAS_FALSE;

 /* check to see if we hit the end of the waveform this time */
 /*lint -e{703} use shift for performance */
    endPhaseFrac = pWTVoice->phaseFrac + (pWTIntFrame->frame.phaseIncrement << SYNTH_UPDATE_PERIOD_IN_BITS);
    endPhaseAccum = pWTVoice->phaseAccum + GET_PHASE_INT_PART(endPhaseFrac);
 if (endPhaseAccum >= pWTVoice->loopEnd)
 {
 /* calculate how far current ptr is from end */
        numSamples = (EAS_I32) (pWTVoice->loopEnd - pWTVoice->phaseAccum);

 /* now account for the fractional portion */
 /*lint -e{703} use shift for performance */
        numSamples = (EAS_I32) ((numSamples << NUM_PHASE_FRAC_BITS) - pWTVoice->phaseFrac);
 if (pWTIntFrame->frame.phaseIncrement) {
            pWTIntFrame->numSamples = 1 + (numSamples / pWTIntFrame->frame.phaseIncrement);

         } else {
             pWTIntFrame->numSamples = numSamples;
         }
 
         /* sound will be done this frame */
         done = EAS_TRUE;
 }

 /* update data for off-chip synth */
 if (update)
 {
        pWTVoice->phaseFrac = endPhaseFrac;
        pWTVoice->phaseAccum = endPhaseAccum;
 }

 return done;
}
