void ExtensionGlobalError::BubbleViewDidClose() {
  if (!closed_callback_.is_null()) {
    closed_callback_.Run(*this, current_browser_);
  }
  if (should_delete_self_on_close_) {
    delete this;
  }
}

ExtensionGlobalError::ExtensionGlobalError(
      base::WeakPtr<ExtensionService> extension_service)
    : current_browser_(NULL),
      should_delete_self_on_close_(true),
      extension_service_(extension_service),
      external_extension_ids_(new ExtensionIdSet),
      blacklisted_extension_ids_(new ExtensionIdSet),
      orphaned_extension_ids_(new ExtensionIdSet) {
}

ExtensionInstalledBubble::~ExtensionInstalledBubble() {}

PanelSettingsMenuModel::~PanelSettingsMenuModel() {
}

ExtensionSettingsHandler::~ExtensionSettingsHandler() {
  if (load_extension_dialog_.get())
    load_extension_dialog_->ListenerDestroyed();

  registrar_.RemoveAll();
}

void ExtensionSettingsHandler::Initialize() {
}

bool ExtensionContextMenuModel::IsCommandIdChecked(int command_id) const {
  return false;
}

void ExtensionSettingsHandler::HandleLoadMessage(const ListValue* args) {
  FilePath::StringType string_path;
  CHECK_EQ(1U, args->GetSize()) << args->GetSize();
  CHECK(args->GetString(0, &string_path));
  extensions::UnpackedInstaller::Create(extension_service_)->
      Load(FilePath(string_path));
}

NTPResourceCache::NTPResourceCache(Profile* profile) : profile_(profile) {
  registrar_.Add(this, chrome::NOTIFICATION_BROWSER_THEME_CHANGED,
                 content::Source<ThemeService>(
                     ThemeServiceFactory::GetForProfile(profile)));
  registrar_.Add(this, chrome::NOTIFICATION_PROMO_RESOURCE_STATE_CHANGED,
                 content::NotificationService::AllSources());
  registrar_.Add(this, chrome::NTP4_INTRO_PREF_CHANGED,
                 content::NotificationService::AllSources());

  pref_change_registrar_.Init(profile_->GetPrefs());
  pref_change_registrar_.Add(prefs::kSyncAcknowledgedSyncTypes, this);
  pref_change_registrar_.Add(prefs::kShowBookmarkBar, this);
  pref_change_registrar_.Add(prefs::kNTPShownPage, this);
  pref_change_registrar_.Add(prefs::kSyncPromoShowNTPBubble, this);
}

string16 ExtensionGlobalError::MenuItemLabel() {
  NOTREACHED();
  return NULL;
}

void NTPResourceCache::CreateNewTabCSS() {
  ui::ThemeProvider* tp = ThemeServiceFactory::GetForProfile(profile_);
  DCHECK(tp);

  SkColor color_background =
      tp->GetColor(ThemeService::COLOR_NTP_BACKGROUND);
  SkColor color_text = tp->GetColor(ThemeService::COLOR_NTP_TEXT);
  SkColor color_link = tp->GetColor(ThemeService::COLOR_NTP_LINK);
  SkColor color_link_underline =
      tp->GetColor(ThemeService::COLOR_NTP_LINK_UNDERLINE);

  SkColor color_section =
      tp->GetColor(ThemeService::COLOR_NTP_SECTION);
  SkColor color_section_text =
      tp->GetColor(ThemeService::COLOR_NTP_SECTION_TEXT);
  SkColor color_section_link =
      tp->GetColor(ThemeService::COLOR_NTP_SECTION_LINK);
  SkColor color_section_link_underline =
      tp->GetColor(ThemeService::COLOR_NTP_SECTION_LINK_UNDERLINE);
  SkColor color_section_header_text =
      tp->GetColor(ThemeService::COLOR_NTP_SECTION_HEADER_TEXT);
  SkColor color_section_header_text_hover =
      tp->GetColor(ThemeService::COLOR_NTP_SECTION_HEADER_TEXT_HOVER);
  SkColor color_section_header_rule =
      tp->GetColor(ThemeService::COLOR_NTP_SECTION_HEADER_RULE);
  SkColor color_section_header_rule_light =
      tp->GetColor(ThemeService::COLOR_NTP_SECTION_HEADER_RULE_LIGHT);
  SkColor color_text_light =
      tp->GetColor(ThemeService::COLOR_NTP_TEXT_LIGHT);

  SkColor color_header =
      tp->GetColor(ThemeService::COLOR_NTP_HEADER);
  color_utils::HSL header_lighter;
  color_utils::SkColorToHSL(color_header, &header_lighter);
  header_lighter.l += (1 - header_lighter.l) * 0.33;
  SkColor color_header_gradient_light =
      color_utils::HSLToSkColor(header_lighter, SkColorGetA(color_header));

  SkColor color_section_border =
      SkColorSetARGB(80,
                     SkColorGetR(color_header),
                     SkColorGetG(color_header),
                     SkColorGetB(color_header));

  std::vector<std::string> subst;

  subst.push_back(
      profile_->GetPrefs()->GetString(prefs::kCurrentThemeID));  // $1

  subst.push_back(SkColorToRGBAString(color_background));  // $2
  subst.push_back(GetNewTabBackgroundCSS(tp, false));  // $3
  subst.push_back(GetNewTabBackgroundCSS(tp, true));  // $4
  subst.push_back(GetNewTabBackgroundTilingCSS(tp));  // $5
  subst.push_back(SkColorToRGBAString(color_header));  // $6
  subst.push_back(SkColorToRGBAString(color_header_gradient_light));  // $7
  subst.push_back(SkColorToRGBAString(color_text));  // $8
  subst.push_back(SkColorToRGBAString(color_link));  // $9
  subst.push_back(SkColorToRGBAString(color_section));  // $10
  subst.push_back(SkColorToRGBAString(color_section_border));  // $11
  subst.push_back(SkColorToRGBAString(color_section_text));  // $12
  subst.push_back(SkColorToRGBAString(color_section_link));  // $13
  subst.push_back(SkColorToRGBAString(color_link_underline));  // $14
  subst.push_back(SkColorToRGBAString(color_section_link_underline));  // $15
  subst.push_back(SkColorToRGBAString(color_section_header_text)); // $16
  subst.push_back(SkColorToRGBAString(
      color_section_header_text_hover)); // $17
  subst.push_back(SkColorToRGBAString(color_section_header_rule));  // $18
  subst.push_back(SkColorToRGBAString(
      color_section_header_rule_light));  // $19
  subst.push_back(SkColorToRGBAString(
      SkColorSetA(color_section_header_rule, 0)));  // $20
  subst.push_back(SkColorToRGBAString(color_text_light));  // $21
  subst.push_back(SkColorToRGBComponents(color_section_border));  // $22
  subst.push_back(SkColorToRGBComponents(color_text));  // $23

  static const base::StringPiece new_tab_theme_css(
      ResourceBundle::GetSharedInstance().GetRawDataResource(
          IDR_NEW_TAB_4_THEME_CSS));

  std::string css_string;
  css_string = ReplaceStringPlaceholders(new_tab_theme_css, subst, NULL);
  new_tab_css_ = base::RefCountedString::TakeString(&css_string);
}

void ExtensionInstallUI::OpenAppInstalledNTP(Browser* browser,
                                             const std::string& app_id) {
  browser::NavigateParams params =
      browser->GetSingletonTabNavigateParams(GURL(chrome::kChromeUINewTabURL));
  browser::Navigate(&params);

  content::NotificationService::current()->Notify(
      chrome::NOTIFICATION_APP_INSTALLED_TO_NTP,
      content::Source<WebContents>(params.target_contents->web_contents()),
      content::Details<const std::string>(&app_id));
}

void ExtensionGlobalError::set_closed_callback(
    ExtensionGlobalErrorCallback callback) {
  cancel_callback_ = callback;
}

void ExtensionSettingsHandler::HandleUninstallMessage(const ListValue* args) {
  std::string extension_id = UTF16ToUTF8(ExtractStringValue(args));
  CHECK(!extension_id.empty());
  const Extension* extension =
      extension_service_->GetExtensionById(extension_id, true);
  if (!extension)
    extension = extension_service_->GetTerminatedExtension(extension_id);
  if (!extension)
    return;

  if (!Extension::UserMayDisable(extension->location())) {
    LOG(ERROR) << "Attempt to uninstall an extension that is non-usermanagable "
               << "was made. Extension id : " << extension->id();
    return;
  }

  if (!extension_id_prompting_.empty())
    return;  // Only one prompt at a time.

  extension_id_prompting_ = extension_id;

  GetExtensionUninstallDialog()->ConfirmUninstall(extension);
}

void ExtensionSettingsHandler::GetLocalizedValues(
DictionaryValue* localized_strings) {
RegisterTitle(localized_strings, "extensionSettings",
IDS_MANAGE_EXTENSIONS_SETTING_WINDOWS_TITLE);

localized_strings->SetString("extensionSettingsVisitWebsite",
l10n_util::GetStringUTF16(IDS_EXTENSIONS_VISIT_WEBSITE));

localized_strings->SetString("extensionSettingsDeveloperMode",
l10n_util::GetStringUTF16(IDS_EXTENSIONS_DEVELOPER_MODE_LINK));
localized_strings->SetString("extensionSettingsNoExtensions",
l10n_util::GetStringUTF16(IDS_EXTENSIONS_NONE_INSTALLED));
localized_strings->SetString("extensionSettingsSuggestGallery",
l10n_util::GetStringFUTF16(IDS_EXTENSIONS_NONE_INSTALLED_SUGGEST_GALLERY,
ASCIIToUTF16(google_util::AppendGoogleLocaleParam(
GURL(extension_urls::GetWebstoreLaunchURL())).spec())));
localized_strings->SetString("extensionSettingsGetMoreExtensions",
l10n_util::GetStringFUTF16(IDS_GET_MORE_EXTENSIONS,
ASCIIToUTF16(google_util::AppendGoogleLocaleParam(
GURL(extension_urls::GetWebstoreLaunchURL())).spec())));
localized_strings->SetString("extensionSettingsExtensionId",
l10n_util::GetStringUTF16(IDS_EXTENSIONS_ID));
localized_strings->SetString("extensionSettingsExtensionPath",
l10n_util::GetStringUTF16(IDS_EXTENSIONS_PATH));
localized_strings->SetString("extensionSettingsInspectViews",
l10n_util::GetStringUTF16(IDS_EXTENSIONS_INSPECT_VIEWS));
localized_strings->SetString("viewIncognito",
l10n_util::GetStringUTF16(IDS_EXTENSIONS_VIEW_INCOGNITO));
localized_strings->SetString("extensionSettingsEnable",
l10n_util::GetStringUTF16(IDS_EXTENSIONS_ENABLE));
localized_strings->SetString("extensionSettingsEnabled",
l10n_util::GetStringUTF16(IDS_EXTENSIONS_ENABLED));
localized_strings->SetString("extensionSettingsRemove",
l10n_util::GetStringUTF16(IDS_EXTENSIONS_REMOVE));
localized_strings->SetString("extensionSettingsEnableIncognito",
l10n_util::GetStringUTF16(IDS_EXTENSIONS_ENABLE_INCOGNITO));
localized_strings->SetString("extensionSettingsAllowFileAccess",
l10n_util::GetStringUTF16(IDS_EXTENSIONS_ALLOW_FILE_ACCESS));
localized_strings->SetString("extensionSettingsIncognitoWarning",
      l10n_util::GetStringFUTF16(IDS_EXTENSIONS_INCOGNITO_WARNING,
                                 l10n_util::GetStringUTF16(IDS_PRODUCT_NAME)));
localized_strings->SetString("extensionSettingsReload",
l10n_util::GetStringUTF16(IDS_EXTENSIONS_RELOAD));
localized_strings->SetString("extensionSettingsOptions",
l10n_util::GetStringUTF16(IDS_EXTENSIONS_OPTIONS));
localized_strings->SetString("extensionSettingsPolicyControlled",
l10n_util::GetStringUTF16(IDS_EXTENSIONS_POLICY_CONTROLLED));
localized_strings->SetString("extensionSettingsShowButton",
l10n_util::GetStringUTF16(IDS_EXTENSIONS_SHOW_BUTTON));
localized_strings->SetString("extensionSettingsLoadUnpackedButton",
l10n_util::GetStringUTF16(IDS_EXTENSIONS_LOAD_UNPACKED_BUTTON));
localized_strings->SetString("extensionSettingsPackButton",
l10n_util::GetStringUTF16(IDS_EXTENSIONS_PACK_BUTTON));
localized_strings->SetString("extensionSettingsUpdateButton",
l10n_util::GetStringUTF16(IDS_EXTENSIONS_UPDATE_BUTTON));
localized_strings->SetString("extensionSettingsCrashMessage",
l10n_util::GetStringUTF16(IDS_EXTENSIONS_CRASHED_EXTENSION));
localized_strings->SetString("extensionSettingsInDevelopment",
l10n_util::GetStringUTF16(IDS_EXTENSIONS_IN_DEVELOPMENT));
localized_strings->SetString("extensionSettingsWarningsTitle",
l10n_util::GetStringUTF16(IDS_EXTENSION_WARNINGS_TITLE));
localized_strings->SetString("extensionSettingsShowDetails",
l10n_util::GetStringUTF16(IDS_EXTENSIONS_SHOW_DETAILS));
localized_strings->SetString("extensionSettingsHideDetails",
l10n_util::GetStringUTF16(IDS_EXTENSIONS_HIDE_DETAILS));
}

InstalledBubbleContent(Browser* browser,
const Extension* extension,
ExtensionInstalledBubble::BubbleType type,
SkBitmap* icon,
ExtensionInstalledBubble* bubble)
: browser_(browser),
extension_id_(extension->id()),
bubble_(bubble),
type_(type),
info_(NULL) {
ResourceBundle& rb = ResourceBundle::GetSharedInstance();
const gfx::Font& font = rb.GetFont(ResourceBundle::BaseFont);

// Scale down to 43x43, but allow smaller icons (don't scale up).
gfx::Size size(icon->width(), icon->height());
if (size.width() > kIconSize || size.height() > kIconSize)
size = gfx::Size(kIconSize, kIconSize);
icon_ = new views::ImageView();
icon_->SetImageSize(size);
icon_->SetImage(*icon);
AddChildView(icon_);

string16 extension_name = UTF8ToUTF16(extension->name());
base::i18n::AdjustStringForLocaleDirection(&extension_name);
heading_ = new views::Label(l10n_util::GetStringFUTF16(
        IDS_EXTENSION_INSTALLED_HEADING,
        extension_name,
        l10n_util::GetStringUTF16(IDS_SHORT_PRODUCT_NAME)));
heading_->SetFont(rb.GetFont(ResourceBundle::MediumFont));
heading_->SetMultiLine(true);
heading_->SetHorizontalAlignment(views::Label::ALIGN_LEFT);
AddChildView(heading_);

switch (type_) {
case ExtensionInstalledBubble::PAGE_ACTION: {
info_ = new views::Label(l10n_util::GetStringUTF16(
IDS_EXTENSION_INSTALLED_PAGE_ACTION_INFO));
info_->SetFont(font);
info_->SetMultiLine(true);
info_->SetHorizontalAlignment(views::Label::ALIGN_LEFT);
AddChildView(info_);
break;
}
case ExtensionInstalledBubble::OMNIBOX_KEYWORD: {
info_ = new views::Label(l10n_util::GetStringFUTF16(
IDS_EXTENSION_INSTALLED_OMNIBOX_KEYWORD_INFO,
UTF8ToUTF16(extension->omnibox_keyword())));
info_->SetFont(font);
info_->SetMultiLine(true);
info_->SetHorizontalAlignment(views::Label::ALIGN_LEFT);
AddChildView(info_);
break;
}
case ExtensionInstalledBubble::APP: {
views::Link* link = new views::Link(
l10n_util::GetStringUTF16(IDS_EXTENSION_INSTALLED_APP_INFO));
link->set_listener(this);
manage_ = link;
manage_->SetFont(font);
manage_->SetMultiLine(true);
manage_->SetHorizontalAlignment(views::Label::ALIGN_LEFT);
AddChildView(manage_);
break;
}
default:
break;
}

if (type_ != ExtensionInstalledBubble::APP) {
manage_ = new views::Label(
l10n_util::GetStringUTF16(IDS_EXTENSION_INSTALLED_MANAGE_INFO));
manage_->SetFont(font);
manage_->SetMultiLine(true);
manage_->SetHorizontalAlignment(views::Label::ALIGN_LEFT);
AddChildView(manage_);
}

close_button_ = new views::ImageButton(this);
close_button_->SetImage(views::CustomButton::BS_NORMAL,
rb.GetBitmapNamed(IDR_CLOSE_BAR));
close_button_->SetImage(views::CustomButton::BS_HOT,
rb.GetBitmapNamed(IDR_CLOSE_BAR_H));
close_button_->SetImage(views::CustomButton::BS_PUSHED,
rb.GetBitmapNamed(IDR_CLOSE_BAR_P));
AddChildView(close_button_);
}

void ExtensionGlobalError::AddOrphanedExtension(const std::string& id) {
  orphaned_extension_ids_->insert(id);
}

int ExtensionGlobalError::MenuItemCommandID() {
  NOTREACHED();
  return 0;
}

void PanelSettingsMenuModel::ExtensionUninstallAccepted() {
  const Extension* extension = panel_->GetExtension();
  DCHECK(extension);

  panel_->browser()->GetProfile()->GetExtensionService()->
      UninstallExtension(extension->id(), false, NULL);
}

string16 ExtensionGlobalError::GetBubbleViewMessage() {
  if (message_.empty()) {
    message_ = GenerateMessage();
  }
  return message_;
}

void ExtensionSettingsHandler::MaybeRegisterForNotifications() {
  if (registered_for_notifications_)
    return;

  registered_for_notifications_  = true;
  Profile* profile = Profile::FromWebUI(web_ui());

  registrar_.Add(this, chrome::NOTIFICATION_EXTENSION_LOADED,
                 content::Source<Profile>(profile));
  registrar_.Add(this, chrome::NOTIFICATION_EXTENSION_UNLOADED,
                 content::Source<Profile>(profile));
  registrar_.Add(this, chrome::NOTIFICATION_EXTENSION_UPDATE_DISABLED,
                 content::Source<Profile>(profile));
  registrar_.Add(this, chrome::NOTIFICATION_EXTENSION_WARNING_CHANGED,
                 content::Source<Profile>(profile));
  registrar_.Add(this, chrome::NOTIFICATION_EXTENSION_HOST_CREATED,
                 content::NotificationService::AllBrowserContextsAndSources());
  registrar_.Add(this,
                 content::NOTIFICATION_RENDER_VIEW_HOST_CREATED,
                 content::NotificationService::AllBrowserContextsAndSources());
  registrar_.Add(this,
                 content::NOTIFICATION_RENDER_VIEW_HOST_DELETED,
                 content::NotificationService::AllBrowserContextsAndSources());
  registrar_.Add(this,
                 chrome::NOTIFICATION_BACKGROUND_CONTENTS_NAVIGATED,
                 content::NotificationService::AllBrowserContextsAndSources());
  registrar_.Add(this,
                 chrome::NOTIFICATION_BACKGROUND_CONTENTS_DELETED,
                 content::NotificationService::AllBrowserContextsAndSources());
  registrar_.Add(
      this,
      chrome::NOTIFICATION_EXTENSION_BROWSER_ACTION_VISIBILITY_CHANGED,
      content::Source<ExtensionPrefs>(profile->GetExtensionService()->
                             extension_prefs()));
}

ExtensionInstalledBubble::ExtensionInstalledBubble(const Extension* extension,
                                                   Browser *browser,
                                                   const SkBitmap& icon)
    : extension_(extension),
      browser_(browser),
      icon_(icon),
      animation_wait_retries_(0) {
  if (extension->is_app()) {
    type_ = APP;
  } else if (!extension_->omnibox_keyword().empty()) {
    type_ = OMNIBOX_KEYWORD;
  } else if (extension_->browser_action()) {
    type_ = BROWSER_ACTION;
  } else if (extension->page_action() &&
             !extension->page_action()->default_icon_path().empty()) {
    type_ = PAGE_ACTION;
  } else {
    type_ = GENERIC;
  }

  registrar_.Add(this, chrome::NOTIFICATION_EXTENSION_LOADED,
      content::Source<Profile>(browser->profile()));
  registrar_.Add(this, chrome::NOTIFICATION_EXTENSION_UNLOADED,
      content::Source<Profile>(browser->profile()));
}

void ExtensionContextMenuModel::ExtensionUninstallAccepted() {
  if (GetExtension())
    profile_->GetExtensionService()->UninstallExtension(extension_id_, false,
                                                        NULL);

  Release();
}

void ExtensionSettingsHandler::HandleToggleDeveloperMode(
      const ListValue* args) {
  Profile* profile = Profile::FromWebUI(web_ui());
  bool developer_mode =
      profile->GetPrefs()->GetBoolean(prefs::kExtensionsUIDeveloperMode);
  profile->GetPrefs()->SetBoolean(
      prefs::kExtensionsUIDeveloperMode, !developer_mode);
  HandleRequestExtensionsData(NULL);
}

void ExtensionSettingsHandler::HandleOptionsMessage(const ListValue* args) {
  const Extension* extension = GetExtension(args);
  if (!extension || extension->options_url().is_empty())
    return;
  Profile::FromWebUI(web_ui())->GetExtensionProcessManager()->OpenOptionsPage(
      extension, NULL);
}

void ExtensionSettingsHandler::FileSelected(const FilePath& path, int index,
                                            void* params) {
  ListValue results;
  results.Append(Value::CreateStringValue(path.value()));
  web_ui()->CallJavascriptFunction("window.handleFilePathSelected", results);
}

std::string GetNewTabBackgroundCSS(const ui::ThemeProvider* theme_provider,
                                   bool bar_attached) {
  int alignment;
  theme_provider->GetDisplayProperty(
      ThemeService::NTP_BACKGROUND_ALIGNMENT, &alignment);

  if (!theme_provider->HasCustomImage(IDR_THEME_NTP_BACKGROUND)) {
    return "-64px";
  }

  if (bar_attached)
    return ThemeService::AlignmentToString(alignment);

#if defined(OS_WIN) || defined(TOOLKIT_VIEWS)
  int offset = browser_defaults::kNewtabBookmarkBarHeight;
#elif defined(OS_MACOSX)
  int offset = bookmarks::kNTPBookmarkBarHeight;
#elif defined(OS_POSIX)
  int offset = BookmarkBarGtk::kBookmarkBarNTPHeight;
#else
  int offset = 0;
#endif

  if (alignment & ThemeService::ALIGN_TOP) {
    if (alignment & ThemeService::ALIGN_LEFT)
      return "0% " + base::IntToString(-offset) + "px";
    else if (alignment & ThemeService::ALIGN_RIGHT)
      return "100% " + base::IntToString(-offset) + "px";
    return "center " + base::IntToString(-offset) + "px";
  }
  return ThemeService::AlignmentToString(alignment);
}

NTPResourceCache::~NTPResourceCache() {}

void ExtensionSettingsHandler::HandleReloadMessage(const ListValue* args) {
  std::string extension_id = UTF16ToUTF8(ExtractStringValue(args));
  CHECK(!extension_id.empty());
  extension_service_->ReloadExtension(extension_id);
}

ExtensionContextMenuModel::~ExtensionContextMenuModel() {
}

const Extension* ExtensionSettingsHandler::GetExtension(const ListValue* args) {
  std::string extension_id = UTF16ToUTF8(ExtractStringValue(args));
  CHECK(!extension_id.empty());
  return extension_service_->GetExtensionById(extension_id, true);
}

void ExtensionInstalledBubbleGtk::OnButtonClick(GtkWidget* button,
    ExtensionInstalledBubbleGtk* bubble) {
  if (button == bubble->close_button_->widget()) {
    bubble->bubble_->Close();
  } else {
    NOTREACHED();
  }
}

  virtual void ButtonPressed(views::Button* sender, const views::Event& event) {
    if (sender == close_button_)
      bubble_->StartFade(false);
    else
      NOTREACHED() << "Unknown view";
  }

void PanelSettingsMenuModel::ExtensionUninstallCanceled() {
}

void ExtensionSettingsHandler::Observe(
    int type,
    const content::NotificationSource& source,
    const content::NotificationDetails& details) {
  Profile* profile = Profile::FromWebUI(web_ui());
  Profile* source_profile = NULL;
  switch (type) {
    case content::NOTIFICATION_RENDER_VIEW_HOST_DELETED:
      deleting_rvh_ = content::Source<RenderViewHost>(source).ptr();
    case content::NOTIFICATION_RENDER_VIEW_HOST_CREATED:
      source_profile = Profile::FromBrowserContext(
          content::Source<RenderViewHost>(source)->site_instance()->
          browsing_instance()->browser_context());
      if (!profile->IsSameProfile(source_profile))
        return;
      MaybeUpdateAfterNotification();
      break;
    case chrome::NOTIFICATION_BACKGROUND_CONTENTS_DELETED:
      deleting_rvh_ = content::Details<BackgroundContents>(details)->
          web_contents()->GetRenderViewHost();
    case chrome::NOTIFICATION_BACKGROUND_CONTENTS_NAVIGATED:
    case chrome::NOTIFICATION_EXTENSION_HOST_CREATED:
      source_profile = content::Source<Profile>(source).ptr();
      if (!profile->IsSameProfile(source_profile))
          return;
      MaybeUpdateAfterNotification();
      break;
    case chrome::NOTIFICATION_EXTENSION_LOADED:
    case chrome::NOTIFICATION_EXTENSION_UNLOADED:
    case chrome::NOTIFICATION_EXTENSION_UPDATE_DISABLED:
    case chrome::NOTIFICATION_EXTENSION_WARNING_CHANGED:
    case chrome::NOTIFICATION_EXTENSION_BROWSER_ACTION_VISIBILITY_CHANGED:
      MaybeUpdateAfterNotification();
      break;
    default:
      NOTREACHED();
  }
}

gfx::Rect ExtensionInstalledBubble::GetAnchorRect() {
  if (type_ == OMNIBOX_KEYWORD) {
    LocationBarView* location_bar_view =
        BrowserView::GetBrowserViewForBrowser(browser_)->GetLocationBarView();
    return gfx::Rect(location_bar_view->GetLocationEntryOrigin(),
        gfx::Size(0, location_bar_view->location_entry_view()->height()));
  }
  return views::BubbleDelegateView::GetAnchorRect();
}

void ExtensionInstalledBubbleGtk::ShowInternal() {
BrowserWindowGtk* browser_window =
BrowserWindowGtk::GetBrowserWindowForNativeWindow(
browser_->window()->GetNativeHandle());

GtkWidget* reference_widget = NULL;

if (type_ == BROWSER_ACTION) {
BrowserActionsToolbarGtk* toolbar =
browser_window->GetToolbar()->GetBrowserActionsToolbar();

if (toolbar->animating() && animation_wait_retries_-- > 0) {
MessageLoopForUI::current()->PostDelayedTask(
FROM_HERE,
base::Bind(&ExtensionInstalledBubbleGtk::ShowInternal, this),
base::TimeDelta::FromMilliseconds(kAnimationWaitMS));
return;
}

reference_widget = toolbar->GetBrowserActionWidget(extension_);
// glib delays recalculating layout, but we need reference_widget to know
// its coordinates, so we force a check_resize here.
gtk_container_check_resize(GTK_CONTAINER(
browser_window->GetToolbar()->widget()));
// If the widget is not visible then browser_window could be incognito
// with this extension disabled. Try showing it on the chevron.
// If that fails, fall back to default position.
if (reference_widget && !gtk_widget_get_visible(reference_widget)) {
reference_widget = gtk_widget_get_visible(toolbar->chevron()) ?
toolbar->chevron() : NULL;
}
} else if (type_ == PAGE_ACTION) {
LocationBarViewGtk* location_bar_view =
browser_window->GetToolbar()->GetLocationBarView();
location_bar_view->SetPreviewEnabledPageAction(extension_->page_action(),
true);  // preview_enabled
reference_widget = location_bar_view->GetPageActionWidget(
extension_->page_action());
// glib delays recalculating layout, but we need reference_widget to know
// it's coordinates, so we force a check_resize here.
gtk_container_check_resize(GTK_CONTAINER(
browser_window->GetToolbar()->widget()));
DCHECK(reference_widget);
} else if (type_ == OMNIBOX_KEYWORD) {
LocationBarViewGtk* location_bar_view =
browser_window->GetToolbar()->GetLocationBarView();
reference_widget = location_bar_view->location_entry_widget();
DCHECK(reference_widget);
}

// Default case.
if (reference_widget == NULL)
reference_widget = browser_window->GetToolbar()->GetAppMenuButton();

GtkThemeService* theme_provider = GtkThemeService::GetFrom(
browser_->profile());

// Setup the BubbleGtk content.
GtkWidget* bubble_content = gtk_hbox_new(FALSE, kHorizontalColumnSpacing);
gtk_container_set_border_width(GTK_CONTAINER(bubble_content), kContentBorder);

if (!icon_.isNull()) {
// Scale icon down to 43x43, but allow smaller icons (don't scale up).
GdkPixbuf* pixbuf = gfx::GdkPixbufFromSkBitmap(&icon_);
gfx::Size size(icon_.width(), icon_.height());
if (size.width() > kIconSize || size.height() > kIconSize) {
if (size.width() > size.height()) {
size.set_height(size.height() * kIconSize / size.width());
size.set_width(kIconSize);
} else {
size.set_width(size.width() * kIconSize / size.height());
size.set_height(kIconSize);
}

GdkPixbuf* old = pixbuf;
pixbuf = gdk_pixbuf_scale_simple(pixbuf, size.width(), size.height(),
GDK_INTERP_BILINEAR);
g_object_unref(old);
}

// Put Icon in top of the left column.
GtkWidget* icon_column = gtk_vbox_new(FALSE, 0);
// Use 3 pixel padding to get visual balance with BubbleGtk border on the
// left.
gtk_box_pack_start(GTK_BOX(bubble_content), icon_column, FALSE, FALSE,
kIconPadding);
GtkWidget* image = gtk_image_new_from_pixbuf(pixbuf);
g_object_unref(pixbuf);
gtk_box_pack_start(GTK_BOX(icon_column), image, FALSE, FALSE, 0);
}

// Center text column.
GtkWidget* text_column = gtk_vbox_new(FALSE, kTextColumnVerticalSpacing);
gtk_box_pack_start(GTK_BOX(bubble_content), text_column, FALSE, FALSE, 0);

// Heading label
GtkWidget* heading_label = gtk_label_new(NULL);
string16 extension_name = UTF8ToUTF16(extension_->name());
base::i18n::AdjustStringForLocaleDirection(&extension_name);
std::string heading_text = l10n_util::GetStringFUTF8(
      IDS_EXTENSION_INSTALLED_HEADING, extension_name,
      l10n_util::GetStringUTF16(IDS_SHORT_PRODUCT_NAME));
char* markup = g_markup_printf_escaped("<span size=\"larger\">%s</span>",
heading_text.c_str());
gtk_label_set_markup(GTK_LABEL(heading_label), markup);
g_free(markup);

gtk_util::SetLabelWidth(heading_label, kTextColumnWidth);
gtk_box_pack_start(GTK_BOX(text_column), heading_label, FALSE, FALSE, 0);

// Page action label
if (type_ == PAGE_ACTION) {
GtkWidget* info_label = gtk_label_new(l10n_util::GetStringUTF8(
IDS_EXTENSION_INSTALLED_PAGE_ACTION_INFO).c_str());
gtk_util::SetLabelWidth(info_label, kTextColumnWidth);
gtk_box_pack_start(GTK_BOX(text_column), info_label, FALSE, FALSE, 0);
}

// Omnibox keyword label
if (type_ == OMNIBOX_KEYWORD) {
GtkWidget* info_label = gtk_label_new(l10n_util::GetStringFUTF8(
IDS_EXTENSION_INSTALLED_OMNIBOX_KEYWORD_INFO,
UTF8ToUTF16(extension_->omnibox_keyword())).c_str());
gtk_util::SetLabelWidth(info_label, kTextColumnWidth);
gtk_box_pack_start(GTK_BOX(text_column), info_label, FALSE, FALSE, 0);
}

// Manage label
GtkWidget* manage_label = gtk_label_new(
l10n_util::GetStringUTF8(IDS_EXTENSION_INSTALLED_MANAGE_INFO).c_str());
gtk_util::SetLabelWidth(manage_label, kTextColumnWidth);
gtk_box_pack_start(GTK_BOX(text_column), manage_label, FALSE, FALSE, 0);

// Create and pack the close button.
GtkWidget* close_column = gtk_vbox_new(FALSE, 0);
gtk_box_pack_start(GTK_BOX(bubble_content), close_column, FALSE, FALSE, 0);
close_button_.reset(CustomDrawButton::CloseButton(theme_provider));
g_signal_connect(close_button_->widget(), "clicked",
G_CALLBACK(OnButtonClick), this);
gtk_box_pack_start(GTK_BOX(close_column), close_button_->widget(),
FALSE, FALSE, 0);

BubbleGtk::ArrowLocationGtk arrow_location =
!base::i18n::IsRTL() ?
BubbleGtk::ARROW_LOCATION_TOP_RIGHT :
BubbleGtk::ARROW_LOCATION_TOP_LEFT;

gfx::Rect bounds = gtk_util::WidgetBounds(reference_widget);
if (type_ == OMNIBOX_KEYWORD) {
// Reverse the arrow for omnibox keywords, since the bubble will be on the
// other side of the window. We also clear the width to avoid centering
// the popup on the URL bar.
arrow_location =
!base::i18n::IsRTL() ?
BubbleGtk::ARROW_LOCATION_TOP_LEFT :
BubbleGtk::ARROW_LOCATION_TOP_RIGHT;
if (base::i18n::IsRTL())
bounds.Offset(bounds.width(), 0);
bounds.set_width(0);
}

bubble_ = BubbleGtk::Show(reference_widget,
&bounds,
bubble_content,
arrow_location,
true,  // match_system_theme
true,  // grab_input
theme_provider,
this);
}

void ExtensionContextMenuModel::InitCommonCommands() {
const Extension* extension = GetExtension();

// The extension pointer should only be null if the extension was uninstalled,
// and since the menu just opened, it should still be installed.
DCHECK(extension);

AddItem(NAME, UTF8ToUTF16(extension->name()));
AddSeparator();
AddItemWithStringId(CONFIGURE, IDS_EXTENSIONS_OPTIONS);
AddItemWithStringId(DISABLE, IDS_EXTENSIONS_DISABLE);
  AddItem(UNINSTALL, l10n_util::GetStringFUTF16(IDS_EXTENSIONS_UNINSTALL,
      l10n_util::GetStringUTF16(IDS_SHORT_PRODUCT_NAME)));
if (extension->browser_action())
AddItemWithStringId(HIDE, IDS_EXTENSIONS_HIDE_BUTTON);
AddSeparator();
AddItemWithStringId(MANAGE, IDS_MANAGE_EXTENSIONS);
}

void NTPResourceCache::Observe(int type,
    const content::NotificationSource& source,
    const content::NotificationDetails& details) {
  if (chrome::NOTIFICATION_BROWSER_THEME_CHANGED == type ||
      chrome::NOTIFICATION_PROMO_RESOURCE_STATE_CHANGED == type) {
    new_tab_incognito_html_ = NULL;
    new_tab_html_ = NULL;
    new_tab_incognito_css_ = NULL;
    new_tab_css_ = NULL;
  } else if (chrome::NOTIFICATION_PREF_CHANGED == type ||
              chrome::NTP4_INTRO_PREF_CHANGED) {
    new_tab_incognito_html_ = NULL;
    new_tab_html_ = NULL;
  } else {
    NOTREACHED();
  }
}

PanelSettingsMenuModel::PanelSettingsMenuModel(Panel* panel)
: ALLOW_THIS_IN_INITIALIZER_LIST(ui::SimpleMenuModel(this)),
panel_(panel) {
const Extension* extension = panel_->GetExtension();
DCHECK(extension);

AddItem(COMMAND_NAME, UTF8ToUTF16(extension->name()));
AddSeparator();
AddItem(COMMAND_CONFIGURE, l10n_util::GetStringUTF16(IDS_EXTENSIONS_OPTIONS));
AddItem(COMMAND_DISABLE, l10n_util::GetStringUTF16(IDS_EXTENSIONS_DISABLE));
AddItem(COMMAND_UNINSTALL,
      l10n_util::GetStringFUTF16(IDS_EXTENSIONS_UNINSTALL,
          l10n_util::GetStringUTF16(IDS_SHORT_PRODUCT_NAME)));
AddSeparator();
AddItem(COMMAND_MANAGE, l10n_util::GetStringUTF16(IDS_MANAGE_EXTENSIONS));
}

ExtensionGlobalError::~ExtensionGlobalError() {
}

void ExtensionGlobalError::set_accept_callback(
    ExtensionGlobalErrorCallback callback) {
  accept_callback_ = callback;
}

DictionaryValue* ExtensionSettingsHandler::CreateExtensionDetailValue(
    ExtensionService* service, const Extension* extension,
    const std::vector<ExtensionPage>& pages,
    const ExtensionWarningSet* warnings_set,
    bool enabled, bool terminated) {
  DictionaryValue* extension_data = new DictionaryValue();
  GURL icon =
      ExtensionIconSource::GetIconURL(extension,
                                      Extension::EXTENSION_ICON_MEDIUM,
                                      ExtensionIconSet::MATCH_BIGGER,
                                      !enabled, NULL);
  extension_data->SetString("id", extension->id());
  extension_data->SetString("name", extension->name());
  extension_data->SetString("description", extension->description());
  if (extension->location() == Extension::LOAD)
    extension_data->SetString("path", extension->path().value());
  extension_data->SetString("version", extension->version()->GetString());
  extension_data->SetString("icon", icon.spec());
  extension_data->SetBoolean("isUnpacked",
                             extension->location() == Extension::LOAD);
  extension_data->SetBoolean("mayDisable",
                             Extension::UserMayDisable(extension->location()));
  extension_data->SetBoolean("enabled", enabled);
  extension_data->SetBoolean("terminated", terminated);
  extension_data->SetBoolean("enabledIncognito",
      service ? service->IsIncognitoEnabled(extension->id()) : false);
  extension_data->SetBoolean("wantsFileAccess", extension->wants_file_access());
  extension_data->SetBoolean("allowFileAccess",
      service ? service->AllowFileAccess(extension) : false);
  extension_data->SetBoolean("allow_reload",
                             extension->location() == Extension::LOAD);
  extension_data->SetBoolean("is_hosted_app", extension->is_hosted_app());

  if (extension->location() == Extension::LOAD)
    extension_data->SetInteger("order", 1);
  else
    extension_data->SetInteger("order", 2);

  if (!extension->options_url().is_empty() && enabled)
    extension_data->SetString("options_url", extension->options_url().spec());

  if (service && !service->GetBrowserActionVisibility(extension))
    extension_data->SetBoolean("enable_show_button", true);

  ListValue* views = new ListValue;
  for (std::vector<ExtensionPage>::const_iterator iter = pages.begin();
       iter != pages.end(); ++iter) {
    DictionaryValue* view_value = new DictionaryValue;
    if (iter->url.scheme() == chrome::kExtensionScheme) {
      view_value->SetString("path", iter->url.path().substr(1));
    } else {
      view_value->SetString("path", iter->url.spec());
    }
    view_value->SetInteger("renderViewId", iter->render_view_id);
    view_value->SetInteger("renderProcessId", iter->render_process_id);
    view_value->SetBoolean("incognito", iter->incognito);
    views->Append(view_value);
  }
  extension_data->Set("views", views);
  extension_data->SetBoolean("hasPopupAction",
      extension->browser_action() || extension->page_action());
  extension_data->SetString("homepageUrl", extension->GetHomepageURL().spec());

  ListValue* warnings_list = new ListValue;
  if (warnings_set) {
    std::set<ExtensionWarningSet::WarningType> warnings;
    warnings_set->GetWarningsAffectingExtension(extension->id(), &warnings);

    for (std::set<ExtensionWarningSet::WarningType>::const_iterator iter =
             warnings.begin();
         iter != warnings.end();
         ++iter) {
      string16 warning_string(ExtensionWarningSet::GetLocalizedWarning(*iter));
      warnings_list->Append(Value::CreateStringValue(warning_string));
    }
  }
  extension_data->Set("warnings", warnings_list);

  return extension_data;
}

void ExtensionInstalledBubble::ShowInternal() {
  BrowserView* browser_view = BrowserView::GetBrowserViewForBrowser(browser_);

  views::View* reference_view = NULL;
  if (type_ == APP) {
    if (browser_view->IsTabStripVisible()) {
      AbstractTabStripView* tabstrip = browser_view->tabstrip();
      views::View* ntp_button = tabstrip->GetNewTabButton();
      if (ntp_button && ntp_button->IsDrawn()) {
        reference_view = ntp_button;
      } else {
        reference_view = tabstrip;
      }
    }
  } else if (type_ == BROWSER_ACTION) {
    BrowserActionsContainer* container =
        browser_view->GetToolbarView()->browser_actions();
    if (container->animating() &&
        animation_wait_retries_++ < kAnimationWaitMaxRetry) {
      MessageLoopForUI::current()->PostDelayedTask(
          FROM_HERE,
          base::Bind(&ExtensionInstalledBubble::ShowInternal,
                     base::Unretained(this)),
          kAnimationWaitTime);
      return;
    }
    reference_view = container->GetBrowserActionView(
        extension_->browser_action());
    if (!reference_view || !reference_view->visible()) {
      reference_view = container->chevron();
      if (!reference_view || !reference_view->visible())
        reference_view = NULL;  // fall back to app menu below.
    }
  } else if (type_ == PAGE_ACTION) {
    LocationBarView* location_bar_view = browser_view->GetLocationBarView();
    location_bar_view->SetPreviewEnabledPageAction(extension_->page_action(),
                                                   true);  // preview_enabled
    reference_view = location_bar_view->GetPageActionView(
        extension_->page_action());
    DCHECK(reference_view);
  } else if (type_ == OMNIBOX_KEYWORD) {
    LocationBarView* location_bar_view = browser_view->GetLocationBarView();
    reference_view = location_bar_view;
    DCHECK(reference_view);
  }

  if (reference_view == NULL)
    reference_view = browser_view->GetToolbarView()->app_menu();
  set_anchor_view(reference_view);

  set_arrow_location(type_ == OMNIBOX_KEYWORD ? views::BubbleBorder::TOP_LEFT :
                                                views::BubbleBorder::TOP_RIGHT);
  SetLayoutManager(new views::FillLayout());
  AddChildView(
      new InstalledBubbleContent(browser_, extension_, type_, &icon_, this));
  browser::CreateViewsBubble(this);
  StartFade(true);
}

void ExtensionSettingsHandler::RegisterUserPrefs(PrefService* prefs) {
  prefs->RegisterBooleanPref(prefs::kExtensionsUIDeveloperMode,
                             false,
                             PrefService::SYNCABLE_PREF);
}

ExtensionContextMenuModel::ExtensionContextMenuModel(
    const Extension* extension,
    Browser* browser,
    PopupDelegate* delegate)
    : ALLOW_THIS_IN_INITIALIZER_LIST(SimpleMenuModel(this)),
      extension_id_(extension->id()),
      browser_(browser),
      profile_(browser->profile()),
      delegate_(delegate) {
  extension_action_ = extension->browser_action();
  if (!extension_action_)
    extension_action_ = extension->page_action();

  InitCommonCommands();

  if (profile_->GetPrefs()->GetBoolean(prefs::kExtensionsUIDeveloperMode) &&
      delegate_) {
    AddSeparator();
    AddItemWithStringId(INSPECT_POPUP, IDS_EXTENSION_ACTION_INSPECT_POPUP);
  }
}

void ExtensionGlobalError::AddBlacklistedExtension(const std::string& id) {
  blacklisted_extension_ids_->insert(id);
}

string16 ExtensionGlobalError::GetBubbleViewCancelButtonLabel() {
  return l10n_util::GetStringUTF16(IDS_EXTENSION_ALERT_ITEM_DETAILS);
}

void ExtensionGlobalError::ExecuteMenuItem(Browser* browser) {
  NOTREACHED();
}

const Extension* ExtensionContextMenuModel::GetExtension() const {
  ExtensionService* extension_service = profile_->GetExtensionService();
  return extension_service->GetExtensionById(extension_id_, false);
}

void NTPResourceCache::CreateNewTabHTML() {
// TODO(estade): these strings should be defined in their relevant handlers
// (in GetLocalizedValues) and should have more legible names.
// Show the profile name in the title and most visited labels if the current
// profile is not the default.
DictionaryValue localized_strings;
localized_strings.SetString("bookmarkbarattached",
profile_->GetPrefs()->GetBoolean(prefs::kShowBookmarkBar) ?
"true" : "false");
localized_strings.SetString("hasattribution",
ThemeServiceFactory::GetForProfile(profile_)->HasCustomImage(
IDR_THEME_NTP_ATTRIBUTION) ?
"true" : "false");
localized_strings.SetString("title",
l10n_util::GetStringUTF16(IDS_NEW_TAB_TITLE));
localized_strings.SetString("mostvisited",
l10n_util::GetStringUTF16(IDS_NEW_TAB_MOST_VISITED));
localized_strings.SetString("restoreThumbnailsShort",
l10n_util::GetStringUTF16(IDS_NEW_TAB_RESTORE_THUMBNAILS_SHORT_LINK));
localized_strings.SetString("recentlyclosed",
l10n_util::GetStringUTF16(IDS_NEW_TAB_RECENTLY_CLOSED));
localized_strings.SetString("closedwindowsingle",
l10n_util::GetStringUTF16(IDS_NEW_TAB_RECENTLY_CLOSED_WINDOW_SINGLE));
localized_strings.SetString("closedwindowmultiple",
l10n_util::GetStringUTF16(IDS_NEW_TAB_RECENTLY_CLOSED_WINDOW_MULTIPLE));
localized_strings.SetString("attributionintro",
l10n_util::GetStringUTF16(IDS_NEW_TAB_ATTRIBUTION_INTRO));
localized_strings.SetString("thumbnailremovednotification",
l10n_util::GetStringUTF16(IDS_NEW_TAB_THUMBNAIL_REMOVED_NOTIFICATION));
localized_strings.SetString("undothumbnailremove",
l10n_util::GetStringUTF16(IDS_NEW_TAB_UNDO_THUMBNAIL_REMOVE));
localized_strings.SetString("removethumbnailtooltip",
l10n_util::GetStringUTF16(IDS_NEW_TAB_REMOVE_THUMBNAIL_TOOLTIP));
localized_strings.SetString("appuninstall",
      l10n_util::GetStringFUTF16(
          IDS_EXTENSIONS_UNINSTALL,
          l10n_util::GetStringUTF16(IDS_SHORT_PRODUCT_NAME)));
localized_strings.SetString("appoptions",
l10n_util::GetStringUTF16(IDS_NEW_TAB_APP_OPTIONS));
localized_strings.SetString("appdisablenotifications",
l10n_util::GetStringUTF16(IDS_NEW_TAB_APP_DISABLE_NOTIFICATIONS));
localized_strings.SetString("appcreateshortcut",
l10n_util::GetStringUTF16(IDS_NEW_TAB_APP_CREATE_SHORTCUT));
localized_strings.SetString("appDefaultPageName",
l10n_util::GetStringUTF16(IDS_APP_DEFAULT_PAGE_NAME));
localized_strings.SetString("applaunchtypepinned",
l10n_util::GetStringUTF16(IDS_APP_CONTEXT_MENU_OPEN_PINNED));
localized_strings.SetString("applaunchtyperegular",
l10n_util::GetStringUTF16(IDS_APP_CONTEXT_MENU_OPEN_REGULAR));
localized_strings.SetString("applaunchtypewindow",
l10n_util::GetStringUTF16(IDS_APP_CONTEXT_MENU_OPEN_WINDOW));
localized_strings.SetString("applaunchtypefullscreen",
l10n_util::GetStringUTF16(IDS_APP_CONTEXT_MENU_OPEN_FULLSCREEN));
localized_strings.SetString("syncpromotext",
l10n_util::GetStringUTF16(IDS_SYNC_START_SYNC_BUTTON_LABEL));
localized_strings.SetString("syncLinkText",
l10n_util::GetStringUTF16(IDS_SYNC_ADVANCED_OPTIONS));
#if defined(OS_CHROMEOS)
localized_strings.SetString("expandMenu",
l10n_util::GetStringUTF16(IDS_NEW_TAB_CLOSE_MENU_EXPAND));
#endif

NewTabPageHandler::GetLocalizedValues(profile_, &localized_strings);
NTPLoginHandler::GetLocalizedValues(profile_, &localized_strings);

// Don't initiate the sync related message passing with the page if the sync
// code is not present.
if (profile_->GetProfileSyncService())
localized_strings.SetString("syncispresent", "true");
else
localized_strings.SetString("syncispresent", "false");

ChromeURLDataManager::DataSource::SetFontAndTextDirection(&localized_strings);

// Control fade and resize animations.
std::string anim =
ui::Animation::ShouldRenderRichAnimation() ? "true" : "false";
localized_strings.SetString("anim", anim);

int alignment;
ui::ThemeProvider* tp = ThemeServiceFactory::GetForProfile(profile_);
tp->GetDisplayProperty(ThemeService::NTP_BACKGROUND_ALIGNMENT, &alignment);
localized_strings.SetString("themegravity",
(alignment & ThemeService::ALIGN_RIGHT) ? "right" : "");

// If the user has preferences for a start and end time for a custom logo,
// and the time now is between these two times, show the custom logo.
if (profile_->GetPrefs()->FindPreference(prefs::kNTPCustomLogoStart) &&
profile_->GetPrefs()->FindPreference(prefs::kNTPCustomLogoEnd)) {
localized_strings.SetString("customlogo",
InDateRange(profile_->GetPrefs()->GetDouble(prefs::kNTPCustomLogoStart),
profile_->GetPrefs()->GetDouble(prefs::kNTPCustomLogoEnd)) ?
"true" : "false");
} else {
localized_strings.SetString("customlogo", "false");
}

// If the user has preferences for a start and end time for a promo from
// the server, and this promo string exists, set the localized string.
if (PromoResourceService::CanShowNotificationPromo(profile_)) {
localized_strings.SetString("serverpromo",
profile_->GetPrefs()->GetString(prefs::kNTPPromoLine));
}

// Load the new tab page appropriate for this build
std::string full_html;
base::StringPiece new_tab_html(ResourceBundle::GetSharedInstance().
GetRawDataResource(IDR_NEW_TAB_4_HTML));
full_html = jstemplate_builder::GetI18nTemplateHtml(new_tab_html,
&localized_strings);
new_tab_html_ = base::RefCountedString::TakeString(&full_html);
}

void ExtensionSettingsHandler::HandleSelectFilePathMessage(
    const ListValue* args) {
  std::string select_type;
  std::string operation;
  CHECK_EQ(2U, args->GetSize());
  CHECK(args->GetString(0, &select_type));
  CHECK(args->GetString(1, &operation));

  SelectFileDialog::Type type = SelectFileDialog::SELECT_FOLDER;
  SelectFileDialog::FileTypeInfo info;
  int file_type_index = 0;
  if (select_type == "file")
    type = SelectFileDialog::SELECT_OPEN_FILE;

  string16 select_title;
  if (operation == "load") {
    select_title = l10n_util::GetStringUTF16(IDS_EXTENSION_LOAD_FROM_DIRECTORY);
  } else if (operation == "packRoot") {
    select_title = l10n_util::GetStringUTF16(
        IDS_EXTENSION_PACK_DIALOG_SELECT_ROOT);
  } else if (operation == "pem") {
    select_title = l10n_util::GetStringUTF16(
        IDS_EXTENSION_PACK_DIALOG_SELECT_KEY);
    info.extensions.push_back(std::vector<FilePath::StringType>());
        info.extensions.front().push_back(FILE_PATH_LITERAL("pem"));
        info.extension_description_overrides.push_back(
            l10n_util::GetStringUTF16(
                IDS_EXTENSION_PACK_DIALOG_KEY_FILE_TYPE_DESCRIPTION));
        info.include_all_files = true;
    file_type_index = 1;
  } else {
    NOTREACHED();
    return;
  }

  load_extension_dialog_ = SelectFileDialog::Create(this);
  load_extension_dialog_->SelectFile(type, select_title, FilePath(), &info,
      file_type_index, FILE_PATH_LITERAL(""), web_ui()->web_contents(),
      web_ui()->web_contents()->GetView()->GetTopLevelNativeWindow(), NULL);
}

void ExtensionInstalledBubbleGtk::BubbleClosing(BubbleGtk* bubble,
                                                bool closed_by_escape) {
  if (extension_ && type_ == PAGE_ACTION) {
    BrowserWindowGtk* browser_window =
          BrowserWindowGtk::GetBrowserWindowForNativeWindow(
              browser_->window()->GetNativeHandle());
    LocationBarViewGtk* location_bar_view =
        browser_window->GetToolbar()->GetLocationBarView();
    location_bar_view->SetPreviewEnabledPageAction(extension_->page_action(),
                                                   false);  // preview_enabled
  }

  MessageLoopForUI::current()->PostTask(
      FROM_HERE,
      base::Bind(&ExtensionInstalledBubbleGtk::Close, this));
}

void ShowExtensionInstalledBubble(
    const Extension* extension,
    Browser* browser,
    const SkBitmap& icon,
    Profile* profile) {
  ExtensionInstalledBubbleGtk::Show(extension, browser, icon);
}

void NTPResourceCache::CreateNewTabIncognitoCSS() {
  ui::ThemeProvider* tp = ThemeServiceFactory::GetForProfile(profile_);
  DCHECK(tp);

  SkColor color_background =
      tp->GetColor(ThemeService::COLOR_NTP_BACKGROUND);

  std::vector<std::string> subst;

  subst.push_back(
      profile_->GetPrefs()->GetString(prefs::kCurrentThemeID));  // $1

  subst.push_back(SkColorToRGBAString(color_background));  // $2
  subst.push_back(GetNewTabBackgroundCSS(tp, false));  // $3
  subst.push_back(GetNewTabBackgroundCSS(tp, true));  // $4
  subst.push_back(GetNewTabBackgroundTilingCSS(tp));  // $5

  static const base::StringPiece new_tab_theme_css(
      ResourceBundle::GetSharedInstance().GetRawDataResource(
      IDR_NEW_INCOGNITO_TAB_THEME_CSS));

  std::string full_css = ReplaceStringPlaceholders(
      new_tab_theme_css, subst, NULL);

  new_tab_incognito_css_ = base::RefCountedString::TakeString(&full_css);
}

string16 ExtensionInstallUI::Prompt::GetHeading(
    const std::string& extension_name) const {
  if (type_ == INLINE_INSTALL_PROMPT) {
    return UTF8ToUTF16(extension_name);
  } else {
    return l10n_util::GetStringFUTF16(
        kHeadingIds[type_], UTF8ToUTF16(extension_name));
  }
}

bool PanelSettingsMenuModel::GetAcceleratorForCommandId(
    int command_id, ui::Accelerator* accelerator) {
  return false;
}

  virtual void Layout() {
    int x = kHorizOuterMargin;
    int y = kVertOuterMargin;

    icon_->SetBounds(x, y, kIconSize, kIconSize);
    x += kIconSize;
    x += views::kPanelHorizMargin;

    y += kRightcolumnVerticalShift;
    heading_->SizeToFit(kRightColumnWidth);
    heading_->SetX(x);
    heading_->SetY(y);
    y += heading_->height();
    y += kVertInnerMargin;

    if (info_) {
      info_->SizeToFit(kRightColumnWidth);
      info_->SetX(x);
      info_->SetY(y);
      y += info_->height();
      y += kVertInnerMargin;
    }

    manage_->SizeToFit(kRightColumnWidth);
    manage_->SetX(x);
    manage_->SetY(y);
    y += manage_->height();
    y += kVertInnerMargin;

    gfx::Size sz;
    x += kRightColumnWidth + 2 * views::kPanelHorizMargin + kHorizOuterMargin -
        close_button_->GetPreferredSize().width();
    y = kVertOuterMargin;
    sz = close_button_->GetPreferredSize();
    close_button_->SetBounds(x - 1, y - 1, sz.width(), sz.height());
  }

void ExtensionSettingsHandler::HandleAllowFileAccessMessage(
    const ListValue* args) {
  CHECK_EQ(2U, args->GetSize());
  std::string extension_id, allow_str;
  CHECK(args->GetString(0, &extension_id));
  CHECK(args->GetString(1, &allow_str));
  const Extension* extension =
      extension_service_->GetExtensionById(extension_id, true);
  DCHECK(extension);

  if (!Extension::UserMayDisable(extension->location())) {
    LOG(ERROR) << "Attempt to change allow file access of an extension that is "
               << "non-usermanagable was made. Extension id : "
               << extension->id();
    return;
  }

  extension_service_->SetAllowFileAccess(extension, allow_str == "true");
}

void ExtensionInstalledBubbleGtk::Close() {
  Release();  // Balanced in ctor.
  bubble_ = NULL;
}

void ExtensionSettingsHandler::ExtensionUninstallCanceled() {
  extension_id_prompting_ = "";
}

void ExtensionSettingsHandler::HandleShowButtonMessage(const ListValue* args) {
  const Extension* extension = GetExtension(args);
  extension_service_->SetBrowserActionVisibility(extension, true);
}

void ExtensionInstalledBubble::WindowClosing() {
  if (extension_ && type_ == PAGE_ACTION) {
    BrowserView* browser_view = BrowserView::GetBrowserViewForBrowser(browser_);
    browser_view->GetLocationBarView()->SetPreviewEnabledPageAction(
        extension_->page_action(),
        false);  // preview_enabled
  }
}

void ShowExtensionInstalledBubble(
    const Extension* extension,
    Browser* browser,
    const SkBitmap& icon,
    Profile* profile) {
  ExtensionInstalledBubble::Show(extension, browser, icon);
}

void ExtensionSettingsHandler::HandleEnableIncognitoMessage(
    const ListValue* args) {
  CHECK_EQ(2U, args->GetSize());
  std::string extension_id, enable_str;
  CHECK(args->GetString(0, &extension_id));
  CHECK(args->GetString(1, &enable_str));
  const Extension* extension =
      extension_service_->GetExtensionById(extension_id, true);
  DCHECK(extension);

  AutoReset<bool> auto_reset_ignore_notifications(&ignore_notifications_, true);
  extension_service_->SetIsIncognitoEnabled(extension->id(),
                                            enable_str == "true");
}

void ExtensionSettingsHandler::ShowAlert(const std::string& message) {
  ListValue arguments;
  arguments.Append(Value::CreateStringValue(message));
  web_ui()->CallJavascriptFunction("alert", arguments);
}

void PanelSettingsMenuModel::ExecuteCommand(int command_id) {
  const Extension* extension = panel_->GetExtension();
  DCHECK(extension);

  Browser* browser = panel_->browser();
  switch (command_id) {
    case COMMAND_NAME: {
      OpenURLParams params(
          extension->GetHomepageURL(), Referrer(), NEW_FOREGROUND_TAB,
          content::PAGE_TRANSITION_LINK, false);
      browser->OpenURL(params);
      break;
    }
    case COMMAND_CONFIGURE:
      DCHECK(!extension->options_url().is_empty());
      browser->GetProfile()->GetExtensionProcessManager()->OpenOptionsPage(
          extension, browser);
      break;
    case COMMAND_DISABLE:
      browser->GetProfile()->GetExtensionService()->DisableExtension(
          extension->id());
      break;
    case COMMAND_UNINSTALL:
      extension_uninstall_dialog_.reset(
          ExtensionUninstallDialog::Create(browser->GetProfile(), this));
      extension_uninstall_dialog_->ConfirmUninstall(extension);
      break;
    case COMMAND_MANAGE:
      browser->ShowOptionsTab(chrome::kExtensionsSubPage);
      break;
    default:
      NOTREACHED();
      break;
  }
}

bool ShouldShowExtension(const Extension* extension) {
  if (extension->is_theme())
    return false;

  if (extension->location() == Extension::COMPONENT &&
      !CommandLine::ForCurrentProcess()->HasSwitch(
        switches::kShowComponentExtensionOptions))
    return false;

  if (extension->location() == Extension::LOAD)
    return true;

  if (extension->is_hosted_app())
    return false;

  return true;
}

void ExtensionGlobalError::AddExternalExtension(const std::string& id) {
  external_extension_ids_->insert(id);
}

void ExtensionSettingsHandler::HandleInspectMessage(const ListValue* args) {
  std::string render_process_id_str;
  std::string render_view_id_str;
  int render_process_id;
  int render_view_id;
  CHECK_EQ(2U, args->GetSize());
  CHECK(args->GetString(0, &render_process_id_str));
  CHECK(args->GetString(1, &render_view_id_str));
  CHECK(base::StringToInt(render_process_id_str, &render_process_id));
  CHECK(base::StringToInt(render_view_id_str, &render_view_id));
  RenderViewHost* host = RenderViewHost::FromID(render_process_id,
                                                render_view_id);
  if (!host) {
    return;
  }

  DevToolsWindow::OpenDevToolsWindow(host);
}

void ExtensionSettingsHandler::RegisterMessages() {
  extension_service_ = Profile::FromWebUI(web_ui())->GetOriginalProfile()->
      GetExtensionService();

  web_ui()->RegisterMessageCallback("extensionSettingsRequestExtensionsData",
      base::Bind(&ExtensionSettingsHandler::HandleRequestExtensionsData,
                 base::Unretained(this)));
  web_ui()->RegisterMessageCallback("extensionSettingsToggleDeveloperMode",
      base::Bind(&ExtensionSettingsHandler::HandleToggleDeveloperMode,
                 base::Unretained(this)));
  web_ui()->RegisterMessageCallback("extensionSettingsInspect",
      base::Bind(&ExtensionSettingsHandler::HandleInspectMessage,
                 base::Unretained(this)));
  web_ui()->RegisterMessageCallback("extensionSettingsReload",
      base::Bind(&ExtensionSettingsHandler::HandleReloadMessage,
                 base::Unretained(this)));
  web_ui()->RegisterMessageCallback("extensionSettingsEnable",
      base::Bind(&ExtensionSettingsHandler::HandleEnableMessage,
                 base::Unretained(this)));
  web_ui()->RegisterMessageCallback("extensionSettingsEnableIncognito",
      base::Bind(&ExtensionSettingsHandler::HandleEnableIncognitoMessage,
                 base::Unretained(this)));
  web_ui()->RegisterMessageCallback("extensionSettingsAllowFileAccess",
      base::Bind(&ExtensionSettingsHandler::HandleAllowFileAccessMessage,
                 base::Unretained(this)));
  web_ui()->RegisterMessageCallback("extensionSettingsUninstall",
      base::Bind(&ExtensionSettingsHandler::HandleUninstallMessage,
                 base::Unretained(this)));
  web_ui()->RegisterMessageCallback("extensionSettingsOptions",
      base::Bind(&ExtensionSettingsHandler::HandleOptionsMessage,
                 base::Unretained(this)));
  web_ui()->RegisterMessageCallback("extensionSettingsShowButton",
      base::Bind(&ExtensionSettingsHandler::HandleShowButtonMessage,
                 base::Unretained(this)));
  web_ui()->RegisterMessageCallback("extensionSettingsLoad",
      base::Bind(&ExtensionSettingsHandler::HandleLoadMessage,
                 base::Unretained(this)));
  web_ui()->RegisterMessageCallback("extensionSettingsAutoupdate",
      base::Bind(&ExtensionSettingsHandler::HandleAutoUpdateMessage,
                 base::Unretained(this)));
  web_ui()->RegisterMessageCallback("extensionSettingsSelectFilePath",
      base::Bind(&ExtensionSettingsHandler::HandleSelectFilePathMessage,
                 base::Unretained(this)));
}

std::string GetNewTabBackgroundTilingCSS(
    const ui::ThemeProvider* theme_provider) {
  int repeat_mode;
  theme_provider->GetDisplayProperty(
      ThemeService::NTP_BACKGROUND_TILING, &repeat_mode);
  return ThemeService::TilingToString(repeat_mode);
}

std::string SkColorToRGBComponents(SkColor color) {
  return base::StringPrintf(
      "%d,%d,%d",
      SkColorGetR(color),
      SkColorGetG(color),
      SkColorGetB(color));
}

void ExtensionGlobalError::BubbleViewCancelButtonPressed() {
  if (!cancel_callback_.is_null()) {
    cancel_callback_.Run(*this, current_browser_);
  }
}

void ExtensionSettingsHandler::MaybeUpdateAfterNotification() {
  WebContents* contents = web_ui()->web_contents();
  if (!ignore_notifications_ && contents && contents->GetRenderViewHost())
    HandleRequestExtensionsData(NULL);
  deleting_rvh_ = NULL;
}

RefCountedMemory* NTPResourceCache::GetNewTabCSS(bool is_incognito) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  if (is_incognito) {
    if (!new_tab_incognito_css_.get())
      CreateNewTabIncognitoCSS();
  } else {
    if (!new_tab_css_.get())
      CreateNewTabCSS();
  }
  return is_incognito ? new_tab_incognito_css_.get()
                      : new_tab_css_.get();
}

void ExtensionInstalledBubbleGtk::Observe(
    int type,
    const content::NotificationSource& source,
    const content::NotificationDetails& details) {
  if (type == chrome::NOTIFICATION_EXTENSION_LOADED) {
    const Extension* extension =
        content::Details<const Extension>(details).ptr();
    if (extension == extension_) {
      MessageLoopForUI::current()->PostTask(
          FROM_HERE,
          base::Bind(&ExtensionInstalledBubbleGtk::ShowInternal, this));
    }
  } else if (type == chrome::NOTIFICATION_EXTENSION_UNLOADED) {
    const Extension* extension =
        content::Details<UnloadedExtensionInfo>(details)->extension;
    if (extension == extension_)
      extension_ = NULL;
  } else {
    NOTREACHED() << L"Received unexpected notification";
  }
}

bool ExtensionGlobalError::HasBadge() {
  return false;
}

bool InDateRange(double begin, double end) {
  Time start_time = Time::FromDoubleT(begin);
  Time end_time = Time::FromDoubleT(end);
  return start_time < Time::Now() && end_time > Time::Now();
}

void ExtensionGlobalError::ShowBubbleView(Browser* browser) {
  current_browser_ = browser;
  GlobalError::ShowBubbleView(browser);
}

void ExtensionInstalledBubble::Observe(
    int type,
    const content::NotificationSource& source,
    const content::NotificationDetails& details) {
  if (type == chrome::NOTIFICATION_EXTENSION_LOADED) {
    const Extension* extension =
        content::Details<const Extension>(details).ptr();
    if (extension == extension_) {
      animation_wait_retries_ = 0;
      MessageLoopForUI::current()->PostTask(
          FROM_HERE,
          base::Bind(&ExtensionInstalledBubble::ShowInternal,
                     base::Unretained(this)));
    }
  } else if (type == chrome::NOTIFICATION_EXTENSION_UNLOADED) {
    const Extension* extension =
        content::Details<UnloadedExtensionInfo>(details)->extension;
    if (extension == extension_)
      extension_ = NULL;
  } else {
    NOTREACHED() << L"Received unexpected notification";
  }
}

bool ExtensionGlobalError::HasMenuItem() {
  return false;
}

bool PanelSettingsMenuModel::IsCommandIdChecked(int command_id) const {
  return false;
}

bool PanelSettingsMenuModel::IsCommandIdEnabled(int command_id) const {
  const Extension* extension = panel_->GetExtension();
  DCHECK(extension);

  switch (command_id) {
    case COMMAND_NAME:
      return extension->GetHomepageURL().is_valid();
    case COMMAND_CONFIGURE:
      return extension->options_url().spec().length() > 0;
    case COMMAND_DISABLE:
    case COMMAND_UNINSTALL:
      return Extension::UserMayDisable(extension->location());
    case COMMAND_MANAGE:
      return true;
    default:
      NOTREACHED();
      return false;
  }
}
