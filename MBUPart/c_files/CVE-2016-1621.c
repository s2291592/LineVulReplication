   virtual void SetUp() {
     int i;

    UUT = GetParam();
    memset(input, 0, sizeof(input));
 /* Set up guard blocks */
 for (i = 0; i < 256; i++) output[i] = ((i & 0xF) < 4 && (i < 64)) ? 0 : -1;
 }

void VarianceTest<VarianceFunctionType>::OneQuarterTest() {
  memset(src_, 255, block_size_);
const int half = block_size_ / 2;
  memset(ref_, 255, half);
  memset(ref_ + half, 0, half);
unsigned int sse;
unsigned int var;
  REGISTER_STATE_CHECK(var = variance_(src_, width_, ref_, width_, &sse));
const unsigned int expected = block_size_ * 255 * 255 / 4;
EXPECT_EQ(expected, var);
}

Track::Track(
    Segment* pSegment,
    long long element_start,
    long long element_size) :
    m_pSegment(pSegment),
    m_element_start(element_start),
    m_element_size(element_size),
    content_encoding_entries_(NULL),
    content_encoding_entries_end_(NULL)
{
}

 void Encoder::EncodeFrame(VideoSource *video, const unsigned long frame_flags) {
   if (video->img())
     EncodeFrameInternal(*video, frame_flags);
 else
 Flush();

 CxDataIterator iter = GetCxData();

 while (const vpx_codec_cx_pkt_t *pkt = iter.Next()) {
 if (pkt->kind != VPX_CODEC_STATS_PKT)
 continue;

    stats_->Append(*pkt);
 }
}

long Cluster::CreateBlockGroup(
    long long start_offset,
    long long size,
    long long discard_padding)
{
    assert(m_entries);
    assert(m_entries_size > 0);
    assert(m_entries_count >= 0);
    assert(m_entries_count < m_entries_size);

    IMkvReader* const pReader = m_pSegment->m_pReader;
    long long pos = start_offset;
    const long long stop = start_offset + size;
    //For WebM files, there is a bias towards previous reference times
    //(in order to support alt-ref frames, which refer back to the previous
    //keyframe).  Normally a 0 value is not possible, but here we tenatively
    //allow 0 as the value of a reference frame, with the interpretation
    //that this is a "previous" reference time.
    long long prev = 1;  //nonce
    long long next = 0;  //nonce
    long long duration = -1;  //really, this is unsigned
    long long bpos = -1;
    long long bsize = -1;
    while (pos < stop)
    {
        long len;
        const long long id = ReadUInt(pReader, pos, len);
        assert(id >= 0);  //TODO
        assert((pos + len) <= stop);
        pos += len;  //consume ID
        const long long size = ReadUInt(pReader, pos, len);
        assert(size >= 0);  //TODO
        assert((pos + len) <= stop);
        pos += len;  //consume size
        if (id == 0x21) //Block ID
        {
            if (bpos < 0) //Block ID
            {
                bpos = pos;
                bsize = size;
            }
        }
        else if (id == 0x1B)  //Duration ID
        {
            assert(size <= 8);
            duration = UnserializeUInt(pReader, pos, size);
            assert(duration >= 0);  //TODO
        }
        else if (id == 0x7B)  //ReferenceBlock
        {
            assert(size <= 8);
            const long size_ = static_cast<long>(size);
            long long time;
            long status = UnserializeInt(pReader, pos, size_, time);
            assert(status == 0);
            if (status != 0)
                return -1;
            if (time <= 0)  //see note above
                prev = time;
            else  //weird
                next = time;
        }
        pos += size;  //consume payload
        assert(pos <= stop);
}

    assert(pos == stop);
    assert(bpos >= 0);
    assert(bsize >= 0);

    const long idx = m_entries_count;
    BlockEntry** const ppEntry = m_entries + idx;
    BlockEntry*& pEntry = *ppEntry;
    pEntry = new (std::nothrow) BlockGroup(
                                  this,
                                  idx,
                                  bpos,
                                  bsize,
                                  prev,
                                  next,
                                  duration,
                                  discard_padding);
    if (pEntry == NULL)
        return -1;  //generic error
    BlockGroup* const p = static_cast<BlockGroup*>(pEntry);
    const long status = p->Parse();
    if (status == 0)  //success
    {
        ++m_entries_count;
        return 0;
    }
    delete pEntry;
    pEntry = 0;
    return status;
}

const Chapters::Edition* Chapters::GetEdition(int idx) const
{
    if (idx < 0)
        return NULL;

    if (idx >= m_editions_count)
        return NULL;

    return m_editions + idx;
}

 virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,
 ::libvpx_test::Encoder *encoder) {
 if (video->frame() == 1) {
      encoder->Control(VP8E_SET_CPUUSED, set_cpu_used_);
      encoder->Control(VP9E_SET_AQ_MODE, aq_mode_);
      encoder->Control(VP8E_SET_MAX_INTRA_BITRATE_PCT, 100);

     }
   }

 void CheckHPrediction() const {
 for (int p = 0; p < num_planes_; p++)
 for (int y = 0; y < block_size_; y++)
 for (int x = 0; x < block_size_; x++)
          ASSERT_EQ(data_ptr_[p][-1 + y * stride_],
                    data_ptr_[p][x + y * stride_]);
 }

long BlockEntry::GetIndex() const
{
    return m_index;
}

long long Cluster::GetLastTime() const
{
    const BlockEntry* pEntry;
    const long status = GetLast(pEntry);
    if (status < 0)  //error
        return status;
    if (pEntry == NULL)  //empty cluster
        return GetTime();
    const Block* const pBlock = pEntry->GetBlock();
    assert(pBlock);
    return pBlock->GetTime(this);
}

const Track* Tracks::GetTrackByNumber(long tn) const
{
    if (tn < 0)
        return NULL;
    Track** i = m_trackEntries;
    Track** const j = m_trackEntriesEnd;
    while (i != j)
    {
        Track* const pTrack = *i++;
        if (pTrack == NULL)
            continue;
        if (tn == pTrack->GetNumber())
            return pTrack;
    }
    return NULL;  //not found
}

TileIndependenceTest()
: EncoderTest(GET_PARAM(0)),
md5_fw_order_(),

md5_inv_order_(),
n_tiles_(GET_PARAM(1)) {
init_flags_ = VPX_CODEC_USE_PSNR;
    vpx_codec_dec_cfg_t cfg;
cfg.w = 704;
cfg.h = 144;
cfg.threads = 1;
fw_dec_ = codec_->CreateDecoder(cfg, 0);
inv_dec_ = codec_->CreateDecoder(cfg, 0);
inv_dec_->Control(VP9_INVERT_TILE_DECODE_ORDER, 1);
}

long Cluster::CreateSimpleBlock(
    long long st,
    long long sz)
{
    assert(m_entries);
    assert(m_entries_size > 0);
    assert(m_entries_count >= 0);
    assert(m_entries_count < m_entries_size);
    const long idx = m_entries_count;
    BlockEntry** const ppEntry = m_entries + idx;
    BlockEntry*& pEntry = *ppEntry;
    pEntry = new (std::nothrow) SimpleBlock(this, idx, st, sz);
    if (pEntry == NULL)
        return -1;  //generic error
    SimpleBlock* const p = static_cast<SimpleBlock*>(pEntry);
    const long status = p->Parse();
    if (status == 0)
    {
        ++m_entries_count;
        return 0;
    }
    delete pEntry;
    pEntry = 0;
    return status;
}

void RunAccuracyCheck() {
ACMRandom rnd(ACMRandom::DeterministicSeed());
uint32_t max_error = 0;

int64_t total_error = 0;
const int count_test_block = 10000;
for (int i = 0; i < count_test_block; ++i) {
      DECLARE_ALIGNED_ARRAY(16, int16_t, test_input_block, kNumCoeffs);
      DECLARE_ALIGNED_ARRAY(16, int16_t, test_temp_block, kNumCoeffs);
      DECLARE_ALIGNED_ARRAY(16, uint8_t, dst, kNumCoeffs);
      DECLARE_ALIGNED_ARRAY(16, uint8_t, src, kNumCoeffs);

      // Initialize a test block with input range [-255, 255].
for (int j = 0; j < kNumCoeffs; ++j) {
        src[j] = rnd.Rand8();
        dst[j] = rnd.Rand8();
        test_input_block[j] = src[j] - dst[j];
}

      REGISTER_STATE_CHECK(RunFwdTxfm(test_input_block,
                                      test_temp_block, pitch_));
      REGISTER_STATE_CHECK(RunInvTxfm(test_temp_block, dst, pitch_));

for (int j = 0; j < kNumCoeffs; ++j) {
const uint32_t diff = dst[j] - src[j];
const uint32_t error = diff * diff;
if (max_error < error)
max_error = error;
total_error += error;

}
}

    EXPECT_GE(1u, max_error)
<< "Error: 16x16 FHT/IHT has an individual round trip error > 1";

    EXPECT_GE(count_test_block , total_error)
<< "Error: 16x16 FHT/IHT has average round trip error > 1 per block";
}

static void write_ivf_frame_header(const vpx_codec_cx_pkt_t *const pkt,
 FILE *const outfile) {
 char header[12];
 vpx_codec_pts_t pts;

 if (pkt->kind != VPX_CODEC_CX_FRAME_PKT)
 return;

  pts = pkt->data.frame.pts;
  mem_put_le32(header, static_cast<unsigned int>(pkt->data.frame.sz));
  mem_put_le32(header + 4, pts & 0xFFFFFFFF);
  mem_put_le32(header + 8, pts >> 32);

 (void)fwrite(header, 1, 12, outfile);
}

const char* SegmentInfo::GetWritingAppAsUTF8() const
{
    return m_pWritingAppAsUTF8;
}

 virtual void BeginPassHook(unsigned int /*pass*/) {
    file_size_ = 0;
    psnr_ = 0.0;
    n_frames_ = 0;
 }

  void RunFwdTxfm(int16_t *in, int16_t *out, int stride) {
     fwd_txfm_(in, out, stride);
   }

const SegmentInfo* Segment::GetInfo() const
{
    return m_pInfo;
}

 double GetAveragePsnr() const {
 if (nframes_)
 return psnr_ / nframes_;
 return 0.0;
 }

 ResizingVideoSource() {
 SetSize(kInitialWidth, kInitialHeight);
    limit_ = 60;
 }

Chapters::Display::Display()
{
}

 static void TearDownTestCase() {
    vpx_free(data_array_);
    vpx_free(mi_);
    vpx_free(mb_);
    data_array_ = NULL;
 }

const char* SegmentInfo::GetMuxingAppAsUTF8() const
{
    return m_pMuxingAppAsUTF8;
}

   void CheckGuardBlocks() {
 for (int i = 0; i < kOutputBufferSize; ++i) {
 if (IsIndexInBorder(i))
        EXPECT_EQ(255, output_[i]);

     }
   }

void SADs(unsigned int *results) {
    const uint8_t* refs[] = {GetReference(0), GetReference(1),
                             GetReference(2), GetReference(3)};

    REGISTER_STATE_CHECK(GET_PARAM(2)(source_data_, source_stride_,
                                      refs, reference_stride_,
                                      results));
}

const CuePoint* Cues::GetNext(const CuePoint* pCurr) const
{
    if (pCurr == NULL)
        return NULL;
    assert(pCurr->GetTimeCode() >= 0);
    assert(m_cue_points);
    assert(m_count >= 1);

#if 0
const size_t count = m_count + m_preload_count;

size_t index = pCurr->m_index;
assert(index < count);

CuePoint* const* const pp = m_cue_points;
assert(pp);
assert(pp[index] == pCurr);

++index;

if (index >= count)
return NULL;

CuePoint* const pNext = pp[index];
assert(pNext);


pNext->Load(m_pSegment->m_pReader);
#else
    long index = pCurr->m_index;
    assert(index < m_count);

    CuePoint* const* const pp = m_cue_points;
    assert(pp);
    assert(pp[index] == pCurr);

    ++index;

    if (index >= m_count)
        return NULL;

    CuePoint* const pNext = pp[index];
    assert(pNext);
    assert(pNext->GetTimeCode() >= 0);
#endif

    return pNext;
}

 virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {
 UpdateMD5(fw_dec_, pkt, &md5_fw_order_);
 UpdateMD5(inv_dec_, pkt, &md5_inv_order_);
 }

 virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {
 if (pkt->data.frame.flags & VPX_FRAME_IS_KEY) {
 }
 }

void reference2_16x16_idct_2d(double *input, double *output) {
 double x;
 for (int l = 0; l < 16; ++l) {
 for (int k = 0; k < 16; ++k) {
 double s = 0;
 for (int i = 0; i < 16; ++i) {
 for (int j = 0; j < 16; ++j) {
          x = cos(PI * j * (l + 0.5) / 16.0) *
              cos(PI * i * (k + 0.5) / 16.0) *
              input[i * 16 + j] / 256;
 if (i != 0)
            x *= sqrt(2.0);
 if (j != 0)
            x *= sqrt(2.0);
          s += x;
 }
 }
      output[k*16+l] = s;
 }
 }
}

 bool CreateBufferList(int num_buffers) {
 if (num_buffers < 0)
 return false;

    num_buffers_ = num_buffers;
    ext_fb_list_ = new ExternalFrameBuffer[num_buffers_];
    EXPECT_TRUE(ext_fb_list_ != NULL);
    memset(ext_fb_list_, 0, sizeof(ext_fb_list_[0]) * num_buffers_);
 return true;
 }

long long Segment::ParseHeaders()
{
    //Outermost (level 0) segment object has been constructed,
    //and pos designates start of payload.  We need to find the
    //inner (level 1) elements.
    long long total, available;
    const int status = m_pReader->Length(&total, &available);
    if (status < 0) //error
return status;

    assert((total < 0) || (available <= total));

    const long long segment_stop = (m_size < 0) ? -1 : m_start + m_size;
    assert((segment_stop < 0) || (total < 0) || (segment_stop <= total));
    assert((segment_stop < 0) || (m_pos <= segment_stop));

    for (;;)
    {
        if ((total >= 0) && (m_pos >= total))
            break;

        if ((segment_stop >= 0) && (m_pos >= segment_stop))
            break;

        long long pos = m_pos;
        const long long element_start = pos;

        if ((pos + 1) > available)
            return (pos + 1);

        long len;
        long long result = GetUIntLength(m_pReader, pos, len);
        if (result < 0)  //error
            return result;
        if (result > 0)  //underflow (weird)
            return (pos + 1);
        if ((segment_stop >= 0) && ((pos + len) > segment_stop))
            return E_FILE_FORMAT_INVALID;
        if ((pos + len) > available)
            return pos + len;
        const long long idpos = pos;
        const long long id = ReadUInt(m_pReader, idpos, len);
        if (id < 0)  //error
            return id;
        if (id == 0x0F43B675)  //Cluster ID
            break;
        pos += len;  //consume ID
        if ((pos + 1) > available)
            return (pos + 1);
        //Read Size
        result = GetUIntLength(m_pReader, pos, len);
        if (result < 0)  //error
            return result;
        if (result > 0)  //underflow (weird)
            return (pos + 1);
        if ((segment_stop >= 0) && ((pos + len) > segment_stop))
            return E_FILE_FORMAT_INVALID;
        if ((pos + len) > available)
            return pos + len;
        const long long size = ReadUInt(m_pReader, pos, len);
        if (size < 0)  //error
            return size;
        pos += len;  //consume length of size of element
        const long long element_size = size + pos - element_start;
        //Pos now points to start of payload
        if ((segment_stop >= 0) && ((pos + size) > segment_stop))
            return E_FILE_FORMAT_INVALID;
        //We read EBML elements either in total or nothing at all.
        if ((pos + size) > available)
            return pos + size;
        if (id == 0x0549A966)  //Segment Info ID
        {
            if (m_pInfo)
                return E_FILE_FORMAT_INVALID;
            m_pInfo = new (std::nothrow) SegmentInfo(
                                          this,
                                          pos,
                                          size,
                                          element_start,
                                          element_size);
            if (m_pInfo == NULL)
                return -1;
            const long status = m_pInfo->Parse();
            if (status)
                return status;
        }
        else if (id == 0x0654AE6B)  //Tracks ID
        {
            if (m_pTracks)
                return E_FILE_FORMAT_INVALID;
            m_pTracks = new (std::nothrow) Tracks(this,
                                                  pos,
                                                  size,
                                                  element_start,
                                                  element_size);
            if (m_pTracks == NULL)
                return -1;
            const long status = m_pTracks->Parse();
            if (status)
                return status;
        }
        else if (id == 0x0C53BB6B)  //Cues ID
        {
            if (m_pCues == NULL)
            {
                m_pCues = new (std::nothrow) Cues(
                                                this,
                                                pos,
                                                size,
                                                element_start,
                                                element_size);
                if (m_pCues == NULL)
                    return -1;
            }
        }
        else if (id == 0x014D9B74)  //SeekHead ID
        {
            if (m_pSeekHead == NULL)
            {
                m_pSeekHead = new (std::nothrow) SeekHead(
                                                    this,
                                                    pos,
                                                    size,
                                                    element_start,
                                                    element_size);
                if (m_pSeekHead == NULL)
                    return -1;
                const long status = m_pSeekHead->Parse();
                if (status)
                    return status;
            }
        }
        else if (id == 0x0043A770)  //Chapters ID
        {
            if (m_pChapters == NULL)
            {
                m_pChapters = new (std::nothrow) Chapters(
                                this,
                                pos,
                                size,
                                element_start,
                                element_size);
                if (m_pChapters == NULL)
                  return -1;
                const long status = m_pChapters->Parse();
                if (status)
                  return status;
            }
        }
        m_pos = pos + size;  //consume payload
}

    assert((segment_stop < 0) || (m_pos <= segment_stop));

    if (m_pInfo == NULL)  //TODO: liberalize this behavior
        return E_FILE_FORMAT_INVALID;

    if (m_pTracks == NULL)
        return E_FILE_FORMAT_INVALID;

    return 0;  //success
}

void filter_block2d_8_c(const uint8_t *src_ptr,
const unsigned int src_stride,
const int16_t *HFilter,
const int16_t *VFilter,
uint8_t *dst_ptr,
unsigned int dst_stride,
unsigned int output_width,
unsigned int output_height) {
// Between passes, we use an intermediate buffer whose height is extended to
// have enough horizontally filtered values as input for the vertical pass.
// This buffer is allocated to be big enough for the largest block type we
// support.

const int kInterp_Extend = 4;
const unsigned int intermediate_height =
(kInterp_Extend - 1) + output_height + kInterp_Extend;

  /* Size of intermediate_buffer is max_intermediate_height * filter_max_width,
   * where max_intermediate_height = (kInterp_Extend - 1) + filter_max_height
   *                                 + kInterp_Extend
   *                               = 3 + 16 + 4
   *                               = 23
   * and filter_max_width = 16
   *
  uint8_t intermediate_buffer[71 * 64];
const int intermediate_next_stride = 1 - intermediate_height * output_width;

// Horizontal pass (src -> transposed intermediate).
  {
    uint8_t *output_ptr = intermediate_buffer;
    const int src_next_row_stride = src_stride - output_width;
    unsigned int i, j;
    src_ptr -= (kInterp_Extend - 1) * src_stride + (kInterp_Extend - 1);
    for (i = 0; i < intermediate_height; ++i) {
      for (j = 0; j < output_width; ++j) {
        // Apply filter...
        const int temp = (src_ptr[0] * HFilter[0]) +
                         (src_ptr[1] * HFilter[1]) +
                         (src_ptr[2] * HFilter[2]) +
                         (src_ptr[3] * HFilter[3]) +
                         (src_ptr[4] * HFilter[4]) +
                         (src_ptr[5] * HFilter[5]) +
                         (src_ptr[6] * HFilter[6]) +
                         (src_ptr[7] * HFilter[7]) +
                         (VP9_FILTER_WEIGHT >> 1);  // Rounding

        // Normalize back to 0-255...
        *output_ptr = clip_pixel(temp >> VP9_FILTER_SHIFT);
        ++src_ptr;
        output_ptr += intermediate_height;
      }
      src_ptr += src_next_row_stride;
      output_ptr += intermediate_next_stride;
}
}

// Vertical pass (transposed intermediate -> dst).
  {
    uint8_t *src_ptr = intermediate_buffer;
    const int dst_next_row_stride = dst_stride - output_width;
    unsigned int i, j;
    for (i = 0; i < output_height; ++i) {
      for (j = 0; j < output_width; ++j) {
        // Apply filter...
        const int temp = (src_ptr[0] * VFilter[0]) +
                         (src_ptr[1] * VFilter[1]) +
                         (src_ptr[2] * VFilter[2]) +
                         (src_ptr[3] * VFilter[3]) +
                         (src_ptr[4] * VFilter[4]) +
                         (src_ptr[5] * VFilter[5]) +
                         (src_ptr[6] * VFilter[6]) +
                         (src_ptr[7] * VFilter[7]) +
                         (VP9_FILTER_WEIGHT >> 1);  // Rounding

        // Normalize back to 0-255...
        *dst_ptr++ = clip_pixel(temp >> VP9_FILTER_SHIFT);
        src_ptr += intermediate_height;
      }
      src_ptr += intermediate_next_stride;
      dst_ptr += dst_next_row_stride;
}
}
}

void SoftVPX::onQueueFilled(OMX_U32 /* portIndex */) {
if (mOutputPortSettingsChange != NONE) {
return;
}

List<BufferInfo *> &inQueue = getPortQueue(0);
List<BufferInfo *> &outQueue = getPortQueue(1);
bool EOSseen = false;

while (!inQueue.empty() && !outQueue.empty()) {
BufferInfo *inInfo = *inQueue.begin();
OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;

BufferInfo *outInfo = *outQueue.begin();
OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;

if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
EOSseen = true;
if (inHeader->nFilledLen == 0) {
inQueue.erase(inQueue.begin());
inInfo->mOwnedByUs = false;
notifyEmptyBufferDone(inHeader);

outHeader->nFilledLen = 0;
outHeader->nFlags = OMX_BUFFERFLAG_EOS;

outQueue.erase(outQueue.begin());
outInfo->mOwnedByUs = false;
notifyFillBufferDone(outHeader);
return;
}
}

if (mImg == NULL) {
if (vpx_codec_decode(
(vpx_codec_ctx_t *)mCtx,
inHeader->pBuffer + inHeader->nOffset,
inHeader->nFilledLen,
NULL,
0)) {
ALOGE("on2 decoder failed to decode frame.");

notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
return;
}
vpx_codec_iter_t iter = NULL;
mImg = vpx_codec_get_frame((vpx_codec_ctx_t *)mCtx, &iter);

}

if (mImg != NULL) {
            CHECK_EQ(mImg->fmt, IMG_FMT_I420);

uint32_t width = mImg->d_w;
uint32_t height = mImg->d_h;
bool portWillReset = false;
handlePortSettingsChange(&portWillReset, width, height);
if (portWillReset) {
return;
}

outHeader->nOffset = 0;
outHeader->nFilledLen = (outputBufferWidth() * outputBufferHeight() * 3) / 2;
outHeader->nFlags = EOSseen ? OMX_BUFFERFLAG_EOS : 0;

outHeader->nTimeStamp = inHeader->nTimeStamp;

uint8_t *dst = outHeader->pBuffer;
            const uint8_t *srcY = (const uint8_t *)mImg->planes[PLANE_Y];
            const uint8_t *srcU = (const uint8_t *)mImg->planes[PLANE_U];
            const uint8_t *srcV = (const uint8_t *)mImg->planes[PLANE_V];
            size_t srcYStride = mImg->stride[PLANE_Y];
            size_t srcUStride = mImg->stride[PLANE_U];
            size_t srcVStride = mImg->stride[PLANE_V];
copyYV12FrameToOutputBuffer(dst, srcY, srcU, srcV, srcYStride, srcUStride, srcVStride);

mImg = NULL;
outInfo->mOwnedByUs = false;
outQueue.erase(outQueue.begin());
outInfo = NULL;
notifyFillBufferDone(outHeader);
outHeader = NULL;
}

inInfo->mOwnedByUs = false;
inQueue.erase(inQueue.begin());
inInfo = NULL;
notifyEmptyBufferDone(inHeader);
inHeader = NULL;
}
}

long SimpleBlock::Parse()
{
    return m_block.Parse(m_pCluster);
}

 static int read_frame(FILE *f, vpx_image_t *img) {
 size_t nbytes, to_read;
 int    res = 1;

    to_read = img->w*img->h*3/2;
    nbytes = fread(img->planes[0], 1, to_read, f);
 if(nbytes != to_read) {
        res = 0;
 if(nbytes > 0)
            printf("Warning: Read partial frame. Check your width & height!\n");
 }
 return res;
}

char **argv_dup(int argc, const char **argv) {
 char **new_argv = malloc((argc + 1) * sizeof(*argv));

  memcpy(new_argv, argv, argc * sizeof(*argv));
  new_argv[argc] = NULL;
 return new_argv;
}

void RunCoeffCheck() {
ACMRandom rnd(ACMRandom::DeterministicSeed());
const int count_test_block = 5000;
    DECLARE_ALIGNED_ARRAY(16, int16_t, input_block, kNumCoeffs);
    DECLARE_ALIGNED_ARRAY(16, int16_t, output_ref_block, kNumCoeffs);
    DECLARE_ALIGNED_ARRAY(16, int16_t, output_block, kNumCoeffs);

for (int i = 0; i < count_test_block; ++i) {
      // Initialize a test block with input range [-255, 255].
for (int j = 0; j < kNumCoeffs; ++j)
        input_block[j] = rnd.Rand8() - rnd.Rand8();

fwd_txfm_ref(input_block, output_ref_block, pitch_, tx_type_);
      REGISTER_STATE_CHECK(RunFwdTxfm(input_block, output_block, pitch_));

// The minimum quant value is 4.
for (int j = 0; j < kNumCoeffs; ++j)
EXPECT_EQ(output_block[j], output_ref_block[j]);
}
}

void reference_dct_1d(double input[8], double output[8]) {
 const double kPi = 3.141592653589793238462643383279502884;
 const double kInvSqrt2 = 0.707106781186547524400844362104;
 for (int k = 0; k < 8; k++) {
    output[k] = 0.0;
 for (int n = 0; n < 8; n++)
      output[k] += input[n]*cos(kPi*(2*n+1)*k/16.0);
 if (k == 0)
      output[k] = output[k]*kInvSqrt2;
 }
}

 void CheckVPrediction() const {
 for (int p = 0; p < num_planes_; p++)
 for (int y = 0; y < block_size_; y++)
        ASSERT_EQ(0, memcmp(&data_ptr_[p][-stride_],
 &data_ptr_[p][y * stride_], block_size_));
 }

ContentEncoding::ContentEncryption::ContentEncryption()
: algo(0),
key_id(NULL),
key_id_len(0),
signature(NULL),
signature_len(0),

sig_key_id(NULL),
sig_key_id_len(0),
sig_algo(0),
      sig_hash_algo(0) {
}

int Track::Info::Copy(Info& dst) const
{
    if (&dst == this)
        return 0;

    dst.type = type;
    dst.number = number;
    dst.defaultDuration = defaultDuration;
    dst.codecDelay = codecDelay;
    dst.seekPreRoll = seekPreRoll;
    dst.uid = uid;
    dst.lacing = lacing;
    dst.settings = settings;

    //We now copy the string member variables from src to dst.
    //This involves memory allocation so in principle the operation
    //can fail (indeed, that's why we have Info::Copy), so we must
    //report this to the caller.  An error return from this function
    //therefore implies that the copy was only partially successful.

    if (int status = CopyStr(&Info::nameAsUTF8, dst))
        return status;

    if (int status = CopyStr(&Info::language, dst))
        return status;

    if (int status = CopyStr(&Info::codecId, dst))
        return status;

    if (int status = CopyStr(&Info::codecNameAsUTF8, dst))
        return status;

    if (codecPrivateSize > 0)
    {
        if (codecPrivate == NULL)
            return -1;

        if (dst.codecPrivate)
            return -1;

        if (dst.codecPrivateSize != 0)
            return -1;

        dst.codecPrivate = new (std::nothrow) unsigned char[codecPrivateSize];

        if (dst.codecPrivate == NULL)
            return -1;

        memcpy(dst.codecPrivate, codecPrivate, codecPrivateSize);
        dst.codecPrivateSize = codecPrivateSize;
}

    return 0;
}

long long Cluster::GetTimeCode() const
{
long long pos;
long len;

    const long status = Load(pos, len);

    if (status < 0) //error
        return status;
    return m_timecode;
}

ContentEncoding::ContentCompression::ContentCompression()
    : algo(0),
      settings(NULL),
      settings_len(0) {
}

 virtual void SetUp() {
 InitializeConfig();
 SetMode(libvpx_test::kTwoPassGood);
 }

long Cluster::GetIndex() const
{
    return m_index;
}

const Chapters* Segment::GetChapters() const
{
  return m_pChapters;
}

 virtual void Next() {
 ++frame_;
 SetSize(ScaleForFrameNumber(frame_, kInitialWidth),
 ScaleForFrameNumber(frame_, kInitialHeight));
 FillFrame();
 }

void FillConstant(uint8_t *data, int stride, uint8_t fill_constant) {
for (int h = 0; h < height_; ++h) {
for (int w = 0; w < width_; ++w) {
        data[h * stride + w] = fill_constant;
}
}
}

 virtual void SetUp() {
    pred_fn_ = GetParam();
 SetupMacroblock(mb_, mi_, data_array_, kBlockSize, kStride, 1);
 }

Chapters::Atom::Atom()
{
}

unsigned long ContentEncoding::GetCompressionCount() const {
 const ptrdiff_t count = compression_entries_end_ - compression_entries_;
  assert(count >= 0);


   return static_cast<unsigned long>(count);
 }

virtual void SetUp() {
InitializeConfig();
    SetMode(GET_PARAM(1));
    set_cpu_used_ = GET_PARAM(2);
}

virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {
    if (pkt->data.frame.flags & VPX_FRAME_IS_KEY) {
    }
}

static void encode_frame(vpx_codec_ctx_t *ctx,
                         const vpx_image_t *img,
                         vpx_codec_pts_t pts,
                         unsigned int duration,
                         vpx_enc_frame_flags_t flags,
                         unsigned int deadline,
                         VpxVideoWriter *writer) {
vpx_codec_iter_t iter = NULL;
const vpx_codec_cx_pkt_t *pkt = NULL;
const vpx_codec_err_t res = vpx_codec_encode(ctx, img, pts, duration, flags,
deadline);
if (res != VPX_CODEC_OK)

die_codec(ctx, "Failed to encode frame.");

while ((pkt = vpx_codec_get_cx_data(ctx, &iter)) != NULL) {
if (pkt->kind == VPX_CODEC_CX_FRAME_PKT) {
const int keyframe = (pkt->data.frame.flags & VPX_FRAME_IS_KEY) != 0;

if (!vpx_video_writer_write_frame(writer, pkt->data.frame.buf,
pkt->data.frame.sz,
pkt->data.frame.pts))
die_codec(ctx, "Failed to write compressed frame.");
printf(keyframe ? "K" : ".");

fflush(stdout);
}
}
}

  virtual ~VP9WorkerThreadTest() {}

 virtual ~CQTest() {}

void RunInvAccuracyCheck() {
ACMRandom rnd(ACMRandom::DeterministicSeed());
const int count_test_block = 1000;
    DECLARE_ALIGNED_ARRAY(16, int16_t, in, kNumCoeffs);
    DECLARE_ALIGNED_ARRAY(16, int16_t, coeff, kNumCoeffs);
    DECLARE_ALIGNED_ARRAY(16, uint8_t, dst, kNumCoeffs);
    DECLARE_ALIGNED_ARRAY(16, uint8_t, src, kNumCoeffs);

for (int i = 0; i < count_test_block; ++i) {
      // Initialize a test block with input range [-255, 255].
for (int j = 0; j < kNumCoeffs; ++j) {
        src[j] = rnd.Rand8();
        dst[j] = rnd.Rand8();
        in[j] = src[j] - dst[j];
}

fwd_txfm_ref(in, coeff, pitch_, tx_type_);

      REGISTER_STATE_CHECK(RunInvTxfm(coeff, dst, pitch_));

for (int j = 0; j < kNumCoeffs; ++j) {
const uint32_t diff = dst[j] - src[j];
const uint32_t error = diff * diff;
        EXPECT_GE(1u, error)
            << "Error: 16x16 IDCT has error " << error
<< " at index " << j;
}
}
}

long long Block::GetDiscardPadding() const
{
    return m_discard_padding;
}

long mkvparser::UnserializeString(
    IMkvReader* pReader,
    long long pos,
    long long size_,
    char*& str)
{
delete[] str;
str = NULL;

    if (size_ >= LONG_MAX)  //we need (size+1) chars
        return E_FILE_FORMAT_INVALID;

    const long size = static_cast<long>(size_);

    str = new (std::nothrow) char[size+1];
    if (str == NULL)
        return -1;
    unsigned char* const buf = reinterpret_cast<unsigned char*>(str);
    const long status = pReader->Read(pos, size, buf);
    if (status)
    {
        delete[] str;
        str = NULL;
        return status;
    }
    str[size] = '\0';
    return 0;  //success
}

 virtual ~TileIndependenceTest() {
 delete fw_dec_;
 delete inv_dec_;
 }

long long Cluster::GetElementSize() const
{
    return m_element_size;
}

int main(int argc, char **argv)
{
    FILE                *infile, *outfile[NUM_ENCODERS];
vpx_codec_ctx_t      codec[NUM_ENCODERS];
vpx_codec_enc_cfg_t  cfg[NUM_ENCODERS];
    vpx_codec_pts_t      frame_cnt = 0;
vpx_image_t          raw[NUM_ENCODERS];
vpx_codec_err_t      res[NUM_ENCODERS];

int                  i;
long                 width;
long                 height;
int                  frame_avail;
int                  got_data;
int                  flags = 0;

/*Currently, only realtime mode is supported in multi-resolution encoding.*/
int                  arg_deadline = VPX_DL_REALTIME;

/* Set show_psnr to 1/0 to show/not show PSNR. Choose show_psnr=0 if you

don't need to know PSNR, which will skip PSNR calculation and save
encoding time. */
int                  show_psnr = 0;
uint64_t             psnr_sse_total[NUM_ENCODERS] = {0};
uint64_t             psnr_samples_total[NUM_ENCODERS] = {0};
double               psnr_totals[NUM_ENCODERS][4] = {{0,0}};
int                  psnr_count[NUM_ENCODERS] = {0};

/* Set the required target bitrates for each resolution level.
* If target bitrate for highest-resolution level is set to 0,
* (i.e. target_bitrate[0]=0), we skip encoding at that level.
*/
unsigned int         target_bitrate[NUM_ENCODERS]={1000, 500, 100};
/* Enter the frame rate of the input video */
int                  framerate = 30;
/* Set down-sampling factor for each resolution level.
dsf[0] controls down sampling from level 0 to level 1;
dsf[1] controls down sampling from level 1 to level 2;
dsf[2] is not used. */
vpx_rational_t dsf[NUM_ENCODERS] = {{2, 1}, {2, 1}, {1, 1}};

    if(argc!= (5+NUM_ENCODERS))
        die("Usage: %s <width> <height> <infile> <outfile(s)> <output psnr?>\n",
argv[0]);

printf("Using %s\n",vpx_codec_iface_name(interface));

width = strtol(argv[1], NULL, 0);
height = strtol(argv[2], NULL, 0);

if(width < 16 || width%2 || height <16 || height%2)
die("Invalid resolution: %ldx%ld", width, height);

/* Open input video file for encoding */
    if(!(infile = fopen(argv[3], "rb")))
        die("Failed to open %s for reading", argv[3]);

/* Open output file for each encoder to output bitstreams */
for (i=0; i< NUM_ENCODERS; i++)
{
if(!target_bitrate[i])
{
outfile[i] = NULL;

continue;
}

        if(!(outfile[i] = fopen(argv[i+4], "wb")))
die("Failed to open %s for writing", argv[i+4]);
}

    show_psnr = strtol(argv[NUM_ENCODERS + 4], NULL, 0);

/* Populate default encoder configuration */
for (i=0; i< NUM_ENCODERS; i++)
{
res[i] = vpx_codec_enc_config_default(interface, &cfg[i], 0);
if(res[i]) {
printf("Failed to get config: %s\n", vpx_codec_err_to_string(res[i]));
return EXIT_FAILURE;
}
}

/*
* Update the default configuration according to needs of the application.
*/

/* Highest-resolution encoder settings */
cfg[0].g_w = width;
cfg[0].g_h = height;
    cfg[0].g_threads = 1;                           /* number of threads used *
    cfg[0].rc_dropframe_thresh = 30;
cfg[0].rc_end_usage = VPX_CBR;
cfg[0].rc_resize_allowed = 0;
    cfg[0].rc_min_quantizer = 4;
cfg[0].rc_max_quantizer = 56;
    cfg[0].rc_undershoot_pct = 98;
    cfg[0].rc_overshoot_pct = 100;
cfg[0].rc_buf_initial_sz = 500;
cfg[0].rc_buf_optimal_sz = 600;
cfg[0].rc_buf_sz = 1000;
cfg[0].g_error_resilient = 1; /* Enable error resilient mode */
cfg[0].g_lag_in_frames   = 0;

/* Disable automatic keyframe placement */

/* Note: These 3 settings are copied to all levels. But, except the lowest
* resolution level, all other levels are set to VPX_KF_DISABLED internally.
*/
    //cfg[0].kf_mode           = VPX_KF_DISABLED;
cfg[0].kf_mode           = VPX_KF_AUTO;
cfg[0].kf_min_dist = 3000;
cfg[0].kf_max_dist = 3000;

cfg[0].rc_target_bitrate = target_bitrate[0]; /* Set target bitrate */
cfg[0].g_timebase.num = 1; /* Set fps */
cfg[0].g_timebase.den = framerate;

/* Other-resolution encoder settings */
for (i=1; i< NUM_ENCODERS; i++)

{
memcpy(&cfg[i], &cfg[0], sizeof(vpx_codec_enc_cfg_t));

        cfg[i].g_threads = 1;                       /* number of threads used *
cfg[i].rc_target_bitrate = target_bitrate[i];

/* Note: Width & height of other-resolution encoders are calculated
* from the highest-resolution encoder's size and the corresponding
* down_sampling_factor.
*/
{
unsigned int iw = cfg[i-1].g_w*dsf[i-1].den + dsf[i-1].num - 1;
unsigned int ih = cfg[i-1].g_h*dsf[i-1].den + dsf[i-1].num - 1;
cfg[i].g_w = iw/dsf[i-1].num;
cfg[i].g_h = ih/dsf[i-1].num;
}

/* Make width & height to be multiplier of 2. */
// Should support odd size ???
if((cfg[i].g_w)%2)cfg[i].g_w++;

if((cfg[i].g_h)%2)cfg[i].g_h++;
}

/* Allocate image for each encoder */
for (i=0; i< NUM_ENCODERS; i++)
if(!vpx_img_alloc(&raw[i], VPX_IMG_FMT_I420, cfg[i].g_w, cfg[i].g_h, 32))
die("Failed to allocate image", cfg[i].g_w, cfg[i].g_h);

if (raw[0].stride[VPX_PLANE_Y] == raw[0].d_w)
read_frame_p = read_frame;
else
read_frame_p = read_frame_by_row;

for (i=0; i< NUM_ENCODERS; i++)

if(outfile[i])
write_ivf_file_header(outfile[i], &cfg[i], 0);

/* Initialize multi-encoder */
if(vpx_codec_enc_init_multi(&codec[0], interface, &cfg[0], NUM_ENCODERS,
(show_psnr ? VPX_CODEC_USE_PSNR : 0), &dsf[0]))
die_codec(&codec[0], "Failed to initialize encoder");

/* The extra encoding configuration parameters can be set as follows. */
/* Set encoding speed */

for ( i=0; i<NUM_ENCODERS; i++)
{
int speed = -6;
if(vpx_codec_control(&codec[i], VP8E_SET_CPUUSED, speed))
die_codec(&codec[i], "Failed to set cpu_used");
}

    /* Set static threshold. *
for ( i=0; i<NUM_ENCODERS; i++)
{
        unsigned int static_thresh = 1;
        if(vpx_codec_control(&codec[i], VP8E_SET_STATIC_THRESHOLD, static_thresh))
die_codec(&codec[i], "Failed to set static threshold");
}

/* Set NOISE_SENSITIVITY to do TEMPORAL_DENOISING */
/* Enable denoising for the highest-resolution encoder. */
if(vpx_codec_control(&codec[0], VP8E_SET_NOISE_SENSITIVITY, 1))
die_codec(&codec[0], "Failed to set noise_sensitivity");
for ( i=1; i< NUM_ENCODERS; i++)
{
if(vpx_codec_control(&codec[i], VP8E_SET_NOISE_SENSITIVITY, 0))

die_codec(&codec[i], "Failed to set noise_sensitivity");
}


frame_avail = 1;
got_data = 0;

while(frame_avail || got_data)
{
vpx_codec_iter_t iter[NUM_ENCODERS]={NULL};
const vpx_codec_cx_pkt_t *pkt[NUM_ENCODERS];

flags = 0;
frame_avail = read_frame_p(infile, &raw[0]);

if(frame_avail)
{
for ( i=1; i<NUM_ENCODERS; i++)
{
/*Scale the image down a number of times by downsampling factor*/
/* FilterMode 1 or 2 give better psnr than FilterMode 0. */
I420Scale(raw[i-1].planes[VPX_PLANE_Y], raw[i-1].stride[VPX_PLANE_Y],
raw[i-1].planes[VPX_PLANE_U], raw[i-1].stride[VPX_PLANE_U],
raw[i-1].planes[VPX_PLANE_V], raw[i-1].stride[VPX_PLANE_V],
raw[i-1].d_w, raw[i-1].d_h,
raw[i].planes[VPX_PLANE_Y], raw[i].stride[VPX_PLANE_Y],

raw[i].planes[VPX_PLANE_U], raw[i].stride[VPX_PLANE_U],
raw[i].planes[VPX_PLANE_V], raw[i].stride[VPX_PLANE_V],
raw[i].d_w, raw[i].d_h, 1);
}
}

        /* Encode each frame at multi-levels *
        if(vpx_codec_encode(&codec[0], frame_avail? &raw[0] : NULL,
            frame_cnt, 1, flags, arg_deadline))
            die_codec(&codec[0], "Failed to encode frame");

for (i=NUM_ENCODERS-1; i>=0 ; i--)
{
got_data = 0;
while( (pkt[i] = vpx_codec_get_cx_data(&codec[i], &iter[i])) )
{
got_data = 1;
switch(pkt[i]->kind) {
case VPX_CODEC_CX_FRAME_PKT:
write_ivf_frame_header(outfile[i], pkt[i]);
(void) fwrite(pkt[i]->data.frame.buf, 1,
pkt[i]->data.frame.sz, outfile[i]);
break;
case VPX_CODEC_PSNR_PKT:
if (show_psnr)
{
int j;

psnr_sse_total[i] += pkt[i]->data.psnr.sse[0];

psnr_samples_total[i] += pkt[i]->data.psnr.samples[0];
for (j = 0; j < 4; j++)
{
                                //fprintf(stderr, "%.3lf ", pkt[i]->data.psnr.psnr[j]);
psnr_totals[i][j] += pkt[i]->data.psnr.psnr[j];
}
psnr_count[i]++;
}

break;
default:

break;
}
printf(pkt[i]->kind == VPX_CODEC_CX_FRAME_PKT
                       && (pkt[i]->data.frame.flags & VPX_FRAME_IS_KEY)? "K":".");
fflush(stdout);
}
}
frame_cnt++;
}
printf("\n");

fclose(infile);

printf("Processed %ld frames.\n",(long int)frame_cnt-1);
for (i=0; i< NUM_ENCODERS; i++)
{
/* Calculate PSNR and print it out */
if ( (show_psnr) && (psnr_count[i]>0) )
{
int j;
double ovpsnr = sse_to_psnr(psnr_samples_total[i], 255.0,
psnr_sse_total[i]);

fprintf(stderr, "\n ENC%d PSNR (Overall/Avg/Y/U/V)", i);

fprintf(stderr, " %.3lf", ovpsnr);
for (j = 0; j < 4; j++)
{
fprintf(stderr, " %.3lf", psnr_totals[i][j]/psnr_count[i]);
}
}

if(vpx_codec_destroy(&codec[i]))
die_codec(&codec[i], "Failed to destroy codec");

vpx_img_free(&raw[i]);

if(!outfile[i])
continue;

/* Try to rewrite the file header with the actual frame count */
if(!fseek(outfile[i], 0, SEEK_SET))
write_ivf_file_header(outfile[i], &cfg[i], frame_cnt-1);
fclose(outfile[i]);
}
printf("\n");

return EXIT_SUCCESS;
}

unsigned int ReferenceSAD(unsigned int max_sad, int block_idx = 0) {
unsigned int sad = 0;
    const uint8_t* const reference = GetReference(block_idx);
for (int h = 0; h < height_; ++h) {
for (int w = 0; w < width_; ++w) {
        sad += abs(source_data_[h * source_stride_ + w]
               - reference[h * reference_stride_ + w]);
      }
      if (sad > max_sad) {
        break;
}
}
return sad;
}

void reference_dct_2d(int16_t input[64], double output[64]) {
 for (int i = 0; i < 8; ++i) {
 double temp_in[8], temp_out[8];
 for (int j = 0; j < 8; ++j)
      temp_in[j] = input[j*8 + i];
    reference_dct_1d(temp_in, temp_out);
 for (int j = 0; j < 8; ++j)
      output[j*8 + i] = temp_out[j];
 }
 for (int i = 0; i < 8; ++i) {
 double temp_in[8], temp_out[8];
 for (int j = 0; j < 8; ++j)
      temp_in[j] = output[j + i*8];
    reference_dct_1d(temp_in, temp_out);
 for (int j = 0; j < 8; ++j)
      output[j + i*8] = temp_out[j];
 }
 for (int i = 0; i < 64; ++i)
    output[i] *= 2;
}

status_t SoftVPX::initDecoder() {
    mCtx = new vpx_codec_ctx_t;
 vpx_codec_err_t vpx_err;
 vpx_codec_dec_cfg_t cfg;
    memset(&cfg, 0, sizeof(vpx_codec_dec_cfg_t));
    cfg.threads = GetCPUCoreCount();
 if ((vpx_err = vpx_codec_dec_init(
 (vpx_codec_ctx_t *)mCtx,
                 mMode == MODE_VP8 ? &vpx_codec_vp8_dx_algo : &vpx_codec_vp9_dx_algo,
 &cfg, 0))) {
        ALOGE("on2 decoder failed to initialize. (%d)", vpx_err);
 return UNKNOWN_ERROR;
 }

 return OK;
}

 virtual void SetUp() {
 InitializeConfig();
 SetMode(GET_PARAM(1));
    set_cpu_used_ = GET_PARAM(2);
 ResetModel();
 }

 FrameInfo(vpx_codec_pts_t _pts, unsigned int _w, unsigned int _h)
 : pts(_pts), w(_w), h(_h) {}

long Cluster::GetLast(const BlockEntry*& pLast) const
{
    for (;;)
    {
        long long pos;
        long len;
        const long status = Parse(pos, len);
        if (status < 0)  //error
        {
            pLast = NULL;
            return status;
        }
        if (status > 0)  //no new block
            break;
    }
    if (m_entries_count <= 0)
    {
        pLast = NULL;
        return 0;
    }
    assert(m_entries);
    const long idx = m_entries_count - 1;
    pLast = m_entries[idx];
    assert(pLast);
return 0;
}

virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,
::libvpx_test::Encoder *encoder) {
if (video->frame() == 1) {
encoder->Control(VP8E_SET_CPUUSED, set_cpu_used_);
      encoder->Control(VP8E_SET_ENABLEAUTOALTREF, 1);
      encoder->Control(VP8E_SET_ARNR_MAXFRAMES, 7);
      encoder->Control(VP8E_SET_ARNR_STRENGTH, 5);
      encoder->Control(VP8E_SET_ARNR_TYPE, 3);
}
}

void Chapters::Atom::ShallowCopy(Atom& rhs) const
{
    rhs.m_string_uid = m_string_uid;
    rhs.m_uid = m_uid;
    rhs.m_start_timecode = m_start_timecode;
    rhs.m_stop_timecode = m_stop_timecode;
    rhs.m_displays = m_displays;
    rhs.m_displays_size = m_displays_size;
    rhs.m_displays_count = m_displays_count;
}

static void usage(char *progname) {
printf("Usage:\n");
printf("%s <input_yuv> <width>x<height> <target_width>x<target_height> ",
         progname);
printf("<output_yuv> [<frames>]\n");
}

unsigned int ScaleForFrameNumber(unsigned int frame, unsigned int val) {
 if (frame < 10)
 return val;
 if (frame < 20)
 return val / 2;
 if (frame < 30)
 return val * 2 / 3;
 if (frame < 40)
 return val / 4;
 if (frame < 50)
 return val * 7 / 8;
 return val;
}

virtual void TearDown() {
    delete[] src_;
    delete[] ref_;
libvpx_test::ClearSystemState();
}

  uint8_t* output() const {
     return output_ + BorderTop() * kOuterBlockSize + BorderLeft();
   }

double VideoTrack::GetFrameRate() const
{
    return m_rate;
}

BlockEntry::~BlockEntry()
{
}

int Chapters::GetEditionCount() const
{
    return m_editions_count;
}

 virtual ~DatarateTestVP9Large() {}

 static int parse_dim(char *v, int *width, int *height) {
   char *x = strchr(v, 'x');
   if (x == NULL)
    x = strchr(v, 'X');
 if (x == NULL)
 return 0;
 *width = atoi(v);
 *height = atoi(&x[1]);
 if (*width <= 0 || *height <= 0)
 return 0;
 else
 return 1;
}

const char* Chapters::Atom::GetStringUID() const
{
    return m_string_uid;
}

Cluster::Cluster(
    Segment* pSegment,
    long idx,
    long long element_start
    /* long long element_size */ ) :
    m_pSegment(pSegment),
    m_element_start(element_start),
    m_index(idx),
    m_pos(element_start),
    m_element_size(-1 /* element_size */ ),
    m_timecode(-1),
    m_entries(NULL),
    m_entries_size(0),
    m_entries_count(-1)  //means "has not been parsed yet"
{
}

mkvparser::IMkvReader::~IMkvReader()
{
}

static int read_frame_by_row(FILE *f, vpx_image_t *img) {
 size_t nbytes, to_read;
 int    res = 1;
 int plane;

 for (plane = 0; plane < 3; plane++)
 {
 unsigned char *ptr;
 int w = (plane ? (1 + img->d_w) / 2 : img->d_w);
 int h = (plane ? (1 + img->d_h) / 2 : img->d_h);
 int r;

 /* Determine the correct plane based on the image format. The for-loop
         * always counts in Y,U,V order, but this may not match the order of
         * the data on disk.
         */
 switch (plane)
 {
 case 1:
            ptr = img->planes[img->fmt==VPX_IMG_FMT_YV12? VPX_PLANE_V : VPX_PLANE_U];
 break;
 case 2:
            ptr = img->planes[img->fmt==VPX_IMG_FMT_YV12?VPX_PLANE_U : VPX_PLANE_V];
 break;
 default:
            ptr = img->planes[plane];
 }

 for (r = 0; r < h; r++)
 {
            to_read = w;

            nbytes = fread(ptr, 1, to_read, f);
 if(nbytes != to_read) {
                res = 0;
 if(nbytes > 0)
                    printf("Warning: Read partial frame. Check your width & height!\n");
 break;
 }

            ptr += img->stride[plane];
 }
 if (!res)
 break;
 }

 return res;
}

  virtual ~LosslessTestLarge() {}

Block::~Block()
{
    delete[] m_frames;
}

const unsigned char* Track::GetCodecPrivate(size_t& size) const
{
    size = m_info.codecPrivateSize;
    return m_info.codecPrivate;
}

 virtual void PSNRPktHook(const vpx_codec_cx_pkt_t *pkt) {
 if (!frame0_psnr_)
      frame0_psnr_ = pkt->data.psnr.psnr[0];

     EXPECT_NEAR(pkt->data.psnr.psnr[0], frame0_psnr_, 2.0);
   }

long long mkvparser::UnserializeUInt(
    IMkvReader* pReader,
    long long pos,
    long long size)
{
    assert(pReader);
    assert(pos >= 0);

    if ((size <= 0) || (size > 8))
        return E_FILE_FORMAT_INVALID;

    long long result = 0;

    for (long long i = 0; i < size; ++i)
    {
        unsigned char b;

        const long status = pReader->Read(pos, 1, &b);

        if (status < 0)
            return status;

        result <<= 8;
        result |= b;

        ++pos;
}

    return result;
}

long Chapters::Edition::Parse(
    IMkvReader* pReader,
    long long pos,
    long long size)
{
    const long long stop = pos + size;

    while (pos < stop)
    {
        long long id, size;

        long status = ParseElementHeader(
                        pReader,
                        pos,
                        stop,
                        id,
                        size);

        if (status < 0)  // error
            return status;

        if (size == 0)  // weird
            continue;

        if (id == 0x36)  // Atom ID
        {
            status = ParseAtom(pReader, pos, size);

            if (status < 0)  // error
                return status;
        }

        pos += size;
        assert(pos <= stop);
}

    assert(pos == stop);
    return 0;
}

   size_t file_size() const { return file_size_; }

 void OpenMD5File(const std::string& md5_file_name_) {
    md5_file_ = libvpx_test::OpenTestDataFile(md5_file_name_);
    ASSERT_TRUE(md5_file_ != NULL) << "Md5 file open failed. Filename: "
 << md5_file_name_;
 }

 virtual void SetUp() {
    width_ = GET_PARAM(0);
    height_ = GET_PARAM(1);
    sixtap_predict_ = GET_PARAM(2);
    memset(src_, 0, kSrcSize);
    memset(dst_, 0, kDstSize);
    memset(dst_c_, 0, kDstSize);
 }

void Chapters::Atom::Clear()
{
    delete[] m_string_uid;
    m_string_uid = NULL;
    while (m_displays_count > 0)
    {
        Display& d = m_displays[--m_displays_count];
        d.Clear();
    }
    delete[] m_displays;
    m_displays = NULL;
    m_displays_size = 0;
}

void reference_32x32_dct_2d(const int16_t input[kNumCoeffs],
double output[kNumCoeffs]) {
// First transform columns
for (int i = 0; i < 32; ++i) {

double temp_in[32], temp_out[32];
for (int j = 0; j < 32; ++j)
temp_in[j] = input[j*32 + i];
    reference_32x32_dct_1d(temp_in, temp_out, 1);
for (int j = 0; j < 32; ++j)
output[j * 32 + i] = temp_out[j];
}
// Then transform rows
for (int i = 0; i < 32; ++i) {

double temp_in[32], temp_out[32];
for (int j = 0; j < 32; ++j)
temp_in[j] = output[j + i*32];
    reference_32x32_dct_1d(temp_in, temp_out, 1);
// Scale by some magic number
for (int j = 0; j < 32; ++j)
output[j + i * 32] = temp_out[j] / 4;
}
}

long Cluster::Load(long long& pos, long& len) const
{
    assert(m_pSegment);
    assert(m_pos >= m_element_start);

    if (m_timecode >= 0)  //at least partially loaded
        return 0;

    assert(m_pos == m_element_start);
    assert(m_element_size < 0);

    IMkvReader* const pReader = m_pSegment->m_pReader;

    long long total, avail;

    const int status = pReader->Length(&total, &avail);

    if (status < 0)  //error
        return status;

    assert((total < 0) || (avail <= total));
    assert((total < 0) || (m_pos <= total));  //TODO: verify this

    pos = m_pos;

    long long cluster_size = -1;
    {
        if ((pos + 1) > avail)
        {
            len = 1;
            return E_BUFFER_NOT_FULL;
        }
        long long result = GetUIntLength(pReader, pos, len);
        if (result < 0)  //error or underflow
            return static_cast<long>(result);
        if (result > 0)  //underflow (weird)
            return E_BUFFER_NOT_FULL;
        //if ((pos + len) > segment_stop)
        //    return E_FILE_FORMAT_INVALID;
        if ((pos + len) > avail)
            return E_BUFFER_NOT_FULL;
        const long long id_ = ReadUInt(pReader, pos, len);
        if (id_ < 0)  //error
            return static_cast<long>(id_);
        if (id_ != 0x0F43B675)  //Cluster ID
            return E_FILE_FORMAT_INVALID;
        pos += len;  //consume id
        //read cluster size
        if ((pos + 1) > avail)
        {
            len = 1;
            return E_BUFFER_NOT_FULL;
        }
        result = GetUIntLength(pReader, pos, len);
        if (result < 0)  //error
            return static_cast<long>(result);
        if (result > 0)  //weird
            return E_BUFFER_NOT_FULL;
        //if ((pos + len) > segment_stop)
        //    return E_FILE_FORMAT_INVALID;
        if ((pos + len) > avail)
            return E_BUFFER_NOT_FULL;
        const long long size = ReadUInt(pReader, pos, len);
        if (size < 0)  //error
            return static_cast<long>(cluster_size);
        if (size == 0)
            return E_FILE_FORMAT_INVALID;  //TODO: verify this
        pos += len;  //consume length of size of element
        const long long unknown_size = (1LL << (7 * len)) - 1;
        if (size != unknown_size)
            cluster_size = size;
}

    //pos points to start of payload

#if 0
len = static_cast<long>(size_);

if (cluster_stop > avail)

return E_BUFFER_NOT_FULL;
#endif

    long long timecode = -1;
    long long new_pos = -1;
    bool bBlock = false;

    long long cluster_stop = (cluster_size < 0) ? -1 : pos + cluster_size;

    for (;;)
    {
        if ((cluster_stop >= 0) && (pos >= cluster_stop))
            break;

        //Parse ID

        if ((pos + 1) > avail)
        {
            len = 1;
            return E_BUFFER_NOT_FULL;
        }
        long long result = GetUIntLength(pReader, pos, len);
        if (result < 0)  //error
            return static_cast<long>(result);
        if (result > 0)  //weird
            return E_BUFFER_NOT_FULL;
        if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))
            return E_FILE_FORMAT_INVALID;
        if ((pos + len) > avail)
            return E_BUFFER_NOT_FULL;
        const long long id = ReadUInt(pReader, pos, len);
        if (id < 0) //error
            return static_cast<long>(id);
        if (id == 0)
            return E_FILE_FORMAT_INVALID;
        //This is the distinguished set of ID's we use to determine
        //that we have exhausted the sub-element's inside the cluster
        //whose ID we parsed earlier.
        if (id == 0x0F43B675)  //Cluster ID
            break;
        if (id == 0x0C53BB6B)  //Cues ID
            break;
        pos += len;  //consume ID field
        //Parse Size
        if ((pos + 1) > avail)
        {
            len = 1;
            return E_BUFFER_NOT_FULL;
        }
        result = GetUIntLength(pReader, pos, len);
        if (result < 0)  //error
            return static_cast<long>(result);
        if (result > 0)  //weird
            return E_BUFFER_NOT_FULL;
        if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))
            return E_FILE_FORMAT_INVALID;
        if ((pos + len) > avail)
            return E_BUFFER_NOT_FULL;
        const long long size = ReadUInt(pReader, pos, len);
        if (size < 0)  //error
            return static_cast<long>(size);
        const long long unknown_size = (1LL << (7 * len)) - 1;
        if (size == unknown_size)
            return E_FILE_FORMAT_INVALID;
        pos += len;  //consume size field
        if ((cluster_stop >= 0) && (pos > cluster_stop))
            return E_FILE_FORMAT_INVALID;
        //pos now points to start of payload
        if (size == 0)  //weird
            continue;
        if ((cluster_stop >= 0) && ((pos + size) > cluster_stop))
            return E_FILE_FORMAT_INVALID;
        if (id == 0x67)  //TimeCode ID
        {
            len = static_cast<long>(size);
            if ((pos + size) > avail)
                return E_BUFFER_NOT_FULL;
            timecode = UnserializeUInt(pReader, pos, size);
            if (timecode < 0)  //error (or underflow)
                return static_cast<long>(timecode);
            new_pos = pos + size;
            if (bBlock)
                break;
        }
        else if (id == 0x20)  //BlockGroup ID
        {
            bBlock = true;
            break;
        }
        else if (id == 0x23)  //SimpleBlock ID
        {
            bBlock = true;
            break;
        }
        pos += size;  //consume payload
        assert((cluster_stop < 0) || (pos <= cluster_stop));
    }
    assert((cluster_stop < 0) || (pos <= cluster_stop));
    if (timecode < 0)  //no timecode found
        return E_FILE_FORMAT_INVALID;
    if (!bBlock)
        return E_FILE_FORMAT_INVALID;
    m_pos = new_pos;  //designates position just beyond timecode payload
    m_timecode = timecode;  // m_timecode >= 0 means we're partially loaded
    if (cluster_size >= 0)
        m_element_size = cluster_stop - m_element_start;
    return 0;
}

   virtual void SetUp() {
     InitializeConfig();
 SetMode(GET_PARAM(1));
    set_cpu_used_ = GET_PARAM(2);
    aq_mode_ = 0;
 }

SegmentInfo::SegmentInfo(
    Segment* pSegment,
    long long start,
    long long size_,
    long long element_start,
    long long element_size) :
    m_pSegment(pSegment),
    m_start(start),
    m_size(size_),
    m_element_start(element_start),
    m_element_size(element_size),
    m_pMuxingAppAsUTF8(NULL),
    m_pWritingAppAsUTF8(NULL),
    m_pTitleAsUTF8(NULL)
{
}

 double GetAverageMismatchPsnr() const {
 if (mismatch_nframes_)
 return mismatch_psnr_ / mismatch_nframes_;
 return 0.0;
 }

int Block::GetFrameCount() const
{
    return m_frame_count;
}

long long AudioTrack::GetChannels() const
{
    return m_channels;
}

void reference_32x32_dct_1d(const double in[32], double out[32], int stride) {
   const double kInvSqrt2 = 0.707106781186547524400844362104;
   for (int k = 0; k < 32; k++) {
     out[k] = 0.0;
 for (int n = 0; n < 32; n++)
      out[k] += in[n] * cos(kPi * (2 * n + 1) * k / 64.0);
 if (k == 0)
      out[k] = out[k] * kInvSqrt2;
 }
}

Cluster::Cluster() :
    m_pSegment(NULL),
    m_element_start(0),
    m_index(0),
    m_pos(0),
    m_element_size(0),
    m_timecode(0),
    m_entries(NULL),
    m_entries_size(0),
    m_entries_count(0)  //means "no entries"
{
}

void usage_exit() {
   fprintf(stderr,
           "Usage: %s <codec> <width> <height> <infile> <outfile> "
               "<keyframe-interval> [<error-resilient>]\nSee comments in "
 "simple_encoder.c for more information.\n",
          exec_name);

   exit(EXIT_FAILURE);
 }

 DatarateTestLarge() : EncoderTest(GET_PARAM(0)) {}

long Cluster::Parse(long long& pos, long& len) const
{
    long status = Load(pos, len);
    if (status < 0)
        return status;
    assert(m_pos >= m_element_start);
    assert(m_timecode >= 0);
    //assert(m_size > 0);
    //assert(m_element_size > m_size);
    const long long cluster_stop =
        (m_element_size < 0) ? -1 : m_element_start + m_element_size;
    if ((cluster_stop >= 0) && (m_pos >= cluster_stop))
        return 1;  //nothing else to do
    IMkvReader* const pReader = m_pSegment->m_pReader;
    long long total, avail;
    status = pReader->Length(&total, &avail);
    if (status < 0)  //error
        return status;
    assert((total < 0) || (avail <= total));
    pos = m_pos;
    for (;;)
    {
        if ((cluster_stop >= 0) && (pos >= cluster_stop))
            break;
        if ((total >= 0) && (pos >= total))
        {
            if (m_element_size < 0)
                m_element_size = pos - m_element_start;
            break;
        }
        //Parse ID
        if ((pos + 1) > avail)
        {
            len = 1;
            return E_BUFFER_NOT_FULL;
        }
        long long result = GetUIntLength(pReader, pos, len);
        if (result < 0)  //error
            return static_cast<long>(result);
        if (result > 0)  //weird
            return E_BUFFER_NOT_FULL;
        if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))
            return E_FILE_FORMAT_INVALID;
        if ((pos + len) > avail)
            return E_BUFFER_NOT_FULL;
        const long long id = ReadUInt(pReader, pos, len);
        if (id < 0) //error
            return static_cast<long>(id);
        if (id == 0)  //weird
            return E_FILE_FORMAT_INVALID;
        //This is the distinguished set of ID's we use to determine
        //that we have exhausted the sub-element's inside the cluster
        //whose ID we parsed earlier.
        if ((id == 0x0F43B675) || (id == 0x0C53BB6B)) //Cluster or Cues ID
        {
            if (m_element_size < 0)
                m_element_size = pos - m_element_start;
            break;
        }
        pos += len;  //consume ID field
        //Parse Size
        if ((pos + 1) > avail)
        {
            len = 1;
            return E_BUFFER_NOT_FULL;
        }
        result = GetUIntLength(pReader, pos, len);
        if (result < 0)  //error
            return static_cast<long>(result);
        if (result > 0)  //weird
            return E_BUFFER_NOT_FULL;
        if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))
            return E_FILE_FORMAT_INVALID;
        if ((pos + len) > avail)
            return E_BUFFER_NOT_FULL;
        const long long size = ReadUInt(pReader, pos, len);
        if (size < 0)  //error
            return static_cast<long>(size);
        const long long unknown_size = (1LL << (7 * len)) - 1;
        if (size == unknown_size)
            return E_FILE_FORMAT_INVALID;
        pos += len;  //consume size field
        if ((cluster_stop >= 0) && (pos > cluster_stop))
            return E_FILE_FORMAT_INVALID;
        //pos now points to start of payload
        if (size == 0)  //weird
            continue;
        //const long long block_start = pos;
        const long long block_stop = pos + size;
        if (cluster_stop >= 0)
        {
            if (block_stop > cluster_stop)
            {
                if ((id == 0x20) || (id == 0x23))
                    return E_FILE_FORMAT_INVALID;
                pos = cluster_stop;
                break;
            }
        }
        else if ((total >= 0) && (block_stop > total))
        {
            m_element_size = total - m_element_start;
            pos = total;
            break;
        }
        else if (block_stop > avail)
        {
            len = static_cast<long>(size);
            return E_BUFFER_NOT_FULL;
        }
        Cluster* const this_ = const_cast<Cluster*>(this);
        if (id == 0x20)  //BlockGroup
            return this_->ParseBlockGroup(size, pos, len);
        if (id == 0x23)  //SimpleBlock
            return this_->ParseSimpleBlock(size, pos, len);
        pos += size;  //consume payload
        assert((cluster_stop < 0) || (pos <= cluster_stop));
    }
    assert(m_element_size > 0);
    m_pos = pos;
    assert((cluster_stop < 0) || (m_pos <= cluster_stop));
    if (m_entries_count > 0)
    {
        const long idx = m_entries_count - 1;
        const BlockEntry* const pLast = m_entries[idx];
        assert(pLast);
        const Block* const pBlock = pLast->GetBlock();
        assert(pBlock);
        const long long start = pBlock->m_start;
        if ((total >= 0) && (start > total))
            return -1;  //defend against trucated stream
        const long long size = pBlock->m_size;
        const long long stop = start + size;
        assert((cluster_stop < 0) || (stop <= cluster_stop));
        if ((total >= 0) && (stop > total))
            return -1;  //defend against trucated stream
    }
    return 1;  //no more entries
}

int main(int argc, char **argv) {
FILE *infile = NULL;
vpx_codec_ctx_t codec;
vpx_codec_enc_cfg_t cfg;
int frame_count = 0;
vpx_image_t raw;
vpx_codec_err_t res;
VpxVideoInfo info = {0};
VpxVideoWriter *writer = NULL;
const VpxInterface *encoder = NULL;
const int fps = 30; // TODO(dkovalev) add command line argument
const int bitrate = 200; // kbit/s TODO(dkovalev) add command line argument
int keyframe_interval = 0;

// TODO(dkovalev): Add some simple command line parsing code to make the
// command line more flexible.
const char *codec_arg = NULL;
const char *width_arg = NULL;
const char *height_arg = NULL;
const char *infile_arg = NULL;
const char *outfile_arg = NULL;
const char *keyframe_interval_arg = NULL;

exec_name = argv[0];

if (argc < 7)
die("Invalid number of arguments");

codec_arg = argv[1];
width_arg = argv[2];
height_arg = argv[3];
infile_arg = argv[4];
outfile_arg = argv[5];
keyframe_interval_arg = argv[6];

encoder = get_vpx_encoder_by_name(codec_arg);
if (!encoder)
die("Unsupported codec.");

info.codec_fourcc = encoder->fourcc;
info.frame_width = strtol(width_arg, NULL, 0);
info.frame_height = strtol(height_arg, NULL, 0);
info.time_base.numerator = 1;
info.time_base.denominator = fps;

if (info.frame_width <= 0 ||
info.frame_height <= 0 ||
(info.frame_width % 2) != 0 ||
(info.frame_height % 2) != 0) {
die("Invalid frame size: %dx%d", info.frame_width, info.frame_height);
}

if (!vpx_img_alloc(&raw, VPX_IMG_FMT_I420, info.frame_width,
info.frame_height, 1)) {
die("Failed to allocate image.");
}

keyframe_interval = strtol(keyframe_interval_arg, NULL, 0);

if (keyframe_interval < 0)
die("Invalid keyframe interval value.");

  printf("Using %s\n", vpx_codec_iface_name(encoder->interface()));

  res = vpx_codec_enc_config_default(encoder->interface(), &cfg, 0);
if (res)
die_codec(&codec, "Failed to get default codec config.");

cfg.g_w = info.frame_width;
cfg.g_h = info.frame_height;
cfg.g_timebase.num = info.time_base.numerator;
cfg.g_timebase.den = info.time_base.denominator;
cfg.rc_target_bitrate = bitrate;
cfg.g_error_resilient = argc > 7 ? strtol(argv[7], NULL, 0) : 0;

writer = vpx_video_writer_open(outfile_arg, kContainerIVF, &info);
if (!writer)
die("Failed to open %s for writing.", outfile_arg);


if (!(infile = fopen(infile_arg, "rb")))
die("Failed to open %s for reading.", infile_arg);

  if (vpx_codec_enc_init(&codec, encoder->interface(), &cfg, 0))
die_codec(&codec, "Failed to initialize encoder");

while (vpx_img_read(&raw, infile)) {
int flags = 0;
if (keyframe_interval > 0 && frame_count % keyframe_interval == 0)
flags |= VPX_EFLAG_FORCE_KF;
encode_frame(&codec, &raw, frame_count++, flags, writer);
}
  encode_frame(&codec, NULL, -1, 0, writer);  // flush the encoder

printf("\n");
fclose(infile);
printf("Processed %d frames.\n", frame_count);

vpx_img_free(&raw);
if (vpx_codec_destroy(&codec))
die_codec(&codec, "Failed to destroy codec.");

vpx_video_writer_close(writer);

return EXIT_SUCCESS;
}

long mkvparser::UnserializeFloat(
    IMkvReader* pReader,
    long long pos,
    long long size_,
    double& result)
{
    assert(pReader);
    assert(pos >= 0);

    if ((size_ != 4) && (size_ != 8))
        return E_FILE_FORMAT_INVALID;

    const long size = static_cast<long>(size_);

    unsigned char buf[8];

    const int status = pReader->Read(pos, size, buf);

    if (status < 0)  //error
        return status;

    if (size == 4)
    {
        union
        {
            float f;
            unsigned long ff;
        };

        ff = 0;

        for (int i = 0;;)
        {
            ff |= buf[i];

            if (++i >= 4)
                break;

            ff <<= 8;
        }
        result = f;
    }
    else
    {
        assert(size == 8);
        union
        {
            double d;
            unsigned long long dd;
        };
        dd = 0;
        for (int i = 0;;)
        {
            dd |= buf[i];
            if (++i >= 8)
                break;
            dd <<= 8;
        }
        result = d;
    }
    return 0;
}

 bool IsIndexInBorder(int i) {
 return (i < BorderTop() * kOuterBlockSize ||
            i >= (BorderTop() + Height()) * kOuterBlockSize ||
            i % kOuterBlockSize < BorderLeft() ||
            i % kOuterBlockSize >= (BorderLeft() + Width()));
 }

 virtual ~ActiveMapTest() {}

virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,
::libvpx_test::Encoder *encoder) {

if (video->frame() == 1) {
encoder->Control(VP8E_SET_CPUUSED, cpu_used_);
} else if (video->frame() == 3) {
      vpx_active_map_t map = {0};
uint8_t active_map[9 * 13] = {
1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0,
1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0,
1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0,
1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0,
0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1,
0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1,
0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1,
0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1,
1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0,
};
map.cols = (kWidth + 15) / 16;
map.rows = (kHeight + 15) / 16;
ASSERT_EQ(map.cols, 13u);
ASSERT_EQ(map.rows, 9u);

map.active_map = active_map;
encoder->Control(VP8E_SET_ACTIVEMAP, &map);
} else if (video->frame() == 15) {
      vpx_active_map_t map = {0};
map.cols = (kWidth + 15) / 16;
map.rows = (kHeight + 15) / 16;
map.active_map = NULL;
encoder->Control(VP8E_SET_ACTIVEMAP, &map);
}
}

Track::Info::Info():
    uid(0),
    defaultDuration(0),
    codecDelay(0),
    seekPreRoll(0),
    nameAsUTF8(NULL),
    language(NULL),
    codecId(NULL),
    codecNameAsUTF8(NULL),
    codecPrivate(NULL),
    codecPrivateSize(0),
    lacing(false)
{
}

void Chapters::Atom::Init()
{
    m_string_uid = NULL;
    m_uid = 0;
    m_start_timecode = -1;
    m_stop_timecode = -1;
    m_displays = NULL;
    m_displays_size = 0;
    m_displays_count = 0;
}

  void RunInvTxfm(const int16_t *out, uint8_t *dst, int stride) {
     inv_txfm_(out, dst, stride);
   }

int SeekHead::GetVoidElementCount() const
{
    return m_void_element_count;
}

 virtual void SetUp() {
 InitializeConfig();
 SetMode(GET_PARAM(1));
 ResetModel();
 }

 virtual void DecompressedFrameHook(const vpx_image_t &img,
 vpx_codec_pts_t pts) {
    frame_info_list_.push_back(FrameInfo(pts, img.d_w, img.d_h));
 }

  SADTestBase(int width, int height) : width_(width), height_(height) {}

   virtual ~TestVectorTest() {
     if (md5_file_)
      fclose(md5_file_);
 }

 double GetMinPsnr() const {
 return psnr_;
 }

MD5Transform(UWORD32 buf[4], UWORD32 const in[16]) {
 register UWORD32 a, b, c, d;

  a = buf[0];
  b = buf[1];
  c = buf[2];
  d = buf[3];

  MD5STEP(F1, a, b, c, d, in[0] + 0xd76aa478, 7);
  MD5STEP(F1, d, a, b, c, in[1] + 0xe8c7b756, 12);
  MD5STEP(F1, c, d, a, b, in[2] + 0x242070db, 17);
  MD5STEP(F1, b, c, d, a, in[3] + 0xc1bdceee, 22);
  MD5STEP(F1, a, b, c, d, in[4] + 0xf57c0faf, 7);
  MD5STEP(F1, d, a, b, c, in[5] + 0x4787c62a, 12);
  MD5STEP(F1, c, d, a, b, in[6] + 0xa8304613, 17);
  MD5STEP(F1, b, c, d, a, in[7] + 0xfd469501, 22);
  MD5STEP(F1, a, b, c, d, in[8] + 0x698098d8, 7);
  MD5STEP(F1, d, a, b, c, in[9] + 0x8b44f7af, 12);
  MD5STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);
  MD5STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);
  MD5STEP(F1, a, b, c, d, in[12] + 0x6b901122, 7);
  MD5STEP(F1, d, a, b, c, in[13] + 0xfd987193, 12);
  MD5STEP(F1, c, d, a, b, in[14] + 0xa679438e, 17);
  MD5STEP(F1, b, c, d, a, in[15] + 0x49b40821, 22);

  MD5STEP(F2, a, b, c, d, in[1] + 0xf61e2562, 5);
  MD5STEP(F2, d, a, b, c, in[6] + 0xc040b340, 9);
  MD5STEP(F2, c, d, a, b, in[11] + 0x265e5a51, 14);
  MD5STEP(F2, b, c, d, a, in[0] + 0xe9b6c7aa, 20);
  MD5STEP(F2, a, b, c, d, in[5] + 0xd62f105d, 5);
  MD5STEP(F2, d, a, b, c, in[10] + 0x02441453, 9);
  MD5STEP(F2, c, d, a, b, in[15] + 0xd8a1e681, 14);
  MD5STEP(F2, b, c, d, a, in[4] + 0xe7d3fbc8, 20);
  MD5STEP(F2, a, b, c, d, in[9] + 0x21e1cde6, 5);
  MD5STEP(F2, d, a, b, c, in[14] + 0xc33707d6, 9);
  MD5STEP(F2, c, d, a, b, in[3] + 0xf4d50d87, 14);
  MD5STEP(F2, b, c, d, a, in[8] + 0x455a14ed, 20);
  MD5STEP(F2, a, b, c, d, in[13] + 0xa9e3e905, 5);
  MD5STEP(F2, d, a, b, c, in[2] + 0xfcefa3f8, 9);
  MD5STEP(F2, c, d, a, b, in[7] + 0x676f02d9, 14);
  MD5STEP(F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20);

  MD5STEP(F3, a, b, c, d, in[5] + 0xfffa3942, 4);
  MD5STEP(F3, d, a, b, c, in[8] + 0x8771f681, 11);
  MD5STEP(F3, c, d, a, b, in[11] + 0x6d9d6122, 16);
  MD5STEP(F3, b, c, d, a, in[14] + 0xfde5380c, 23);
  MD5STEP(F3, a, b, c, d, in[1] + 0xa4beea44, 4);
  MD5STEP(F3, d, a, b, c, in[4] + 0x4bdecfa9, 11);
  MD5STEP(F3, c, d, a, b, in[7] + 0xf6bb4b60, 16);
  MD5STEP(F3, b, c, d, a, in[10] + 0xbebfbc70, 23);
  MD5STEP(F3, a, b, c, d, in[13] + 0x289b7ec6, 4);
  MD5STEP(F3, d, a, b, c, in[0] + 0xeaa127fa, 11);
  MD5STEP(F3, c, d, a, b, in[3] + 0xd4ef3085, 16);
  MD5STEP(F3, b, c, d, a, in[6] + 0x04881d05, 23);
  MD5STEP(F3, a, b, c, d, in[9] + 0xd9d4d039, 4);
  MD5STEP(F3, d, a, b, c, in[12] + 0xe6db99e5, 11);
  MD5STEP(F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);
  MD5STEP(F3, b, c, d, a, in[2] + 0xc4ac5665, 23);

  MD5STEP(F4, a, b, c, d, in[0] + 0xf4292244, 6);
  MD5STEP(F4, d, a, b, c, in[7] + 0x432aff97, 10);
  MD5STEP(F4, c, d, a, b, in[14] + 0xab9423a7, 15);
  MD5STEP(F4, b, c, d, a, in[5] + 0xfc93a039, 21);
  MD5STEP(F4, a, b, c, d, in[12] + 0x655b59c3, 6);
  MD5STEP(F4, d, a, b, c, in[3] + 0x8f0ccc92, 10);
  MD5STEP(F4, c, d, a, b, in[10] + 0xffeff47d, 15);
  MD5STEP(F4, b, c, d, a, in[1] + 0x85845dd1, 21);
  MD5STEP(F4, a, b, c, d, in[8] + 0x6fa87e4f, 6);
  MD5STEP(F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10);
  MD5STEP(F4, c, d, a, b, in[6] + 0xa3014314, 15);
  MD5STEP(F4, b, c, d, a, in[13] + 0x4e0811a1, 21);
  MD5STEP(F4, a, b, c, d, in[4] + 0xf7537e82, 6);
  MD5STEP(F4, d, a, b, c, in[11] + 0xbd3af235, 10);
  MD5STEP(F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15);
  MD5STEP(F4, b, c, d, a, in[9] + 0xeb86d391, 21);

  buf[0] += a;
  buf[1] += b;
  buf[2] += c;
  buf[3] += d;
}

virtual void TearDown() {
vpx_free(src_);
delete[] ref_;
    vpx_free(sec_);
libvpx_test::ClearSystemState();
}

Track::GetContentEncodingByIndex(unsigned long idx) const {
   const ptrdiff_t count =
       content_encoding_entries_end_ - content_encoding_entries_;
   assert(count >= 0);

 if (idx >= static_cast<unsigned long>(count))
 return NULL;

 return content_encoding_entries_[idx];
}

void EBMLHeader::Init()
{
    m_version = 1;
    m_readVersion = 1;
    m_maxIdLength = 4;
    m_maxSizeLength = 8;

    if (m_docType)
    {
        delete[] m_docType;
        m_docType = NULL;
    }

    m_docTypeVersion = 1;
    m_docTypeReadVersion = 1;
}

static void set_roi_map(const vpx_codec_enc_cfg_t *cfg,
vpx_codec_ctx_t *codec) {
unsigned int i;
  vpx_roi_map_t roi = {0};

roi.rows = (cfg->g_h + 15) / 16;
roi.cols = (cfg->g_w + 15) / 16;

roi.delta_q[0] = 0;
roi.delta_q[1] = -2;
roi.delta_q[2] = -4;
roi.delta_q[3] = -6;

roi.delta_lf[0] = 0;
roi.delta_lf[1] = 1;
roi.delta_lf[2] = 2;
roi.delta_lf[3] = 3;

roi.static_threshold[0] = 1500;
roi.static_threshold[1] = 1000;
roi.static_threshold[2] = 500;
roi.static_threshold[3] = 0;

roi.roi_map = (uint8_t *)malloc(roi.rows * roi.cols);
for (i = 0; i < roi.rows * roi.cols; ++i)
roi.roi_map[i] = i % 4;

if (vpx_codec_control(codec, VP8E_SET_ROI_MAP, &roi))
die_codec(codec, "Failed to set ROI map");

free(roi.roi_map);
}

long Track::ParseContentEncodingsEntry(long long start, long long size) {
IMkvReader* const pReader = m_pSegment->m_pReader;
assert(pReader);

long long pos = start;
const long long stop = start + size;

// Count ContentEncoding elements.

int count = 0;
while (pos < stop) {
long long id, size;
    const long status = ParseElementHeader(pReader,
                                           pos,
                                           stop,
                                           id,
                                           size);
    if (status < 0)  //error
return status;

    //pos now designates start of element
if (id == 0x2240)  // ContentEncoding ID
++count;

    pos += size;  //consume payload
assert(pos <= stop);
}

if (count <= 0)
return -1;

  content_encoding_entries_ = new (std::nothrow) ContentEncoding*[count];
if (!content_encoding_entries_)
return -1;

content_encoding_entries_end_ = content_encoding_entries_;


pos = start;
while (pos < stop) {
long long id, size;
    long status = ParseElementHeader(pReader,
                                     pos,
                                     stop,
                                     id,
                                     size);
    if (status < 0)  //error
return status;

    //pos now designates start of element
    if (id == 0x2240) { // ContentEncoding ID
ContentEncoding* const content_encoding =
new (std::nothrow) ContentEncoding();
if (!content_encoding)
return -1;

      status = content_encoding->ParseContentEncodingEntry(pos,
                                                           size,
                                                           pReader);
if (status) {
delete content_encoding;
return status;
}


*content_encoding_entries_end_++ = content_encoding;
}

    pos += size;  //consume payload
assert(pos <= stop);
}

assert(pos == stop);


return 0;
}

unsigned int subpel_avg_variance_ref(const uint8_t *ref,
                                     const uint8_t *src,
                                     const uint8_t *second_pred,
                                     int l2w, int l2h,
                                     int xoff, int yoff,
                                     unsigned int *sse_ptr) {
  int se = 0;
  unsigned int sse = 0;
  const int w = 1 << l2w, h = 1 << l2h;
  for (int y = 0; y < h; y++) {
    for (int x = 0; x < w; x++) {
      // bilinear interpolation at a 16th pel step
      const int a1 = ref[(w + 1) * (y + 0) + x + 0];
      const int a2 = ref[(w + 1) * (y + 0) + x + 1];
      const int b1 = ref[(w + 1) * (y + 1) + x + 0];
      const int b2 = ref[(w + 1) * (y + 1) + x + 1];
      const int a = a1 + (((a2 - a1) * xoff + 8) >> 4);
      const int b = b1 + (((b2 - b1) * xoff + 8) >> 4);
      const int r = a + (((b - a) * yoff + 8) >> 4);
      int diff = ((r + second_pred[w * y + x] + 1) >> 1) - src[w * y + x];
      se += diff;
      sse += diff * diff;
    }
  }
  *sse_ptr = sse;
  return sse - (((int64_t) se * se) >> (l2w + l2h));
}

const BlockEntry* Track::GetEOS() const
{
    return &m_eos;
}

const CuePoint* Cues::GetFirst() const
{
    if (m_cue_points == NULL)
        return NULL;
    if (m_count == 0)
        return NULL;

#if 0
LoadCuePoint();  //init cues

const size_t count = m_count + m_preload_count;

if (count == 0) //weird

return NULL;
#endif

    CuePoint* const* const pp = m_cue_points;
    assert(pp);

    CuePoint* const pCP = pp[0];
    assert(pCP);
    assert(pCP->GetTimeCode() >= 0);

    return pCP;
}

Block::Lacing Block::GetLacing() const
{
    const int value = int(m_flags & 0x06) >> 1;
    return static_cast<Lacing>(value);
}

long ContentEncoding::ParseEncryptionEntry(
    long long start,
    long long size,
    IMkvReader* pReader,
    ContentEncryption* encryption) {
assert(pReader);
assert(encryption);

long long pos = start;
const long long stop = start + size;


while (pos < stop) {
long long id, size;
    const long status = ParseElementHeader(pReader,
                                           pos,
                                           stop,
                                           id,
                                           size);
    if (status < 0)  //error
return status;

if (id == 0x7E1) {
// ContentEncAlgo
encryption->algo = UnserializeUInt(pReader, pos, size);
if (encryption->algo != 5)

return E_FILE_FORMAT_INVALID;
} else if (id == 0x7E2) {
// ContentEncKeyID
      delete[] encryption->key_id;
encryption->key_id = NULL;
encryption->key_id_len = 0;

if (size <= 0)
return E_FILE_FORMAT_INVALID;

const size_t buflen = static_cast<size_t>(size);
typedef unsigned char* buf_t;
const buf_t buf = new (std::nothrow) unsigned char[buflen];

if (buf == NULL)
return -1;

      const int read_status = pReader->Read(pos, buflen, buf);
if (read_status) {
        delete [] buf;
return status;
}

encryption->key_id = buf;

encryption->key_id_len = buflen;
} else if (id == 0x7E3) {
// ContentSignature
      delete[] encryption->signature;
encryption->signature = NULL;
encryption->signature_len = 0;

if (size <= 0)
return E_FILE_FORMAT_INVALID;

const size_t buflen = static_cast<size_t>(size);
typedef unsigned char* buf_t;
const buf_t buf = new (std::nothrow) unsigned char[buflen];

if (buf == NULL)
return -1;

      const int read_status = pReader->Read(pos, buflen, buf);
if (read_status) {
        delete [] buf;
return status;
}

encryption->signature = buf;

encryption->signature_len = buflen;
} else if (id == 0x7E4) {
// ContentSigKeyID
      delete[] encryption->sig_key_id;
encryption->sig_key_id = NULL;
encryption->sig_key_id_len = 0;

if (size <= 0)
return E_FILE_FORMAT_INVALID;

const size_t buflen = static_cast<size_t>(size);
typedef unsigned char* buf_t;
const buf_t buf = new (std::nothrow) unsigned char[buflen];

if (buf == NULL)
return -1;

      const int read_status = pReader->Read(pos, buflen, buf);
if (read_status) {
        delete [] buf;
return status;
}

encryption->sig_key_id = buf;
encryption->sig_key_id_len = buflen;
} else if (id == 0x7E5) {
// ContentSigAlgo
encryption->sig_algo = UnserializeUInt(pReader, pos, size);
} else if (id == 0x7E6) {
// ContentSigHashAlgo
encryption->sig_hash_algo = UnserializeUInt(pReader, pos, size);

} else if (id == 0x7E7) {
// ContentEncAESSettings
const long status = ParseContentEncAESSettingsEntry(
          pos,
          size,
          pReader,
          &encryption->aes_settings);
if (status)
return status;
}

    pos += size;  //consume payload
assert(pos <= stop);
}

return 0;
}

long long SegmentInfo::GetTimeCodeScale() const
{
    return m_timecodeScale;
}

static unsigned int subpel_variance_ref(const uint8_t *ref, const uint8_t *src,
                                        int l2w, int l2h, int xoff, int yoff,
                                        unsigned int *sse_ptr) {
  int se = 0;
  unsigned int sse = 0;
  const int w = 1 << l2w, h = 1 << l2h;
for (int y = 0; y < h; y++) {
for (int x = 0; x < w; x++) {
      // bilinear interpolation at a 16th pel step
      const int a1 = ref[(w + 1) * (y + 0) + x + 0];
      const int a2 = ref[(w + 1) * (y + 0) + x + 1];
      const int b1 = ref[(w + 1) * (y + 1) + x + 0];
      const int b2 = ref[(w + 1) * (y + 1) + x + 1];
      const int a = a1 + (((a2 - a1) * xoff + 8) >> 4);
      const int b = b1 + (((b2 - b1) * xoff + 8) >> 4);
      const int r = a + (((b - a) * yoff + 8) >> 4);
      int diff = r - src[w * y + x];
      se += diff;
      sse += diff * diff;
}
}
  *sse_ptr = sse;
  return sse - (((int64_t) se * se) >> (l2w + l2h));
}

long long Block::GetTimeCode(const Cluster* pCluster) const
{
    if (pCluster == 0)
        return m_timecode;

    const long long tc0 = pCluster->GetTimeCode();
    assert(tc0 >= 0);

    const long long tc = tc0 + m_timecode;
    return tc;  //unscaled timecode units
}

void EncoderTest::SetMode(TestMode mode) {
 switch (mode) {
 case kRealTime:
      deadline_ = VPX_DL_REALTIME;
 break;

 case kOnePassGood:
 case kTwoPassGood:
      deadline_ = VPX_DL_GOOD_QUALITY;
 break;

 case kOnePassBest:
 case kTwoPassBest:
      deadline_ = VPX_DL_BEST_QUALITY;
 break;

 default:
      ASSERT_TRUE(false) << "Unexpected mode " << mode;
 }

 if (mode == kTwoPassGood || mode == kTwoPassBest)
    passes_ = 2;
 else
    passes_ = 1;
}

const Chapters::Atom* Chapters::Edition::GetAtom(int index) const
{
    if (index < 0)
        return NULL;

    if (index >= m_atoms_count)
        return NULL;

    return m_atoms + index;
}

Track::EOSBlock::EOSBlock() :
    BlockEntry(NULL, LONG_MIN)
{
}

 virtual void EndPassHook(void) {
 for (int layer = 0; layer < static_cast<int>(cfg_.ts_number_layers);
 ++layer) {
      duration_ = (last_pts_ + 1) * timebase_;
 if (bits_total_[layer]) {
        effective_datarate_[layer] = (bits_total_[layer] / 1000.0) / duration_;
 }
 }
 }

long Cluster::GetNext(
    const BlockEntry* pCurr,
    const BlockEntry*& pNext) const
{
    assert(pCurr);
assert(m_entries);
assert(m_entries_count > 0);
    size_t idx = pCurr->GetIndex();
assert(idx < size_t(m_entries_count));
    assert(m_entries[idx] == pCurr);

    ++idx;

    if (idx >= size_t(m_entries_count))
    {
        long long pos;
        long len;
        const long status = Parse(pos, len);
        if (status < 0)  //error
        {
            pNext = NULL;
            return status;
        }
        if (status > 0)
        {
            pNext = NULL;
            return 0;
        }
        assert(m_entries);
        assert(m_entries_count > 0);
        assert(idx < size_t(m_entries_count));
    }
    pNext = m_entries[idx];
    assert(pNext);
    return 0;
}

const char* Chapters::Display::GetString() const
{
    return m_string;
}

void SubpelVarianceTest<SubpelVarianceFunctionType>::RefTest() {
  for (int x = 0; x < 16; ++x) {
    for (int y = 0; y < 16; ++y) {
      for (int j = 0; j < block_size_; j++) {
        src_[j] = rnd.Rand8();
      }
      for (int j = 0; j < block_size_ + width_ + height_ + 1; j++) {
        ref_[j] = rnd.Rand8();
}
unsigned int sse1, sse2;
unsigned int var1;
      REGISTER_STATE_CHECK(var1 = subpel_variance_(ref_, width_ + 1, x, y,
                                                   src_, width_, &sse1));
      const unsigned int var2 = subpel_variance_ref(ref_, src_, log2width_,
                                                    log2height_, x, y, &sse2);
EXPECT_EQ(sse1, sse2) << "at position " << x << ", " << y;
EXPECT_EQ(var1, var2) << "at position " << x << ", " << y;
}
}
}

 virtual void ResetModel() {
    last_pts_ = 0;
    bits_in_buffer_model_ = cfg_.rc_target_bitrate * cfg_.rc_buf_initial_sz;
    frame_number_ = 0;

     first_drop_ = 0;
     bits_total_ = 0;
     duration_ = 0.0;
   }

void fdct16x16_ref(const int16_t *in, int16_t *out, int stride, int tx_type) {
  vp9_fdct16x16_c(in, out, stride);
}

 void SetupMacroblock(MACROBLOCKD *mbptr,
                       MODE_INFO *miptr,
 uint8_t *data,
 int block_size,
 int stride,
 int num_planes) {
    mbptr_ = mbptr;
    miptr_ = miptr;
    mbptr_->up_available = 1;
    mbptr_->left_available = 1;
    mbptr_->mode_info_context = miptr_;
    stride_ = stride;
    block_size_ = block_size;
    num_planes_ = num_planes;
 for (int p = 0; p < num_planes; p++)
      data_ptr_[p] = data + stride * (block_size + 1) * p +
                     stride + block_size;
 }

Tracks::Tracks(
    Segment* pSegment,
    long long start,
    long long size_,
    long long element_start,
    long long element_size) :
    m_pSegment(pSegment),
    m_start(start),
    m_size(size_),
    m_element_start(element_start),
    m_element_size(element_size),
    m_trackEntries(NULL),
    m_trackEntriesEnd(NULL)
{
}

 static int ClipByte(int value) {
 if (value > 255)
 return 255;
 else if (value < 0)
 return 0;
 return value;
 }

ConvolveFunctions(convolve_fn_t h8, convolve_fn_t h8_avg,
                    convolve_fn_t v8, convolve_fn_t v8_avg,
                    convolve_fn_t hv8, convolve_fn_t hv8_avg)
      : h8_(h8), v8_(v8), hv8_(hv8), h8_avg_(h8_avg), v8_avg_(v8_avg),
        hv8_avg_(hv8_avg) {}

const Cluster* BlockEntry::GetCluster() const
{
    return m_pCluster;
}

long Cluster::GetEntry(long index, const mkvparser::BlockEntry*& pEntry) const
{
    assert(m_pos >= m_element_start);
    pEntry = NULL;
    if (index < 0)
        return -1;  //generic error
    if (m_entries_count < 0)
        return E_BUFFER_NOT_FULL;
    assert(m_entries);
    assert(m_entries_size > 0);
    assert(m_entries_count <= m_entries_size);
    if (index < m_entries_count)
    {
        pEntry = m_entries[index];
        assert(pEntry);
        return 1;  //found entry
}

    if (m_element_size < 0)        //we don't know cluster end yet
        return E_BUFFER_NOT_FULL;  //underflow

    const long long element_stop = m_element_start + m_element_size;

    if (m_pos >= element_stop)
        return 0;  //nothing left to parse
    return E_BUFFER_NOT_FULL;  //underflow, since more remains to be parsed
}

MD5Update(struct MD5Context *ctx, md5byte const *buf, unsigned len) {
  UWORD32 t;

 /* Update byte count */

  t = ctx->bytes[0];

 if ((ctx->bytes[0] = t + len) < t)
    ctx->bytes[1]++; /* Carry from low to high */

  t = 64 - (t & 0x3f); /* Space available in ctx->in (at least 1) */

 if (t > len) {
    memcpy((md5byte *)ctx->in + 64 - t, buf, len);
 return;
 }

 /* First chunk is an odd size */
  memcpy((md5byte *)ctx->in + 64 - t, buf, t);
  byteSwap(ctx->in, 16);
  MD5Transform(ctx->buf, ctx->in);
  buf += t;
  len -= t;

 /* Process data in 64-byte chunks */
 while (len >= 64) {
    memcpy(ctx->in, buf, 64);
    byteSwap(ctx->in, 16);
    MD5Transform(ctx->buf, ctx->in);
    buf += 64;
    len -= 64;
 }

 /* Handle any remaining bytes of data. */
  memcpy(ctx->in, buf, len);
}

void reference_idct_2d(double input[64], int16_t output[64]) {
 double out[64], out2[64];
 for (int i = 0; i < 8; ++i) {
 double temp_in[8], temp_out[8];
 for (int j = 0; j < 8; ++j)
      temp_in[j] = input[j + i*8];
    reference_idct_1d(temp_in, temp_out);
 for (int j = 0; j < 8; ++j)
      out[j + i*8] = temp_out[j];
 }
 for (int i = 0; i < 8; ++i) {
 double temp_in[8], temp_out[8];
 for (int j = 0; j < 8; ++j)
      temp_in[j] = out[j*8 + i];
    reference_idct_1d(temp_in, temp_out);
 for (int j = 0; j < 8; ++j)
      out2[j*8 + i] = temp_out[j];
 }
 for (int i = 0; i < 64; ++i)
    output[i] = round(out2[i]/32);
}

long Segment::Load()
{
    assert(m_clusters == NULL);
    assert(m_clusterSize == 0);
    assert(m_clusterCount == 0);
    //assert(m_size >= 0);

    //Outermost (level 0) segment object has been constructed,
    //and pos designates start of payload.  We need to find the
    //inner (level 1) elements.

    const long long header_status = ParseHeaders();

    if (header_status < 0)  //error
        return static_cast<long>(header_status);

    if (header_status > 0)  //underflow
        return E_BUFFER_NOT_FULL;

    assert(m_pInfo);
    assert(m_pTracks);

    for (;;)
    {
        const int status = LoadCluster();

        if (status < 0)  //error
            return status;

        if (status >= 1)  //no more clusters
            return 0;
    }
}

 virtual void MismatchHook(const vpx_image_t *img1,
 const vpx_image_t *img2) {
 double mismatch_psnr = compute_psnr(img1, img2);
    mismatch_psnr_ += mismatch_psnr;
 ++mismatch_nframes_;
 }

const Block* Track::EOSBlock::GetBlock() const
{
    return NULL;
}

long long CuePoint::GetTime(const Segment* pSegment) const
{
    assert(pSegment);
    assert(m_timecode >= 0);
    const SegmentInfo* const pInfo = pSegment->GetInfo();
    assert(pInfo);
    const long long scale = pInfo->GetTimeCodeScale();
    assert(scale >= 1);
    const long long time = scale * m_timecode;
    return time;
}

 virtual bool DoDecode() const {
 if (error_nframes_ > 0 &&
 (cfg_.g_pass == VPX_RC_LAST_PASS || cfg_.g_pass == VPX_RC_ONE_PASS)) {
 for (unsigned int i = 0; i < error_nframes_; ++i) {
 if (error_frames_[i] == nframes_ - 1) {
          std::cout << "             Skipping decoding frame: "
 << error_frames_[i] << "\n";
 return 0;
 }
 }
 }
 return 1;
 }

static void die_codec(vpx_codec_ctx_t *ctx, const char *s) {
    const char *detail = vpx_codec_error_detail(ctx);
    printf("%s: %s\n", s, vpx_codec_error(ctx));
    if(detail)
        printf("    %s\n",detail);
    exit(EXIT_FAILURE);
}

void mkvparser::GetVersion(int& major, int& minor, int& build, int& revision)
{
    major = 1;
    minor = 0;
    build = 0;
    revision = 27;
}

 virtual ~SuperframeTest() {}

   static void SetUpTestCase() {
     src_ = reinterpret_cast<uint8_t*>(vpx_memalign(kDataAlignment, kSrcSize));
    dst_ = reinterpret_cast<uint8_t*>(vpx_memalign(kDataAlignment, kDstSize));
    dst_c_ = reinterpret_cast<uint8_t*>(vpx_memalign(kDataAlignment, kDstSize));
 }

static void SetUpTestCase() {
    source_data_ = reinterpret_cast<uint8_t*>(
vpx_memalign(kDataAlignment, kDataBlockSize));
    reference_data_ = reinterpret_cast<uint8_t*>(
vpx_memalign(kDataAlignment, kDataBufferSize));
}

   int n_frames() const { return n_frames_; }

int Track::Info::CopyStr(char* Info::*str, Info& dst_) const
{
    if (str == static_cast<char* Info::*>(NULL))
        return -1;
    char*& dst = dst_.*str;
    if (dst)  //should be NULL already
        return -1;
    const char* const src = this->*str;
    if (src == NULL)
        return 0;
    const size_t len = strlen(src);
    dst = new (std::nothrow) char[len+1];
    if (dst == NULL)
        return -1;
    strcpy(dst, src);
return 0;
}

 virtual const vpx_codec_cx_pkt_t * MutateEncoderOutputHook(
 const vpx_codec_cx_pkt_t *pkt) {
 if (pkt->kind != VPX_CODEC_CX_FRAME_PKT)
 return pkt;

 const uint8_t *buffer = reinterpret_cast<uint8_t*>(pkt->data.frame.buf);
 const uint8_t marker = buffer[pkt->data.frame.sz - 1];
 const int frames = (marker & 0x7) + 1;
 const int mag = ((marker >> 3) & 3) + 1;
 const unsigned int index_sz = 2 + mag  * frames;
 if ((marker & 0xe0) == 0xc0 &&
        pkt->data.frame.sz >= index_sz &&
        buffer[pkt->data.frame.sz - index_sz] == marker) {
 if (modified_buf_)
 delete[] modified_buf_;
      modified_buf_ = new uint8_t[pkt->data.frame.sz - index_sz];
      memcpy(modified_buf_, pkt->data.frame.buf,
             pkt->data.frame.sz - index_sz);
      modified_pkt_ = *pkt;
      modified_pkt_.data.frame.buf = modified_buf_;
      modified_pkt_.data.frame.sz -= index_sz;

      sf_count_++;
      last_sf_pts_ = pkt->data.frame.pts;
 return &modified_pkt_;
 }

    abort_ |= sf_count_ > sf_count_max_ &&
              pkt->data.frame.pts - last_sf_pts_ >= 5;
 return pkt;
 }

   static void SetUpTestCase() {
     mb_ = reinterpret_cast<MACROBLOCKD*>(
        vpx_memalign(32, sizeof(MACROBLOCKD)));
    mi_ = reinterpret_cast<MODE_INFO*>(
        vpx_memalign(32, sizeof(MODE_INFO)));
    data_array_ = reinterpret_cast<uint8_t*>(
        vpx_memalign(kDataAlignment, kDataBufferSize));
 }

SvcTest()
: codec_iface_(0),
test_file_name_("hantro_collage_w352h288.yuv"),
        stats_file_name_("hantro_collage_w352h288.stat"),
codec_initialized_(false),
decoder_(0) {
memset(&svc_, 0, sizeof(svc_));
memset(&codec_, 0, sizeof(codec_));
memset(&codec_enc_, 0, sizeof(codec_enc_));
}

static unsigned int variance_ref(const uint8_t *ref, const uint8_t *src,
                                 int l2w, int l2h, unsigned int *sse_ptr) {
  int se = 0;
  unsigned int sse = 0;
  const int w = 1 << l2w, h = 1 << l2h;
  for (int y = 0; y < h; y++) {
    for (int x = 0; x < w; x++) {
      int diff = ref[w * y + x] - src[w * y + x];
      se += diff;
      sse += diff * diff;
    }
}
  *sse_ptr = sse;
  return sse - (((int64_t) se * se) >> (l2w + l2h));
}

   virtual void TearDown() {
     libvpx_test::ClearSystemState();
 }

MD5Init(struct MD5Context *ctx) {
  ctx->buf[0] = 0x67452301;
  ctx->buf[1] = 0xefcdab89;
  ctx->buf[2] = 0x98badcfe;
  ctx->buf[3] = 0x10325476;

  ctx->bytes[0] = 0;
  ctx->bytes[1] = 0;
}

CuePoint::CuePoint(long idx, long long pos) :
    m_element_start(0),
    m_element_size(0),
    m_index(idx),
    m_timecode(-1 * pos),
    m_track_positions(NULL),
    m_track_positions_count(0)
{
    assert(pos > 0);
}

BlockEntry::BlockEntry(Cluster* p, long idx) :
    m_pCluster(p),
    m_index(idx)
{
}

  CpuSpeedTest() : EncoderTest(GET_PARAM(0)) {}

 static void get_image_md5(const vpx_image_t *img, unsigned char digest[16]) {
 int plane, y;
  MD5Context md5;

  MD5Init(&md5);

 for (plane = 0; plane < 3; ++plane) {
 const unsigned char *buf = img->planes[plane];
 const int stride = img->stride[plane];
 const int w = plane ? (img->d_w + 1) >> 1 : img->d_w;
 const int h = plane ? (img->d_h + 1) >> 1 : img->d_h;

 for (y = 0; y < h; ++y) {
      MD5Update(&md5, buf, w);
      buf += stride;
 }
 }

  MD5Final(digest, &md5);
}

Cluster* Cluster::Create(
    Segment* pSegment,
    long idx,
    long long off)
    //long long element_size)
{
    assert(pSegment);
    assert(off >= 0);
    const long long element_start = pSegment->m_start + off;
    Cluster* const pCluster = new Cluster(pSegment,
                                          idx,
                                          element_start);
                                          //element_size);
    assert(pCluster);
    return pCluster;
}

void Chapters::Display::ShallowCopy(Display& rhs) const
{
    rhs.m_string = m_string;
    rhs.m_language = m_language;
    rhs.m_country = m_country;
}

  LosslessTestLarge()
       : EncoderTest(GET_PARAM(0)),
         psnr_(kMaxPsnr),
         nframes_(0),
         encoding_mode_(GET_PARAM(1)) {
   }

Block::Block(long long start, long long size_, long long discard_padding) :
    m_start(start),
    m_size(size_),
    m_track(0),
    m_timecode(-1),
    m_flags(0),
    m_frames(NULL),
    m_frame_count(-1),
    m_discard_padding(discard_padding)
{
}

static void write_ivf_frame_header(FILE *outfile,
 const vpx_codec_cx_pkt_t *pkt)
{
 char             header[12];
 vpx_codec_pts_t  pts;

 if(pkt->kind != VPX_CODEC_CX_FRAME_PKT)
 return;

    pts = pkt->data.frame.pts;
    mem_put_le32(header, pkt->data.frame.sz);
    mem_put_le32(header+4, pts&0xFFFFFFFF);
    mem_put_le32(header+8, pts >> 32);


     (void) fwrite(header, 1, 12, outfile);
 }

 ErrorResilienceTestLarge()
 : EncoderTest(GET_PARAM(0)),
        psnr_(0.0),
        nframes_(0),
        mismatch_psnr_(0.0),
        mismatch_nframes_(0),
        encoding_mode_(GET_PARAM(1)) {
 Reset();
 }

virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {
#if WRITE_COMPRESSED_STREAM
++out_frames_;

// Write initial file header if first frame.
if (pkt->data.frame.pts == 0)
write_ivf_file_header(&cfg_, 0, outfile_);


// Write frame header and data.
write_ivf_frame_header(pkt, outfile_);
(void)fwrite(pkt->data.frame.buf, 1, pkt->data.frame.sz, outfile_);
#endif
}

 static void append_negative_gtest_filter(const char *str) {
   std::string filter = ::testing::FLAGS_gtest_filter;
 if (filter.find('-') == std::string::npos) filter += '-';
  filter += str;
 ::testing::FLAGS_gtest_filter = filter;
}

bool mkvparser::Match(
    IMkvReader* pReader,
    long long& pos,
    unsigned long id_,
    unsigned char*& buf,
    size_t& buflen)
{
    assert(pReader);
    assert(pos >= 0);

    long long total, available;

    long status = pReader->Length(&total, &available);
    assert(status >= 0);
    assert((total < 0) || (available <= total));
    if (status < 0)
        return false;

    long len;
    const long long id = ReadUInt(pReader, pos, len);
    assert(id >= 0);
    assert(len > 0);
    assert(len <= 8);
    assert((pos + len) <= available);

    if ((unsigned long)id != id_)
        return false;

    pos += len;  //consume id

    const long long size_ = ReadUInt(pReader, pos, len);
    assert(size_ >= 0);
    assert(len > 0);
    assert(len <= 8);
    assert((pos + len) <= available);

    pos += len;  //consume length of size of payload
    assert((pos + size_) <= available);

    const long buflen_ = static_cast<long>(size_);

    buf = new (std::nothrow) unsigned char[buflen_];
    assert(buf);  //TODO

    status = pReader->Read(pos, buflen_, buf);
    assert(status == 0);  //TODO

    buflen = buflen_;

    pos += size_;  //consume size of payload
    return true;
}

   virtual ~Trans16x16DCT() {}

void test_decrypt_cb(void *decrypt_state, const uint8_t *input,
 uint8_t *output, int count) {
  encrypt_buffer(input, output, count,
                 input - reinterpret_cast<uint8_t *>(decrypt_state));
}

 DatarateTestVP9Large() : EncoderTest(GET_PARAM(0)) {}

bool Cues::DoneParsing() const
{
    const long long stop = m_start + m_size;
    return (m_pos >= stop);
}

const Block* BlockGroup::GetBlock() const
{
    return &m_block;
}

 virtual void EndPassHook(void) {
 if (bits_total_) {
 const double file_size_in_kb = bits_total_ / 1000.; // bits per kilobit

      duration_ = (last_pts_ + 1) * timebase_;

      effective_datarate_ = (bits_total_ - bits_in_last_frame_) / 1000.0
 / (cfg_.rc_buf_initial_sz / 1000.0 + duration_);

      file_datarate_ = file_size_in_kb / duration_;
 }
 }

   virtual void SetUp() {
 InitializeConfig();
 SetMode(encoding_mode_);
 }

int Chapters::Edition::GetAtomCount() const
{
    return m_atoms_count;
}

SeekHead::~SeekHead()
{
    delete[] m_entries;
    delete[] m_void_elements;
}

SoftVPX::~SoftVPX() {
    vpx_codec_destroy((vpx_codec_ctx_t *)mCtx);
 delete (vpx_codec_ctx_t *)mCtx;
    mCtx = NULL;
}

void Encoder::EncodeFrameInternal(const VideoSource &video,
const unsigned long frame_flags) {

vpx_codec_err_t res;
const vpx_image_t *img = video.img();

  // Handle first frame initialization
  if (!encoder_.priv) {
    cfg_.g_w = img->d_w;
    cfg_.g_h = img->d_h;
    cfg_.g_timebase = video.timebase();
    cfg_.rc_twopass_stats_in = stats_->buf();
    res = vpx_codec_enc_init(&encoder_, CodecInterface(), &cfg_,
                             init_flags_);
    ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();
  }
// Handle frame resizing
if (cfg_.g_w != img->d_w || cfg_.g_h != img->d_h) {
cfg_.g_w = img->d_w;
cfg_.g_h = img->d_h;
res = vpx_codec_enc_config_set(&encoder_, &cfg_);
ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();

}

// Encode the frame
  REGISTER_STATE_CHECK(
      res = vpx_codec_encode(&encoder_,
                             video.img(), video.pts(), video.duration(),
frame_flags, deadline_));
ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();
}

int main(int argc, char **argv) {
int frame_cnt = 0;
FILE *outfile = NULL;
vpx_codec_ctx_t codec;
vpx_codec_err_t res;
VpxVideoReader *reader = NULL;
const VpxInterface *decoder = NULL;
const VpxVideoInfo *info = NULL;

exec_name = argv[0];

if (argc != 3)
die("Invalid number of arguments.");

reader = vpx_video_reader_open(argv[1]);
if (!reader)
die("Failed to open %s for reading.", argv[1]);

if (!(outfile = fopen(argv[2], "wb")))
die("Failed to open %s for writing", argv[2]);

info = vpx_video_reader_get_info(reader);

decoder = get_vpx_decoder_by_fourcc(info->codec_fourcc);

if (!decoder)
die("Unknown input codec.");

  printf("Using %s\n", vpx_codec_iface_name(decoder->interface()));

  res = vpx_codec_dec_init(&codec, decoder->interface(), NULL,
VPX_CODEC_USE_POSTPROC);
if (res == VPX_CODEC_INCAPABLE)
die_codec(&codec, "Postproc not supported by this decoder.");

if (res)
die_codec(&codec, "Failed to initialize decoder.");

while (vpx_video_reader_read_frame(reader)) {
vpx_codec_iter_t iter = NULL;
vpx_image_t *img = NULL;
size_t frame_size = 0;
const unsigned char *frame = vpx_video_reader_get_frame(reader,
&frame_size);

++frame_cnt;

if (frame_cnt % 30 == 1) {
vp8_postproc_cfg_t pp = {0, 0, 0};

if (vpx_codec_control(&codec, VP8_SET_POSTPROC, &pp))
die_codec(&codec, "Failed to turn off postproc.");
} else if (frame_cnt % 30 == 16) {
vp8_postproc_cfg_t pp = {VP8_DEBLOCK | VP8_DEMACROBLOCK | VP8_MFQE,
4, 0};
if (vpx_codec_control(&codec, VP8_SET_POSTPROC, &pp))
die_codec(&codec, "Failed to turn on postproc.");
};

// Decode the frame with 15ms deadline
if (vpx_codec_decode(&codec, frame, (unsigned int)frame_size, NULL, 15000))
die_codec(&codec, "Failed to decode frame");

while ((img = vpx_codec_get_frame(&codec, &iter)) != NULL) {
vpx_img_write(img, outfile);
}
}

printf("Processed %d frames.\n", frame_cnt);
if (vpx_codec_destroy(&codec))
die_codec(&codec, "Failed to destroy codec");

printf("Play: ffplay -f rawvideo -pix_fmt yuv420p -s %dx%d %s\n",
info->frame_width, info->frame_height, argv[2]);

vpx_video_reader_close(reader);

fclose(outfile);
return EXIT_SUCCESS;
}

long Track::GetFirst(const BlockEntry*& pBlockEntry) const
{
    const Cluster* pCluster = m_pSegment->GetFirst();
    for (int i = 0; ; )
    {
        if (pCluster == NULL)
        {
            pBlockEntry = GetEOS();
            return 1;
        }
        if (pCluster->EOS())
        {
#if 0
            if (m_pSegment->Unparsed() <= 0)  //all clusters have been loaded
            {
pBlockEntry = GetEOS();
return 1;
}
#else
            if (m_pSegment->DoneParsing())
            {
                pBlockEntry = GetEOS();
                return 1;
            }
#endif

            pBlockEntry = 0;
            return E_BUFFER_NOT_FULL;
        }
        long status = pCluster->GetFirst(pBlockEntry);
        if (status < 0)  //error
            return status;
        if (pBlockEntry == 0)  //empty cluster
        {
            pCluster = m_pSegment->GetNext(pCluster);
            continue;
        }
        for (;;)
        {
            const Block* const pBlock = pBlockEntry->GetBlock();
            assert(pBlock);
            const long long tn = pBlock->GetTrackNumber();
            if ((tn == m_info.number) && VetEntry(pBlockEntry))
                return 0;
            const BlockEntry* pNextEntry;
            status = pCluster->GetNext(pBlockEntry, pNextEntry);
            if (status < 0)  //error
                return status;
            if (pNextEntry == 0)
                break;
            pBlockEntry = pNextEntry;
        }
        ++i;
        if (i >= 100)
            break;
        pCluster = m_pSegment->GetNext(pCluster);
}

    //NOTE: if we get here, it means that we didn't find a block with
    //a matching track number.  We interpret that as an error (which
    //might be too conservative).

    pBlockEntry = GetEOS();  //so we can return a non-NULL value
    return 1;
}

 virtual void TearDown() {
    libvpx_test::ClearSystemState();
 }

 virtual ~ResizeTest() {}

void show_q_histogram(const int counts[64], int max_buckets) {
 struct hist_bucket bucket[64];
 int buckets = 0;
 int total = 0;
 int scale;
 int i;

 for (i = 0; i < 64; i++) {
 if (counts[i]) {
      bucket[buckets].low = bucket[buckets].high = i;
      bucket[buckets].count = counts[i];
      buckets++;
      total += counts[i];
 }
 }

  fprintf(stderr, "\nQuantizer Selection:\n");
  scale = merge_hist_buckets(bucket, max_buckets, &buckets);
  show_histogram(bucket, buckets, total, scale);
}

unsigned long Segment::GetCount() const
{
    return m_clusterCount;
}

long Block::Parse(const Cluster* pCluster)
{
    if (pCluster == NULL)
        return -1;

    if (pCluster->m_pSegment == NULL)
        return -1;

    assert(m_start >= 0);
    assert(m_size >= 0);
    assert(m_track <= 0);
    assert(m_frames == NULL);
    assert(m_frame_count <= 0);

    long long pos = m_start;
    const long long stop = m_start + m_size;

    long len;

    IMkvReader* const pReader = pCluster->m_pSegment->m_pReader;

    m_track = ReadUInt(pReader, pos, len);

    if (m_track <= 0)
        return E_FILE_FORMAT_INVALID;

    if ((pos + len) > stop)
        return E_FILE_FORMAT_INVALID;

    pos += len;  //consume track number

    if ((stop - pos) < 2)
        return E_FILE_FORMAT_INVALID;

    long status;
    long long value;

    status = UnserializeInt(pReader, pos, 2, value);

    if (status)
        return E_FILE_FORMAT_INVALID;

    if (value < SHRT_MIN)
        return E_FILE_FORMAT_INVALID;

    if (value > SHRT_MAX)
        return E_FILE_FORMAT_INVALID;

    m_timecode = static_cast<short>(value);

    pos += 2;

    if ((stop - pos) <= 0)
        return E_FILE_FORMAT_INVALID;
    status = pReader->Read(pos, 1, &m_flags);
    if (status)
        return E_FILE_FORMAT_INVALID;
    const int lacing = int(m_flags & 0x06) >> 1;
    ++pos;  //consume flags byte
    if (lacing == 0)  //no lacing
    {
        if (pos > stop)
            return E_FILE_FORMAT_INVALID;
        m_frame_count = 1;
        m_frames = new Frame[m_frame_count];
        Frame& f = m_frames[0];
        f.pos = pos;
        const long long frame_size = stop - pos;
        if (frame_size > LONG_MAX)
            return E_FILE_FORMAT_INVALID;
        f.len = static_cast<long>(frame_size);
        return 0;  //success
    }
    if (pos >= stop)
        return E_FILE_FORMAT_INVALID;
    unsigned char biased_count;
    status = pReader->Read(pos, 1, &biased_count);
    if (status)
        return E_FILE_FORMAT_INVALID;
    ++pos;  //consume frame count
    assert(pos <= stop);
    m_frame_count = int(biased_count) + 1;
m_frames = new Frame[m_frame_count];
    assert(m_frames);

    if (lacing == 1)  //Xiph
    {
        Frame* pf = m_frames;
        Frame* const pf_end = pf + m_frame_count;

        long size = 0;
        int frame_count = m_frame_count;

        while (frame_count > 1)
        {
            long frame_size = 0;

            for (;;)
            {
                unsigned char val;

                if (pos >= stop)
                    return E_FILE_FORMAT_INVALID;

                status = pReader->Read(pos, 1, &val);

                if (status)
                    return E_FILE_FORMAT_INVALID;

                ++pos;  //consume xiph size byte

                frame_size += val;

                if (val < 255)
                    break;
            }

            Frame& f = *pf++;
            assert(pf < pf_end);

            f.pos = 0;  //patch later

            f.len = frame_size;
            size += frame_size;  //contribution of this frame

            --frame_count;
        }

        assert(pf < pf_end);
        assert(pos <= stop);

        {
            Frame& f = *pf++;
            if (pf != pf_end)
                return E_FILE_FORMAT_INVALID;
            f.pos = 0;  //patch later
            const long long total_size = stop - pos;
            if (total_size < size)
                return E_FILE_FORMAT_INVALID;
            const long long frame_size = total_size - size;
            if (frame_size > LONG_MAX)
                return E_FILE_FORMAT_INVALID;
            f.len = static_cast<long>(frame_size);
        }
        pf = m_frames;
        while (pf != pf_end)
        {
            Frame& f = *pf++;
            assert((pos + f.len) <= stop);
            f.pos = pos;
            pos += f.len;
        }
        assert(pos == stop);
    }
    else if (lacing == 2)  //fixed-size lacing
    {
        const long long total_size = stop - pos;
        if ((total_size % m_frame_count) != 0)
            return E_FILE_FORMAT_INVALID;
        const long long frame_size = total_size / m_frame_count;
        if (frame_size > LONG_MAX)
            return E_FILE_FORMAT_INVALID;
        Frame* pf = m_frames;
        Frame* const pf_end = pf + m_frame_count;
        while (pf != pf_end)
        {
            assert((pos + frame_size) <= stop);
            Frame& f = *pf++;
            f.pos = pos;
            f.len = static_cast<long>(frame_size);
            pos += frame_size;
        }
        assert(pos == stop);
    }
    else
    {
        assert(lacing == 3);  //EBML lacing

if (pos >= stop)
            return E_FILE_FORMAT_INVALID;

        long size = 0;
        int frame_count = m_frame_count;

        long long frame_size = ReadUInt(pReader, pos, len);

        if (frame_size < 0)
            return E_FILE_FORMAT_INVALID;

        if (frame_size > LONG_MAX)
            return E_FILE_FORMAT_INVALID;

        if ((pos + len) > stop)
            return E_FILE_FORMAT_INVALID;

        pos += len; //consume length of size of first frame

        if ((pos + frame_size) > stop)
            return E_FILE_FORMAT_INVALID;

        Frame* pf = m_frames;
        Frame* const pf_end = pf + m_frame_count;

        {
            Frame& curr = *pf;
            curr.pos = 0;  //patch later
            curr.len = static_cast<long>(frame_size);
            size += curr.len;  //contribution of this frame
        }
        --frame_count;
        while (frame_count > 1)
        {
            if (pos >= stop)
                return E_FILE_FORMAT_INVALID;
            assert(pf < pf_end);
            const Frame& prev = *pf++;
            assert(prev.len == frame_size);
            if (prev.len != frame_size)
                return E_FILE_FORMAT_INVALID;
            assert(pf < pf_end);
            Frame& curr = *pf;
            curr.pos = 0;  //patch later
            const long long delta_size_ = ReadUInt(pReader, pos, len);
            if (delta_size_ < 0)
                return E_FILE_FORMAT_INVALID;
            if ((pos + len) > stop)
                return E_FILE_FORMAT_INVALID;
            pos += len;  //consume length of (delta) size
            assert(pos <= stop);
            const int exp = 7*len - 1;
            const long long bias = (1LL << exp) - 1LL;
            const long long delta_size = delta_size_ - bias;
            frame_size += delta_size;
            if (frame_size < 0)
                return E_FILE_FORMAT_INVALID;
            if (frame_size > LONG_MAX)
                return E_FILE_FORMAT_INVALID;
            curr.len = static_cast<long>(frame_size);
            size += curr.len;  //contribution of this frame
            --frame_count;
        }
        {
            assert(pos <= stop);
            assert(pf < pf_end);
            const Frame& prev = *pf++;
            assert(prev.len == frame_size);
            if (prev.len != frame_size)
                return E_FILE_FORMAT_INVALID;
            assert(pf < pf_end);
            Frame& curr = *pf++;
            assert(pf == pf_end);
            curr.pos = 0;  //patch later
            const long long total_size = stop - pos;
            if (total_size < size)
                return E_FILE_FORMAT_INVALID;
            frame_size = total_size - size;
            if (frame_size > LONG_MAX)
                return E_FILE_FORMAT_INVALID;
            curr.len = static_cast<long>(frame_size);
        }
        pf = m_frames;
        while (pf != pf_end)
        {
            Frame& f = *pf++;
            assert((pos + f.len) <= stop);
            f.pos = pos;
            pos += f.len;
        }
        assert(pos == stop);
}

    return 0;  //success
}

void encrypt_buffer(uint8_t *buffer, size_t size) {
 for (size_t i = 0; i < size; ++i) {
    buffer[i] ^= secret_key[i & 15];
 }
}

  void RunInvTxfm(int16_t *out, uint8_t *dst, int stride) {
     inv_txfm_(out, dst, stride);
   }

unsigned long long Track::GetDefaultDuration() const
{
    return m_info.defaultDuration;
}

 virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {
 vpx_codec_pts_t duration = pkt->data.frame.pts - last_pts_;

 if (duration > 1) {
 if (!first_drop_)
        first_drop_ = last_pts_ + 1;
      num_drops_ += static_cast<int>(duration - 1);
      tot_frame_number_ += static_cast<int>(duration - 1);
 }

 int layer = SetLayerId(tot_frame_number_, cfg_.ts_number_layers);

    bits_in_buffer_model_ += static_cast<int64_t>(
        duration * timebase_ * cfg_.rc_target_bitrate * 1000);

    ASSERT_GE(bits_in_buffer_model_, 0) << "Buffer Underrun at frame "
 << pkt->data.frame.pts;

 const size_t frame_size_in_bits = pkt->data.frame.sz * 8;

 for (int i = layer; i < static_cast<int>(cfg_.ts_number_layers); ++i) {
      bits_total_[i] += frame_size_in_bits;
 }

    last_pts_ = pkt->data.frame.pts;
 ++frame_number_;
 ++tot_frame_number_;
 }

   virtual ~SvcTest() {}

 virtual ~ErrorResilienceTestLarge() {}

void Chapters::Edition::Init()
{
    m_atoms = NULL;
    m_atoms_size = 0;
    m_atoms_count = 0;
}

const Block* SimpleBlock::GetBlock() const
{
    return &m_block;
}

const Track* Tracks::GetTrackByIndex(unsigned long idx) const
{
    const ptrdiff_t count = m_trackEntriesEnd - m_trackEntries;
    if (idx >= static_cast<unsigned long>(count))
         return NULL;
    return m_trackEntries[idx];
}

Segment::~Segment()
{
    const long count = m_clusterCount + m_clusterPreloadCount;

    Cluster** i = m_clusters;
    Cluster** j = m_clusters + count;

    while (i != j)
    {
        Cluster* const p = *i++;
        assert(p);

        delete p;
    }

    delete[] m_clusters;

    delete m_pTracks;
    delete m_pInfo;
    delete m_pCues;
    delete m_pChapters;
    delete m_pSeekHead;
}

double AudioTrack::GetSamplingRate() const
{
    return m_rate;
}

const char* SegmentInfo::GetTitleAsUTF8() const
{
    return m_pTitleAsUTF8;
}

unsigned long long Track::GetSeekPreRoll() const
{
    return m_info.seekPreRoll;
}

void usage_exit() {
   fprintf(stderr, "Usage: %s <infile> <outfile> <N-M|N/M>\n", exec_name);
   exit(EXIT_FAILURE);
 }

   virtual ~Trans16x16TestBase() {}

ContentEncoding::GetEncryptionByIndex(unsigned long idx) const {
   const ptrdiff_t count = encryption_entries_end_ - encryption_entries_;
   assert(count >= 0);
 
 if (idx >= static_cast<unsigned long>(count))
 return NULL;

 return encryption_entries_[idx];
}

void usage_exit() {
   fprintf(stderr, "Usage: %s <codec> <width> <height> <infile> <outfile>\n",
           exec_name);
   exit(EXIT_FAILURE);
 }

bool Chapters::Atom::ExpandDisplaysArray()
{
    if (m_displays_size > m_displays_count)
        return true;  // nothing else to do
    const int size = (m_displays_size == 0) ? 1 : 2 * m_displays_size;
    Display* const displays = new (std::nothrow) Display[size];
    if (displays == NULL)
        return false;
    for (int idx = 0; idx < m_displays_count; ++idx)
    {
        m_displays[idx].ShallowCopy(displays[idx]);
    }
    delete[] m_displays;
    m_displays = displays;
    m_displays_size = size;
    return true;
}

long mkvparser::ParseElementHeader(
    IMkvReader* pReader,
    long long& pos,
    long long stop,
    long long& id,
    long long& size)
{
    if ((stop >= 0) && (pos >= stop))
        return E_FILE_FORMAT_INVALID;

    long len;

    id = ReadUInt(pReader, pos, len);

    if (id < 0)
        return E_FILE_FORMAT_INVALID;

    pos += len;  //consume id

    if ((stop >= 0) && (pos >= stop))
        return E_FILE_FORMAT_INVALID;

    size = ReadUInt(pReader, pos, len);

    if (size < 0)
        return E_FILE_FORMAT_INVALID;

    pos += len;  //consume length of size

    //pos now designates payload

    if ((stop >= 0) && ((pos + size) > stop))
        return E_FILE_FORMAT_INVALID;
    return 0;  //success
}

const BlockEntry* Cluster::GetEntry(
    const Track* pTrack,
    long long time_ns) const
{
    assert(pTrack);
    if (m_pSegment == NULL)  //this is the special EOS cluster
        return pTrack->GetEOS();

#if 0

LoadBlockEntries();

if ((m_entries == NULL) || (m_entries_count <= 0))
return NULL; //return EOS here?

const BlockEntry* pResult = pTrack->GetEOS();

BlockEntry** i = m_entries;
assert(i);

BlockEntry** const j = i + m_entries_count;

while (i != j)
{
const BlockEntry* const pEntry = *i++;
assert(pEntry);
assert(!pEntry->EOS());

const Block* const pBlock = pEntry->GetBlock();
assert(pBlock);

if (pBlock->GetTrackNumber() != pTrack->GetNumber())
continue;

if (pTrack->VetEntry(pEntry))
{
if (time_ns < 0) //just want first candidate block
return pEntry;

const long long ns = pBlock->GetTime(this);

if (ns > time_ns)
break;

pResult = pEntry;
}
else if (time_ns >= 0)
{
const long long ns = pBlock->GetTime(this);

if (ns > time_ns)
break;
}
}

return pResult;


#else

    const BlockEntry* pResult = pTrack->GetEOS();

    long index = 0;

    for (;;)
    {
        if (index >= m_entries_count)
        {
            long long pos;
            long len;

            const long status = Parse(pos, len);
            assert(status >= 0);

            if (status > 0)  //completely parsed, and no more entries
                return pResult;

            if (status < 0)  //should never happen
                return 0;

            assert(m_entries);
            assert(index < m_entries_count);
        }
        const BlockEntry* const pEntry = m_entries[index];
        assert(pEntry);
        assert(!pEntry->EOS());
        const Block* const pBlock = pEntry->GetBlock();
        assert(pBlock);
        if (pBlock->GetTrackNumber() != pTrack->GetNumber())
        {
            ++index;
            continue;
        }
        if (pTrack->VetEntry(pEntry))
        {
            if (time_ns < 0)  //just want first candidate block
                return pEntry;
            const long long ns = pBlock->GetTime(this);
            if (ns > time_ns)
                return pResult;
            pResult = pEntry;  //have a candidate
        }
        else if (time_ns >= 0)
        {
            const long long ns = pBlock->GetTime(this);
            if (ns > time_ns)
                return pResult;
        }
        ++index;
}

#endif
}

 virtual void DecompressedFrameHook(const vpx_image_t &img,
 const unsigned int frame_number) {
    ASSERT_TRUE(md5_file_ != NULL);
 char expected_md5[33];
 char junk[128];

 const int res = fscanf(md5_file_, "%s  %s", expected_md5, junk);
    ASSERT_NE(EOF, res) << "Read md5 data failed";
    expected_md5[32] = '\0';

 ::libvpx_test::MD5 md5_res;
    md5_res.Add(&img);
 const char *const actual_md5 = md5_res.Get();

    ASSERT_STREQ(expected_md5, actual_md5)
 << "Md5 checksums don't match: frame number = " << frame_number;
 }

unsigned long ContentEncoding::GetEncryptionCount() const {
 const ptrdiff_t count = encryption_entries_end_ - encryption_entries_;
  assert(count >= 0);

 return static_cast<unsigned long>(count);

 }

const char* Track::GetCodecId() const
{
    return m_info.codecId;
}

void Segment::AppendCluster(Cluster* pCluster)
{
    assert(pCluster);
    assert(pCluster->m_index >= 0);

    const long count = m_clusterCount + m_clusterPreloadCount;

    long& size = m_clusterSize;
    assert(size >= count);

    const long idx = pCluster->m_index;
    assert(idx == m_clusterCount);

    if (count >= size)
    {
        const long n = (size <= 0) ? 2048 : 2*size;

        Cluster** const qq = new Cluster*[n];
        Cluster** q = qq;

        Cluster** p = m_clusters;
        Cluster** const pp = p + count;

        while (p != pp)
            *q++ = *p++;

        delete[] m_clusters;

        m_clusters = qq;
        size = n;
    }
    if (m_clusterPreloadCount > 0)
    {
        assert(m_clusters);
        Cluster** const p = m_clusters + m_clusterCount;
        assert(*p);
        assert((*p)->m_index < 0);
        Cluster** q = p + m_clusterPreloadCount;
        assert(q < (m_clusters + size));
        for (;;)
        {
            Cluster** const qq = q - 1;
            assert((*qq)->m_index < 0);
            *q = *qq;
            q = qq;
            if (q == p)
                break;
        }
    }
    m_clusters[idx] = pCluster;
    ++m_clusterCount;
}

long BlockGroup::Parse()
{
    const long status = m_block.Parse(m_pCluster);
    if (status)
        return status;
    m_block.SetKey((m_prev > 0) && (m_next <= 0));
    return 0;
}

   virtual ~FwdTrans8x8TestBase() {}

 void SetTopLeftUnavailable() {
 SetLeftUnavailable();
 SetTopUnavailable();
 }

static void encode_frame(vpx_codec_ctx_t *codec,
                         vpx_image_t *img,
                         int frame_index,
                         int flags,
                         VpxVideoWriter *writer) {
vpx_codec_iter_t iter = NULL;
const vpx_codec_cx_pkt_t *pkt = NULL;
const vpx_codec_err_t res = vpx_codec_encode(codec, img, frame_index, 1,
flags, VPX_DL_GOOD_QUALITY);
if (res != VPX_CODEC_OK)

die_codec(codec, "Failed to encode frame");

while ((pkt = vpx_codec_get_cx_data(codec, &iter)) != NULL) {
if (pkt->kind == VPX_CODEC_CX_FRAME_PKT) {
const int keyframe = (pkt->data.frame.flags & VPX_FRAME_IS_KEY) != 0;
if (!vpx_video_writer_write_frame(writer,
pkt->data.frame.buf,
pkt->data.frame.sz,

pkt->data.frame.pts)) {
die_codec(codec, "Failed to write compressed frame");
}
printf(keyframe ? "K" : ".");
fflush(stdout);
}
}
}

long long BlockGroup::GetDurationTimeCode() const
{
    return m_duration;
}

bool Chapters::Edition::ExpandAtomsArray()
{
    if (m_atoms_size > m_atoms_count)
        return true;  // nothing else to do

    const int size = (m_atoms_size == 0) ? 1 : 2 * m_atoms_size;

    Atom* const atoms = new (std::nothrow) Atom[size];

    if (atoms == NULL)
        return false;

    for (int idx = 0; idx < m_atoms_count; ++idx)
    {
        m_atoms[idx].ShallowCopy(atoms[idx]);
}

    delete[] m_atoms;
    m_atoms = atoms;

    m_atoms_size = size;
    return true;
}

void reference_idct4x4(const int16_t *input, int16_t *output) {
 const int16_t *ip = input;
 int16_t *op = output;

 for (int i = 0; i < 4; ++i) {
 const int a1 = ip[0] + ip[8];
 const int b1 = ip[0] - ip[8];
 const int temp1 = (ip[4] * sinpi8sqrt2) >> 16;
 const int temp2 = ip[12] + ((ip[12] * cospi8sqrt2minus1) >> 16);
 const int c1 = temp1 - temp2;
 const int temp3 = ip[4] + ((ip[4] * cospi8sqrt2minus1) >> 16);
 const int temp4 = (ip[12] * sinpi8sqrt2) >> 16;
 const int d1 = temp3 + temp4;
    op[0] = a1 + d1;
    op[12] = a1 - d1;
    op[4] = b1 + c1;
    op[8] = b1 - c1;
 ++ip;
 ++op;
 }
  ip = output;
  op = output;
 for (int i = 0; i < 4; ++i) {
 const int a1 = ip[0] + ip[2];
 const int b1 = ip[0] - ip[2];
 const int temp1 = (ip[1] * sinpi8sqrt2) >> 16;
 const int temp2 = ip[3] + ((ip[3] * cospi8sqrt2minus1) >> 16);
 const int c1 = temp1 - temp2;
 const int temp3 = ip[1] + ((ip[1] * cospi8sqrt2minus1) >> 16);
 const int temp4 = (ip[3] * sinpi8sqrt2) >> 16;
 const int d1 = temp3 + temp4;
    op[0] = (a1 + d1 + 4) >> 3;
    op[3] = (a1 - d1 + 4) >> 3;
    op[1] = (b1 + c1 + 4) >> 3;
    op[2] = (b1 - c1 + 4) >> 3;
    ip += 4;
    op += 4;
 }
}

long long Chapters::Atom::GetStopTime(const Chapters* pChapters) const
{
    return GetTime(pChapters, m_stop_timecode);
}

int arg_parse_enum_or_int(const struct arg *arg) {
 if (arg->def->enums)
 return arg_parse_enum(arg);
 return arg_parse_int(arg);
}

 SuperframeTest() : EncoderTest(GET_PARAM(0)), modified_buf_(NULL),
      last_sf_pts_(0) {}

int get_vp9_zero_frame_buffer(void *user_priv, size_t min_size,
 vpx_codec_frame_buffer_t *fb) {
 ExternalFrameBufferList *const fb_list =
 reinterpret_cast<ExternalFrameBufferList*>(user_priv);
 return fb_list->GetZeroFrameBuffer(min_size, fb);
}

 virtual void PreEncodeFrameHook(libvpx_test::VideoSource *video,
                                  libvpx_test::Encoder *encoder) {
 if (video->frame() == 1) {
      encoder->Control(VP8E_SET_ENABLEAUTOALTREF, 1);
 }
 }

long Segment::DoLoadClusterUnknownSize(
    long long& pos,
    long& len)
{
    assert(m_pos < 0);
    assert(m_pUnknownSize);

#if 0
assert(m_pUnknownSize->GetElementSize() < 0);  //TODO: verify this

const long long element_start = m_pUnknownSize->m_element_start;

pos = -m_pos;
assert(pos > element_start);

//We have already consumed the (cluster) ID and size fields.
//We just need to consume the blocks and other sub-elements
//of this cluster, until we discover the boundary.

long long total, avail;

long status = m_pReader->Length(&total, &avail);

if (status < 0) //error
return status;

assert((total < 0) || (avail <= total));

const long long segment_stop = (m_size < 0) ? -1 : m_start + m_size;


long long element_size = -1;

    for (;;)  //determine cluster size
    {
if ((total >= 0) && (pos >= total))
{
element_size = total - element_start;
assert(element_size > 0);

break;
}

if ((segment_stop >= 0) && (pos >= segment_stop))
{
element_size = segment_stop - element_start;
assert(element_size > 0);

break;
}

//Read ID

if ((pos + 1) > avail)
{
len = 1;
return E_BUFFER_NOT_FULL;
}

long long result = GetUIntLength(m_pReader, pos, len);

if (result < 0) //error
return static_cast<long>(result);

if (result > 0) //weird
return E_BUFFER_NOT_FULL;

if ((segment_stop >= 0) && ((pos + len) > segment_stop))
return E_FILE_FORMAT_INVALID;

if ((pos + len) > avail)
return E_BUFFER_NOT_FULL;

const long long idpos = pos;
const long long id = ReadUInt(m_pReader, idpos, len);

if (id < 0) //error (or underflow)
return static_cast<long>(id);

//This is the distinguished set of ID's we use to determine

//that we have exhausted the sub-element's inside the cluster
//whose ID we parsed earlier.

        if ((id == 0x0F43B675) || (id == 0x0C53BB6B)) //Cluster ID or Cues ID
        {
element_size = pos - element_start;
assert(element_size > 0);

break;
}

#ifdef _DEBUG
switch (id)
{
case 0x20: //BlockGroup
case 0x23: //Simple Block
case 0x67: //TimeCode
case 0x2B: //PrevSize
break;

default:
assert(false);
break;
}
#endif

pos += len; //consume ID (of sub-element)

//Read Size

if ((pos + 1) > avail)
{
len = 1;
return E_BUFFER_NOT_FULL;
}

result = GetUIntLength(m_pReader, pos, len);

if (result < 0) //error
return static_cast<long>(result);

if (result > 0) //weird
return E_BUFFER_NOT_FULL;

if ((segment_stop >= 0) && ((pos + len) > segment_stop))
return E_FILE_FORMAT_INVALID;

if ((pos + len) > avail)
return E_BUFFER_NOT_FULL;

const long long size = ReadUInt(m_pReader, pos, len);

if (size < 0) //error
return static_cast<long>(size);

pos += len; //consume size field of element

//pos now points to start of sub-element's payload

if (size == 0) //weird
continue;

const long long unknown_size = (1LL << (7 * len)) - 1;

if (size == unknown_size)
return E_FILE_FORMAT_INVALID; //not allowed for sub-elements

if ((segment_stop >= 0) && ((pos + size) > segment_stop)) //weird
return E_FILE_FORMAT_INVALID;

pos += size; //consume payload of sub-element
assert((segment_stop < 0) || (pos <= segment_stop));
} //determine cluster size

assert(element_size >= 0);

m_pos = element_start + element_size;
m_pUnknownSize = 0;


return 2;  //continue parsing
#else
    const long status = m_pUnknownSize->Parse(pos, len);

    if (status < 0)  //error or underflow
        return status;

    if (status == 0)  //parsed a block
        return 2;     //continue parsing

    assert(status > 0);   //nothing left to parse of this cluster

    const long long start = m_pUnknownSize->m_element_start;

    const long long size = m_pUnknownSize->GetElementSize();
    assert(size >= 0);

    pos = start + size;
    m_pos = pos;

    m_pUnknownSize = 0;

    return 2;  //continue parsing
#endif
}

Segment::Segment(
    IMkvReader* pReader,
    long long elem_start,
    //long long elem_size,
    long long start,
    long long size) :
    m_pReader(pReader),
    m_element_start(elem_start),
    //m_element_size(elem_size),
    m_start(start),
    m_size(size),
    m_pos(start),
    m_pUnknownSize(0),
    m_pSeekHead(NULL),
    m_pInfo(NULL),
    m_pTracks(NULL),
    m_pCues(NULL),
    m_pChapters(NULL),
    m_clusters(NULL),
    m_clusterCount(0),
    m_clusterPreloadCount(0),
    m_clusterSize(0)
{
}

int main(int argc, char **argv) {
FILE *infile = NULL;
  VpxVideoWriter *writer = NULL;
vpx_codec_ctx_t codec;
vpx_codec_enc_cfg_t cfg;
vpx_image_t raw;
vpx_codec_err_t res;
  vpx_fixed_buf_t stats = {0};
  VpxVideoInfo info = {0};
const VpxInterface *encoder = NULL;
  int pass;
const int fps = 30;        // TODO(dkovalev) add command line argument
const int bitrate = 200;   // kbit/s TODO(dkovalev) add command line argument
const char *const codec_arg = argv[1];
const char *const width_arg = argv[2];
const char *const height_arg = argv[3];
const char *const infile_arg = argv[4];
const char *const outfile_arg = argv[5];
exec_name = argv[0];

if (argc != 6)
die("Invalid number of arguments.");

encoder = get_vpx_encoder_by_name(codec_arg);

if (!encoder)
die("Unsupported codec.");

  info.codec_fourcc = encoder->fourcc;
  info.time_base.numerator = 1;
  info.time_base.denominator = fps;
  info.frame_width = strtol(width_arg, NULL, 0);
  info.frame_height = strtol(height_arg, NULL, 0);

  if (info.frame_width <= 0 ||
      info.frame_height <= 0 ||
      (info.frame_width % 2) != 0 ||
      (info.frame_height % 2) != 0) {
    die("Invalid frame size: %dx%d", info.frame_width, info.frame_height);
  }

  if (!vpx_img_alloc(&raw, VPX_IMG_FMT_I420, info.frame_width,
                                             info.frame_height, 1)) {
    die("Failed to allocate image", info.frame_width, info.frame_height);
  }

  writer = vpx_video_writer_open(outfile_arg, kContainerIVF, &info);
  if (!writer)
    die("Failed to open %s for writing", outfile_arg);

  printf("Using %s\n", vpx_codec_iface_name(encoder->interface()));
  res = vpx_codec_enc_config_default(encoder->interface(), &cfg, 0);
if (res)
die_codec(&codec, "Failed to get default codec config.");

  cfg.g_w = info.frame_width;
  cfg.g_h = info.frame_height;
  cfg.g_timebase.num = info.time_base.numerator;
  cfg.g_timebase.den = info.time_base.denominator;
cfg.rc_target_bitrate = bitrate;

  for (pass = 0; pass < 2; ++pass) {
    int frame_count = 0;

    if (pass == 0) {
      cfg.g_pass = VPX_RC_FIRST_PASS;
    } else {
      cfg.g_pass = VPX_RC_LAST_PASS;
      cfg.rc_twopass_stats_in = stats;
    }

    if (!(infile = fopen(infile_arg, "rb")))
      die("Failed to open %s for reading", infile_arg);
    if (vpx_codec_enc_init(&codec, encoder->interface(), &cfg, 0))
      die_codec(&codec, "Failed to initialize encoder");
    while (vpx_img_read(&raw, infile)) {
      ++frame_count;
      if (pass == 0) {
        get_frame_stats(&codec, &raw, frame_count, 1, 0, VPX_DL_BEST_QUALITY,
                        &stats);
      } else {
        encode_frame(&codec, &raw, frame_count, 1, 0, VPX_DL_BEST_QUALITY,
                     writer);
      }
    }
    if (pass == 0) {
      get_frame_stats(&codec, NULL, frame_count, 1, 0, VPX_DL_BEST_QUALITY,
                      &stats);
    } else {
      printf("\n");
    }
    fclose(infile);
    printf("Pass %d complete. Processed %d frames.\n", pass + 1, frame_count);
    if (vpx_codec_destroy(&codec))
      die_codec(&codec, "Failed to destroy codec.");
  }
  vpx_img_free(&raw);
free(stats.buf);

  vpx_video_writer_close(writer);

return EXIT_SUCCESS;
}

 virtual void SetUp() {
    pred_fn_ = GetParam();
 SetupMacroblock(mb_, mi_, data_array_, kBlockSize, kStride, 2);
 }

SimpleBlock::SimpleBlock(
    Cluster* pCluster,
    long idx,
    long long start,
    long long size) :
    BlockEntry(pCluster, idx),
    m_block(start, size, 0)
{
}

int arg_parse_int(const struct arg *arg) {
 long int   rawval;
 char *endptr;

  rawval = strtol(arg->val, &endptr, 10);

 if (arg->val[0] != '\0' && endptr[0] == '\0') {
 if (rawval >= INT_MIN && rawval <= INT_MAX)
 return rawval;

    die("Option %s: Value %ld out of range for signed int\n",
        arg->name, rawval);
 }

  die("Option %s: Invalid character '%c'\n", arg->name, *endptr);
 return 0;
}

 int BlockSizeLog2Min1() const {
 switch (block_size_) {
 case 16:
 return 3;
 case 8:
 return 2;
 default:
 return 0;
 }
 }

bool mkvparser::Match(
    IMkvReader* pReader,
    long long& pos,
    unsigned long id_,
    long long& val)
{
    assert(pReader);
    assert(pos >= 0);

    long long total, available;

    const long status = pReader->Length(&total, &available);
    assert(status >= 0);
    assert((total < 0) || (available <= total));
    if (status < 0)
        return false;

    long len;

    const long long id = ReadUInt(pReader, pos, len);
    assert(id >= 0);
    assert(len > 0);
    assert(len <= 8);
    assert((pos + len) <= available);

    if ((unsigned long)id != id_)
        return false;

    pos += len;  //consume id

    const long long size = ReadUInt(pReader, pos, len);
    assert(size >= 0);
    assert(size <= 8);
    assert(len > 0);
    assert(len <= 8);
    assert((pos + len) <= available);

    pos += len;  //consume length of size of payload

    val = UnserializeUInt(pReader, pos, size);
    assert(val >= 0);

    pos += size;  //consume size of payload
    return true;
}

void SubpelVarianceTest<vp9_subp_avg_variance_fn_t>::RefTest() {
  for (int x = 0; x < 16; ++x) {
    for (int y = 0; y < 16; ++y) {
      for (int j = 0; j < block_size_; j++) {
        src_[j] = rnd.Rand8();
        sec_[j] = rnd.Rand8();
      }
      for (int j = 0; j < block_size_ + width_ + height_ + 1; j++) {
        ref_[j] = rnd.Rand8();
}
unsigned int sse1, sse2;
unsigned int var1;
      REGISTER_STATE_CHECK(var1 = subpel_variance_(ref_, width_ + 1, x, y,
                                                   src_, width_, &sse1, sec_));
const unsigned int var2 = subpel_avg_variance_ref(ref_, src_, sec_,
log2width_, log2height_,
                                                        x, y, &sse2);
EXPECT_EQ(sse1, sse2) << "at position " << x << ", " << y;
EXPECT_EQ(var1, var2) << "at position " << x << ", " << y;
}
}
}

const SeekHead::Entry* SeekHead::GetEntry(int idx) const
{
    if (idx < 0)
        return 0;
    if (idx >= m_entry_count)
        return 0;
    return m_entries + idx;
}

long long Chapters::Atom::GetTime(
    const Chapters* pChapters,
    long long timecode)
{
    if (pChapters == NULL)
        return -1;
    Segment* const pSegment = pChapters->m_pSegment;
    if (pSegment == NULL)  // weird
        return -1;
    const SegmentInfo* const pInfo = pSegment->GetInfo();
    if (pInfo == NULL)
        return -1;
    const long long timecode_scale = pInfo->GetTimeCodeScale();
    if (timecode_scale < 1)  // weird
        return -1;
    if (timecode < 0)
        return -1;
    const long long result = timecode_scale * timecode;
    return result;
}

void usage_exit() {
   fprintf(stderr, "Usage: %s <infile> <outfile>\n", exec_name);
   exit(EXIT_FAILURE);
 }

long SeekHead::Parse()
{
    IMkvReader* const pReader = m_pSegment->m_pReader;

    long long pos = m_start;
    const long long stop = m_start + m_size;

    //first count the seek head entries

    int entry_count = 0;
    int void_element_count = 0;

    while (pos < stop)
    {
        long long id, size;

        const long status = ParseElementHeader(
                                pReader,
                                pos,
                                stop,
                                id,
                                size);

        if (status < 0)  //error
            return status;

        if (id == 0x0DBB)  //SeekEntry ID
            ++entry_count;
        else if (id == 0x6C)  //Void ID
            ++void_element_count;

        pos += size;  //consume payload
        assert(pos <= stop);
}

    assert(pos == stop);

    m_entries = new (std::nothrow) Entry[entry_count];

    if (m_entries == NULL)
        return -1;

    m_void_elements = new (std::nothrow) VoidElement[void_element_count];

    if (m_void_elements == NULL)
        return -1;

    //now parse the entries and void elements

    Entry* pEntry = m_entries;
    VoidElement* pVoidElement = m_void_elements;

    pos = m_start;

    while (pos < stop)
    {
        const long long idpos = pos;
        long long id, size;
        const long status = ParseElementHeader(
                                pReader,
                                pos,
                                stop,
                                id,
                                size);
        if (status < 0)  //error
            return status;
        if (id == 0x0DBB)  //SeekEntry ID
        {
            if (ParseEntry(pReader, pos, size, pEntry))
            {
                Entry& e = *pEntry++;
                e.element_start = idpos;
                e.element_size = (pos + size) - idpos;
            }
        }
        else if (id == 0x6C)  //Void ID
        {
            VoidElement& e = *pVoidElement++;
            e.element_start = idpos;
            e.element_size = (pos + size) - idpos;
        }
        pos += size;  //consume payload
        assert(pos <= stop);
    }
    assert(pos == stop);
    ptrdiff_t count_ = ptrdiff_t(pEntry - m_entries);
    assert(count_ >= 0);
    assert(count_ <= entry_count);
    m_entry_count = static_cast<int>(count_);
    count_ = ptrdiff_t(pVoidElement - m_void_elements);
    assert(count_ >= 0);
    assert(count_ <= void_element_count);
    m_void_element_count = static_cast<int>(count_);
return 0;
}

Tracks::~Tracks()
{
    Track** i = m_trackEntries;
    Track** const j = m_trackEntriesEnd;
    while (i != j)
    {
        Track* const pTrack = *i++;
        delete pTrack;
    }
    delete[] m_trackEntries;
}

void fht16x16_ref(const int16_t *in, int16_t *out, int stride, int tx_type) {
   vp9_fht16x16_c(in, out, stride, tx_type);
 }

const char* Chapters::Display::GetCountry() const
{
    return m_country;
}

 virtual void TearDown() {
 delete decoder_;
 delete video_;
 }

 virtual ~ExternalFrameBufferList() {
 for (int i = 0; i < num_buffers_; ++i) {
 delete [] ext_fb_list_[i].data;
 }
 delete [] ext_fb_list_;
 }

unsigned long long Track::GetCodecDelay() const
{
    return m_info.codecDelay;
}

void filter_average_block2d_8_c(const uint8_t *src_ptr,
const unsigned int src_stride,
const int16_t *HFilter,
const int16_t *VFilter,
uint8_t *dst_ptr,

unsigned int dst_stride,
unsigned int output_width,
unsigned int output_height) {
  uint8_t tmp[64 * 64];

  assert(output_width <= 64);
  assert(output_height <= 64);
filter_block2d_8_c(src_ptr, src_stride, HFilter, VFilter, tmp, 64,
output_width, output_height);
block2d_average_c(tmp, 64, dst_ptr, dst_stride,
output_width, output_height);
}

long Chapters::ParseEdition(
    long long pos,
    long long size)
{
    if (!ExpandEditionsArray())
        return -1;

    Edition& e = m_editions[m_editions_count++];
    e.Init();
    return e.Parse(m_pSegment->m_pReader, pos, size);
}

const CuePoint* Cues::GetLast() const
{
    if (m_cue_points == NULL)
        return NULL;
    if (m_count <= 0)
        return NULL;

#if 0
LoadCuePoint();  //init cues

const size_t count = m_count + m_preload_count;

if (count == 0) //weird
return NULL;

const size_t index = count - 1;

CuePoint* const* const pp = m_cue_points;
assert(pp);

CuePoint* const pCP = pp[index];
assert(pCP);


pCP->Load(m_pSegment->m_pReader);
assert(pCP->GetTimeCode() >= 0);
#else
    const long index = m_count - 1;

    CuePoint* const* const pp = m_cue_points;
    assert(pp);

    CuePoint* const pCP = pp[index];
    assert(pCP);
    assert(pCP->GetTimeCode() >= 0);
#endif

    return pCP;
}

void Chapters::Display::Clear()
{
    delete[] m_string;
    m_string = NULL;
    delete[] m_language;
    m_language = NULL;
    delete[] m_country;
    m_country = NULL;
}

BlockEntry::Kind SimpleBlock::GetKind() const
{
    return kBlockSimple;
}

 static int GetVP9FrameBuffer(void *user_priv, size_t min_size,
 vpx_codec_frame_buffer_t *fb) {
 ExternalFrameBufferMD5Test *const md5Test =
 reinterpret_cast<ExternalFrameBufferMD5Test*>(user_priv);
 return md5Test->fb_list_.GetFreeFrameBuffer(min_size, fb);
 }

virtual void SetUp() {
    svc_.encoding_mode = INTER_LAYER_PREDICTION_IP;
svc_.log_level = SVC_LOG_DEBUG;
svc_.log_print = 0;

codec_iface_ = vpx_codec_vp9_cx();
const vpx_codec_err_t res =
vpx_codec_enc_config_default(codec_iface_, &codec_enc_, 0);
EXPECT_EQ(VPX_CODEC_OK, res);

codec_enc_.g_w = kWidth;
codec_enc_.g_h = kHeight;
codec_enc_.g_timebase.num = 1;
codec_enc_.g_timebase.den = 60;

codec_enc_.kf_min_dist = 100;
codec_enc_.kf_max_dist = 100;

    vpx_codec_dec_cfg_t dec_cfg = {0};
VP9CodecFactory codec_factory;
decoder_ = codec_factory.CreateDecoder(dec_cfg, 0);
}

int main(int argc, char **argv) {
::testing::InitGoogleTest(&argc, argv);


#if ARCH_X86 || ARCH_X86_64
const int simd_caps = x86_simd_caps();
if (!(simd_caps & HAS_MMX))
    append_negative_gtest_filter(":MMX/*");
if (!(simd_caps & HAS_SSE))
    append_negative_gtest_filter(":SSE/*");
if (!(simd_caps & HAS_SSE2))
    append_negative_gtest_filter(":SSE2/*");
if (!(simd_caps & HAS_SSE3))
    append_negative_gtest_filter(":SSE3/*");
if (!(simd_caps & HAS_SSSE3))
    append_negative_gtest_filter(":SSSE3/*");
if (!(simd_caps & HAS_SSE4_1))
    append_negative_gtest_filter(":SSE4_1/*");
if (!(simd_caps & HAS_AVX))
    append_negative_gtest_filter(":AVX/*");
if (!(simd_caps & HAS_AVX2))
    append_negative_gtest_filter(":AVX2/*");
#endif

#if !CONFIG_SHARED
// Shared library builds don't support whitebox tests
// that exercise internal symbols.


#if CONFIG_VP8
vp8_rtcd();
#endif
#if CONFIG_VP9
vp9_rtcd();
#endif
#endif

return RUN_ALL_TESTS();
}

unsigned long long Track::GetUid() const
{
    return m_info.uid;
}

void encrypt_buffer(const uint8_t *src, uint8_t *dst, size_t size,
 ptrdiff_t offset) {
 for (size_t i = 0; i < size; ++i) {
    dst[i] = src[i] ^ test_key[(offset + i) & 15];
 }
}

long long Segment::GetDuration() const
{
    assert(m_pInfo);
    return m_pInfo->GetDuration();
}

long Cues::GetCount() const
{
    if (m_cue_points == NULL)
        return -1;

    return m_count;  //TODO: really ignore preload count?
}

long Track::GetNext(
    const BlockEntry* pCurrEntry,
    const BlockEntry*& pNextEntry) const
{
    assert(pCurrEntry);
    assert(!pCurrEntry->EOS());  //?

    const Block* const pCurrBlock = pCurrEntry->GetBlock();
    assert(pCurrBlock && pCurrBlock->GetTrackNumber() == m_info.number);
    if (!pCurrBlock || pCurrBlock->GetTrackNumber() != m_info.number)
        return -1;

    const Cluster* pCluster = pCurrEntry->GetCluster();
    assert(pCluster);
    assert(!pCluster->EOS());

    long status = pCluster->GetNext(pCurrEntry, pNextEntry);

    if (status < 0)  //error
return status;

    for (int i = 0; ; )
    {
        while (pNextEntry)
        {
            const Block* const pNextBlock = pNextEntry->GetBlock();
            assert(pNextBlock);

            if (pNextBlock->GetTrackNumber() == m_info.number)
                return 0;

            pCurrEntry = pNextEntry;

            status = pCluster->GetNext(pCurrEntry, pNextEntry);

            if (status < 0) //error
                return status;
        }

        pCluster = m_pSegment->GetNext(pCluster);

        if (pCluster == NULL)
        {
            pNextEntry = GetEOS();
            return 1;
        }

        if (pCluster->EOS())
        {
#if 0
if (m_pSegment->Unparsed() <= 0)   //all clusters have been loaded
{
pNextEntry = GetEOS();

return 1;
}
#else
            if (m_pSegment->DoneParsing())
            {
                pNextEntry = GetEOS();
                return 1;
            }
#endif

            //TODO: there is a potential O(n^2) problem here: we tell the
            //caller to (pre)load another cluster, which he does, but then he
            //calls GetNext again, which repeats the same search.  This is
            //a pathological case, since the only way it can happen is if
            //there exists a long sequence of clusters none of which contain a
            // block from this track.  One way around this problem is for the
            //caller to be smarter when he loads another cluster: don't call
            //us back until you have a cluster that contains a block from this
            //track. (Of course, that's not cheap either, since our caller
            //would have to scan the each cluster as it's loaded, so that
            //would just push back the problem.)

            pNextEntry = NULL;
            return E_BUFFER_NOT_FULL;
        }
        status = pCluster->GetFirst(pNextEntry);
        if (status < 0)  //error
            return status;
        if (pNextEntry == NULL)  //empty cluster
            continue;
        ++i;
        if (i >= 100)
            break;
}

    //NOTE: if we get here, it means that we didn't find a block with
    //a matching track number after lots of searching, so we give
    //up trying.

    pNextEntry = GetEOS();  //so we can return a non-NULL value
    return 1;
}

long Tracks::Parse()
{
    assert(m_trackEntries == NULL);
    assert(m_trackEntriesEnd == NULL);
    const long long stop = m_start + m_size;
    IMkvReader* const pReader = m_pSegment->m_pReader;
    int count = 0;
    long long pos = m_start;
    while (pos < stop)
    {
        long long id, size;
        const long status = ParseElementHeader(
                                pReader,
                                pos,
                                stop,
                                id,
                                size);
        if (status < 0)  //error
            return status;
        if (size == 0)  //weird
            continue;
        if (id == 0x2E)  //TrackEntry ID
            ++count;
        pos += size;  //consume payload
        assert(pos <= stop);
    }
    assert(pos == stop);
    if (count <= 0)
        return 0;  //success
    m_trackEntries = new (std::nothrow) Track*[count];
    if (m_trackEntries == NULL)
        return -1;
    m_trackEntriesEnd = m_trackEntries;
    pos = m_start;
    while (pos < stop)
    {
        const long long element_start = pos;
        long long id, payload_size;
        const long status = ParseElementHeader(
                                pReader,
                                pos,
                                stop,
                                id,
                                payload_size);
        if (status < 0)  //error
            return status;
        if (payload_size == 0)  //weird
            continue;
        const long long payload_stop = pos + payload_size;
        assert(payload_stop <= stop);  //checked in ParseElement
        const long long element_size = payload_stop - element_start;
        if (id == 0x2E)  //TrackEntry ID
        {
            Track*& pTrack = *m_trackEntriesEnd;
            pTrack = NULL;
            const long status = ParseTrackEntry(
                                    pos,
                                    payload_size,
                                    element_start,
                                    element_size,
                                    pTrack);
            if (status)
                return status;
            if (pTrack)
                ++m_trackEntriesEnd;
        }
        pos = payload_stop;
        assert(pos <= stop);
    }
    assert(pos == stop);
    return 0;  //success
}

EBMLHeader::~EBMLHeader()
{
delete[] m_docType;
}

  SADx4Test() : SADTestBase(GET_PARAM(0), GET_PARAM(1)) {}

ContentEncoding::ContentEncryption::~ContentEncryption() {
  delete [] key_id;
  delete [] signature;
  delete [] sig_key_id;
}

 virtual void TearDown() {
 delete[] modified_buf_;
 }

int main(int argc, char **argv) {
FILE *infile = NULL;
vpx_codec_ctx_t codec = {0};
vpx_codec_enc_cfg_t cfg = {0};
int frame_count = 0;
vpx_image_t raw;
vpx_codec_err_t res;
VpxVideoInfo info = {0};
VpxVideoWriter *writer = NULL;
const VpxInterface *encoder = NULL;
int update_frame_num = 0;
const int fps = 30; // TODO(dkovalev) add command line argument
const int bitrate = 200; // kbit/s TODO(dkovalev) add command line argument

exec_name = argv[0];

if (argc != 6)
die("Invalid number of arguments");

// TODO(dkovalev): add vp9 support and rename the file accordingly
encoder = get_vpx_encoder_by_name("vp8");
if (!encoder)
die("Unsupported codec.");

update_frame_num = atoi(argv[5]);
if (!update_frame_num)
die("Couldn't parse frame number '%s'\n", argv[5]);

info.codec_fourcc = encoder->fourcc;
info.frame_width = strtol(argv[1], NULL, 0);
info.frame_height = strtol(argv[2], NULL, 0);
info.time_base.numerator = 1;
info.time_base.denominator = fps;

if (info.frame_width <= 0 ||
info.frame_height <= 0 ||
(info.frame_width % 2) != 0 ||
(info.frame_height % 2) != 0) {
die("Invalid frame size: %dx%d", info.frame_width, info.frame_height);
}

if (!vpx_img_alloc(&raw, VPX_IMG_FMT_I420, info.frame_width,
info.frame_height, 1)) {

die("Failed to allocate image.");
}

  printf("Using %s\n", vpx_codec_iface_name(encoder->interface()));

  res = vpx_codec_enc_config_default(encoder->interface(), &cfg, 0);
if (res)
die_codec(&codec, "Failed to get default codec config.");

cfg.g_w = info.frame_width;
cfg.g_h = info.frame_height;
cfg.g_timebase.num = info.time_base.numerator;
cfg.g_timebase.den = info.time_base.denominator;
cfg.rc_target_bitrate = bitrate;

writer = vpx_video_writer_open(argv[4], kContainerIVF, &info);
if (!writer)
die("Failed to open %s for writing.", argv[4]);


if (!(infile = fopen(argv[3], "rb")))
die("Failed to open %s for reading.", argv[3]);

  if (vpx_codec_enc_init(&codec, encoder->interface(), &cfg, 0))
die_codec(&codec, "Failed to initialize encoder");

while (vpx_img_read(&raw, infile)) {
if (frame_count + 1 == update_frame_num) {
vpx_ref_frame_t ref;
ref.frame_type = VP8_LAST_FRAME;
ref.img = raw;
if (vpx_codec_control(&codec, VP8_SET_REFERENCE, &ref))
die_codec(&codec, "Failed to set reference frame");
}


encode_frame(&codec, &raw, frame_count++, writer);
}
  encode_frame(&codec, NULL, -1, writer);

printf("\n");
fclose(infile);
printf("Processed %d frames.\n", frame_count);

vpx_img_free(&raw);
if (vpx_codec_destroy(&codec))
die_codec(&codec, "Failed to destroy codec.");

vpx_video_writer_close(writer);

return EXIT_SUCCESS;
}

 int GetZeroFrameBuffer(size_t min_size, vpx_codec_frame_buffer_t *fb) {
    EXPECT_TRUE(fb != NULL);
 const int idx = FindFreeBufferIndex();
 if (idx == num_buffers_)
 return -1;

 if (ext_fb_list_[idx].size < min_size) {
 delete [] ext_fb_list_[idx].data;
      ext_fb_list_[idx].data = NULL;
      ext_fb_list_[idx].size = min_size;
 }

 SetFrameBuffer(idx, fb);

     return 0;
   }

void CheckSad(unsigned int max_sad) {
    unsigned int reference_sad, exp_sad;
    reference_sad = ReferenceSAD(max_sad);
    exp_sad = SAD(max_sad);
    if (reference_sad <= max_sad) {
      ASSERT_EQ(exp_sad, reference_sad);
    } else {
      // Alternative implementations are not required to check max_sad
      ASSERT_GE(exp_sad, reference_sad);
    }
  }

void block2d_average_c(uint8_t *src,
 unsigned int src_stride,
 uint8_t *output_ptr,
 unsigned int output_stride,
 unsigned int output_width,
 unsigned int output_height) {
 unsigned int i, j;
 for (i = 0; i < output_height; ++i) {
 for (j = 0; j < output_width; ++j) {
      output_ptr[j] = (output_ptr[j] + src[i * src_stride + j] + 1) >> 1;
 }
    output_ptr += output_stride;
 }
}

long Segment::ParseCues(
    long long off,
    long long& pos,
    long& len)
{
    if (m_pCues)
        return 0;  //success

    if (off < 0)
        return -1;

    long long total, avail;

    const int status = m_pReader->Length(&total, &avail);

    if (status < 0)  //error
        return status;

    assert((total < 0) || (avail <= total));

    pos = m_start + off;

    if ((total < 0) || (pos >= total))
        return 1;  //don't bother parsing cues

    const long long element_start = pos;
    const long long segment_stop = (m_size < 0) ? -1 : m_start + m_size;

    if ((pos + 1) > avail)
    {
        len = 1;
        return E_BUFFER_NOT_FULL;
    }

    long long result = GetUIntLength(m_pReader, pos, len);

    if (result < 0)  //error
        return static_cast<long>(result);

    if (result > 0) //underflow (weird)
    {
        len = 1;
        return E_BUFFER_NOT_FULL;
    }

    if ((segment_stop >= 0) && ((pos + len) > segment_stop))
        return E_FILE_FORMAT_INVALID;

    if ((pos + len) > avail)
        return E_BUFFER_NOT_FULL;

    const long long idpos = pos;

    const long long id = ReadUInt(m_pReader, idpos, len);

    if (id != 0x0C53BB6B)  //Cues ID
        return E_FILE_FORMAT_INVALID;

    pos += len;  //consume ID
    assert((segment_stop < 0) || (pos <= segment_stop));

    //Read Size

    if ((pos + 1) > avail)
    {
        len = 1;
        return E_BUFFER_NOT_FULL;
    }

    result = GetUIntLength(m_pReader, pos, len);

    if (result < 0)  //error
        return static_cast<long>(result);

    if (result > 0) //underflow (weird)
    {
        len = 1;
        return E_BUFFER_NOT_FULL;
    }

    if ((segment_stop >= 0) && ((pos + len) > segment_stop))
        return E_FILE_FORMAT_INVALID;

    if ((pos + len) > avail)
        return E_BUFFER_NOT_FULL;

    const long long size = ReadUInt(m_pReader, pos, len);

    if (size < 0)  //error
        return static_cast<long>(size);

    if (size == 0)  //weird, although technically not illegal
        return 1;   //done

    pos += len;  //consume length of size of element
    assert((segment_stop < 0) || (pos <= segment_stop));

    //Pos now points to start of payload

    const long long element_stop = pos + size;

    if ((segment_stop >= 0) && (element_stop > segment_stop))
        return E_FILE_FORMAT_INVALID;

    if ((total >= 0) && (element_stop > total))
        return 1;  //don't bother parsing anymore

    len = static_cast<long>(size);

    if (element_stop > avail)
        return E_BUFFER_NOT_FULL;

    const long long element_size = element_stop - element_start;

    m_pCues = new (std::nothrow) Cues(
                                    this,
                                    pos,
                                    size,
                                    element_start,
                                    element_size);
    assert(m_pCues);  //TODO

    return 0;  //success
}

 void SetTopUnavailable() {
    mbptr_->up_available = 0;
 for (int p = 0; p < num_planes_; p++)
      memset(&data_ptr_[p][-1 - stride_], 127, block_size_ + 2);
 }

 int GetFreeFrameBuffer(size_t min_size, vpx_codec_frame_buffer_t *fb) {
    EXPECT_TRUE(fb != NULL);
 const int idx = FindFreeBufferIndex();
 if (idx == num_buffers_)
 return -1;


     if (ext_fb_list_[idx].size < min_size) {
       delete [] ext_fb_list_[idx].data;
       ext_fb_list_[idx].data = new uint8_t[min_size];
       ext_fb_list_[idx].size = min_size;
     }
 
 SetFrameBuffer(idx, fb);
 return 0;
 }

long ContentEncoding::ParseContentEncAESSettingsEntry(
    long long start,
    long long size,
    IMkvReader* pReader,
ContentEncAESSettings* aes) {
assert(pReader);
assert(aes);

long long pos = start;
const long long stop = start + size;


while (pos < stop) {
long long id, size;
    const long status = ParseElementHeader(pReader,
                                           pos,
                                           stop,
                                           id,
                                           size);
    if (status < 0)  //error
return status;

if (id == 0x7E8) {
// AESSettingsCipherMode
aes->cipher_mode = UnserializeUInt(pReader, pos, size);
if (aes->cipher_mode != 1)

return E_FILE_FORMAT_INVALID;
}

    pos += size;  //consume payload
assert(pos <= stop);
}

return 0;
}

long long mkvparser::ReadUInt(IMkvReader* pReader, long long pos, long& len)
{
    assert(pReader);
    assert(pos >= 0);

    int status;

#ifdef _DEBUG
    long long total, available;
    status = pReader->Length(&total, &available);
    assert(status >= 0);
    assert((total < 0) || (available <= total));
    assert(pos < available);
    assert((available - pos) >= 1);  //assume here max u-int len is 8
#endif

    len = 1;

    unsigned char b;

status = pReader->Read(pos, 1, &b);

    if (status < 0)  //error or underflow
        return status;
    if (status > 0)  //interpreted as "underflow"
        return E_BUFFER_NOT_FULL;
    if (b == 0)  //we can't handle u-int values larger than 8 bytes
        return E_FILE_FORMAT_INVALID;
    unsigned char m = 0x80;
    while (!(b & m))
    {
        m >>= 1;
        ++len;
}

#ifdef _DEBUG
    assert((available - pos) >= len);
#endif

    long long result = b & (~m);
++pos;

    for (int i = 1; i < len; ++i)
    {
        status = pReader->Read(pos, 1, &b);
        if (status < 0)
        {
            len = 1;
            return status;
        }
        if (status > 0)
        {
            len = 1;
            return E_BUFFER_NOT_FULL;
        }
        result <<= 8;
        result |= b;
        ++pos;
    }
    return result;
}

void fht4x4_ref(const int16_t *in, int16_t *out, int stride, int tx_type) {
   vp9_fht4x4_c(in, out, stride, tx_type);
 }

long SegmentInfo::Parse()
{
    assert(m_pMuxingAppAsUTF8 == NULL);
    assert(m_pWritingAppAsUTF8 == NULL);
    assert(m_pTitleAsUTF8 == NULL);
    IMkvReader* const pReader = m_pSegment->m_pReader;
    long long pos = m_start;
    const long long stop = m_start + m_size;
    m_timecodeScale = 1000000;
    m_duration = -1;
    while (pos < stop)
    {
        long long id, size;
        const long status = ParseElementHeader(
                                pReader,
                                pos,
                                stop,
                                id,
                                size);
        if (status < 0)  //error
            return status;
        if (id == 0x0AD7B1)  //Timecode Scale
        {
            m_timecodeScale = UnserializeUInt(pReader, pos, size);
            if (m_timecodeScale <= 0)
                return E_FILE_FORMAT_INVALID;
        }
        else if (id == 0x0489)  //Segment duration
        {
            const long status = UnserializeFloat(
                                    pReader,
                                    pos,
                                    size,
                                    m_duration);
            if (status < 0)
                return status;
            if (m_duration < 0)
                return E_FILE_FORMAT_INVALID;
        }
        else if (id == 0x0D80)  //MuxingApp
        {
            const long status = UnserializeString(
                                    pReader,
                                    pos,
                                    size,
                                    m_pMuxingAppAsUTF8);
            if (status)
                return status;
        }
        else if (id == 0x1741)  //WritingApp
        {
            const long status = UnserializeString(
                                    pReader,
                                    pos,
                                    size,
                                    m_pWritingAppAsUTF8);
            if (status)
                return status;
        }
        else if (id == 0x3BA9)  //Title
        {
            const long status = UnserializeString(
                                    pReader,
                                    pos,
                                    size,
                                    m_pTitleAsUTF8);
            if (status)
                return status;
        }
        pos += size;
        assert(pos <= stop);
    }
    assert(pos == stop);
    return 0;
}

 virtual void SetUp() {
    fwd_txfm_ = GET_PARAM(0);
    inv_txfm_ = GET_PARAM(1);

     tx_type_  = GET_PARAM(2);
     pitch_    = 8;
     fwd_txfm_ref = fht8x8_ref;
   }

static int merge_hist_buckets(struct hist_bucket *bucket,
 int max_buckets, int *num_buckets) {
 int small_bucket = 0, merge_bucket = INT_MAX, big_bucket = 0;
 int buckets = *num_buckets;
 int i;

 /* Find the extrema for this list of buckets */
  big_bucket = small_bucket = 0;
 for (i = 0; i < buckets; i++) {
 if (bucket[i].count < bucket[small_bucket].count)
      small_bucket = i;
 if (bucket[i].count > bucket[big_bucket].count)
      big_bucket = i;
 }

 /* If we have too many buckets, merge the smallest with an adjacent
   * bucket.
   */
 while (buckets > max_buckets) {
 int last_bucket = buckets - 1;

 /* merge the small bucket with an adjacent one. */
 if (small_bucket == 0)
      merge_bucket = 1;
 else if (small_bucket == last_bucket)
      merge_bucket = last_bucket - 1;
 else if (bucket[small_bucket - 1].count < bucket[small_bucket + 1].count)
      merge_bucket = small_bucket - 1;
 else
      merge_bucket = small_bucket + 1;

    assert(abs(merge_bucket - small_bucket) <= 1);
    assert(small_bucket < buckets);
    assert(big_bucket < buckets);
    assert(merge_bucket < buckets);

 if (merge_bucket < small_bucket) {
      bucket[merge_bucket].high = bucket[small_bucket].high;
      bucket[merge_bucket].count += bucket[small_bucket].count;
 } else {
      bucket[small_bucket].high = bucket[merge_bucket].high;
      bucket[small_bucket].count += bucket[merge_bucket].count;
      merge_bucket = small_bucket;
 }

    assert(bucket[merge_bucket].low != bucket[merge_bucket].high);

    buckets--;

 /* Remove the merge_bucket from the list, and find the new small
     * and big buckets while we're at it
     */
    big_bucket = small_bucket = 0;
 for (i = 0; i < buckets; i++) {
 if (i > merge_bucket)
        bucket[i] = bucket[i + 1];

 if (bucket[i].count < bucket[small_bucket].count)
        small_bucket = i;
 if (bucket[i].count > bucket[big_bucket].count)
        big_bucket = i;
 }
 }

 *num_buckets = buckets;
 return bucket[big_bucket].count;
}

Chapters::Atom::~Atom()
{
}

long Cluster::ParseBlockGroup(
    long long payload_size,
    long long& pos,
    long& len)
{
    const long long payload_start = pos;
    const long long payload_stop = pos + payload_size;

    IMkvReader* const pReader = m_pSegment->m_pReader;

    long long total, avail;

    long status = pReader->Length(&total, &avail);

    if (status < 0)  //error
        return status;

    assert((total < 0) || (avail <= total));

    if ((total >= 0) && (payload_stop > total))
        return E_FILE_FORMAT_INVALID;

    if (payload_stop > avail)
    {
         len = static_cast<long>(payload_size);
         return E_BUFFER_NOT_FULL;
}

    long long discard_padding = 0;

    while (pos < payload_stop)
    {
        //parse sub-block element ID

        if ((pos + 1) > avail)
        {
            len = 1;
            return E_BUFFER_NOT_FULL;
        }

        long long result = GetUIntLength(pReader, pos, len);

        if (result < 0)  //error
            return static_cast<long>(result);

        if (result > 0)  //weird
            return E_BUFFER_NOT_FULL;

        if ((pos + len) > payload_stop)
            return E_FILE_FORMAT_INVALID;

        if ((pos + len) > avail)
            return E_BUFFER_NOT_FULL;

        const long long id = ReadUInt(pReader, pos, len);

        if (id < 0) //error
            return static_cast<long>(id);

        if (id == 0)  //not a value ID
            return E_FILE_FORMAT_INVALID;

        pos += len;  //consume ID field

        //Parse Size

        if ((pos + 1) > avail)
        {
            len = 1;
            return E_BUFFER_NOT_FULL;
        }

        result = GetUIntLength(pReader, pos, len);

        if (result < 0)  //error
            return static_cast<long>(result);

        if (result > 0)  //weird
            return E_BUFFER_NOT_FULL;

        if ((pos + len) > payload_stop)
            return E_FILE_FORMAT_INVALID;

        if ((pos + len) > avail)
            return E_BUFFER_NOT_FULL;

        const long long size = ReadUInt(pReader, pos, len);

        if (size < 0)  //error
            return static_cast<long>(size);

        pos += len;  //consume size field

        //pos now points to start of sub-block group payload

        if (pos > payload_stop)
            return E_FILE_FORMAT_INVALID;

        if (size == 0)  //weird
            continue;

        const long long unknown_size = (1LL << (7 * len)) - 1;

        if (size == unknown_size)
            return E_FILE_FORMAT_INVALID;

        if (id == 0x35A2)  //DiscardPadding
        {
            result = GetUIntLength(pReader, pos, len);

            if (result < 0)  //error
                return static_cast<long>(result);

            status = UnserializeInt(pReader, pos, len, discard_padding);

            if (status < 0)  //error
                return status;
        }

        if (id != 0x21)  //sub-part of BlockGroup is not a Block
        {
            pos += size;  //consume sub-part of block group

            if (pos > payload_stop)
                return E_FILE_FORMAT_INVALID;

            continue;
        }

        const long long block_stop = pos + size;

        if (block_stop > payload_stop)
            return E_FILE_FORMAT_INVALID;

        //parse track number

        if ((pos + 1) > avail)
        {
            len = 1;
            return E_BUFFER_NOT_FULL;
        }

        result = GetUIntLength(pReader, pos, len);

        if (result < 0)  //error
            return static_cast<long>(result);

        if (result > 0)  //weird
            return E_BUFFER_NOT_FULL;
        if ((pos + len) > block_stop)
            return E_FILE_FORMAT_INVALID;
        if ((pos + len) > avail)
            return E_BUFFER_NOT_FULL;
        const long long track = ReadUInt(pReader, pos, len);
        if (track < 0) //error
            return static_cast<long>(track);
        if (track == 0)
            return E_FILE_FORMAT_INVALID;

#if 0
//TODO(matthewjheaney)
//This turned out to be too conservative.  The problem is that
//if we see a track header in the tracks element with an unsupported
//track type, we throw that track header away, so it is not present
//in the track map.  But even though we don't understand the track
//header, there are still blocks in the cluster with that track
//number.  It was our decision to ignore that track header, so it's
//up to us to deal with blocks associated with that track -- we
//cannot simply report an error since technically there's nothing
//wrong with the file.
//
//For now we go ahead and finish the parse, creating a block entry
//for this block.  This is somewhat wasteful, because without a
//track header there's nothing you can do with the block. What
//we really need here is a special return value that indicates to
//the caller that he should ignore this particular block, and
//continue parsing.

const Tracks* const pTracks = m_pSegment->GetTracks();
assert(pTracks);

const long tn = static_cast<long>(track);

const Track* const pTrack = pTracks->GetTrackByNumber(tn);

if (pTrack == NULL)

return E_FILE_FORMAT_INVALID;
#endif

        pos += len;  //consume track number

        if ((pos + 2) > block_stop)
            return E_FILE_FORMAT_INVALID;

        if ((pos + 2) > avail)
        {
            len = 2;
            return E_BUFFER_NOT_FULL;
        }
        pos += 2;  //consume timecode
        if ((pos + 1) > block_stop)
            return E_FILE_FORMAT_INVALID;
        if ((pos + 1) > avail)
        {
            len = 1;
            return E_BUFFER_NOT_FULL;
        }
        unsigned char flags;
        status = pReader->Read(pos, 1, &flags);
        if (status < 0)  //error or underflow
        {
            len = 1;
            return status;
        }
        ++pos;  //consume flags byte
        assert(pos <= avail);
        if (pos >= block_stop)
            return E_FILE_FORMAT_INVALID;
        const int lacing = int(flags & 0x06) >> 1;
        if ((lacing != 0) && (block_stop > avail))
        {
            len = static_cast<long>(block_stop - pos);
            return E_BUFFER_NOT_FULL;
        }
        pos = block_stop;  //consume block-part of block group
        assert(pos <= payload_stop);
}

    assert(pos == payload_stop);

    status = CreateBlock(0x20,  //BlockGroup ID
                         payload_start, payload_size,
                         discard_padding);
    if (status != 0)
        return status;

    m_pos = payload_stop;
    return 0;  //success
}

Cues::Cues(
    Segment* pSegment,
    long long start_,
    long long size_,
    long long element_start,
    long long element_size) :
    m_pSegment(pSegment),
    m_start(start_),
    m_size(size_),
    m_element_start(element_start),
    m_element_size(element_size),
    m_cue_points(NULL),
    m_count(0),
    m_preload_count(0),
    m_pos(start_)
{
}

bool Chapters::ExpandEditionsArray()
{
    if (m_editions_size > m_editions_count)
        return true;  // nothing else to do

    const int size = (m_editions_size == 0) ? 1 : 2 * m_editions_size;

    Edition* const editions = new (std::nothrow) Edition[size];

    if (editions == NULL)
        return false;

    for (int idx = 0; idx < m_editions_count; ++idx)
    {
        m_editions[idx].ShallowCopy(editions[idx]);
}

    delete[] m_editions;
    m_editions = editions;

    m_editions_size = size;
    return true;
}

virtual void TearDown() {
    vpx_svc_release(&svc_);
delete(decoder_);
if (codec_initialized_) vpx_codec_destroy(&codec_);
}

 void set_num_buffers(int num_buffers) { num_buffers_ = num_buffers; }

 void CheckDecodedFrames() {
    libvpx_test::DxDataIterator dec_iter = decoder_->GetDxData();
 const vpx_image_t *img = NULL;

 while ((img = dec_iter.Next()) != NULL) {
      fb_list_.CheckXImageFrameBuffer(img);
 }
 }

   virtual ~Trans4x4DCT() {}

 virtual void SetUp() {
 InitializeConfig();
 SetMode(GET_PARAM(1));
    cpu_used_ = GET_PARAM(2);
 }

long Track::Create(
    Segment* pSegment,
    const Info& info,
    long long element_start,
    long long element_size,
    Track*& pResult)
{
    if (pResult)
        return -1;

    Track* const pTrack = new (std::nothrow) Track(pSegment,
                                                   element_start,
                                                   element_size);

    if (pTrack == NULL)
        return -1;  //generic error

    const int status = info.Copy(pTrack->m_info);

    if (status)  // error
    {
        delete pTrack;
        return status;
    }

    pResult = pTrack;
    return 0;  //success
}

 virtual void PSNRPktHook(const vpx_codec_cx_pkt_t *pkt) {
    psnr_ += pkt->data.psnr.psnr[0];

     nframes_++;
   }

bool Cluster::EOS() const
{
    return (m_pSegment == NULL);
}

Cluster::~Cluster()
{
    if (m_entries_count <= 0)
        return;
    BlockEntry** i = m_entries;
    BlockEntry** const j = m_entries + m_entries_count;
    while (i != j)
    {
         BlockEntry* p = *i++;
         assert(p);
         delete p;
}

    delete[] m_entries;
}

long long Cluster::GetTime() const
{
    const long long tc = GetTimeCode();
    if (tc < 0)
        return tc;
    const SegmentInfo* const pInfo = m_pSegment->GetInfo();
    assert(pInfo);
    const long long scale = pInfo->GetTimeCodeScale();
    assert(scale >= 1);
    const long long t = m_timecode * scale;
    return t;
}

void fdct4x4_ref(const int16_t *in, int16_t *out, int stride, int tx_type) {
  vp9_fdct4x4_c(in, out, stride);
}

  SADTest() : SADTestBase(GET_PARAM(0), GET_PARAM(1)) {}

long long Block::GetTime(const Cluster* pCluster) const
{
    assert(pCluster);

    const long long tc = GetTimeCode(pCluster);

    const Segment* const pSegment = pCluster->m_pSegment;
    const SegmentInfo* const pInfo = pSegment->GetInfo();
    assert(pInfo);

    const long long scale = pInfo->GetTimeCodeScale();
    assert(scale >= 1);

    const long long ns = tc * scale;
    return ns;
}

   AqSegmentTest() : EncoderTest(GET_PARAM(0)) {}

unsigned long Tracks::GetTracksCount() const
{
    const ptrdiff_t result = m_trackEntriesEnd - m_trackEntries;
    assert(result >= 0);
    return static_cast<unsigned long>(result);
}

Chapters::Edition::~Edition()
{
}

long long EBMLHeader::Parse(
    IMkvReader* pReader,
    long long& pos)
{
    assert(pReader);

    long long total, available;

    long status = pReader->Length(&total, &available);

    if (status < 0)  //error
return status;

    pos = 0;
    long long end = (available >= 1024) ? 1024 : available;

    for (;;)
    {
        unsigned char b = 0;
        while (pos < end)
        {
            status = pReader->Read(pos, 1, &b);
            if (status < 0)  //error
                return status;
            if (b == 0x1A)
                break;
            ++pos;
        }
        if (b != 0x1A)
        {
            if (pos >= 1024)
                return E_FILE_FORMAT_INVALID;  //don't bother looking anymore
            if ((total >= 0) && ((total - available) < 5))
                return E_FILE_FORMAT_INVALID;
            return available + 5;  //5 = 4-byte ID + 1st byte of size
        }
        if ((total >= 0) && ((total - pos) < 5))
            return E_FILE_FORMAT_INVALID;
        if ((available - pos) < 5)
            return pos + 5;  //try again later
        long len;
        const long long result = ReadUInt(pReader, pos, len);
        if (result < 0)  //error
            return result;
        if (result == 0x0A45DFA3)  //EBML Header ID
        {
            pos += len;  //consume ID
            break;
        }
        ++pos;  //throw away just the 0x1A byte, and try again
}

    //pos designates start of size field

    //get length of size field

long len;
long long result = GetUIntLength(pReader, pos, len);

    if (result < 0)  //error
        return result;

    if (result > 0)  //need more data
        return result;

    assert(len > 0);
    assert(len <= 8);

    if ((total >= 0) && ((total -  pos) < len))
        return E_FILE_FORMAT_INVALID;

    if ((available - pos) < len)
        return pos + len;  //try again later

    //get the EBML header size

    result = ReadUInt(pReader, pos, len);

    if (result < 0)  //error
        return result;

    pos += len;  //consume size field

    //pos now designates start of payload

    if ((total >= 0) && ((total - pos) < result))
        return E_FILE_FORMAT_INVALID;

    if ((available - pos) < result)
        return pos + result;

    end = pos + result;

    Init();

    while (pos < end)
    {
        long long id, size;

        status = ParseElementHeader(
                    pReader,
                    pos,
                    end,
                    id,
                    size);

        if (status < 0) //error
            return status;

        if (size == 0)  //weird
            return E_FILE_FORMAT_INVALID;

        if (id == 0x0286)  //version
        {
            m_version = UnserializeUInt(pReader, pos, size);

            if (m_version <= 0)
                return E_FILE_FORMAT_INVALID;
        }
        else if (id == 0x02F7)  //read version
        {
            m_readVersion = UnserializeUInt(pReader, pos, size);

            if (m_readVersion <= 0)
                return E_FILE_FORMAT_INVALID;
        }
        else if (id == 0x02F2)  //max id length
        {
            m_maxIdLength = UnserializeUInt(pReader, pos, size);

            if (m_maxIdLength <= 0)
                return E_FILE_FORMAT_INVALID;
        }
        else if (id == 0x02F3)  //max size length
        {
            m_maxSizeLength = UnserializeUInt(pReader, pos, size);
            if (m_maxSizeLength <= 0)
                return E_FILE_FORMAT_INVALID;
        }
        else if (id == 0x0282)  //doctype
        {
            if (m_docType)
                return E_FILE_FORMAT_INVALID;
            status = UnserializeString(pReader, pos, size, m_docType);
            if (status)  //error
                return status;
        }
        else if (id == 0x0287)  //doctype version
        {
            m_docTypeVersion = UnserializeUInt(pReader, pos, size);
            if (m_docTypeVersion <= 0)
                return E_FILE_FORMAT_INVALID;
        }
        else if (id == 0x0285)  //doctype read version
        {
            m_docTypeReadVersion = UnserializeUInt(pReader, pos, size);
            if (m_docTypeReadVersion <= 0)
                return E_FILE_FORMAT_INVALID;
        }
        pos += size;
}

    assert(pos == end);
    return 0;
}

   virtual void SetUp() {
     source_stride_ = (width_ + 31) & ~31;
     reference_stride_ = width_ * 2;
     rnd_.Reset(ACMRandom::DeterministicSeed());
   }

int main(int argc, char **argv) {
int frame_cnt = 0;
FILE *outfile = NULL;
vpx_codec_ctx_t codec;
VpxVideoReader *reader = NULL;
const VpxInterface *decoder = NULL;
const VpxVideoInfo *info = NULL;

exec_name = argv[0];

if (argc != 3)
die("Invalid number of arguments.");

reader = vpx_video_reader_open(argv[1]);
if (!reader)
die("Failed to open %s for reading.", argv[1]);

if (!(outfile = fopen(argv[2], "wb")))
die("Failed to open %s for writing.", argv[2]);

info = vpx_video_reader_get_info(reader);

decoder = get_vpx_decoder_by_fourcc(info->codec_fourcc);

if (!decoder)
die("Unknown input codec.");

  printf("Using %s\n", vpx_codec_iface_name(decoder->interface()));

  if (vpx_codec_dec_init(&codec, decoder->interface(), NULL, 0))
die_codec(&codec, "Failed to initialize decoder.");

while (vpx_video_reader_read_frame(reader)) {
vpx_codec_iter_t iter = NULL;
vpx_image_t *img = NULL;
size_t frame_size = 0;
const unsigned char *frame = vpx_video_reader_get_frame(reader,
&frame_size);
if (vpx_codec_decode(&codec, frame, (unsigned int)frame_size, NULL, 0))
die_codec(&codec, "Failed to decode frame.");

while ((img = vpx_codec_get_frame(&codec, &iter)) != NULL) {
vpx_img_write(img, outfile);
++frame_cnt;
}
}

printf("Processed %d frames.\n", frame_cnt);
if (vpx_codec_destroy(&codec))
die_codec(&codec, "Failed to destroy codec");

printf("Play: ffplay -f rawvideo -pix_fmt yuv420p -s %dx%d %s\n",
info->frame_width, info->frame_height, argv[2]);

vpx_video_reader_close(reader);

fclose(outfile);

return EXIT_SUCCESS;
}

 virtual void EndPassHook() {
#if WRITE_COMPRESSED_STREAM
 if (outfile_) {
 if (!fseek(outfile_, 0, SEEK_SET))
        write_ivf_file_header(&cfg_, out_frames_, outfile_);
      fclose(outfile_);
      outfile_ = NULL;
 }
#endif
 }

long Track::Seek(
    long long time_ns,
    const BlockEntry*& pResult) const
{
    const long status = GetFirst(pResult);

    if (status < 0)  //buffer underflow, etc
        return status;

    assert(pResult);

    if (pResult->EOS())
        return 0;

    const Cluster* pCluster = pResult->GetCluster();
assert(pCluster);
assert(pCluster->GetIndex() >= 0);

    if (time_ns <= pResult->GetBlock()->GetTime(pCluster))
        return 0;

    Cluster** const clusters = m_pSegment->m_clusters;
    assert(clusters);

    const long count = m_pSegment->GetCount();  //loaded only, not preloaded
    assert(count > 0);

    Cluster** const i = clusters + pCluster->GetIndex();
    assert(i);
    assert(*i == pCluster);
assert(pCluster->GetTime() <= time_ns);

    Cluster** const j = clusters + count;

    Cluster** lo = i;
    Cluster** hi = j;

    while (lo < hi)
    {
        //INVARIANT:
        //[i, lo) <= time_ns
        //[lo, hi) ?
        //[hi, j)  > time_ns

        Cluster** const mid = lo + (hi - lo) / 2;
        assert(mid < hi);
        pCluster = *mid;
        assert(pCluster);
        assert(pCluster->GetIndex() >= 0);
        assert(pCluster->GetIndex() == long(mid - m_pSegment->m_clusters));
        const long long t = pCluster->GetTime();
        if (t <= time_ns)
            lo = mid + 1;
        else
            hi = mid;
        assert(lo <= hi);
    }
    assert(lo == hi);
    assert(lo > i);
    assert(lo <= j);
    while (lo > i)
    {
        pCluster = *--lo;
        assert(pCluster);
        assert(pCluster->GetTime() <= time_ns);
        pResult = pCluster->GetEntry(this);
        if ((pResult != 0) && !pResult->EOS())
            return 0;
        //landed on empty cluster (no entries)
    }
    pResult = GetEOS();  //weird
    return 0;
}

static void print_md5(FILE *stream, unsigned char digest[16]) {
 int i;

 for (i = 0; i < 16; ++i)
    fprintf(stream, "%02x", digest[i]);
}

EBMLHeader::EBMLHeader() :
    m_docType(NULL)
{
    Init();
}

 unsigned int GetMismatchFrames() {

     return mismatch_nframes_;
   }

long Block::Frame::Read(IMkvReader* pReader, unsigned char* buf) const
{
    assert(pReader);
    assert(buf);
    const long status = pReader->Read(pos, len, buf);
    return status;
}

void reference_16x16_dct_2d(int16_t input[256], double output[256]) {
 for (int i = 0; i < 16; ++i) {
 double temp_in[16], temp_out[16];
 for (int j = 0; j < 16; ++j)
      temp_in[j] = input[j * 16 + i];
    butterfly_16x16_dct_1d(temp_in, temp_out);
 for (int j = 0; j < 16; ++j)
      output[j * 16 + i] = temp_out[j];
 }
 for (int i = 0; i < 16; ++i) {
 double temp_in[16], temp_out[16];
 for (int j = 0; j < 16; ++j)
      temp_in[j] = output[j + i * 16];
    butterfly_16x16_dct_1d(temp_in, temp_out);
 for (int j = 0; j < 16; ++j)
      output[j + i * 16] = temp_out[j]/2;

   }
 }

void Chapters::Edition::ShallowCopy(Edition& rhs) const
{
    rhs.m_atoms = m_atoms;
    rhs.m_atoms_size = m_atoms_size;
    rhs.m_atoms_count = m_atoms_count;
}

SoftVPX::SoftVPX(
 const char *name,
 const char *componentRole,
        OMX_VIDEO_CODINGTYPE codingType,
 const OMX_CALLBACKTYPE *callbacks,
        OMX_PTR appData,
        OMX_COMPONENTTYPE **component)
 : SoftVideoDecoderOMXComponent(
            name, componentRole, codingType,
            NULL /* profileLevels */, 0 /* numProfileLevels */,
 320 /* width */, 240 /* height */, callbacks, appData, component),
      mMode(codingType == OMX_VIDEO_CodingVP8 ? MODE_VP8 : MODE_VP9),
      mCtx(NULL),
      mImg(NULL) {
 const size_t kMinCompressionRatio = mMode == MODE_VP8 ? 2 : 4;
 const char *mime = mMode == MODE_VP8 ? MEDIA_MIMETYPE_VIDEO_VP8 : MEDIA_MIMETYPE_VIDEO_VP9;
 const size_t kMaxOutputBufferSize = 2048 * 2048 * 3 / 2;
    initPorts(
            kNumBuffers, kMaxOutputBufferSize / kMinCompressionRatio /* inputBufferSize */,
            kNumBuffers, mime, kMinCompressionRatio);
    CHECK_EQ(initDecoder(), (status_t)OK);
}

long Tracks::ParseTrackEntry(
    long long track_start,
    long long track_size,
    long long element_start,
    long long element_size,
    Track*& pResult) const
{
    if (pResult)
        return -1;
    IMkvReader* const pReader = m_pSegment->m_pReader;
    long long pos = track_start;
    const long long track_stop = track_start + track_size;
    Track::Info info;
    info.type = 0;
    info.number = 0;
    info.uid = 0;
    info.defaultDuration = 0;
    Track::Settings v;
    v.start = -1;
    v.size = -1;
    Track::Settings a;
    a.start = -1;
    a.size = -1;
    Track::Settings e;  //content_encodings_settings;
    e.start = -1;
    e.size = -1;
    long long lacing = 1;  //default is true
    while (pos < track_stop)
    {
        long long id, size;
        const long status = ParseElementHeader(
                                pReader,
                                pos,
                                track_stop,
                                id,
                                size);
        if (status < 0)  //error
            return status;
        if (size < 0)
            return E_FILE_FORMAT_INVALID;
        const long long start = pos;
        if (id == 0x60)  // VideoSettings ID
        {
            v.start = start;
            v.size = size;
        }
        else if (id == 0x61)  // AudioSettings ID
        {
            a.start = start;
            a.size = size;
        }
        else if (id == 0x2D80) // ContentEncodings ID
        {
            e.start = start;
            e.size = size;
        }
        else if (id == 0x33C5)  //Track UID
        {
            if (size > 8)
                return E_FILE_FORMAT_INVALID;
            info.uid = 0;
            long long pos_ = start;
            const long long pos_end = start + size;
            while (pos_ != pos_end)
            {
                unsigned char b;
                const int status = pReader->Read(pos_, 1, &b);
                if (status)
                    return status;
                info.uid <<= 8;
                info.uid |= b;
                ++pos_;
            }
        }
        else if (id == 0x57)  //Track Number
        {
            const long long num = UnserializeUInt(pReader, pos, size);
            if ((num <= 0) || (num > 127))
                return E_FILE_FORMAT_INVALID;
            info.number = static_cast<long>(num);
        }
        else if (id == 0x03)  //Track Type
        {
            const long long type = UnserializeUInt(pReader, pos, size);
            if ((type <= 0) || (type > 254))
                return E_FILE_FORMAT_INVALID;
            info.type = static_cast<long>(type);
        }
        else if (id == 0x136E)  //Track Name
        {
            const long status = UnserializeString(
                                    pReader,
                                    pos,
                                    size,
                                    info.nameAsUTF8);
            if (status)
                return status;
        }
        else if (id == 0x02B59C)  //Track Language
        {
            const long status = UnserializeString(
                                    pReader,
                                    pos,
                                    size,
                                    info.language);
            if (status)
                return status;
        }
        else if (id == 0x03E383)  //Default Duration
        {
            const long long duration = UnserializeUInt(pReader, pos, size);
            if (duration < 0)
                return E_FILE_FORMAT_INVALID;
            info.defaultDuration = static_cast<unsigned long long>(duration);
        }
        else if (id == 0x06)  //CodecID
        {
            const long status = UnserializeString(
                                    pReader,
                                    pos,
                                    size,
                                    info.codecId);
            if (status)
                return status;
        }
        else if (id == 0x1C)  //lacing
        {
            lacing = UnserializeUInt(pReader, pos, size);
            if ((lacing < 0) || (lacing > 1))
                return E_FILE_FORMAT_INVALID;
        }
        else if (id == 0x23A2)  //Codec Private
        {
            delete[] info.codecPrivate;
            info.codecPrivate = NULL;
            info.codecPrivateSize = 0;
            const size_t buflen = static_cast<size_t>(size);
            if (buflen)
            {
                typedef unsigned char* buf_t;
                const buf_t buf = new (std::nothrow) unsigned char[buflen];
                if (buf == NULL)
                    return -1;
                const int status = pReader->Read(pos, buflen, buf);
                if (status)
                {
                    delete[] buf;
                    return status;
                }
                info.codecPrivate = buf;
                info.codecPrivateSize = buflen;
            }
        }
        else if (id == 0x058688)  //Codec Name
        {
            const long status = UnserializeString(
                                    pReader,
                                    pos,
                                    size,
                                    info.codecNameAsUTF8);
            if (status)
                return status;
        }
        else if (id == 0x16AA)  //Codec Delay
        {
            info.codecDelay = UnserializeUInt(pReader, pos, size);
        }
        else if (id == 0x16BB) //Seek Pre Roll
        {
            info.seekPreRoll = UnserializeUInt(pReader, pos, size);
        }
        pos += size;  //consume payload
        assert(pos <= track_stop);
    }
    assert(pos == track_stop);
    if (info.number <= 0)  //not specified
        return E_FILE_FORMAT_INVALID;
    if (GetTrackByNumber(info.number))
        return E_FILE_FORMAT_INVALID;
    if (info.type <= 0)  //not specified
        return E_FILE_FORMAT_INVALID;
    info.lacing = (lacing > 0) ? true : false;
    if (info.type == Track::kVideo)
    {
        if (v.start < 0)
            return E_FILE_FORMAT_INVALID;
        if (a.start >= 0)
            return E_FILE_FORMAT_INVALID;
        info.settings = v;
        VideoTrack* pTrack = NULL;
        const long status = VideoTrack::Parse(m_pSegment,
                                              info,
                                              element_start,
                                              element_size,
                                              pTrack);
        if (status)
            return status;
        pResult = pTrack;
        assert(pResult);
        if (e.start >= 0)
            pResult->ParseContentEncodingsEntry(e.start, e.size);
    }
    else if (info.type == Track::kAudio)
    {
        if (a.start < 0)
            return E_FILE_FORMAT_INVALID;
        if (v.start >= 0)
            return E_FILE_FORMAT_INVALID;
        info.settings = a;
        AudioTrack* pTrack = NULL;
        const long status = AudioTrack::Parse(m_pSegment,
                                              info,
                                              element_start,
                                              element_size,
                                              pTrack);
        if (status)
            return status;
        pResult = pTrack;
        assert(pResult);
        if (e.start >= 0)
            pResult->ParseContentEncodingsEntry(e.start, e.size);
    }
    else
    {
        // neither video nor audio - probably metadata or subtitles
        if (a.start >= 0)
            return E_FILE_FORMAT_INVALID;
        if (v.start >= 0)
            return E_FILE_FORMAT_INVALID;
        if (e.start >= 0)
            return E_FILE_FORMAT_INVALID;
        info.settings.start = -1;
        info.settings.size = 0;
        Track* pTrack = NULL;
        const long status = Track::Create(m_pSegment,
                                          info,
                                          element_start,
                                          element_size,
                                          pTrack);
        if (status)
            return status;
        pResult = pTrack;
        assert(pResult);
    }
    return 0;  //success
}

virtual void Predict(MB_PREDICTION_MODE mode) {
mbptr_->mode_info_context->mbmi.mode = mode;
    REGISTER_STATE_CHECK(pred_fn_(mbptr_,
                                  data_ptr_[0] - kStride,
                                  data_ptr_[0] - 1, kStride,
                                  data_ptr_[0], kStride));
}

  virtual uint8_t* GetReference(int block_idx) {
     return reference_data_ + block_idx * kDataBlockSize;
   }

 virtual void PSNRPktHook(const vpx_codec_cx_pkt_t *pkt) {
    psnr_ += pow(10.0, pkt->data.psnr.psnr[0] / 10.0);
    n_frames_++;
 }

virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,
::libvpx_test::Encoder *encoder) {
    if (video->frame() == 1) {
encoder->Control(VP8E_SET_CPUUSED, set_cpu_used_);
}
if (cfg_.ts_number_layers > 1) {
      if (video->frame() == 1) {
encoder->Control(VP9E_SET_SVC, 1);
}
      vpx_svc_layer_id_t layer_id = {0, 0};
layer_id.spatial_layer_id = 0;
frame_flags_ = SetFrameFlags(video->frame(), cfg_.ts_number_layers);
layer_id.temporal_layer_id = SetLayerId(video->frame(),
cfg_.ts_number_layers);
      if (video->frame() > 0) {
       encoder->Control(VP9E_SET_SVC_LAYER_ID, &layer_id);
      }
}
const vpx_rational_t tb = video->timebase();
timebase_ = static_cast<double>(tb.num) / tb.den;
duration_ = 0;
}

   virtual void BeginPassHook(unsigned int /*pass*/) {
     psnr_ = kMaxPsnr;
     nframes_ = 0;
 }

 virtual void SetUp() {
    fwd_txfm_ = GET_PARAM(0);
    inv_txfm_ = GET_PARAM(1);

     tx_type_  = GET_PARAM(2);
     pitch_    = 8;
     fwd_txfm_ref = fdct8x8_ref;
   }

 virtual void SetUp() {
 InitializeConfig();
 SetMode(GET_PARAM(1));
    sf_count_ = 0;
    sf_count_max_ = INT_MAX;
 }

long VideoTrack::Parse(
    Segment* pSegment,
    const Info& info,
    long long element_start,
    long long element_size,
    VideoTrack*& pResult)
{
    if (pResult)
        return -1;

    if (info.type != Track::kVideo)
        return -1;

    long long width = 0;
    long long height = 0;
    double rate = 0.0;

    IMkvReader* const pReader = pSegment->m_pReader;

    const Settings& s = info.settings;
    assert(s.start >= 0);
    assert(s.size >= 0);

    long long pos = s.start;
    assert(pos >= 0);

    const long long stop = pos + s.size;

    while (pos < stop)
    {
        long long id, size;

        const long status = ParseElementHeader(
                                pReader,
                                pos,
                                stop,
                                id,
                                size);

        if (status < 0)  //error
            return status;

        if (id == 0x30)  //pixel width
        {
            width = UnserializeUInt(pReader, pos, size);
            if (width <= 0)
                return E_FILE_FORMAT_INVALID;
        }
        else if (id == 0x3A)  //pixel height
        {
            height = UnserializeUInt(pReader, pos, size);
            if (height <= 0)
                return E_FILE_FORMAT_INVALID;
        }
        else if (id == 0x0383E3)  //frame rate
        {
            const long status = UnserializeFloat(
                                    pReader,
                                    pos,
                                    size,
                                    rate);
            if (status < 0)
                return status;
            if (rate <= 0)
                return E_FILE_FORMAT_INVALID;
        }
        pos += size;  //consume payload
        assert(pos <= stop);
    }
    assert(pos == stop);
    VideoTrack* const pTrack = new (std::nothrow) VideoTrack(pSegment,
                                                             element_start,
                                                             element_size);
    if (pTrack == NULL)
        return -1;  //generic error
    const int status = info.Copy(pTrack->m_info);
    if (status)  // error
    {
        delete pTrack;
        return status;
    }
    pTrack->m_width = width;
    pTrack->m_height = height;
    pTrack->m_rate = rate;
    pResult = pTrack;
    return 0;  //success
}

void EncoderTest::RunLoop(VideoSource *video) {
  vpx_codec_dec_cfg_t dec_cfg = {0};

stats_.Reset();

ASSERT_TRUE(passes_ == 1 || passes_ == 2);
for (unsigned int pass = 0; pass < passes_; pass++) {
last_pts_ = 0;

if (passes_ == 1)
cfg_.g_pass = VPX_RC_ONE_PASS;
else if (pass == 0)
cfg_.g_pass = VPX_RC_FIRST_PASS;
else
cfg_.g_pass = VPX_RC_LAST_PASS;

BeginPassHook(pass);

Encoder* const encoder = codec_->CreateEncoder(cfg_, deadline_, init_flags_,
&stats_);
ASSERT_TRUE(encoder != NULL);
    Decoder* const decoder = codec_->CreateDecoder(dec_cfg, 0);
bool again;
    for (again = true, video->Begin(); again; video->Next()) {
again = (video->img() != NULL);

PreEncodeFrameHook(video);
PreEncodeFrameHook(video, encoder);
encoder->EncodeFrame(video, frame_flags_);

CxDataIterator iter = encoder->GetCxData();

bool has_cxdata = false;
bool has_dxdata = false;
while (const vpx_codec_cx_pkt_t *pkt = iter.Next()) {
pkt = MutateEncoderOutputHook(pkt);
again = true;
switch (pkt->kind) {
case VPX_CODEC_CX_FRAME_PKT:
has_cxdata = true;

if (decoder && DoDecode()) {
vpx_codec_err_t res_dec = decoder->DecodeFrame(
(const uint8_t*)pkt->data.frame.buf, pkt->data.frame.sz);
              ASSERT_EQ(VPX_CODEC_OK, res_dec) << decoder->DecodeError();
has_dxdata = true;
}
ASSERT_GE(pkt->data.frame.pts, last_pts_);
last_pts_ = pkt->data.frame.pts;
FramePktHook(pkt);
break;

case VPX_CODEC_PSNR_PKT:
PSNRPktHook(pkt);
break;

default:
break;

}
}

if (has_dxdata && has_cxdata) {
const vpx_image_t *img_enc = encoder->GetPreviewFrame();
DxDataIterator dec_iter = decoder->GetDxData();
const vpx_image_t *img_dec = dec_iter.Next();
if (img_enc && img_dec) {
const bool res = compare_img(img_enc, img_dec);
if (!res) { // Mismatch
MismatchHook(img_enc, img_dec);
}
}
if (img_dec)
DecompressedFrameHook(*img_dec, video->pts());
}
if (!Continue())
break;
}

EndPassHook();

if (decoder)
delete decoder;
delete encoder;

if (!Continue())
break;
}
}

int main(int argc, char **argv) {
int frame_cnt = 0;
FILE *outfile = NULL;
vpx_codec_ctx_t codec;
const VpxInterface *decoder = NULL;
VpxVideoReader *reader = NULL;
const VpxVideoInfo *info = NULL;
int n = 0;
int m = 0;
int is_range = 0;
char *nptr = NULL;

exec_name = argv[0];

if (argc != 4)
die("Invalid number of arguments.");

reader = vpx_video_reader_open(argv[1]);
if (!reader)
die("Failed to open %s for reading.", argv[1]);

if (!(outfile = fopen(argv[2], "wb")))
die("Failed to open %s for writing.", argv[2]);

n = strtol(argv[3], &nptr, 0);
m = strtol(nptr + 1, NULL, 0);
is_range = (*nptr == '-');
if (!n || !m || (*nptr != '-' && *nptr != '/'))
die("Couldn't parse pattern %s.\n", argv[3]);

info = vpx_video_reader_get_info(reader);

decoder = get_vpx_decoder_by_fourcc(info->codec_fourcc);

if (!decoder)
die("Unknown input codec.");

  printf("Using %s\n", vpx_codec_iface_name(decoder->interface()));

  if (vpx_codec_dec_init(&codec, decoder->interface(), NULL, 0))
die_codec(&codec, "Failed to initialize decoder.");

while (vpx_video_reader_read_frame(reader)) {
vpx_codec_iter_t iter = NULL;
vpx_image_t *img = NULL;
size_t frame_size = 0;
int skip;
const unsigned char *frame = vpx_video_reader_get_frame(reader,
&frame_size);
if (vpx_codec_decode(&codec, frame, (unsigned int)frame_size, NULL, 0))
die_codec(&codec, "Failed to decode frame.");

++frame_cnt;

skip = (is_range && frame_cnt >= n && frame_cnt <= m) ||
(!is_range && m - (frame_cnt - 1) % m <= n);

if (!skip) {
putc('.', stdout);

while ((img = vpx_codec_get_frame(&codec, &iter)) != NULL)
vpx_img_write(img, outfile);
} else {
putc('X', stdout);
}

fflush(stdout);
}

printf("Processed %d frames.\n", frame_cnt);
if (vpx_codec_destroy(&codec))
die_codec(&codec, "Failed to destroy codec.");

printf("Play: ffplay -f rawvideo -pix_fmt yuv420p -s %dx%d %s\n",
info->frame_width, info->frame_height, argv[2]);

vpx_video_reader_close(reader);
fclose(outfile);

return EXIT_SUCCESS;
}

bool Track::GetLacing() const
{
    return m_info.lacing;
}

Track::~Track()
{
    Info& info = const_cast<Info&>(m_info);
    info.Clear();

    ContentEncoding** i = content_encoding_entries_;
    ContentEncoding** const j = content_encoding_entries_end_;

    while (i != j) {
        ContentEncoding* const encoding = *i++;
        delete encoding;
    }

    delete [] content_encoding_entries_;
}

virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {
    if (pkt->data.frame.flags & VPX_FRAME_IS_KEY) {
    }
  }

   virtual ~Trans4x4HT() {}

long long SegmentInfo::GetDuration() const
{
    if (m_duration < 0)
        return -1;
    assert(m_timecodeScale >= 1);
    const double dd = double(m_duration) * double(m_timecodeScale);
    const long long d = static_cast<long long>(dd);
    return d;
}

   void Reset() {
     error_nframes_ = 0;
     droppable_nframes_ = 0;
   }

 int Width() const { return GET_PARAM(0); }

const BlockEntry* Segment::GetBlock(
    const CuePoint& cp,
    const CuePoint::TrackPosition& tp)
{
    Cluster** const ii = m_clusters;
    Cluster** i = ii;

    const long count = m_clusterCount + m_clusterPreloadCount;

    Cluster** const jj = ii + count;
    Cluster** j = jj;

    while (i < j)
    {
        //INVARIANT:
        //[ii, i) < pTP->m_pos
        //[i, j) ?
        //[j, jj)  > pTP->m_pos

        Cluster** const k = i + (j - i) / 2;
        assert(k < jj);
        Cluster* const pCluster = *k;
        assert(pCluster);
        //const long long pos_ = pCluster->m_pos;
        //assert(pos_);
        //const long long pos = pos_ * ((pos_ < 0) ? -1 : 1);
        const long long pos = pCluster->GetPosition();
        assert(pos >= 0);
        if (pos < tp.m_pos)
            i = k + 1;
        else if (pos > tp.m_pos)
            j = k;
        else
            return pCluster->GetEntry(cp, tp);
    }
    assert(i == j);
    //assert(Cluster::HasBlockEntries(this, tp.m_pos));
    Cluster* const pCluster = Cluster::Create(this, -1, tp.m_pos); //, -1);
assert(pCluster);

    const ptrdiff_t idx = i - m_clusters;

    PreloadCluster(pCluster, idx);
    assert(m_clusters);
    assert(m_clusterPreloadCount > 0);
    assert(m_clusters[idx] == pCluster);

    return pCluster->GetEntry(cp, tp);
}

long long Cluster::GetPosition() const
{
    const long long pos = m_element_start - m_pSegment->m_start;
    assert(pos >= 0);

    return pos;
}

 ContentEncoding::GetCompressionByIndex(unsigned long idx) const {
   const ptrdiff_t count = compression_entries_end_ - compression_entries_;
  assert(count >= 0);

 if (idx >= static_cast<unsigned long>(count))
 return NULL;

 return compression_entries_[idx];
}

 virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,
 ::libvpx_test::Encoder *encoder) {
 if (video->frame() == 1) {
      encoder->Control(VP8E_SET_CPUUSED, 1);
      encoder->Control(VP8E_SET_ENABLEAUTOALTREF, 1);
      encoder->Control(VP8E_SET_ARNR_MAXFRAMES, 7);
      encoder->Control(VP8E_SET_ARNR_STRENGTH, 5);
      encoder->Control(VP8E_SET_ARNR_TYPE, 3);
 }
 }

 static void TearDownTestCase() {
    vpx_free(src_);
    src_ = NULL;
    vpx_free(dst_);
    dst_ = NULL;
    vpx_free(dst_c_);
    dst_c_ = NULL;
 }

bool Segment::DoneParsing() const
{
    if (m_size < 0)
    {
        long long total, avail;

        const int status = m_pReader->Length(&total, &avail);

        if (status < 0)  //error
            return true;  //must assume done

        if (total < 0)
            return false;  //assume live stream

        return (m_pos >= total);
    }

    const long long stop = m_start + m_size;

    return (m_pos >= stop);
}

 int BorderLeft() const {
 const int center = (kOuterBlockSize - Width()) / 2;
 return (center + (kDataAlignment - 1)) & ~(kDataAlignment - 1);
 }

long long CuePoint::GetTimeCode() const
{
    return m_timecode;
}

long Segment::ParseNext(
    const Cluster* pCurr,
    const Cluster*& pResult,
    long long& pos,
    long& len)
{
    assert(pCurr);
    assert(!pCurr->EOS());
    assert(m_clusters);

    pResult = 0;

    if (pCurr->m_index >= 0)  //loaded (not merely preloaded)
    {
        assert(m_clusters[pCurr->m_index] == pCurr);

        const long next_idx = pCurr->m_index + 1;

        if (next_idx < m_clusterCount)
        {
            pResult = m_clusters[next_idx];
            return 0;  //success
        }

        //curr cluster is last among loaded

        const long result = LoadCluster(pos, len);

        if (result < 0)  //error or underflow
            return result;

        if (result > 0)  //no more clusters
        {
            //pResult = &m_eos;
            return 1;
        }

        pResult = GetLast();
        return 0;  //success
}

    assert(m_pos > 0);

    long long total, avail;

    long status = m_pReader->Length(&total, &avail);

    if (status < 0)  //error
        return status;

    assert((total < 0) || (avail <= total));

    const long long segment_stop = (m_size < 0) ? -1 : m_start + m_size;

    //interrogate curr cluster

    pos = pCurr->m_element_start;

    if (pCurr->m_element_size >= 0)
        pos += pCurr->m_element_size;
else
    {
        if ((pos + 1) > avail)
        {
            len = 1;
            return E_BUFFER_NOT_FULL;
        }

        long long result = GetUIntLength(m_pReader, pos, len);

        if (result < 0)  //error
            return static_cast<long>(result);

        if (result > 0)  //weird
            return E_BUFFER_NOT_FULL;

        if ((segment_stop >= 0) && ((pos + len) > segment_stop))
            return E_FILE_FORMAT_INVALID;

        if ((pos + len) > avail)
            return E_BUFFER_NOT_FULL;
        const long long id = ReadUInt(m_pReader, pos, len);
        if (id != 0x0F43B675)  //weird: not Cluster ID
            return -1;
        pos += len;  //consume ID
        //Read Size
        if ((pos + 1) > avail)
        {
            len = 1;
            return E_BUFFER_NOT_FULL;
        }
        result = GetUIntLength(m_pReader, pos, len);
        if (result < 0)  //error
            return static_cast<long>(result);
        if (result > 0)  //weird
            return E_BUFFER_NOT_FULL;
        if ((segment_stop >= 0) && ((pos + len) > segment_stop))
            return E_FILE_FORMAT_INVALID;
        if ((pos + len) > avail)
            return E_BUFFER_NOT_FULL;
        const long long size = ReadUInt(m_pReader, pos, len);
        if (size < 0) //error
            return static_cast<long>(size);
        pos += len;  //consume size field
        const long long unknown_size = (1LL << (7 * len)) - 1;
        if (size == unknown_size)          //TODO: should never happen
            return E_FILE_FORMAT_INVALID;  //TODO: resolve this
        //assert((pCurr->m_size <= 0) || (pCurr->m_size == size));
        if ((segment_stop >= 0) && ((pos + size) > segment_stop))
            return E_FILE_FORMAT_INVALID;
        //Pos now points to start of payload
        pos += size;  //consume payload (that is, the current cluster)
        assert((segment_stop < 0) || (pos <= segment_stop));
        //By consuming the payload, we are assuming that the curr
        //cluster isn't interesting.  That is, we don't bother checking
        //whether the payload of the curr cluster is less than what
        //happens to be available (obtained via IMkvReader::Length).
        //Presumably the caller has already dispensed with the current
        //cluster, and really does want the next cluster.
    }
    //pos now points to just beyond the last fully-loaded cluster
    for (;;)
    {
        const long status = DoParseNext(pResult, pos, len);
        if (status <= 1)
            return status;
    }
}

static void unset_active_map(const vpx_codec_enc_cfg_t *cfg,
vpx_codec_ctx_t *codec) {
  vpx_active_map_t map = {0};

map.rows = (cfg->g_h + 15) / 16;
map.cols = (cfg->g_w + 15) / 16;
map.active_map = NULL;

if (vpx_codec_control(codec, VP8E_SET_ACTIVEMAP, &map))

die_codec(codec, "Failed to set active map");
}

int arg_parse_enum(const struct arg *arg) {
 const struct arg_enum_list *listptr;
 long int                    rawval;
 char *endptr;

 /* First see if the value can be parsed as a raw value */
  rawval = strtol(arg->val, &endptr, 10);
 if (arg->val[0] != '\0' && endptr[0] == '\0') {
 /* Got a raw value, make sure it's valid */
 for (listptr = arg->def->enums; listptr->name; listptr++)
 if (listptr->val == rawval)
 return rawval;
 }

 /* Next see if it can be parsed as a string */
 for (listptr = arg->def->enums; listptr->name; listptr++)
 if (!strcmp(arg->val, listptr->name))
 return listptr->val;

  die("Option %s: Invalid value '%s'\n", arg->name, arg->val);
 return 0;
}

   virtual ~Trans16x16HT() {}

const Tracks* Segment::GetTracks() const
{
    return m_pTracks;
}

 int SetFrameFlags(int frame_num, int num_temp_layers) {
 int frame_flags = 0;
 if (num_temp_layers == 2) {
 if (frame_num % 2 == 0) {
        frame_flags = VP8_EFLAG_NO_REF_GF | VP8_EFLAG_NO_UPD_GF |
                      VP8_EFLAG_NO_UPD_ARF;
 } else {
        frame_flags = VP8_EFLAG_NO_UPD_ARF | VP8_EFLAG_NO_UPD_LAST |
                      VP8_EFLAG_NO_UPD_ENTROPY;
 }
 } else if (num_temp_layers == 3) {
 if (frame_num % 4 == 0) {
        frame_flags = VP8_EFLAG_NO_UPD_GF | VP8_EFLAG_NO_UPD_ARF |
                      VP8_EFLAG_NO_REF_GF;
 } else if ((frame_num - 2) % 4 == 0) {
        frame_flags = VP8_EFLAG_NO_UPD_ARF | VP8_EFLAG_NO_UPD_LAST;
 } else if ((frame_num - 1) % 2 == 0) {
        frame_flags = VP8_EFLAG_NO_UPD_GF | VP8_EFLAG_NO_UPD_ARF |
                      VP8_EFLAG_NO_UPD_LAST;
 }
 }
 return frame_flags;
 }

Cues::~Cues()
{
    const long n = m_count + m_preload_count;

    CuePoint** p = m_cue_points;
    CuePoint** const q = p + n;

    while (p != q)
    {
        CuePoint* const pCP = *p++;
        assert(pCP);

        delete pCP;
    }

delete[] m_cue_points;
}

   virtual void TearDown() {
    libvpx_test::ClearSystemState();
 }

const SeekHead::VoidElement* SeekHead::GetVoidElement(int idx) const
{
    if (idx < 0)
        return 0;
    if (idx >= m_void_element_count)
        return 0;
    return m_void_elements + idx;
}

   virtual ~FwdTrans8x8DCT() {}

long long AudioTrack::GetBitDepth() const
{
    return m_bitDepth;
}

int get_vp9_one_less_byte_frame_buffer(void *user_priv, size_t min_size,
 vpx_codec_frame_buffer_t *fb) {
 ExternalFrameBufferList *const fb_list =
 reinterpret_cast<ExternalFrameBufferList*>(user_priv);
 return fb_list->GetFreeFrameBuffer(min_size - 1, fb);
}

void usage_exit() {
   fprintf(stderr, "Usage: %s <codec> <width> <height> <infile> <outfile>\n",
           exec_name);
   exit(EXIT_FAILURE);
}

const Cluster* Segment::FindCluster(long long time_ns) const
{
    if ((m_clusters == NULL) || (m_clusterCount <= 0))
        return &m_eos;

    {
        Cluster* const pCluster = m_clusters[0];
        assert(pCluster);
        assert(pCluster->m_index == 0);

        if (time_ns <= pCluster->GetTime())
            return pCluster;
    }

    //Binary search of cluster array

    long i = 0;
    long j = m_clusterCount;

    while (i < j)
    {
        //INVARIANT:
        //[0, i) <= time_ns
        //[i, j) ?
        //[j, m_clusterCount)  > time_ns
        const long k = i + (j - i) / 2;
        assert(k < m_clusterCount);
        Cluster* const pCluster = m_clusters[k];
        assert(pCluster);
        assert(pCluster->m_index == k);
        const long long t = pCluster->GetTime();
        if (t <= time_ns)
            i = k + 1;
        else
            j = k;
        assert(i <= j);
    }
    assert(i == j);
    assert(i > 0);
    assert(i <= m_clusterCount);
    const long k = i - 1;

Cluster* const pCluster = m_clusters[k];
assert(pCluster);
assert(pCluster->m_index == k);
    assert(pCluster->GetTime() <= time_ns);

    return pCluster;
}

int ReturnFrameBuffer(vpx_codec_frame_buffer_t *fb) {
    EXPECT_TRUE(fb != NULL);
ExternalFrameBuffer *const ext_fb =
reinterpret_cast<ExternalFrameBuffer*>(fb->priv);
    EXPECT_TRUE(ext_fb != NULL);
EXPECT_EQ(1, ext_fb->in_use);
ext_fb->in_use = 0;
return 0;
}

void destroy_rate_histogram(struct rate_hist *hist) {
 if (hist) {
    free(hist->pts);
    free(hist->sz);
    free(hist);
 }
}

virtual void SetUp() {
    const tuple<int, int, SubpelVarianceFunctionType>& params =
        this->GetParam();
log2width_  = get<0>(params);
width_ = 1 << log2width_;
log2height_ = get<1>(params);
height_ = 1 << log2height_;
    subpel_variance_ = get<2>(params);

rnd(ACMRandom::DeterministicSeed());
block_size_ = width_ * height_;
src_ = reinterpret_cast<uint8_t *>(vpx_memalign(16, block_size_));
    sec_ = reinterpret_cast<uint8_t *>(vpx_memalign(16, block_size_));
    ref_ = new uint8_t[block_size_ + width_ + height_ + 1];
ASSERT_TRUE(src_ != NULL);
    ASSERT_TRUE(sec_ != NULL);
ASSERT_TRUE(ref_ != NULL);
}

int Chapters::Atom::GetDisplayCount() const
{
    return m_displays_count;
}

void usage_exit() {
   fprintf(stderr, "Usage: %s <width> <height> <infile> <outfile> <frame>\n",
           exec_name);
   exit(EXIT_FAILURE);
 }

 void UpdateMD5(::libvpx_test::Decoder *dec, const vpx_codec_cx_pkt_t *pkt,
 ::libvpx_test::MD5 *md5) {
 const vpx_codec_err_t res = dec->DecodeFrame(
 reinterpret_cast<uint8_t*>(pkt->data.frame.buf), pkt->data.frame.sz);
 if (res != VPX_CODEC_OK) {
      abort_ = true;
      ASSERT_EQ(VPX_CODEC_OK, res);
 }
 const vpx_image_t *img = dec->GetDxData().Next();
    md5->Add(img);
 }

long long VideoTrack::GetWidth() const
{
    return m_width;
}

string DecodeFile(const string& filename, int num_threads) {
libvpx_test::WebMVideoSource video(filename);
video.Init();

  vpx_codec_dec_cfg_t cfg = {0};
cfg.threads = num_threads;
libvpx_test::VP9Decoder decoder(cfg, 0);

libvpx_test::MD5 md5;
for (video.Begin(); video.cxdata(); video.Next()) {
const vpx_codec_err_t res =
decoder.DecodeFrame(video.cxdata(), video.frame_size());
if (res != VPX_CODEC_OK) {
EXPECT_EQ(VPX_CODEC_OK, res) << decoder.DecodeError();
break;
}

libvpx_test::DxDataIterator dec_iter = decoder.GetDxData();
const vpx_image_t *img = NULL;

// Get decompressed data
while ((img = dec_iter.Next())) {
md5.Add(img);
}
}

return string(md5.Get());
}

void RunCoeffCheck() {
ACMRandom rnd(ACMRandom::DeterministicSeed());
const int count_test_block = 1000;
    DECLARE_ALIGNED_ARRAY(16, int16_t, input_block, kNumCoeffs);
    DECLARE_ALIGNED_ARRAY(16, int16_t, output_ref_block, kNumCoeffs);
    DECLARE_ALIGNED_ARRAY(16, int16_t, output_block, kNumCoeffs);

for (int i = 0; i < count_test_block; ++i) {
      // Initialize a test block with input range [-255, 255].
for (int j = 0; j < kNumCoeffs; ++j)
        input_block[j] = rnd.Rand8() - rnd.Rand8();

fwd_txfm_ref(input_block, output_ref_block, pitch_, tx_type_);
      REGISTER_STATE_CHECK(RunFwdTxfm(input_block, output_block, pitch_));

// The minimum quant value is 4.
for (int j = 0; j < kNumCoeffs; ++j)
EXPECT_EQ(output_block[j], output_ref_block[j]);
}
}

 int ThreadHook(void* data, void* return_value) {
 int* const hook_data = reinterpret_cast<int*>(data);
 *hook_data = 5;

   return *reinterpret_cast<int*>(return_value);
 }

static void encode_frame(vpx_codec_ctx_t *codec,
                         vpx_image_t *img,
                         int frame_index,
                         VpxVideoWriter *writer) {
vpx_codec_iter_t iter = NULL;
const vpx_codec_cx_pkt_t *pkt = NULL;
const vpx_codec_err_t res = vpx_codec_encode(codec, img, frame_index, 1, 0,
VPX_DL_GOOD_QUALITY);
if (res != VPX_CODEC_OK)

die_codec(codec, "Failed to encode frame");

while ((pkt = vpx_codec_get_cx_data(codec, &iter)) != NULL) {
if (pkt->kind == VPX_CODEC_CX_FRAME_PKT) {
const int keyframe = (pkt->data.frame.flags & VPX_FRAME_IS_KEY) != 0;
if (!vpx_video_writer_write_frame(writer,
pkt->data.frame.buf,
pkt->data.frame.sz,
pkt->data.frame.pts)) {
die_codec(codec, "Failed to write compressed frame");
}

printf(keyframe ? "K" : ".");

fflush(stdout);
}
}
}

long Segment::DoLoadCluster(
    long long& pos,
    long& len)
{
    if (m_pos < 0)
        return DoLoadClusterUnknownSize(pos, len);

    long long total, avail;

    long status = m_pReader->Length(&total, &avail);

    if (status < 0)  //error
        return status;

    assert((total < 0) || (avail <= total));

    const long long segment_stop = (m_size < 0) ? -1 : m_start + m_size;

    long long cluster_off = -1;   //offset relative to start of segment
    long long cluster_size = -1;  //size of cluster payload

    for (;;)
    {
        if ((total >= 0) && (m_pos >= total))
            return 1;  //no more clusters

        if ((segment_stop >= 0) && (m_pos >= segment_stop))
            return 1;  //no more clusters

        pos = m_pos;

        //Read ID

        if ((pos + 1) > avail)
        {
            len = 1;
            return E_BUFFER_NOT_FULL;
        }

        long long result = GetUIntLength(m_pReader, pos, len);

        if (result < 0)  //error
            return static_cast<long>(result);

        if (result > 0)  //weird
            return E_BUFFER_NOT_FULL;

        if ((segment_stop >= 0) && ((pos + len) > segment_stop))
            return E_FILE_FORMAT_INVALID;

        if ((pos + len) > avail)
            return E_BUFFER_NOT_FULL;

        const long long idpos = pos;
        const long long id = ReadUInt(m_pReader, idpos, len);

        if (id < 0)  //error (or underflow)
            return static_cast<long>(id);

        pos += len;  //consume ID

        //Read Size
        if ((pos + 1) > avail)
        {
            len = 1;
            return E_BUFFER_NOT_FULL;
        }
        result = GetUIntLength(m_pReader, pos, len);
        if (result < 0)  //error
            return static_cast<long>(result);
        if (result > 0)  //weird
            return E_BUFFER_NOT_FULL;
        if ((segment_stop >= 0) && ((pos + len) > segment_stop))
            return E_FILE_FORMAT_INVALID;
        if ((pos + len) > avail)
            return E_BUFFER_NOT_FULL;
        const long long size = ReadUInt(m_pReader, pos, len);
        if (size < 0)  //error
            return static_cast<long>(size);
        pos += len;  //consume length of size of element
        //pos now points to start of payload
        if (size == 0)  //weird
        {
            m_pos = pos;
            continue;
        }
        const long long unknown_size = (1LL << (7 * len)) - 1;
#if 0  //we must handle this to support live webm
if (size == unknown_size)
return E_FILE_FORMAT_INVALID;  //TODO: allow this
#endif

        if ((segment_stop >= 0) &&
            (size != unknown_size) &&
            ((pos + size) > segment_stop))
        {
            return E_FILE_FORMAT_INVALID;
        }

#if 0  //commented-out, to support incremental cluster parsing
len = static_cast<long>(size);

if ((pos + size) > avail)
return E_BUFFER_NOT_FULL;
#endif

        if (id == 0x0C53BB6B)  //Cues ID
        {
            if (size == unknown_size)
                return E_FILE_FORMAT_INVALID;  //TODO: liberalize

            if (m_pCues == NULL)
            {
                const long long element_size = (pos - idpos) + size;

                m_pCues = new Cues(this,
                                   pos,
                                   size,
                                   idpos,
                                   element_size);
                assert(m_pCues);  //TODO
            }

            m_pos = pos + size;  //consume payload
            continue;
        }
        if (id != 0x0F43B675)  //Cluster ID
        {
            if (size == unknown_size)
                return E_FILE_FORMAT_INVALID;  //TODO: liberalize
            m_pos = pos + size;  //consume payload
            continue;
        }
        //We have a cluster.
        cluster_off = idpos - m_start;  //relative pos
        if (size != unknown_size)
            cluster_size = size;
        break;
}

    assert(cluster_off >= 0);  //have cluster

    long long pos_;
    long len_;
    status = Cluster::HasBlockEntries(this, cluster_off, pos_, len_);
    if (status < 0) //error, or underflow
    {
        pos = pos_;
        len = len_;
        return status;
}

    //status == 0 means "no block entries found"
    //status > 0 means "found at least one block entry"

    //TODO:
    //The issue here is that the segment increments its own
    //pos ptr past the most recent cluster parsed, and then
    //starts from there to parse the next cluster.  If we
    //don't know the size of the current cluster, then we
    //must either parse its payload (as we do below), looking
    //for the cluster (or cues) ID to terminate the parse.
    //This isn't really what we want: rather, we really need
    //a way to create the curr cluster object immediately.
    //The pity is that cluster::parse can determine its own
    //boundary, and we largely duplicate that same logic here.
    
    //Maybe we need to get rid of our look-ahead preloading
    //in source::parse???
    
    //As we're parsing the blocks in the curr cluster
    //(in cluster::parse), we should have some way to signal
    //to the segment that we have determined the boundary,
    //so it can adjust its own segment::m_pos member.
    
    //The problem is that we're asserting in asyncreadinit,
    //because we adjust the pos down to the curr seek pos,
    //and the resulting adjusted len is > 2GB.  I'm suspicious
    //that this is even correct, but even if it is, we can't
    //be loading that much data in the cache anyway.

    const long idx = m_clusterCount;

    if (m_clusterPreloadCount > 0)
    {
        assert(idx < m_clusterSize);

        Cluster* const pCluster = m_clusters[idx];
        assert(pCluster);
        assert(pCluster->m_index < 0);

        const long long off = pCluster->GetPosition();
        assert(off >= 0);

        if (off == cluster_off)  //preloaded already
        {
            if (status == 0)  //no entries found
                return E_FILE_FORMAT_INVALID;

            if (cluster_size >= 0)
                pos += cluster_size;
            else
            {
                const long long element_size = pCluster->GetElementSize();

                if (element_size <= 0)
                    return E_FILE_FORMAT_INVALID;  //TODO: handle this case

                pos = pCluster->m_element_start + element_size;
            }

            pCluster->m_index = idx;  //move from preloaded to loaded
            ++m_clusterCount;
            --m_clusterPreloadCount;

            m_pos = pos;  //consume payload
            assert((segment_stop < 0) || (m_pos <= segment_stop));

            return 0;  //success
        }
    }
    if (status == 0)  //no entries found
    {
        if (cluster_size < 0)
            return E_FILE_FORMAT_INVALID;  //TODO: handle this
        pos += cluster_size;
        if ((total >= 0) && (pos >= total))
        {
            m_pos = total;
            return 1;  //no more clusters
        }
        if ((segment_stop >= 0) && (pos >= segment_stop))
        {
            m_pos = segment_stop;
            return 1;  //no more clusters
        }
        m_pos = pos;
        return 2;  //try again
    }
    //status > 0 means we have an entry
    Cluster* const pCluster = Cluster::Create(this,
                                              idx,
                                              cluster_off);
                                              //element_size);
    assert(pCluster);
    AppendCluster(pCluster);
    assert(m_clusters);
assert(idx < m_clusterSize);
    assert(m_clusters[idx] == pCluster);

    if (cluster_size >= 0)
    {
pos += cluster_size;

        m_pos = pos;
        assert((segment_stop < 0) || (m_pos <= segment_stop));

        return 0;
}

    m_pUnknownSize = pCluster;
    m_pos = -pos;

    return 0;  //partial success, since we have a new cluster

    //status == 0 means "no block entries found"

    //pos designates start of payload
    //m_pos has NOT been adjusted yet (in case we need to come back here)

#if 0

    if (cluster_size < 0)  //unknown size
    {
const long long payload_pos = pos;  //absolute pos of cluster payload

        for (;;)  //determine cluster size
        {
if ((total >= 0) && (pos >= total))
break;

if ((segment_stop >= 0) && (pos >= segment_stop))
break; //no more clusters

//Read ID

if ((pos + 1) > avail)
{
len = 1;
return E_BUFFER_NOT_FULL;
}

long long result = GetUIntLength(m_pReader, pos, len);

if (result < 0) //error
return static_cast<long>(result);

if (result > 0) //weird
return E_BUFFER_NOT_FULL;

if ((segment_stop >= 0) && ((pos + len) > segment_stop))
return E_FILE_FORMAT_INVALID;

if ((pos + len) > avail)
return E_BUFFER_NOT_FULL;

const long long idpos = pos;
const long long id = ReadUInt(m_pReader, idpos, len);

if (id < 0) //error (or underflow)
return static_cast<long>(id);

//This is the distinguished set of ID's we use to determine
//that we have exhausted the sub-element's inside the cluster
//whose ID we parsed earlier.

if (id == 0x0F43B675) //Cluster ID
break;

if (id == 0x0C53BB6B) //Cues ID
break;

switch (id)
{
case 0x20: //BlockGroup
case 0x23: //Simple Block
case 0x67: //TimeCode
case 0x2B: //PrevSize
break;

default:
assert(false);
break;
}

pos += len; //consume ID (of sub-element)

//Read Size

if ((pos + 1) > avail)
{
len = 1;
return E_BUFFER_NOT_FULL;
}

result = GetUIntLength(m_pReader, pos, len);

if (result < 0) //error
return static_cast<long>(result);

if (result > 0) //weird
return E_BUFFER_NOT_FULL;

if ((segment_stop >= 0) && ((pos + len) > segment_stop))
return E_FILE_FORMAT_INVALID;

if ((pos + len) > avail)
return E_BUFFER_NOT_FULL;

const long long size = ReadUInt(m_pReader, pos, len);

if (size < 0) //error
return static_cast<long>(size);

pos += len; //consume size field of element

//pos now points to start of sub-element's payload

if (size == 0) //weird
continue;

const long long unknown_size = (1LL << (7 * len)) - 1;

if (size == unknown_size)
return E_FILE_FORMAT_INVALID; //not allowed for sub-elements

if ((segment_stop >= 0) && ((pos + size) > segment_stop)) //weird
return E_FILE_FORMAT_INVALID;

pos += size; //consume payload of sub-element
assert((segment_stop < 0) || (pos <= segment_stop));
} //determine cluster size

cluster_size = pos - payload_pos;
assert(cluster_size >= 0);

pos = payload_pos; //reset and re-parse original cluster
}

if (m_clusterPreloadCount > 0)
{
assert(idx < m_clusterSize);

Cluster* const pCluster = m_clusters[idx];
assert(pCluster);
assert(pCluster->m_index < 0);

const long long off = pCluster->GetPosition();
assert(off >= 0);

if (off == cluster_off) //preloaded already
return E_FILE_FORMAT_INVALID; //subtle
}

m_pos = pos + cluster_size; //consume payload
assert((segment_stop < 0) || (m_pos <= segment_stop));


return 2;     //try to find another cluster

#endif
}

 virtual ~ExternalFrameBufferMD5Test() {
 if (md5_file_ != NULL)
      fclose(md5_file_);
 }

long VideoTrack::Seek(
    long long time_ns,
    const BlockEntry*& pResult) const
{
    const long status = GetFirst(pResult);
    if (status < 0)  //buffer underflow, etc
return status;

    assert(pResult);

    if (pResult->EOS())
        return 0;

    const Cluster* pCluster = pResult->GetCluster();
assert(pCluster);
assert(pCluster->GetIndex() >= 0);

    if (time_ns <= pResult->GetBlock()->GetTime(pCluster))
        return 0;

    Cluster** const clusters = m_pSegment->m_clusters;
    assert(clusters);

    const long count = m_pSegment->GetCount();  //loaded only, not pre-loaded
    assert(count > 0);

    Cluster** const i = clusters + pCluster->GetIndex();
    assert(i);
    assert(*i == pCluster);
    assert(pCluster->GetTime() <= time_ns);

    Cluster** const j = clusters + count;

    Cluster** lo = i;
    Cluster** hi = j;

    while (lo < hi)
    {
        //INVARIANT:
        //[i, lo) <= time_ns
        //[lo, hi) ?
        //[hi, j)  > time_ns

        Cluster** const mid = lo + (hi - lo) / 2;
        assert(mid < hi);
        pCluster = *mid;
        assert(pCluster);
        assert(pCluster->GetIndex() >= 0);
        assert(pCluster->GetIndex() == long(mid - m_pSegment->m_clusters));
        const long long t = pCluster->GetTime();
        if (t <= time_ns)
            lo = mid + 1;
        else
            hi = mid;
        assert(lo <= hi);
    }
    assert(lo == hi);
    assert(lo > i);
    assert(lo <= j);
pCluster = *--lo;
assert(pCluster);
assert(pCluster->GetTime() <= time_ns);

    pResult = pCluster->GetEntry(this, time_ns);
    if ((pResult != 0) && !pResult->EOS())  //found a keyframe
        return 0;
    while (lo != i)
    {
        pCluster = *--lo;
        assert(pCluster);
        assert(pCluster->GetTime() <= time_ns);
#if 0
//TODO:
//We need to handle the case when a cluster
//contains multiple keyframes.  Simply returning
//the largest keyframe on the cluster isn't

//good enough.
pResult = pCluster->GetMaxKey(this);
#else
        pResult = pCluster->GetEntry(this, time_ns);
#endif

        if ((pResult != 0) && !pResult->EOS())
            return 0;
}

    //weird: we're on the first cluster, but no keyframe found
    //should never happen but we must return something anyway

    pResult = GetEOS();
    return 0;
}

 virtual void SetUp() {
 InitializeConfig();
 SetMode(GET_PARAM(1));
 }

void Block::SetKey(bool bKey)
{
    if (bKey)
        m_flags |= static_cast<unsigned char>(1 << 7);
    else
        m_flags &= 0x7F;
}

 virtual void Predict(MB_PREDICTION_MODE mode) {
    mbptr_->mode_info_context->mbmi.uv_mode = mode;
    pred_fn_(mbptr_, data_ptr_[0] - kStride, data_ptr_[1] - kStride,
             data_ptr_[0] - 1, data_ptr_[1] - 1, kStride,

              data_ptr_[0], data_ptr_[1], kStride);
   }

  void RunInvTxfm(int16_t *out, uint8_t *dst, int stride) {
     inv_txfm_(out, dst, stride, tx_type_);
   }

const char* Chapters::Display::GetLanguage() const
{
    return m_language;
}

vpx_codec_err_t Decoder::DecodeFrame(const uint8_t *cxdata, size_t size) {
vpx_codec_err_t res_dec;
InitOnce();
  REGISTER_STATE_CHECK(
res_dec = vpx_codec_decode(&decoder_,
cxdata, static_cast<unsigned int>(size),
                                 NULL, 0));
return res_dec;
}

static void mem_put_le32(char *const mem, const unsigned int val) {
  mem[0] = val;
  mem[1] = val >> 8;
  mem[2] = val >> 16;
  mem[3] = val >> 24;
}

virtual void TearDown() {
    vp9_worker_end(&worker_);
}

long Cluster::GetFirst(const BlockEntry*& pFirst) const
{
    if (m_entries_count <= 0)
    {
        long long pos;
        long len;
        const long status = Parse(pos, len);
        if (status < 0)  //error
        {
            pFirst = NULL;
            return status;
        }
        if (m_entries_count <= 0)  //empty cluster
        {
            pFirst = NULL;
            return 0;
        }
    }
    assert(m_entries);
    pFirst = m_entries[0];
    assert(pFirst);
    return 0;  //success
}

long long Chapters::Atom::GetStartTime(const Chapters* pChapters) const
{
    return GetTime(pChapters, m_start_timecode);
}

 static bool compare_img(const vpx_image_t *img1,
                         const vpx_image_t *img2) {
   bool match = (img1->fmt == img2->fmt) &&
                (img1->d_w == img2->d_w) &&
                (img1->d_h == img2->d_h);
 
 const unsigned int width_y  = img1->d_w;
 const unsigned int height_y = img1->d_h;
 unsigned int i;
 for (i = 0; i < height_y; ++i)
    match = (memcmp(img1->planes[VPX_PLANE_Y] + i * img1->stride[VPX_PLANE_Y],
                    img2->planes[VPX_PLANE_Y] + i * img2->stride[VPX_PLANE_Y],
                    width_y) == 0) && match;
 const unsigned int width_uv  = (img1->d_w + 1) >> 1;
 const unsigned int height_uv = (img1->d_h + 1) >> 1;
 for (i = 0; i <  height_uv; ++i)
    match = (memcmp(img1->planes[VPX_PLANE_U] + i * img1->stride[VPX_PLANE_U],
                    img2->planes[VPX_PLANE_U] + i * img2->stride[VPX_PLANE_U],
                    width_uv) == 0) && match;
 for (i = 0; i < height_uv; ++i)
    match = (memcmp(img1->planes[VPX_PLANE_V] + i * img1->stride[VPX_PLANE_V],
                    img2->planes[VPX_PLANE_V] + i * img2->stride[VPX_PLANE_V],
                    width_uv) == 0) && match;

   return match;
 }

int arg_match(struct arg *arg_, const struct arg_def *def, char **argv) {
 struct arg arg;

 if (!argv[0] || argv[0][0] != '-')
 return 0;

  arg = arg_init(argv);

 if (def->short_name
 && strlen(arg.argv[0]) == strlen(def->short_name) + 1
 && !strcmp(arg.argv[0] + 1, def->short_name)) {

    arg.name = arg.argv[0] + 1;
    arg.val = def->has_val ? arg.argv[1] : NULL;
    arg.argv_step = def->has_val ? 2 : 1;
 } else if (def->long_name) {
 const size_t name_len = strlen(def->long_name);

 if (strlen(arg.argv[0]) >= name_len + 2
 && arg.argv[0][1] == '-'
 && !strncmp(arg.argv[0] + 2, def->long_name, name_len)
 && (arg.argv[0][name_len + 2] == '='
 || arg.argv[0][name_len + 2] == '\0')) {

      arg.name = arg.argv[0] + 2;
      arg.val = arg.name[name_len] == '=' ? arg.name + name_len + 1 : NULL;
      arg.argv_step = 1;
 }
 }

 if (arg.name && !arg.val && def->has_val)
    die("Error: option %s requires argument.\n", arg.name);

 if (arg.name && arg.val && !def->has_val)
    die("Error: option %s requires no argument.\n", arg.name);

 if (arg.name
 && (arg.val || !def->has_val)) {
    arg.def = def;
 *arg_ = arg;
 return 1;
 }

 return 0;
}

static void write_ivf_file_header(FILE *outfile,
 const vpx_codec_enc_cfg_t *cfg,
 int frame_cnt) {
 char header[32];

 if(cfg->g_pass != VPX_RC_ONE_PASS && cfg->g_pass != VPX_RC_LAST_PASS)
 return;
    header[0] = 'D';
    header[1] = 'K';
    header[2] = 'I';
    header[3] = 'F';
    mem_put_le16(header+4, 0); /* version */
    mem_put_le16(header+6, 32); /* headersize */
    mem_put_le32(header+8,  fourcc); /* headersize */
    mem_put_le16(header+12, cfg->g_w); /* width */
    mem_put_le16(header+14, cfg->g_h); /* height */
    mem_put_le32(header+16, cfg->g_timebase.den); /* rate */
    mem_put_le32(header+20, cfg->g_timebase.num); /* scale */
    mem_put_le32(header+24, frame_cnt); /* length */
    mem_put_le32(header+28, 0); /* unused */

 (void) fwrite(header, 1, 32, outfile);
}

void RunInvAccuracyCheck() {
ACMRandom rnd(ACMRandom::DeterministicSeed());
const int count_test_block = 1000;
    DECLARE_ALIGNED_ARRAY(16, int16_t, in, kNumCoeffs);
    DECLARE_ALIGNED_ARRAY(16, int16_t, coeff, kNumCoeffs);
    DECLARE_ALIGNED_ARRAY(16, uint8_t, dst, kNumCoeffs);
    DECLARE_ALIGNED_ARRAY(16, uint8_t, src, kNumCoeffs);

for (int i = 0; i < count_test_block; ++i) {
double out_r[kNumCoeffs];

// Initialize a test block with input range [-255, 255].
for (int j = 0; j < kNumCoeffs; ++j) {
        src[j] = rnd.Rand8();
        dst[j] = rnd.Rand8();
        in[j] = src[j] - dst[j];
}

reference_16x16_dct_2d(in, out_r);
for (int j = 0; j < kNumCoeffs; ++j)
        coeff[j] = round(out_r[j]);

      REGISTER_STATE_CHECK(RunInvTxfm(coeff, dst, 16));

for (int j = 0; j < kNumCoeffs; ++j) {
const uint32_t diff = dst[j] - src[j];
const uint32_t error = diff * diff;
EXPECT_GE(1u, error)
<< "Error: 16x16 IDCT has error " << error
<< " at index " << j;

}
}
}

   void SetConstantInput(int value) {
     memset(input_, value, kInputBufferSize);
   }

virtual void SetUp() {
UUT_ = GET_PARAM(2);
/* Set up guard blocks for an inner block centered in the outer block */
for (int i = 0; i < kOutputBufferSize; ++i) {
if (IsIndexInBorder(i))
output_[i] = 255;
else
output_[i] = 0;

}

::libvpx_test::ACMRandom prng;
    for (int i = 0; i < kInputBufferSize; ++i)
      input_[i] = prng.Rand8Extremes();
}

bool SeekHead::ParseEntry(
    IMkvReader* pReader,
    long long start,
    long long size_,
    Entry* pEntry)
{
    if (size_ <= 0)
        return false;

    long long pos = start;
    const long long stop = start + size_;

    long len;

    //parse the container for the level-1 element ID

    const long long seekIdId = ReadUInt(pReader, pos, len);
    //seekIdId;

    if (seekIdId != 0x13AB)  //SeekID ID
        return false;

    if ((pos + len) > stop)
        return false;

    pos += len;  //consume SeekID id

    const long long seekIdSize = ReadUInt(pReader, pos, len);

    if (seekIdSize <= 0)
        return false;

    if ((pos + len) > stop)
        return false;

    pos += len;  //consume size of field

    if ((pos + seekIdSize) > stop)
        return false;

    //Note that the SeekId payload really is serialized
    //as a "Matroska integer", not as a plain binary value.
    //In fact, Matroska requires that ID values in the
    //stream exactly match the binary representation as listed
    //in the Matroska specification.
    
    //This parser is more liberal, and permits IDs to have
    //any width.  (This could make the representation in the stream
    //different from what's in the spec, but it doesn't matter here,
    //since we always normalize "Matroska integer" values.)

    pEntry->id = ReadUInt(pReader, pos, len);  //payload

    if (pEntry->id <= 0)
        return false;

    if (len != seekIdSize)
        return false;

    pos += seekIdSize;  //consume SeekID payload

    const long long seekPosId = ReadUInt(pReader, pos, len);

    if (seekPosId != 0x13AC)  //SeekPos ID
        return false;

    if ((pos + len) > stop)
        return false;

    pos += len;  //consume id

    const long long seekPosSize = ReadUInt(pReader, pos, len);

    if (seekPosSize <= 0)
        return false;

    if ((pos + len) > stop)
        return false;

    pos += len;  //consume size

    if ((pos + seekPosSize) > stop)
        return false;

    pEntry->pos = UnserializeUInt(pReader, pos, seekPosSize);

    if (pEntry->pos < 0)
        return false;

    pos += seekPosSize;  //consume payload

    if (pos != stop)
        return false;

    return true;
}

 vpx_codec_err_t DecodeOneFrame() {
 const vpx_codec_err_t res =
        decoder_->DecodeFrame(video_->cxdata(), video_->frame_size());
 CheckDecodedFrames();
 if (res == VPX_CODEC_OK)
      video_->Next();
 return res;
 }

 int FindFreeBufferIndex() {
 int i;
 for (i = 0; i < num_buffers_; ++i) {
 if (!ext_fb_list_[i].in_use)
 break;
 }
 return i;
 }

VideoTrack::VideoTrack(
    Segment* pSegment,
    long long element_start,
    long long element_size) :
    Track(pSegment, element_start, element_size)
{
}

unsigned int SAD(unsigned int max_sad, int block_idx = 0) {
    unsigned int ret;
    const uint8_t* const reference = GetReference(block_idx);
    REGISTER_STATE_CHECK(ret = GET_PARAM(2)(source_data_, source_stride_,
                                            reference, reference_stride_,
                                            max_sad));
    return ret;
  }

const Cluster* Segment::GetFirst() const
{
    if ((m_clusters == NULL) || (m_clusterCount <= 0))
       return &m_eos;

    Cluster* const pCluster = m_clusters[0];
    assert(pCluster);
    return pCluster;
}

const Block::Frame& Block::GetFrame(int idx) const
{
    assert(idx >= 0);
    assert(idx < m_frame_count);
    const Frame& f = m_frames[idx];
    assert(f.pos > 0);
    assert(f.len > 0);
    return f;
}

long mkvparser::UnserializeInt(
    IMkvReader* pReader,
    long long pos,
    long size,
    long long& result)
{
    assert(pReader);
    assert(pos >= 0);
    assert(size > 0);
    assert(size <= 8);

    {
        signed char b;

        const long status = pReader->Read(pos, 1, (unsigned char*)&b);

        if (status < 0)
            return status;

        result = b;

        ++pos;
    }

    for (long i = 1; i < size; ++i)
    {
        unsigned char b;
        const long status = pReader->Read(pos, 1, &b);
        if (status < 0)
            return status;
        result <<= 8;
        result |= b;
        ++pos;
    }
    return 0;  //success
}

int do_not_release_vp9_frame_buffer(void *user_priv,
 vpx_codec_frame_buffer_t *fb) {
 (void)user_priv;
 (void)fb;
 return 0;
}

void CuePoint::Load(IMkvReader* pReader)
{
    //odbgstream os;
    //os << "CuePoint::Load(begin): timecode=" << m_timecode << endl;

    if (m_timecode >= 0)  //already loaded
        return;

    assert(m_track_positions == NULL);
    assert(m_track_positions_count == 0);

    long long pos_ = -m_timecode;
    const long long element_start = pos_;

    long long stop;

    {
        long len;

        const long long id = ReadUInt(pReader, pos_, len);
        assert(id == 0x3B);  //CuePoint ID
        if (id != 0x3B)
            return;

        pos_ += len;  //consume ID

        const long long size = ReadUInt(pReader, pos_, len);
        assert(size >= 0);

        pos_ += len;  //consume Size field
        //pos_ now points to start of payload

        stop = pos_ + size;
}

    const long long element_size = stop - element_start;

    long long pos = pos_;

    //First count number of track positions
    while (pos < stop)
    {
        long len;
        const long long id = ReadUInt(pReader, pos, len);
        assert(id >= 0);  //TODO
        assert((pos + len) <= stop);
        pos += len;  //consume ID
        const long long size = ReadUInt(pReader, pos, len);
        assert(size >= 0);
        assert((pos + len) <= stop);
        pos += len;  //consume Size field
        assert((pos + size) <= stop);
        if (id == 0x33)  //CueTime ID
            m_timecode = UnserializeUInt(pReader, pos, size);
        else if (id == 0x37) //CueTrackPosition(s) ID
            ++m_track_positions_count;
        pos += size;  //consume payload
        assert(pos <= stop);
    }
    assert(m_timecode >= 0);
    assert(m_track_positions_count > 0);
    //os << "CuePoint::Load(cont'd): idpos=" << idpos
    //   << " timecode=" << m_timecode
    //   << endl;
    m_track_positions = new TrackPosition[m_track_positions_count];
    //Now parse track positions
    TrackPosition* p = m_track_positions;
    pos = pos_;
    while (pos < stop)
    {
        long len;
        const long long id = ReadUInt(pReader, pos, len);
        assert(id >= 0);  //TODO
        assert((pos + len) <= stop);
        pos += len;  //consume ID
        const long long size = ReadUInt(pReader, pos, len);
        assert(size >= 0);
        assert((pos + len) <= stop);
        pos += len;  //consume Size field
        assert((pos + size) <= stop);
        if (id == 0x37) //CueTrackPosition(s) ID
        {
            TrackPosition& tp = *p++;
            tp.Parse(pReader, pos, size);
        }
        pos += size;  //consume payload
        assert(pos <= stop);
    }
    assert(size_t(p - m_track_positions) == m_track_positions_count);
    m_element_start = element_start;
    m_element_size = element_size;
}

Cluster::GetEntry(
    const CuePoint& cp,
    const CuePoint::TrackPosition& tp) const
{
    assert(m_pSegment);

#if 0

LoadBlockEntries();

if (m_entries == NULL)
return NULL;

const long long count = m_entries_count;

if (count <= 0)
return NULL;

const long long tc = cp.GetTimeCode();

if ((tp.m_block > 0) && (tp.m_block <= count))
{
const size_t block = static_cast<size_t>(tp.m_block);
const size_t index = block - 1;

const BlockEntry* const pEntry = m_entries[index];
assert(pEntry);
assert(!pEntry->EOS());

const Block* const pBlock = pEntry->GetBlock();
assert(pBlock);

if ((pBlock->GetTrackNumber() == tp.m_track) &&
(pBlock->GetTimeCode(this) == tc))
{
return pEntry;
}
}

const BlockEntry* const* i = m_entries;
const BlockEntry* const* const j = i + count;

while (i != j)
{
#ifdef _DEBUG
const ptrdiff_t idx = i - m_entries;
idx;
#endif

const BlockEntry* const pEntry = *i++;
assert(pEntry);
assert(!pEntry->EOS());

const Block* const pBlock = pEntry->GetBlock();
assert(pBlock);

if (pBlock->GetTrackNumber() != tp.m_track)
continue;

const long long tc_ = pBlock->GetTimeCode(this);
assert(tc_ >= 0);

if (tc_ < tc)
continue;

if (tc_ > tc)
return NULL;

const Tracks* const pTracks = m_pSegment->GetTracks();
assert(pTracks);

const long tn = static_cast<long>(tp.m_track);
const Track* const pTrack = pTracks->GetTrackByNumber(tn);

if (pTrack == NULL)
return NULL;

const long long type = pTrack->GetType();

if (type == 2) //audio
return pEntry;

if (type != 1) //not video
return NULL;

if (!pBlock->IsKey())
return NULL;

return pEntry;
}

return NULL;


#else

    const long long tc = cp.GetTimeCode();

    if (tp.m_block > 0)
    {
        const long block = static_cast<long>(tp.m_block);
        const long index = block - 1;

        while (index >= m_entries_count)
        {
            long long pos;
            long len;

            const long status = Parse(pos, len);

            if (status < 0)  //TODO: can this happen?
                return NULL;

            if (status > 0)  //nothing remains to be parsed
                return NULL;
        }
        const BlockEntry* const pEntry = m_entries[index];
        assert(pEntry);
        assert(!pEntry->EOS());
        const Block* const pBlock = pEntry->GetBlock();
        assert(pBlock);
        if ((pBlock->GetTrackNumber() == tp.m_track) &&
            (pBlock->GetTimeCode(this) == tc))
        {
            return pEntry;
        }
}

    long index = 0;

    for (;;)
    {
        if (index >= m_entries_count)
        {
            long long pos;
            long len;

            const long status = Parse(pos, len);
            if (status < 0)  //TODO: can this happen?
                return NULL;
            if (status > 0)  //nothing remains to be parsed
                return NULL;
            assert(m_entries);
            assert(index < m_entries_count);
        }
        const BlockEntry* const pEntry = m_entries[index];
        assert(pEntry);
        assert(!pEntry->EOS());
        const Block* const pBlock = pEntry->GetBlock();
        assert(pBlock);
        if (pBlock->GetTrackNumber() != tp.m_track)
        {
            ++index;
            continue;
        }
        const long long tc_ = pBlock->GetTimeCode(this);
        if (tc_ < tc)
        {
            ++index;
            continue;
        }
        if (tc_ > tc)
            return NULL;
        const Tracks* const pTracks = m_pSegment->GetTracks();
        assert(pTracks);
        const long tn = static_cast<long>(tp.m_track);
        const Track* const pTrack = pTracks->GetTrackByNumber(tn);
        if (pTrack == NULL)
            return NULL;
        const long long type = pTrack->GetType();
        if (type == 2)  //audio
            return pEntry;
        if (type != 1)  //not video
            return NULL;
        if (!pBlock->IsKey())
            return NULL;
        return pEntry;
}

#endif
}

void Cues::PreloadCuePoint(
    long& cue_points_size,
    long long pos) const
{
    assert(m_count == 0);
    if (m_preload_count >= cue_points_size)
    {
        const long n = (cue_points_size <= 0) ? 2048 : 2*cue_points_size;
        CuePoint** const qq = new CuePoint*[n];
        CuePoint** q = qq;  //beginning of target
        CuePoint** p = m_cue_points;                //beginning of source
        CuePoint** const pp = p + m_preload_count;  //end of source
        while (p != pp)
            *q++ = *p++;
        delete[] m_cue_points;
        m_cue_points = qq;
        cue_points_size = n;
}

    CuePoint* const pCP = new CuePoint(m_preload_count, pos);
    m_cue_points[m_preload_count++] = pCP;
}

static void show_histogram(const struct hist_bucket *bucket,
 int buckets, int total, int scale) {
 const char *pat1, *pat2;
 int i;

 switch ((int)(log(bucket[buckets - 1].high) / log(10)) + 1) {
 case 1:
 case 2:
      pat1 = "%4d %2s: ";
      pat2 = "%4d-%2d: ";
 break;
 case 3:
      pat1 = "%5d %3s: ";
      pat2 = "%5d-%3d: ";
 break;
 case 4:
      pat1 = "%6d %4s: ";
      pat2 = "%6d-%4d: ";
 break;
 case 5:
      pat1 = "%7d %5s: ";
      pat2 = "%7d-%5d: ";
 break;
 case 6:
      pat1 = "%8d %6s: ";
      pat2 = "%8d-%6d: ";
 break;
 case 7:
      pat1 = "%9d %7s: ";
      pat2 = "%9d-%7d: ";
 break;
 default:
      pat1 = "%12d %10s: ";
      pat2 = "%12d-%10d: ";
 break;
 }

 for (i = 0; i < buckets; i++) {
 int len;
 int j;
 float pct;

    pct = (float)(100.0 * bucket[i].count / total);
    len = HIST_BAR_MAX * bucket[i].count / scale;
 if (len < 1)
      len = 1;
    assert(len <= HIST_BAR_MAX);

 if (bucket[i].low == bucket[i].high)
      fprintf(stderr, pat1, bucket[i].low, "");
 else
      fprintf(stderr, pat2, bucket[i].low, bucket[i].high);

 for (j = 0; j < HIST_BAR_MAX; j++)
      fprintf(stderr, j < len ? "=" : " ");
    fprintf(stderr, "\t%5d (%6.2f%%)\n", bucket[i].count, pct);
 }
}

BlockEntry::Kind BlockGroup::GetKind() const
{
    return kBlockGroup;
}

void Cues::Init() const
{
    if (m_cue_points)
        return;

    assert(m_count == 0);
    assert(m_preload_count == 0);

    IMkvReader* const pReader = m_pSegment->m_pReader;

    const long long stop = m_start + m_size;
    long long pos = m_start;

    long cue_points_size = 0;

    while (pos < stop)
    {
        const long long idpos = pos;

        long len;
        const long long id = ReadUInt(pReader, pos, len);
        assert(id >= 0);  //TODO
        assert((pos + len) <= stop);
        pos += len;  //consume ID
        const long long size = ReadUInt(pReader, pos, len);
        assert(size >= 0);
        assert((pos + len) <= stop);
        pos += len;  //consume Size field
        assert((pos + size) <= stop);
        if (id == 0x3B)  //CuePoint ID
            PreloadCuePoint(cue_points_size, idpos);
        pos += size;  //consume payload
        assert(pos <= stop);
    }
}

 virtual void SetUp() {
    fwd_txfm_ = GET_PARAM(0);
    inv_txfm_ = GET_PARAM(1);

     tx_type_  = GET_PARAM(2);
     pitch_    = 4;
     fwd_txfm_ref = fht4x4_ref;
   }

const CuePoint::TrackPosition* CuePoint::Find(const Track* pTrack) const
{
    assert(pTrack);

    const long long n = pTrack->GetNumber();

    const TrackPosition* i = m_track_positions;
    const TrackPosition* const j = i + m_track_positions_count;

    while (i != j)
    {
        const TrackPosition& p = *i++;

        if (p.m_track == n)
            return &p;
    }
    return NULL;  //no matching track number found
}

Chapters::~Chapters()
{
    while (m_editions_count > 0)
    {
        Edition& e = m_editions[--m_editions_count];
        e.Clear();
    }
}

AudioTrack::AudioTrack(
    Segment* pSegment,
    long long element_start,
    long long element_size) :
    Track(pSegment, element_start, element_size)
{
}

 int BorderTop() const { return (kOuterBlockSize - Height()) / 2; }

void Encoder::Flush() {
const vpx_codec_err_t res = vpx_codec_encode(&encoder_, NULL, 0, 0, 0,
deadline_);
  ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();
}

static void write_ivf_file_header(const vpx_codec_enc_cfg_t *const cfg,
 int frame_cnt, FILE *const outfile) {
 char header[32];

  header[0] = 'D';
  header[1] = 'K';
  header[2] = 'I';
  header[3] = 'F';
  mem_put_le16(header + 4, 0); /* version */
  mem_put_le16(header + 6, 32); /* headersize */
  mem_put_le32(header + 8, 0x30395056); /* fourcc (vp9) */
  mem_put_le16(header + 12, cfg->g_w); /* width */
  mem_put_le16(header + 14, cfg->g_h); /* height */
  mem_put_le32(header + 16, cfg->g_timebase.den); /* rate */
  mem_put_le32(header + 20, cfg->g_timebase.num); /* scale */
  mem_put_le32(header + 24, frame_cnt); /* length */
  mem_put_le32(header + 28, 0); /* unused */

 (void)fwrite(header, 1, 32, outfile);
}

   virtual void TearDown() { libvpx_test::ClearSystemState(); }

void RunRoundTripErrorCheck() {
ACMRandom rnd(ACMRandom::DeterministicSeed());

int max_error = 0;
int total_error = 0;
const int count_test_block = 100000;
    DECLARE_ALIGNED_ARRAY(16, int16_t, test_input_block, 64);
    DECLARE_ALIGNED_ARRAY(16, int16_t, test_temp_block, 64);
    DECLARE_ALIGNED_ARRAY(16, uint8_t, dst, 64);
    DECLARE_ALIGNED_ARRAY(16, uint8_t, src, 64);

for (int i = 0; i < count_test_block; ++i) {
      // Initialize a test block with input range [-255, 255].
for (int j = 0; j < 64; ++j) {
        src[j] = rnd.Rand8();
        dst[j] = rnd.Rand8();
        test_input_block[j] = src[j] - dst[j];
}

      REGISTER_STATE_CHECK(
RunFwdTxfm(test_input_block, test_temp_block, pitch_));
for (int j = 0; j < 64; ++j) {
if (test_temp_block[j] > 0) {
test_temp_block[j] += 2;
test_temp_block[j] /= 4;
test_temp_block[j] *= 4;
} else {
test_temp_block[j] -= 2;
test_temp_block[j] /= 4;

test_temp_block[j] *= 4;
}
}
      REGISTER_STATE_CHECK(
          RunInvTxfm(test_temp_block, dst, pitch_));

for (int j = 0; j < 64; ++j) {
const int diff = dst[j] - src[j];
const int error = diff * diff;
if (max_error < error)
max_error = error;
total_error += error;

}
}

    EXPECT_GE(1, max_error)
<< "Error: 8x8 FDCT/IDCT or FHT/IHT has an individual"
<< " roundtrip error > 1";

    EXPECT_GE(count_test_block/5, total_error)
<< "Error: 8x8 FDCT/IDCT or FHT/IHT has average roundtrip "
<< "error > 1/5 per block";
}

 virtual void PSNRPktHook(const vpx_codec_cx_pkt_t *pkt) {
 if (pkt->data.psnr.psnr[0] < psnr_)
      psnr_= pkt->data.psnr.psnr[0];
 }

long Cluster::GetEntryCount() const
{
    return m_entries_count;
}

 virtual void PreEncodeFrameHook(libvpx_test::VideoSource *video,
                                  libvpx_test::Encoder *encoder) {
 if (video->frame() == kStepDownFrame) {
 struct vpx_scaling_mode mode = {VP8E_FOURFIVE, VP8E_THREEFIVE};
      encoder->Control(VP8E_SET_SCALEMODE, &mode);
 }
 if (video->frame() == kStepUpFrame) {
 struct vpx_scaling_mode mode = {VP8E_NORMAL, VP8E_NORMAL};
      encoder->Control(VP8E_SET_SCALEMODE, &mode);
 }
 }

const char* Track::GetCodecNameAsUTF8() const
{
    return m_info.codecNameAsUTF8;
}

const char* Track::GetNameAsUTF8() const
{
    return m_info.nameAsUTF8;
}

Track::Info::~Info()
{
    Clear();
}

 virtual void PreEncodeFrameHook(libvpx_test::VideoSource *video,
                                  libvpx_test::Encoder *encoder) {
 if (video->frame() == 1) {
      encoder->Control(VP9E_SET_TILE_COLUMNS, n_tiles_);
 }
 }

  uint8_t* input() const {
     return input_ + BorderTop() * kOuterBlockSize + BorderLeft();
   }

void fht8x8_ref(const int16_t *in, int16_t *out, int stride, int tx_type) {
   vp9_fht8x8_c(in, out, stride, tx_type);
 }

virtual void SetUp() {
    vp9_worker_init(&worker_);
}

ContentEncoding::~ContentEncoding() {
ContentCompression** comp_i = compression_entries_;
ContentCompression** const comp_j = compression_entries_end_;

while (comp_i != comp_j) {
ContentCompression* const comp = *comp_i++;

delete comp;
}

  delete [] compression_entries_;

ContentEncryption** enc_i = encryption_entries_;
ContentEncryption** const enc_j = encryption_entries_end_;

while (enc_i != enc_j) {
ContentEncryption* const enc = *enc_i++;

delete enc;
}

  delete [] encryption_entries_;
}

  void RunFwdTxfm(const int16_t *in, int16_t *out, int stride) {
     fwd_txfm_(in, out, stride);
   }

ContentEncoding::ContentEncoding()
: compression_entries_(NULL),
compression_entries_end_(NULL),
encryption_entries_(NULL),

encryption_entries_end_(NULL),
encoding_order_(0),
encoding_scope_(1),
      encoding_type_(0) {
}

int SeekHead::GetCount() const
{
    return m_entry_count;
}

 virtual ~IntraPredBase() { libvpx_test::ClearSystemState(); }

static void set_active_map(const vpx_codec_enc_cfg_t *cfg,
vpx_codec_ctx_t *codec) {
unsigned int i;
  vpx_active_map_t map = {0};

map.rows = (cfg->g_h + 15) / 16;
map.cols = (cfg->g_w + 15) / 16;

map.active_map = (uint8_t *)malloc(map.rows * map.cols);
for (i = 0; i < map.rows * map.cols; ++i)
map.active_map[i] = i % 2;

if (vpx_codec_control(codec, VP8E_SET_ACTIVEMAP, &map))
die_codec(codec, "Failed to set active map");

free(map.active_map);
}

   virtual ~CpuSpeedTest() {}

MD5Final(md5byte digest[16], struct MD5Context *ctx) {
 int count = ctx->bytes[0] & 0x3f; /* Number of bytes in ctx->in */
  md5byte *p = (md5byte *)ctx->in + count;

 /* Set the first char of padding to 0x80.  There is always room. */
 *p++ = 0x80;

 /* Bytes of padding needed to make 56 bytes (-8..55) */
  count = 56 - 1 - count;

 if (count < 0) { /* Padding forces an extra block */
    memset(p, 0, count + 8);
    byteSwap(ctx->in, 16);
    MD5Transform(ctx->buf, ctx->in);
    p = (md5byte *)ctx->in;
    count = 56;
 }

  memset(p, 0, count);
  byteSwap(ctx->in, 14);

 /* Append length in bits and transform */
  ctx->in[14] = ctx->bytes[0] << 3;
  ctx->in[15] = ctx->bytes[1] << 3 | ctx->bytes[0] >> 29;
  MD5Transform(ctx->buf, ctx->in);

  byteSwap(ctx->buf, 4);
  memcpy(digest, ctx->buf, 16);
  memset(ctx, 0, sizeof(*ctx)); /* In case it's sensitive */
}

SegmentInfo::~SegmentInfo()
{
    delete[] m_pMuxingAppAsUTF8;
    m_pMuxingAppAsUTF8 = NULL;
    delete[] m_pWritingAppAsUTF8;
    m_pWritingAppAsUTF8 = NULL;
    delete[] m_pTitleAsUTF8;
    m_pTitleAsUTF8 = NULL;
}

  void RunFwdTxfm(const int16_t *in, int16_t *out, int stride) {
     fwd_txfm_(in, out, stride, tx_type_);
   }

bool BlockEntry::EOS() const
{
    return (GetKind() == kBlockEOS);
}

 void SetDroppableFrames(int num, unsigned int *list) {
 if (num > kMaxDroppableFrames)
      num = kMaxDroppableFrames;
 else if (num < 0)
      num = 0;
    droppable_nframes_ = num;
 for (unsigned int i = 0; i < droppable_nframes_; ++i)
      droppable_frames_[i] = list[i];
 }

BlockGroup::BlockGroup(
    Cluster* pCluster,
    long idx,
    long long block_start,
    long long block_size,
    long long prev,
    long long next,
    long long duration,
    long long discard_padding) :
    BlockEntry(pCluster, idx),
    m_block(block_start, block_size, discard_padding),
    m_prev(prev),
    m_next(next),
    m_duration(duration)
{
}

void Chapters::Edition::Clear()
{
    while (m_atoms_count > 0)
    {
        Atom& a = m_atoms[--m_atoms_count];
        a.Clear();
}

    delete[] m_atoms;
    m_atoms = NULL;

    m_atoms_size = 0;
}

   virtual ~FwdTrans8x8HT() {}

long Segment::LoadCluster(
    long long& pos,
    long& len)
{
    for (;;)
    {
        const long result = DoLoadCluster(pos, len);

        if (result <= 1)
            return result;
}
}

void RunMemCheck() {
ACMRandom rnd(ACMRandom::DeterministicSeed());
const int count_test_block = 1000;
    DECLARE_ALIGNED_ARRAY(16, int16_t, input_block, kNumCoeffs);
    DECLARE_ALIGNED_ARRAY(16, int16_t, input_extreme_block, kNumCoeffs);
    DECLARE_ALIGNED_ARRAY(16, int16_t, output_ref_block, kNumCoeffs);
    DECLARE_ALIGNED_ARRAY(16, int16_t, output_block, kNumCoeffs);

for (int i = 0; i < count_test_block; ++i) {
      // Initialize a test block with input range [-255, 255].
for (int j = 0; j < kNumCoeffs; ++j) {
        input_block[j] = rnd.Rand8() - rnd.Rand8();
        input_extreme_block[j] = rnd.Rand8() % 2 ? 255 : -255;
}
      if (i == 0)
for (int j = 0; j < kNumCoeffs; ++j)
          input_extreme_block[j] = 255;
      if (i == 1)
for (int j = 0; j < kNumCoeffs; ++j)
          input_extreme_block[j] = -255;

fwd_txfm_ref(input_extreme_block, output_ref_block, pitch_, tx_type_);
      REGISTER_STATE_CHECK(RunFwdTxfm(input_extreme_block,
                                      output_block, pitch_));

// The minimum quant value is 4.
for (int j = 0; j < kNumCoeffs; ++j) {
EXPECT_EQ(output_block[j], output_ref_block[j]);
        EXPECT_GE(4 * DCT_MAX_VALUE, abs(output_block[j]))
<< "Error: 16x16 FDCT has coefficient larger than 4*DCT_MAX_VALUE";
}
}
}

 ResizeInternalTest()
 : ResizeTest(),
        frame0_psnr_(0.0),
        outfile_(NULL),
        out_frames_(0) {}

 ActiveMapTest() : EncoderTest(GET_PARAM(0)) {}

void CheckSADs() {
unsigned int reference_sad, exp_sad[4];

SADs(exp_sad);
    for (int block = 0; block < 4; block++) {
      reference_sad = ReferenceSAD(UINT_MAX, block);

      EXPECT_EQ(exp_sad[block], reference_sad) << "block " << block;
}
}

   virtual ~PartialIDctTest() {}

void Track::Info::Clear()
{
    delete[] nameAsUTF8;
    nameAsUTF8 = NULL;

    delete[] language;
    language = NULL;

    delete[] codecId;
    codecId = NULL;
    delete[] codecPrivate;
    codecPrivate = NULL;
    codecPrivateSize = 0;
    delete[] codecNameAsUTF8;
    codecNameAsUTF8 = NULL;
}

 static int ReleaseVP9FrameBuffer(void *user_priv,
 vpx_codec_frame_buffer_t *fb) {
 ExternalFrameBufferMD5Test *const md5Test =
 reinterpret_cast<ExternalFrameBufferMD5Test*>(user_priv);
 return md5Test->fb_list_.ReturnFrameBuffer(fb);
 }

  void RunInvTxfm(const int16_t *out, uint8_t *dst, int stride) {
     inv_txfm_(out, dst, stride, tx_type_);
   }

void VarianceTest<VarianceFunctionType>::RefTest() {
for (int i = 0; i < 10; ++i) {
for (int j = 0; j < block_size_; j++) {
      src_[j] = rnd.Rand8();
      ref_[j] = rnd.Rand8();
}
unsigned int sse1, sse2;
unsigned int var1;
    REGISTER_STATE_CHECK(var1 = variance_(src_, width_, ref_, width_, &sse1));
const unsigned int var2 = variance_ref(src_, ref_, log2width_,
                                           log2height_, &sse2);
EXPECT_EQ(sse1, sse2);
EXPECT_EQ(var1, var2);
}
}

long Chapters::Edition::ParseAtom(
    IMkvReader* pReader,
    long long pos,
    long long size)
{
    if (!ExpandAtomsArray())
        return -1;

    Atom& a = m_atoms[m_atoms_count++];
    a.Init();

    return a.Parse(pReader, pos, size);
}

virtual void PreEncodeFrameHook(libvpx_test::VideoSource *video) {
frame_flags_ &= ~(VP8_EFLAG_NO_UPD_LAST |
VP8_EFLAG_NO_UPD_GF |
VP8_EFLAG_NO_UPD_ARF);
    if (droppable_nframes_ > 0 &&
        (cfg_.g_pass == VPX_RC_LAST_PASS || cfg_.g_pass == VPX_RC_ONE_PASS)) {
for (unsigned int i = 0; i < droppable_nframes_; ++i) {
if (droppable_frames_[i] == video->frame()) {
          std::cout << "             Encoding droppable frame: "
<< droppable_frames_[i] << "\n";
          frame_flags_ |= (VP8_EFLAG_NO_UPD_LAST |
                           VP8_EFLAG_NO_UPD_GF |
                           VP8_EFLAG_NO_UPD_ARF);
          return;
}
}
}
}

bool Cues::LoadCuePoint() const
{
    //odbgstream os;
    //os << "Cues::LoadCuePoint" << endl;
    const long long stop = m_start + m_size;
    if (m_pos >= stop)
        return false;  //nothing else to do
    Init();
    IMkvReader* const pReader = m_pSegment->m_pReader;
    while (m_pos < stop)
    {
        const long long idpos = m_pos;
        long len;
        const long long id = ReadUInt(pReader, m_pos, len);
        assert(id >= 0);  //TODO
        assert((m_pos + len) <= stop);
        m_pos += len;  //consume ID
        const long long size = ReadUInt(pReader, m_pos, len);
        assert(size >= 0);
        assert((m_pos + len) <= stop);
        m_pos += len;  //consume Size field
        assert((m_pos + size) <= stop);
        if (id != 0x3B)  //CuePoint ID
        {
            m_pos += size;  //consume payload
            assert(m_pos <= stop);
            continue;
        }
        assert(m_preload_count > 0);
        CuePoint* const pCP = m_cue_points[m_count];
        assert(pCP);
        assert((pCP->GetTimeCode() >= 0) || (-pCP->GetTimeCode() == idpos));
        if (pCP->GetTimeCode() < 0 && (-pCP->GetTimeCode() != idpos))
            return false;
        pCP->Load(pReader);
        ++m_count;
        --m_preload_count;
        m_pos += size;  //consume payload
        assert(m_pos <= stop);
        return true;  //yes, we loaded a cue point
    }
    //return (m_pos < stop);
    return false;  //no, we did not load a cue point
}

struct vpx_rational arg_parse_rational(const struct arg *arg) {
 long int             rawval;
 char *endptr;
 struct vpx_rational  rat;

 /* parse numerator */
  rawval = strtol(arg->val, &endptr, 10);

 if (arg->val[0] != '\0' && endptr[0] == '/') {
 if (rawval >= INT_MIN && rawval <= INT_MAX)
      rat.num = rawval;
 else die("Option %s: Value %ld out of range for signed int\n",
               arg->name, rawval);
 } else die("Option %s: Expected / at '%c'\n", arg->name, *endptr);

 /* parse denominator */
  rawval = strtol(endptr + 1, &endptr, 10);

 if (arg->val[0] != '\0' && endptr[0] == '\0') {
 if (rawval >= INT_MIN && rawval <= INT_MAX)
      rat.den = rawval;
 else die("Option %s: Value %ld out of range for signed int\n",
               arg->name, rawval);
 } else die("Option %s: Invalid character '%c'\n", arg->name, *endptr);

 return rat;
}

void Chapters::Display::Init()
{
    m_string = NULL;
    m_language = NULL;
    m_country = NULL;
}

long long Chapters::Atom::GetStartTimecode() const
{
    return m_start_timecode;
}

void butterfly_16x16_dct_1d(double input[16], double output[16]) {
 double step[16];
 double intermediate[16];
 double temp1, temp2;

  step[ 0] = input[0] + input[15];
  step[ 1] = input[1] + input[14];
  step[ 2] = input[2] + input[13];
  step[ 3] = input[3] + input[12];
  step[ 4] = input[4] + input[11];
  step[ 5] = input[5] + input[10];
  step[ 6] = input[6] + input[ 9];
  step[ 7] = input[7] + input[ 8];
  step[ 8] = input[7] - input[ 8];
  step[ 9] = input[6] - input[ 9];
  step[10] = input[5] - input[10];
  step[11] = input[4] - input[11];
  step[12] = input[3] - input[12];
  step[13] = input[2] - input[13];
  step[14] = input[1] - input[14];
  step[15] = input[0] - input[15];

  output[0] = step[0] + step[7];
  output[1] = step[1] + step[6];
  output[2] = step[2] + step[5];
  output[3] = step[3] + step[4];
  output[4] = step[3] - step[4];
  output[5] = step[2] - step[5];
  output[6] = step[1] - step[6];
  output[7] = step[0] - step[7];

  temp1 = step[ 8] * C7;
  temp2 = step[15] * C9;
  output[ 8] = temp1 + temp2;

  temp1 = step[ 9] * C11;
  temp2 = step[14] * C5;
  output[ 9] = temp1 - temp2;

  temp1 = step[10] * C3;
  temp2 = step[13] * C13;
  output[10] = temp1 + temp2;

  temp1 = step[11] * C15;
  temp2 = step[12] * C1;
  output[11] = temp1 - temp2;

  temp1 = step[11] * C1;
  temp2 = step[12] * C15;
  output[12] = temp2 + temp1;

  temp1 = step[10] * C13;
  temp2 = step[13] * C3;
  output[13] = temp2 - temp1;

  temp1 = step[ 9] * C5;
  temp2 = step[14] * C11;
  output[14] = temp2 + temp1;

  temp1 = step[ 8] * C9;
  temp2 = step[15] * C7;
  output[15] = temp2 - temp1;

  step[ 0] = output[0] + output[3];
  step[ 1] = output[1] + output[2];
  step[ 2] = output[1] - output[2];
  step[ 3] = output[0] - output[3];

  temp1 = output[4] * C14;
  temp2 = output[7] * C2;
  step[ 4] = temp1 + temp2;

  temp1 = output[5] * C10;
  temp2 = output[6] * C6;
  step[ 5] = temp1 + temp2;

  temp1 = output[5] * C6;
  temp2 = output[6] * C10;
  step[ 6] = temp2 - temp1;

  temp1 = output[4] * C2;
  temp2 = output[7] * C14;
  step[ 7] = temp2 - temp1;

  step[ 8] = output[ 8] + output[11];
  step[ 9] = output[ 9] + output[10];
  step[10] = output[ 9] - output[10];
  step[11] = output[ 8] - output[11];

  step[12] = output[12] + output[15];
  step[13] = output[13] + output[14];
  step[14] = output[13] - output[14];
  step[15] = output[12] - output[15];

  output[ 0] = (step[ 0] + step[ 1]);
  output[ 8] = (step[ 0] - step[ 1]);

  temp1 = step[2] * C12;
  temp2 = step[3] * C4;
  temp1 = temp1 + temp2;
  output[ 4] = 2*(temp1 * C8);

  temp1 = step[2] * C4;
  temp2 = step[3] * C12;
  temp1 = temp2 - temp1;
  output[12] = 2 * (temp1 * C8);

  output[ 2] = 2 * ((step[4] + step[ 5]) * C8);
  output[14] = 2 * ((step[7] - step[ 6]) * C8);

  temp1 = step[4] - step[5];
  temp2 = step[6] + step[7];
  output[ 6] = (temp1 + temp2);
  output[10] = (temp1 - temp2);

  intermediate[8] = step[8] + step[14];
  intermediate[9] = step[9] + step[15];

  temp1 = intermediate[8] * C12;
  temp2 = intermediate[9] * C4;
  temp1 = temp1 - temp2;
  output[3] = 2 * (temp1 * C8);

  temp1 = intermediate[8] * C4;
  temp2 = intermediate[9] * C12;
  temp1 = temp2 + temp1;
  output[13] = 2 * (temp1 * C8);

  output[ 9] = 2 * ((step[10] + step[11]) * C8);

  intermediate[11] = step[10] - step[11];
  intermediate[12] = step[12] + step[13];
  intermediate[13] = step[12] - step[13];
  intermediate[14] = step[ 8] - step[14];
  intermediate[15] = step[ 9] - step[15];

  output[15] = (intermediate[11] + intermediate[12]);
  output[ 1] = -(intermediate[11] - intermediate[12]);

  output[ 7] = 2 * (intermediate[13] * C8);

  temp1 = intermediate[14] * C12;
  temp2 = intermediate[15] * C4;
  temp1 = temp1 - temp2;
  output[11] = -2 * (temp1 * C8);

  temp1 = intermediate[14] * C4;
  temp2 = intermediate[15] * C12;
  temp1 = temp2 + temp1;
  output[ 5] = 2 * (temp1 * C8);
}

void test_decrypt_cb(void *decrypt_state, const uint8_t *input,
 uint8_t *output, int count) {
 const size_t offset = input - reinterpret_cast<uint8_t*>(decrypt_state);
 for (int i = 0; i < count; i++) {
    output[i] = input[i] ^ secret_key[(offset + i) & 15];
 }
}

void RunAccuracyCheck() {
ACMRandom rnd(ACMRandom::DeterministicSeed());
uint32_t max_error = 0;
int64_t total_error = 0;
const int count_test_block = 10000;
for (int i = 0; i < count_test_block; ++i) {
      DECLARE_ALIGNED_ARRAY(16, int16_t, test_input_block, kNumCoeffs);
      DECLARE_ALIGNED_ARRAY(16, int16_t, test_temp_block, kNumCoeffs);
      DECLARE_ALIGNED_ARRAY(16, uint8_t, dst, kNumCoeffs);
      DECLARE_ALIGNED_ARRAY(16, uint8_t, src, kNumCoeffs);

// Initialize a test block with input range [-255, 255].
for (int j = 0; j < kNumCoeffs; ++j) {
        src[j] = rnd.Rand8();
        dst[j] = rnd.Rand8();
        test_input_block[j] = src[j] - dst[j];
}

      REGISTER_STATE_CHECK(RunFwdTxfm(test_input_block,
                                      test_temp_block, pitch_));
      REGISTER_STATE_CHECK(RunInvTxfm(test_temp_block, dst, pitch_));

for (int j = 0; j < kNumCoeffs; ++j) {
const uint32_t diff = dst[j] - src[j];
const uint32_t error = diff * diff;
if (max_error < error)
max_error = error;
total_error += error;

}
}

    EXPECT_GE(1u, max_error)
        << "Error: 4x4 FHT/IHT has an individual round trip error > 1";

    EXPECT_GE(count_test_block , total_error)
        << "Error: 4x4 FHT/IHT has average round trip error > 1 per block";
}

 virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {
 vpx_codec_pts_t duration = pkt->data.frame.pts - last_pts_;

 if (last_pts_ == 0)
      duration = 1;

    bits_in_buffer_model_ += static_cast<int64_t>(
        duration * timebase_ * cfg_.rc_target_bitrate * 1000);

 /* Test the buffer model here before subtracting the frame. Do so because
     * the way the leaky bucket model works in libvpx is to allow the buffer to
     * empty - and then stop showing frames until we've got enough bits to
     * show one. As noted in comment below (issue 495), this does not currently
     * apply to key frames. For now exclude key frames in condition below. */
 const bool key_frame = (pkt->data.frame.flags & VPX_FRAME_IS_KEY)
 ? true: false;
 if (!key_frame) {
      ASSERT_GE(bits_in_buffer_model_, 0) << "Buffer Underrun at frame "
 << pkt->data.frame.pts;
 }

 const size_t frame_size_in_bits = pkt->data.frame.sz * 8;

    bits_in_buffer_model_ -= frame_size_in_bits;

    bits_total_ += frame_size_in_bits;

 if (!first_drop_ && duration > 1)
      first_drop_ = last_pts_ + 1;

    last_pts_ = pkt->data.frame.pts;

    bits_in_last_frame_ = frame_size_in_bits;

 ++frame_number_;
 }

void RunExtremalCheck() {

ACMRandom rnd(ACMRandom::DeterministicSeed());
int max_error = 0;
int total_error = 0;
const int count_test_block = 100000;
    DECLARE_ALIGNED_ARRAY(16, int16_t, test_input_block, 64);
    DECLARE_ALIGNED_ARRAY(16, int16_t, test_temp_block, 64);
    DECLARE_ALIGNED_ARRAY(16, uint8_t, dst, 64);
    DECLARE_ALIGNED_ARRAY(16, uint8_t, src, 64);

for (int i = 0; i < count_test_block; ++i) {
      // Initialize a test block with input range [-255, 255].
for (int j = 0; j < 64; ++j) {
        src[j] = rnd.Rand8() % 2 ? 255 : 0;
        dst[j] = src[j] > 0 ? 0 : 255;
        test_input_block[j] = src[j] - dst[j];
}

      REGISTER_STATE_CHECK(
RunFwdTxfm(test_input_block, test_temp_block, pitch_));
      REGISTER_STATE_CHECK(
          RunInvTxfm(test_temp_block, dst, pitch_));

for (int j = 0; j < 64; ++j) {
const int diff = dst[j] - src[j];
const int error = diff * diff;
if (max_error < error)
max_error = error;
total_error += error;
}

      EXPECT_GE(1, max_error)
<< "Error: Extremal 8x8 FDCT/IDCT or FHT/IHT has"
<< "an individual roundtrip error > 1";

      EXPECT_GE(count_test_block/5, total_error)
<< "Error: Extremal 8x8 FDCT/IDCT or FHT/IHT has average"
<< " roundtrip error > 1/5 per block";
}
}

 virtual void SetUp() {

     fwd_txfm_ = GET_PARAM(0);
     inv_txfm_ = GET_PARAM(1);
     tx_type_  = GET_PARAM(2);
     pitch_    = 16;
     fwd_txfm_ref = fdct16x16_ref;
   }

virtual void SetUp() {
    const tuple<int, int, VarianceFunctionType>& params = this->GetParam();
log2width_  = get<0>(params);
width_ = 1 << log2width_;
log2height_ = get<1>(params);
height_ = 1 << log2height_;
variance_ = get<2>(params);

    rnd(ACMRandom::DeterministicSeed());
block_size_ = width_ * height_;
    src_ = new uint8_t[block_size_];
    ref_ = new uint8_t[block_size_];
ASSERT_TRUE(src_ != NULL);
ASSERT_TRUE(ref_ != NULL);
}

  void RunFwdTxfm(int16_t *in, int16_t *out, int stride) {
     fwd_txfm_(in, out, stride, tx_type_);
   }

const Cluster* Segment::GetNext(const Cluster* pCurr)
{
    assert(pCurr);
    assert(pCurr != &m_eos);
    assert(m_clusters);

    long idx =  pCurr->m_index;

    if (idx >= 0)
    {
        assert(m_clusterCount > 0);
        assert(idx < m_clusterCount);
        assert(pCurr == m_clusters[idx]);

        ++idx;
        if (idx >= m_clusterCount)
            return &m_eos;  //caller will LoadCluster as desired
        Cluster* const pNext = m_clusters[idx];
        assert(pNext);
        assert(pNext->m_index >= 0);
        assert(pNext->m_index == idx);
        return pNext;
    }
    assert(m_clusterPreloadCount > 0);
    long long pos = pCurr->m_element_start;
    assert(m_size >= 0);  //TODO
    const long long stop = m_start + m_size;  //end of segment
    {
        long len;
        long long result = GetUIntLength(m_pReader, pos, len);
        assert(result == 0);
        assert((pos + len) <= stop);  //TODO
        if (result != 0)
            return NULL;
        const long long id = ReadUInt(m_pReader, pos, len);
        assert(id == 0x0F43B675);  //Cluster ID
        if (id != 0x0F43B675)
            return NULL;
        pos += len;  //consume ID
        //Read Size
        result = GetUIntLength(m_pReader, pos, len);
        assert(result == 0);  //TODO
        assert((pos + len) <= stop);  //TODO
        const long long size = ReadUInt(m_pReader, pos, len);
        assert(size > 0);  //TODO
        //assert((pCurr->m_size <= 0) || (pCurr->m_size == size));
        pos += len;  //consume length of size of element
        assert((pos + size) <= stop);  //TODO
        //Pos now points to start of payload
        pos += size;  //consume payload
    }
    long long off_next = 0;
    while (pos < stop)
    {
        long len;
        long long result = GetUIntLength(m_pReader, pos, len);
        assert(result == 0);
        assert((pos + len) <= stop);  //TODO
        if (result != 0)
            return NULL;
        const long long idpos = pos;  //pos of next (potential) cluster
        const long long id = ReadUInt(m_pReader, idpos, len);
        assert(id > 0);  //TODO
        pos += len;  //consume ID
        //Read Size
        result = GetUIntLength(m_pReader, pos, len);
        assert(result == 0);  //TODO
        assert((pos + len) <= stop);  //TODO
        const long long size = ReadUInt(m_pReader, pos, len);
        assert(size >= 0);  //TODO
        pos += len;  //consume length of size of element
        assert((pos + size) <= stop);  //TODO
        //Pos now points to start of payload
        if (size == 0)  //weird
            continue;
        if (id == 0x0F43B675)  //Cluster ID
        {
            const long long off_next_ = idpos - m_start;
            long long pos_;
            long len_;
            const long status = Cluster::HasBlockEntries(
                                    this,
                                    off_next_,
                                    pos_,
                                    len_);
            assert(status >= 0);
            if (status > 0)
            {
                off_next = off_next_;
                break;
            }
        }
        pos += size;  //consume payload
    }
    if (off_next <= 0)
        return 0;
    Cluster** const ii = m_clusters + m_clusterCount;
    Cluster** i = ii;
    Cluster** const jj = ii + m_clusterPreloadCount;
    Cluster** j = jj;
    while (i < j)
    {
        //INVARIANT:
        //[0, i) < pos_next
        //[i, j) ?
        //[j, jj)  > pos_next
        Cluster** const k = i + (j - i) / 2;
        assert(k < jj);
        Cluster* const pNext = *k;
        assert(pNext);
        assert(pNext->m_index < 0);
        //const long long pos_ = pNext->m_pos;
        //assert(pos_);
        //pos = pos_ * ((pos_ < 0) ? -1 : 1);
        pos = pNext->GetPosition();
        if (pos < off_next)
            i = k + 1;
        else if (pos > off_next)
            j = k;
        else
            return pNext;
    }
    assert(i == j);
    Cluster* const pNext = Cluster::Create(this,
                                          -1,
                                          off_next);
assert(pNext);
    const ptrdiff_t idx_next = i - m_clusters;  //insertion position
    PreloadCluster(pNext, idx_next);
    assert(m_clusters);
    assert(idx_next < m_clusterSize);
    assert(m_clusters[idx_next] == pNext);

return pNext;
}

   virtual ~Trans4x4TestBase() {}

 BordersTest() : EncoderTest(GET_PARAM(0)) {}
