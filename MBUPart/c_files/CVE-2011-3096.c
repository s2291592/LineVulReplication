void OmniboxPopupViewGtk::PaintUpdatesNow() {
  GdkWindow* gdk_window = gtk_widget_get_window(window_);
  gdk_window_process_updates(gdk_window, FALSE);
}

void OmniboxPopupViewGtk::Hide() {
  gtk_widget_hide(window_);
  opened_ = false;
}

void OmniboxPopupViewGtk::Show(size_t num_results) {
  gint origin_x, origin_y;
  GdkWindow* gdk_window = gtk_widget_get_window(location_bar_);
  gdk_window_get_origin(gdk_window, &origin_x, &origin_y);
  GtkAllocation allocation;
  gtk_widget_get_allocation(location_bar_, &allocation);

  int horizontal_offset = 1;
  gtk_window_move(GTK_WINDOW(window_),
      origin_x + allocation.x - kBorderThickness + horizontal_offset,
      origin_y + allocation.y + allocation.height - kBorderThickness - 1 +
          kVerticalOffset);
  gtk_widget_set_size_request(window_,
      allocation.width + (kBorderThickness * 2) - (horizontal_offset * 2),
      (num_results * kHeightPerResult) + (kBorderThickness * 2));
  gtk_widget_show(window_);
  StackWindow();
  opened_ = true;
}

void OmniboxPopupViewGtk::GetVisibleMatchForInput(
    size_t index,
    const AutocompleteMatch** match,
    bool* is_selected_keyword) {
  const AutocompleteResult& result = model_->result();

  if (result.match_at(index).associated_keyword.get() &&
      model_->selected_line() == index &&
      model_->selected_line_state() == AutocompletePopupModel::KEYWORD) {
    *match = result.match_at(index).associated_keyword.get();
    *is_selected_keyword = true;
    return;
  }

  *match = &result.match_at(index);
  *is_selected_keyword = false;
}

size_t OmniboxPopupViewGtk::LineFromY(int y) {
  size_t line = std::max(y - kBorderThickness, 0) / kHeightPerResult;
  return std::min(line, model_->result().size() - 1);
}

void DrawFullImage(cairo_t* cr, GtkWidget* widget, const gfx::Image* image,
                   gint dest_x, gint dest_y) {
  gfx::CairoCachedSurface* surface = image->ToCairo();
  surface->SetSource(cr, widget, dest_x, dest_y);
  cairo_pattern_set_extend(cairo_get_source(cr), CAIRO_EXTEND_REPEAT);
  cairo_rectangle(cr, dest_x, dest_y, surface->Width(), surface->Height());
  cairo_fill(cr);
}

size_t GetUTF8Offset(const string16& text, size_t text_offset) {
  return UTF16ToUTF8(text.substr(0, text_offset)).length();
}

OmniboxPopupViewGtk::OmniboxPopupViewGtk(const gfx::Font& font,
OmniboxView* omnibox_view,
AutocompleteEditModel* edit_model,
GtkWidget* location_bar)
    : model_(new AutocompletePopupModel(this, edit_model)),
omnibox_view_(omnibox_view),
location_bar_(location_bar),
window_(gtk_window_new(GTK_WINDOW_POPUP)),
layout_(NULL),
theme_service_(ThemeServiceGtk::GetFrom(edit_model->profile())),
font_(font.DeriveFont(kEditFontAdjust)),
ignore_mouse_drag_(false),
opened_(false) {
gtk_widget_set_can_focus(window_, FALSE);
// Don't allow the window to be resized.  This also forces the window to
// shrink down to the size of its child contents.
gtk_window_set_resizable(GTK_WINDOW(window_), FALSE);
gtk_widget_set_app_paintable(window_, TRUE);
// Have GTK double buffer around the expose signal.
gtk_widget_set_double_buffered(window_, TRUE);

// Cache the layout so we don't have to create it for every expose.  If we
// were a real widget we should handle changing directions, but we're not
// doing RTL or anything yet, so it shouldn't be important now.
layout_ = gtk_widget_create_pango_layout(window_, NULL);
// We don't want the layout of search results depending on their language.
pango_layout_set_auto_dir(layout_, FALSE);
// We always ellipsize when drawing our text runs.
pango_layout_set_ellipsize(layout_, PANGO_ELLIPSIZE_END);

gtk_widget_add_events(window_, GDK_BUTTON_MOTION_MASK |
GDK_POINTER_MOTION_MASK |
GDK_BUTTON_PRESS_MASK |
GDK_BUTTON_RELEASE_MASK);
  g_signal_connect(window_, "motion-notify-event",
                   G_CALLBACK(HandleMotionThunk), this);
  g_signal_connect(window_, "button-press-event",
                   G_CALLBACK(HandleButtonPressThunk), this);
  g_signal_connect(window_, "button-release-event",
                   G_CALLBACK(HandleButtonReleaseThunk), this);
  g_signal_connect(window_, "expose-event",
                   G_CALLBACK(HandleExposeThunk), this);

registrar_.Add(this,
chrome::NOTIFICATION_BROWSER_THEME_CHANGED,
content::Source<ThemeService>(theme_service_));
theme_service_->InitThemesFor(this);

// TODO(erg): There appears to be a bug somewhere in something which shows
// itself when we're in NX. Previously, we called
// gtk_util::ActAsRoundedWindow() to make this popup have rounded
// corners. This worked on the standard xorg server (both locally and
// remotely), but broke over NX. My current hypothesis is that it can't
// handle shaping top-level windows during an expose event, but I'm not sure
// how else to get accurate shaping information.
//
// r25080 (the original patch that added rounded corners here) should
// eventually be cherry picked once I know what's going
// on. http://crbug.com/22015.
}

gboolean OmniboxPopupViewGtk::HandleExpose(GtkWidget* widget,
                                           GdkEventExpose* event) {
  bool ltr = !base::i18n::IsRTL();
  const AutocompleteResult& result = model_->result();

  gfx::Rect window_rect = GetWindowRect(event->window);
  gfx::Rect damage_rect = gfx::Rect(event->area);
  if (window_rect.width() < (kIconAreaWidth * 3))
    return TRUE;

  cairo_t* cr = gdk_cairo_create(gtk_widget_get_window(widget));
  gdk_cairo_rectangle(cr, &event->area);
  cairo_clip(cr);

  COMPILE_ASSERT(kBorderThickness == 1, border_1px_implied);
  gdk_cairo_set_source_color(cr, &border_color_);
  cairo_rectangle(cr, 0, 0, window_rect.width(), window_rect.height());
  cairo_stroke(cr);

  pango_layout_set_height(layout_, kHeightPerResult * PANGO_SCALE);

  for (size_t i = 0; i < result.size(); ++i) {
    gfx::Rect line_rect = GetRectForLine(i, window_rect.width());
    if (!line_rect.Intersects(damage_rect))
      continue;

    const AutocompleteMatch* match = NULL;
    bool is_selected_keyword = false;
    GetVisibleMatchForInput(i, &match, &is_selected_keyword);
    bool is_selected = (model_->selected_line() == i);
    bool is_hovered = (model_->hovered_line() == i);
    if (is_selected || is_hovered) {
      gdk_cairo_set_source_color(cr, is_selected ? &selected_background_color_ :
                                 &hovered_background_color_);
      cairo_rectangle(cr, line_rect.x(), line_rect.y(),
                      line_rect.width(), line_rect.height());
      cairo_fill(cr);
    }

    int icon_start_x = ltr ? kIconLeftPadding :
        (line_rect.width() - kIconLeftPadding - kIconWidth);
    DrawFullImage(cr, widget,
                  IconForMatch(*match, is_selected, is_selected_keyword),
                  icon_start_x, line_rect.y() + kIconTopPadding);

    bool has_description = !match->description.empty();
    int text_width = window_rect.width() - (kIconAreaWidth + kRightPadding);
    int allocated_content_width = has_description ?
        static_cast<int>(text_width * kContentWidthPercentage) : text_width;
    pango_layout_set_width(layout_, allocated_content_width * PANGO_SCALE);

    SetupLayoutForMatch(layout_, match->contents, match->contents_class,
                        is_selected ? &selected_content_text_color_ :
                            &content_text_color_,
                        is_selected ? &selected_content_dim_text_color_ :
                            &content_dim_text_color_,
                        is_selected ? &url_selected_text_color_ :
                            &url_text_color_,
                        std::string());

    int actual_content_width, actual_content_height;
    pango_layout_get_size(layout_,
        &actual_content_width, &actual_content_height);
    actual_content_width /= PANGO_SCALE;
    actual_content_height /= PANGO_SCALE;

    int content_y = std::max(line_rect.y(),
        line_rect.y() + ((kHeightPerResult - actual_content_height) / 2));

    cairo_save(cr);
    cairo_move_to(cr,
                  ltr ? kIconAreaWidth :
                        (text_width - actual_content_width),
                  content_y);
    pango_cairo_show_layout(cr, layout_);
    cairo_restore(cr);

    if (has_description) {
      pango_layout_set_width(layout_,
          (text_width - actual_content_width) * PANGO_SCALE);

      SetupLayoutForMatch(layout_, match->description, match->description_class,
                          is_selected ? &selected_content_dim_text_color_ :
                              &content_dim_text_color_,
                          is_selected ? &selected_content_dim_text_color_ :
                              &content_dim_text_color_,
                          is_selected ? &url_selected_text_color_ :
                              &url_text_color_,
                          std::string(" - "));
      gint actual_description_width;
      pango_layout_get_size(layout_, &actual_description_width, NULL);

      cairo_save(cr);
      cairo_move_to(cr, ltr ?
                    (kIconAreaWidth + actual_content_width) :
                    (text_width - actual_content_width -
                     (actual_description_width / PANGO_SCALE)),
                    content_y);
      pango_cairo_show_layout(cr, layout_);
      cairo_restore(cr);
    }

    if (match->associated_keyword.get()) {
      icon_start_x = ltr ? (line_rect.width() - kIconLeftPadding - kIconWidth) :
          kIconLeftPadding;
      DrawFullImage(cr, widget,
                    theme_service_->GetImageNamed(
                        is_selected ? IDR_OMNIBOX_TTS_DARK : IDR_OMNIBOX_TTS),
                    icon_start_x, line_rect.y() + kIconTopPadding);
    }
  }

  cairo_destroy(cr);
  return TRUE;
}

gboolean OmniboxPopupViewGtk::HandleMotion(GtkWidget* widget,
                                           GdkEventMotion* event) {
  size_t line = LineFromY(static_cast<int>(event->y));
  model_->SetHoveredLine(line);
  if (!ignore_mouse_drag_ && (event->state & GDK_BUTTON1_MASK))
    model_->SetSelectedLine(line, false, false);
  return TRUE;
}

gboolean OmniboxPopupViewGtk::HandleButtonRelease(GtkWidget* widget,
                                                  GdkEventButton* event) {
  if (ignore_mouse_drag_) {
    ignore_mouse_drag_ = false;
    return TRUE;
  }

  size_t line = LineFromY(static_cast<int>(event->y));
  switch (event->button) {
    case 1:  // Left click.
      AcceptLine(line, CURRENT_TAB);
      break;
    case 2:  // Middle click.
      AcceptLine(line, NEW_BACKGROUND_TAB);
      break;
    default:
      break;
  }
  return TRUE;
}

const gfx::Image* OmniboxPopupViewGtk::IconForMatch(
    const AutocompleteMatch& match,
    bool selected,
    bool is_selected_keyword) {
  const SkBitmap* bitmap = model_->GetIconIfExtensionMatch(match);
  if (bitmap) {
    if (!ContainsKey(images_, bitmap)) {
      images_[bitmap] = new gfx::Image(gfx::GdkPixbufFromSkBitmap(bitmap));
    }
    return images_[bitmap];
  }

  int icon;
  if (is_selected_keyword)
    icon = IDR_OMNIBOX_TTS;
  else if (match.starred)
    icon = IDR_OMNIBOX_STAR;
  else
    icon = AutocompleteMatch::TypeToIcon(match.type);

  if (selected) {
    switch (icon) {
      case IDR_OMNIBOX_EXTENSION_APP:
        icon = IDR_OMNIBOX_EXTENSION_APP_DARK;
        break;
      case IDR_OMNIBOX_HTTP:
        icon = IDR_OMNIBOX_HTTP_DARK;
        break;
      case IDR_OMNIBOX_HISTORY:
        icon = IDR_OMNIBOX_HISTORY_DARK;
        break;
      case IDR_OMNIBOX_SEARCH:
        icon = IDR_OMNIBOX_SEARCH_DARK;
        break;
      case IDR_OMNIBOX_STAR:
        icon = IDR_OMNIBOX_STAR_DARK;
        break;
      case IDR_OMNIBOX_TTS:
        icon = IDR_OMNIBOX_TTS_DARK;
        break;
      default:
        NOTREACHED();
        break;
    }
  }

  return theme_service_->GetImageNamed(icon);
}

void OmniboxPopupViewGtk::InvalidateLine(size_t line) {
  GdkWindow* gdk_window = gtk_widget_get_window(GTK_WIDGET(window_));
  GdkRectangle line_rect = GetRectForLine(
      line, GetWindowRect(gdk_window).width()).ToGdkRectangle();
  gdk_window_invalidate_rect(gdk_window, &line_rect, FALSE);
}

gfx::Rect OmniboxPopupViewGtk::GetTargetBounds() {
  if (!gtk_widget_get_realized(window_))
    return gfx::Rect();

  gfx::Rect retval = ui::GetWidgetScreenBounds(window_);

  GtkRequisition req;
  gtk_widget_size_request(window_, &req);
  retval.set_width(req.width);
  retval.set_height(req.height);

  return retval;
}

void OmniboxPopupViewGtk::UpdatePopupAppearance() {
  const AutocompleteResult& result = model_->result();
  if (result.empty()) {
    Hide();
    return;
  }

  Show(result.size());
  gtk_widget_queue_draw(window_);
}

 OmniboxPopupViewGtk::~OmniboxPopupViewGtk() {
  model_.reset();
  g_object_unref(layout_);
  gtk_widget_destroy(window_);

  for (ImageMap::iterator it = images_.begin(); it != images_.end(); ++it)
    delete it->second;
}

bool OmniboxPopupViewGtk::IsOpen() const {
  return opened_;
}

void OmniboxPopupViewGtk::OnDragCanceled() {
  ignore_mouse_drag_ = true;
}

void OmniboxPopupViewGtk::StackWindow() {
  gfx::NativeView omnibox_view = omnibox_view_->GetNativeView();
  DCHECK(GTK_IS_WIDGET(omnibox_view));
  GtkWidget* toplevel = gtk_widget_get_toplevel(omnibox_view);
  DCHECK(gtk_widget_is_toplevel(toplevel));
  ui::StackPopupWindow(window_, toplevel);
}
