void MediaStreamDevicesController::NotifyUIRequestDenied() const {
  if (!content_settings_)
    return;

  if (request_.audio_type == content::MEDIA_TAB_AUDIO_CAPTURE ||
      request_.video_type == content::MEDIA_TAB_VIDEO_CAPTURE) {
      return;
  }

  if (request_.audio_type == content::MEDIA_DEVICE_AUDIO_CAPTURE)
    content_settings_->OnMicrophoneAccessBlocked();
  if (request_.video_type == content::MEDIA_DEVICE_VIDEO_CAPTURE)
    content_settings_->OnCameraAccessBlocked();
}

bool MediaStreamDevicesController::IsRequestAllowedByDefault() const {
// The request from internal objects like chrome://URLs is always allowed.
if (ShouldAlwaysAllowOrigin())
return true;

struct {
bool has_capability;
const char* policy_name;
const char* list_policy_name;
ContentSettingsType settings_type;
} device_checks[] = {
{ microphone_requested_, prefs::kAudioCaptureAllowed,
prefs::kAudioCaptureAllowedUrls, CONTENT_SETTINGS_TYPE_MEDIASTREAM_MIC },
{ webcam_requested_, prefs::kVideoCaptureAllowed,
prefs::kVideoCaptureAllowedUrls,
CONTENT_SETTINGS_TYPE_MEDIASTREAM_CAMERA },
};

for (size_t i = 0; i < ARRAYSIZE_UNSAFE(device_checks); ++i) {
if (!device_checks[i].has_capability)
continue;

DevicePolicy policy = GetDevicePolicy(device_checks[i].policy_name,
device_checks[i].list_policy_name);
    if (policy == ALWAYS_DENY ||
        (policy == POLICY_NOT_SET &&
         profile_->GetHostContentSettingsMap()->GetContentSetting(
            request_.security_origin, request_.security_origin,
            device_checks[i].settings_type, NO_RESOURCE_IDENTIFIER) !=
         CONTENT_SETTING_ALLOW)) {
return false;
}
// If we get here, then either policy is set to ALWAYS_ALLOW or the content
// settings allow the request by default.
}

return true;
}

void MediaStreamDevicesController::Deny(bool update_content_setting) {
  if (content_settings_) {
    content_settings_->OnContentBlocked(CONTENT_SETTINGS_TYPE_MEDIASTREAM,
                                        std::string());
  }

  NotifyUIRequestDenied();

  if (update_content_setting)
    SetPermission(false);

  content::MediaResponseCallback cb = callback_;
  callback_.Reset();
  cb.Run(content::MediaStreamDevices(), scoped_ptr<content::MediaStreamUI>());
}

const std::string& MediaStreamDevicesController::GetSecurityOriginSpec() const {
  return request_.security_origin.spec();
}

bool HasAnyAvailableDevice() {
  const content::MediaStreamDevices& audio_devices =
      MediaCaptureDevicesDispatcher::GetInstance()->GetAudioCaptureDevices();
  const content::MediaStreamDevices& video_devices =
      MediaCaptureDevicesDispatcher::GetInstance()->GetVideoCaptureDevices();

  return !audio_devices.empty() || !video_devices.empty();
}

bool IsInKioskMode() {
  if (CommandLine::ForCurrentProcess()->HasSwitch(switches::kKioskMode))
    return true;

#if defined(OS_CHROMEOS)
  const chromeos::UserManager* user_manager = chromeos::UserManager::Get();
  return user_manager && user_manager->IsLoggedInAsKioskApp();
#else
  return false;
#endif
}

bool MediaStreamDevicesController::IsDefaultMediaAccessBlocked() const {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  ContentSetting current_setting =
      profile_->GetHostContentSettingsMap()->GetDefaultContentSetting(
          CONTENT_SETTINGS_TYPE_MEDIASTREAM, NULL);
  return (current_setting == CONTENT_SETTING_BLOCK);
}

void MediaStreamDevicesController::Accept(bool update_content_setting) {
// TODO(xians): Remove the following call after the UI handles microphone
// and camera seprately.
if (content_settings_)
content_settings_->OnMediaStreamAllowed();

NotifyUIRequestAccepted();

// Get the default devices for the request.
content::MediaStreamDevices devices;
if (microphone_requested_ || webcam_requested_) {
switch (request_.request_type) {
case content::MEDIA_OPEN_DEVICE:
// For open device request pick the desired device or fall back to the
// first available of the given type.
MediaCaptureDevicesDispatcher::GetInstance()->GetRequestedDevice(
request_.requested_device_id,
request_.audio_type == content::MEDIA_DEVICE_AUDIO_CAPTURE,
request_.video_type == content::MEDIA_DEVICE_VIDEO_CAPTURE,
&devices);
break;
case content::MEDIA_DEVICE_ACCESS:
case content::MEDIA_GENERATE_STREAM:
case content::MEDIA_ENUMERATE_DEVICES:
// Get the default devices for the request.
MediaCaptureDevicesDispatcher::GetInstance()->
GetDefaultDevicesForProfile(profile_,
microphone_requested_,
webcam_requested_,
&devices);
break;
}

    if (update_content_setting && IsSchemeSecure() && !devices.empty())
      SetPermission(true);
}

scoped_ptr<content::MediaStreamUI> ui;
if (!devices.empty()) {
ui = MediaCaptureDevicesDispatcher::GetInstance()->
GetMediaStreamCaptureIndicator()->RegisterMediaStream(
web_contents_, devices);
}
content::MediaResponseCallback cb = callback_;
callback_.Reset();
cb.Run(devices, ui.Pass());
}

void MediaStreamDevicesController::SetPermission(bool allowed) const {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
#if defined(OS_ANDROID)
  return;
#endif
  ContentSettingsPattern primary_pattern =
      ContentSettingsPattern::FromURLNoWildcard(request_.security_origin);
  if (!primary_pattern.IsValid())
    return;

  ContentSetting content_setting = allowed ?
      CONTENT_SETTING_ALLOW : CONTENT_SETTING_BLOCK;
  if (microphone_requested_) {
      profile_->GetHostContentSettingsMap()->SetContentSetting(
        primary_pattern,
        ContentSettingsPattern::Wildcard(),
        CONTENT_SETTINGS_TYPE_MEDIASTREAM_MIC,
        std::string(),
        content_setting);
  }
  if (webcam_requested_) {
    profile_->GetHostContentSettingsMap()->SetContentSetting(
        primary_pattern,
        ContentSettingsPattern::Wildcard(),
        CONTENT_SETTINGS_TYPE_MEDIASTREAM_CAMERA,
        std::string(),
        content_setting);
  }
}
