void MockDownloadController::DangerousDownloadValidated(
    content::WebContents* web_contents,
    const std::string& download_guid,
    bool accept) {}

void DownloadController::DangerousDownloadValidated(
    WebContents* web_contents,
    const std::string& download_guid,
    bool accept) {
  if (!web_contents)
    return;
  DownloadManager* dlm =
      BrowserContext::GetDownloadManager(web_contents->GetBrowserContext());
  DownloadItem* item = dlm->GetDownloadByGuid(download_guid);
  if (!item)
    return;
  if (accept) {
    item->ValidateDangerousDownload();
  } else {
    DownloadController::RecordDownloadCancelReason(
        DownloadController::CANCEL_REASON_DANGEROUS_DOWNLOAD_INFOBAR_DISMISSED);
    item->Remove();
  }
}

void DownloadController::SetDefaultDownloadFileName(
    const std::string& file_name) {
  default_file_name_ = file_name;
}

bool RegisterChromeDownloadDelegate(JNIEnv* env) {
  return RegisterNativesImpl(env);
}

 void MockDownloadController::OnDownloadStarted(
     content::DownloadItem* download_item) {
 }

void ChromeDownloadDelegate::RequestFileAccess(intptr_t callback_id) {
  JNIEnv* env = base::android::AttachCurrentThread();
  Java_ChromeDownloadDelegate_requestFileAccess(
      env, java_ref_, callback_id);
}

DownloadController::~DownloadController() {
  if (java_object_) {
    JNIEnv* env = base::android::AttachCurrentThread();
    env->DeleteWeakGlobalRef(java_object_->obj_);
    delete java_object_;
    base::android::CheckException(env);
  }
}

 MockDownloadController::~MockDownloadController() {}

bool ChromeDownloadDelegate::EnqueueDownloadManagerRequest(
    jobject chrome_download_delegate,
    bool overwrite,
    jobject download_info) {
  JNIEnv* env = base::android::AttachCurrentThread();

  return Java_ChromeDownloadDelegate_enqueueDownloadManagerRequestFromNative(
      env, chrome_download_delegate, overwrite, download_info);
}

bool DownloadController::RegisterDownloadController(JNIEnv* env) {
  return RegisterNativesImpl(env);
}

DownloadController::DownloadController()
    : java_object_(NULL) {
}

void ChromeDownloadDelegate::OnDownloadStarted(const std::string& filename,
                                               const std::string& mime_type) {
JNIEnv* env = base::android::AttachCurrentThread();
ScopedJavaLocalRef<jstring> jfilename = ConvertUTF8ToJavaString(
env, filename);
  ScopedJavaLocalRef<jstring> jmime_type =
      ConvertUTF8ToJavaString(env, mime_type);
  Java_ChromeDownloadDelegate_onDownloadStarted(env, java_ref_, jfilename,
                                                jmime_type);
}

void DownloadController::Init(JNIEnv* env, jobject obj) {
  java_object_ = new JavaObject;
  java_object_->obj_ = env->NewWeakGlobalRef(obj);
}

void DownloadController::StartAndroidDownload(
    const content::ResourceRequestInfo::WebContentsGetter& wc_getter,
    bool must_download, const DownloadInfo& info) {
  DCHECK_CURRENTLY_ON(BrowserThread::UI);
  WebContents* web_contents = wc_getter.Run();
  if (!web_contents) {
    // The view went away. Can't proceed.
    LOG(ERROR) << "Download failed on URL:" << info.url.spec();
    return;
  }
  AcquireFileAccessPermission(
      web_contents,
      base::Bind(&DownloadController::StartAndroidDownloadInternal,
                 base::Unretained(this), wc_getter, must_download, info));
}

void DownloadController::StartContextMenuDownload(
    const ContextMenuParams& params, WebContents* web_contents, bool is_link,
    const std::string& extra_headers) {
  int process_id = web_contents->GetRenderProcessHost()->GetID();
  int routing_id = web_contents->GetRoutingID();
  AcquireFileAccessPermission(
      web_contents, base::Bind(&CreateContextMenuDownload, process_id,
                               routing_id, params, is_link, extra_headers));
}

void Init(JNIEnv* env,
          const JavaParamRef<jobject>& obj,
          const JavaParamRef<jobject>& jweb_contents) {
  auto* web_contents = WebContents::FromJavaWebContents(jweb_contents);
  ChromeDownloadDelegate::CreateForWebContents(web_contents);
  ChromeDownloadDelegate::FromWebContents(web_contents)->SetJavaRef(env, obj);
}

static ScopedJavaLocalRef<jstring> GetDownloadWarningText(
    JNIEnv* env,
    const JavaParamRef<jclass>& clazz,
    const JavaParamRef<jstring>& filename) {
  return base::android::ConvertUTF8ToJavaString(
      env, l10n_util::GetStringFUTF8(
               IDS_PROMPT_DANGEROUS_DOWNLOAD,
               base::android::ConvertJavaStringToUTF16(env, filename)));
}

void DownloadController::RecordDownloadCancelReason(
    DownloadCancelReason reason) {
  UMA_HISTOGRAM_ENUMERATION(
      "MobileDownload.CancelReason", reason, CANCEL_REASON_MAX);
}

void ChromeDownloadDelegate::RequestHTTPGetDownload(
    const std::string& url,
    const std::string& user_agent,
    const std::string& content_disposition,
    const std::string& mime_type,
    const std::string& cookie,
    const std::string& referer,
    const base::string16& file_name,
    int64_t content_length,
    bool has_user_gesture,
    bool must_download) {
  JNIEnv* env = base::android::AttachCurrentThread();
  ScopedJavaLocalRef<jstring> jurl =
      ConvertUTF8ToJavaString(env, url);
  ScopedJavaLocalRef<jstring> juser_agent =
      ConvertUTF8ToJavaString(env, user_agent);
  ScopedJavaLocalRef<jstring> jcontent_disposition =
      ConvertUTF8ToJavaString(env, content_disposition);
  ScopedJavaLocalRef<jstring> jmime_type =
      ConvertUTF8ToJavaString(env, mime_type);
  ScopedJavaLocalRef<jstring> jcookie =
      ConvertUTF8ToJavaString(env, cookie);
  ScopedJavaLocalRef<jstring> jreferer =
      ConvertUTF8ToJavaString(env, referer);
  // net::GetSuggestedFilename will fallback to "download" as filename.
  ScopedJavaLocalRef<jstring> jfilename =
      base::android::ConvertUTF16ToJavaString(env, file_name);
  Java_ChromeDownloadDelegate_requestHttpGetDownload(
      env, java_ref_, jurl, juser_agent, jcontent_disposition, jmime_type,
      jcookie, jreferer, has_user_gesture, jfilename, content_length,
      must_download);
}

static jboolean IsDownloadDangerous(JNIEnv* env,
                                    const JavaParamRef<jclass>& clazz,
                                    const JavaParamRef<jstring>& filename) {
  base::FilePath path(base::android::ConvertJavaStringToUTF8(env, filename));
  return safe_browsing::FileTypePolicies::GetInstance()->GetFileDangerLevel(
             path) != safe_browsing::DownloadFileType::NOT_DANGEROUS;
}

MockDownloadController::MockDownloadController()
    : approve_file_access_request_(true) {
}

void MockDownloadController::SetApproveFileAccessRequestForTesting(
    bool approve) {
  approve_file_access_request_ = approve;
}

void CreateContextMenuDownload(int render_process_id,
                               int render_view_id,
                               const content::ContextMenuParams& params,
                               bool is_link,
                               const std::string& extra_headers,
                               bool granted) {
  if (!granted)
    return;

  content::WebContents* web_contents =
      GetWebContents(render_process_id, render_view_id);
  if (!web_contents)
    return;

  const GURL& url = is_link ? params.link_url : params.src_url;
  const GURL& referring_url =
      params.frame_url.is_empty() ? params.page_url : params.frame_url;
  content::DownloadManager* dlm =
      content::BrowserContext::GetDownloadManager(
          web_contents->GetBrowserContext());
  std::unique_ptr<content::DownloadUrlParameters> dl_params(
      content::DownloadUrlParameters::CreateForWebContentsMainFrame(
          web_contents, url));
  content::Referrer referrer = content::Referrer::SanitizeForRequest(
      url,
      content::Referrer(referring_url.GetAsReferrer(), params.referrer_policy));
  dl_params->set_referrer(referrer);
  if (is_link)
    dl_params->set_referrer_encoding(params.frame_charset);
  net::HttpRequestHeaders headers;
  headers.AddHeadersFromString(extra_headers);
  for (net::HttpRequestHeaders::Iterator it(headers); it.GetNext();)
    dl_params->add_request_header(it.name(), it.value());
  if (!is_link && extra_headers.empty())
    dl_params->set_prefer_cache(true);
  dl_params->set_prompt(false);
  dlm->DownloadUrl(std::move(dl_params));
}

void ChromeDownloadDelegate::SetJavaRef(JNIEnv* env, jobject jobj) {
   java_ref_ = env->NewGlobalRef(jobj);
 }

static void OnRequestFileAccessResult(JNIEnv* env,
                                      const JavaParamRef<jobject>& obj,
                                      jlong callback_id,
                                      jboolean granted) {
  DCHECK_CURRENTLY_ON(BrowserThread::UI);
  DCHECK(callback_id);

  std::unique_ptr<
      DownloadControllerBase::AcquireFileAccessPermissionCallback>
  cb(reinterpret_cast<
      DownloadControllerBase::AcquireFileAccessPermissionCallback*>(
      callback_id));
  if (!granted) {
    DownloadController::RecordDownloadCancelReason(
        DownloadController::CANCEL_REASON_NO_STORAGE_PERMISSION);
  }
  cb->Run(granted);
}

ChromeDownloadDelegate::ChromeDownloadDelegate(
    WebContents* web_contents) {}

void MockDownloadController::AcquireFileAccessPermission(
    content::WebContents* web_contents,
    const DownloadControllerBase::AcquireFileAccessPermissionCallback& cb) {
  base::ThreadTaskRunnerHandle::Get()->PostTask(
      FROM_HERE, base::Bind(cb, approve_file_access_request_));
}

static void LaunchPermissionUpdateInfoBar(
    JNIEnv* env,
    const JavaParamRef<jclass>& clazz,
    const JavaParamRef<jobject>& tab,
    const JavaParamRef<jstring>& jpermission,
    jlong callback_id) {
  TabAndroid* tab_android = TabAndroid::GetNativeTab(env, tab);

  std::string permission =
      base::android::ConvertJavaStringToUTF8(env, jpermission);

  static_assert(
      std::is_same<
          DownloadControllerBase::AcquireFileAccessPermissionCallback,
          base::Callback<void(bool)>>::value,
      "Callback types don't match!");
  std::unique_ptr<base::Callback<void(bool)>> cb(
      reinterpret_cast<base::Callback<void(bool)>*>(callback_id));

  std::vector<std::string> permissions;
  permissions.push_back(permission);

  PermissionUpdateInfoBarDelegate::Create(
      tab_android->web_contents(),
      permissions,
      IDS_MISSING_STORAGE_PERMISSION_DOWNLOAD_EDUCATION_TEXT,
      *cb);
}

bool IsInterruptedDownloadAutoResumable(content::DownloadItem* download_item) {
  int interrupt_reason = download_item->GetLastReason();
  DCHECK_NE(interrupt_reason, content::DOWNLOAD_INTERRUPT_REASON_NONE);
  return
      interrupt_reason == content::DOWNLOAD_INTERRUPT_REASON_NETWORK_TIMEOUT ||
      interrupt_reason == content::DOWNLOAD_INTERRUPT_REASON_NETWORK_FAILED ||
      interrupt_reason ==
          content::DOWNLOAD_INTERRUPT_REASON_NETWORK_DISCONNECTED;
}

    DownloadController::GetJavaObject() {
  if (!java_object_) {
    JNIEnv* env = base::android::AttachCurrentThread();
    Java_DownloadController_getInstance(env);
  }

  DCHECK(java_object_);
  return java_object_;
}

DownloadController* DownloadController::GetInstance() {
  return base::Singleton<DownloadController>::get();
}

void DownloadController::OnDangerousDownload(DownloadItem* item) {
  WebContents* web_contents = item->GetWebContents();
  if (!web_contents)
    return;
  ChromeDownloadDelegate::FromWebContents(web_contents)->OnDangerousDownload(
      item->GetTargetFilePath().BaseName().value(), item->GetGuid());
}

 void DownloadController::OnDownloadUpdated(DownloadItem* item) {
  DCHECK_CURRENTLY_ON(BrowserThread::UI);
  if (item->IsDangerous() && (item->GetState() != DownloadItem::CANCELLED))
    OnDangerousDownload(item);

  JNIEnv* env = base::android::AttachCurrentThread();
  ScopedJavaLocalRef<jstring> jguid =
      ConvertUTF8ToJavaString(env, item->GetGuid());
  ScopedJavaLocalRef<jstring> jurl =
      ConvertUTF8ToJavaString(env, item->GetURL().spec());
  ScopedJavaLocalRef<jstring> jmime_type =
      ConvertUTF8ToJavaString(env, item->GetMimeType());
  ScopedJavaLocalRef<jstring> jpath =
      ConvertUTF8ToJavaString(env, item->GetTargetFilePath().value());
  ScopedJavaLocalRef<jstring> jfilename = ConvertUTF8ToJavaString(
      env, item->GetTargetFilePath().BaseName().value());
  ScopedJavaLocalRef<jstring> joriginal_url =
      ConvertUTF8ToJavaString(env, item->GetOriginalUrl().spec());
  ScopedJavaLocalRef<jstring> jreferrer_url =
      ConvertUTF8ToJavaString(env, item->GetReferrerUrl().spec());

  ui::PageTransition base_transition =
      ui::PageTransitionStripQualifier(item->GetTransitionType());
  bool user_initiated =
      item->GetTransitionType() & ui::PAGE_TRANSITION_FROM_ADDRESS_BAR ||
      base_transition == ui::PAGE_TRANSITION_TYPED ||
      base_transition == ui::PAGE_TRANSITION_AUTO_BOOKMARK ||
      base_transition == ui::PAGE_TRANSITION_GENERATED ||
      base_transition == ui::PAGE_TRANSITION_RELOAD ||
      base_transition == ui::PAGE_TRANSITION_KEYWORD;
  bool hasUserGesture = item->HasUserGesture() || user_initiated;
  switch (item->GetState()) {
    case DownloadItem::IN_PROGRESS: {
      base::TimeDelta time_delta;
      item->TimeRemaining(&time_delta);
      Java_DownloadController_onDownloadUpdated(
          env, GetJavaObject()->Controller(env), jurl, jmime_type, jfilename,
          jpath, item->GetReceivedBytes(), jguid, item->PercentComplete(),
          time_delta.InMilliseconds(), hasUserGesture, item->IsPaused(),
          item->GetBrowserContext()->IsOffTheRecord());
      break;
    }
    case DownloadItem::COMPLETE:
      item->RemoveObserver(this);

      Java_DownloadController_onDownloadCompleted(
          env, GetJavaObject()->Controller(env), jurl, jmime_type, jfilename,
          jpath, item->GetReceivedBytes(), jguid, joriginal_url, jreferrer_url,
          hasUserGesture);
      DownloadController::RecordDownloadCancelReason(
             DownloadController::CANCEL_REASON_NOT_CANCELED);
      break;
    case DownloadItem::CANCELLED:
      Java_DownloadController_onDownloadCancelled(
          env, GetJavaObject()->Controller(env), jguid);
      break;
    case DownloadItem::INTERRUPTED:
      Java_DownloadController_onDownloadInterrupted(
          env, GetJavaObject()->Controller(env), jurl, jmime_type, jfilename,
          jpath, item->GetReceivedBytes(), jguid, item->CanResume(),
          IsInterruptedDownloadAutoResumable(item),
          item->GetBrowserContext()->IsOffTheRecord());
      item->RemoveObserver(this);
      break;
    case DownloadItem::MAX_DOWNLOAD_STATE:
      NOTREACHED();
  }
}

void DownloadController::AcquireFileAccessPermission(
    WebContents* web_contents,
    const DownloadControllerBase::AcquireFileAccessPermissionCallback& cb) {
  DCHECK_CURRENTLY_ON(BrowserThread::UI);
  DCHECK(web_contents);

  ui::ViewAndroid* view_android =
      ViewAndroidHelper::FromWebContents(web_contents)->GetViewAndroid();
  if (!view_android) {
    BrowserThread::PostTask(
        BrowserThread::UI, FROM_HERE, base::Bind(cb, false));
    return;
  }
  ui::WindowAndroid* window_android = view_android->GetWindowAndroid();
  if (window_android && HasFileAccessPermission(window_android)) {
    BrowserThread::PostTask(
        BrowserThread::UI, FROM_HERE, base::Bind(cb, true));
    return;
  }
  intptr_t callback_id = reinterpret_cast<intptr_t>(
      new DownloadControllerBase::AcquireFileAccessPermissionCallback(cb));
  ChromeDownloadDelegate::FromWebContents(web_contents)->
      RequestFileAccess(callback_id);
}

WebContents* GetWebContents(int render_process_id, int render_view_id) {
  content::RenderViewHost* render_view_host =
      content::RenderViewHost::FromID(render_process_id, render_view_id);

  if (!render_view_host)
    return nullptr;

  return WebContents::FromRenderViewHost(render_view_host);
}

void MockDownloadController::CreateGETDownload(
    const content::ResourceRequestInfo::WebContentsGetter& wc_getter,
    bool must_download, const DownloadInfo& info) {
}
