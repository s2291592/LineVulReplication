  virtual ~ConsumesTouchMovesDelegate() {}

  virtual ~QueueTouchEventDelegate() {
    while(!queue_.empty()) {
      delete queue_.front();
      queue_.pop();
    }
  }

  bool UsingUnifiedGR() {
    return GetParam();
  }

  bool scroll_end() const { return scroll_end_; }

ScopedVector<GestureEvent>* GestureProviderAura::GetAndResetPendingGestures() {
  if (pending_gestures_.empty())
    return NULL;
  ScopedVector<GestureEvent>* old_pending_gestures =
      new ScopedVector<GestureEvent>();
  old_pending_gestures->swap(pending_gestures_);
  return old_pending_gestures;
}

  base::TimeDelta InFuture(int time_in_millis) {
    return base::TimeDelta::FromMilliseconds(simulated_now_ + time_in_millis);
  }

  TestGestureRecognizer() : GestureRecognizerImpl() {
  }

  void ReceivedAckImpl(bool prevent_defaulted) {
    scoped_ptr<ui::TouchEvent> event(queue_.front());
    dispatcher_->ProcessedTouchEvent(event.get(), window_,
        prevent_defaulted ? ui::ER_HANDLED : ui::ER_UNHANDLED);
    queue_.pop();
  }

  const gfx::Point& tap_location() const {
    return tap_location_;
  }

   const std::vector<ui::EventType>& events() const { return events_; };

  explicit TimerTestGestureSequence(ui::GestureSequenceDelegate* delegate)
      : ui::GestureSequence(delegate) {
  }

  bool scroll_begin() const { return scroll_begin_; }

  TestEventHandler() : touch_released_count_(0),
                       touch_pressed_count_(0),
                       touch_moved_count_(0),
                       touch_cancelled_count_(0) {
  }

  void SendScrollEvent(ui::EventProcessor* dispatcher,
                       float x,
                       float y,
                       int touch_id,
                       GestureEventConsumeDelegate* delegate) {
    delegate->Reset();
    ui::TouchEvent move(ui::ET_TOUCH_MOVED, gfx::PointF(x, y),
                        touch_id,
                        base::TimeDelta::FromMilliseconds(simulated_now_));
    ui::EventDispatchDetails details = dispatcher->OnEventFromSource(&move);
    ASSERT_FALSE(details.dispatcher_destroyed);
    simulated_now_++;
  }

  const gfx::Point& scroll_begin_position() const {
    return scroll_begin_position_;
  }

  virtual ~GestureEventConsumeDelegate() {}

bool GestureProviderAura::IsConsideredDoubleTap(
    const GestureEventData& previous_tap,
    const GestureEventData& current_tap) const {
  if (current_tap.time - previous_tap.time >
      base::TimeDelta::FromMilliseconds(
          ui::GestureConfiguration::max_seconds_between_double_click() *
          1000)) {
    return false;
  }

  double double_tap_slop_square =
      GestureConfiguration::max_distance_between_taps_for_double_tap();
  double_tap_slop_square *= double_tap_slop_square;
  const float delta_x = previous_tap.x - current_tap.x;
  const float delta_y = previous_tap.y - current_tap.y;
  return (delta_x * delta_x + delta_y * delta_y < double_tap_slop_square);
}

  bool double_click() const { return double_click_; }

  bool pinch_update() const { return pinch_update_; }

  bool mouse_move() const { return mouse_move_; }

  virtual ~RemoveOnTouchCancelHandler() {}

  bool mouse_press() const { return mouse_press_; }

  const gfx::Point& gesture_end_location() const {
    return gesture_end_location_;
  }

  bool scroll_update() const { return scroll_update_; }

bool GestureProviderAura::OnTouchEvent(const TouchEvent& event) {
  last_touch_event_flags_ = event.flags();
bool pointer_id_is_active = false;
for (size_t i = 0; i < pointer_state_.GetPointerCount(); ++i) {
if (event.touch_id() != pointer_state_.GetPointerId(i))
continue;
pointer_id_is_active = true;
break;
}

if (event.type() == ET_TOUCH_PRESSED && pointer_id_is_active) {
// Ignore touch press events if we already believe the pointer is down.
return false;
} else if (event.type() != ET_TOUCH_PRESSED && !pointer_id_is_active) {
// We could have an active touch stream transfered to us, resulting in touch
// move or touch up events without associated touch down events. Ignore
// them.
return false;
}

pointer_state_.OnTouch(event);

bool result = filtered_gesture_provider_.OnTouchEvent(pointer_state_);
pointer_state_.CleanupRemovedTouchPoints(event);
return result;
}

  void Reset() {
    mouse_enter_ = false;
    mouse_exit_ = false;
    mouse_press_ = false;
    mouse_release_ = false;
    mouse_move_ = false;
    double_click_ = false;
  }

  bool swipe_right() const { return swipe_right_; }

  float scroll_velocity_x() const { return scroll_velocity_x_; }

  base::TimeDelta Now() {
    base::TimeDelta t = base::TimeDelta::FromMilliseconds(simulated_now_);
    simulated_now_++;
    return t;
  }

  TestOneShotGestureSequenceTimer() {}

  bool mouse_enter() const { return mouse_enter_; }

  bool tap_cancel() const { return tap_cancel_; }

  bool show_press() const { return show_press_; }

  void ForceTimeout() {
    static_cast<TestOneShotGestureSequenceTimer*>(
        GetLongPressTimer())->ForceTimeout();
  }

  virtual ~ScopedGestureRecognizerSetter() {
    ui::SetGestureRecognizerForTesting(original_gr_);
  }

  GestureRecognizerTest() {}

  ConsumesTouchMovesDelegate() : consume_touch_move_(true) {}

  float scroll_y() const { return scroll_y_; }

  bool mouse_exit() const { return mouse_exit_; }

GestureProviderAura::GestureProviderAura(GestureProviderAuraClient* client)
    : client_(client),
      filtered_gesture_provider_(ui::DefaultGestureProviderConfig(), this),
      handling_event_(false) {
  filtered_gesture_provider_.SetDoubleTapSupportForPlatformEnabled(false);
}

  void ForceTimeout() {
    if (IsRunning()) {
      user_task().Run();
      Stop();
    }
  }

  GestureEventSynthDelegate()
      : mouse_enter_(false),
        mouse_exit_(false),
        mouse_press_(false),
        mouse_release_(false),
        mouse_move_(false),
        double_click_(false) {
  }

  bool long_tap() const { return long_tap_; }

  bool long_press() const { return long_press_; }

void GestureProviderAura::OnTouchEventAck(bool event_consumed) {
  DCHECK(pending_gestures_.empty());
   DCHECK(!handling_event_);
   base::AutoReset<bool> handling_event(&handling_event_, true);
   filtered_gesture_provider_.OnTouchEventAck(event_consumed);
 }

  float scroll_x_hint() const { return scroll_x_hint_; }

  bool two_finger_tap() const { return two_finger_tap_; }

  void ReceivedAckPreventDefaulted() {
    ReceivedAckImpl(true);
  }

base::TimeDelta GetTime() {
  return ui::EventTimeForNow();
}

  float velocity_x() const { return velocity_x_; }

   const gfx::Rect& bounding_box() const { return bounding_box_; }

  int touch_moved_count() const { return touch_moved_count_; }

  TimedEvents() : simulated_now_(1) {
  }

  bool end() const { return end_; }

  bool pinch_end() const { return pinch_end_; }

  RemoveOnTouchCancelHandler() {}

  GestureEventConsumeDelegate()
      : tap_(false),
        tap_down_(false),
        tap_cancel_(false),
        begin_(false),
        end_(false),
        scroll_begin_(false),
        scroll_update_(false),
        scroll_end_(false),
        pinch_begin_(false),
        pinch_update_(false),
        pinch_end_(false),
        long_press_(false),
        fling_(false),
        two_finger_tap_(false),
        show_press_(false),
        swipe_left_(false),
        swipe_right_(false),
        swipe_up_(false),
        swipe_down_(false),
        scroll_x_(0),
        scroll_y_(0),
        scroll_velocity_x_(0),
        scroll_velocity_y_(0),
        velocity_x_(0),
        velocity_y_(0),
        scroll_x_hint_(0),
        scroll_y_hint_(0),
        tap_count_(0),
        flags_(0),
        wait_until_event_(ui::ET_UNKNOWN) {}

  explicit QueueTouchEventDelegate(WindowEventDispatcher* dispatcher)
      : window_(NULL),
        dispatcher_(dispatcher),
        queue_events_(true) {
  }

  void set_queue_events(bool queue) { queue_events_ = queue; }

  int touch_released_count() const { return touch_released_count_; }

 GestureProviderAura::~GestureProviderAura() {}

  bool tap() const { return tap_; }

  bool IsTimerRunning() {
    return GetLongPressTimer()->IsRunning();
  }

  float scroll_x() const { return scroll_x_; }

  bool swipe_left() const { return swipe_left_; }

  float scroll_velocity_y() const { return scroll_velocity_y_; }

  bool begin() const { return begin_; }

  void Reset() {
    events_.clear();
    tap_ = false;
    tap_down_ = false;
    tap_cancel_ = false;
    begin_ = false;
    end_ = false;
    scroll_begin_ = false;
    scroll_update_ = false;
    scroll_end_ = false;
    pinch_begin_ = false;
    pinch_update_ = false;
    pinch_end_ = false;
    long_press_ = false;
    fling_ = false;
    two_finger_tap_ = false;
    show_press_ = false;
    swipe_left_ = false;
    swipe_right_ = false;
    swipe_up_ = false;
    swipe_down_ = false;

    scroll_begin_position_.SetPoint(0, 0);
    tap_location_.SetPoint(0, 0);
    gesture_end_location_.SetPoint(0, 0);

    scroll_x_ = 0;
    scroll_y_ = 0;
    scroll_velocity_x_ = 0;
    scroll_velocity_y_ = 0;
    velocity_x_ = 0;
    velocity_y_ = 0;
    scroll_x_hint_ = 0;
    scroll_y_hint_ = 0;
     tap_count_ = 0;
     scale_ = 0;
     flags_ = 0;
   }

  float scale() const { return scale_; }

  virtual ~TestEventHandler() {}

  float velocity_y() const { return velocity_y_; }

  int touch_pressed_count() const { return touch_pressed_count_; }

  bool fling() const { return fling_; }

 void GestureProviderAura::OnGestureEvent(
    const GestureEventData& gesture) {
  GestureEventDetails details = gesture.details;

  if (gesture.type == ET_GESTURE_TAP) {
    int tap_count = 1;
    if (previous_tap_ && IsConsideredDoubleTap(*previous_tap_, gesture))
      tap_count = 1 + (previous_tap_->details.tap_count() % 3);
    details.set_tap_count(tap_count);
    if (!previous_tap_)
      previous_tap_.reset(new GestureEventData(gesture));
    else
      *previous_tap_ = gesture;
    previous_tap_->details = details;
  } else if (gesture.type == ET_GESTURE_TAP_CANCEL) {
    previous_tap_.reset();
  }

  scoped_ptr<ui::GestureEvent> event(
      new ui::GestureEvent(gesture.type,
                           gesture.x,
                           gesture.y,
                           last_touch_event_flags_,
                           gesture.time - base::TimeTicks(),
                           details,
                            1 << gesture.motion_event_id));
 
   if (!handling_event_) {
     client_->OnGestureEvent(event.get());
  } else {
    pending_gestures_.push_back(event.release());
  }
}

   void WaitUntilReceivedGesture(ui::EventType type) {
     wait_until_event_ = type;
    run_loop_.reset(new base::RunLoop());
    run_loop_->Run();
  }

  bool tap_down() const { return tap_down_; }
