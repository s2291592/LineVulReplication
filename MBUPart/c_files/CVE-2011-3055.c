static v8::Handle<v8::Value> methodWithNonCallbackArgAndCallbackArgCallback(const v8::Arguments& args)
{
INC_STATS("DOM.TestObj.methodWithNonCallbackArgAndCallbackArg");
if (args.Length() < 2)
        return V8Proxy::throwNotEnoughArgumentsError();
TestObj* imp = V8TestObj::toNative(args.Holder());
EXCEPTION_BLOCK(int, nonCallback, toInt32(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));
if (args.Length() <= 1 || !args[1]->IsFunction())
return throwError(TYPE_MISMATCH_ERR, args.GetIsolate());
RefPtr<TestCallback> callback = V8TestCallback::create(args[1], getScriptExecutionContext());
imp->methodWithNonCallbackArgAndCallbackArg(nonCallback, callback);
return v8::Handle<v8::Value>();
}

static WebGLUniformLocation* toWebGLUniformLocation(v8::Handle<v8::Value> value, bool& ok)
{
    ok = false;
    WebGLUniformLocation* location = 0;
    if (V8WebGLUniformLocation::HasInstance(value)) {
        location = V8WebGLUniformLocation::toNative(value->ToObject());
        ok = true;
    }
    return location;
}

v8::Handle<v8::Object> V8TestInterface::wrapSlow(PassRefPtr<TestInterface> impl, v8::Isolate* isolate)
{
    v8::Handle<v8::Object> wrapper;
    V8Proxy* proxy = 0;
    wrapper = V8DOMWrapper::instantiateV8Object(proxy, &info, impl.get());
    if (UNLIKELY(wrapper.IsEmpty()))
        return wrapper;

    v8::Persistent<v8::Object> wrapperHandle = v8::Persistent<v8::Object>::New(wrapper);

    if (!hasDependentLifetime)
        wrapperHandle.MarkIndependent();
    V8DOMWrapper::setJSWrapperForActiveDOMObject(impl, wrapperHandle, isolate);
    return wrapper;
}

v8::Local<v8::Value> V8Proxy::evaluate(const ScriptSourceCode& source, Node* node)
{
    ASSERT(v8::Context::InContext());

    V8GCController::checkMemoryUsage();

    InspectorInstrumentationCookie cookie = InspectorInstrumentation::willEvaluateScript(m_frame, source.url().isNull() ? String() : source.url().string(), source.startLine());

    v8::Local<v8::Value> result;
    {
        v8::TryCatch tryCatch;
        tryCatch.SetVerbose(true);

        v8::Local<v8::String> code = v8ExternalString(source.source());
#if PLATFORM(CHROMIUM)
        TRACE_EVENT_BEGIN0("v8", "v8.compile");
#endif
        OwnPtr<v8::ScriptData> scriptData = precompileScript(code, source.cachedScript());

        v8::Handle<v8::Script> script = compileScript(code, source.url(), source.startPosition(), scriptData.get());
#if PLATFORM(CHROMIUM)
        TRACE_EVENT_END0("v8", "v8.compile");
        TRACE_EVENT0("v8", "v8.run");
#endif
        result = runScript(script);
    }

    InspectorInstrumentation::didEvaluateScript(cookie);

    return result;
}

v8::Handle<v8::Value> V8WebGLRenderingContext::getUniformCallback(const v8::Arguments& args)
{
INC_STATS("DOM.WebGLRenderingContext.getUniform()");

if (args.Length() != 2)
        return V8Proxy::throwNotEnoughArgumentsError();

ExceptionCode ec = 0;
WebGLRenderingContext* context = V8WebGLRenderingContext::toNative(args.Holder());
if (args.Length() > 0 && !isUndefinedOrNull(args[0]) && !V8WebGLProgram::HasInstance(args[0])) {
V8Proxy::throwTypeError();
return notHandledByInterceptor();
}
WebGLProgram* program = V8WebGLProgram::HasInstance(args[0]) ? V8WebGLProgram::toNative(v8::Handle<v8::Object>::Cast(args[0])) : 0;

if (args.Length() > 1 && !isUndefinedOrNull(args[1]) && !V8WebGLUniformLocation::HasInstance(args[1])) {
V8Proxy::throwTypeError();
return notHandledByInterceptor();
}
bool ok = false;
WebGLUniformLocation* location = toWebGLUniformLocation(args[1], ok);

WebGLGetInfo info = context->getUniform(program, location, ec);
if (ec) {
V8Proxy::setDOMException(ec, args.GetIsolate());
return v8::Undefined();
}
return toV8Object(info, args.GetIsolate());
}

static v8::Handle<v8::Value> readonlyValueAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestSerializedScriptValueInterface.readonlyValue._get");
    TestSerializedScriptValueInterface* imp = V8TestSerializedScriptValueInterface::toNative(info.Holder());
    return imp->readonlyValue() ? imp->readonlyValue()->deserialize() : v8::Handle<v8::Value>(v8::Null());
}

static v8::Handle<v8::Value> dispatchEventCallback(const v8::Arguments& args)
{
INC_STATS("DOM.TestEventTarget.dispatchEvent");
if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();
TestEventTarget* imp = V8TestEventTarget::toNative(args.Holder());
ExceptionCode ec = 0;
{
EXCEPTION_BLOCK(Event*, evt, V8Event::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Event::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
bool result = imp->dispatchEvent(evt, ec);
if (UNLIKELY(ec))
goto fail;
return v8Boolean(result);
}
fail:
V8Proxy::setDOMException(ec, args.GetIsolate());
return v8::Handle<v8::Value>();
}

static void dateSequenceAttrAttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.dateSequenceAttr._set");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    Vector<Date> v = toNativeArray<Date>(value);
    imp->setDateSequenceAttr(v);
    return;
}

static void strawberryAttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.strawberry._set");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    int v = V8int::HasInstance(value) ? V8int::toNative(v8::Handle<v8::Object>::Cast(value)) : 0;
    imp->setBlueberry(v);
    return;
}

bool ScriptController::processingUserGesture()
{
    return UserGestureIndicator::processingUserGesture();
}

v8::Persistent<v8::FunctionTemplate> V8TestNamedConstructor::GetRawTemplate()
{
    V8BindingPerIsolateData* data = V8BindingPerIsolateData::current();
    V8BindingPerIsolateData::TemplateMap::iterator result = data->rawTemplateMap().find(&info);
    if (result != data->rawTemplateMap().end())
        return result->second;

    v8::HandleScope handleScope;
    v8::Persistent<v8::FunctionTemplate> templ = createRawTemplate();
    data->rawTemplateMap().add(&info, templ);
    return templ;
}

v8::Persistent<v8::FunctionTemplate> V8TestEventConstructor::GetTemplate()
{
    V8BindingPerIsolateData* data = V8BindingPerIsolateData::current();
    V8BindingPerIsolateData::TemplateMap::iterator result = data->templateMap().find(&info);
    if (result != data->templateMap().end())
        return result->second;

    v8::HandleScope handleScope;
    v8::Persistent<v8::FunctionTemplate> templ =
        ConfigureV8TestEventConstructorTemplate(GetRawTemplate());
    data->templateMap().add(&info, templ);
    return templ;
}

static v8::Handle<v8::Value> methodReturningSequenceCallback(const v8::Arguments& args)
{
INC_STATS("DOM.TestObj.methodReturningSequence");
if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();
TestObj* imp = V8TestObj::toNative(args.Holder());
EXCEPTION_BLOCK(int, intArg, toInt32(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));
return v8Array(imp->methodReturningSequence(intArg), args.GetIsolate());
}

v8::Local<v8::Context> V8Proxy::currentContext()
{
    return v8::Context::GetCurrent();
}

void ScriptController::finishedWithEvent(Event* event)
{
    m_proxy->finishedWithEvent(event);
}

v8::Handle<v8::Value> V8DataView::getInt8Callback(const v8::Arguments& args)
{
INC_STATS("DOM.DataView.getInt8");
if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();

DataView* imp = V8DataView::toNative(args.Holder());
ExceptionCode ec = 0;
EXCEPTION_BLOCK(unsigned, byteOffset, toUInt32(args[0]));
int8_t result = imp->getInt8(byteOffset, ec);
if (UNLIKELY(ec)) {
V8Proxy::setDOMException(ec, args.GetIsolate());
return v8::Handle<v8::Value>();
}
return v8::Integer::New(result);
}

static void supplementalStr2AttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestInterface.supplementalStr2._set");
    TestInterface* imp = V8TestInterface::toNative(info.Holder());
    STRING_TO_V8PARAMETER_EXCEPTION_BLOCK_VOID(V8Parameter<>, v, value);
    TestSupplemental::setSupplementalStr2(imp, v);
    return;
}

static void stringAttrWithGetterExceptionAttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.stringAttrWithGetterException._set");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    STRING_TO_V8PARAMETER_EXCEPTION_BLOCK_VOID(V8Parameter<>, v, value);
    ExceptionCode ec = 0;
    imp->setStringAttrWithGetterException(v, ec);
    if (UNLIKELY(ec))
        V8Proxy::setDOMException(ec, info.GetIsolate());
    return;
}

v8::Handle<v8::Value> toV8(DataView* impl, v8::Isolate* isolate)
{
    if (!impl)
        return v8::Null();
    return V8DataView::wrap(impl, isolate);
}

v8::Handle<v8::Value> V8WebGLRenderingContext::getShaderParameterCallback(const v8::Arguments& args)
{
INC_STATS("DOM.WebGLRenderingContext.getShaderParameter()");

if (args.Length() != 2)
        return V8Proxy::throwNotEnoughArgumentsError();

ExceptionCode ec = 0;
WebGLRenderingContext* context = V8WebGLRenderingContext::toNative(args.Holder());
if (args.Length() > 0 && !isUndefinedOrNull(args[0]) && !V8WebGLShader::HasInstance(args[0])) {
V8Proxy::throwTypeError();
return notHandledByInterceptor();
}
WebGLShader* shader = V8WebGLShader::HasInstance(args[0]) ? V8WebGLShader::toNative(v8::Handle<v8::Object>::Cast(args[0])) : 0;
unsigned pname = toInt32(args[1]);
WebGLGetInfo info = context->getShaderParameter(shader, pname, ec);
if (ec) {
V8Proxy::setDOMException(ec, args.GetIsolate());
return v8::Undefined();
}
return toV8Object(info, args.GetIsolate());
}

static v8::Handle<v8::Value> enabledAtRuntimeAttr2AttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.enabledAtRuntimeAttr2._get");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    return v8::Integer::New(imp->enabledAtRuntimeAttr2());
}

static v8::Handle<v8::Value> readOnlyTestObjAttrAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.readOnlyTestObjAttr._get");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    RefPtr<TestObj> result = imp->readOnlyTestObjAttr();
    v8::Handle<v8::Value> wrapper = result.get() ? getDOMObjectMap(info.GetIsolate()).get(result.get()) : v8::Handle<v8::Object>();
    if (wrapper.IsEmpty()) {
        wrapper = toV8(result.get(), info.GetIsolate());
        if (!wrapper.IsEmpty())
            V8DOMWrapper::setNamedHiddenReference(info.Holder(), "readOnlyTestObjAttr", wrapper);
    }
    return wrapper;
}

ScriptController::~ScriptController()
{
}

v8::Persistent<v8::FunctionTemplate> V8TestMediaQueryListListener::GetRawTemplate()
{
    V8BindingPerIsolateData* data = V8BindingPerIsolateData::current();
    V8BindingPerIsolateData::TemplateMap::iterator result = data->rawTemplateMap().find(&info);
    if (result != data->rawTemplateMap().end())
        return result->second;

    v8::HandleScope handleScope;
    v8::Persistent<v8::FunctionTemplate> templ = createRawTemplate();
    data->rawTemplateMap().add(&info, templ);
    return templ;
}

Frame* V8Proxy::retrieveFrameForEnteredContext()
{
    v8::Handle<v8::Context> context = v8::Context::GetEntered();
    if (context.IsEmpty())
        return 0;
    return retrieveFrame(context);
}

PassScriptInstance ScriptController::createScriptInstanceForWidget(Widget* widget)
{
    ASSERT(widget);

    if (widget->isFrameView())
        return 0;

    NPObject* npObject = PlatformSupport::pluginScriptableObject(widget);

    if (!npObject)
        return 0;


    v8::Local<v8::Object> wrapper = createV8ObjectForNPObject(npObject, 0);

    m_pluginObjects.set(widget, npObject);

    return V8ScriptInstance::create(wrapper);
}

bool V8TestEventTarget::HasInstance(v8::Handle<v8::Value> value)
{
    return GetRawTemplate()->HasInstance(value);
}

static v8::Handle<v8::Value> strictFunctionCallback(const v8::Arguments& args)
{
INC_STATS("DOM.TestObj.strictFunction");
if (args.Length() < 3)
        return V8Proxy::throwNotEnoughArgumentsError();
TestObj* imp = V8TestObj::toNative(args.Holder());
ExceptionCode ec = 0;
{
STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, str, MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined));
EXCEPTION_BLOCK(float, a, static_cast<float>(MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined)->NumberValue()));
EXCEPTION_BLOCK(int, b, V8int::HasInstance(MAYBE_MISSING_PARAMETER(args, 2, DefaultIsUndefined)) ? V8int::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 2, DefaultIsUndefined))) : 0);
RefPtr<bool> result = imp->strictFunction(str, a, b, ec);
if (UNLIKELY(ec))
goto fail;
return toV8(result.release(), args.GetIsolate());
}
fail:
V8Proxy::setDOMException(ec, args.GetIsolate());
return v8::Handle<v8::Value>();
}

static void stringAttrAttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.stringAttr._set");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    STRING_TO_V8PARAMETER_EXCEPTION_BLOCK_VOID(V8Parameter<>, v, value);
    imp->setStringAttr(v);
    return;
}

NPObject* ScriptController::createScriptObjectForPluginElement(HTMLPlugInElement* plugin)
{
    if (!canExecuteScripts(NotAboutToExecuteScript))
        return createNoScriptObject();

    v8::HandleScope handleScope;
    v8::Handle<v8::Context> v8Context = V8Proxy::mainWorldContext(m_frame);
    if (v8Context.IsEmpty())
        return createNoScriptObject();
    v8::Context::Scope scope(v8Context);

    DOMWindow* window = m_frame->domWindow();
    v8::Handle<v8::Value> v8plugin = toV8(static_cast<HTMLEmbedElement*>(plugin));
    if (!v8plugin->IsObject())
        return createNoScriptObject();

    return npCreateV8ScriptObject(0, v8::Handle<v8::Object>::Cast(v8plugin), window);
}

v8::Local<v8::Value> V8Proxy::newInstance(v8::Handle<v8::Function> constructor, int argc, v8::Handle<v8::Value> args[])
{
#if PLATFORM(CHROMIUM)
    TRACE_EVENT0("v8", "v8.newInstance");
#endif

    v8::Local<v8::Value> result;
    {
        V8RecursionScope recursionScope(frame() ? frame()->document() : 0);
        result = constructor->NewInstance(argc, args);
    }

    if (v8::V8::IsDead())
        handleFatalErrorInV8();

    return result;
}

static v8::Handle<v8::Value> unsignedShortAttrAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.unsignedShortAttr._get");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    return v8::Integer::New(imp->unsignedShortAttr());
}

bool V8TestObj::HasInstance(v8::Handle<v8::Value> value)
{
    return GetRawTemplate()->HasInstance(value);
}

static v8::Handle<v8::Value> reflectedURLAttrAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.reflectedURLAttr._get");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    return v8String(imp->getURLAttribute(WebCore::HTMLNames::reflectedurlattrAttr), info.GetIsolate());
}

static v8::Handle<v8::Value> attrWithSetterExceptionAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.attrWithSetterException._get");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    return v8::Integer::New(imp->attrWithSetterException());
}

v8::Handle<v8::Value> V8WebGLRenderingContext::getExtensionCallback(const v8::Arguments& args)
{
INC_STATS("DOM.WebGLRenderingContext.getExtensionCallback()");
WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();
STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, name, args[0]);
WebGLExtension* extension = imp->getExtension(name);
return toV8Object(extension, args.Holder(), args.GetIsolate());
}

v8::Local<v8::Value> V8Proxy::instrumentedCallFunction(Frame* frame, v8::Handle<v8::Function> function, v8::Handle<v8::Object> receiver, int argc, v8::Handle<v8::Value> args[])
{
    V8GCController::checkMemoryUsage();

    if (V8RecursionScope::recursionLevel() >= kMaxRecursionDepth)
        return handleMaxRecursionDepthExceeded();

    ScriptExecutionContext* context = frame ? frame->document() : 0;

    InspectorInstrumentationCookie cookie;
    if (InspectorInstrumentation::hasFrontends() && context) {
        String resourceName;
        int lineNumber;
        resourceInfo(function, resourceName, lineNumber);
        cookie = InspectorInstrumentation::willCallFunction(context, resourceName, lineNumber);
    }

    v8::Local<v8::Value> result;
    {
#if PLATFORM(CHROMIUM)
        TRACE_EVENT1("v8", "v8.callFunction", "callsite", resourceString(function).utf8());
#endif
        V8RecursionScope recursionScope(context);
        result = function->Call(receiver, argc, args);
    }

    InspectorInstrumentation::didCallFunction(cookie);

    if (v8::V8::IsDead())
        handleFatalErrorInV8();

    return result;
}

void ScriptController::initializeThreading()
{
    static bool initializedThreading = false;
    if (!initializedThreading) {
        WTF::initializeThreading();
        WTF::initializeMainThread();
        initializedThreading = true;
    }
}

v8::Handle<v8::Value> V8SVGLength::valueAccessorGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.SVGLength.value._get");
    SVGPropertyTearOff<SVGLength>* wrapper = V8SVGLength::toNative(info.Holder());
    SVGLength& imp = wrapper->propertyReference();
    ExceptionCode ec = 0;
    SVGLengthContext lengthContext(wrapper->contextElement());
    float value = imp.value(lengthContext, ec);
    if (UNLIKELY(ec)) {
        V8Proxy::setDOMException(ec, info.GetIsolate());
        return v8::Handle<v8::Value>();
    }
    return v8::Number::New(value);
}

static v8::Handle<v8::Value> strawberryAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.strawberry._get");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    return v8::Integer::New(imp->blueberry());
}

bool V8Proxy::matchesCurrentContext()
{
    v8::Handle<v8::Context> context;
    if (V8IsolatedContext* isolatedContext = V8IsolatedContext::getEntered()) {
        context = isolatedContext->sharedContext()->get();
        if (m_frame != V8Proxy::retrieveFrame(context))
            return false;
    } else {
        windowShell()->initContextIfNeeded();
        context = windowShell()->context();
    }
    return context == context->GetCurrent();
}

static void reflectedStringAttrAttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.reflectedStringAttr._set");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    STRING_TO_V8PARAMETER_EXCEPTION_BLOCK_VOID(V8Parameter<WithNullCheck>, v, value);
    imp->setAttribute(WebCore::HTMLNames::customContentStringAttrAttr, v);
    return;
}

NPObject* ScriptController::windowScriptNPObject()
{
    if (m_wrappedWindowScriptNPObject)
        return m_wrappedWindowScriptNPObject;

    NPObject* windowScriptNPObject = 0;
    if (canExecuteScripts(NotAboutToExecuteScript)) {
        windowScriptNPObject = createScriptObject(m_frame);
        _NPN_RegisterObject(windowScriptNPObject, 0);
    } else {
        windowScriptNPObject = createNoScriptObject();
    }

    m_wrappedWindowScriptNPObject = NPObjectWrapper::create(windowScriptNPObject);
    return m_wrappedWindowScriptNPObject;
}

v8::Handle<v8::Script> V8Proxy::compileScript(v8::Handle<v8::String> code, const String& fileName, const TextPosition& scriptStartPosition, v8::ScriptData* scriptData)
{
    const uint16_t* fileNameString = fromWebCoreString(fileName);
    v8::Handle<v8::String> name = v8::String::New(fileNameString, fileName.length());
    v8::Handle<v8::Integer> line = v8::Integer::New(scriptStartPosition.m_line.zeroBasedInt());
    v8::Handle<v8::Integer> column = v8::Integer::New(scriptStartPosition.m_column.zeroBasedInt());
    v8::ScriptOrigin origin(name, line, column);
    v8::Handle<v8::Script> script = v8::Script::Compile(code, &origin, scriptData);
    return script;
}

static v8::Handle<v8::Value> readOnlyIntAttrAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.readOnlyIntAttr._get");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    return v8::Integer::New(imp->readOnlyIntAttr());
}

static v8::Handle<v8::Value> valueAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestSerializedScriptValueInterface.value._get");
    TestSerializedScriptValueInterface* imp = V8TestSerializedScriptValueInterface::toNative(info.Holder());
    return imp->value() ? imp->value()->deserialize() : v8::Handle<v8::Value>(v8::Null());
}

static v8::Handle<v8::Value> intMethodCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.TestObj.intMethod");
    TestObj* imp = V8TestObj::toNative(args.Holder());
    return v8::Integer::New(imp->intMethod());
}

static void attrWithGetterExceptionAttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.attrWithGetterException._set");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    int v = toInt32(value);
    ExceptionCode ec = 0;
    imp->setAttrWithGetterException(v, ec);
    if (UNLIKELY(ec))
        V8Proxy::setDOMException(ec, info.GetIsolate());
    return;
}

static v8::Handle<v8::Value> getObjectParameter(const v8::Arguments& args, ObjectType objectType)
{
if (args.Length() != 2)
        return V8Proxy::throwNotEnoughArgumentsError();

ExceptionCode ec = 0;
WebGLRenderingContext* context = V8WebGLRenderingContext::toNative(args.Holder());
unsigned target = toInt32(args[0]);
unsigned pname = toInt32(args[1]);
WebGLGetInfo info;
switch (objectType) {
case kBuffer:
info = context->getBufferParameter(target, pname, ec);
break;
case kRenderbuffer:
info = context->getRenderbufferParameter(target, pname, ec);
break;
case kTexture:
info = context->getTexParameter(target, pname, ec);
break;
case kVertexAttrib:
// target => index
info = context->getVertexAttrib(target, pname, ec);
break;
default:
notImplemented();
break;
}
if (ec) {
V8Proxy::setDOMException(ec, args.GetIsolate());
return v8::Undefined();
}
return toV8Object(info, args.GetIsolate());
}

static v8::Handle<v8::Value> vertexAttribAndUniformHelperf(const v8::Arguments& args,
FunctionToCall functionToCall) {
// Forms:
// * glUniform1fv(WebGLUniformLocation location, Array data);
// * glUniform1fv(WebGLUniformLocation location, Float32Array data);
// * glUniform2fv(WebGLUniformLocation location, Array data);
// * glUniform2fv(WebGLUniformLocation location, Float32Array data);
// * glUniform3fv(WebGLUniformLocation location, Array data);
// * glUniform3fv(WebGLUniformLocation location, Float32Array data);
// * glUniform4fv(WebGLUniformLocation location, Array data);
// * glUniform4fv(WebGLUniformLocation location, Float32Array data);
// * glVertexAttrib1fv(GLint index, Array data);
// * glVertexAttrib1fv(GLint index, Float32Array data);
// * glVertexAttrib2fv(GLint index, Array data);
// * glVertexAttrib2fv(GLint index, Float32Array data);
// * glVertexAttrib3fv(GLint index, Array data);
// * glVertexAttrib3fv(GLint index, Float32Array data);
// * glVertexAttrib4fv(GLint index, Array data);
// * glVertexAttrib4fv(GLint index, Float32Array data);

if (args.Length() != 2)
        return V8Proxy::throwNotEnoughArgumentsError();

bool ok = false;
int index = -1;
WebGLUniformLocation* location = 0;

if (isFunctionToCallForAttribute(functionToCall))
index = toInt32(args[0]);
else {
if (args.Length() > 0 && !isUndefinedOrNull(args[0]) && !V8WebGLUniformLocation::HasInstance(args[0])) {
V8Proxy::throwTypeError();
return notHandledByInterceptor();
}
location = toWebGLUniformLocation(args[0], ok);
}

WebGLRenderingContext* context = V8WebGLRenderingContext::toNative(args.Holder());

if (V8Float32Array::HasInstance(args[1])) {
Float32Array* array = V8Float32Array::toNative(args[1]->ToObject());
ASSERT(array != NULL);
ExceptionCode ec = 0;
switch (functionToCall) {
case kUniform1v: context->uniform1fv(location, array, ec); break;
case kUniform2v: context->uniform2fv(location, array, ec); break;
case kUniform3v: context->uniform3fv(location, array, ec); break;
case kUniform4v: context->uniform4fv(location, array, ec); break;
case kVertexAttrib1v: context->vertexAttrib1fv(index, array); break;
case kVertexAttrib2v: context->vertexAttrib2fv(index, array); break;
case kVertexAttrib3v: context->vertexAttrib3fv(index, array); break;
case kVertexAttrib4v: context->vertexAttrib4fv(index, array); break;
default: ASSERT_NOT_REACHED(); break;
}
if (ec)
V8Proxy::setDOMException(ec, args.GetIsolate());
return v8::Undefined();
}

if (args[1].IsEmpty() || !args[1]->IsArray()) {
V8Proxy::throwTypeError();
return notHandledByInterceptor();
}
v8::Handle<v8::Array> array =
v8::Local<v8::Array>::Cast(args[1]);
uint32_t len = array->Length();
float* data = jsArrayToFloatArray(array, len);
if (!data) {
// FIXME: consider different / better exception type.
V8Proxy::setDOMException(SYNTAX_ERR, args.GetIsolate());
return notHandledByInterceptor();
}
ExceptionCode ec = 0;
switch (functionToCall) {
case kUniform1v: context->uniform1fv(location, data, len, ec); break;
case kUniform2v: context->uniform2fv(location, data, len, ec); break;
case kUniform3v: context->uniform3fv(location, data, len, ec); break;
case kUniform4v: context->uniform4fv(location, data, len, ec); break;
case kVertexAttrib1v: context->vertexAttrib1fv(index, data, len); break;
case kVertexAttrib2v: context->vertexAttrib2fv(index, data, len); break;
case kVertexAttrib3v: context->vertexAttrib3fv(index, data, len); break;
case kVertexAttrib4v: context->vertexAttrib4fv(index, data, len); break;
default: ASSERT_NOT_REACHED(); break;
}
fastFree(data);
if (ec)
V8Proxy::setDOMException(ec, args.GetIsolate());
return v8::Undefined();
}

v8::Handle<v8::Value> V8WebSocket::constructorCallback(const v8::Arguments& args)
{
INC_STATS("DOM.WebSocket.Constructor");

if (!args.IsConstructCall())
return V8Proxy::throwTypeError("DOM object constructor cannot be called as a function.");

if (ConstructorMode::current() == ConstructorMode::WrapExistingObject)
return args.Holder();

if (args.Length() == 0)
        return V8Proxy::throwNotEnoughArgumentsError();

v8::TryCatch tryCatch;
v8::Handle<v8::String> urlstring = args[0]->ToString();
if (tryCatch.HasCaught())
return throwError(tryCatch.Exception(), args.GetIsolate());
if (urlstring.IsEmpty())
return V8Proxy::throwError(V8Proxy::SyntaxError, "Empty URL", args.GetIsolate());

// Get the script execution context.
ScriptExecutionContext* context = getScriptExecutionContext();
if (!context)
return V8Proxy::throwError(V8Proxy::ReferenceError, "WebSocket constructor's associated frame is not available", args.GetIsolate());

const KURL& url = context->completeURL(toWebCoreString(urlstring));

RefPtr<WebSocket> webSocket = WebSocket::create(context);
ExceptionCode ec = 0;

if (args.Length() < 2)
webSocket->connect(url, ec);
else {
v8::Local<v8::Value> protocolsValue = args[1];
if (protocolsValue->IsArray()) {
Vector<String> protocols;
v8::Local<v8::Array> protocolsArray = v8::Local<v8::Array>::Cast(protocolsValue);
for (uint32_t i = 0; i < protocolsArray->Length(); ++i) {
v8::TryCatch tryCatchProtocol;
v8::Handle<v8::String> protocol = protocolsArray->Get(v8::Int32::New(i))->ToString();
if (tryCatchProtocol.HasCaught())
return throwError(tryCatchProtocol.Exception(), args.GetIsolate());
protocols.append(toWebCoreString(protocol));
}
webSocket->connect(url, protocols, ec);
} else {
v8::TryCatch tryCatchProtocol;
v8::Handle<v8::String> protocol = protocolsValue->ToString();
if (tryCatchProtocol.HasCaught())
return throwError(tryCatchProtocol.Exception(), args.GetIsolate());
webSocket->connect(url, toWebCoreString(protocol), ec);
}
}
if (ec)
return throwError(ec, args.GetIsolate());

V8DOMWrapper::setDOMWrapper(args.Holder(), &info, webSocket.get());
V8DOMWrapper::setJSWrapperForActiveDOMObject(webSocket.release(), v8::Persistent<v8::Object>::New(args.Holder()));
return args.Holder();
}

static v8::Handle<v8::Value> unsignedShortSequenceAttrAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.unsignedShortSequenceAttr._get");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    return v8Array(imp->unsignedShortSequenceAttr(), info.GetIsolate());
}

static v8::Handle<v8::Value> orangeCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.TestObj.orange");
    TestObj* imp = V8TestObj::toNative(args.Holder());
    imp->banana();
    return v8::Handle<v8::Value>();
}

v8::Handle<v8::Value> V8DataView::constructorCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.DataView.Constructor");

    if (!args.IsConstructCall())
        return V8Proxy::throwTypeError("DOM object constructor cannot be called as a function");

    if (ConstructorMode::current() == ConstructorMode::WrapExistingObject)
        return args.Holder();

    if (!args.Length()) {
        RefPtr<DataView> dataView = DataView::create(0);
        V8DOMWrapper::setDOMWrapper(args.Holder(), &info, dataView.get());
        V8DOMWrapper::setJSWrapperForDOMObject(dataView.release(), v8::Persistent<v8::Object>::New(args.Holder()));
        return args.Holder();
    }
    if (args[0]->IsNull() || !V8ArrayBuffer::HasInstance(args[0]))
        return V8Proxy::throwTypeError();
    return constructWebGLArrayWithArrayBufferArgument<DataView, char>(args, &info, v8::kExternalByteArray, false);
}

ScriptValue ScriptController::evaluate(const ScriptSourceCode& sourceCode)
{
    String sourceURL = sourceCode.url();
    const String* savedSourceURL = m_sourceURL;
    m_sourceURL = &sourceURL;

    v8::HandleScope handleScope;
    v8::Handle<v8::Context> v8Context = V8Proxy::mainWorldContext(m_proxy->frame());
    if (v8Context.IsEmpty())
        return ScriptValue();

    v8::Context::Scope scope(v8Context);

    RefPtr<Frame> protect(m_frame);

    v8::Local<v8::Value> object = m_proxy->evaluate(sourceCode, 0);

    m_sourceURL = savedSourceURL;

    if (object.IsEmpty())
        return ScriptValue();

    return ScriptValue(object);
}

v8::Persistent<v8::FunctionTemplate> V8TestInterface::GetRawTemplate()
{
    V8BindingPerIsolateData* data = V8BindingPerIsolateData::current();
    V8BindingPerIsolateData::TemplateMap::iterator result = data->rawTemplateMap().find(&info);
    if (result != data->rawTemplateMap().end())
        return result->second;

    v8::HandleScope handleScope;
    v8::Persistent<v8::FunctionTemplate> templ = createRawTemplate();
    data->rawTemplateMap().add(&info, templ);
    return templ;
}

static v8::Handle<v8::Value> floatArrayAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.floatArray._get");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    return v8NumberArray(imp->floatArray());
}

static v8::Handle<v8::Value> V8TestNamedConstructorConstructorCallback(const v8::Arguments& args)
{
INC_STATS("DOM.TestNamedConstructor.Constructor");

if (!args.IsConstructCall())
return V8Proxy::throwTypeError("DOM object constructor cannot be called as a function.");

if (ConstructorMode::current() == ConstructorMode::WrapExistingObject)
return args.Holder();

Frame* frame = V8Proxy::retrieveFrameForCurrentContext();
if (!frame)
return V8Proxy::throwError(V8Proxy::ReferenceError, "TestNamedConstructor constructor associated frame is unavailable", args.GetIsolate());

Document* document = frame->document();

// Make sure the document is added to the DOM Node map. Otherwise, the TestNamedConstructor instance
// may end up being the only node in the map and get garbage-collected prematurely.
toV8(document, args.GetIsolate());

if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();

ExceptionCode ec = 0;
STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, str1, MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined));
STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, str2, MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined));
STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, str3, MAYBE_MISSING_PARAMETER(args, 2, DefaultIsNullString));

RefPtr<TestNamedConstructor> impl = TestNamedConstructor::createForJSConstructor(document, str1, str2, str3, ec);
v8::Handle<v8::Object> wrapper = args.Holder();
if (ec)
goto fail;

V8DOMWrapper::setDOMWrapper(wrapper, &V8TestNamedConstructorConstructor::info, impl.get());
V8DOMWrapper::setJSWrapperForActiveDOMObject(impl.release(), v8::Persistent<v8::Object>::New(wrapper), args.GetIsolate());
return args.Holder();
fail:
return throwError(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> mutablePointFunctionCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.TestObj.mutablePointFunction");
    TestObj* imp = V8TestObj::toNative(args.Holder());
    return toV8(WTF::getPtr(SVGPropertyTearOff<FloatPoint>::create(imp->mutablePointFunction())), args.GetIsolate());
}

bool ScriptController::haveInterpreter() const
{
    return m_proxy->windowShell()->isContextInitialized();
}

v8::Handle<v8::Value> V8WebGLRenderingContext::getFramebufferAttachmentParameterCallback(const v8::Arguments& args)
{
INC_STATS("DOM.WebGLRenderingContext.getFramebufferAttachmentParameter()");

if (args.Length() != 3)
        return V8Proxy::throwNotEnoughArgumentsError();

ExceptionCode ec = 0;
WebGLRenderingContext* context = V8WebGLRenderingContext::toNative(args.Holder());
unsigned target = toInt32(args[0]);
unsigned attachment = toInt32(args[1]);
unsigned pname = toInt32(args[2]);
WebGLGetInfo info = context->getFramebufferAttachmentParameter(target, attachment, pname, ec);
if (ec) {
V8Proxy::setDOMException(ec, args.GetIsolate());
return v8::Undefined();
}
return toV8Object(info, args.GetIsolate());
}

v8::Handle<v8::Value> V8DirectoryEntry::getDirectoryCallback(const v8::Arguments& args)
{
INC_STATS("DOM.DirectoryEntry.getDirectory");
DirectoryEntry* imp = V8DirectoryEntry::toNative(args.Holder());

if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();

STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<WithUndefinedOrNullCheck>, path, args[0]);
if (args.Length() <= 1) {
imp->getDirectory(path);
return v8::Handle<v8::Value>();
}
RefPtr<WebKitFlags> flags;
if (!isUndefinedOrNull(args[1]) && args[1]->IsObject()) {
EXCEPTION_BLOCK(v8::Handle<v8::Object>, object, v8::Handle<v8::Object>::Cast(args[1]));
flags = WebKitFlags::create();
v8::Local<v8::Value> v8Create = object->Get(v8::String::New("create"));
if (!v8Create.IsEmpty() && !isUndefinedOrNull(v8Create)) {
EXCEPTION_BLOCK(bool, isCreate, v8Create->BooleanValue());
flags->setCreate(isCreate);
}
v8::Local<v8::Value> v8Exclusive = object->Get(v8::String::New("exclusive"));
if (!v8Exclusive.IsEmpty() && !isUndefinedOrNull(v8Exclusive)) {
EXCEPTION_BLOCK(bool, isExclusive, v8Exclusive->BooleanValue());
flags->setExclusive(isExclusive);
}
}
RefPtr<EntryCallback> successCallback;
if (args.Length() > 2 && !args[2]->IsNull() && !args[2]->IsUndefined()) {
if (!args[2]->IsObject())
return throwError(TYPE_MISMATCH_ERR, args.GetIsolate());
successCallback = V8EntryCallback::create(args[2], getScriptExecutionContext());
}
RefPtr<ErrorCallback> errorCallback;
if (args.Length() > 3 && !args[3]->IsNull() && !args[3]->IsUndefined()) {
if (!args[3]->IsObject())
return throwError(TYPE_MISMATCH_ERR, args.GetIsolate());
errorCallback = V8ErrorCallback::create(args[3], getScriptExecutionContext());
}
imp->getDirectory(path, flags, successCallback, errorCallback);
return v8::Handle<v8::Value>();
}

v8::Persistent<v8::FunctionTemplate> V8TestInterface::GetTemplate()
{
    V8BindingPerIsolateData* data = V8BindingPerIsolateData::current();
    V8BindingPerIsolateData::TemplateMap::iterator result = data->templateMap().find(&info);
    if (result != data->templateMap().end())
        return result->second;

    v8::HandleScope handleScope;
    v8::Persistent<v8::FunctionTemplate> templ =
        ConfigureV8TestInterfaceTemplate(GetRawTemplate());
    data->templateMap().add(&info, templ);
    return templ;
}

void batchConfigureAttributes(v8::Handle<v8::ObjectTemplate> instance, 
                              v8::Handle<v8::ObjectTemplate> proto, 
                              const BatchedAttribute* attributes, 
                              size_t attributeCount)
{
    for (size_t i = 0; i < attributeCount; ++i)
        configureAttribute(instance, proto, attributes[i]);
}

static v8::Handle<v8::Value> unsignedLongSequenceAttrAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.unsignedLongSequenceAttr._get");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    return v8Array(imp->unsignedLongSequenceAttr(), info.GetIsolate());
}

static v8::Handle<v8::Value> methodWithCallbackAndOptionalArgCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.TestObj.methodWithCallbackAndOptionalArg");
    TestObj* imp = V8TestObj::toNative(args.Holder());
    RefPtr<TestCallback> callback;
    if (args.Length() > 0 && !args[0]->IsNull() && !args[0]->IsUndefined()) {
        if (!args[0]->IsFunction())
            return throwError(TYPE_MISMATCH_ERR, args.GetIsolate());
        callback = V8TestCallback::create(args[0], getScriptExecutionContext());
    }
    imp->methodWithCallbackAndOptionalArg(callback);
    return v8::Handle<v8::Value>();
}

void ScriptController::evaluateInWorld(const ScriptSourceCode& source,
                                       DOMWrapperWorld* world)
{
    Vector<ScriptSourceCode> sources;
    sources.append(source);
    evaluateInIsolatedWorld(0, sources, 0);
}

static v8::Handle<v8::Value> supplementalNodeAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestInterface.supplementalNode._get");
    TestInterface* imp = V8TestInterface::toNative(info.Holder());
    return toV8(TestSupplemental::supplementalNode(imp), info.GetIsolate());
}

static v8::Handle<v8::Value> optionsObjectCallback(const v8::Arguments& args)
{
INC_STATS("DOM.TestObj.optionsObject");
if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();
TestObj* imp = V8TestObj::toNative(args.Holder());
EXCEPTION_BLOCK(Dictionary, oo, MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined));
if (args.Length() > 0 && !oo.isUndefinedOrNull() && !oo.isObject()) {
return V8Proxy::throwTypeError("Not an object.");
}
if (args.Length() <= 1) {
imp->optionsObject(oo);
return v8::Handle<v8::Value>();
}
EXCEPTION_BLOCK(Dictionary, ooo, MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined));
if (args.Length() > 1 && !ooo.isUndefinedOrNull() && !ooo.isObject()) {
return V8Proxy::throwTypeError("Not an object.");
}
imp->optionsObject(oo, ooo);
return v8::Handle<v8::Value>();
}

bool isFunctionToCallForAttribute(FunctionToCall functionToCall)
{
    switch (functionToCall) {
    case kVertexAttrib1v:
    case kVertexAttrib2v:
    case kVertexAttrib3v:
    case kVertexAttrib4v:
        return true;
    default:
        break;
    }
    return false;
}

v8::Handle<v8::Value> V8WebGLRenderingContext::uniform3ivCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.uniform3iv()");
    return uniformHelperi(args, kUniform3v);
}

static void unsignedLongLongAttrAttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.unsignedLongLongAttr._set");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    unsigned long long v = toInt64(value);
    imp->setUnsignedLongLongAttr(WTF::getPtr(v));
    return;
}

static v8::Handle<v8::Value> reflectedCustomURLAttrAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.reflectedCustomURLAttr._get");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    return v8String(imp->getURLAttribute(WebCore::HTMLNames::customContentURLAttrAttr), info.GetIsolate());
}

static v8::Handle<v8::Value> enabledAtRuntimeMethod1Callback(const v8::Arguments& args)
{
INC_STATS("DOM.TestObj.enabledAtRuntimeMethod1");
if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();
TestObj* imp = V8TestObj::toNative(args.Holder());
EXCEPTION_BLOCK(int, intArg, V8int::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8int::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
imp->enabledAtRuntimeMethod1(intArg);
return v8::Handle<v8::Value>();
}

v8::Persistent<v8::FunctionTemplate> V8TestObj::GetTemplate()
{
    V8BindingPerIsolateData* data = V8BindingPerIsolateData::current();
    V8BindingPerIsolateData::TemplateMap::iterator result = data->templateMap().find(&info);
    if (result != data->templateMap().end())
        return result->second;

    v8::HandleScope handleScope;
    v8::Persistent<v8::FunctionTemplate> templ =
        ConfigureV8TestObjTemplate(GetRawTemplate());
    data->templateMap().add(&info, templ);
    return templ;
}

v8::Handle<v8::Value> V8XMLHttpRequest::responseTextAccessorGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.XMLHttpRequest.responsetext._get");
    XMLHttpRequest* xmlHttpRequest = V8XMLHttpRequest::toNative(info.Holder());
    ExceptionCode ec = 0;
    const String& text = xmlHttpRequest->responseText(ec);
    if (ec)
        return throwError(ec, info.GetIsolate());
    return v8String(text);
}

static v8::Handle<v8::Value> overloadedMethod4Callback(const v8::Arguments& args)
{
INC_STATS("DOM.TestObj.overloadedMethod4");
if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();
TestObj* imp = V8TestObj::toNative(args.Holder());
EXCEPTION_BLOCK(int, intArg, toInt32(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));
imp->overloadedMethod(intArg);
return v8::Handle<v8::Value>();
}

void ScriptController::disableEval()
{
    if (!m_proxy->windowShell()->initContextIfNeeded())
        return;

    v8::HandleScope handleScope;
    v8::Handle<v8::Context> v8Context = V8Proxy::mainWorldContext(m_frame);
    if (v8Context.IsEmpty())
        return;

    v8Context->AllowCodeGenerationFromStrings(false);
}

void V8TestInterface::derefObject(void* object)
{
    static_cast<TestInterface*>(object)->deref();
}

v8::Handle<v8::Value> V8WebGLRenderingContext::uniform1fvCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.uniform1fv()");
    return vertexAttribAndUniformHelperf(args, kUniform1v);
}

static v8::Handle<v8::Value> withScriptExecutionContextAndScriptStateAttributeRaisesAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.withScriptExecutionContextAndScriptStateAttributeRaises._get");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    ExceptionCode ec = 0;
    ScriptState* state = ScriptState::current();
    if (!state)
        return v8::Undefined();
    ScriptExecutionContext* scriptContext = getScriptExecutionContext();
    if (!scriptContext)
        return v8::Undefined();
    RefPtr<TestObj> v = imp->withScriptExecutionContextAndScriptStateAttributeRaises(state, scriptContext, ec);
    if (UNLIKELY(ec)) {
        V8Proxy::setDOMException(ec, info.GetIsolate());
        return v8::Handle<v8::Value>();
    }
    if (state.hadException())
        return throwError(state.exception(), info.GetIsolate());
    return toV8(v.release(), info.GetIsolate());
}

ActiveDOMObject* V8TestNamedConstructor::toActiveDOMObject(v8::Handle<v8::Object> object)
{
    return toNative(object);
}      

static void withScriptStateAttributeRaisesAttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.withScriptStateAttributeRaises._set");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    TestObj* v = V8TestObj::HasInstance(value) ? V8TestObj::toNative(v8::Handle<v8::Object>::Cast(value)) : 0;
    ExceptionCode ec = 0;
    ScriptState* state = ScriptState::current();
    if (!state)
        return;
    imp->setWithScriptStateAttributeRaises(state, WTF::getPtr(v), ec);
    if (UNLIKELY(ec))
        V8Proxy::setDOMException(ec, info.GetIsolate());
    if (state.hadException())
        throwError(state.exception(), info.GetIsolate());
    return;
}

static v8::Handle<v8::Value> longLongAttrAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.longLongAttr._get");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    return v8::Number::New(static_cast<double>(imp->longLongAttr()));
}

static v8::Handle<v8::Value> conditionalAttr3AttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.conditionalAttr3._get");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    return v8::Integer::New(imp->conditionalAttr3());
}

void ScriptController::updateDocument()
{
    m_proxy->windowShell()->updateDocument();
}

void V8Proxy::setIsolatedWorldSecurityOrigin(int worldID, PassRefPtr<SecurityOrigin> prpSecurityOriginIn)
{
    ASSERT(worldID);
    RefPtr<SecurityOrigin> securityOrigin = prpSecurityOriginIn;
    m_isolatedWorldSecurityOrigins.set(worldID, securityOrigin);
    IsolatedWorldMap::iterator iter = m_isolatedWorlds.find(worldID);
    if (iter != m_isolatedWorlds.end())
        iter->second->setSecurityOrigin(securityOrigin);
}

static void floatSequenceAttrAttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.floatSequenceAttr._set");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    Vector<float> v = toNativeArray<float>(value);
    imp->setFloatSequenceAttr(v);
    return;
}

DOMWindow* V8Proxy::retrieveWindow(v8::Handle<v8::Context> context)
{
    v8::Handle<v8::Object> global = context->Global();
    ASSERT(!global.IsEmpty());
    global = V8DOMWrapper::lookupDOMWrapper(V8DOMWindow::GetTemplate(), global);
    ASSERT(!global.IsEmpty());
    return V8DOMWindow::toNative(global);
}

static void unsignedLongSequenceAttrAttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.unsignedLongSequenceAttr._set");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    Vector<unsigned long> v = toNativeArray<unsigned long>(value);
    imp->setUnsignedLongSequenceAttr(v);
    return;
}

void V8Proxy::setDOMException(int ec, v8::Isolate* isolate)
{
    if (ec <= 0)
        return;

    ExceptionCodeDescription description(ec);

    v8::Handle<v8::Value> exception;
    switch (description.type) {
        DOM_EXCEPTION_INTERFACES_FOR_EACH(TRY_TO_CREATE_EXCEPTION)
    }

    if (exception.IsEmpty())
        return;

    v8::Handle<v8::Value> error = v8::Exception::Error(v8String(description.description, isolate));
    ASSERT(!error.IsEmpty());
    ASSERT(exception->IsObject());
    exception->ToObject()->SetAccessor(v8String("stack", isolate), DOMExceptionStackGetter, DOMExceptionStackSetter, error);

    v8::ThrowException(exception);
}

static void withScriptExecutionContextAndScriptStateAttributeAttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.withScriptExecutionContextAndScriptStateAttribute._set");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    TestObj* v = V8TestObj::HasInstance(value) ? V8TestObj::toNative(v8::Handle<v8::Object>::Cast(value)) : 0;
    ScriptState* state = ScriptState::current();
    if (!state)
        return;
    ScriptExecutionContext* scriptContext = getScriptExecutionContext();
    if (!scriptContext)
        return;
    imp->setWithScriptExecutionContextAndScriptStateAttribute(state, scriptContext, WTF::getPtr(v));
    if (state.hadException())
        throwError(state.exception(), info.GetIsolate());
    return;
}

static v8::Handle<v8::Value> overloadedMethod7Callback(const v8::Arguments& args)
{
INC_STATS("DOM.TestObj.overloadedMethod7");
if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();
TestObj* imp = V8TestObj::toNative(args.Holder());
EXCEPTION_BLOCK(RefPtr<DOMStringList>, arrayArg, v8ValueToWebCoreDOMStringList(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));
imp->overloadedMethod(arrayArg);
return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> addEventListenerCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.TestObj.addEventListener()");
    RefPtr<EventListener> listener = V8DOMWrapper::getEventListener(args[1], false, ListenerFindOrCreate);
    if (listener) {
        V8TestObj::toNative(args.Holder())->addEventListener(v8ValueToAtomicWebCoreString(args[0]), listener, args[2]->BooleanValue());
        createHiddenDependency(args.Holder(), args[1], V8TestObj::eventListenerCacheIndex);
    }
    return v8::Undefined();
}

static v8::Handle<v8::Value> hashAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.hash._get");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    return v8String(imp->hash(), info.GetIsolate());
}

Frame* V8Proxy::retrieveFrameForCallingContext()
{
    v8::Handle<v8::Context> context = v8::Context::GetCalling();
    if (context.IsEmpty())
        return 0;
    return retrieveFrame(context);
}

static v8::Handle<v8::Value> supplementalStr2AttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestInterface.supplementalStr2._get");
    TestInterface* imp = V8TestInterface::toNative(info.Holder());
    return v8String(TestSupplemental::supplementalStr2(imp), info.GetIsolate());
}

static v8::Handle<v8::Value> withScriptArgumentsAndCallStackAttributeAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.withScriptArgumentsAndCallStackAttribute._get");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    RefPtr<ScriptCallStack> callStack(createScriptCallStackForInspector());
    if (!callStack)
        return v8::Undefined();
    return toV8(imp->withScriptArgumentsAndCallStackAttribute(callStack), info.GetIsolate());
}

v8::Persistent<v8::FunctionTemplate> V8TestEventConstructor::GetRawTemplate()
{
    V8BindingPerIsolateData* data = V8BindingPerIsolateData::current();
    V8BindingPerIsolateData::TemplateMap::iterator result = data->rawTemplateMap().find(&info);
    if (result != data->rawTemplateMap().end())
        return result->second;

    v8::HandleScope handleScope;
    v8::Persistent<v8::FunctionTemplate> templ = createRawTemplate();
    data->rawTemplateMap().add(&info, templ);
    return templ;
}

v8::Local<v8::Context> V8Proxy::isolatedWorldContext(int worldId)
{
    IsolatedWorldMap::iterator iter = m_isolatedWorlds.find(worldId);
    if (iter == m_isolatedWorlds.end())
        return v8::Local<v8::Context>();
    return v8::Local<v8::Context>::New(iter->second->context());
}

static v8::Handle<v8::Value> withScriptStateAttributeRaisesAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.withScriptStateAttributeRaises._get");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    ExceptionCode ec = 0;
    ScriptState* state = ScriptState::current();
    if (!state)
        return v8::Undefined();
    RefPtr<TestObj> v = imp->withScriptStateAttributeRaises(state, ec);
    if (UNLIKELY(ec)) {
        V8Proxy::setDOMException(ec, info.GetIsolate());
        return v8::Handle<v8::Value>();
    }
    if (state.hadException())
        return throwError(state.exception(), info.GetIsolate());
    return toV8(v.release(), info.GetIsolate());
}

static v8::Handle<v8::Value> sequenceAttrAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.sequenceAttr._get");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    return v8Array(imp->sequenceAttr(), info.GetIsolate());
}

static v8::Handle<v8::Value> attrWithGetterExceptionAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.attrWithGetterException._get");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    ExceptionCode ec = 0;
    int v = imp->attrWithGetterException(ec);
    if (UNLIKELY(ec)) {
        V8Proxy::setDOMException(ec, info.GetIsolate());
        return v8::Handle<v8::Value>();
    }
    return v8::Integer::New(v);
}

static v8::Handle<v8::Value> methodWithOptionalArgCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.TestObj.methodWithOptionalArg");
    TestObj* imp = V8TestObj::toNative(args.Holder());
    if (args.Length() <= 0) {
        imp->methodWithOptionalArg();
        return v8::Handle<v8::Value>();
    }
    EXCEPTION_BLOCK(int, opt, toInt32(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));
    imp->methodWithOptionalArg(opt);
    return v8::Handle<v8::Value>();
}

v8::Handle<v8::Value> V8XMLHttpRequest::sendCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.XMLHttpRequest.send()");
    XMLHttpRequest* xmlHttpRequest = V8XMLHttpRequest::toNative(args.Holder());

    InspectorInstrumentation::willSendXMLHttpRequest(xmlHttpRequest->scriptExecutionContext(), xmlHttpRequest->url());

    ExceptionCode ec = 0;
    if (args.Length() < 1)
        xmlHttpRequest->send(ec);
    else {
        v8::Handle<v8::Value> arg = args[0];
        if (isUndefinedOrNull(arg))
            xmlHttpRequest->send(ec);
        else if (isDocumentType(arg)) {
            v8::Handle<v8::Object> object = v8::Handle<v8::Object>::Cast(arg);
            Document* document = V8Document::toNative(object);
            ASSERT(document);
            xmlHttpRequest->send(document, ec);
        } else if (V8Blob::HasInstance(arg)) {
            v8::Handle<v8::Object> object = v8::Handle<v8::Object>::Cast(arg);
            Blob* blob = V8Blob::toNative(object);
            ASSERT(blob);
            xmlHttpRequest->send(blob, ec);
        } else if (V8DOMFormData::HasInstance(arg)) {
            v8::Handle<v8::Object> object = v8::Handle<v8::Object>::Cast(arg);
            DOMFormData* domFormData = V8DOMFormData::toNative(object);
            ASSERT(domFormData);
            xmlHttpRequest->send(domFormData, ec);
#if ENABLE(WEBGL) || ENABLE(BLOB)
        } else if (V8ArrayBuffer::HasInstance(arg)) {
            v8::Handle<v8::Object> object = v8::Handle<v8::Object>::Cast(arg);
            ArrayBuffer* arrayBuffer = V8ArrayBuffer::toNative(object);
            ASSERT(arrayBuffer);
            xmlHttpRequest->send(arrayBuffer, ec);
#endif
        } else
            xmlHttpRequest->send(toWebCoreStringWithNullCheck(arg), ec);
    }

    if (ec)
        return throwError(ec, args.GetIsolate());

    return v8::Undefined();
}

static v8::Handle<v8::Value> classMethodCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.TestObj.classMethod");
    TestObj::classMethod();
    return v8::Handle<v8::Value>();
}

v8::Handle<v8::Value> V8AudioContext::constructorCallback(const v8::Arguments& args)
{
INC_STATS("DOM.AudioContext.Contructor");

if (!args.IsConstructCall())
return V8Proxy::throwTypeError("AudioContext constructor cannot be called as a function.");

if (ConstructorMode::current() == ConstructorMode::WrapExistingObject)
return args.Holder();

Frame* frame = V8Proxy::retrieveFrameForCurrentContext();
if (!frame)
return V8Proxy::throwError(V8Proxy::ReferenceError, "AudioContext constructor associated frame is unavailable", args.GetIsolate());

Document* document = frame->document();
if (!document)
return V8Proxy::throwError(V8Proxy::ReferenceError, "AudioContext constructor associated document is unavailable", args.GetIsolate());

RefPtr<AudioContext> audioContext;

if (!args.Length()) {
// Constructor for default AudioContext which talks to audio hardware.
ExceptionCode ec = 0;
audioContext = AudioContext::create(document, ec);
if (ec)
return throwError(ec, args.GetIsolate());
if (!audioContext.get())
return V8Proxy::throwError(V8Proxy::SyntaxError, "audio resources unavailable for AudioContext construction", args.GetIsolate());
} else {
// Constructor for offline (render-target) AudioContext which renders into an AudioBuffer.
// new AudioContext(in unsigned long numberOfChannels, in unsigned long numberOfFrames, in float sampleRate);
if (args.Length() < 3)
            return V8Proxy::throwNotEnoughArgumentsError();

bool ok = false;

int32_t numberOfChannels = toInt32(args[0], ok);
if (!ok || numberOfChannels <= 0 || numberOfChannels > 10)
return V8Proxy::throwError(V8Proxy::SyntaxError, "Invalid number of channels", args.GetIsolate());

int32_t numberOfFrames = toInt32(args[1], ok);
if (!ok || numberOfFrames <= 0)
return V8Proxy::throwError(V8Proxy::SyntaxError, "Invalid number of frames", args.GetIsolate());

float sampleRate = toFloat(args[2]);
if (sampleRate <= 0)
return V8Proxy::throwError(V8Proxy::SyntaxError, "Invalid sample rate", args.GetIsolate());

ExceptionCode ec = 0;
audioContext = AudioContext::createOfflineContext(document, numberOfChannels, numberOfFrames, sampleRate, ec);
if (ec)
return throwError(ec, args.GetIsolate());
}

if (!audioContext.get())
return V8Proxy::throwError(V8Proxy::SyntaxError, "Error creating AudioContext", args.GetIsolate());

// Transform the holder into a wrapper object for the audio context.
V8DOMWrapper::setDOMWrapper(args.Holder(), &info, audioContext.get());
audioContext->ref();

return args.Holder();
}

static void withScriptStateAttributeAttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.withScriptStateAttribute._set");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    int v = toInt32(value);
    ScriptState* state = ScriptState::current();
    if (!state)
        return;
    imp->setWithScriptStateAttribute(state, v);
    if (state.hadException())
        throwError(state.exception(), info.GetIsolate());
    return;
}

static v8::Handle<v8::Value> cachedAttribute1AttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.cachedAttribute1._get");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    RefPtr<any> result = imp->cachedAttribute1();
    v8::Handle<v8::Value> wrapper = result.get() ? getDOMObjectMap(info.GetIsolate()).get(result.get()) : v8::Handle<v8::Object>();
    if (wrapper.IsEmpty()) {
        wrapper = toV8(result.get(), info.GetIsolate());
        if (!wrapper.IsEmpty())
            V8DOMWrapper::setNamedHiddenReference(info.Holder(), "cachedAttribute1", wrapper);
    }
    return wrapper;
}

static v8::Handle<v8::Value> mutablePointAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.mutablePoint._get");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    return toV8(WTF::getPtr(SVGStaticPropertyTearOff<TestObj, FloatPoint>::create(imp, imp->mutablePoint(), &TestObj::updateMutablePoint)), info.GetIsolate());
}

static v8::Handle<v8::Value> withScriptExecutionContextAttributeAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.withScriptExecutionContextAttribute._get");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    ScriptExecutionContext* scriptContext = getScriptExecutionContext();
    if (!scriptContext)
        return v8::Undefined();
    return toV8(imp->withScriptExecutionContextAttribute(scriptContext), info.GetIsolate());
}

v8::Persistent<v8::FunctionTemplate> V8TestActiveDOMObject::GetRawTemplate()
{
    V8BindingPerIsolateData* data = V8BindingPerIsolateData::current();
    V8BindingPerIsolateData::TemplateMap::iterator result = data->rawTemplateMap().find(&info);
    if (result != data->rawTemplateMap().end())
        return result->second;

    v8::HandleScope handleScope;
    v8::Persistent<v8::FunctionTemplate> templ = createRawTemplate();
    data->rawTemplateMap().add(&info, templ);
    return templ;
}

static v8::Handle<v8::Value> portsAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestSerializedScriptValueInterface.ports._get");
    TestSerializedScriptValueInterface* imp = V8TestSerializedScriptValueInterface::toNative(info.Holder());
    MessagePortArray* ports = imp->ports();
    if (!ports)
        return v8::Array::New(0);
    MessagePortArray portsCopy(*ports);
    v8::Local<v8::Array> portArray = v8::Array::New(portsCopy.size());
    for (size_t i = 0; i < portsCopy.size(); ++i)
        portArray->Set(v8::Integer::New(i), toV8(portsCopy[i].get(), info.GetIsolate()));
    return portArray;
}

static void reflectedBooleanAttrAttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.reflectedBooleanAttr._set");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    bool v = value->BooleanValue();
    imp->setBooleanAttribute(WebCore::HTMLNames::reflectedbooleanattrAttr, v);
    return;
}

bool V8TestNamedConstructor::HasInstance(v8::Handle<v8::Value> value)
{
    return GetRawTemplate()->HasInstance(value);
}

v8::Persistent<v8::FunctionTemplate> V8TestNamedConstructor::GetTemplate()
{
    V8BindingPerIsolateData* data = V8BindingPerIsolateData::current();
    V8BindingPerIsolateData::TemplateMap::iterator result = data->templateMap().find(&info);
    if (result != data->templateMap().end())
        return result->second;

    v8::HandleScope handleScope;
    v8::Persistent<v8::FunctionTemplate> templ =
        ConfigureV8TestNamedConstructorTemplate(GetRawTemplate());
    data->templateMap().add(&info, templ);
    return templ;
}

static v8::Handle<v8::Value> testObjAttrAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.testObjAttr._get");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    return toV8(imp->testObjAttr(), info.GetIsolate());
}

static void mutablePointAttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.mutablePoint._set");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    RefPtr<SVGPropertyTearOff<FloatPoint> > v = V8SVGPoint::HasInstance(value) ? V8SVGPoint::toNative(v8::Handle<v8::Object>::Cast(value)) : 0;
    imp->setMutablePoint(WTF::getPtr(v));
    return;
}

static v8::Handle<v8::Value> objMethodWithArgsCallback(const v8::Arguments& args)
{
INC_STATS("DOM.TestObj.objMethodWithArgs");
if (args.Length() < 3)
        return V8Proxy::throwNotEnoughArgumentsError();
TestObj* imp = V8TestObj::toNative(args.Holder());
EXCEPTION_BLOCK(int, intArg, toInt32(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));
STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, strArg, MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined));
EXCEPTION_BLOCK(TestObj*, objArg, V8TestObj::HasInstance(MAYBE_MISSING_PARAMETER(args, 2, DefaultIsUndefined)) ? V8TestObj::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 2, DefaultIsUndefined))) : 0);
return toV8(imp->objMethodWithArgs(intArg, strArg, objArg), args.GetIsolate());
}

v8::Handle<v8::Value> V8WebGLRenderingContext::getTexParameterCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.getTexParameter()");
    return getObjectParameter(args, kTexture);
}

static void reflectedURLAttrAttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.reflectedURLAttr._set");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    STRING_TO_V8PARAMETER_EXCEPTION_BLOCK_VOID(V8Parameter<WithNullCheck>, v, value);
    imp->setAttribute(WebCore::HTMLNames::reflectedurlattrAttr, v);
    return;
}

static v8::Handle<v8::Value> intMethodWithArgsCallback(const v8::Arguments& args)
{
INC_STATS("DOM.TestObj.intMethodWithArgs");
if (args.Length() < 3)
        return V8Proxy::throwNotEnoughArgumentsError();
TestObj* imp = V8TestObj::toNative(args.Holder());
EXCEPTION_BLOCK(int, intArg, toInt32(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));
STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, strArg, MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined));
EXCEPTION_BLOCK(TestObj*, objArg, V8TestObj::HasInstance(MAYBE_MISSING_PARAMETER(args, 2, DefaultIsUndefined)) ? V8TestObj::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 2, DefaultIsUndefined))) : 0);
return v8::Integer::New(imp->intMethodWithArgs(intArg, strArg, objArg));
}

static v8::Handle<v8::Value> unsignedIntSequenceAttrAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.unsignedIntSequenceAttr._get");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    return v8Array(imp->unsignedIntSequenceAttr(), info.GetIsolate());
}

static v8::Handle<v8::Value> methodWithOptionalStringCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.TestObj.methodWithOptionalString");
    TestObj* imp = V8TestObj::toNative(args.Holder());
    if (args.Length() <= 0) {
        imp->methodWithOptionalString();
        return v8::Handle<v8::Value>();
    }
    STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, str, MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined));
    imp->methodWithOptionalString(str);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> withScriptStateObjCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.TestObj.withScriptStateObj");
    TestObj* imp = V8TestObj::toNative(args.Holder());
    EmptyScriptState state;
    RefPtr<TestObj> result = imp->withScriptStateObj(&state);
    if (state.hadException())
        return throwError(state.exception(), args.GetIsolate());
    return toV8(result.release(), args.GetIsolate());
}

static v8::Handle<v8::Value> stringAttrWithSetterExceptionAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.stringAttrWithSetterException._get");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    return v8String(imp->stringAttrWithSetterException(), info.GetIsolate());
}

static NPObject* createScriptObject(Frame* frame)
{
    v8::HandleScope handleScope;
    v8::Handle<v8::Context> v8Context = V8Proxy::mainWorldContext(frame);
    if (v8Context.IsEmpty())
        return createNoScriptObject();

    v8::Context::Scope scope(v8Context);
    DOMWindow* window = frame->domWindow();
    v8::Handle<v8::Value> global = toV8(window);
    ASSERT(global->IsObject());
    return npCreateV8ScriptObject(0, v8::Handle<v8::Object>::Cast(global), window);
}

v8::Handle<v8::Value> V8SVGLength::convertToSpecifiedUnitsCallback(const v8::Arguments& args)
{
INC_STATS("DOM.SVGLength.convertToSpecifiedUnits");
SVGPropertyTearOff<SVGLength>* wrapper = V8SVGLength::toNative(args.Holder());
if (wrapper->role() == AnimValRole) {
V8Proxy::setDOMException(NO_MODIFICATION_ALLOWED_ERR, args.GetIsolate());
return v8::Handle<v8::Value>();
}

if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();

SVGLength& imp = wrapper->propertyReference();
ExceptionCode ec = 0;
EXCEPTION_BLOCK(int, unitType, toUInt32(args[0]));
SVGLengthContext lengthContext(wrapper->contextElement());
imp.convertToSpecifiedUnits(unitType, lengthContext, ec);
if (UNLIKELY(ec))
V8Proxy::setDOMException(ec, args.GetIsolate());
else
wrapper->commitChange();
return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> uniformHelperi(const v8::Arguments& args,
FunctionToCall functionToCall) {
// Forms:
// * glUniform1iv(GLUniformLocation location, Array data);
// * glUniform1iv(GLUniformLocation location, Int32Array data);
// * glUniform2iv(GLUniformLocation location, Array data);
// * glUniform2iv(GLUniformLocation location, Int32Array data);
// * glUniform3iv(GLUniformLocation location, Array data);
// * glUniform3iv(GLUniformLocation location, Int32Array data);
// * glUniform4iv(GLUniformLocation location, Array data);
// * glUniform4iv(GLUniformLocation location, Int32Array data);

if (args.Length() != 2)
        return V8Proxy::throwNotEnoughArgumentsError();

WebGLRenderingContext* context = V8WebGLRenderingContext::toNative(args.Holder());
if (args.Length() > 0 && !isUndefinedOrNull(args[0]) && !V8WebGLUniformLocation::HasInstance(args[0])) {
V8Proxy::throwTypeError();
return notHandledByInterceptor();
}
bool ok = false;
WebGLUniformLocation* location = toWebGLUniformLocation(args[0], ok);

if (V8Int32Array::HasInstance(args[1])) {
Int32Array* array = V8Int32Array::toNative(args[1]->ToObject());
ASSERT(array != NULL);
ExceptionCode ec = 0;
switch (functionToCall) {
case kUniform1v: context->uniform1iv(location, array, ec); break;
case kUniform2v: context->uniform2iv(location, array, ec); break;
case kUniform3v: context->uniform3iv(location, array, ec); break;
case kUniform4v: context->uniform4iv(location, array, ec); break;
default: ASSERT_NOT_REACHED(); break;
}
if (ec)
V8Proxy::setDOMException(ec, args.GetIsolate());
return v8::Undefined();
}

if (args[1].IsEmpty() || !args[1]->IsArray()) {
V8Proxy::throwTypeError();
return notHandledByInterceptor();
}
v8::Handle<v8::Array> array =
v8::Local<v8::Array>::Cast(args[1]);
uint32_t len = array->Length();
int* data = jsArrayToIntArray(array, len);
if (!data) {
// FIXME: consider different / better exception type.
V8Proxy::setDOMException(SYNTAX_ERR, args.GetIsolate());
return notHandledByInterceptor();
}
ExceptionCode ec = 0;
switch (functionToCall) {
case kUniform1v: context->uniform1iv(location, data, len, ec); break;
case kUniform2v: context->uniform2iv(location, data, len, ec); break;
case kUniform3v: context->uniform3iv(location, data, len, ec); break;
case kUniform4v: context->uniform4iv(location, data, len, ec); break;
default: ASSERT_NOT_REACHED(); break;
}
fastFree(data);
if (ec)
V8Proxy::setDOMException(ec, args.GetIsolate());
return v8::Undefined();
}

static void strictFloatAttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.strictFloat._set");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    float v = static_cast<float>(value->NumberValue());
    imp->setStrictFloat(v);
    return;
}

static v8::Handle<v8::Value> stringAttrWithGetterExceptionAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.stringAttrWithGetterException._get");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    ExceptionCode ec = 0;
    String v = imp->stringAttrWithGetterException(ec);
    if (UNLIKELY(ec)) {
        V8Proxy::setDOMException(ec, info.GetIsolate());
        return v8::Handle<v8::Value>();
    }
    return v8String(v, info.GetIsolate());
}

void V8TestEventTarget::derefObject(void* object)
{
    static_cast<TestEventTarget*>(object)->deref();
}

static v8::Handle<v8::Value> withScriptStateVoidCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.TestObj.withScriptStateVoid");
    TestObj* imp = V8TestObj::toNative(args.Holder());
    EmptyScriptState state;
    imp->withScriptStateVoid(&state);
    if (state.hadException())
        return throwError(state.exception(), args.GetIsolate());
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> fooCallback(const v8::Arguments& args)
{
INC_STATS("DOM.Float64Array.foo");
if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();
Float64Array* imp = V8Float64Array::toNative(args.Holder());
EXCEPTION_BLOCK(Float32Array*, array, V8Float32Array::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Float32Array::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
return toV8(imp->foo(array), args.GetIsolate());
}

static v8::Persistent<v8::FunctionTemplate> ConfigureV8TestInterfaceTemplate(v8::Persistent<v8::FunctionTemplate> desc)
{
    desc->ReadOnlyPrototype();

    v8::Local<v8::Signature> defaultSignature;
    defaultSignature = configureTemplate(desc, "TestInterface", v8::Persistent<v8::FunctionTemplate>(), V8TestInterface::internalFieldCount,
        TestInterfaceAttrs, WTF_ARRAY_LENGTH(TestInterfaceAttrs),
        TestInterfaceCallbacks, WTF_ARRAY_LENGTH(TestInterfaceCallbacks));
    UNUSED_PARAM(defaultSignature); // In some cases, it will not be used.
    desc->SetCallHandler(V8TestInterface::constructorCallback);
    v8::Local<v8::ObjectTemplate> instance = desc->InstanceTemplate();
    v8::Local<v8::ObjectTemplate> proto = desc->PrototypeTemplate();
    UNUSED_PARAM(instance); // In some cases, it will not be used.
    UNUSED_PARAM(proto); // In some cases, it will not be used.
    

    const int supplementalMethod2Argc = 2;
    v8::Handle<v8::FunctionTemplate> supplementalMethod2Argv[supplementalMethod2Argc] = { v8::Handle<v8::FunctionTemplate>(), V8TestObj::GetRawTemplate() };
    v8::Handle<v8::Signature> supplementalMethod2Signature = v8::Signature::New(desc, supplementalMethod2Argc, supplementalMethod2Argv);
#if ENABLE(Condition11) || ENABLE(Condition12)
    proto->Set(v8::String::New("supplementalMethod2"), v8::FunctionTemplate::New(TestInterfaceV8Internal::supplementalMethod2Callback, v8::Handle<v8::Value>(), supplementalMethod2Signature));
#endif // ENABLE(Condition11) || ENABLE(Condition12)
#if ENABLE(Condition11) || ENABLE(Condition12)
    desc->Set(v8::String::New("supplementalMethod4"), v8::FunctionTemplate::New(TestInterfaceV8Internal::supplementalMethod4Callback, v8::Handle<v8::Value>(), v8::Local<v8::Signature>()));
#endif // ENABLE(Condition11) || ENABLE(Condition12)
    batchConfigureConstants(desc, proto, TestInterfaceConsts, WTF_ARRAY_LENGTH(TestInterfaceConsts));

    desc->Set(getToStringName(), getToStringTemplate());
    return desc;
}

void ScriptController::bindToWindowObject(Frame* frame, const String& key, NPObject* object)
{
    v8::HandleScope handleScope;

    v8::Handle<v8::Context> v8Context = V8Proxy::mainWorldContext(frame);
    if (v8Context.IsEmpty())
        return;

    v8::Context::Scope scope(v8Context);

    v8::Handle<v8::Object> value = createV8ObjectForNPObject(object, 0);

    v8::Handle<v8::Object> global = v8Context->Global();
    global->Set(v8String(key), value);
}

static v8::Handle<v8::Value> getSVGDocumentCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.TestObj.getSVGDocument");
    TestObj* imp = V8TestObj::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    if (!V8BindingSecurity::shouldAllowAccessToNode(V8BindingState::Only(), imp->getSVGDocument(ec)))
        return v8::Handle<v8::Value>(v8::Null());
    RefPtr<SVGDocument> result = imp->getSVGDocument(ec);
    if (UNLIKELY(ec))
        goto fail;
    return toV8(result.release(), args.GetIsolate());
    }
    fail:
    V8Proxy::setDOMException(ec, args.GetIsolate());
    return v8::Handle<v8::Value>();
}

static void floatArrayAttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.floatArray._set");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    Vector<float> v = v8NumberArrayToVector<float>(value);
    imp->setFloatArray(v);
    return;
}

static void reflectedIntegralAttrAttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.reflectedIntegralAttr._set");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    int v = toInt32(value);
    imp->setIntegralAttribute(WebCore::HTMLNames::reflectedintegralattrAttr, v);
    return;
}

static v8::Handle<v8::Value> overloadedMethod11Callback(const v8::Arguments& args)
{
INC_STATS("DOM.TestObj.overloadedMethod11");
if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();
EXCEPTION_BLOCK(int, arg, toInt32(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));
TestObj::overloadedMethod1(arg);
return v8::Handle<v8::Value>();
}

static void intAttrAttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.intAttr._set");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    int v = toInt32(value);
    imp->setIntAttr(v);
    return;
}

static v8::Handle<v8::Value> objMethodCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.TestObj.objMethod");
    TestObj* imp = V8TestObj::toNative(args.Holder());
    return toV8(imp->objMethod(), args.GetIsolate());
}

v8::Handle<v8::Value> V8DataView::setUint8Callback(const v8::Arguments& args)
{
INC_STATS("DOM.DataView.setUint8");
if (args.Length() < 2)
        return V8Proxy::throwNotEnoughArgumentsError();

DataView* imp = V8DataView::toNative(args.Holder());
ExceptionCode ec = 0;
EXCEPTION_BLOCK(unsigned, byteOffset, toUInt32(args[0]));
EXCEPTION_BLOCK(int, value, toInt32(args[1]));
imp->setUint8(byteOffset, static_cast<uint8_t>(value), ec);
if (UNLIKELY(ec))
V8Proxy::setDOMException(ec, args.GetIsolate());
return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> intSequenceAttrAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.intSequenceAttr._get");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    return v8Array(imp->intSequenceAttr(), info.GetIsolate());
}

v8::Handle<v8::Value> V8Intent::constructorCallback(const v8::Arguments& args)
{
INC_STATS("DOM.Intent.Constructor");

if (!args.IsConstructCall())
return V8Proxy::throwTypeError("DOM object constructor cannot be called as a function.");

if (ConstructorMode::current() == ConstructorMode::WrapExistingObject)
return args.Holder();
if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();
if (args.Length() == 1) {
// Use the dictionary constructor. This block will return if the
// argument isn't a valid Dictionary.
EXCEPTION_BLOCK(Dictionary, options, args[0]);
ExceptionCode ec = 0;
RefPtr<Intent> impl = Intent::create(ScriptState::current(), options, ec);
if (ec)
return throwError(ec, args.GetIsolate());

v8::Handle<v8::Object> wrapper = args.Holder();
V8DOMWrapper::setDOMWrapper(wrapper, &info, impl.get());
V8DOMWrapper::setJSWrapperForDOMObject(impl.release(), v8::Persistent<v8::Object>::New(wrapper));
return wrapper;
}

ExceptionCode ec = 0;
STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, action, MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined));
STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, type, MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined));
MessagePortArray messagePortArrayTransferList;
ArrayBufferArray arrayBufferArrayTransferList;
if (args.Length() > 3) {
if (!extractTransferables(args[3], messagePortArrayTransferList, arrayBufferArrayTransferList))
return V8Proxy::throwTypeError("Could not extract transferables");
}
bool dataDidThrow = false;
RefPtr<SerializedScriptValue> data = SerializedScriptValue::create(args[2], &messagePortArrayTransferList, &arrayBufferArrayTransferList, dataDidThrow);
if (dataDidThrow)
return throwError(DATA_CLONE_ERR, args.GetIsolate());

RefPtr<Intent> impl = Intent::create(action, type, data, messagePortArrayTransferList, ec);
if (ec)
return throwError(ec, args.GetIsolate());

v8::Handle<v8::Object> wrapper = args.Holder();
V8DOMWrapper::setDOMWrapper(wrapper, &info, impl.get());
V8DOMWrapper::setJSWrapperForDOMObject(impl.release(), v8::Persistent<v8::Object>::New(wrapper));
return wrapper;
}

v8::Handle<v8::Value> V8WebGLRenderingContext::vertexAttrib1fvCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.vertexAttrib1fv()");
    return vertexAttribAndUniformHelperf(args, kVertexAttrib1v);
}

void ScriptController::cleanupScriptObjectsForPlugin(Widget* nativeHandle)
{
    PluginObjectMap::iterator it = m_pluginObjects.find(nativeHandle);
    if (it == m_pluginObjects.end())
        return;
    _NPN_UnregisterObject(it->second);
    _NPN_ReleaseObject(it->second);
    m_pluginObjects.remove(it);
}

static v8::Handle<v8::Value> withScriptArgumentsAndCallStackCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.TestObj.withScriptArgumentsAndCallStack");
    TestObj* imp = V8TestObj::toNative(args.Holder());
    RefPtr<ScriptArguments> scriptArguments(createScriptArguments(args, 0));
    RefPtr<ScriptCallStack> callStack(createScriptCallStackForInspector());
    if (!callStack)
        return v8::Undefined();
    imp->withScriptArgumentsAndCallStack(scriptArguments, callStack);
    return v8::Handle<v8::Value>();
}

static void shortSequenceAttrAttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.shortSequenceAttr._set");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    Vector<short> v = toNativeArray<short>(value);
    imp->setShortSequenceAttr(v);
    return;
}

bool V8TestEventConstructor::HasInstance(v8::Handle<v8::Value> value)
{
    return GetRawTemplate()->HasInstance(value);
}

void ScriptController::updateSecurityOrigin()
{
    m_proxy->windowShell()->updateSecurityOrigin();
}

static void supplementalNodeAttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestInterface.supplementalNode._set");
    TestInterface* imp = V8TestInterface::toNative(info.Holder());
    Node* v = V8Node::HasInstance(value) ? V8Node::toNative(v8::Handle<v8::Object>::Cast(value)) : 0;
    TestSupplemental::setSupplementalNode(imp, WTF::getPtr(v));
    return;
}

static void longLongAttrAttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.longLongAttr._set");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    long long v = toInt64(value);
    imp->setLongLongAttr(WTF::getPtr(v));
    return;
}

static v8::Handle<v8::Value> removeEventListenerCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.TestEventTarget.removeEventListener()");
    RefPtr<EventListener> listener = V8DOMWrapper::getEventListener(args[1], false, ListenerFindOnly);
    if (listener) {
        V8TestEventTarget::toNative(args.Holder())->removeEventListener(v8ValueToAtomicWebCoreString(args[0]), listener.get(), args[2]->BooleanValue());
        removeHiddenDependency(args.Holder(), args[1], V8TestEventTarget::eventListenerCacheIndex);
    }
    return v8::Undefined();
}

v8::Local<v8::Context> toV8Context(ScriptExecutionContext* context, const WorldContextHandle& worldContext)
{
    if (context->isDocument()) {
        if (V8Proxy* proxy = V8Proxy::retrieve(context))
            return worldContext.adjustedContext(proxy);
#if ENABLE(WORKERS)
    } else if (context->isWorkerContext()) {
        if (WorkerContextExecutionProxy* proxy = static_cast<WorkerContext*>(context)->script()->proxy())
            return proxy->context();
#endif
    }
    return v8::Local<v8::Context>();
}

v8::Local<v8::Value> V8Proxy::runScript(v8::Handle<v8::Script> script)
{
    if (script.IsEmpty())
        return notHandledByInterceptor();

    V8GCController::checkMemoryUsage();
    if (V8RecursionScope::recursionLevel() >= kMaxRecursionDepth)
        return handleMaxRecursionDepthExceeded();

    if (handleOutOfMemory())
        ASSERT(script.IsEmpty());

    RefPtr<Frame> protect(frame());

    v8::Local<v8::Value> result;
    v8::TryCatch tryCatch;
    tryCatch.SetVerbose(true);
    {
        V8RecursionScope recursionScope(frame()->document());
        result = script->Run();
    }

    if (handleOutOfMemory())
        ASSERT(result.IsEmpty());

    if (tryCatch.HasCaught()) {
        ASSERT(result.IsEmpty());
        return notHandledByInterceptor();
    }

    if (result.IsEmpty())
        return notHandledByInterceptor();

    if (v8::V8::IsDead())
        handleFatalErrorInV8();

    return result;
}

v8::Handle<v8::Value> V8WebGLRenderingContext::vertexAttrib3fvCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.vertexAttrib3fv()");
    return vertexAttribAndUniformHelperf(args, kVertexAttrib3v);
}

static v8::Handle<v8::Value> attr2AttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestEventConstructor.attr2._get");
    TestEventConstructor* imp = V8TestEventConstructor::toNative(info.Holder());
    return v8String(imp->attr2(), info.GetIsolate());
}

static v8::Persistent<v8::FunctionTemplate> ConfigureV8TestActiveDOMObjectTemplate(v8::Persistent<v8::FunctionTemplate> desc)
{
    desc->ReadOnlyPrototype();

    v8::Local<v8::Signature> defaultSignature;
    defaultSignature = configureTemplate(desc, "TestActiveDOMObject", v8::Persistent<v8::FunctionTemplate>(), V8TestActiveDOMObject::internalFieldCount,
        TestActiveDOMObjectAttrs, WTF_ARRAY_LENGTH(TestActiveDOMObjectAttrs),
        0, 0);
    UNUSED_PARAM(defaultSignature); // In some cases, it will not be used.
    v8::Local<v8::ObjectTemplate> instance = desc->InstanceTemplate();
    v8::Local<v8::ObjectTemplate> proto = desc->PrototypeTemplate();
    UNUSED_PARAM(instance); // In some cases, it will not be used.
    UNUSED_PARAM(proto); // In some cases, it will not be used.
    instance->SetAccessCheckCallbacks(V8TestActiveDOMObject::namedSecurityCheck, V8TestActiveDOMObject::indexedSecurityCheck, v8::External::Wrap(&V8TestActiveDOMObject::info));

    const int excitingFunctionArgc = 1;
    v8::Handle<v8::FunctionTemplate> excitingFunctionArgv[excitingFunctionArgc] = { V8Node::GetRawTemplate() };
    v8::Handle<v8::Signature> excitingFunctionSignature = v8::Signature::New(desc, excitingFunctionArgc, excitingFunctionArgv);
    proto->Set(v8::String::New("excitingFunction"), v8::FunctionTemplate::New(TestActiveDOMObjectV8Internal::excitingFunctionCallback, v8::Handle<v8::Value>(), excitingFunctionSignature));

    proto->SetAccessor(v8::String::New("postMessage"), TestActiveDOMObjectV8Internal::postMessageAttrGetter, 0, v8::Handle<v8::Value>(), v8::ALL_CAN_READ, static_cast<v8::PropertyAttribute>(v8::DontDelete | v8::ReadOnly));

    desc->Set(getToStringName(), getToStringTemplate());
    return desc;
}

v8::Handle<v8::Value> V8Proxy::checkNewLegal(const v8::Arguments& args)
{
    if (ConstructorMode::current() == ConstructorMode::CreateNewObject)
        return throwError(TypeError, "Illegal constructor", args.GetIsolate());

    return args.This();
}

static void valueAttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestSerializedScriptValueInterface.value._set");
    TestSerializedScriptValueInterface* imp = V8TestSerializedScriptValueInterface::toNative(info.Holder());
    RefPtr<SerializedScriptValue> v = SerializedScriptValue::create(value, info.GetIsolate());
    imp->setValue(WTF::getPtr(v));
    return;
}

v8::Persistent<v8::FunctionTemplate> V8TestEventTarget::GetTemplate()
{
    V8BindingPerIsolateData* data = V8BindingPerIsolateData::current();
    V8BindingPerIsolateData::TemplateMap::iterator result = data->templateMap().find(&info);
    if (result != data->templateMap().end())
        return result->second;

    v8::HandleScope handleScope;
    v8::Persistent<v8::FunctionTemplate> templ =
        ConfigureV8TestEventTargetTemplate(GetRawTemplate());
    data->templateMap().add(&info, templ);
    return templ;
}

static v8::Handle<v8::Value> dateSequenceAttrAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.dateSequenceAttr._get");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    return v8Array(imp->dateSequenceAttr(), info.GetIsolate());
}

static void unsignedIntSequenceAttrAttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.unsignedIntSequenceAttr._set");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    Vector<unsigned int> v = toNativeArray<unsigned int>(value);
    imp->setUnsignedIntSequenceAttr(v);
    return;
}

static v8::Handle<v8::Value> longLongSequenceAttrAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.longLongSequenceAttr._get");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    return v8Array(imp->longLongSequenceAttr(), info.GetIsolate());
}

static v8::Handle<v8::Value> reflectedCustomIntegralAttrAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.reflectedCustomIntegralAttr._get");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    return v8::Integer::New(imp->getIntegralAttribute(WebCore::HTMLNames::customContentIntegralAttrAttr));
}

static v8::Persistent<v8::FunctionTemplate> ConfigureV8TestSerializedScriptValueInterfaceTemplate(v8::Persistent<v8::FunctionTemplate> desc)
{
    desc->ReadOnlyPrototype();

    v8::Local<v8::Signature> defaultSignature;
    defaultSignature = configureTemplate(desc, "TestSerializedScriptValueInterface", v8::Persistent<v8::FunctionTemplate>(), V8TestSerializedScriptValueInterface::internalFieldCount,
        TestSerializedScriptValueInterfaceAttrs, WTF_ARRAY_LENGTH(TestSerializedScriptValueInterfaceAttrs),
        TestSerializedScriptValueInterfaceCallbacks, WTF_ARRAY_LENGTH(TestSerializedScriptValueInterfaceCallbacks));
    UNUSED_PARAM(defaultSignature); // In some cases, it will not be used.
    desc->SetCallHandler(V8TestSerializedScriptValueInterface::constructorCallback);
    v8::Local<v8::ObjectTemplate> instance = desc->InstanceTemplate();
    v8::Local<v8::ObjectTemplate> proto = desc->PrototypeTemplate();
    UNUSED_PARAM(instance); // In some cases, it will not be used.
    UNUSED_PARAM(proto); // In some cases, it will not be used.
    

    desc->Set(getToStringName(), getToStringTemplate());
    return desc;
}

static v8::Handle<v8::Value> overloadedMethod12Callback(const v8::Arguments& args)
{
INC_STATS("DOM.TestObj.overloadedMethod12");
if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();
STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, type, MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined));
TestObj::overloadedMethod1(type);
return v8::Handle<v8::Value>();
}

Frame* V8Proxy::retrieveFrame(v8::Handle<v8::Context> context)
{
    DOMWindow* window = retrieveWindow(context);
    Frame* frame = window->frame();
    if (frame && frame->domWindow() == window)
        return frame;
    return 0;
}

static v8::Handle<v8::Value> methodWithExceptionCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.TestObj.methodWithException");
    TestObj* imp = V8TestObj::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    imp->methodWithException(ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8::Handle<v8::Value>();
    }
    fail:
    V8Proxy::setDOMException(ec, args.GetIsolate());
    return v8::Handle<v8::Value>();
}

void V8TestSerializedScriptValueInterface::derefObject(void* object)
{
    static_cast<TestSerializedScriptValueInterface*>(object)->deref();
}

static void withScriptExecutionContextAttributeRaisesAttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.withScriptExecutionContextAttributeRaises._set");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    TestObj* v = V8TestObj::HasInstance(value) ? V8TestObj::toNative(v8::Handle<v8::Object>::Cast(value)) : 0;
    ExceptionCode ec = 0;
    ScriptExecutionContext* scriptContext = getScriptExecutionContext();
    if (!scriptContext)
        return;
    imp->setWithScriptExecutionContextAttributeRaises(scriptContext, WTF::getPtr(v), ec);
    if (UNLIKELY(ec))
        V8Proxy::setDOMException(ec, info.GetIsolate());
    return;
}

void V8SVGLength::valueAccessorSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.SVGLength.value._set");
    SVGPropertyTearOff<SVGLength>* wrapper = V8SVGLength::toNative(info.Holder());
    if (wrapper->role() == AnimValRole) {
        V8Proxy::setDOMException(NO_MODIFICATION_ALLOWED_ERR, info.GetIsolate());
        return;
    }

    if (!isUndefinedOrNull(value) && !value->IsNumber() && !value->IsBoolean()) {
        V8Proxy::throwTypeError();
        return;
    }

    SVGLength& imp = wrapper->propertyReference();
    ExceptionCode ec = 0;
    SVGLengthContext lengthContext(wrapper->contextElement());
    imp.setValue(static_cast<float>(value->NumberValue()), lengthContext, ec);
    if (UNLIKELY(ec))
        V8Proxy::setDOMException(ec, info.GetIsolate());
    else
        wrapper->commitChange();
}

static v8::Handle<v8::Value> readOnlyStringAttrAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.readOnlyStringAttr._get");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    return v8String(imp->readOnlyStringAttr(), info.GetIsolate());
}

v8::Handle<v8::Value> V8Proxy::throwTypeError(const char* message)
{
     return throwError(TypeError, (message ? message : "Type error"));
 }

static v8::Handle<v8::Value> contentDocumentAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.contentDocument._get");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    if (!V8BindingSecurity::shouldAllowAccessToNode(V8BindingState::Only(), imp->contentDocument()))
        return v8::Handle<v8::Value>(v8::Null());

    return toV8(imp->contentDocument(), info.GetIsolate());
}

static v8::Handle<v8::Value> conditionalMethod1Callback(const v8::Arguments& args)
{
    INC_STATS("DOM.TestObj.conditionalMethod1");
    TestObj* imp = V8TestObj::toNative(args.Holder());
    return v8String(imp->conditionalMethod1(), args.GetIsolate());
}

static void reflectedStringAttrAttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.reflectedStringAttr._set");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    STRING_TO_V8PARAMETER_EXCEPTION_BLOCK_VOID(V8Parameter<WithNullCheck>, v, value);
    imp->setAttribute(WebCore::HTMLNames::reflectedstringattrAttr, v);
    return;
}

v8::Handle<v8::Value> V8WebGLRenderingContext::uniform3fvCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.uniform3fv()");
    return vertexAttribAndUniformHelperf(args, kUniform3v);
}

v8::Persistent<v8::FunctionTemplate> V8TestActiveDOMObject::GetTemplate()
{
    V8BindingPerIsolateData* data = V8BindingPerIsolateData::current();
    V8BindingPerIsolateData::TemplateMap::iterator result = data->templateMap().find(&info);
    if (result != data->templateMap().end())
        return result->second;

    v8::HandleScope handleScope;
    v8::Persistent<v8::FunctionTemplate> templ =
        ConfigureV8TestActiveDOMObjectTemplate(GetRawTemplate());
    data->templateMap().add(&info, templ);
    return templ;
}

Frame* ScriptController::retrieveFrameForEnteredContext()
{
    return V8Proxy::retrieveFrameForEnteredContext();
}

static void cachedValueAttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestSerializedScriptValueInterface.cachedValue._set");
    TestSerializedScriptValueInterface* imp = V8TestSerializedScriptValueInterface::toNative(info.Holder());
    RefPtr<SerializedScriptValue> v = SerializedScriptValue::create(value, info.GetIsolate());
    imp->setCachedValue(WTF::getPtr(v));
    info.Holder()->DeleteHiddenValue(v8::String::NewSymbol("cachedValue")); // Invalidate the cached value.
    return;
}

static v8::Handle<v8::Value> excitingFunctionCallback(const v8::Arguments& args)
{
INC_STATS("DOM.TestActiveDOMObject.excitingFunction");
if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();
TestActiveDOMObject* imp = V8TestActiveDOMObject::toNative(args.Holder());
if (!V8BindingSecurity::canAccessFrame(V8BindingState::Only(), imp->frame(), true))
return v8::Handle<v8::Value>();
EXCEPTION_BLOCK(Node*, nextChild, V8Node::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Node::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
imp->excitingFunction(nextChild);
return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> reflectedStringAttrAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.reflectedStringAttr._get");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    return v8String(imp->getAttribute(WebCore::HTMLNames::customContentStringAttrAttr), info.GetIsolate());
}

v8::Persistent<v8::FunctionTemplate> V8TestSerializedScriptValueInterface::GetRawTemplate()
{
    V8BindingPerIsolateData* data = V8BindingPerIsolateData::current();
    V8BindingPerIsolateData::TemplateMap::iterator result = data->rawTemplateMap().find(&info);
    if (result != data->rawTemplateMap().end())
        return result->second;

    v8::HandleScope handleScope;
    v8::Persistent<v8::FunctionTemplate> templ = createRawTemplate();
    data->rawTemplateMap().add(&info, templ);
    return templ;
}

static v8::Handle<v8::Value> cachedValueAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestSerializedScriptValueInterface.cachedValue._get");
    v8::Handle<v8::String> propertyName = v8::String::NewSymbol("cachedValue");
    v8::Handle<v8::Value> value = info.Holder()->GetHiddenValue(propertyName);
    if (!value.IsEmpty())
        return value;
    TestSerializedScriptValueInterface* imp = V8TestSerializedScriptValueInterface::toNative(info.Holder());
    SerializedScriptValue* serialized = imp->cachedValue();
    value = serialized ? serialized->deserialize() : v8::Handle<v8::Value>(v8::Null());
    info.Holder()->SetHiddenValue(propertyName, value);
    return value;
}

static v8::Handle<v8::Value> uniformMatrixHelper(const v8::Arguments& args,
int matrixSize)
{
// Forms:
// * glUniformMatrix2fv(GLint location, GLboolean transpose, Array data);
// * glUniformMatrix2fv(GLint location, GLboolean transpose, Float32Array data);
// * glUniformMatrix3fv(GLint location, GLboolean transpose, Array data);
// * glUniformMatrix3fv(GLint location, GLboolean transpose, Float32Array data);
// * glUniformMatrix4fv(GLint location, GLboolean transpose, Array data);
// * glUniformMatrix4fv(GLint location, GLboolean transpose, Float32Array data);
//
// FIXME: need to change to accept Float32Array as well.
if (args.Length() != 3)
        return V8Proxy::throwNotEnoughArgumentsError();

WebGLRenderingContext* context = V8WebGLRenderingContext::toNative(args.Holder());

if (args.Length() > 0 && !isUndefinedOrNull(args[0]) && !V8WebGLUniformLocation::HasInstance(args[0])) {
V8Proxy::throwTypeError();
return notHandledByInterceptor();
}
bool ok = false;
WebGLUniformLocation* location = toWebGLUniformLocation(args[0], ok);

bool transpose = args[1]->BooleanValue();
if (V8Float32Array::HasInstance(args[2])) {
Float32Array* array = V8Float32Array::toNative(args[2]->ToObject());
ASSERT(array != NULL);
ExceptionCode ec = 0;
switch (matrixSize) {
case 2: context->uniformMatrix2fv(location, transpose, array, ec); break;
case 3: context->uniformMatrix3fv(location, transpose, array, ec); break;
case 4: context->uniformMatrix4fv(location, transpose, array, ec); break;
default: ASSERT_NOT_REACHED(); break;
}
if (ec)
V8Proxy::setDOMException(ec, args.GetIsolate());
return v8::Undefined();
}

if (args[2].IsEmpty() || !args[2]->IsArray()) {
V8Proxy::throwTypeError();
return notHandledByInterceptor();
}
v8::Handle<v8::Array> array =
v8::Local<v8::Array>::Cast(args[2]);
uint32_t len = array->Length();
float* data = jsArrayToFloatArray(array, len);
if (!data) {
// FIXME: consider different / better exception type.
V8Proxy::setDOMException(SYNTAX_ERR, args.GetIsolate());
return notHandledByInterceptor();
}
ExceptionCode ec = 0;
switch (matrixSize) {
case 2: context->uniformMatrix2fv(location, transpose, data, len, ec); break;
case 3: context->uniformMatrix3fv(location, transpose, data, len, ec); break;
case 4: context->uniformMatrix4fv(location, transpose, data, len, ec); break;
default: ASSERT_NOT_REACHED(); break;
}
fastFree(data);
if (ec)
V8Proxy::setDOMException(ec, args.GetIsolate());
return v8::Undefined();
}

static v8::Handle<v8::Value> withScriptStateAttributeAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.withScriptStateAttribute._get");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    ScriptState* state = ScriptState::current();
    if (!state)
        return v8::Undefined();
    return v8::Integer::New(imp->withScriptStateAttribute(state));
}

static v8::Handle<v8::Value> overloadedMethod1Callback(const v8::Arguments& args)
{
    INC_STATS("DOM.TestObj.overloadedMethod1");
    if (args.Length() == 1)
        return overloadedMethod11Callback(args);
    if ((args.Length() == 1 && (args[0]->IsNull() || args[0]->IsUndefined() || args[0]->IsString() || args[0]->IsObject())))
        return overloadedMethod12Callback(args);
    V8Proxy::throwTypeError();
    return notHandledByInterceptor();
}

v8::Local<v8::Value> V8Proxy::callFunction(v8::Handle<v8::Function> function, v8::Handle<v8::Object> receiver, int argc, v8::Handle<v8::Value> args[])
{
    RefPtr<Frame> protect(frame());
    return V8Proxy::instrumentedCallFunction(frame(), function, receiver, argc, args);
}

void ScriptController::evaluateInIsolatedWorld(unsigned worldID, const Vector<ScriptSourceCode>& sources, Vector<ScriptValue>* results)
{
    evaluateInIsolatedWorld(worldID, sources, 0, results);
}

static void createAttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.create._set");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    bool v = value->BooleanValue();
    imp->setCreate(v);
    return;
}

static void attrWithSetterExceptionAttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.attrWithSetterException._set");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    int v = toInt32(value);
    ExceptionCode ec = 0;
    imp->setAttrWithSetterException(v, ec);
    if (UNLIKELY(ec))
        V8Proxy::setDOMException(ec, info.GetIsolate());
    return;
}

void ScriptController::collectIsolatedContexts(Vector<std::pair<ScriptState*, SecurityOrigin*> >& result)
{
    m_proxy->collectIsolatedContexts(result);
}

static bool isDocumentType(v8::Handle<v8::Value> value)
{
    return V8Document::HasInstance(value) || V8HTMLDocument::HasInstance(value);
}

static v8::Persistent<v8::FunctionTemplate> ConfigureV8TestMediaQueryListListenerTemplate(v8::Persistent<v8::FunctionTemplate> desc)
{
    desc->ReadOnlyPrototype();

    v8::Local<v8::Signature> defaultSignature;
    defaultSignature = configureTemplate(desc, "TestMediaQueryListListener", v8::Persistent<v8::FunctionTemplate>(), V8TestMediaQueryListListener::internalFieldCount,
        0, 0,
        TestMediaQueryListListenerCallbacks, WTF_ARRAY_LENGTH(TestMediaQueryListListenerCallbacks));
    UNUSED_PARAM(defaultSignature); // In some cases, it will not be used.
    v8::Local<v8::ObjectTemplate> instance = desc->InstanceTemplate();
    v8::Local<v8::ObjectTemplate> proto = desc->PrototypeTemplate();
    UNUSED_PARAM(instance); // In some cases, it will not be used.
    UNUSED_PARAM(proto); // In some cases, it will not be used.
    

    desc->Set(getToStringName(), getToStringTemplate());
    return desc;
}

bool fillTestEventConstructorInit(TestEventConstructorInit& eventInit, const Dictionary& options)
{
    options.get("attr2", eventInit.attr2);
    return true;
}

static v8::Handle<v8::Value> idbKeyCallback(const v8::Arguments& args)
{
INC_STATS("DOM.TestObj.idbKey");
if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();
TestObj* imp = V8TestObj::toNative(args.Holder());
EXCEPTION_BLOCK(RefPtr<IDBKey>, key, createIDBKeyFromValue(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));
imp->idbKey(key.get());
return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> withScriptExecutionContextAndScriptStateObjExceptionCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.TestObj.withScriptExecutionContextAndScriptStateObjException");
    TestObj* imp = V8TestObj::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    EmptyScriptState state;
    ScriptExecutionContext* scriptContext = getScriptExecutionContext();
    if (!scriptContext)
        return v8::Undefined();
    RefPtr<TestObj> result = imp->withScriptExecutionContextAndScriptStateObjException(&state, scriptContext, ec);
    if (UNLIKELY(ec))
        goto fail;
    if (state.hadException())
        return throwError(state.exception(), args.GetIsolate());
    return toV8(result.release(), args.GetIsolate());
    }
    fail:
    V8Proxy::setDOMException(ec, args.GetIsolate());
    return v8::Handle<v8::Value>();
}

v8::Handle<v8::Object> V8TestActiveDOMObject::wrapSlow(PassRefPtr<TestActiveDOMObject> impl, v8::Isolate* isolate)
{
    v8::Handle<v8::Object> wrapper;
    V8Proxy* proxy = 0;
    if (impl->frame()) {
        proxy = V8Proxy::retrieve(impl->frame());
        if (proxy)
            proxy->windowShell()->initContextIfNeeded();
    }

    v8::Handle<v8::Context> context;
    if (proxy && !proxy->matchesCurrentContext()) {
        context = proxy->context();
        if (!context.IsEmpty())
            context->Enter();
    }
    wrapper = V8DOMWrapper::instantiateV8Object(proxy, &info, impl.get());
    if (!context.IsEmpty())
        context->Exit();
    if (UNLIKELY(wrapper.IsEmpty()))
        return wrapper;

    v8::Persistent<v8::Object> wrapperHandle = v8::Persistent<v8::Object>::New(wrapper);

    if (!hasDependentLifetime)
        wrapperHandle.MarkIndependent();
    V8DOMWrapper::setJSWrapperForDOMObject(impl, wrapperHandle, isolate);
    return wrapper;
}

void V8Proxy::clearForClose()
{
    resetIsolatedWorlds();
    windowShell()->clearForClose();
}

v8::Persistent<v8::FunctionTemplate> V8TestMediaQueryListListener::GetTemplate()
{
    V8BindingPerIsolateData* data = V8BindingPerIsolateData::current();
    V8BindingPerIsolateData::TemplateMap::iterator result = data->templateMap().find(&info);
    if (result != data->templateMap().end())
        return result->second;

    v8::HandleScope handleScope;
    v8::Persistent<v8::FunctionTemplate> templ =
        ConfigureV8TestMediaQueryListListenerTemplate(GetRawTemplate());
    data->templateMap().add(&info, templ);
    return templ;
}

static v8::Handle<v8::Value> toV8Object(WebGLExtension* extension, v8::Handle<v8::Object> contextObject, v8::Isolate* isolate)
{
    if (!extension)
        return v8::Null();
    v8::Handle<v8::Value> extensionObject;
    const char* referenceName = 0;
    switch (extension->getName()) {
    case WebGLExtension::WebKitWebGLLoseContextName:
        extensionObject = toV8(static_cast<WebGLLoseContext*>(extension), isolate);
        referenceName = "webKitWebGLLoseContextName";
        break;
    case WebGLExtension::EXTTextureFilterAnisotropicName:
        extensionObject = toV8(static_cast<EXTTextureFilterAnisotropic*>(extension), isolate);
        referenceName = "extTextureFilterAnisotropicName";
        break;
    case WebGLExtension::OESStandardDerivativesName:
        extensionObject = toV8(static_cast<OESStandardDerivatives*>(extension), isolate);
        referenceName = "oesStandardDerivativesName";
        break;
    case WebGLExtension::OESTextureFloatName:
        extensionObject = toV8(static_cast<OESTextureFloat*>(extension), isolate);
        referenceName = "oesTextureFloatName";
        break;
    case WebGLExtension::OESVertexArrayObjectName:
        extensionObject = toV8(static_cast<OESVertexArrayObject*>(extension), isolate);
        referenceName = "oesVertexArrayObjectName";
        break;
    case WebGLExtension::WebGLDebugRendererInfoName:
        extensionObject = toV8(static_cast<WebGLDebugRendererInfo*>(extension), isolate);
        referenceName = "webGLDebugRendererInfoName";
        break;
    case WebGLExtension::WebGLDebugShadersName:
        extensionObject = toV8(static_cast<WebGLDebugShaders*>(extension), isolate);
        referenceName = "webGLDebugShadersName";
        break;
    case WebGLExtension::WebKitWebGLCompressedTextureS3TCName:
        extensionObject = toV8(static_cast<WebGLCompressedTextureS3TC*>(extension), isolate);
        referenceName = "webKitWebGLCompressedTextureS3TCName";
        break;
    }
    ASSERT(!extensionObject.IsEmpty());
    V8DOMWrapper::setNamedHiddenReference(contextObject, referenceName, extensionObject);
    return extensionObject;
}

void V8TestNamedConstructor::derefObject(void* object)
{
    static_cast<TestNamedConstructor*>(object)->deref();
}

static v8::Handle<v8::Value> multiTransferListCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.TestSerializedScriptValueInterface.multiTransferList");
    TestSerializedScriptValueInterface* imp = V8TestSerializedScriptValueInterface::toNative(args.Holder());
    if (args.Length() <= 0) {
        imp->multiTransferList();
        return v8::Handle<v8::Value>();
    }
    MessagePortArray messagePortArrayTx;
    ArrayBufferArray arrayBufferArrayTx;
    if (args.Length() > 1) {
        if (!extractTransferables(args[1], messagePortArrayTx, arrayBufferArrayTx))
            return V8Proxy::throwTypeError("Could not extract transferables");
    }
    bool firstDidThrow = false;
    RefPtr<SerializedScriptValue> first = SerializedScriptValue::create(args[0], &messagePortArrayTx, &arrayBufferArrayTx, firstDidThrow, args.GetIsolate());
    if (firstDidThrow)
        return v8::Undefined();
    if (args.Length() <= 1) {
        imp->multiTransferList(first);
        return v8::Handle<v8::Value>();
    }
    if (args.Length() <= 2) {
        imp->multiTransferList(first, messagePortArrayTx);
        return v8::Handle<v8::Value>();
    }
    MessagePortArray messagePortArrayTxx;
    ArrayBufferArray arrayBufferArrayTxx;
    if (args.Length() > 3) {
        if (!extractTransferables(args[3], messagePortArrayTxx, arrayBufferArrayTxx))
            return V8Proxy::throwTypeError("Could not extract transferables");
    }
    bool secondDidThrow = false;
    RefPtr<SerializedScriptValue> second = SerializedScriptValue::create(args[2], &messagePortArrayTxx, &arrayBufferArrayTxx, secondDidThrow, args.GetIsolate());
    if (secondDidThrow)
        return v8::Undefined();
    if (args.Length() <= 3) {
        imp->multiTransferList(first, messagePortArrayTx, second);
        return v8::Handle<v8::Value>();
    }
    imp->multiTransferList(first, messagePortArrayTx, second, messagePortArrayTxx);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> methodWithOptionalStringIsUndefinedCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.TestObj.methodWithOptionalStringIsUndefined");
    TestObj* imp = V8TestObj::toNative(args.Holder());
    STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, str, MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined));
    imp->methodWithOptionalStringIsUndefined(str);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> shortSequenceAttrAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.shortSequenceAttr._get");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    return v8Array(imp->shortSequenceAttr(), info.GetIsolate());
}

void ScriptController::clearScriptObjects()
{
    PluginObjectMap::iterator it = m_pluginObjects.begin();
    for (; it != m_pluginObjects.end(); ++it) {
        _NPN_UnregisterObject(it->second);
        _NPN_ReleaseObject(it->second);
    }
    m_pluginObjects.clear();

#if ENABLE(NETSCAPE_PLUGIN_API)
    if (m_wrappedWindowScriptNPObject) {
        NPObjectWrapper* windowScriptObjectWrapper = NPObjectWrapper::getWrapper(m_wrappedWindowScriptNPObject);
        ASSERT(windowScriptObjectWrapper);

        NPObject* windowScriptNPObject = NPObjectWrapper::getUnderlyingNPObject(m_wrappedWindowScriptNPObject);
        ASSERT(windowScriptNPObject);
        _NPN_DeallocateObject(windowScriptNPObject);

        windowScriptObjectWrapper->clear();
        _NPN_ReleaseObject(m_wrappedWindowScriptNPObject);
        m_wrappedWindowScriptNPObject = 0;
    }
#endif
}

static v8::Handle<v8::Value> longSequenceAttrAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.longSequenceAttr._get");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    return v8Array(imp->longSequenceAttr(), info.GetIsolate());
}

v8::Handle<v8::Value> V8WebGLRenderingContext::getSupportedExtensionsCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.getSupportedExtensionsCallback()");
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    if (imp->isContextLost())
        return v8::Null();

    Vector<String> value = imp->getSupportedExtensions();
    v8::Local<v8::Array> array = v8::Array::New(value.size());
    for (size_t ii = 0; ii < value.size(); ++ii)
        array->Set(v8::Integer::New(ii), v8::String::New(fromWebCoreString(value[ii]), value[ii].length()));
    return array;
}

v8::Handle<v8::Value> V8WebGLRenderingContext::uniform4fvCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.uniform4fv()");
    return vertexAttribAndUniformHelperf(args, kUniform4v);
}

ScriptController::ScriptController(Frame* frame)
    : m_frame(frame)
    , m_sourceURL(0)
    , m_paused(false)
    , m_proxy(adoptPtr(new V8Proxy(frame)))
#if ENABLE(NETSCAPE_PLUGIN_API)
    , m_wrappedWindowScriptNPObject(0)
#endif
{
}

v8::Handle<v8::Value> V8WebGLRenderingContext::vertexAttrib4fvCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.vertexAttrib4fv()");
    return vertexAttribAndUniformHelperf(args, kVertexAttrib4v);
}

static v8::Persistent<v8::FunctionTemplate> ConfigureV8TestEventConstructorTemplate(v8::Persistent<v8::FunctionTemplate> desc)
{
    desc->ReadOnlyPrototype();

    v8::Local<v8::Signature> defaultSignature;
    defaultSignature = configureTemplate(desc, "TestEventConstructor", v8::Persistent<v8::FunctionTemplate>(), V8TestEventConstructor::internalFieldCount,
        TestEventConstructorAttrs, WTF_ARRAY_LENGTH(TestEventConstructorAttrs),
        0, 0);
    UNUSED_PARAM(defaultSignature); // In some cases, it will not be used.
    desc->SetCallHandler(V8TestEventConstructor::constructorCallback);
    

    desc->Set(getToStringName(), getToStringTemplate());
    return desc;
}

v8::Persistent<v8::FunctionTemplate> V8TestNamedConstructorConstructor::GetTemplate()
{
    static v8::Persistent<v8::FunctionTemplate> cachedTemplate;
    if (!cachedTemplate.IsEmpty())
        return cachedTemplate;

    v8::HandleScope scope;
    v8::Local<v8::FunctionTemplate> result = v8::FunctionTemplate::New(V8TestNamedConstructorConstructorCallback);

    v8::Local<v8::ObjectTemplate> instance = result->InstanceTemplate();
    instance->SetInternalFieldCount(V8TestNamedConstructor::internalFieldCount);
    result->SetClassName(v8::String::New("TestNamedConstructor"));
    result->Inherit(V8TestNamedConstructor::GetTemplate());

    cachedTemplate = v8::Persistent<v8::FunctionTemplate>::New(result);
    return cachedTemplate;
}

static v8::Handle<v8::Value> methodCallback(const v8::Arguments& args)
{
INC_STATS("DOM.TestMediaQueryListListener.method");
if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();
TestMediaQueryListListener* imp = V8TestMediaQueryListListener::toNative(args.Holder());
EXCEPTION_BLOCK(RefPtr<MediaQueryListListener>, listener, MediaQueryListListener::create(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));
imp->method(listener);
return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> conditionalMethod3Callback(const v8::Arguments& args)
{
    INC_STATS("DOM.TestObj.conditionalMethod3");
    TestObj* imp = V8TestObj::toNative(args.Holder());
    imp->conditionalMethod3();
    return v8::Handle<v8::Value>();
}

const V8Extensions& V8Proxy::extensions()
{
    return staticExtensionsList();
}

static v8::Local<v8::Value> handleMaxRecursionDepthExceeded()
{
    V8Proxy::throwError(V8Proxy::RangeError, "Maximum call stack size exceeded.");
    return v8::Local<v8::Value>();
}

static v8::Handle<v8::Value> supplementalMethod2Callback(const v8::Arguments& args)
{
INC_STATS("DOM.TestInterface.supplementalMethod2");
if (args.Length() < 2)
        return V8Proxy::throwNotEnoughArgumentsError();
TestInterface* imp = V8TestInterface::toNative(args.Holder());
ExceptionCode ec = 0;
{
STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, strArg, MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined));
EXCEPTION_BLOCK(TestObj*, objArg, V8TestObj::HasInstance(MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined)) ? V8TestObj::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined))) : 0);
ScriptExecutionContext* scriptContext = getScriptExecutionContext();
if (!scriptContext)
return v8::Undefined();
RefPtr<TestObj> result = TestSupplemental::supplementalMethod2(imp, scriptContext, strArg, objArg, ec);
if (UNLIKELY(ec))
goto fail;
return toV8(result.release(), args.GetIsolate());
}
fail:
V8Proxy::setDOMException(ec, args.GetIsolate());
return v8::Handle<v8::Value>();
}

static void reflectedUnsignedIntegralAttrAttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.reflectedUnsignedIntegralAttr._set");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    unsigned v = toUInt32(value);
    imp->setUnsignedIntegralAttribute(WebCore::HTMLNames::reflectedunsignedintegralattrAttr, v);
    return;
}

void V8Proxy::resetIsolatedWorlds()
{
    for (IsolatedWorldMap::iterator iter = m_isolatedWorlds.begin();
         iter != m_isolatedWorlds.end(); ++iter) {
        iter->second->destroy();
    }
    m_isolatedWorlds.clear();
    m_isolatedWorldSecurityOrigins.clear();
}

static v8::Handle<v8::Value> withScriptExecutionContextAndScriptStateCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.TestObj.withScriptExecutionContextAndScriptState");
    TestObj* imp = V8TestObj::toNative(args.Holder());
    EmptyScriptState state;
    ScriptExecutionContext* scriptContext = getScriptExecutionContext();
    if (!scriptContext)
        return v8::Undefined();
    imp->withScriptExecutionContextAndScriptState(&state, scriptContext);
    if (state.hadException())
        return throwError(state.exception(), args.GetIsolate());
    return v8::Handle<v8::Value>();
}

v8::Handle<v8::Object> V8TestSerializedScriptValueInterface::wrapSlow(PassRefPtr<TestSerializedScriptValueInterface> impl, v8::Isolate* isolate)
{
    v8::Handle<v8::Object> wrapper;
    V8Proxy* proxy = 0;
    wrapper = V8DOMWrapper::instantiateV8Object(proxy, &info, impl.get());
    if (UNLIKELY(wrapper.IsEmpty()))
        return wrapper;

    v8::Persistent<v8::Object> wrapperHandle = v8::Persistent<v8::Object>::New(wrapper);

    if (!hasDependentLifetime)
        wrapperHandle.MarkIndependent();
    V8DOMWrapper::setJSWrapperForDOMObject(impl, wrapperHandle, isolate);
    return wrapper;
}

static v8::Persistent<v8::FunctionTemplate> ConfigureV8TestCustomNamedGetterTemplate(v8::Persistent<v8::FunctionTemplate> desc)
{
    desc->ReadOnlyPrototype();

    v8::Local<v8::Signature> defaultSignature;
    defaultSignature = configureTemplate(desc, "TestCustomNamedGetter", v8::Persistent<v8::FunctionTemplate>(), V8TestCustomNamedGetter::internalFieldCount,
        0, 0,
        TestCustomNamedGetterCallbacks, WTF_ARRAY_LENGTH(TestCustomNamedGetterCallbacks));
    UNUSED_PARAM(defaultSignature); // In some cases, it will not be used.
    v8::Local<v8::ObjectTemplate> instance = desc->InstanceTemplate();
    v8::Local<v8::ObjectTemplate> proto = desc->PrototypeTemplate();
    UNUSED_PARAM(instance); // In some cases, it will not be used.
    UNUSED_PARAM(proto); // In some cases, it will not be used.
    
    desc->InstanceTemplate()->SetNamedPropertyHandler(V8TestCustomNamedGetter::namedPropertyGetter, 0, 0, 0, 0);

    desc->Set(getToStringName(), getToStringTemplate());
    return desc;
}

static V8Extensions& staticExtensionsList()
{
    DEFINE_STATIC_LOCAL(V8Extensions, extensions, ());
    return extensions;
}

v8::Handle<v8::Value> V8TestEventConstructor::constructorCallback(const v8::Arguments& args)
{
INC_STATS("DOM.TestEventConstructor.Constructor");

if (!args.IsConstructCall())
return V8Proxy::throwTypeError("DOM object constructor cannot be called as a function.");

if (ConstructorMode::current() == ConstructorMode::WrapExistingObject)
return args.Holder();

if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();

STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, type, args[0]);
TestEventConstructorInit eventInit;
if (args.Length() >= 2) {
EXCEPTION_BLOCK(Dictionary, options, args[1]);
if (!fillTestEventConstructorInit(eventInit, options))
return v8::Undefined();
}

RefPtr<TestEventConstructor> event = TestEventConstructor::create(type, eventInit);

V8DOMWrapper::setDOMWrapper(args.Holder(), &info, event.get());
V8DOMWrapper::setJSWrapperForDOMObject(event.release(), v8::Persistent<v8::Object>::New(args.Holder()), args.GetIsolate());
return args.Holder();
}

static void unsignedShortAttrAttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.unsignedShortAttr._set");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    int v = toUInt32(value);
    imp->setUnsignedShortAttr(v);
    return;
}

bool V8Proxy::setContextDebugId(int debugId)
{
    ASSERT(debugId > 0);
    v8::HandleScope scope;
    v8::Handle<v8::Context> context = windowShell()->context();
    if (context.IsEmpty())
        return false;
    if (!context->GetData()->IsUndefined())
        return false;

    v8::Context::Scope contextScope(context);

    char buffer[32];
    snprintf(buffer, sizeof(buffer), "page,%d", debugId);
    context->SetData(v8::String::New(buffer));

    return true;
}

v8::Handle<v8::Value> V8WebGLRenderingContext::getBufferParameterCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.getBufferParameter()");
    return getObjectParameter(args, kBuffer);
}

void ScriptController::evaluateInIsolatedWorld(unsigned worldID, const Vector<ScriptSourceCode>& sources, int extensionGroup, Vector<ScriptValue>* results)
{
    v8::HandleScope handleScope;
    if (results) {
        Vector<v8::Local<v8::Value> > v8Results;
        m_proxy->evaluateInIsolatedWorld(worldID, sources, extensionGroup, &v8Results);
        Vector<v8::Local<v8::Value> >::iterator itr;
        for (itr = v8Results.begin(); itr != v8Results.end(); ++itr)
            results->append(ScriptValue(*itr));
    } else
        m_proxy->evaluateInIsolatedWorld(worldID, sources, extensionGroup, 0);
}

void V8TestActiveDOMObject::derefObject(void* object)
{
    static_cast<TestActiveDOMObject*>(object)->deref();
}

static void reflectedCustomURLAttrAttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.reflectedCustomURLAttr._set");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    STRING_TO_V8PARAMETER_EXCEPTION_BLOCK_VOID(V8Parameter<WithNullCheck>, v, value);
    imp->setAttribute(WebCore::HTMLNames::customContentURLAttrAttr, v);
    return;
}

static v8::Handle<v8::Value> methodWithOptionalStringIsNullStringCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.TestObj.methodWithOptionalStringIsNullString");
    TestObj* imp = V8TestObj::toNative(args.Holder());
    STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, str, MAYBE_MISSING_PARAMETER(args, 0, DefaultIsNullString));
    imp->methodWithOptionalStringIsNullString(str);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> unsignedLongLongSequenceAttrAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.unsignedLongLongSequenceAttr._get");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    return v8Array(imp->unsignedLongLongSequenceAttr(), info.GetIsolate());
}

 v8::Local<v8::Context> V8Proxy::context(Frame* frame)
{
    v8::Local<v8::Context> context = V8Proxy::mainWorldContext(frame);
    if (context.IsEmpty())
        return v8::Local<v8::Context>();

    if (V8IsolatedContext* isolatedContext = V8IsolatedContext::getEntered()) {
        context = v8::Local<v8::Context>::New(isolatedContext->context());
        if (frame != V8Proxy::retrieveFrame(context))
            return v8::Local<v8::Context>();
    }

    return context;
}

static v8::Handle<v8::Value> strictFloatAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.strictFloat._get");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    return v8::Number::New(imp->strictFloat());
}

static void idAttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.id._set");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    int v = toInt32(value);
    imp->setId(v);
    return;
}

void V8TestEventConstructor::derefObject(void* object)
{
    static_cast<TestEventConstructor*>(object)->deref();
}

TextPosition ScriptController::eventHandlerPosition() const
{
    ScriptableDocumentParser* parser = m_frame->document()->scriptableDocumentParser();
    if (parser)
        return parser->textPosition();
    return TextPosition::minimumPosition();
}

void V8Proxy::collectIsolatedContexts(Vector<std::pair<ScriptState*, SecurityOrigin*> >& result)
{
    v8::HandleScope handleScope;
    for (IsolatedWorldMap::iterator it = m_isolatedWorlds.begin(); it != m_isolatedWorlds.end(); ++it) {
        V8IsolatedContext* isolatedContext = it->second;
        if (!isolatedContext->securityOrigin())
            continue;
        v8::Handle<v8::Context> v8Context = isolatedContext->context();
        if (v8Context.IsEmpty())
            continue;
        ScriptState* scriptState = ScriptState::forContext(v8::Local<v8::Context>::New(v8Context));
        result.append(std::pair<ScriptState*, SecurityOrigin*>(scriptState, isolatedContext->securityOrigin()));
    }
}

bool V8Proxy::registeredExtensionWithV8(v8::Extension* extension)
{
    const V8Extensions& registeredExtensions = extensions();
    for (size_t i = 0; i < registeredExtensions.size(); ++i) {
        if (registeredExtensions[i] == extension)
            return true;
    }

    return false;
}

v8::Handle<v8::Value> V8Proxy::throwError(ErrorType type, const char* message, v8::Isolate* isolate)
{
    switch (type) {
    case RangeError:
        return v8::ThrowException(v8::Exception::RangeError(v8String(message, isolate)));
    case ReferenceError:
        return v8::ThrowException(v8::Exception::ReferenceError(v8String(message, isolate)));
    case SyntaxError:
        return v8::ThrowException(v8::Exception::SyntaxError(v8String(message, isolate)));
    case TypeError:
        return v8::ThrowException(v8::Exception::TypeError(v8String(message, isolate)));
    case GeneralError:
        return v8::ThrowException(v8::Exception::Error(v8String(message, isolate)));
    default:
        ASSERT_NOT_REACHED();
        return notHandledByInterceptor();
    }
}

static v8::Handle<v8::Value> idAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.id._get");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    return v8::Integer::New(imp->id());
}

static void testObjAttrAttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.testObjAttr._set");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    TestObj* v = V8TestObj::HasInstance(value) ? V8TestObj::toNative(v8::Handle<v8::Object>::Cast(value)) : 0;
    imp->setTestObjAttr(WTF::getPtr(v));
    return;
}

void ScriptController::installFunctionsForPagePopup(Frame* frame, PagePopupClient* popupClient)
{
    ASSERT(frame);
    ASSERT(popupClient);
    v8::HandleScope handleScope;
    v8::Handle<v8::Context> context = V8Proxy::mainWorldContext(frame);
    if (context.IsEmpty()) {
        ASSERT_NOT_REACHED();
        return;
    }
    v8::Context::Scope scope(context);
    DOMWindowPagePopup::install(frame->existingDOMWindow(), popupClient);
    v8::Local<v8::FunctionTemplate> templ = v8::FunctionTemplate::New(setValueAndClosePopupCallback, V8DOMWindow::wrap(frame->existingDOMWindow()));
    context->Global()->Set(v8::String::New("setValueAndClosePopup"), v8::Handle<v8::Function>(templ->GetFunction()));
}

void ScriptController::setIsolatedWorldSecurityOrigin(int worldID, PassRefPtr<SecurityOrigin> securityOrigin)
{
    m_proxy->setIsolatedWorldSecurityOrigin(worldID, securityOrigin);
}

static v8::Handle<v8::Value> methodWithNonOptionalArgAndTwoOptionalArgsCallback(const v8::Arguments& args)
{
INC_STATS("DOM.TestObj.methodWithNonOptionalArgAndTwoOptionalArgs");
if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();
TestObj* imp = V8TestObj::toNative(args.Holder());
EXCEPTION_BLOCK(int, nonOpt, toInt32(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));
if (args.Length() <= 1) {
imp->methodWithNonOptionalArgAndTwoOptionalArgs(nonOpt);
return v8::Handle<v8::Value>();
}
EXCEPTION_BLOCK(int, opt1, toInt32(MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined)));
if (args.Length() <= 2) {
imp->methodWithNonOptionalArgAndTwoOptionalArgs(nonOpt, opt1);
return v8::Handle<v8::Value>();
}
EXCEPTION_BLOCK(int, opt2, toInt32(MAYBE_MISSING_PARAMETER(args, 2, DefaultIsUndefined)));
imp->methodWithNonOptionalArgAndTwoOptionalArgs(nonOpt, opt1, opt2);
return v8::Handle<v8::Value>();
}

void V8TestMediaQueryListListener::derefObject(void* object)
{
    static_cast<TestMediaQueryListListener*>(object)->deref();
}

static v8::Persistent<v8::FunctionTemplate> ConfigureV8TestEventTargetTemplate(v8::Persistent<v8::FunctionTemplate> desc)
{
    desc->ReadOnlyPrototype();

    v8::Local<v8::Signature> defaultSignature;
    defaultSignature = configureTemplate(desc, "TestEventTarget", v8::Persistent<v8::FunctionTemplate>(), V8TestEventTarget::internalFieldCount,
        0, 0,
        TestEventTargetCallbacks, WTF_ARRAY_LENGTH(TestEventTargetCallbacks));
    UNUSED_PARAM(defaultSignature); // In some cases, it will not be used.
    v8::Local<v8::ObjectTemplate> instance = desc->InstanceTemplate();
    v8::Local<v8::ObjectTemplate> proto = desc->PrototypeTemplate();
    UNUSED_PARAM(instance); // In some cases, it will not be used.
    UNUSED_PARAM(proto); // In some cases, it will not be used.
    
    setCollectionIndexedGetter<TestEventTarget, Node>(desc);
    desc->InstanceTemplate()->SetNamedPropertyHandler(V8TestEventTarget::namedPropertyGetter, 0, 0, 0, 0);
    desc->InstanceTemplate()->MarkAsUndetectable();

    const int dispatchEventArgc = 1;
    v8::Handle<v8::FunctionTemplate> dispatchEventArgv[dispatchEventArgc] = { V8Event::GetRawTemplate() };
    v8::Handle<v8::Signature> dispatchEventSignature = v8::Signature::New(desc, dispatchEventArgc, dispatchEventArgv);
    proto->Set(v8::String::New("dispatchEvent"), v8::FunctionTemplate::New(TestEventTargetV8Internal::dispatchEventCallback, v8::Handle<v8::Value>(), dispatchEventSignature));

    desc->Set(getToStringName(), getToStringTemplate());
    return desc;
}

V8Proxy::V8Proxy(Frame* frame)
    : m_frame(frame)
    , m_windowShell(V8DOMWindowShell::create(frame))
{
}

static v8::Handle<v8::Value> withScriptStateVoidExceptionCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.TestObj.withScriptStateVoidException");
    TestObj* imp = V8TestObj::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    EmptyScriptState state;
    imp->withScriptStateVoidException(&state, ec);
    if (UNLIKELY(ec))
        goto fail;
    if (state.hadException())
        return throwError(state.exception(), args.GetIsolate());
    return v8::Handle<v8::Value>();
    }
    fail:
    V8Proxy::setDOMException(ec, args.GetIsolate());
    return v8::Handle<v8::Value>();
}

void V8Proxy::clearForNavigation()
{
    resetIsolatedWorlds();
    windowShell()->clearForNavigation();
}

ActiveDOMObject* V8TestInterface::toActiveDOMObject(v8::Handle<v8::Object> object)
{
    return toNative(object);
}      

static v8::Handle<v8::Value> TestObjConstructorGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.constructors._get");
    v8::Handle<v8::Value> data = info.Data();
    ASSERT(data->IsExternal() || data->IsNumber());
    WrapperTypeInfo* type = WrapperTypeInfo::unwrap(data);
    return v8::Handle<v8::Value>();}

static v8::Handle<v8::Value> methodWithSequenceArgCallback(const v8::Arguments& args)
{
INC_STATS("DOM.TestObj.methodWithSequenceArg");
if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();
TestObj* imp = V8TestObj::toNative(args.Holder());
EXCEPTION_BLOCK(sequence<ScriptProfile>*, sequenceArg, toNativeArray<ScriptProfile>(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));
imp->methodWithSequenceArg(sequenceArg);
return v8::Handle<v8::Value>();
}

static void XMLObjAttrAttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.XMLObjAttr._set");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    TestObj* v = V8TestObj::HasInstance(value) ? V8TestObj::toNative(v8::Handle<v8::Object>::Cast(value)) : 0;
    imp->setXMLObjAttr(WTF::getPtr(v));
    return;
}

void ScriptController::collectGarbage()
{
    v8::HandleScope handleScope;

    v8::Persistent<v8::Context> v8Context = v8::Context::New();
    if (v8Context.IsEmpty())
        return;
    {
        v8::Context::Scope scope(v8Context);
        v8::Local<v8::String> source = v8::String::New("if (gc) gc();");
        v8::Local<v8::String> name = v8::String::New("gc");
        v8::Handle<v8::Script> script = v8::Script::Compile(source, name);
        if (!script.IsEmpty()) {
            V8RecursionScope::MicrotaskSuppression scope;
            script->Run();
        }
    }
    v8Context.Dispose();
}

static void stringAttrWithSetterExceptionAttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.stringAttrWithSetterException._set");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    STRING_TO_V8PARAMETER_EXCEPTION_BLOCK_VOID(V8Parameter<>, v, value);
    ExceptionCode ec = 0;
    imp->setStringAttrWithSetterException(v, ec);
    if (UNLIKELY(ec))
        V8Proxy::setDOMException(ec, info.GetIsolate());
    return;
}

static NPObject* createNoScriptObject()
{
    notImplemented();
    return 0;
}

v8::Handle<v8::Object> V8TestEventTarget::wrapSlow(PassRefPtr<TestEventTarget> impl, v8::Isolate* isolate)
{
    v8::Handle<v8::Object> wrapper;
    V8Proxy* proxy = 0;
    wrapper = V8DOMWrapper::instantiateV8Object(proxy, &info, impl.get());
    if (UNLIKELY(wrapper.IsEmpty()))
        return wrapper;

    v8::Persistent<v8::Object> wrapperHandle = v8::Persistent<v8::Object>::New(wrapper);

    if (!hasDependentLifetime)
        wrapperHandle.MarkIndependent();
    V8DOMWrapper::setJSWrapperForDOMObject(impl, wrapperHandle, isolate);
    return wrapper;
}

void ScriptController::getAllWorlds(Vector<RefPtr<DOMWrapperWorld> >& worlds)
{
    worlds.append(mainThreadNormalWorld());
}

static v8::Handle<v8::Value> reflectedBooleanAttrAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.reflectedBooleanAttr._get");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    return v8Boolean(imp->hasAttribute(WebCore::HTMLNames::reflectedbooleanattrAttr));
}

v8::Handle<v8::Object> V8TestObj::wrapSlow(PassRefPtr<TestObj> impl, v8::Isolate* isolate)
{
    v8::Handle<v8::Object> wrapper;
    V8Proxy* proxy = 0;
    wrapper = V8DOMWrapper::instantiateV8Object(proxy, &info, impl.get());
    if (UNLIKELY(wrapper.IsEmpty()))
        return wrapper;

    v8::Persistent<v8::Object> wrapperHandle = v8::Persistent<v8::Object>::New(wrapper);

    if (!hasDependentLifetime)
        wrapperHandle.MarkIndependent();
    V8DOMWrapper::setJSWrapperForDOMObject(impl, wrapperHandle, isolate);
    return wrapper;
}

static v8::Handle<v8::Value> withScriptExecutionContextCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.TestObj.withScriptExecutionContext");
    TestObj* imp = V8TestObj::toNative(args.Holder());
    ScriptExecutionContext* scriptContext = getScriptExecutionContext();
    if (!scriptContext)
        return v8::Undefined();
    imp->withScriptExecutionContext(scriptContext);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> convert1Callback(const v8::Arguments& args)
{
INC_STATS("DOM.TestObj.convert1");
if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();
TestObj* imp = V8TestObj::toNative(args.Holder());
EXCEPTION_BLOCK(a*, , V8a::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8a::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
imp->convert1();
return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> withScriptExecutionContextAndScriptStateWithSpacesAttributeAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.withScriptExecutionContextAndScriptStateWithSpacesAttribute._get");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    ScriptState* state = ScriptState::current();
    if (!state)
        return v8::Undefined();
    ScriptExecutionContext* scriptContext = getScriptExecutionContext();
    if (!scriptContext)
        return v8::Undefined();
    return toV8(imp->withScriptExecutionContextAndScriptStateWithSpacesAttribute(state, scriptContext), info.GetIsolate());
}

v8::Persistent<v8::FunctionTemplate> V8TestSerializedScriptValueInterface::GetTemplate()
{
    V8BindingPerIsolateData* data = V8BindingPerIsolateData::current();
    V8BindingPerIsolateData::TemplateMap::iterator result = data->templateMap().find(&info);
    if (result != data->templateMap().end())
        return result->second;

    v8::HandleScope handleScope;
    v8::Persistent<v8::FunctionTemplate> templ =
        ConfigureV8TestSerializedScriptValueInterfaceTemplate(GetRawTemplate());
    data->templateMap().add(&info, templ);
    return templ;
}

static v8::Handle<v8::Value> XMLObjAttrAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.XMLObjAttr._get");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    return toV8(imp->xmlObjAttr(), info.GetIsolate());
}

void V8Proxy::reportUnsafeAccessTo(Frame* target)
{
    ASSERT(target);
    Document* targetDocument = target->document();
    if (!targetDocument)
        return;

    Frame* source = V8Proxy::retrieveFrameForEnteredContext();
    if (!source)
        return;

    Document* sourceDocument = source->document();
    if (!sourceDocument)
        return; // Ignore error if the source document is gone.

    String str = "Unsafe JavaScript attempt to access frame with URL " + targetDocument->url().string() +
                 " from frame with URL " + sourceDocument->url().string() + ". Domains, protocols and ports must match.\n";

    RefPtr<ScriptCallStack> stackTrace = createScriptCallStack(ScriptCallStack::maxCallStackSizeToCapture, true);

    sourceDocument->addConsoleMessage(JSMessageSource, LogMessageType, ErrorMessageLevel, str, stackTrace.release());
}

static v8::Handle<v8::Value> overloadedMethod5Callback(const v8::Arguments& args)
{
INC_STATS("DOM.TestObj.overloadedMethod5");
if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();
TestObj* imp = V8TestObj::toNative(args.Holder());
if (args.Length() <= 0 || !args[0]->IsFunction())
return throwError(TYPE_MISMATCH_ERR, args.GetIsolate());
RefPtr<TestCallback> callback = V8TestCallback::create(args[0], getScriptExecutionContext());
imp->overloadedMethod(callback);
return v8::Handle<v8::Value>();
}

bool V8Float64Array::HasInstance(v8::Handle<v8::Value> value)
{
    return GetRawTemplate()->HasInstance(value);
}

v8::Handle<v8::Value> V8DataView::getUint8Callback(const v8::Arguments& args)
{
INC_STATS("DOM.DataView.getUint8");
if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();

DataView* imp = V8DataView::toNative(args.Holder());
ExceptionCode ec = 0;
EXCEPTION_BLOCK(unsigned, byteOffset, toUInt32(args[0]));
uint8_t result = imp->getUint8(byteOffset, ec);
if (UNLIKELY(ec)) {
V8Proxy::setDOMException(ec, args.GetIsolate());
return v8::Handle<v8::Value>();
}
return v8::Integer::New(result);
}

static int* jsArrayToIntArray(v8::Handle<v8::Array> array, uint32_t len)
{
    int* data = 0;
    if (len > std::numeric_limits<uint32_t>::max() / sizeof(int)
        || !tryFastMalloc(len * sizeof(int)).getValue(data))
        return 0;
    for (uint32_t i = 0; i < len; i++) {
        v8::Local<v8::Value> val = array->Get(i);
        bool ok;
        int ival = toInt32(val, ok);
        if (!ok) {
            fastFree(data);
            return 0;
        }
        data[i] = ival;
    }
    return data;
}

static v8::Handle<v8::Value> cachedReadonlyValueAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestSerializedScriptValueInterface.cachedReadonlyValue._get");
    v8::Handle<v8::String> propertyName = v8::String::NewSymbol("cachedReadonlyValue");
    v8::Handle<v8::Value> value = info.Holder()->GetHiddenValue(propertyName);
    if (!value.IsEmpty())
        return value;
    TestSerializedScriptValueInterface* imp = V8TestSerializedScriptValueInterface::toNative(info.Holder());
    SerializedScriptValue* serialized = imp->cachedReadonlyValue();
    value = serialized ? serialized->deserialize() : v8::Handle<v8::Value>(v8::Null());
    info.Holder()->SetHiddenValue(propertyName, value);
    return value;
}

static v8::Handle<v8::Value> enabledAtRuntimeAttr1AttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.enabledAtRuntimeAttr1._get");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    return v8::Integer::New(imp->enabledAtRuntimeAttr1());
}

v8::Handle<v8::Value> V8WebSocket::closeCallback(const v8::Arguments& args)
{
    WebSocket* webSocket = toNative(args.Holder());
    int argumentCount = args.Length();
    int code = WebSocketChannel::CloseEventCodeNotSpecified;
    String reason = "";
    if (argumentCount >= 1) {
        double x = args[0]->NumberValue();
        double maxValue = static_cast<double>(std::numeric_limits<uint16_t>::max());
        double minValue = static_cast<double>(std::numeric_limits<uint16_t>::min());
        if (isnan(x))
            x = 0.0;
        else
            x = clampTo(x, minValue, maxValue);
        code = clampToInteger(x);
        if (argumentCount >= 2) {
            v8::TryCatch tryCatch;
            v8::Handle<v8::String> reasonValue = args[1]->ToString();
            if (tryCatch.HasCaught())
                return throwError(tryCatch.Exception(), args.GetIsolate());
            reason = toWebCoreString(reasonValue);
        }
    }
    ExceptionCode ec = 0;
    webSocket->close(code, reason, ec);
    if (ec)
        return throwError(ec, args.GetIsolate());
    return v8::Undefined();
}

static float* jsArrayToFloatArray(v8::Handle<v8::Array> array, uint32_t len)
{
    float* data = 0;
    if (len > std::numeric_limits<uint32_t>::max() / sizeof(float)
        || !tryFastMalloc(len * sizeof(float)).getValue(data))
        return 0;
    for (uint32_t i = 0; i < len; i++) {
        v8::Local<v8::Value> val = array->Get(i);
        if (!val->IsNumber()) {
            fastFree(data);
            return 0;
        }
        data[i] = toFloat(val);
    }
    return data;
}

v8::Handle<v8::Value> V8WebGLRenderingContext::getParameterCallback(const v8::Arguments& args)
{
INC_STATS("DOM.WebGLRenderingContext.getParameter()");

if (args.Length() != 1)
        return V8Proxy::throwNotEnoughArgumentsError();

ExceptionCode ec = 0;
WebGLRenderingContext* context = V8WebGLRenderingContext::toNative(args.Holder());
unsigned pname = toInt32(args[0]);
WebGLGetInfo info = context->getParameter(pname, ec);
if (ec) {
V8Proxy::setDOMException(ec, args.GetIsolate());
return v8::Undefined();
}
return toV8Object(info, args.GetIsolate());
}

static v8::Handle<v8::Value> descriptionAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.description._get");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    return v8::Integer::New(imp->description());
}

static v8::Handle<v8::Value> serializedValueCallback(const v8::Arguments& args)
{
INC_STATS("DOM.TestObj.serializedValue");
if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();
TestObj* imp = V8TestObj::toNative(args.Holder());
bool serializedArgDidThrow = false;
RefPtr<SerializedScriptValue> serializedArg = SerializedScriptValue::create(args[0], 0, 0, serializedArgDidThrow, args.GetIsolate());
if (serializedArgDidThrow)
return v8::Undefined();
imp->serializedValue(serializedArg);
return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> setValueAndClosePopupCallback(const v8::Arguments& args)
{
if (args.Length() < 2)
        return V8Proxy::throwNotEnoughArgumentsError();
DOMWindow* imp = V8DOMWindow::toNative(args.Data()->ToObject());
EXCEPTION_BLOCK(int, intValue, toInt32(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));
STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, stringValue, MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined));
DOMWindowPagePopup::setValueAndClosePopup(imp, intValue, stringValue);
// setValueAndClosePopup() deletes the window. Do not access it.
return v8::Undefined();
}

static v8::Handle<v8::Value> withScriptExecutionContextAttributeRaisesAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.withScriptExecutionContextAttributeRaises._get");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    ExceptionCode ec = 0;
    ScriptExecutionContext* scriptContext = getScriptExecutionContext();
    if (!scriptContext)
        return v8::Undefined();
    RefPtr<TestObj> v = imp->withScriptExecutionContextAttributeRaises(scriptContext, ec);
    if (UNLIKELY(ec)) {
        V8Proxy::setDOMException(ec, info.GetIsolate());
        return v8::Handle<v8::Value>();
    }
    return toV8(v.release(), info.GetIsolate());
}

void ScriptController::namedItemAdded(HTMLDocument* doc, const AtomicString& name)
{
    m_proxy->windowShell()->namedItemAdded(doc, name);
}

static v8::Handle<v8::Value> shortAttrAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.shortAttr._get");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    return v8::Integer::New(imp->shortAttr());
}

static v8::Handle<v8::Value> overloadedMethod2Callback(const v8::Arguments& args)
{
INC_STATS("DOM.TestObj.overloadedMethod2");
if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();
TestObj* imp = V8TestObj::toNative(args.Holder());
EXCEPTION_BLOCK(TestObj*, objArg, V8TestObj::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8TestObj::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
if (args.Length() <= 1) {
imp->overloadedMethod(objArg);
return v8::Handle<v8::Value>();
}
EXCEPTION_BLOCK(int, intArg, toInt32(MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined)));
imp->overloadedMethod(objArg, intArg);
return v8::Handle<v8::Value>();
}

bool V8TestSerializedScriptValueInterface::HasInstance(v8::Handle<v8::Value> value)
{
    return GetRawTemplate()->HasInstance(value);
}

static void longSequenceAttrAttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.longSequenceAttr._set");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    Vector<long> v = toNativeArray<long>(value);
    imp->setLongSequenceAttr(v);
    return;
}

static v8::Persistent<v8::FunctionTemplate> ConfigureV8TestObjTemplate(v8::Persistent<v8::FunctionTemplate> desc)
{
    desc->ReadOnlyPrototype();

    v8::Local<v8::Signature> defaultSignature;
    defaultSignature = configureTemplate(desc, "TestObject", v8::Persistent<v8::FunctionTemplate>(), V8TestObj::internalFieldCount,
        TestObjAttrs, WTF_ARRAY_LENGTH(TestObjAttrs),
        TestObjCallbacks, WTF_ARRAY_LENGTH(TestObjCallbacks));
    UNUSED_PARAM(defaultSignature); // In some cases, it will not be used.
    desc->SetCallHandler(V8TestObj::constructorCallback);
    v8::Local<v8::ObjectTemplate> instance = desc->InstanceTemplate();
    v8::Local<v8::ObjectTemplate> proto = desc->PrototypeTemplate();
    UNUSED_PARAM(instance); // In some cases, it will not be used.
    UNUSED_PARAM(proto); // In some cases, it will not be used.
    
    if (RuntimeEnabledFeatures::enabledAtRuntimeAttr1Enabled()) {
        static const BatchedAttribute attrData =\
        {"enabledAtRuntimeAttr1", TestObjV8Internal::enabledAtRuntimeAttr1AttrGetter, TestObjV8Internal::enabledAtRuntimeAttr1AttrSetter, 0 /* no data */, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), 0 /* on instance */};
        configureAttribute(instance, proto, attrData);
    }
    if (RuntimeEnabledFeatures::featureNameEnabled()) {
        static const BatchedAttribute attrData =\
        {"enabledAtRuntimeAttr2", TestObjV8Internal::enabledAtRuntimeAttr2AttrGetter, TestObjV8Internal::enabledAtRuntimeAttr2AttrSetter, 0 /* no data */, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), 0 /* on instance */};
        configureAttribute(instance, proto, attrData);
    }

    const int voidMethodWithArgsArgc = 3;
    v8::Handle<v8::FunctionTemplate> voidMethodWithArgsArgv[voidMethodWithArgsArgc] = { v8::Handle<v8::FunctionTemplate>(), v8::Handle<v8::FunctionTemplate>(), V8TestObj::GetRawTemplate() };
    v8::Handle<v8::Signature> voidMethodWithArgsSignature = v8::Signature::New(desc, voidMethodWithArgsArgc, voidMethodWithArgsArgv);
    proto->Set(v8::String::New("voidMethodWithArgs"), v8::FunctionTemplate::New(TestObjV8Internal::voidMethodWithArgsCallback, v8::Handle<v8::Value>(), voidMethodWithArgsSignature));

    const int intMethodWithArgsArgc = 3;
    v8::Handle<v8::FunctionTemplate> intMethodWithArgsArgv[intMethodWithArgsArgc] = { v8::Handle<v8::FunctionTemplate>(), v8::Handle<v8::FunctionTemplate>(), V8TestObj::GetRawTemplate() };
    v8::Handle<v8::Signature> intMethodWithArgsSignature = v8::Signature::New(desc, intMethodWithArgsArgc, intMethodWithArgsArgv);
    proto->Set(v8::String::New("intMethodWithArgs"), v8::FunctionTemplate::New(TestObjV8Internal::intMethodWithArgsCallback, v8::Handle<v8::Value>(), intMethodWithArgsSignature));

    const int objMethodWithArgsArgc = 3;
    v8::Handle<v8::FunctionTemplate> objMethodWithArgsArgv[objMethodWithArgsArgc] = { v8::Handle<v8::FunctionTemplate>(), v8::Handle<v8::FunctionTemplate>(), V8TestObj::GetRawTemplate() };
    v8::Handle<v8::Signature> objMethodWithArgsSignature = v8::Signature::New(desc, objMethodWithArgsArgc, objMethodWithArgsArgv);
    proto->Set(v8::String::New("objMethodWithArgs"), v8::FunctionTemplate::New(TestObjV8Internal::objMethodWithArgsCallback, v8::Handle<v8::Value>(), objMethodWithArgsSignature));

    const int methodWithSequenceArgArgc = 1;
    v8::Handle<v8::FunctionTemplate> methodWithSequenceArgArgv[methodWithSequenceArgArgc] = { V8sequence<ScriptProfile>::GetRawTemplate() };
    v8::Handle<v8::Signature> methodWithSequenceArgSignature = v8::Signature::New(desc, methodWithSequenceArgArgc, methodWithSequenceArgArgv);
    proto->Set(v8::String::New("methodWithSequenceArg"), v8::FunctionTemplate::New(TestObjV8Internal::methodWithSequenceArgCallback, v8::Handle<v8::Value>(), methodWithSequenceArgSignature));

    const int methodThatRequiresAllArgsAndThrowsArgc = 2;
    v8::Handle<v8::FunctionTemplate> methodThatRequiresAllArgsAndThrowsArgv[methodThatRequiresAllArgsAndThrowsArgc] = { v8::Handle<v8::FunctionTemplate>(), V8TestObj::GetRawTemplate() };
    v8::Handle<v8::Signature> methodThatRequiresAllArgsAndThrowsSignature = v8::Signature::New(desc, methodThatRequiresAllArgsAndThrowsArgc, methodThatRequiresAllArgsAndThrowsArgv);
    proto->Set(v8::String::New("methodThatRequiresAllArgsAndThrows"), v8::FunctionTemplate::New(TestObjV8Internal::methodThatRequiresAllArgsAndThrowsCallback, v8::Handle<v8::Value>(), methodThatRequiresAllArgsAndThrowsSignature));
    desc->Set(v8::String::New("classMethod"), v8::FunctionTemplate::New(TestObjV8Internal::classMethodCallback, v8::Handle<v8::Value>(), v8::Local<v8::Signature>()));
    desc->Set(v8::String::New("classMethodWithOptional"), v8::FunctionTemplate::New(TestObjV8Internal::classMethodWithOptionalCallback, v8::Handle<v8::Value>(), v8::Local<v8::Signature>()));
    desc->Set(v8::String::New("classMethod2"), v8::FunctionTemplate::New(V8TestObj::classMethod2Callback, v8::Handle<v8::Value>(), v8::Local<v8::Signature>()));
#if ENABLE(Condition1)
    desc->Set(v8::String::New("overloadedMethod1"), v8::FunctionTemplate::New(TestObjV8Internal::overloadedMethod1Callback, v8::Handle<v8::Value>(), v8::Local<v8::Signature>()));
#endif // ENABLE(Condition1)
    if (RuntimeEnabledFeatures::enabledAtRuntimeMethod1Enabled())
        proto->Set(v8::String::New("enabledAtRuntimeMethod1"), v8::FunctionTemplate::New(TestObjV8Internal::enabledAtRuntimeMethod1Callback, v8::Handle<v8::Value>(), defaultSignature));
    if (RuntimeEnabledFeatures::featureNameEnabled())
        proto->Set(v8::String::New("enabledAtRuntimeMethod2"), v8::FunctionTemplate::New(TestObjV8Internal::enabledAtRuntimeMethod2Callback, v8::Handle<v8::Value>(), defaultSignature));

    const int convert1Argc = 1;
    v8::Handle<v8::FunctionTemplate> convert1Argv[convert1Argc] = { V8a::GetRawTemplate() };
    v8::Handle<v8::Signature> convert1Signature = v8::Signature::New(desc, convert1Argc, convert1Argv);
    proto->Set(v8::String::New("convert1"), v8::FunctionTemplate::New(TestObjV8Internal::convert1Callback, v8::Handle<v8::Value>(), convert1Signature));

    const int convert2Argc = 1;
    v8::Handle<v8::FunctionTemplate> convert2Argv[convert2Argc] = { V8b::GetRawTemplate() };
    v8::Handle<v8::Signature> convert2Signature = v8::Signature::New(desc, convert2Argc, convert2Argv);
    proto->Set(v8::String::New("convert2"), v8::FunctionTemplate::New(TestObjV8Internal::convert2Callback, v8::Handle<v8::Value>(), convert2Signature));

    const int convert3Argc = 1;
    v8::Handle<v8::FunctionTemplate> convert3Argv[convert3Argc] = { V8c::GetRawTemplate() };
    v8::Handle<v8::Signature> convert3Signature = v8::Signature::New(desc, convert3Argc, convert3Argv);
    proto->Set(v8::String::New("convert3"), v8::FunctionTemplate::New(TestObjV8Internal::convert3Callback, v8::Handle<v8::Value>(), convert3Signature));

    const int convert4Argc = 1;
    v8::Handle<v8::FunctionTemplate> convert4Argv[convert4Argc] = { V8d::GetRawTemplate() };
    v8::Handle<v8::Signature> convert4Signature = v8::Signature::New(desc, convert4Argc, convert4Argv);
    proto->Set(v8::String::New("convert4"), v8::FunctionTemplate::New(TestObjV8Internal::convert4Callback, v8::Handle<v8::Value>(), convert4Signature));

    const int convert5Argc = 1;
    v8::Handle<v8::FunctionTemplate> convert5Argv[convert5Argc] = { V8e::GetRawTemplate() };
    v8::Handle<v8::Signature> convert5Signature = v8::Signature::New(desc, convert5Argc, convert5Argv);
    proto->Set(v8::String::New("convert5"), v8::FunctionTemplate::New(TestObjV8Internal::convert5Callback, v8::Handle<v8::Value>(), convert5Signature));
    batchConfigureConstants(desc, proto, TestObjConsts, WTF_ARRAY_LENGTH(TestObjConsts));

    desc->Set(getToStringName(), getToStringTemplate());
    return desc;
}

static v8::Handle<v8::Value> overloadedMethodCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.TestObj.overloadedMethod");
    if ((args.Length() == 2 && (args[0]->IsNull() || V8TestObj::HasInstance(args[0])) && (args[1]->IsNull() || args[1]->IsUndefined() || args[1]->IsString() || args[1]->IsObject())))
        return overloadedMethod1Callback(args);
    if ((args.Length() == 1 && (args[0]->IsNull() || V8TestObj::HasInstance(args[0]))) || (args.Length() == 2 && (args[0]->IsNull() || V8TestObj::HasInstance(args[0]))))
        return overloadedMethod2Callback(args);
    if ((args.Length() == 1 && (args[0]->IsNull() || args[0]->IsUndefined() || args[0]->IsString() || args[0]->IsObject())))
        return overloadedMethod3Callback(args);
    if (args.Length() == 1)
        return overloadedMethod4Callback(args);
    if ((args.Length() == 1 && (args[0]->IsNull() || args[0]->IsFunction())))
        return overloadedMethod5Callback(args);
    if ((args.Length() == 1 && (args[0]->IsNull() || V8DOMStringList::HasInstance(args[0]))))
        return overloadedMethod6Callback(args);
    if ((args.Length() == 1 && (args[0]->IsNull() || args[0]->IsArray())))
        return overloadedMethod7Callback(args);
    V8Proxy::throwTypeError();
    return notHandledByInterceptor();
}

v8::Handle<v8::Value> V8DirectoryEntry::getFileCallback(const v8::Arguments& args)
{
INC_STATS("DOM.DirectoryEntry.getFile");
DirectoryEntry* imp = V8DirectoryEntry::toNative(args.Holder());

if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();

STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<WithUndefinedOrNullCheck>, path, args[0]);
if (args.Length() <= 1) {
imp->getFile(path);
return v8::Handle<v8::Value>();
}
RefPtr<WebKitFlags> flags;
if (!isUndefinedOrNull(args[1]) && args[1]->IsObject()) {
EXCEPTION_BLOCK(v8::Handle<v8::Object>, object, v8::Handle<v8::Object>::Cast(args[1]));
flags = WebKitFlags::create();
v8::Local<v8::Value> v8Create = object->Get(v8::String::New("create"));
if (!v8Create.IsEmpty() && !isUndefinedOrNull(v8Create)) {
EXCEPTION_BLOCK(bool, isCreate, v8Create->BooleanValue());
flags->setCreate(isCreate);
}
v8::Local<v8::Value> v8Exclusive = object->Get(v8::String::New("exclusive"));
if (!v8Exclusive.IsEmpty() && !isUndefinedOrNull(v8Exclusive)) {
EXCEPTION_BLOCK(bool, isExclusive, v8Exclusive->BooleanValue());
flags->setExclusive(isExclusive);
}
}
RefPtr<EntryCallback> successCallback;
if (args.Length() > 2 && !args[2]->IsNull() && !args[2]->IsUndefined()) {
if (!args[2]->IsObject())
return throwError(TYPE_MISMATCH_ERR, args.GetIsolate());
successCallback = V8EntryCallback::create(args[2], getScriptExecutionContext());
}
RefPtr<ErrorCallback> errorCallback;
if (args.Length() > 3 && !args[3]->IsNull() && !args[3]->IsUndefined()) {
if (!args[3]->IsObject())
return throwError(TYPE_MISMATCH_ERR, args.GetIsolate());
errorCallback = V8ErrorCallback::create(args[3], getScriptExecutionContext());
}
imp->getFile(path, flags, successCallback, errorCallback);
return v8::Handle<v8::Value>();
}

PassOwnPtr<v8::ScriptData> V8Proxy::precompileScript(v8::Handle<v8::String> code, CachedScript* cachedScript)
{
    static const unsigned dataTypeID = 0xECC13BD7;

    static const int minPreparseLength = 1024;

    if (!cachedScript || code->Length() < minPreparseLength)
        return nullptr;

    CachedMetadata* cachedMetadata = cachedScript->cachedMetadata(dataTypeID);
    if (cachedMetadata)
        return adoptPtr(v8::ScriptData::New(cachedMetadata->data(), cachedMetadata->size()));

    OwnPtr<v8::ScriptData> scriptData = adoptPtr(v8::ScriptData::PreCompile(code));
    cachedScript->setCachedMetadata(dataTypeID, scriptData->Data(), scriptData->Length());

    return scriptData.release();
}

void V8Float64Array::derefObject(void* object)
{
    static_cast<Float64Array*>(object)->deref();
}

v8::Handle<v8::Value> V8WebGLRenderingContext::uniformMatrix3fvCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.uniformMatrix3fv()");
    return uniformMatrixHelper(args, 3);
}

static v8::Handle<v8::Value> postMessageCallback(const v8::Arguments& args)
{
INC_STATS("DOM.TestActiveDOMObject.postMessage");
if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();
TestActiveDOMObject* imp = V8TestActiveDOMObject::toNative(args.Holder());
STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, message, MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined));
imp->postMessage(message);
return v8::Handle<v8::Value>();
}

v8::Handle<v8::Value> V8WebSocket::sendCallback(const v8::Arguments& args)
{
INC_STATS("DOM.WebSocket.send()");

if (!args.Length())
        return V8Proxy::throwNotEnoughArgumentsError();

WebSocket* webSocket = V8WebSocket::toNative(args.Holder());
v8::Handle<v8::Value> message = args[0];
ExceptionCode ec = 0;
bool result;
if (V8ArrayBuffer::HasInstance(message)) {
ArrayBuffer* arrayBuffer = V8ArrayBuffer::toNative(v8::Handle<v8::Object>::Cast(message));
ASSERT(arrayBuffer);
result = webSocket->send(arrayBuffer, ec);
} else if (V8Blob::HasInstance(message)) {
Blob* blob = V8Blob::toNative(v8::Handle<v8::Object>::Cast(message));
ASSERT(blob);
result = webSocket->send(blob, ec);
} else {
v8::TryCatch tryCatch;
v8::Handle<v8::String> stringMessage = message->ToString();
if (tryCatch.HasCaught())
return throwError(tryCatch.Exception(), args.GetIsolate());
result = webSocket->send(toWebCoreString(stringMessage), ec);
}
if (ec)
return throwError(ec, args.GetIsolate());

return v8Boolean(result);
}

void V8Proxy::registerExtensionWithV8(v8::Extension* extension)
{
    if (!registeredExtensionWithV8(extension))
        v8::RegisterExtension(extension);
}

static void withScriptExecutionContextAndScriptStateAttributeRaisesAttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.withScriptExecutionContextAndScriptStateAttributeRaises._set");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    TestObj* v = V8TestObj::HasInstance(value) ? V8TestObj::toNative(v8::Handle<v8::Object>::Cast(value)) : 0;
    ExceptionCode ec = 0;
    ScriptState* state = ScriptState::current();
    if (!state)
        return;
    ScriptExecutionContext* scriptContext = getScriptExecutionContext();
    if (!scriptContext)
        return;
    imp->setWithScriptExecutionContextAndScriptStateAttributeRaises(state, scriptContext, WTF::getPtr(v), ec);
    if (UNLIKELY(ec))
        V8Proxy::setDOMException(ec, info.GetIsolate());
    if (state.hadException())
        throwError(state.exception(), info.GetIsolate());
    return;
}

V8Proxy* V8Proxy::retrieve()
{
    DOMWindow* window = retrieveWindow(currentContext());
    ASSERT(window);
    return retrieve(window->frame());
}

static void reflectedCustomBooleanAttrAttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.reflectedCustomBooleanAttr._set");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    bool v = value->BooleanValue();
    imp->setBooleanAttribute(WebCore::HTMLNames::customContentBooleanAttrAttr, v);
    return;
}

static v8::Handle<v8::Value> attr1AttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestEventConstructor.attr1._get");
    TestEventConstructor* imp = V8TestEventConstructor::toNative(info.Holder());
    return v8String(imp->attr1(), info.GetIsolate());
}

static void booleanSequenceAttrAttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.booleanSequenceAttr._set");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    Vector<boolean> v = toNativeArray<boolean>(value);
    imp->setBooleanSequenceAttr(v);
    return;
}

static void withScriptExecutionContextAttributeAttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.withScriptExecutionContextAttribute._set");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    TestObj* v = V8TestObj::HasInstance(value) ? V8TestObj::toNative(v8::Handle<v8::Object>::Cast(value)) : 0;
    ScriptExecutionContext* scriptContext = getScriptExecutionContext();
    if (!scriptContext)
        return;
    imp->setWithScriptExecutionContextAttribute(scriptContext, WTF::getPtr(v));
    return;
}

static v8::Handle<v8::Value> reflectedCustomBooleanAttrAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.reflectedCustomBooleanAttr._get");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    return v8Boolean(imp->hasAttribute(WebCore::HTMLNames::customContentBooleanAttrAttr));
}

v8::Persistent<v8::FunctionTemplate> V8Float64Array::GetRawTemplate()
{
    V8BindingPerIsolateData* data = V8BindingPerIsolateData::current();
    V8BindingPerIsolateData::TemplateMap::iterator result = data->rawTemplateMap().find(&info);
    if (result != data->rawTemplateMap().end())
        return result->second;

    v8::HandleScope handleScope;
    v8::Persistent<v8::FunctionTemplate> templ = createRawTemplate();
    data->rawTemplateMap().add(&info, templ);
    return templ;
}

v8::Handle<v8::Value> V8WebGLRenderingContext::getRenderbufferParameterCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.getRenderbufferParameter()");
    return getObjectParameter(args, kRenderbuffer);
}

static void immutablePointAttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.immutablePoint._set");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    RefPtr<SVGPropertyTearOff<FloatPoint> > v = V8SVGPoint::HasInstance(value) ? V8SVGPoint::toNative(v8::Handle<v8::Object>::Cast(value)) : 0;
    imp->setImmutablePoint(WTF::getPtr(v));
    return;
}

static void reflectedCustomIntegralAttrAttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.reflectedCustomIntegralAttr._set");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    int v = toInt32(value);
    imp->setIntegralAttribute(WebCore::HTMLNames::customContentIntegralAttrAttr, v);
    return;
}

v8::Persistent<v8::FunctionTemplate> V8TestCustomNamedGetter::GetRawTemplate()
{
    V8BindingPerIsolateData* data = V8BindingPerIsolateData::current();
    V8BindingPerIsolateData::TemplateMap::iterator result = data->rawTemplateMap().find(&info);
    if (result != data->rawTemplateMap().end())
        return result->second;

    v8::HandleScope handleScope;
    v8::Persistent<v8::FunctionTemplate> templ = createRawTemplate();
    data->rawTemplateMap().add(&info, templ);
    return templ;
}

v8::Handle<v8::Object> V8Float64Array::wrapSlow(PassRefPtr<Float64Array> impl, v8::Isolate* isolate)
{
    v8::Handle<v8::Object> wrapper;
    V8Proxy* proxy = 0;
    wrapper = V8DOMWrapper::instantiateV8Object(proxy, &info, impl.get());
    if (UNLIKELY(wrapper.IsEmpty()))
        return wrapper;

    v8::Persistent<v8::Object> wrapperHandle = v8::Persistent<v8::Object>::New(wrapper);

    if (!hasDependentLifetime)
        wrapperHandle.MarkIndependent();
    V8DOMWrapper::setJSWrapperForDOMObject(impl, wrapperHandle, isolate);
    return wrapper;
}

static v8::Handle<v8::Value> supplementalMethod4Callback(const v8::Arguments& args)
{
    INC_STATS("DOM.TestInterface.supplementalMethod4");
    TestSupplemental::supplementalMethod4();
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> conditionalAttr2AttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.conditionalAttr2._get");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    return v8::Integer::New(imp->conditionalAttr2());
}

v8::Handle<v8::Value> V8WebGLRenderingContext::uniform1ivCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.uniform1iv()");
    return uniformHelperi(args, kUniform1v);
}

v8::Handle<v8::Value> V8TestInterface::constructorCallback(const v8::Arguments& args)
{
INC_STATS("DOM.TestInterface.Constructor");

if (!args.IsConstructCall())
return V8Proxy::throwTypeError("DOM object constructor cannot be called as a function.");

if (ConstructorMode::current() == ConstructorMode::WrapExistingObject)
return args.Holder();
if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();

ExceptionCode ec = 0;
STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, str1, MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined));
STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, str2, MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined));

ScriptExecutionContext* context = getScriptExecutionContext();
if (!context)
return V8Proxy::throwError(V8Proxy::ReferenceError, "TestInterface constructor's associated context is not available", args.GetIsolate());

RefPtr<TestInterface> impl = TestInterface::create(context, str1, str2, ec);
v8::Handle<v8::Object> wrapper = args.Holder();
if (ec)
goto fail;

V8DOMWrapper::setDOMWrapper(wrapper, &info, impl.get());
V8DOMWrapper::setJSWrapperForActiveDOMObject(impl.release(), v8::Persistent<v8::Object>::New(wrapper), args.GetIsolate());
return args.Holder();
fail:
return throwError(ec, args.GetIsolate());
}

v8::Local<v8::Context> V8Proxy::context()
{
    if (V8IsolatedContext* isolatedContext = V8IsolatedContext::getEntered()) {
        RefPtr<SharedPersistent<v8::Context> > context = isolatedContext->sharedContext();
        if (m_frame != V8Proxy::retrieveFrame(context->get()))
            return v8::Local<v8::Context>();
        return v8::Local<v8::Context>::New(context->get());
    }
    return mainWorldContext();
}

static void DOMExceptionStackSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
{
    ASSERT(info.Data()->IsObject());
    info.Data()->ToObject()->Set(v8String("stack", info.GetIsolate()), value);
}

bool V8TestMediaQueryListListener::HasInstance(v8::Handle<v8::Value> value)
{
    return GetRawTemplate()->HasInstance(value);
}

v8::Handle<v8::Value> V8WebGLRenderingContext::uniform4ivCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.uniform4iv()");
    return uniformHelperi(args, kUniform4v);
}

static v8::Handle<v8::Value> toV8Object(const WebGLGetInfo& info, v8::Isolate* isolate)
{
    switch (info.getType()) {
    case WebGLGetInfo::kTypeBool:
        return v8::Boolean::New(info.getBool());
    case WebGLGetInfo::kTypeBoolArray: {
        const Vector<bool>& value = info.getBoolArray();
        v8::Local<v8::Array> array = v8::Array::New(value.size());
        for (size_t ii = 0; ii < value.size(); ++ii)
            array->Set(v8::Integer::New(ii), v8::Boolean::New(value[ii]));
        return array;
    }
    case WebGLGetInfo::kTypeFloat:
        return v8::Number::New(info.getFloat());
    case WebGLGetInfo::kTypeInt:
        return v8::Integer::New(info.getInt());
    case WebGLGetInfo::kTypeNull:
        return v8::Null();
    case WebGLGetInfo::kTypeString:
        return v8::String::New(fromWebCoreString(info.getString()), info.getString().length());
    case WebGLGetInfo::kTypeUnsignedInt:
        return v8::Integer::NewFromUnsigned(info.getUnsignedInt());
    case WebGLGetInfo::kTypeWebGLBuffer:
        return toV8(info.getWebGLBuffer(), isolate);
    case WebGLGetInfo::kTypeWebGLFloatArray:
        return toV8(info.getWebGLFloatArray(), isolate);
    case WebGLGetInfo::kTypeWebGLFramebuffer:
        return toV8(info.getWebGLFramebuffer(), isolate);
    case WebGLGetInfo::kTypeWebGLIntArray:
        return toV8(info.getWebGLIntArray(), isolate);
    case WebGLGetInfo::kTypeWebGLProgram:
        return toV8(info.getWebGLProgram(), isolate);
    case WebGLGetInfo::kTypeWebGLRenderbuffer:
        return toV8(info.getWebGLRenderbuffer(), isolate);
    case WebGLGetInfo::kTypeWebGLTexture:
        return toV8(info.getWebGLTexture(), isolate);
    case WebGLGetInfo::kTypeWebGLUnsignedByteArray:
        return toV8(info.getWebGLUnsignedByteArray(), isolate);
    case WebGLGetInfo::kTypeWebGLUnsignedIntArray:
        return toV8(info.getWebGLUnsignedIntArray(), isolate);
    case WebGLGetInfo::kTypeWebGLVertexArrayObjectOES:
        return toV8(info.getWebGLVertexArrayObjectOES(), isolate);
    default:
        notImplemented();
        return v8::Undefined();
    }
}

v8::Persistent<v8::FunctionTemplate> V8TestEventTarget::GetRawTemplate()
{
    V8BindingPerIsolateData* data = V8BindingPerIsolateData::current();
    V8BindingPerIsolateData::TemplateMap::iterator result = data->rawTemplateMap().find(&info);
    if (result != data->rawTemplateMap().end())
        return result->second;

    v8::HandleScope handleScope;
    v8::Persistent<v8::FunctionTemplate> templ = createRawTemplate();
    data->rawTemplateMap().add(&info, templ);
    return templ;
}

static v8::Handle<v8::Value> supplementalStr1AttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestInterface.supplementalStr1._get");
    TestInterface* imp = V8TestInterface::toNative(info.Holder());
    return v8String(TestSupplemental::supplementalStr1(imp), info.GetIsolate());
}

v8::Handle<v8::Value> V8WebGLRenderingContext::uniformMatrix2fvCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.uniformMatrix2fv()");
    return uniformMatrixHelper(args, 2);
}

static v8::Handle<v8::Value> doubleSequenceAttrAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.doubleSequenceAttr._get");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    return v8Array(imp->doubleSequenceAttr(), info.GetIsolate());
}

static v8::Handle<v8::Value> overloadedMethod6Callback(const v8::Arguments& args)
{
INC_STATS("DOM.TestObj.overloadedMethod6");
if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();
TestObj* imp = V8TestObj::toNative(args.Holder());
EXCEPTION_BLOCK(RefPtr<DOMStringList>, listArg, v8ValueToWebCoreDOMStringList(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));
imp->overloadedMethod(listArg);
return v8::Handle<v8::Value>();
}

void ScriptController::lowMemoryNotification()
{
    v8::V8::LowMemoryNotification();
}

static v8::Handle<v8::Value> cachedAttribute2AttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.cachedAttribute2._get");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    RefPtr<any> result = imp->cachedAttribute2();
    v8::Handle<v8::Value> wrapper = result.get() ? getDOMObjectMap(info.GetIsolate()).get(result.get()) : v8::Handle<v8::Object>();
    if (wrapper.IsEmpty()) {
        wrapper = toV8(result.get(), info.GetIsolate());
        if (!wrapper.IsEmpty())
            V8DOMWrapper::setNamedHiddenReference(info.Holder(), "cachedAttribute2", wrapper);
    }
    return wrapper;
}

static v8::Handle<v8::Value> supplementalMethod1Callback(const v8::Arguments& args)
{
    INC_STATS("DOM.TestInterface.supplementalMethod1");
    TestInterface* imp = V8TestInterface::toNative(args.Holder());
    TestSupplemental::supplementalMethod1(imp);
    return v8::Handle<v8::Value>();
}

v8::Handle<v8::Value> V8WebKitMutationObserver::constructorCallback(const v8::Arguments& args)
{
INC_STATS("DOM.WebKitMutationObserver.Constructor");

if (!args.IsConstructCall())
return V8Proxy::throwTypeError("DOM object constructor cannot be called as a function.");

if (ConstructorMode::current() == ConstructorMode::WrapExistingObject)
return args.Holder();

if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();

v8::Local<v8::Value> arg = args[0];
if (!arg->IsObject())
return throwError(TYPE_MISMATCH_ERR, args.GetIsolate());

ScriptExecutionContext* context = getScriptExecutionContext();
if (!context)
return V8Proxy::throwError(V8Proxy::ReferenceError, "WebKitMutationObserver constructor's associated frame unavailable", args.GetIsolate());

RefPtr<MutationCallback> callback = V8MutationCallback::create(arg, context);
RefPtr<WebKitMutationObserver> observer = WebKitMutationObserver::create(callback.release());

V8DOMWrapper::setDOMWrapper(args.Holder(), &info, observer.get());
V8DOMWrapper::setJSWrapperForDOMObject(observer.release(), v8::Persistent<v8::Object>::New(args.Holder()));
return args.Holder();
}

void ScriptController::setFlags(const char* string, int length)
{
    v8::V8::SetFlagsFromString(string, length);
}

void ScriptController::setCaptureCallStackForUncaughtExceptions(bool value)
{
    v8::V8::SetCaptureStackTraceForUncaughtExceptions(value, ScriptCallStack::maxCallStackSizeToCapture, stackTraceOptions);
}

void ScriptController::updatePlatformScriptObjects()
{
    notImplemented();
}

V8BindingPerContextData* V8Proxy::retrievePerContextData(Frame* frame)
{
    V8IsolatedContext* isolatedContext;
    if (UNLIKELY(!!(isolatedContext = V8IsolatedContext::getEntered())))
        return isolatedContext->perContextData();
    return V8Proxy::retrieve(frame)->windowShell()->perContextData();
}

static void enabledAtRuntimeAttr1AttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.enabledAtRuntimeAttr1._set");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    int v = toInt32(value);
    imp->setEnabledAtRuntimeAttr1(v);
    return;
}

bool V8TestCustomNamedGetter::HasInstance(v8::Handle<v8::Value> value)
{
    return GetRawTemplate()->HasInstance(value);
}

static void shortAttrAttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.shortAttr._set");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    int v = toInt32(value);
    imp->setShortAttr(v);
    return;
}

Frame* V8Proxy::retrieveFrameForCurrentContext()
{
    v8::Handle<v8::Context> context = v8::Context::GetCurrent();
    if (context.IsEmpty())
        return 0;
    return retrieveFrame(context);
}

DOMWindow* V8Proxy::retrieveWindowForCallingContext()
{
    v8::Handle<v8::Context> context = v8::Context::GetCalling();
    if (context.IsEmpty())
        return 0;
    return retrieveWindow(context);
}

static v8::Handle<v8::Value> conditionalAttr1AttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.conditionalAttr1._get");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    return v8::Integer::New(imp->conditionalAttr1());
}

static v8::Handle<v8::Value> immutablePointFunctionCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.TestObj.immutablePointFunction");
    TestObj* imp = V8TestObj::toNative(args.Holder());
    return toV8(WTF::getPtr(SVGPropertyTearOff<FloatPoint>::create(imp->immutablePointFunction())), args.GetIsolate());
}

void ScriptController::clearWindowShell(bool)
{
    m_proxy->clearForNavigation();
}

V8Proxy* V8Proxy::retrieve(ScriptExecutionContext* context)
{
    if (!context || !context->isDocument())
        return 0;
    return retrieve(static_cast<Document*>(context)->frame());
}

bool V8Proxy::handleOutOfMemory()
{
    v8::Local<v8::Context> context = v8::Context::GetCurrent();

    if (!context->HasOutOfMemoryException())
        return false;

    Frame* frame = V8Proxy::retrieveFrame(context);

    V8Proxy* proxy = V8Proxy::retrieve(frame);
    if (proxy) {
        proxy->clearForClose();

        proxy->windowShell()->destroyGlobal();
    }

#if PLATFORM(CHROMIUM)
    PlatformSupport::notifyJSOutOfMemory(frame);
#endif

    Settings* settings = frame->settings();
    ASSERT(settings);
    settings->setScriptEnabled(false);

    return true;
}

static void withScriptExecutionContextAndScriptStateWithSpacesAttributeAttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.withScriptExecutionContextAndScriptStateWithSpacesAttribute._set");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    TestObj* v = V8TestObj::HasInstance(value) ? V8TestObj::toNative(v8::Handle<v8::Object>::Cast(value)) : 0;
    ScriptState* state = ScriptState::current();
    if (!state)
        return;
    ScriptExecutionContext* scriptContext = getScriptExecutionContext();
    if (!scriptContext)
        return;
    imp->setWithScriptExecutionContextAndScriptStateWithSpacesAttribute(state, scriptContext, WTF::getPtr(v));
    if (state.hadException())
        throwError(state.exception(), info.GetIsolate());
    return;
}

static void conditionalAttr2AttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.conditionalAttr2._set");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    int v = toInt32(value);
    imp->setConditionalAttr2(v);
    return;
}

void batchConfigureCallbacks(v8::Handle<v8::ObjectTemplate> proto, 
                             v8::Handle<v8::Signature> signature, 
                             v8::PropertyAttribute attributes,
                             const BatchedCallback* callbacks,
                             size_t callbackCount)
{
    for (size_t i = 0; i < callbackCount; ++i) {
        proto->Set(v8::String::New(callbacks[i].name),
                   v8::FunctionTemplate::New(callbacks[i].callback, 
                                             v8::Handle<v8::Value>(),
                                             signature),
                   attributes);
    }
}

static void doubleSequenceAttrAttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.doubleSequenceAttr._set");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    Vector<double> v = toNativeArray<double>(value);
    imp->setDoubleSequenceAttr(v);
    return;
}

static v8::Handle<v8::Value> reflectedUnsignedIntegralAttrAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.reflectedUnsignedIntegralAttr._get");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    return v8::Integer::NewFromUnsigned(std::max(0, imp->getIntegralAttribute(WebCore::HTMLNames::reflectedunsignedintegralattrAttr)));
}

static v8::Handle<v8::Value> convert2Callback(const v8::Arguments& args)
{
INC_STATS("DOM.TestObj.convert2");
if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();
TestObj* imp = V8TestObj::toNative(args.Holder());
EXCEPTION_BLOCK(b*, , V8b::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8b::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
imp->convert2();
return v8::Handle<v8::Value>();
}

v8::Persistent<v8::FunctionTemplate> V8TestCustomNamedGetter::GetTemplate()
{
    V8BindingPerIsolateData* data = V8BindingPerIsolateData::current();
    V8BindingPerIsolateData::TemplateMap::iterator result = data->templateMap().find(&info);
    if (result != data->templateMap().end())
        return result->second;

    v8::HandleScope handleScope;
    v8::Persistent<v8::FunctionTemplate> templ =
        ConfigureV8TestCustomNamedGetterTemplate(GetRawTemplate());
    data->templateMap().add(&info, templ);
    return templ;
}

static v8::Handle<v8::Value> voidMethodWithArgsCallback(const v8::Arguments& args)
{
INC_STATS("DOM.TestObj.voidMethodWithArgs");
if (args.Length() < 3)
        return V8Proxy::throwNotEnoughArgumentsError();
TestObj* imp = V8TestObj::toNative(args.Holder());
EXCEPTION_BLOCK(int, intArg, toInt32(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));
STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, strArg, MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined));
EXCEPTION_BLOCK(TestObj*, objArg, V8TestObj::HasInstance(MAYBE_MISSING_PARAMETER(args, 2, DefaultIsUndefined)) ? V8TestObj::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 2, DefaultIsUndefined))) : 0);
imp->voidMethodWithArgs(intArg, strArg, objArg);
return v8::Handle<v8::Value>();
}

bool V8TestActiveDOMObject::HasInstance(v8::Handle<v8::Value> value)
{
    return GetRawTemplate()->HasInstance(value);
}

ScriptValue ScriptController::callFunctionEvenIfScriptDisabled(v8::Handle<v8::Function> function, v8::Handle<v8::Object> receiver, int argc, v8::Handle<v8::Value> argv[])
{
    return ScriptValue(m_proxy->callFunction(function, receiver, argc, argv));
}

v8::Handle<v8::Value> V8WebGLRenderingContext::vertexAttrib2fvCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.vertexAttrib2fv()");
    return vertexAttribAndUniformHelperf(args, kVertexAttrib2v);
}

static v8::Handle<v8::Value> itemCallback(const v8::Arguments& args)
{
INC_STATS("DOM.TestEventTarget.item");
if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();
TestEventTarget* imp = V8TestEventTarget::toNative(args.Holder());
ExceptionCode ec = 0;
{
EXCEPTION_BLOCK(int, index, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));
if (UNLIKELY(index < 0)) {
ec = INDEX_SIZE_ERR;
goto fail;
}
return toV8(imp->item(index), args.GetIsolate());
}
fail:
V8Proxy::setDOMException(ec, args.GetIsolate());
return v8::Handle<v8::Value>();
}

static void withScriptArgumentsAndCallStackAttributeAttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.withScriptArgumentsAndCallStackAttribute._set");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    TestObj* v = V8TestObj::HasInstance(value) ? V8TestObj::toNative(v8::Handle<v8::Object>::Cast(value)) : 0;
    RefPtr<ScriptCallStack> callStack(createScriptCallStackForInspector());
    if (!callStack)
        return v8::Undefined();
    imp->setWithScriptArgumentsAndCallStackAttribute(callStack, WTF::getPtr(v));
    return;
}

static v8::Handle<v8::Value> overloadedMethod3Callback(const v8::Arguments& args)
{
INC_STATS("DOM.TestObj.overloadedMethod3");
if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();
TestObj* imp = V8TestObj::toNative(args.Holder());
STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, strArg, MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined));
imp->overloadedMethod(strArg);
return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> booleanSequenceAttrAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.TestObj.booleanSequenceAttr._get");
    TestObj* imp = V8TestObj::toNative(info.Holder());
    return v8Array(imp->booleanSequenceAttr(), info.GetIsolate());
}
