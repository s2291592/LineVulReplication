bool ChromeContentRendererClient::OverrideCreatePlugin(
    content::RenderView* render_view,
    WebFrame* frame,
    const WebPluginParams& params,
    WebPlugin** plugin) {
  ChromeViewHostMsg_GetPluginInfo_Status status;
  webkit::WebPluginInfo plugin_info;
  std::string actual_mime_type;
  render_view->Send(new ChromeViewHostMsg_GetPluginInfo(
      render_view->GetRoutingID(), GURL(params.url),
      frame->top()->document().url(), params.mimeType.utf8(),
      &status, &plugin_info, &actual_mime_type));
  *plugin = CreatePlugin(render_view, frame, params,
                         status, plugin_info, actual_mime_type);
  return true;
}

bool ChromeContentRendererClient::IsAdblockPlusWithWebRequestInstalled() {
  return extension_dispatcher_->IsAdblockPlusWithWebRequestInstalled();
}

WebPlugin* ChromeContentRendererClient::CreatePlugin(
    content::RenderView* render_view,
    WebFrame* frame,
    const WebPluginParams& original_params,
    const ChromeViewHostMsg_GetPluginInfo_Status& status,
    const webkit::WebPluginInfo& plugin,
    const std::string& actual_mime_type) {
  ChromeViewHostMsg_GetPluginInfo_Status::Value status_value = status.value;
  GURL url(original_params.url);
  std::string orig_mime_type = original_params.mimeType.utf8();
  PluginPlaceholder* placeholder = NULL;
  if (status_value == ChromeViewHostMsg_GetPluginInfo_Status::kNotFound) {
    MissingPluginReporter::GetInstance()->ReportPluginMissing(
        orig_mime_type, url);
    placeholder = PluginPlaceholder::CreateMissingPlugin(
        render_view, frame, original_params);
  } else {
    scoped_ptr<webkit::npapi::PluginGroup> group(
        webkit::npapi::PluginList::Singleton()->GetPluginGroup(plugin));
    string16 name = group->GetGroupName();

    WebPluginParams params(original_params);
    for (size_t i = 0; i < plugin.mime_types.size(); ++i) {
      if (plugin.mime_types[i].mime_type == actual_mime_type) {
        AppendParams(plugin.mime_types[i].additional_param_names,
                     plugin.mime_types[i].additional_param_values,
                     &params.attributeNames,
                     &params.attributeValues);
        break;
      }
    }
    if (params.mimeType.isNull() && (actual_mime_type.size() > 0)) {
      params.mimeType = WebString::fromUTF8(actual_mime_type.c_str());
    }

    ContentSettingsObserver* observer =
        ContentSettingsObserver::Get(render_view);

    bool is_nacl_plugin =
        plugin.name ==
            ASCIIToUTF16(chrome::ChromeContentClient::kNaClPluginName);
    ContentSettingsType content_type =
        is_nacl_plugin ? CONTENT_SETTINGS_TYPE_JAVASCRIPT :
                         CONTENT_SETTINGS_TYPE_PLUGINS;

    if ((status_value ==
             ChromeViewHostMsg_GetPluginInfo_Status::kUnauthorized ||
         status_value == ChromeViewHostMsg_GetPluginInfo_Status::kClickToPlay ||
         status_value == ChromeViewHostMsg_GetPluginInfo_Status::kBlocked) &&
        observer->plugins_temporarily_allowed()) {
      status_value = ChromeViewHostMsg_GetPluginInfo_Status::kAllowed;
    }

    switch (status_value) {
      case ChromeViewHostMsg_GetPluginInfo_Status::kNotFound: {
        NOTREACHED();
        break;
      }
      case ChromeViewHostMsg_GetPluginInfo_Status::kAllowed: {
        if (prerender::PrerenderHelper::IsPrerendering(render_view)) {
          placeholder = PluginPlaceholder::CreateBlockedPlugin(
              render_view, frame, params, plugin, name,
              IDR_CLICK_TO_PLAY_PLUGIN_HTML, IDS_PLUGIN_LOAD);
          placeholder->set_blocked_for_prerendering(true);
          placeholder->set_allow_loading(true);
          break;
        }

        const char* kNaClMimeType = "application/x-nacl";
        bool is_nacl_mime_type = actual_mime_type == kNaClMimeType;
        bool is_nacl_unrestricted;
        if (is_nacl_plugin) {
          is_nacl_unrestricted = CommandLine::ForCurrentProcess()->HasSwitch(
              switches::kEnableNaCl);
        } else {
          is_nacl_unrestricted = true;
        }
        if (is_nacl_plugin || is_nacl_mime_type) {
          GURL manifest_url = is_nacl_mime_type ?
              url : GetNaClContentHandlerURL(actual_mime_type, plugin);
          const Extension* extension =
              extension_dispatcher_->extensions()->GetExtensionOrAppByURL(
                  ExtensionURLInfo(manifest_url));
          bool is_extension_from_webstore =
              extension && extension->from_webstore();
          bool is_extension_unrestricted = extension &&
              (extension->location() == Extension::COMPONENT ||
              extension->location() == Extension::LOAD);
          GURL top_url = frame->top()->document().url();
          if (!IsNaClAllowed(manifest_url,
                             top_url,
                             is_nacl_unrestricted,
                             is_extension_unrestricted,
                             is_extension_from_webstore,
                             &params)) {
            frame->addMessageToConsole(
                WebConsoleMessage(
                    WebConsoleMessage::LevelError,
                    "Only unpacked extensions and apps installed from the "
                    "Chrome Web Store can load NaCl modules without enabling "
                    "Native Client in about:flags."));
            placeholder = PluginPlaceholder::CreateBlockedPlugin(
                render_view, frame, params, plugin, name,
                IDR_BLOCKED_PLUGIN_HTML, IDS_PLUGIN_BLOCKED);
            break;
          }
        }
        return render_view->CreatePlugin(frame, plugin, params);
      }
      case ChromeViewHostMsg_GetPluginInfo_Status::kDisabled: {
        placeholder = PluginPlaceholder::CreateBlockedPlugin(
            render_view, frame, params, plugin, name,
            IDR_DISABLED_PLUGIN_HTML, IDS_PLUGIN_DISABLED);
        break;
      }
      case ChromeViewHostMsg_GetPluginInfo_Status::kOutdatedBlocked: {
#if defined(ENABLE_PLUGIN_INSTALLATION)
        placeholder = PluginPlaceholder::CreateBlockedPlugin(
            render_view, frame, params, plugin, name,
            IDR_BLOCKED_PLUGIN_HTML, IDS_PLUGIN_OUTDATED);
        placeholder->set_allow_loading(true);
        render_view->Send(new ChromeViewHostMsg_BlockedOutdatedPlugin(
            render_view->GetRoutingID(), placeholder->CreateRoutingId(),
            group->identifier()));
#else
        NOTREACHED();
#endif
        break;
      }
      case ChromeViewHostMsg_GetPluginInfo_Status::kOutdatedDisallowed: {
        placeholder = PluginPlaceholder::CreateBlockedPlugin(
            render_view, frame, params, plugin, name,
            IDR_BLOCKED_PLUGIN_HTML, IDS_PLUGIN_OUTDATED);
        break;
      }
      case ChromeViewHostMsg_GetPluginInfo_Status::kUnauthorized: {
        placeholder = PluginPlaceholder::CreateBlockedPlugin(
            render_view, frame, params, plugin, name,
            IDR_BLOCKED_PLUGIN_HTML, IDS_PLUGIN_NOT_AUTHORIZED);
        placeholder->set_allow_loading(true);
        render_view->Send(new ChromeViewHostMsg_BlockedUnauthorizedPlugin(
            render_view->GetRoutingID(), group->GetGroupName()));
        break;
      }
      case ChromeViewHostMsg_GetPluginInfo_Status::kClickToPlay: {
        placeholder = PluginPlaceholder::CreateBlockedPlugin(
            render_view, frame, params, plugin, name,
            IDR_CLICK_TO_PLAY_PLUGIN_HTML, IDS_PLUGIN_LOAD);
        placeholder->set_allow_loading(true);
        RenderThread::Get()->RecordUserMetrics("Plugin_ClickToPlay");
        observer->DidBlockContentType(content_type, group->identifier());
        break;
      }
      case ChromeViewHostMsg_GetPluginInfo_Status::kBlocked: {
        placeholder = PluginPlaceholder::CreateBlockedPlugin(
            render_view, frame, params, plugin, name,
            IDR_BLOCKED_PLUGIN_HTML, IDS_PLUGIN_BLOCKED);
        placeholder->set_allow_loading(true);
        RenderThread::Get()->RecordUserMetrics("Plugin_Blocked");
        observer->DidBlockContentType(content_type, group->identifier());
        break;
      }
    }
  }
  placeholder->SetStatus(status);
  return placeholder->plugin();
}

ChromeContentRendererClient::OverrideCreateWebMediaPlayer(
    content::RenderView* render_view,
    WebKit::WebFrame* frame,
    WebKit::WebMediaPlayerClient* client,
    base::WeakPtr<webkit_media::WebMediaPlayerDelegate> delegate,
    media::FilterCollection* collection,
    WebKit::WebAudioSourceProvider* audio_source_provider,
    media::MessageLoopFactory* message_loop_factory,
    webkit_media::MediaStreamClient* media_stream_client,
    media::MediaLog* media_log) {
  if (!prerender::PrerenderHelper::IsPrerendering(render_view))
    return NULL;

  return new prerender::PrerenderWebMediaPlayer(render_view, frame, client,
      delegate, collection, audio_source_provider, message_loop_factory,
      media_stream_client, media_log);
}

bool ChromeContentRendererClient::HandleSetCookieRequest(
    content::RenderView* sender,
    const GURL& url,
    const GURL& first_party_for_cookies,
    const std::string& value) {
  if (CommandLine::ForCurrentProcess()->HasSwitch(switches::kChromeFrame)) {
    sender->Send(new ChromeViewHostMsg_SetCookie(
        MSG_ROUTING_NONE, url, first_party_for_cookies, value));
    return true;
  }
  return false;
}

static WebTransformationMatrix blendTransformOperations(const WebTransformOperation* from, const WebTransformOperation* to, double progress)
{
    WebTransformationMatrix toReturn;
if (isIdentity(from) && isIdentity(to))
        return toReturn;

WebTransformOperation::Type interpolationType = WebTransformOperation::WebTransformOperationIdentity;
if (isIdentity(to))
interpolationType = from->type;
else
interpolationType = to->type;

switch (interpolationType) {
case WebTransformOperation::WebTransformOperationTranslate: {
double fromX = isIdentity(from) ? 0 : from->translate.x;
double fromY = isIdentity(from) ? 0 : from->translate.y;
double fromZ = isIdentity(from) ? 0 : from->translate.z;
double toX = isIdentity(to) ? 0 : to->translate.x;
double toY = isIdentity(to) ? 0 : to->translate.y;
double toZ = isIdentity(to) ? 0 : to->translate.z;
        toReturn.translate3d(blendDoubles(fromX, toX, progress),
                             blendDoubles(fromY, toY, progress),
                             blendDoubles(fromZ, toZ, progress));
break;
}
case WebTransformOperation::WebTransformOperationRotate: {
double axisX = 0;
double axisY = 0;
double axisZ = 1;
double fromAngle = 0;
double toAngle = isIdentity(to) ? 0 : to->rotate.angle;
if (shareSameAxis(from, to, axisX, axisY, axisZ, fromAngle))
            toReturn.rotate3d(axisX, axisY, axisZ, blendDoubles(fromAngle, toAngle, progress));
else {
WebTransformationMatrix toMatrix;
if (!isIdentity(to))
toMatrix = to->matrix;
WebTransformationMatrix fromMatrix;
if (!isIdentity(from))
fromMatrix = from->matrix;
            toReturn = toMatrix;
            toReturn.blend(fromMatrix, progress);
}
break;
}
case WebTransformOperation::WebTransformOperationScale: {
double fromX = isIdentity(from) ? 1 : from->scale.x;
double fromY = isIdentity(from) ? 1 : from->scale.y;
double fromZ = isIdentity(from) ? 1 : from->scale.z;
double toX = isIdentity(to) ? 1 : to->scale.x;
double toY = isIdentity(to) ? 1 : to->scale.y;
double toZ = isIdentity(to) ? 1 : to->scale.z;
        toReturn.scale3d(blendDoubles(fromX, toX, progress),
                         blendDoubles(fromY, toY, progress),
                         blendDoubles(fromZ, toZ, progress));
break;
}
case WebTransformOperation::WebTransformOperationSkew: {
double fromX = isIdentity(from) ? 0 : from->skew.x;
double fromY = isIdentity(from) ? 0 : from->skew.y;
double toX = isIdentity(to) ? 0 : to->skew.x;
double toY = isIdentity(to) ? 0 : to->skew.y;
        toReturn.skewX(blendDoubles(fromX, toX, progress));
        toReturn.skewY(blendDoubles(fromY, toY, progress));
break;
}
case WebTransformOperation::WebTransformOperationPerspective: {
double fromPerspectiveDepth = isIdentity(from) ? numeric_limits<double>::max() : from->perspectiveDepth;
double toPerspectiveDepth = isIdentity(to) ? numeric_limits<double>::max() : to->perspectiveDepth;
        toReturn.applyPerspective(blendDoubles(fromPerspectiveDepth, toPerspectiveDepth, progress));
break;
}
case WebTransformOperation::WebTransformOperationMatrix: {
WebTransformationMatrix toMatrix;
if (!isIdentity(to))
toMatrix = to->matrix;
WebTransformationMatrix fromMatrix;
if (!isIdentity(from))
fromMatrix = from->matrix;
        toReturn = toMatrix;
        toReturn.blend(fromMatrix, progress);
break;
}
case WebTransformOperation::WebTransformOperationIdentity:
// Do nothing.
break;
}

    return toReturn;
}

bool ChromeContentRendererClient::IsNaClAllowed(
    const GURL& manifest_url,
    const GURL& top_url,
    bool is_nacl_unrestricted,
    bool is_extension_unrestricted,
    bool is_extension_from_webstore,
    WebPluginParams* params) {
  bool is_whitelisted_url =
      ((top_url.SchemeIs("http") || top_url.SchemeIs("https")) &&
      (top_url.host() == "plus.google.com" ||
          top_url.host() == "plus.sandbox.google.com") &&
      top_url.path().find("/games") == 0);

  bool is_nacl_allowed =
      is_extension_from_webstore ||
      is_extension_unrestricted ||
      is_whitelisted_url ||
      is_nacl_unrestricted;
  if (is_nacl_allowed) {
    bool app_can_use_dev_interfaces =
        (is_extension_from_webstore &&
        manifest_url.SchemeIs("chrome-extension") &&
        manifest_url.host() == "acadkphlmlegjaadjagenfimbpphcgnh");
    WebString dev_attribute = WebString::fromUTF8("@dev");
    if ((!is_whitelisted_url && !is_extension_from_webstore) ||
        app_can_use_dev_interfaces) {
      std::vector<string16> param_names;
      std::vector<string16> param_values;
      param_names.push_back(dev_attribute);
      param_values.push_back(WebString());
      AppendParams(
          param_names,
          param_values,
          &params->attributeNames,
          &params->attributeValues);
    } else {
      size_t attribute_count = params->attributeNames.size();
      for (size_t i = 0; i < attribute_count; ++i) {
        if (params->attributeNames[i].equals(dev_attribute))
          params->attributeNames[i] = WebString();
      }
    }
  }
  return is_nacl_allowed;
}

bool ChromeContentRendererClient::AllowPopup(const GURL& creator) {
  ChromeV8Context* current_context =
      extension_dispatcher_->v8_context_set().GetCurrent();
  return current_context && !current_context->extension_id().empty();
}

bool ChromeContentRendererClient::IsAdblockWithWebRequestInstalled() {
  return extension_dispatcher_->IsAdblockWithWebRequestInstalled();
}

static bool shareSameAxis(const WebTransformOperation* from, const WebTransformOperation* to, double& axisX, double& axisY, double& axisZ, double& angleFrom)
{
    if (isIdentity(from) && isIdentity(to))
        return false;

    if (isIdentity(from) && !isIdentity(to)) {
        axisX = to->rotate.axis.x;
        axisY = to->rotate.axis.y;
        axisZ = to->rotate.axis.z;
        angleFrom = 0;
        return true;
    }

    if (!isIdentity(from) && isIdentity(to)) {
        axisX = from->rotate.axis.x;
        axisY = from->rotate.axis.y;
        axisZ = from->rotate.axis.z;
        angleFrom = from->rotate.angle;
        return true;
    }

    double length2 = from->rotate.axis.x * from->rotate.axis.x + from->rotate.axis.y * from->rotate.axis.y + from->rotate.axis.z * from->rotate.axis.z;
    double otherLength2 = to->rotate.axis.x * to->rotate.axis.x + to->rotate.axis.y * to->rotate.axis.y + to->rotate.axis.z * to->rotate.axis.z;

    if (length2 <= EPSILON || otherLength2 <= EPSILON)
        return false;

    double dot = to->rotate.axis.x * from->rotate.axis.x + to->rotate.axis.y * from->rotate.axis.y + to->rotate.axis.z * from->rotate.axis.z;
    double error = fabs(1.0 - (dot * dot) / (length2 * otherLength2));
    bool result = error < EPSILON;
    if (result) {
        axisX = to->rotate.axis.x;
        axisY = to->rotate.axis.y;
        axisZ = to->rotate.axis.z;
        angleFrom = dot > 0 ? from->rotate.angle : -from->rotate.angle;
    }
    return result;
}

bool ChromeContentRendererClient::IsAdblockPlusInstalled() {
  return extension_dispatcher_->extensions()->Contains(
      "cfhdojbkjhnklbpkdaibdccddilifddb");
}

bool ChromeContentRendererClient::HasErrorPage(int http_status_code,
                                               std::string* error_domain) {
  if (!LocalizedError::HasStrings(LocalizedError::kHttpErrorDomain,
                                  http_status_code)) {
    return false;
  }

  *error_domain = LocalizedError::kHttpErrorDomain;
  return true;
}

bool ChromeContentRendererClient::HandleGetCookieRequest(
    content::RenderView* sender,
    const GURL& url,
    const GURL& first_party_for_cookies,
    std::string* cookies) {
  if (CommandLine::ForCurrentProcess()->HasSwitch(switches::kChromeFrame)) {
    IPC::SyncMessage* msg = new ChromeViewHostMsg_GetCookies(
        MSG_ROUTING_NONE, url, first_party_for_cookies, cookies);
    sender->Send(msg);
    return true;
  }
  return false;
}

static double blendDoubles(double from, double to, double progress)
{
     return from * (1 - progress) + to * progress;
 }

void WebTransformOperations::appendRotate(double x, double y, double z, double degrees)
{
    WebTransformOperation toAdd;
    toAdd.matrix.rotate3d(x, y, z, degrees);
    toAdd.type = WebTransformOperation::WebTransformOperationRotate;
    toAdd.rotate.axis.x = x;
    toAdd.rotate.axis.y = y;
    toAdd.rotate.axis.z = z;
    toAdd.rotate.angle = degrees;
    m_private->operations.append(toAdd);
}

 void WebTransformOperations::appendTranslate(double x, double y, double z)
 {
     WebTransformOperation toAdd;
    toAdd.matrix.translate3d(x, y, z);
    toAdd.type = WebTransformOperation::WebTransformOperationTranslate;
    toAdd.translate.x = x;
    toAdd.translate.y = y;
    toAdd.translate.z = z;
    m_private->operations.append(toAdd);
}

    WebTransformOperation()
        : type(WebTransformOperationIdentity)
    {
    }

bool WebTransformOperations::matchesTypes(const WebTransformOperations& other) const
{
    if (isIdentity() || other.isIdentity())
        return true;

    if (m_private->operations.size() != other.m_private->operations.size())
        return false;

    for (size_t i = 0; i < m_private->operations.size(); ++i) {
        if (m_private->operations[i].type != other.m_private->operations[i].type
            && !m_private->operations[i].isIdentity()
            && !other.m_private->operations[i].isIdentity())
            return false;
    }

     return true;
 }

void ChromeContentRendererClient::RegisterPPAPIInterfaceFactories(
    webkit::ppapi::PpapiInterfaceFactoryManager* factory_manager) {
  factory_manager->RegisterFactory(ChromePPAPIInterfaceFactory);
}

void WebTransformOperations::appendScale(double x, double y, double z)
{
    WebTransformOperation toAdd;
    toAdd.matrix.scale3d(x, y, z);
    toAdd.type = WebTransformOperation::WebTransformOperationScale;
    toAdd.scale.x = x;
    toAdd.scale.y = y;
    toAdd.scale.z = z;
    m_private->operations.append(toAdd);
}

bool ExtensionResourceRequestPolicy::CanRequestResource(
const GURL& resource_url,
    const GURL& frame_url,
const ExtensionSet* loaded_extensions) {
CHECK(resource_url.SchemeIs(chrome::kExtensionScheme));

const Extension* extension =
loaded_extensions->GetExtensionOrAppByURL(ExtensionURLInfo(resource_url));
if (!extension) {
// Allow the load in the case of a non-existent extension. We'll just get a
// 404 from the browser process.
return true;
}

// Disallow loading of packaged resources for hosted apps. We don't allow
// hybrid hosted/packaged apps. The one exception is access to icons, since
// some extensions want to be able to do things like create their own
// launchers.
std::string resource_root_relative_path =
resource_url.path().empty() ? "" : resource_url.path().substr(1);
if (extension->is_hosted_app() &&
!extension->icons().ContainsPath(resource_root_relative_path)) {
LOG(ERROR) << "Denying load of " << resource_url.spec() << " from "
<< "hosted app.";
return false;
}

// Disallow loading of extension resources which are not explicitely listed
// as web accessible if the manifest version is 2 or greater.

// Exceptions are:
// - empty origin (needed for some edge cases when we have empty origins)
// - chrome-extension:// (for legacy reasons -- some extensions interop)
if (!CommandLine::ForCurrentProcess()->HasSwitch(
switches::kDisableExtensionsResourceWhitelist) &&
!frame_url.is_empty() &&
!frame_url.SchemeIs(chrome::kExtensionScheme) &&
!extension->IsResourceWebAccessible(resource_url.path())) {
LOG(ERROR) << "Denying load of " << resource_url.spec() << " which "
<< "is not a web accessible resource.";
return false;
}

return true;
}

void WebTransformOperations::initialize(const WebTransformOperations& other)
{
    if (m_private.get() != other.m_private.get())
        m_private.reset(new WebTransformOperationsPrivate(*other.m_private.get()));
    else
         initialize();
 }

void WebTransformOperations::initialize()
{
    m_private.reset(new WebTransformOperationsPrivate);
}

bool ChromeContentRendererClient::ShouldFork(WebFrame* frame,
                                             const GURL& url,
                                             bool is_initial_navigation,
                                             bool* send_referrer) {
  DCHECK(!frame->parent());

  if (prerender_dispatcher_.get() && prerender_dispatcher_->IsPrerenderURL(url))
    return true;

  const ExtensionSet* extensions = extension_dispatcher_->extensions();

  const Extension* new_url_extension = extensions::GetNonBookmarkAppExtension(
      *extensions, ExtensionURLInfo(url));
  bool is_extension_url = !!new_url_extension;

  if (CrossesExtensionExtents(frame, url, *extensions, is_extension_url,
          is_initial_navigation)) {
    *send_referrer = true;

    const Extension* extension =
        extension_dispatcher_->extensions()->GetExtensionOrAppByURL(
            ExtensionURLInfo(url));
    if (extension && extension->is_app()) {
      UMA_HISTOGRAM_ENUMERATION(
          extension_misc::kAppLaunchHistogram,
          extension_misc::APP_LAUNCH_CONTENT_NAVIGATION,
          extension_misc::APP_LAUNCH_BUCKET_BOUNDARY);
    }
    return true;
  }

  if (frame->top()->document().url() == url) {
    if (is_extension_url != extension_dispatcher_->is_extension_process())
      return true;
  }

  if (url.SchemeIs(kChromeUIScheme))
    return true;

  return false;
}

bool ChromeContentRendererClient::WillSendRequest(WebKit::WebFrame* frame,
const GURL& url,
GURL* new_url) {
// If the request is for an extension resource, check whether it should be
// allowed. If not allowed, we reset the URL to something invalid to prevent
// the request and cause an error.
if (url.SchemeIs(chrome::kExtensionScheme) &&
!ExtensionResourceRequestPolicy::CanRequestResource(
url,
          GURL(frame->document().url()),
extension_dispatcher_->extensions())) {
*new_url = GURL("chrome-extension://invalid/");
return true;
}

return false;
}

bool WebTransformOperations::isIdentity() const
{
    for (size_t i = 0; i < m_private->operations.size(); ++i) {
        if (!m_private->operations[i].isIdentity())
            return false;
    }
    return true;
}

WebTransformationMatrix WebTransformOperations::blend(const WebTransformOperations& from, double progress) const
{
WebTransformationMatrix toReturn;
    bool fromIdentity = from.isIdentity();
    bool toIdentity = isIdentity();
    if (fromIdentity && toIdentity)
        return toReturn;
    if (matchesTypes(from)) {
        size_t numOperations = max(fromIdentity ? 0 : from.m_private->operations.size(),
                                   toIdentity ? 0 : m_private->operations.size());
        for (size_t i = 0; i < numOperations; ++i) {
            WebTransformationMatrix blended = blendTransformOperations(
                fromIdentity ? 0 : &from.m_private->operations[i],
                toIdentity ? 0 : &m_private->operations[i],
                progress);
            toReturn.multiply(blended);
        }
    } else {
        toReturn = apply();
        WebTransformationMatrix fromTransform = from.apply();
        toReturn.blend(fromTransform, progress);
    }
return toReturn;
}

void WebTransformOperations::appendPerspective(double depth)
{
    WebTransformOperation toAdd;
    toAdd.matrix.applyPerspective(depth);
    toAdd.type = WebTransformOperation::WebTransformOperationPerspective;
    toAdd.perspectiveDepth = depth;
    m_private->operations.append(toAdd);
}

void ChromeContentRendererClient::GetNavigationErrorStrings(
    const WebKit::WebURLRequest& failed_request,
    const WebKit::WebURLError& error,
    std::string* error_html,
    string16* error_description) {
  const GURL failed_url = error.unreachableURL;
  const Extension* extension = NULL;
  const bool is_repost =
      error.reason == net::ERR_CACHE_MISS &&
      error.domain == WebString::fromUTF8(net::kErrorDomain) &&
      EqualsASCII(failed_request.httpMethod(), "POST");

  if (failed_url.is_valid() && !failed_url.SchemeIs(chrome::kExtensionScheme)) {
    extension = extension_dispatcher_->extensions()->GetExtensionOrAppByURL(
        ExtensionURLInfo(failed_url));
  }

  if (error_html) {
    int resource_id;
    DictionaryValue error_strings;
    if (extension && !extension->from_bookmark()) {
      LocalizedError::GetAppErrorStrings(error, failed_url, extension,
                                         &error_strings);

      resource_id = IDR_ERROR_APP_HTML;
    } else {
      if (is_repost) {
        LocalizedError::GetFormRepostStrings(failed_url, &error_strings);
      } else {
        LocalizedError::GetStrings(error, &error_strings);
      }
      resource_id = IDR_NET_ERROR_HTML;
    }

    const base::StringPiece template_html(
        ResourceBundle::GetSharedInstance().GetRawDataResource(resource_id));
    if (template_html.empty()) {
      NOTREACHED() << "unable to load template. ID: " << resource_id;
    } else {
      *error_html = jstemplate_builder::GetTemplatesHtml(
          template_html, &error_strings, "t");
    }
  }

  if (error_description) {
    if (!extension && !is_repost)
      *error_description = LocalizedError::GetErrorDetails(error);
  }
}

void WebTransformOperations::reset()
{
    m_private.reset(0);
}

ChromeContentRendererClient::ChromeContentRendererClient() {
}

static bool isIdentity(const WebTransformOperation* operation)
{
    return !operation || operation->isIdentity();
}

WebTransformationMatrix WebTransformOperations::apply() const
{
    WebTransformationMatrix toReturn;
    for (size_t i = 0; i < m_private->operations.size(); ++i)
        toReturn.multiply(m_private->operations[i].matrix);
    return toReturn;
}

void ChromeContentRendererClient::RenderThreadStarted() {
  chrome_observer_.reset(new ChromeRenderProcessObserver(this));
  extension_dispatcher_.reset(new ExtensionDispatcher());
  histogram_snapshots_.reset(new RendererHistogramSnapshots());
  net_predictor_.reset(new RendererNetPredictor());
  spellcheck_.reset(new SpellCheck());
  visited_link_slave_.reset(new VisitedLinkSlave());
#if defined(ENABLE_SAFE_BROWSING)
  phishing_classifier_.reset(safe_browsing::PhishingClassifierFilter::Create());
#endif
  prerender_dispatcher_.reset(new prerender::PrerenderDispatcher());

  RenderThread* thread = RenderThread::Get();

  thread->AddObserver(chrome_observer_.get());
  thread->AddObserver(extension_dispatcher_.get());
  thread->AddObserver(histogram_snapshots_.get());
#if defined(ENABLE_SAFE_BROWSING)
  thread->AddObserver(phishing_classifier_.get());
#endif
  thread->AddObserver(spellcheck_.get());
  thread->AddObserver(visited_link_slave_.get());
  thread->AddObserver(prerender_dispatcher_.get());

  thread->RegisterExtension(extensions_v8::ExternalExtension::Get());
  thread->RegisterExtension(extensions_v8::LoadTimesExtension::Get());
  thread->RegisterExtension(extensions_v8::SearchBoxExtension::Get());
  v8::Extension* search_extension = extensions_v8::SearchExtension::Get();
  if (search_extension)
    thread->RegisterExtension(search_extension);

  if (CommandLine::ForCurrentProcess()->HasSwitch(
          switches::kEnableBenchmarking))
    thread->RegisterExtension(extensions_v8::BenchmarkingExtension::Get());

  if (CommandLine::ForCurrentProcess()->HasSwitch(
          switches::kEnableIPCFuzzing)) {
    thread->GetChannel()->set_outgoing_message_filter(LoadExternalIPCFuzzer());
  }
  WebString chrome_ui_scheme(ASCIIToUTF16(chrome::kChromeUIScheme));
  WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(chrome_ui_scheme);

  WebString dev_tools_scheme(ASCIIToUTF16(chrome::kChromeDevToolsScheme));
  WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(dev_tools_scheme);

  WebString internal_scheme(ASCIIToUTF16(chrome::kChromeInternalScheme));
  WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(internal_scheme);

  WebSecurityPolicy::registerURLSchemeAsNotAllowingJavascriptURLs(
      chrome_ui_scheme);

  WebSecurityPolicy::registerURLSchemeAsSecure(chrome_ui_scheme);

  WebString extension_scheme(ASCIIToUTF16(chrome::kExtensionScheme));
  WebSecurityPolicy::registerURLSchemeAsSecure(extension_scheme);

  WebSecurityPolicy::registerURLSchemeAsCORSEnabled(extension_scheme);
}

void ChromeContentRendererClient::WillReleaseScriptContext(
    WebFrame* frame, v8::Handle<v8::Context> context, int world_id) {
  extension_dispatcher_->WillReleaseScriptContext(frame, context, world_id);
}

void ChromeContentRendererClient::RenderViewCreated(
    content::RenderView* render_view) {
  ContentSettingsObserver* content_settings =
      new ContentSettingsObserver(render_view);
  if (chrome_observer_.get()) {
    content_settings->SetContentSettingRules(
        chrome_observer_->content_setting_rules());
  }
  new ExtensionHelper(render_view, extension_dispatcher_.get());
  new PageLoadHistograms(render_view, histogram_snapshots_.get());
  new PrintWebViewHelper(render_view);
  new SearchBox(render_view);
  new SpellCheckProvider(render_view, this);
#if defined(ENABLE_SAFE_BROWSING)
  safe_browsing::MalwareDOMDetails::Create(render_view);
#endif

  PasswordAutofillManager* password_autofill_manager =
      new PasswordAutofillManager(render_view);
  AutofillAgent* autofill_agent = new AutofillAgent(render_view,
                                                    password_autofill_manager);
  PageClickTracker* page_click_tracker = new PageClickTracker(render_view);
  page_click_tracker->AddListener(password_autofill_manager);
  page_click_tracker->AddListener(autofill_agent);

  TranslateHelper* translate = new TranslateHelper(render_view);
  new ChromeRenderViewObserver(
      render_view, content_settings, chrome_observer_.get(),
      extension_dispatcher_.get(), translate);

  if (CommandLine::ForCurrentProcess()->HasSwitch(
          switches::kDomAutomationController)) {
    new AutomationRendererHelper(render_view);
  }
  if (CommandLine::ForCurrentProcess()->HasSwitch(
          switches::kEnablePasswordGeneration)) {
    new PasswordGenerationManager(render_view);
  }
}

bool ChromeContentRendererClient::CrossesExtensionExtents(
    WebFrame* frame,
    const GURL& new_url,
    const ExtensionSet& extensions,
    bool is_extension_url,
    bool is_initial_navigation) {
  GURL old_url(frame->top()->document().url());

  if (is_initial_navigation && old_url.is_empty() && frame->opener()) {
    WebDocument opener_document = frame->opener()->document();
    GURL opener_url = opener_document.url();
    WebSecurityOrigin opener_origin = opener_document.securityOrigin();
    bool opener_is_extension_url = !!extensions.GetExtensionOrAppByURL(
        ExtensionURLInfo(opener_origin, opener_url));
    WebSecurityOrigin opener = frame->opener()->document().securityOrigin();
    if (!is_extension_url &&
        !opener_is_extension_url &&
        extension_dispatcher_->is_extension_process() &&
        opener.canRequest(WebURL(new_url)))
      return false;

    old_url = frame->top()->opener()->top()->document().url();
  }

  return extensions::CrossesExtensionProcessBoundary(
      extensions, ExtensionURLInfo(old_url), ExtensionURLInfo(new_url));
}
