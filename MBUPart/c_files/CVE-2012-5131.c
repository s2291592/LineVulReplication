    virtual void didReadMetadata(const WebKit::WebFileInfo& info)
    {
        ASSERT(m_callbacks);
        if (info.type != WebKit::WebFileInfo::TypeFile || info.length < 0)
            m_callbacks->didFail(WebKit::WebFileErrorInvalidState);
        else {
            OwnPtr<AsyncFileWriterChromium> asyncFileWriterChromium = adoptPtr(new AsyncFileWriterChromium(m_client));
            OwnPtr<WebKit::WebFileWriter> webFileWriter = adoptPtr(m_webFileSystem->createFileWriter(m_path, asyncFileWriterChromium.get()));
            asyncFileWriterChromium->setWebFileWriter(webFileWriter.release());
            m_callbacks->didCreateFileWriter(asyncFileWriterChromium.release(), info.length);
        }
        delete this;
    }

void FileReaderLoader::didFinishLoading(unsigned long, double)
{
    if (m_variableLength && m_totalBytes > m_bytesLoaded) {
        RefPtr<ArrayBuffer> newData = m_rawData->slice(0, m_bytesLoaded);

        m_rawData = newData;
        m_totalBytes = m_bytesLoaded;
    }
    cleanup();
    if (m_client)
        m_client->didFinishLoading();
}

void BlobRegistryProxy::registerBlobURL(const KURL& url, const KURL& srcURL)
{
    if (m_webBlobRegistry)
        m_webBlobRegistry->registerBlobURL(url, srcURL);
}

BlobRegistry& blobRegistry()
{
    ASSERT(isMainThread());
    DEFINE_STATIC_LOCAL(BlobRegistryProxy, instance, ());
    return instance;
}

URLRegistry& Blob::registry() const
{
    return BlobURLRegistry::registry();
}

FileError::ErrorCode FileReaderLoader::httpStatusCodeToErrorCode(int httpStatusCode)
{
    switch (httpStatusCode) {
    case 403:
        return FileError::SECURITY_ERR;
    case 404:
        return FileError::NOT_FOUND_ERR;
    default:
        return FileError::NOT_READABLE_ERR;
    }
}

void BlobRegistryProxy::finalizeStream(const KURL& url)
{
    if (m_webBlobRegistry)
        m_webBlobRegistry->finalizeStream(url);
}

void ThreadableBlobRegistry::registerBlobURL(const KURL& url, PassOwnPtr<BlobData> blobData)
{
    if (isMainThread())
        blobRegistry().registerBlobURL(url, blobData);
    else {
OwnPtr<BlobRegistryContext> context = adoptPtr(new BlobRegistryContext(url, blobData));
callOnMainThread(&registerBlobURLTask, context.leakPtr());
}
}

    virtual void didReadDirectory(const WebKit::WebVector<WebKit::WebFileSystemEntry>& entries, bool hasMore)
    {
        ASSERT_NOT_REACHED();
        delete this;
    }

FileReaderLoader::~FileReaderLoader()
{
terminate();
if (!m_urlForReading.isEmpty())
        ThreadableBlobRegistry::unregisterBlobURL(m_urlForReading);
}

void AsyncFileSystemChromium::removeRecursively(const KURL& path, PassOwnPtr<AsyncFileSystemCallbacks> callbacks)
{
    m_webFileSystem->removeRecursively(path, new WebKit::WebFileSystemCallbacksImpl(callbacks));
}

 PassRefPtr<Blob> Blob::slice(long long start, long long end, const String& contentType) const
{
    long long size;
    double modificationTime;
    if (isFile()) {
        toFile(this)->captureSnapshot(size, modificationTime);
    } else {
        ASSERT(m_size != -1);
        size = m_size;
    }

    if (start < 0)
        start = start + size;
    if (end < 0)
        end = end + size;

    if (start < 0)
        start = 0;
    if (end < 0)
        end = 0;
    if (start >= size) {
        start = 0;
        end = 0;
    } else if (end < start)
        end = start;
    else if (end > size)
        end = size;

    long long length = end - start;
    OwnPtr<BlobData> blobData = BlobData::create();
    blobData->setContentType(contentType);
    if (isFile()) {
        if (!toFile(this)->fileSystemURL().isEmpty())
            blobData->appendURL(toFile(this)->fileSystemURL(), start, length, modificationTime);
        else
            blobData->appendFile(toFile(this)->path(), start, length, modificationTime);
    } else
        blobData->appendBlob(m_internalURL, start, length);

    return Blob::create(blobData.release(), length);
}

static void registerBlobURLFromTask(void* context)
{
OwnPtr<BlobRegistryContext> blobRegistryContext = adoptPtr(static_cast<BlobRegistryContext*>(context));
    blobRegistry().registerBlobURL(blobRegistryContext->url, blobRegistryContext->srcURL);
}

Blob::~Blob()
{
    ThreadableBlobRegistry::unregisterBlobURL(m_internalURL);
}

void BlobData::appendFile(const String& path)
{
    m_items.append(BlobDataItem(path));
}

void BlobRegistryProxy::registerBlobURL(const KURL& url, PassOwnPtr<BlobData> blobData)
{
    if (m_webBlobRegistry) {
        WebKit::WebBlobData webBlobData(blobData);
        m_webBlobRegistry->registerBlobURL(url, webBlobData);
    }
}

void FileReaderLoader::setRange(unsigned start, unsigned length)
{
    ASSERT(length > 0);
    m_hasRange = true;
    m_rangeStart = start;
    m_rangeEnd = start + length - 1;
}

void BlobData::appendURL(const KURL& url, long long offset, long long length, double expectedModificationTime)
{
    m_items.append(BlobDataItem(url, offset, length, expectedModificationTime));
}

void BlobRegistryProxy::registerStreamURL(const KURL& url, const String& type)
{
    if (m_webBlobRegistry)
        m_webBlobRegistry->registerStreamURL(url, type);
}

void AsyncFileSystemChromium::createWriter(AsyncFileWriterClient* client, const KURL& path, PassOwnPtr<AsyncFileSystemCallbacks> callbacks)
{
    m_webFileSystem->readMetadata(path, new FileWriterHelperCallbacks(client, path, m_webFileSystem, callbacks));
}

void FileReaderLoader::convertToDataURL()
{
    StringBuilder builder;
    builder.append("data:");

    if (!m_bytesLoaded) {
        m_stringResult = builder.toString();
        return;
    }

    builder.append(m_dataType);
    builder.append(";base64,");

    Vector<char> out;
    base64Encode(static_cast<const char*>(m_rawData->data()), m_bytesLoaded, out);
    out.append('\0');
    builder.append(out.data());

    m_stringResult = builder.toString();
}

void FileReaderLoader::terminate()
{
    if (m_loader) {
        m_loader->cancel();
        cleanup();
    }
}

AsyncFileSystemChromium::~AsyncFileSystemChromium()
{
}

    BlobRegistryContext(const KURL& url, const KURL& srcURL)
        : url(url.copy())
        , srcURL(srcURL.copy())
    {
    }

void ThreadableBlobRegistry::addDataToStream(const KURL& url, PassRefPtr<RawData> streamData)
{
if (isMainThread()) {
        blobRegistry().addDataToStream(url, streamData);
} else {
OwnPtr<BlobRegistryContext> context = adoptPtr(new BlobRegistryContext(url, streamData));
callOnMainThread(&addDataToStreamTask, context.leakPtr());
}
}

void FileReaderLoader::setEncoding(const String& encoding)
{
    if (!encoding.isEmpty())
        m_encoding = WTF::TextEncoding(encoding);
}

void FileReaderLoader::start(ScriptExecutionContext* scriptExecutionContext, Blob* blob)
{
// The blob is read by routing through the request handling layer given a temporary public url.
m_urlForReading = BlobURL::createPublicURL(scriptExecutionContext->securityOrigin());
if (m_urlForReading.isEmpty()) {
failed(FileError::SECURITY_ERR);
return;
}
    ThreadableBlobRegistry::registerBlobURL(scriptExecutionContext->securityOrigin(), m_urlForReading, blob->url());

// Construct and load the request.
ResourceRequest request(m_urlForReading);
request.setHTTPMethod("GET");
if (m_hasRange)
request.setHTTPHeaderField("Range", String::format("bytes=%d-%d", m_rangeStart, m_rangeEnd));

ThreadableLoaderOptions options;
options.sendLoadCallbacks = SendCallbacks;
options.sniffContent = DoNotSniffContent;
options.preflightPolicy = ConsiderPreflight;
options.allowCredentials = AllowStoredCredentials;
options.crossOriginRequestPolicy = DenyCrossOriginRequests;
// FIXME: Is there a directive to which this load should be subject?
options.contentSecurityPolicyEnforcement = DoNotEnforceContentSecurityPolicy;

if (m_client)
m_loader = ThreadableLoader::create(scriptExecutionContext, this, request, options);
else
ThreadableLoader::loadResourceSynchronously(scriptExecutionContext, request, *this, options);
}

void FileReaderLoader::didReceiveResponse(unsigned long, const ResourceResponse& response)
{
    if (response.httpStatusCode() != 200) {
        failed(httpStatusCodeToErrorCode(response.httpStatusCode()));
        return;
    }

    unsigned long long length = response.expectedContentLength();

    if (length > INT_MAX) {
        m_variableLength = true;
        if (m_hasRange)
            length = 1 + m_rangeEnd - m_rangeStart;
        else
            length = defaultBufferLength;
    }

    if (length > numeric_limits<unsigned>::max()) {
        failed(FileError::NOT_READABLE_ERR);
        return;
    }

    ASSERT(!m_rawData);
    m_rawData = ArrayBuffer::create(static_cast<unsigned>(length), 1);

    if (!m_rawData) {
        failed(FileError::NOT_READABLE_ERR);
        return;
    }

    m_totalBytes = static_cast<unsigned>(length);

    if (m_client)
        m_client->didStartLoading();
}

    virtual void didOpenFileSystem(const WebKit::WebString& name, const WebKit::WebURL& rootURL)
    {
        ASSERT_NOT_REACHED();
        delete this;
    }

void ThreadableBlobRegistry::unregisterBlobURL(const KURL& url)
{
if (BlobURL::getOrigin(url) == "null")
originMap()->remove(url.string());

    if (isMainThread())
        blobRegistry().unregisterBlobURL(url);
    else {
OwnPtr<BlobRegistryContext> context = adoptPtr(new BlobRegistryContext(url));
callOnMainThread(&unregisterBlobURLTask, context.leakPtr());
}
}

void BlobData::detachFromCurrentThread()
{
    m_contentType = m_contentType.isolatedCopy();
    m_contentDisposition = m_contentDisposition.isolatedCopy();
    for (size_t i = 0; i < m_items.size(); ++i)
        m_items.at(i).detachFromCurrentThread();
}

void ThreadableBlobRegistry::finalizeStream(const KURL& url)
{
if (isMainThread()) {
        blobRegistry().finalizeStream(url);
} else {
OwnPtr<BlobRegistryContext> context = adoptPtr(new BlobRegistryContext(url));
callOnMainThread(&finalizeStreamTask, context.leakPtr());
}
}

void BlobData::appendBlob(const KURL& url, long long offset, long long length)
{
    m_items.append(BlobDataItem(url, offset, length));
}

String FileReaderLoader::stringResult()
{
    ASSERT(m_readType != ReadAsArrayBuffer && m_readType != ReadAsBlob);

    if (!m_rawData || m_errorCode)
        return m_stringResult;

    if (m_isRawDataConverted)
        return m_stringResult;

    switch (m_readType) {
    case ReadAsArrayBuffer:
        break;
    case ReadAsBinaryString:
        m_stringResult = String(static_cast<const char*>(m_rawData->data()), m_bytesLoaded);
        break;
    case ReadAsText:
        convertToText();
        break;
    case ReadAsDataURL:
        if (isCompleted())
            convertToDataURL();
        break;
    default:
        ASSERT_NOT_REACHED();
    }
    
    return m_stringResult;
}

void AsyncFileSystemChromium::move(const KURL& sourcePath, const KURL& destinationPath, PassOwnPtr<AsyncFileSystemCallbacks> callbacks)
{
    m_webFileSystem->move(sourcePath, destinationPath, new WebKit::WebFileSystemCallbacksImpl(callbacks));
}

void FileReaderLoader::failed(int errorCode)
{
    m_errorCode = errorCode;
    cleanup();
    if (m_client)
        m_client->didFail(m_errorCode);
}

    virtual void didFail(WebKit::WebFileError error)
    {
        ASSERT(m_callbacks);
        m_callbacks->didFail(error);
        delete this;
    }

PassRefPtr<Blob> FileReaderLoader::blobResult()
{
    ASSERT(m_readType == ReadAsBlob);

    if (!m_rawData || m_errorCode || !isCompleted())
        return 0;

    if (!m_blobResult) {
        OwnPtr<BlobData> blobData = BlobData::create();
        size_t size = 0;
        RefPtr<RawData> rawData = RawData::create();
        size = m_rawData->byteLength();
        rawData->mutableData()->append(static_cast<char*>(m_rawData->data()), size);
        blobData->appendData(rawData, 0, size);
        blobData->setContentType(m_dataType);
        m_blobResult = Blob::create(blobData.release(), size);
    }
    return m_blobResult;
}

Blob::Blob()
: m_size(0)
{
ScriptWrappable::init(this);
OwnPtr<BlobData> blobData = BlobData::create();

// Create a new internal URL and register it with the provided blob data.
m_internalURL = BlobURL::createInternalURL();
    ThreadableBlobRegistry::registerBlobURL(m_internalURL, blobData.release());
}

AsyncFileSystemChromium::AsyncFileSystemChromium()
    : m_webFileSystem(WebKit::Platform::current()->fileSystem())
{
    ASSERT(m_webFileSystem);
}

void BlobData::appendData(PassRefPtr<RawData> data, long long offset, long long length)
{
    m_items.append(BlobDataItem(data, offset, length));
}

void AsyncFileSystemChromium::fileExists(const KURL& path, PassOwnPtr<AsyncFileSystemCallbacks> callbacks)
{
    m_webFileSystem->fileExists(path, new WebKit::WebFileSystemCallbacksImpl(callbacks));
}

FileReaderLoader::FileReaderLoader(ReadType readType, FileReaderLoaderClient* client)
    : m_readType(readType)
    , m_client(client)
    , m_isRawDataConverted(false)
    , m_stringResult("")
    , m_variableLength(false)
    , m_bytesLoaded(0)
    , m_totalBytes(0)
    , m_hasRange(false)
    , m_rangeStart(0)
    , m_rangeEnd(0)
    , m_errorCode(0)
{
}

void AsyncFileSystemChromium::copy(const KURL& sourcePath, const KURL& destinationPath, PassOwnPtr<AsyncFileSystemCallbacks> callbacks)
{
    m_webFileSystem->copy(sourcePath, destinationPath, new WebKit::WebFileSystemCallbacksImpl(callbacks));
}

    BlobRegistryContext(const KURL& url, const String& type)
        : url(url.copy())
        , type(type.isolatedCopy())
    {
    }

void AsyncFileSystemChromium::directoryExists(const KURL& path, PassOwnPtr<AsyncFileSystemCallbacks> callbacks)
{
    m_webFileSystem->directoryExists(path, new WebKit::WebFileSystemCallbacksImpl(callbacks));
}

void AsyncFileSystemChromium::readMetadata(const KURL& path, PassOwnPtr<AsyncFileSystemCallbacks> callbacks)
{
    m_webFileSystem->readMetadata(path, new WebKit::WebFileSystemCallbacksImpl(callbacks));
}

void FileReaderLoader::convertToText()
{
    if (!m_bytesLoaded)
        return;

    StringBuilder builder;
    if (!m_decoder)
        m_decoder = TextResourceDecoder::create("text/plain", m_encoding.isValid() ? m_encoding : UTF8Encoding());
    builder.append(m_decoder->decode(static_cast<const char*>(m_rawData->data()), m_bytesLoaded));

    if (isCompleted())
        builder.append(m_decoder->flush());

    m_stringResult = builder.toString();
}

PassOwnPtr<BlobData> BlobData::create()
{
    return adoptPtr(new BlobData());
}

 URLRegistry& BlobURLRegistry::registry()
{
    DEFINE_STATIC_LOCAL(BlobURLRegistry, instance, ());
    return instance;
}

BlobDataHandle::~BlobDataHandle()
{
    ThreadableBlobRegistry::unregisterBlobURL(m_internalURL);
}

void ThreadableBlobRegistry::registerStreamURL(const KURL& url, const String& type)
{
if (isMainThread()) {
        blobRegistry().registerStreamURL(url, type);
} else {
OwnPtr<BlobRegistryContext> context = adoptPtr(new BlobRegistryContext(url, type));
callOnMainThread(&registerStreamURLTask, context.leakPtr());
}
}

void BlobDataItem::detachFromCurrentThread()
{
    data->detachFromCurrentThread();
    path = path.isolatedCopy();
    url = url.copy();
}

bool FileReaderLoader::isCompleted() const
{
    return m_bytesLoaded == m_totalBytes;
}

void BlobData::swapItems(BlobDataItemList& items)
{
    m_items.swap(items);
}

void BlobURLRegistry::registerURL(SecurityOrigin* origin, const KURL& publicURL, URLRegistrable* blob)
{
ASSERT(&blob->registry() == this);
    ThreadableBlobRegistry::registerBlobURL(origin, publicURL, static_cast<Blob*>(blob)->url());
}

void AsyncFileSystemChromium::createSnapshotFileAndReadMetadata(const KURL& path, PassOwnPtr<AsyncFileSystemCallbacks> callbacks)
{
    m_webFileSystem->createSnapshotFileAndReadMetadata(path, new WebKit::WebFileSystemCallbacksImpl(callbacks));
}

void FileReaderLoader::didFail(const ResourceError&)
{
    if (m_errorCode == FileError::ABORT_ERR)
        return;

    failed(FileError::NOT_READABLE_ERR);
}

BlobRegistryProxy::BlobRegistryProxy()
    : m_webBlobRegistry(WebKit::Platform::current()->blobRegistry())
{
}

void BlobData::appendFile(const String& path, long long offset, long long length, double expectedModificationTime)
{
    m_items.append(BlobDataItem(path, offset, length, expectedModificationTime));
}

static void registerBlobURLTask(void* context)
{
OwnPtr<BlobRegistryContext> blobRegistryContext = adoptPtr(static_cast<BlobRegistryContext*>(context));
    blobRegistry().registerBlobURL(blobRegistryContext->url, blobRegistryContext->blobData.release());
}

void FileReaderLoader::cleanup()
{
    m_loader = 0;

    if (m_errorCode) {
        m_rawData = 0;
        m_stringResult = "";
    }
}

BlobRegistry::~BlobRegistry()
{
}

    FileWriterHelperCallbacks(AsyncFileWriterClient* client, const KURL& path, WebKit::WebFileSystem* webFileSystem, PassOwnPtr<WebCore::AsyncFileSystemCallbacks> callbacks)
        : m_client(client)
        , m_path(path)
        , m_webFileSystem(webFileSystem)
        , m_callbacks(callbacks)
    {
    }

    virtual void didCreateSnapshotFile(const WebKit::WebFileInfo& info)
    {
        ASSERT_NOT_REACHED();
        delete this;
    }

void AsyncFileSystemChromium::remove(const KURL& path, PassOwnPtr<AsyncFileSystemCallbacks> callbacks)
{
    m_webFileSystem->remove(path, new WebKit::WebFileSystemCallbacksImpl(callbacks));
}

void FileReaderLoader::cancel()
{
    m_errorCode = FileError::ABORT_ERR;
    terminate();
}

void AsyncFileSystemChromium::createFile(const KURL& path, bool exclusive, PassOwnPtr<AsyncFileSystemCallbacks> callbacks)
{
    m_webFileSystem->createFile(path, exclusive, new WebKit::WebFileSystemCallbacksImpl(callbacks));
}

void BlobRegistryProxy::unregisterBlobURL(const KURL& url)
{
    if (m_webBlobRegistry)
        m_webBlobRegistry->unregisterBlobURL(url);
}

Blob::Blob(const KURL& srcURL, const String& type, long long size)
: m_type(type)
, m_size(size)
{
ScriptWrappable::init(this);

// Create a new internal URL and register it with the same blob data as the source URL.
m_internalURL = BlobURL::createInternalURL();
    ThreadableBlobRegistry::registerBlobURL(0, m_internalURL, srcURL);
}

void BlobRegistryProxy::addDataToStream(const KURL& url, PassRefPtr<RawData> streamData)
{
    if (m_webBlobRegistry) {
        WebKit::WebThreadSafeData webThreadSafeData(streamData);
        m_webBlobRegistry->addDataToStream(url, webThreadSafeData);
    }
}

static void finalizeStreamTask(void* context)
{
OwnPtr<BlobRegistryContext> blobRegistryContext = adoptPtr(static_cast<BlobRegistryContext*>(context));
    blobRegistry().finalizeStream(blobRegistryContext->url);
}

PassRefPtr<ArrayBuffer> FileReaderLoader::arrayBufferResult() const
{
    ASSERT(m_readType == ReadAsArrayBuffer);

    if (!m_rawData || m_errorCode)
        return 0;

    if (isCompleted())
        return m_rawData;

    return ArrayBuffer::create(m_rawData.get());
}
