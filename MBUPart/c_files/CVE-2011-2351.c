void SyncBackendHost::FinishConfigureDataTypesOnFrontendLoop() {
  DCHECK_EQ(MessageLoop::current(), frontend_loop_);

  VLOG(1) << "Syncer in config mode. SBH executing"
          << "FinishConfigureDataTypesOnFrontendLoop";
  if (pending_config_mode_state_->deleted_type) {
    core_thread_.message_loop()->PostTask(FROM_HERE,
        NewRunnableMethod(core_.get(),
        &SyncBackendHost::Core::DeferNudgeForCleanup));
  }

  if (pending_config_mode_state_->added_types.none() &&
      !core_->syncapi()->InitialSyncEndedForAllEnabledTypes()) {
    LOG(WARNING) << "No new types, but initial sync not finished."
                 << "Possible sync db corruption / removal.";
    pending_config_mode_state_->added_types =
        syncable::ModelTypeBitSetFromSet(
            pending_config_mode_state_->initial_types);
  }

  if (pending_config_mode_state_->added_types.none()) {
    VLOG(1) << "SyncBackendHost(" << this << "): No new types added. "
            << "Calling ready_task directly";
    pending_config_mode_state_->ready_task->Run();
  } else {
    pending_download_state_.reset(pending_config_mode_state_.release());

    syncable::ModelTypeBitSet types_copy(pending_download_state_->added_types);
    if (IsNigoriEnabled())
      types_copy.set(syncable::NIGORI);
    VLOG(1) <<  "SyncBackendHost(" << this << "):New Types added. "
            << "Calling DoRequestConfig";
    core_thread_.message_loop()->PostTask(FROM_HERE,
         NewRunnableMethod(core_.get(),
                           &SyncBackendHost::Core::DoRequestConfig,
                           types_copy,
                           pending_download_state_->reason));
  }

  pending_config_mode_state_.reset();

  core_thread_.message_loop()->PostTask(FROM_HERE,
      NewRunnableMethod(core_.get(),
                        &SyncBackendHost::Core::DoUpdateEnabledTypes));
}

    SyncBackendHost::GetAutofillMigrationState() {
  return core_->syncapi()->GetAutofillMigrationState();
}

void SyncBackendHost::Core::DeferNudgeForCleanup() {
  DCHECK_EQ(MessageLoop::current(), host_->core_thread_.message_loop());
  deferred_nudge_for_cleanup_requested_ = true;
}

void SyncBackendHost::HandleInitializationCompletedOnFrontendLoop() {
  if (!frontend_)
    return;
  syncapi_initialized_ = true;
  frontend_->OnBackendInitialized();
}

bool SyncBackendHost::RequestClearServerData() {
  core_thread_.message_loop()->PostTask(FROM_HERE,
     NewRunnableMethod(core_.get(),
     &SyncBackendHost::Core::DoRequestClearServerData));
  return true;
}

void SyncBackendHost::Core::RemoveParentJsEventRouter() {
  DCHECK_EQ(MessageLoop::current(), host_->frontend_loop_);
  parent_router_ = NULL;
  MessageLoop* core_message_loop = host_->core_thread_.message_loop();
  CHECK(core_message_loop);
  core_message_loop->PostTask(
      FROM_HERE,
      NewRunnableMethod(this,
                        &SyncBackendHost::Core::DisconnectChildJsEventRouter));
}

void SyncBackendHost::SetPassphrase(const std::string& passphrase,
                                    bool is_explicit) {
  if (!IsNigoriEnabled()) {
    LOG(WARNING) << "Silently dropping SetPassphrase request.";
    return;
  }

  DCHECK_EQ(MessageLoop::current(), frontend_loop_);
  if (core_->processing_passphrase()) {
    VLOG(1) << "Attempted to call SetPassphrase while already waiting for "
            << " result from previous SetPassphrase call. Silently dropping.";
    return;
  }
  core_->set_processing_passphrase();

  core_thread_.message_loop()->PostTask(FROM_HERE,
      NewRunnableMethod(core_.get(), &SyncBackendHost::Core::DoSetPassphrase,
                        passphrase, is_explicit));
}

void SyncBackendHost::RequestNudge(const tracked_objects::Location& location) {
  core_thread_.message_loop()->PostTask(FROM_HERE,
      NewRunnableMethod(core_.get(), &SyncBackendHost::Core::DoRequestNudge,
                        location));
}

void SyncBackendHost::StartSyncingWithServer() {
  VLOG(1) << "SyncBackendHost::StartSyncingWithServer called.";
  core_thread_.message_loop()->PostTask(FROM_HERE,
      NewRunnableMethod(core_.get(), &SyncBackendHost::Core::DoStartSyncing));
}

void SyncBackendHost::Core::SaveChanges() {
  syncapi_->SaveChanges();
}

  virtual bool RunOnDBThread(history::HistoryBackend* backend,
                             history::HistoryDatabase* db) {
    work_->Run();
    done_->Signal();
    return true;
  }

void SyncBackendHost::ActivateDataType(
    DataTypeController* data_type_controller,
    ChangeProcessor* change_processor) {
  base::AutoLock lock(registrar_lock_);

  browser_sync::ModelSafeRoutingInfo::iterator i =
      registrar_.routing_info.find(data_type_controller->type());
  DCHECK(i != registrar_.routing_info.end());
  DCHECK((*i).second == GROUP_PASSIVE);
  syncable::ModelType type = data_type_controller->type();
  registrar_.routing_info[type] = data_type_controller->model_safe_group();

  DCHECK_EQ(processors_.count(type), 0U);
  processors_[type] = change_processor;

  change_processor->Start(profile_, GetUserShare());
}

SyncBackendHost::~SyncBackendHost() {
  DCHECK(!core_ && !frontend_) << "Must call Shutdown before destructor.";
  DCHECK(registrar_.workers.empty());
}

  virtual void DoneRunOnMainThread() {}

void SyncBackendHost::InitCore(const Core::DoInitializeOptions& options) {
  core_thread_.message_loop()->PostTask(FROM_HERE,
      NewRunnableMethod(core_.get(), &SyncBackendHost::Core::DoInitialize,
                        options));
}

SyncBackendHost::SyncBackendHost(Profile* profile)
    : core_(new Core(ALLOW_THIS_IN_INITIALIZER_LIST(this))),
      core_thread_("Chrome_SyncCoreThread"),
      frontend_loop_(MessageLoop::current()),
      profile_(profile),
      frontend_(NULL),
      sync_data_folder_path_(
          profile_->GetPath().Append(kSyncDataFolderName)),
      last_auth_error_(AuthError::None()),
      syncapi_initialized_(false) {
}

void SyncBackendHost::Core::DisconnectChildJsEventRouter() {
  DCHECK_EQ(MessageLoop::current(), host_->core_thread_.message_loop());
  syncapi_->GetJsBackend()->RemoveParentJsEventRouter();
  syncapi_->RemoveObserver(&sync_manager_observer_);
}

std::string MakeUserAgentForSyncapi() {
  std::string user_agent;
  user_agent = "Chrome ";
#if defined(OS_WIN)
  user_agent += "WIN ";
#elif defined(OS_LINUX)
  user_agent += "LINUX ";
#elif defined(OS_FREEBSD)
  user_agent += "FREEBSD ";
#elif defined(OS_OPENBSD)
  user_agent += "OPENBSD ";
#elif defined(OS_MACOSX)
  user_agent += "MAC ";
#endif
  chrome::VersionInfo version_info;
  if (!version_info.is_valid()) {
    DLOG(ERROR) << "Unable to create chrome::VersionInfo object";
    return user_agent;
  }

  user_agent += version_info.Version();
  user_agent += " (" + version_info.LastChange() + ")";
  if (!version_info.IsOfficialBuild())
    user_agent += "-devel";
  return user_agent;
}

HistoryModelWorker::~HistoryModelWorker() {
}

void SyncBackendHost::Core::DoSetPassphrase(const std::string& passphrase,
                                            bool is_explicit) {
  DCHECK(MessageLoop::current() == host_->core_thread_.message_loop());
  syncapi_->SetPassphrase(passphrase, is_explicit);
}

void SyncBackendHost::Initialize(
SyncFrontend* frontend,
const GURL& sync_service_url,
const syncable::ModelTypeSet& types,
net::URLRequestContextGetter* baseline_context_getter,
const SyncCredentials& credentials,
bool delete_sync_data_folder) {
if (!core_thread_.Start())
return;

frontend_ = frontend;
DCHECK(frontend);

// Create a worker for the UI thread and route bookmark changes to it.
// TODO(tim): Pull this into a method to reuse.  For now we don't even
// need to lock because we init before the syncapi exists and we tear down
// after the syncapi is destroyed.  Make sure to NULL-check workers_ indices
// when a new type is synced as the worker may already exist and you just
// need to update routing_info_.
registrar_.workers[GROUP_DB] = new DatabaseModelWorker();
registrar_.workers[GROUP_UI] = new UIModelWorker();
registrar_.workers[GROUP_PASSIVE] = new ModelSafeWorker();
  if (CommandLine::ForCurrentProcess()->HasSwitch(
      switches::kEnableSyncTypedUrls) || types.count(syncable::TYPED_URLS)) {
    // TODO(tim): Bug 53916.  HistoryModelWorker crashes, so avoid adding it
    // unless specifically requested until bug is fixed.
    registrar_.workers[GROUP_HISTORY] =
        new HistoryModelWorker(
            profile_->GetHistoryService(Profile::IMPLICIT_ACCESS));
  }

// Any datatypes that we want the syncer to pull down must
// be in the routing_info map.  We set them to group passive, meaning that
// updates will be applied, but not dispatched to the UI thread yet.
for (syncable::ModelTypeSet::const_iterator it = types.begin();
it != types.end(); ++it) {
registrar_.routing_info[(*it)] = GROUP_PASSIVE;
}

PasswordStore* password_store =
profile_->GetPasswordStore(Profile::IMPLICIT_ACCESS);
if (password_store) {
registrar_.workers[GROUP_PASSWORD] =
new PasswordModelWorker(password_store);
} else {
LOG_IF(WARNING, types.count(syncable::PASSWORDS) > 0) << "Password store "
<< "not initialized, cannot sync passwords";
registrar_.routing_info.erase(syncable::PASSWORDS);
}

// Nigori is populated by default now.
registrar_.routing_info[syncable::NIGORI] = GROUP_PASSIVE;

// TODO(akalin): Create SyncNotifier here and pass it in as part of
// DoInitializeOptions.
core_->CreateSyncNotifier(baseline_context_getter);

InitCore(Core::DoInitializeOptions(
sync_service_url,
MakeHttpBridgeFactory(baseline_context_getter),
credentials,
delete_sync_data_folder,
RestoreEncryptionBootstrapToken(),
false));
}

void SyncBackendHost::Core::DoEncryptDataTypes(
    const syncable::ModelTypeSet& encrypted_types) {
  DCHECK(MessageLoop::current() == host_->core_thread_.message_loop());
  syncapi_->EncryptDataTypes(encrypted_types);
}

string16 SyncBackendHost::GetAuthenticatedUsername() const {
  DCHECK(syncapi_initialized_);
  return UTF8ToUTF16(core_->syncapi()->GetAuthenticatedUsername());
}

void SyncBackendHost::Core::ConnectChildJsEventRouter() {
  DCHECK_EQ(MessageLoop::current(), host_->core_thread_.message_loop());
  if (!syncapi_->GetJsBackend()->GetParentJsEventRouter()) {
    syncapi_->GetJsBackend()->SetParentJsEventRouter(this);
    syncapi_->AddObserver(&sync_manager_observer_);
  }
}

bool SyncBackendHost::IsCryptographerReady(
    const sync_api::BaseTransaction* trans) const {
  return syncapi_initialized_ && trans->GetCryptographer()->is_ready();
}

SyncBackendHost::SyncBackendHost()
    : core_thread_("Chrome_SyncCoreThread"),
      frontend_loop_(MessageLoop::current()),
      profile_(NULL),
      frontend_(NULL),
      last_auth_error_(AuthError::None()),
      syncapi_initialized_(false) {
}

  WorkerTask(Callback0::Type* work, WaitableEvent* done)
    : work_(work), done_(done) {}

void SyncBackendHost::Core::DoUpdateEnabledTypes() {
  DCHECK(MessageLoop::current() == host_->core_thread_.message_loop());
  syncapi_->UpdateEnabledTypes();
}

void SyncBackendHost::Core::StartSavingChanges() {
  save_changes_timer_.Start(
      base::TimeDelta::FromSeconds(kSaveChangesIntervalSeconds),
      this, &Core::SaveChanges);
}

void SyncBackendHost::Core::set_processing_passphrase() {
  DCHECK(MessageLoop::current() == host_->frontend_loop_);
  processing_passphrase_ = true;
}

bool HistoryModelWorker::CurrentThreadIsWorkThread() {
  return true;
}

void SyncBackendHost::Core::HandleSyncCycleCompletedOnFrontendLoop(
    SyncSessionSnapshot* snapshot) {
  if (!host_ || !host_->frontend_)
    return;
  DCHECK_EQ(MessageLoop::current(), host_->frontend_loop_);

  host_->last_snapshot_.reset(snapshot);

  const syncable::ModelTypeSet& to_migrate =
      snapshot->syncer_status.types_needing_local_migration;
  if (!to_migrate.empty())
    host_->frontend_->OnMigrationNeededForTypes(to_migrate);

  if (host_->pending_download_state_.get()) {
    bool found_all_added = true;
    for (syncable::ModelTypeSet::const_iterator it =
             host_->pending_download_state_->initial_types.begin();
         it != host_->pending_download_state_->initial_types.end();
         ++it) {
      if (host_->pending_download_state_->added_types.test(*it))
        found_all_added &= snapshot->initial_sync_ended.test(*it);
    }
    if (!found_all_added) {
      NOTREACHED() << "Update didn't return updates for all types requested.";
    } else {
      host_->pending_download_state_->ready_task->Run();
    }
    host_->pending_download_state_.reset();
  }
  host_->frontend_->OnSyncCycleCompleted();
}

SyncBackendHost::Core::~Core() {
}

void SyncBackendHost::Core::DoStartSyncing() {
  DCHECK(MessageLoop::current() == host_->core_thread_.message_loop());
  syncapi_->StartSyncingNormally();
  if (deferred_nudge_for_cleanup_requested_)
    syncapi_->RequestNudge(FROM_HERE);
  deferred_nudge_for_cleanup_requested_ = false;
}

void SyncBackendHost::GetModelSafeRoutingInfo(ModelSafeRoutingInfo* out) {
  base::AutoLock lock(registrar_lock_);
  ModelSafeRoutingInfo copy(registrar_.routing_info);
  out->swap(copy);
}

void SyncBackendHost::Core::RouteJsMessageReply(
    const std::string& name, const JsArgList& args,
    const JsEventHandler* target) {
  host_->frontend_loop_->PostTask(
      FROM_HERE, NewRunnableMethod(
          this, &Core::RouteJsMessageReplyOnFrontendLoop,
          name, args, target));
}

void SyncBackendHost::ConfigureAutofillMigration() {
  if (GetAutofillMigrationState() == syncable::NOT_DETERMINED) {
    sync_api::ReadTransaction trans(GetUserShare());
    sync_api::ReadNode autofil_root_node(&trans);

    if (!autofil_root_node.InitByTagLookup(browser_sync::kAutofillTag)) {
        SetAutofillMigrationState(syncable::INSUFFICIENT_INFO_TO_DETERMINE);
      return;
    }

    if (autofil_root_node.GetFirstChildId() == static_cast<int64>(0)) {
      SetAutofillMigrationState(syncable::INSUFFICIENT_INFO_TO_DETERMINE);
      return;
    }

    sync_api::ReadNode autofill_profile_root_node(&trans);

    if (!autofill_profile_root_node.InitByTagLookup(
       browser_sync::kAutofillProfileTag)) {
      SetAutofillMigrationState(syncable::NOT_MIGRATED);
      return;
    }

    DCHECK(false);

    SetAutofillMigrationState(syncable::NOT_MIGRATED);
    return;
  }
}

void SyncBackendHost::Core::RouteJsEventOnFrontendLoop(
    const std::string& name, const JsEventDetails& details) {
  if (!host_ || !parent_router_)
    return;

  DCHECK_EQ(MessageLoop::current(), host_->frontend_loop_);

  parent_router_->RouteJsEvent(name, details);
}

SyncBackendHost::Core::Core(SyncBackendHost* backend)
    : host_(backend),
      syncapi_(new sync_api::SyncManager()),
      sync_manager_observer_(ALLOW_THIS_IN_INITIALIZER_LIST(this)),
      parent_router_(NULL),
      processing_passphrase_(false),
      deferred_nudge_for_cleanup_requested_(false) {
}

bool SyncBackendHost::IsUsingExplicitPassphrase() {
  return IsNigoriEnabled() && syncapi_initialized_ &&
      core_->syncapi()->InitialSyncEndedForAllEnabledTypes() &&
      core_->syncapi()->IsUsingExplicitPassphrase();
}

SyncBackendHost::StatusSummary SyncBackendHost::GetStatusSummary() {
  DCHECK(syncapi_initialized_);
  return core_->syncapi()->GetStatusSummary();
}

void SyncBackendHost::ConfigureDataTypes(
    const DataTypeController::TypeMap& data_type_controllers,
    const syncable::ModelTypeSet& types,
    sync_api::ConfigureReason reason,
    CancelableTask* ready_task) {
  DCHECK(!pending_config_mode_state_.get());
  DCHECK(!pending_download_state_.get());
  DCHECK(syncapi_initialized_);

  if (types.count(syncable::AUTOFILL_PROFILE) != 0) {
    ConfigureAutofillMigration();
  }

  {
    base::AutoLock lock(registrar_lock_);
    pending_config_mode_state_.reset(
        MakePendingConfigModeState(data_type_controllers, types, ready_task,
                                   &registrar_.routing_info, reason));
  }

  StartConfiguration(NewCallback(core_.get(),
      &SyncBackendHost::Core::FinishConfigureDataTypes));
}

HistoryModelWorker::HistoryModelWorker(HistoryService* history_service)
  : history_service_(history_service) {
}

void SyncBackendHost::LogUnsyncedItems(int level) const {
  DCHECK(syncapi_initialized_);
  return core_->syncapi()->LogUnsyncedItems(level);
}

void SyncBackendHost::Core::DoProcessMessage(
    const std::string& name, const JsArgList& args,
    const JsEventHandler* sender) {
  DCHECK_EQ(MessageLoop::current(), host_->core_thread_.message_loop());
  syncapi_->GetJsBackend()->ProcessMessage(name, args, sender);
}

void SyncBackendHost::Core::DoUpdateCredentials(
    const SyncCredentials& credentials) {
  DCHECK(MessageLoop::current() == host_->core_thread_.message_loop());
  syncapi_->UpdateCredentials(credentials);
}

    SyncBackendHost::GetAutofillMigrationDebugInfo() {
  return core_->syncapi()->GetAutofillMigrationDebugInfo();
}

    SyncBackendHost::MakePendingConfigModeState(
        const DataTypeController::TypeMap& data_type_controllers,
        const syncable::ModelTypeSet& types,
        CancelableTask* ready_task,
        ModelSafeRoutingInfo* routing_info,
        sync_api::ConfigureReason reason) {
  PendingConfigureDataTypesState* state = new PendingConfigureDataTypesState();
  for (DataTypeController::TypeMap::const_iterator it =
           data_type_controllers.begin();
       it != data_type_controllers.end(); ++it) {
    syncable::ModelType type = it->first;
    if (types.count(type) == 0) {
      state->deleted_type = true;
      routing_info->erase(type);
    } else {
      if (routing_info->count(type) == 0) {
        (*routing_info)[type] = GROUP_PASSIVE;
        state->added_types.set(type);
      }
    }
  }

  state->ready_task.reset(ready_task);
  state->initial_types = types;
  state->reason = reason;
  return state;
}

void SyncBackendHost::Core::OnChangesApplied(
    syncable::ModelType model_type,
    const sync_api::BaseTransaction* trans,
    const sync_api::SyncManager::ChangeRecord* changes,
    int change_count) {
  if (!host_ || !host_->frontend_) {
    DCHECK(false) << "OnChangesApplied called after Shutdown?";
    return;
  }
  ChangeProcessor* processor = GetProcessor(model_type);
  if (!processor)
    return;

  processor->ApplyChangesFromSyncModel(trans, changes, change_count);
}

void SyncBackendHost::Core::RouteJsMessageReplyOnFrontendLoop(
    const std::string& name, const JsArgList& args,
    const JsEventHandler* target) {
  if (!host_ || !parent_router_)
    return;

  DCHECK_EQ(MessageLoop::current(), host_->frontend_loop_);

  parent_router_->RouteJsMessageReply(name, args, target);
}

void SyncBackendHost::DeactivateDataType(
    DataTypeController* data_type_controller,
    ChangeProcessor* change_processor) {
  base::AutoLock lock(registrar_lock_);
  registrar_.routing_info.erase(data_type_controller->type());

  change_processor->Stop();
  std::map<syncable::ModelType, ChangeProcessor*>::size_type erased =
      processors_.erase(data_type_controller->type());
  DCHECK_EQ(erased, 1U);
}

void SyncBackendHost::Core::NotifyPassphraseRequired(
    sync_api::PassphraseRequiredReason reason) {
  if (!host_ || !host_->frontend_)
    return;

  DCHECK_EQ(MessageLoop::current(), host_->frontend_loop_);

  if (reason == sync_api::REASON_SET_PASSPHRASE_FAILED)
    processing_passphrase_ = false;

  if (processing_passphrase_) {
    VLOG(1) << "Core received OnPassphraseRequired while processing a "
            << "passphrase. Silently dropping.";
    return;
  }

  host_->frontend_->OnPassphraseRequired(reason);
}

bool SyncBackendHost::Core::IsCurrentThreadSafeForModel(
    syncable::ModelType model_type) {
  base::AutoLock lock(host_->registrar_lock_);

  browser_sync::ModelSafeRoutingInfo::const_iterator routing_it =
      host_->registrar_.routing_info.find(model_type);
  if (routing_it == host_->registrar_.routing_info.end())
    return false;
  browser_sync::ModelSafeGroup group = routing_it->second;
  WorkerMap::const_iterator worker_it = host_->registrar_.workers.find(group);
  if (worker_it == host_->registrar_.workers.end())
    return false;
  ModelSafeWorker* worker = worker_it->second;
  return worker->CurrentThreadIsWorkThread();
}

void SyncBackendHost::Core::CreateSyncNotifier(
    const scoped_refptr<net::URLRequestContextGetter>& request_context_getter) {
  const std::string& client_info = webkit_glue::GetUserAgent(GURL());
  SyncNotifierFactory sync_notifier_factory(client_info);
  sync_notifier_.reset(sync_notifier_factory.CreateSyncNotifier(
      *CommandLine::ForCurrentProcess(),
      request_context_getter));
}

const JsEventRouter* SyncBackendHost::Core::GetParentJsEventRouter() const {
  DCHECK_EQ(MessageLoop::current(), host_->frontend_loop_);
  return parent_router_;
}

PendingConfigureDataTypesState() : deleted_type(false),
    reason(sync_api::CONFIGURE_REASON_UNKNOWN) {}

void SyncBackendHost::GetWorkers(std::vector<ModelSafeWorker*>* out) {
  base::AutoLock lock(registrar_lock_);
  out->clear();
  for (WorkerMap::const_iterator it = registrar_.workers.begin();
       it != registrar_.workers.end(); ++it) {
    out->push_back((*it).second);
  }
}

ChangeProcessor* SyncBackendHost::Core::GetProcessor(
    syncable::ModelType model_type) {
  std::map<syncable::ModelType, ChangeProcessor*>::const_iterator it =
      host_->processors_.find(model_type);

  if (it == host_->processors_.end())
    return NULL;

  if (!IsCurrentThreadSafeForModel(model_type)) {
    NOTREACHED() << "Changes applied on wrong thread.";
    return NULL;
  }

  ChangeProcessor* processor = it->second;

  if (!processor->IsRunning())
    return NULL;

  return processor;
}

sync_api::HttpPostProviderFactory* SyncBackendHost::MakeHttpBridgeFactory(
    net::URLRequestContextGetter* getter) {
  return new HttpBridgeFactory(getter);
}

void SyncBackendHost::Core::HandleInitalizationCompletedOnFrontendLoop() {
  if (!host_)
    return;
  host_->HandleInitializationCompletedOnFrontendLoop();
}

bool SyncBackendHost::IsNigoriEnabled() const {
  base::AutoLock lock(registrar_lock_);
  return registrar_.routing_info.find(syncable::NIGORI) !=
      registrar_.routing_info.end();
}

JsBackend* SyncBackendHost::GetJsBackend() {
  if (syncapi_initialized_) {
    return core_.get();
  } else {
    NOTREACHED();
    return NULL;
  }
}

void SyncBackendHost::UpdateCredentials(const SyncCredentials& credentials) {
  core_thread_.message_loop()->PostTask(FROM_HERE,
      NewRunnableMethod(core_.get(),
                        &SyncBackendHost::Core::DoUpdateCredentials,
                        credentials));
}

ModelSafeGroup HistoryModelWorker::GetModelSafeGroup() {
  return GROUP_HISTORY;
}

void SyncBackendHost::Core::DeleteSyncDataFolder() {
  if (file_util::DirectoryExists(host_->sync_data_folder_path())) {
    if (!file_util::Delete(host_->sync_data_folder_path(), true))
      LOG(DFATAL) << "Could not delete the Sync Data folder.";
  }
}

void HistoryModelWorker::DoWorkAndWaitUntilDone(Callback0::Type* work) {
WaitableEvent done(false, false);
scoped_refptr<WorkerTask> task(new WorkerTask(work, &done));
  history_service_->ScheduleDBTask(task.get(), this);
done.Wait();
}

SyncBackendHost::Core::DoInitializeOptions::DoInitializeOptions(
    const GURL& service_url,
    sync_api::HttpPostProviderFactory* http_bridge_factory,
    const sync_api::SyncCredentials& credentials,
    bool delete_sync_data_folder,
    const std::string& restored_key_for_bootstrapping,
    bool setup_for_test_mode)
    : service_url(service_url),
      http_bridge_factory(http_bridge_factory),
      credentials(credentials),
      delete_sync_data_folder(delete_sync_data_folder),
      restored_key_for_bootstrapping(restored_key_for_bootstrapping),
      setup_for_test_mode(setup_for_test_mode) {
}

void SyncBackendHost::Core::DoRequestNudge(
    const tracked_objects::Location& nudge_location) {
  syncapi_->RequestNudge(nudge_location);
}

UIModelWorker* SyncBackendHost::ui_worker() {
  ModelSafeWorker* w = registrar_.workers[GROUP_UI];
  if (w == NULL)
    return NULL;
  if (w->GetModelSafeGroup() != GROUP_UI)
    NOTREACHED();
  return static_cast<UIModelWorker*>(w);
}

void SyncBackendHost::Core::OnInitializationComplete() {
  if (!host_ || !host_->frontend_)
    return;  // We may have been told to Shutdown before initialization

  host_->frontend_loop_->PostTask(FROM_HERE,
      NewRunnableMethod(this,
                        &Core::HandleInitalizationCompletedOnFrontendLoop));

  host_->core_thread_.message_loop()->PostTask(FROM_HERE,
      NewRunnableMethod(this, &Core::StartSavingChanges));
}

bool SyncBackendHost::Core::processing_passphrase() const {
  DCHECK(MessageLoop::current() == host_->frontend_loop_);
  return processing_passphrase_;
}

void SyncBackendHost::SetAutofillMigrationState(
    syncable::AutofillMigrationState state) {
  return core_->syncapi()->SetAutofillMigrationState(state);
}
