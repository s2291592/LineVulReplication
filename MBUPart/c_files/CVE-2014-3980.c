command_forward_key_event (Fep *fep,
			   FepControlMessage *request)
{
  uint32_t keyval, modifiers;
  if (_fep_control_message_read_uint32_arg (request, 0, &keyval) == 0
      && _fep_control_message_read_uint32_arg (request, 1, &modifiers) == 0)
    {
      size_t length;
      char *data = _fep_key_to_string (keyval, modifiers, &length);
      if (data)
	{
	  _fep_output_send_data (fep, data, length);
	  free (data);
	}
    }
}

_fep_close_control_socket (Fep *fep)
{
  if (fep->server >= 0)
    close (fep->server);
  remove_control_socket (fep->control_socket_path);
  free (fep->control_socket_path);
}

_fep_open_control_socket (Fep *fep)
{
struct sockaddr_un sun;
char *path;
int fd;
ssize_t sun_len;

fd = socket (AF_UNIX, SOCK_STREAM, 0);
if (fd < 0)
{
perror ("socket");
return -1;
}

path = create_socket_name ("fep-XXXXXX/control");
if (strlen (path) + 1 >= sizeof(sun.sun_path))
{
fep_log (FEP_LOG_LEVEL_WARNING,
"unix domain socket path too long: %d + 1 >= %d",
strlen (path),
sizeof (sun.sun_path));
free (path);
return -1;
}

memset (&sun, 0, sizeof(sun));
sun.sun_family = AF_UNIX;

#ifdef __linux__
  sun.sun_path[0] = '\0';
  memcpy (sun.sun_path + 1, path, strlen (path));
  sun_len = offsetof (struct sockaddr_un, sun_path) + strlen (path) + 1;
  remove_control_socket (path);
#else
memcpy (sun.sun_path, path, strlen (path));
sun_len = sizeof (struct sockaddr_un);
#endif

if (bind (fd, (const struct sockaddr *) &sun, sun_len) < 0)
{
perror ("bind");
free (path);
close (fd);
return -1;
}

if (listen (fd, 5) < 0)
{
perror ("listen");
free (path);
close (fd);
return -1;
}

fep->server = fd;
fep->control_socket_path = path;
return 0;
}

fep_client_send_data (FepClient *client, const char *data, size_t length)
{
  FepControlMessage message;

  message.command = FEP_CONTROL_SEND_DATA;
  _fep_control_message_alloc_args (&message, 1);
  _fep_control_message_write_string_arg (&message, 0, data, length);

  if (client->filter_running)
    client->messages = _fep_append_control_message (client->messages, &message);
  else
    _fep_write_control_message (client->control, &message);
  _fep_control_message_free_args (&message);
}

fep_client_get_poll_fd (FepClient *client)
{
  return client->control;
}

fep_client_send_text (FepClient *client, const char *text)
{
  FepControlMessage message;

  message.command = FEP_CONTROL_SEND_TEXT;
  _fep_control_message_alloc_args (&message, 1);
  _fep_control_message_write_string_arg (&message, 0, text, strlen (text) + 1);

  if (client->filter_running)
    client->messages = _fep_append_control_message (client->messages, &message);
  else
    _fep_write_control_message (client->control, &message);
  _fep_control_message_free_args (&message);
}

_fep_transceive_control_message (Fep               *fep,
                                 int                fd,
                                 FepControlMessage *request,
                                 FepControlMessage *response)
{
  FepList *messages = NULL;
  int retval = 0;

  retval = _fep_write_control_message (fd, request);
  if (retval < 0)
    return retval;

  while (true)
    {
      FepControlMessage message;

      retval = _fep_read_control_message (fd, &message);
      if (retval < 0)
	goto out;

      if (message.command == FEP_CONTROL_RESPONSE)
	{
	  memcpy (response, &message, sizeof (FepControlMessage));
	  break;
	}

      fep_log (FEP_LOG_LEVEL_DEBUG,
	       "not a control response %d",
	       message.command);

      messages = _fep_append_control_message (messages, &message);
    }

  if (response->n_args == 0)
    {
      _fep_control_message_free_args (response);
      fep_log (FEP_LOG_LEVEL_WARNING,
	       "too few arguments for RESPONSE");
      retval = -1;
      goto out;
    }

  if (response->args[0].len != 1)
    {
      _fep_control_message_free_args (response);
      fep_log (FEP_LOG_LEVEL_WARNING,
	       "can't extract command from RESPONSE");
      retval = -1;
      goto out;
    }

  if (*response->args[0].str != request->command)
    {
      _fep_control_message_free_args (response);
      fep_log (FEP_LOG_LEVEL_WARNING,
	       "commands do not match (%d != %d)",
	       *response->args[0].str,
	       request->command);
      retval = -1;
      goto out;
    }

 out:
  /* flush queued messages received during waiting for response */
  while (messages)
    {
      FepList *_head = messages;
      FepControlMessage *_message = _head->data;

      messages = _head->next;

      _fep_dispatch_control_message (fep, _message);
      _fep_control_message_free (_message);
      free (_head);
    }
  return retval;
}

command_resize_event (FepClient         *client,
                      FepControlMessage *request,
                      FepControlMessage *response)
{
  FepEventResize event;
  int retval;
  uint32_t intval;

  retval = _fep_control_message_read_uint32_arg (request, 0, &intval);
  if (retval < 0)
    {
      fep_log (FEP_LOG_LEVEL_WARNING, "can't read keyval");
      goto out;
    }
  event.cols = intval;

  retval = _fep_control_message_read_uint32_arg (request, 1, &intval);
  if (retval < 0)
    {
      fep_log (FEP_LOG_LEVEL_WARNING, "can't read modifiers");
      goto out;
    }
  event.rows = intval;

 out:
  response->command = FEP_CONTROL_RESPONSE;
  _fep_control_message_alloc_args (response, 2);
  _fep_control_message_write_uint8_arg (response, 0, FEP_CONTROL_RESIZE_EVENT);

  intval = retval;
  if (retval == 0 && client->filter)
    {
      event.event.type = FEP_RESIZED;
      intval = client->filter ((FepEvent *) &event, client->filter_data);
      _fep_control_message_write_uint32_arg (response, 1, intval);
    }
}

_fep_dispatch_control_message (Fep *fep, FepControlMessage *message)
{
  static const struct
  {
    int command;
    void (*handler) (Fep *fep,
		     FepControlMessage *request);
  } handlers[] =
      {
	{ FEP_CONTROL_SET_CURSOR_TEXT, command_set_cursor_text },
	{ FEP_CONTROL_SET_STATUS_TEXT, command_set_status_text },
	{ FEP_CONTROL_SEND_TEXT, command_send_text },
	{ FEP_CONTROL_SEND_DATA, command_send_data },
	{ FEP_CONTROL_FORWARD_KEY_EVENT, command_forward_key_event }
      };
  int i;

  for (i = 0;
       i < SIZEOF (handlers) && handlers[i].command != message->command;
       i++)
    ;
  if (i == SIZEOF (handlers))
    {
      fep_log (FEP_LOG_LEVEL_WARNING,
	       "no handler defined for %d", message->command);
      return -1;
    }

  handlers[i].handler (fep, message);
  return 0;
}

fep_client_open (const char *address)
{
FepClient *client;
struct sockaddr_un sun;
ssize_t sun_len;
int retval;

if (!address)
address = getenv ("LIBFEP_CONTROL_SOCK");
if (!address)
return NULL;

if (strlen (address) + 1 >= sizeof(sun.sun_path))
{
fep_log (FEP_LOG_LEVEL_WARNING,
"unix domain socket path too long: %d + 1 >= %d",
strlen (address),
sizeof (sun.sun_path));
free (address);
return NULL;
}

client = xzalloc (sizeof(FepClient));
client->filter_running = false;
client->messages = NULL;

memset (&sun, 0, sizeof(struct sockaddr_un));
sun.sun_family = AF_UNIX;

#ifdef __linux__
  sun.sun_path[0] = '\0';
  memcpy (sun.sun_path + 1, address, strlen (address));
  sun_len = offsetof (struct sockaddr_un, sun_path) + strlen (address) + 1;
#else
memcpy (sun.sun_path, address, strlen (address));
sun_len = sizeof (struct sockaddr_un);
#endif

client->control = socket (AF_UNIX, SOCK_STREAM, 0);
if (client->control < 0)
{
free (client);
return NULL;
}

retval = connect (client->control,
(const struct sockaddr *) &sun,
sun_len);
if (retval < 0)
{
close (client->control);
free (client);
return NULL;
}

return client;
}

fep_client_set_cursor_text (FepClient    *client,
                            const char   *text,
                            FepAttribute *attr)
{
  FepControlMessage message;

  message.command = FEP_CONTROL_SET_CURSOR_TEXT;
  _fep_control_message_alloc_args (&message, 2);
  _fep_control_message_write_string_arg (&message, 0, text, strlen (text) + 1);
  _fep_control_message_write_attribute_arg (&message, 1, attr ? attr : &empty_attr);

  if (client->filter_running)
    client->messages = _fep_append_control_message (client->messages, &message);
  else
    _fep_write_control_message (client->control, &message);
  _fep_control_message_free_args (&message);
}

command_set_cursor_text (Fep *fep,
			 FepControlMessage *request)
{
  FepAttribute attr;
  if (_fep_control_message_read_attribute_arg (request, 1, &attr) == 0)
    _fep_output_cursor_text (fep, request->args[0].str, &attr);
}

_fep_read_control_message_from_fd (Fep               *fep,
                                   int                fd,
                                   FepControlMessage *message)
{
  int i;

  if (_fep_read_control_message (fd, message) < 0)
    {
      for (i = 0; i < fep->n_clients; i++)
	if (fep->clients[i] == fd)
	  {
	    close (fd);
	    if (i + 1 < fep->n_clients)
	      memmove (&fep->clients[i],
		       &fep->clients[i + 1],
		       fep->n_clients - (i + 1));
	    fep->clients[--fep->n_clients] = -1;
	    break;
	  }
      return -1;
    }

  return 0;
}

fep_client_set_status_text (FepClient    *client,
                            const char   *text,
                            FepAttribute *attr)
{
  FepControlMessage message;

  message.command = FEP_CONTROL_SET_STATUS_TEXT;
  _fep_control_message_alloc_args (&message, 2);
  _fep_control_message_write_string_arg (&message, 0, text, strlen (text) + 1);
  _fep_control_message_write_attribute_arg (&message, 1, attr ? attr : &empty_attr);

  if (client->filter_running)
    client->messages = _fep_append_control_message (client->messages, &message);
  else
    _fep_write_control_message (client->control, &message);
  _fep_control_message_free_args (&message);
}

remove_control_socket (const char *path)
{
  char *_path = xstrdup (path), *p;
  unlink (_path);
  p = strrchr (_path, '/');
  assert (p != NULL);
  *p = '\0';

  rmdir (_path);
  free (_path);
}

fep_client_close (FepClient *client)
{
  close (client->control);
  free (client);
}

command_send_text (Fep *fep,
		   FepControlMessage *request)
{
  _fep_output_send_text (fep, request->args[0].str);
}

fep_client_forward_key_event (FepClient      *client,
                              unsigned int    keyval,
                              FepModifierType modifiers)
{
  FepControlMessage message;

  message.command = FEP_CONTROL_FORWARD_KEY_EVENT;
  _fep_control_message_alloc_args (&message, 2);
  _fep_control_message_write_uint32_arg (&message, 0, keyval);
  _fep_control_message_write_uint32_arg (&message, 1, modifiers);

  if (client->filter_running)
    client->messages = _fep_append_control_message (client->messages, &message);
  else
    _fep_write_control_message (client->control, &message);
  _fep_control_message_free_args (&message);
}
