status_t SampleTable::findSampleAtTime(
 uint64_t req_time, uint64_t scale_num, uint64_t scale_den,
 uint32_t *sample_index, uint32_t flags) {
    buildSampleEntriesTable();

 if (mSampleTimeEntries == NULL) {
 return ERROR_OUT_OF_RANGE;
 }

 uint32_t left = 0;
 uint32_t right_plus_one = mNumSampleSizes;
 while (left < right_plus_one) {
 uint32_t center = left + (right_plus_one - left) / 2;
 uint64_t centerTime =
            getSampleTime(center, scale_num, scale_den);

 if (req_time < centerTime) {
            right_plus_one = center;
 } else if (req_time > centerTime) {
            left = center + 1;
 } else {
 *sample_index = mSampleTimeEntries[center].mSampleIndex;
 return OK;
 }
 }

 uint32_t closestIndex = left;

 if (closestIndex == mNumSampleSizes) {
 if (flags == kFlagAfter) {
 return ERROR_OUT_OF_RANGE;
 }
        flags = kFlagBefore;
 } else if (closestIndex == 0) {
 if (flags == kFlagBefore) {
 }
        flags = kFlagAfter;
 }

 switch (flags) {
 case kFlagBefore:
 {
 --closestIndex;
 break;
 }

 case kFlagAfter:
 {
 break;
 }

 default:
 {
            CHECK(flags == kFlagClosest);
 if (abs_difference(
                    getSampleTime(closestIndex, scale_num, scale_den), req_time) >
                abs_difference(
                    req_time, getSampleTime(closestIndex - 1, scale_num, scale_den))) {
 --closestIndex;
 }
 break;
 }
 }

 *sample_index = mSampleTimeEntries[closestIndex].mSampleIndex;
 return OK;
}

status_t SampleTable::setTimeToSampleParams(
off64_t data_offset, size_t data_size) {
    if (mTimeToSample != NULL || data_size < 8) {
return ERROR_MALFORMED;
}

uint8_t header[8];
if (mDataSource->readAt(
data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {
return ERROR_IO;
}

if (U32_AT(header) != 0) {
// Expected version = 0, flags = 0.
return ERROR_MALFORMED;

}

mTimeToSampleCount = U32_AT(&header[4]);
    uint64_t allocSize = (uint64_t)mTimeToSampleCount * 2 * sizeof(uint32_t);
    if (allocSize > UINT32_MAX) {
return ERROR_OUT_OF_RANGE;
}
    mTimeToSample = new (std::nothrow) uint32_t[mTimeToSampleCount * 2];
    if (!mTimeToSample)
        return ERROR_OUT_OF_RANGE;

    size_t size = sizeof(uint32_t) * mTimeToSampleCount * 2;
    if (mDataSource->readAt(
                data_offset + 8, mTimeToSample, size) < (ssize_t)size) {
return ERROR_IO;
}

    for (uint32_t i = 0; i < mTimeToSampleCount * 2; ++i) {
        mTimeToSample[i] = ntohl(mTimeToSample[i]);
}
return OK;
}

status_t SampleTable::setSampleSizeParams(
 uint32_t type, off64_t data_offset, size_t data_size) {
 if (mSampleSizeOffset >= 0) {
 return ERROR_MALFORMED;
 }

    CHECK(type == kSampleSizeType32 || type == kSampleSizeTypeCompact);

    mSampleSizeOffset = data_offset;

 if (data_size < 12) {
 return ERROR_MALFORMED;
 }

 uint8_t header[12];
 if (mDataSource->readAt(
                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {
 return ERROR_IO;
 }

 if (U32_AT(header) != 0) {
 return ERROR_MALFORMED;
 }

    mDefaultSampleSize = U32_AT(&header[4]);
    mNumSampleSizes = U32_AT(&header[8]);
 if (mNumSampleSizes > (UINT32_MAX - 12) / 16) {
 return ERROR_MALFORMED;
 }

 if (type == kSampleSizeType32) {
        mSampleSizeFieldSize = 32;

 if (mDefaultSampleSize != 0) {
 return OK;
 }

 if (data_size < 12 + mNumSampleSizes * 4) {
 return ERROR_MALFORMED;
 }
 } else {
 if ((mDefaultSampleSize & 0xffffff00) != 0) {
 return ERROR_MALFORMED;
 }

        mSampleSizeFieldSize = mDefaultSampleSize & 0xff;
        mDefaultSampleSize = 0;

 if (mSampleSizeFieldSize != 4 && mSampleSizeFieldSize != 8
 && mSampleSizeFieldSize != 16) {
 return ERROR_MALFORMED;
 }

 if (data_size < 12 + (mNumSampleSizes * mSampleSizeFieldSize + 4) / 8) {
 return ERROR_MALFORMED;
 }
 }

 return OK;
}

SampleTable::~SampleTable() {
delete[] mSampleToChunkEntries;
mSampleToChunkEntries = NULL;

delete[] mSyncSamples;
mSyncSamples = NULL;

delete mCompositionDeltaLookup;
mCompositionDeltaLookup = NULL;

delete[] mCompositionTimeDeltaEntries;
mCompositionTimeDeltaEntries = NULL;


delete[] mSampleTimeEntries;
mSampleTimeEntries = NULL;

    delete[] mTimeToSample;
    mTimeToSample = NULL;
delete mSampleIterator;
mSampleIterator = NULL;
}

 status_t SampleTable::setChunkOffsetParams(
 uint32_t type, off64_t data_offset, size_t data_size) {
 if (mChunkOffsetOffset >= 0) {
 return ERROR_MALFORMED;
 }

    CHECK(type == kChunkOffsetType32 || type == kChunkOffsetType64);

    mChunkOffsetOffset = data_offset;
    mChunkOffsetType = type;

 if (data_size < 8) {
 return ERROR_MALFORMED;
 }

 uint8_t header[8];
 if (mDataSource->readAt(
                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {
 return ERROR_IO;
 }

 if (U32_AT(header) != 0) {
 return ERROR_MALFORMED;
 }

    mNumChunkOffsets = U32_AT(&header[4]);

 if (mChunkOffsetType == kChunkOffsetType32) {
 if (data_size < 8 + mNumChunkOffsets * 4) {
 return ERROR_MALFORMED;
 }
 } else {
 if (data_size < 8 + mNumChunkOffsets * 8) {
 return ERROR_MALFORMED;
 }
 }

 return OK;
}

bool SampleTable::isValid() const {

return mChunkOffsetOffset >= 0
&& mSampleToChunkOffset >= 0
&& mSampleSizeOffset >= 0
        && !mTimeToSample.empty();
}

SampleTable::SampleTable(const sp<DataSource> &source)
: mDataSource(source),
mChunkOffsetOffset(-1),
mChunkOffsetType(0),
mNumChunkOffsets(0),
mSampleToChunkOffset(-1),
mNumSampleToChunkOffsets(0),
mSampleSizeOffset(-1),
mSampleSizeFieldSize(0),

mDefaultSampleSize(0),
mNumSampleSizes(0),
mTimeToSampleCount(0),
      mTimeToSample(NULL),
mSampleTimeEntries(NULL),
mCompositionTimeDeltaEntries(NULL),
mNumCompositionTimeDeltaEntries(0),
mCompositionDeltaLookup(new CompositionDeltaLookup),
mSyncSampleOffset(-1),
mNumSyncSamples(0),
mSyncSamples(NULL),
mLastSyncSampleIndex(0),
mSampleToChunkEntries(NULL) {
mSampleIterator = new SampleIterator(this);
}

status_t SampleTable::setSyncSampleParams(off64_t data_offset, size_t data_size) {
 if (mSyncSampleOffset >= 0 || data_size < 8) {
 return ERROR_MALFORMED;
 }

    mSyncSampleOffset = data_offset;

 uint8_t header[8];
 if (mDataSource->readAt(
                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {
 return ERROR_IO;
 }

 if (U32_AT(header) != 0) {
 return ERROR_MALFORMED;
 }

    mNumSyncSamples = U32_AT(&header[4]);

 if (mNumSyncSamples < 2) {
        ALOGV("Table of sync samples is empty or has only a single entry!");
 }

 uint64_t allocSize = mNumSyncSamples * (uint64_t)sizeof(uint32_t);
 if (allocSize > SIZE_MAX) {
 return ERROR_OUT_OF_RANGE;
 }

    mSyncSamples = new (std::nothrow) uint32_t[mNumSyncSamples];
 if (!mSyncSamples)
 return ERROR_OUT_OF_RANGE;

 size_t size = mNumSyncSamples * sizeof(uint32_t);
 if (mDataSource->readAt(mSyncSampleOffset + 8, mSyncSamples, size)
 != (ssize_t)size) {
 return ERROR_IO;
 }

 for (size_t i = 0; i < mNumSyncSamples; ++i) {
        mSyncSamples[i] = ntohl(mSyncSamples[i]) - 1;
 }

 return OK;
}

status_t SampleTable::setCompositionTimeToSampleParams(
 off64_t data_offset, size_t data_size) {
    ALOGI("There are reordered frames present.");

 if (mCompositionTimeDeltaEntries != NULL || data_size < 8) {
 return ERROR_MALFORMED;
 }

 uint8_t header[8];
 if (mDataSource->readAt(
                data_offset, header, sizeof(header))
 < (ssize_t)sizeof(header)) {
 return ERROR_IO;
 }

 if (U32_AT(header) != 0) {
 return ERROR_MALFORMED;
 }

 size_t numEntries = U32_AT(&header[4]);

 if (data_size != (numEntries + 1) * 8) {
 return ERROR_MALFORMED;
 }

    mNumCompositionTimeDeltaEntries = numEntries;
 uint64_t allocSize = (uint64_t)numEntries * 2 * sizeof(uint32_t);
 if (allocSize > UINT32_MAX) {
 return ERROR_OUT_OF_RANGE;
 }

    mCompositionTimeDeltaEntries = new (std::nothrow) uint32_t[2 * numEntries];
 if (!mCompositionTimeDeltaEntries)
 return ERROR_OUT_OF_RANGE;

 if (mDataSource->readAt(
                data_offset + 8, mCompositionTimeDeltaEntries, numEntries * 8)
 < (ssize_t)numEntries * 8) {
 delete[] mCompositionTimeDeltaEntries;
        mCompositionTimeDeltaEntries = NULL;

 return ERROR_IO;
 }

 for (size_t i = 0; i < 2 * numEntries; ++i) {
        mCompositionTimeDeltaEntries[i] = ntohl(mCompositionTimeDeltaEntries[i]);
 }

    mCompositionDeltaLookup->setEntries(
            mCompositionTimeDeltaEntries, mNumCompositionTimeDeltaEntries);

 return OK;
}

bool SampleTable::isValid() const {

return mChunkOffsetOffset >= 0
&& mSampleToChunkOffset >= 0
&& mSampleSizeOffset >= 0
        && mTimeToSample != NULL;
}

status_t SampleTable::setSampleToChunkParams(
 off64_t data_offset, size_t data_size) {
 if (mSampleToChunkOffset >= 0) {
 return ERROR_MALFORMED;
 }

    mSampleToChunkOffset = data_offset;

 if (data_size < 8) {
 return ERROR_MALFORMED;
 }

 uint8_t header[8];
 if (mDataSource->readAt(
                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {
 return ERROR_IO;
 }

 if (U32_AT(header) != 0) {
 return ERROR_MALFORMED;
 }

    mNumSampleToChunkOffsets = U32_AT(&header[4]);

 if (data_size < 8 + mNumSampleToChunkOffsets * 12) {
 return ERROR_MALFORMED;
 }

 if (SIZE_MAX / sizeof(SampleToChunkEntry) <= (size_t)mNumSampleToChunkOffsets)
 return ERROR_OUT_OF_RANGE;

    mSampleToChunkEntries =
 new (std::nothrow) SampleToChunkEntry[mNumSampleToChunkOffsets];
 if (!mSampleToChunkEntries)
 return ERROR_OUT_OF_RANGE;

 for (uint32_t i = 0; i < mNumSampleToChunkOffsets; ++i) {
 uint8_t buffer[12];
 if (mDataSource->readAt(
                    mSampleToChunkOffset + 8 + i * 12, buffer, sizeof(buffer))
 != (ssize_t)sizeof(buffer)) {
 return ERROR_IO;
 }

        CHECK(U32_AT(buffer) >= 1); // chunk index is 1 based in the spec.

        mSampleToChunkEntries[i].startChunk = U32_AT(buffer) - 1;
        mSampleToChunkEntries[i].samplesPerChunk = U32_AT(&buffer[4]);
        mSampleToChunkEntries[i].chunkDesc = U32_AT(&buffer[8]);
 }

 return OK;
}

void SampleTable::buildSampleEntriesTable() {
 Mutex::Autolock autoLock(mLock);

 if (mSampleTimeEntries != NULL || mNumSampleSizes == 0) {
 return;
 }

    mSampleTimeEntries = new (std::nothrow) SampleTimeEntry[mNumSampleSizes];
 if (!mSampleTimeEntries)
 return;

 uint32_t sampleIndex = 0;
 uint32_t sampleTime = 0;

 for (uint32_t i = 0; i < mTimeToSampleCount; ++i) {
 uint32_t n = mTimeToSample[2 * i];
 uint32_t delta = mTimeToSample[2 * i + 1];

 for (uint32_t j = 0; j < n; ++j) {
 if (sampleIndex < mNumSampleSizes) {

                mSampleTimeEntries[sampleIndex].mSampleIndex = sampleIndex;

 uint32_t compTimeDelta =
                    mCompositionDeltaLookup->getCompositionTimeOffset(
                            sampleIndex);

                mSampleTimeEntries[sampleIndex].mCompositionTime =
                    sampleTime + compTimeDelta;
 }

 ++sampleIndex;
            sampleTime += delta;
 }
 }

    qsort(mSampleTimeEntries, mNumSampleSizes, sizeof(SampleTimeEntry),
 CompareIncreasingTime);
}
