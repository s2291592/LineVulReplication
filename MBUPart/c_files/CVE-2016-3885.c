static void activity_manager_write(int pid, int signal, int amfd, const std::string& amfd_data) {
 if (amfd == -1) {
 return;
 }

 uint32_t datum = htonl(pid);
 if (!android::base::WriteFully(amfd, &datum, 4)) {
    ALOGE("AM pid write failed: %s\n", strerror(errno));
 return;
 }
  datum = htonl(signal);
 if (!android::base::WriteFully(amfd, &datum, 4)) {
    ALOGE("AM signal write failed: %s\n", strerror(errno));
 return;
 }

 if (!android::base::WriteFully(amfd, amfd_data.c_str(), amfd_data.size())) {
    ALOGE("AM data write failed: %s\n", strerror(errno));
 return;
 }

 uint8_t eodMarker = 0;
 if (!android::base::WriteFully(amfd, &eodMarker, 1)) {
    ALOGE("AM eod write failed: %s\n", strerror(errno));
 return;
 }
  android::base::ReadFully(amfd, &eodMarker, 1);
}

static void ptrace_siblings(pid_t pid, pid_t main_tid, std::set<pid_t>& tids) {
  char task_path[64];

  snprintf(task_path, sizeof(task_path), "/proc/%d/task", pid);

std::unique_ptr<DIR, int (*)(DIR*)> d(opendir(task_path), closedir);

// Bail early if the task directory cannot be opened.
if (!d) {
ALOGE("debuggerd: failed to open /proc/%d/task: %s", pid, strerror(errno));
return;
}

struct dirent* de;
while ((de = readdir(d.get())) != NULL) {
// Ignore "." and "..".
if (!strcmp(de->d_name, ".") || !strcmp(de->d_name, "..")) {
continue;
}

char* end;
pid_t tid = strtoul(de->d_name, &end, 10);
if (*end) {
continue;
}

if (tid == main_tid) {

continue;
}

    if (ptrace(PTRACE_ATTACH, tid, 0, 0) < 0) {
ALOGE("debuggerd: ptrace attach to %d failed: %s", tid, strerror(errno));
continue;
}

tids.insert(tid);
}
}

static int do_server() {
  signal(SIGABRT, SIG_DFL);
  signal(SIGBUS, SIG_DFL);
  signal(SIGFPE, SIG_DFL);
  signal(SIGILL, SIG_DFL);
  signal(SIGSEGV, SIG_DFL);
#ifdef SIGSTKFLT
  signal(SIGSTKFLT, SIG_DFL);
#endif
  signal(SIGTRAP, SIG_DFL);

  signal(SIGPIPE, SIG_IGN);

 sigset_t sigchld;
  sigemptyset(&sigchld);
  sigaddset(&sigchld, SIGCHLD);
  sigprocmask(SIG_SETMASK, &sigchld, nullptr);

 int s = socket_local_server(SOCKET_NAME, ANDROID_SOCKET_NAMESPACE_ABSTRACT,
                              SOCK_STREAM | SOCK_CLOEXEC);
 if (s == -1) return 1;

 if (!start_signal_sender()) {
    ALOGE("debuggerd: failed to fork signal sender");
 return 1;
 }

  ALOGI("debuggerd: starting\n");

 for (;;) {
    sockaddr_storage ss;
    sockaddr* addrp = reinterpret_cast<sockaddr*>(&ss);
 socklen_t alen = sizeof(ss);

    ALOGV("waiting for connection\n");
 int fd = accept4(s, addrp, &alen, SOCK_CLOEXEC);
 if (fd == -1) {
      ALOGE("accept failed: %s\n", strerror(errno));
 continue;
 }

    handle_request(fd);
 }
 return 0;
}

static void wait_for_user_action(const debugger_request_t& request) {
  ALOGI("***********************************************************\n"
 "* Process %d has been suspended while crashing.\n"
 "* To attach gdbserver and start gdb, run this on the host:\n"
 "*\n"
 "*     gdbclient.py -p %d\n"
 "*\n"
 "* Wait for gdb to start, then press the VOLUME DOWN key\n"
 "* to let the process continue crashing.\n"
 "***********************************************************",
        request.pid, request.tid);

 while (true) {
    input_event e;
 if (get_event(&e, -1) == 0) {
 if (e.type == EV_KEY && e.code == KEY_VOLUMEDOWN && e.value == 0) {
 break;
 }
 }
 }

  ALOGI("debuggerd resuming process %d", request.pid);
}

static bool drop_privileges() {
 gid_t groups[] = { AID_DEBUGGERD, AID_LOG, AID_READPROC };
 if (setgroups(sizeof(groups)/sizeof(groups[0]), groups) != 0) {
    ALOGE("debuggerd: failed to setgroups: %s", strerror(errno));
 return false;
 }

 if (setresgid(AID_DEBUGGERD, AID_DEBUGGERD, AID_DEBUGGERD) != 0) {
    ALOGE("debuggerd: failed to setresgid: %s", strerror(errno));
 return false;
 }

 if (setresuid(AID_DEBUGGERD, AID_DEBUGGERD, AID_DEBUGGERD) != 0) {
    ALOGE("debuggerd: failed to setresuid: %s", strerror(errno));
 return false;
 }

 return true;
}

static void worker_process(int fd, debugger_request_t& request) {
// Open the tombstone file if we need it.
std::string tombstone_path;
int tombstone_fd = -1;
switch (request.action) {
case DEBUGGER_ACTION_DUMP_TOMBSTONE:
case DEBUGGER_ACTION_CRASH:
tombstone_fd = open_tombstone(&tombstone_path);
if (tombstone_fd == -1) {
ALOGE("debuggerd: failed to open tombstone file: %s\n", strerror(errno));
exit(1);
}
break;

case DEBUGGER_ACTION_DUMP_BACKTRACE:
break;

default:
ALOGE("debuggerd: unexpected request action: %d", request.action);
exit(1);
}

// At this point, the thread that made the request is blocked in
// a read() call.  If the thread has crashed, then this gives us
// time to PTRACE_ATTACH to it before it has a chance to really fault.
//
// The PTRACE_ATTACH sends a SIGSTOP to the target process, but it
// won't necessarily have stopped by the time ptrace() returns.  (We
// currently assume it does.)  We write to the file descriptor to
// ensure that it can run as soon as we call PTRACE_CONT below.
// See details in bionic/libc/linker/debugger.c, in function

// debugger_signal_handler().

// Attach to the target process.
  if (ptrace(PTRACE_ATTACH, request.tid, 0, 0) != 0) {
ALOGE("debuggerd: ptrace attach failed: %s", strerror(errno));
exit(1);
}

// Don't attach to the sibling threads if we want to attach gdb.
// Supposedly, it makes the process less reliable.
bool attach_gdb = should_attach_gdb(request);
if (attach_gdb) {
// Open all of the input devices we need to listen for VOLUMEDOWN before dropping privileges.
if (init_getevent() != 0) {
ALOGE("debuggerd: failed to initialize input device, not waiting for gdb");
attach_gdb = false;
}

}

std::set<pid_t> siblings;
if (!attach_gdb) {
ptrace_siblings(request.pid, request.tid, siblings);
}

// Generate the backtrace map before dropping privileges.
std::unique_ptr<BacktraceMap> backtrace_map(BacktraceMap::Create(request.pid));

int amfd = -1;
std::unique_ptr<std::string> amfd_data;
if (request.action == DEBUGGER_ACTION_CRASH) {
// Connect to the activity manager before dropping privileges.
amfd = activity_manager_connect();
amfd_data.reset(new std::string);
}

bool succeeded = false;

// Now that we've done everything that requires privileges, we can drop them.
if (!drop_privileges()) {
ALOGE("debuggerd: failed to drop privileges, exiting");
_exit(1);
}

int crash_signal = SIGKILL;
succeeded = perform_dump(request, fd, tombstone_fd, backtrace_map.get(), siblings,
&crash_signal, amfd_data.get());
if (succeeded) {
if (request.action == DEBUGGER_ACTION_DUMP_TOMBSTONE) {
if (!tombstone_path.empty()) {
android::base::WriteFully(fd, tombstone_path.c_str(), tombstone_path.length());
}
}
}

if (attach_gdb) {
// Tell the signal process to send SIGSTOP to the target.
if (!send_signal(request.pid, 0, SIGSTOP)) {
ALOGE("debuggerd: failed to stop process for gdb attach: %s", strerror(errno));
attach_gdb = false;
}
}

if (!attach_gdb) {
// Tell the Activity Manager about the crashing process. If we are
// waiting for gdb to attach, do not send this or Activity Manager
// might kill the process before anyone can attach.
activity_manager_write(request.pid, crash_signal, amfd, *amfd_data.get());
}

if (ptrace(PTRACE_DETACH, request.tid, 0, 0) != 0) {
ALOGE("debuggerd: ptrace detach from %d failed: %s", request.tid, strerror(errno));
}

for (pid_t sibling : siblings) {
ptrace(PTRACE_DETACH, sibling, 0, 0);
}

// Send the signal back to the process if it crashed and we're not waiting for gdb.
if (!attach_gdb && request.action == DEBUGGER_ACTION_CRASH) {
if (!send_signal(request.pid, request.tid, crash_signal)) {
ALOGE("debuggerd: failed to kill process %d: %s", request.pid, strerror(errno));
}
}

// Wait for gdb, if requested.
if (attach_gdb) {
wait_for_user_action(request);

// Now tell the activity manager about this process.
activity_manager_write(request.pid, crash_signal, amfd, *amfd_data.get());

// Tell the signal process to send SIGCONT to the target.
if (!send_signal(request.pid, 0, SIGCONT)) {
ALOGE("debuggerd: failed to resume process %d: %s", request.pid, strerror(errno));
}

uninit_getevent();
}

close(amfd);

exit(!succeeded);
}

static void usage() {
  fputs("Usage: -b [<tid>]\n"
 "  -b dump backtrace to console, otherwise dump full tombstone file\n"
 "\n"
 "If tid specified, sends a request to debuggerd to dump that task.\n"
 "Otherwise, starts the debuggerd server.\n", stderr);
}

static void handle_request(int fd) {
  ALOGV("handle_request(%d)\n", fd);

 ScopedFd closer(fd);
 debugger_request_t request;
  memset(&request, 0, sizeof(request));
 int status = read_request(fd, &request);
 if (status != 0) {
 return;
 }

  ALOGW("debuggerd: handling request: pid=%d uid=%d gid=%d tid=%d\n", request.pid, request.uid,
        request.gid, request.tid);

#if defined(__LP64__)
 if (is32bit(request.tid)) {
 if (request.action == DEBUGGER_ACTION_DUMP_BACKTRACE ||
        request.action == DEBUGGER_ACTION_DUMP_TOMBSTONE) {
      redirect_to_32(fd, &request);
 } else {
      ALOGE("debuggerd: Not allowed to redirect action %d to 32 bit debuggerd\n", request.action);
 }
 return;
 }
#endif

 pid_t fork_pid = fork();
 if (fork_pid == -1) {
    ALOGE("debuggerd: failed to fork: %s\n", strerror(errno));
 } else if (fork_pid == 0) {
    worker_process(fd, request);
 } else {
    monitor_worker_process(fork_pid, request);
 }
}

static bool should_attach_gdb(const debugger_request_t& request) {
 if (request.action == DEBUGGER_ACTION_CRASH) {
 return property_get_bool("debug.debuggerd.wait_for_gdb", false);
 }
 return false;
}

static void redirect_to_32(int fd, debugger_request_t* request) {
 debugger_msg_t msg;
  memset(&msg, 0, sizeof(msg));
  msg.tid = request->tid;
  msg.action = request->action;

 int sock_fd = socket_local_client(DEBUGGER32_SOCKET_NAME, ANDROID_SOCKET_NAMESPACE_ABSTRACT,
                                    SOCK_STREAM | SOCK_CLOEXEC);
 if (sock_fd < 0) {
    ALOGE("Failed to connect to debuggerd32: %s", strerror(errno));
 return;
 }

 if (TEMP_FAILURE_RETRY(write(sock_fd, &msg, sizeof(msg))) != (ssize_t) sizeof(msg)) {
    ALOGE("Failed to write request to debuggerd32 socket: %s", strerror(errno));
    close(sock_fd);
 return;
 }

 char ack;
 if (TEMP_FAILURE_RETRY(read(sock_fd, &ack, 1)) == -1) {
    ALOGE("Failed to read ack from debuggerd32 socket: %s", strerror(errno));
    close(sock_fd);
 return;
 }

 char buffer[1024];
 ssize_t bytes_read;
 while ((bytes_read = TEMP_FAILURE_RETRY(read(sock_fd, buffer, sizeof(buffer)))) > 0) {
 ssize_t bytes_to_send = bytes_read;
 ssize_t bytes_written;
 do {
      bytes_written = TEMP_FAILURE_RETRY(write(fd, buffer + bytes_read - bytes_to_send,
                                               bytes_to_send));
 if (bytes_written == -1) {
 if (errno == EAGAIN) {
 continue;
 }
        ALOGE("Error while writing data to fd: %s", strerror(errno));
 break;
 }
      bytes_to_send -= bytes_written;
 } while (bytes_written != 0 && bytes_to_send > 0);
 if (bytes_to_send != 0) {
        ALOGE("Failed to write all data to fd: read %zd, sent %zd", bytes_read, bytes_to_send);
 break;
 }
 }
  close(sock_fd);

 }

static int activity_manager_connect() {
  android::base::unique_fd amfd(socket(PF_UNIX, SOCK_STREAM, 0));
 if (amfd.get() < -1) {
    ALOGE("debuggerd: Unable to connect to activity manager (socket failed: %s)", strerror(errno));
 return -1;
 }

 struct sockaddr_un address;
  memset(&address, 0, sizeof(address));
  address.sun_family = AF_UNIX;
  strncpy(address.sun_path, "/data/system/ndebugsocket", sizeof(address.sun_path));
 if (TEMP_FAILURE_RETRY(connect(amfd.get(), reinterpret_cast<struct sockaddr*>(&address),
 sizeof(address))) == -1) {
    ALOGE("debuggerd: Unable to connect to activity manager (connect failed: %s)", strerror(errno));
 return -1;
 }

 struct timeval tv;
  memset(&tv, 0, sizeof(tv));
  tv.tv_sec = 1; // tight leash
 if (setsockopt(amfd.get(), SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) == -1) {
    ALOGE("debuggerd: Unable to connect to activity manager (setsockopt SO_SNDTIMEO failed: %s)",
          strerror(errno));
 return -1;
 }

  tv.tv_sec = 3; // 3 seconds on handshake read
 if (setsockopt(amfd.get(), SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) == -1) {
    ALOGE("debuggerd: Unable to connect to activity manager (setsockopt SO_RCVTIMEO failed: %s)",
          strerror(errno));
 return -1;
 }

 return amfd.release();
}

static int get_process_info(pid_t tid, pid_t* out_pid, uid_t* out_uid, uid_t* out_gid) {
 char path[64];
  snprintf(path, sizeof(path), "/proc/%d/status", tid);

 FILE* fp = fopen(path, "r");
 if (!fp) {
 return -1;
 }

 int fields = 0;
 char line[1024];
 while (fgets(line, sizeof(line), fp)) {
 size_t len = strlen(line);
 if (len > 6 && !memcmp(line, "Tgid:\t", 6)) {
 *out_pid = atoi(line + 6);
      fields |= 1;
 } else if (len > 5 && !memcmp(line, "Uid:\t", 5)) {
 *out_uid = atoi(line + 5);
      fields |= 2;
 } else if (len > 5 && !memcmp(line, "Gid:\t", 5)) {
 *out_gid = atoi(line + 5);
      fields |= 4;
 }
 }
  fclose(fp);
 return fields == 7 ? 0 : -1;
}

static bool perform_dump(const debugger_request_t& request, int fd, int tombstone_fd,
 BacktraceMap* backtrace_map, const std::set<pid_t>& siblings,
 int* crash_signal, std::string* amfd_data) {
 if (TEMP_FAILURE_RETRY(write(fd, "\0", 1)) != 1) {
    ALOGE("debuggerd: failed to respond to client: %s\n", strerror(errno));
 return false;
 }

 int total_sleep_time_usec = 0;
 while (true) {
 int signal = wait_for_signal(request.tid, &total_sleep_time_usec);
 switch (signal) {
 case -1:
        ALOGE("debuggerd: timed out waiting for signal");
 return false;

 case SIGSTOP:
 if (request.action == DEBUGGER_ACTION_DUMP_TOMBSTONE) {
          ALOGV("debuggerd: stopped -- dumping to tombstone");
          engrave_tombstone(tombstone_fd, backtrace_map, request.pid, request.tid, siblings, signal,
                            request.original_si_code, request.abort_msg_address, amfd_data);
 } else if (request.action == DEBUGGER_ACTION_DUMP_BACKTRACE) {
          ALOGV("debuggerd: stopped -- dumping to fd");
          dump_backtrace(fd, backtrace_map, request.pid, request.tid, siblings, nullptr);
 } else {
          ALOGV("debuggerd: stopped -- continuing");
 if (ptrace(PTRACE_CONT, request.tid, 0, 0) != 0) {
            ALOGE("debuggerd: ptrace continue failed: %s", strerror(errno));
 return false;
 }
 continue; // loop again
 }
 break;

 case SIGABRT:
 case SIGBUS:
 case SIGFPE:
 case SIGILL:
 case SIGSEGV:
#ifdef SIGSTKFLT
 case SIGSTKFLT:
#endif
 case SIGSYS:
 case SIGTRAP:
        ALOGV("stopped -- fatal signal\n");
 *crash_signal = signal;
        engrave_tombstone(tombstone_fd, backtrace_map, request.pid, request.tid, siblings, signal,
                          request.original_si_code, request.abort_msg_address, amfd_data);
 break;

 default:
        ALOGE("debuggerd: process stopped due to unexpected signal %d\n", signal);
 break;
 }
 break;
 }

 return true;
}

static bool is32bit(pid_t tid) {
 char* exeline;
 if (asprintf(&exeline, "/proc/%d/exe", tid) == -1) {
 return false;
 }
 int fd = TEMP_FAILURE_RETRY(open(exeline, O_RDONLY | O_CLOEXEC));
 int saved_errno = errno;
  free(exeline);
 if (fd == -1) {
    ALOGW("Failed to open /proc/%d/exe %s", tid, strerror(saved_errno));
 return false;
 }

 char ehdr[EI_NIDENT];
 ssize_t bytes = TEMP_FAILURE_RETRY(read(fd, &ehdr, sizeof(ehdr)));
  close(fd);
 if (bytes != (ssize_t) sizeof(ehdr) || memcmp(ELFMAG, ehdr, SELFMAG) != 0) {
 return false;
 }
 if (ehdr[EI_CLASS] == ELFCLASS32) {
 return true;
 }
 return false;
}
