LazyBackgroundTaskQueue* ExtensionSystemImpl::lazy_background_task_queue() {
  return shared_->lazy_background_task_queue();
}

 PermissionsRequestFunction::~PermissionsRequestFunction() {}

MessageService* ExtensionSystemImpl::Shared::message_service() {
  return message_service_.get();
}

ExtensionSystemImpl::Shared::Shared(Profile* profile)
    : profile_(profile) {
}

ExtensionProcessManager* TestExtensionSystem::process_manager() {
  return extension_process_manager_.get();
}

ExtensionInfoMap* ExtensionSystemImpl::Shared::info_map() {
  if (!extension_info_map_)
    extension_info_map_ = new ExtensionInfoMap();
  return extension_info_map_.get();
}

ExtensionSystemImpl::Shared::~Shared() {
}

void ExtensionSystemImpl::Shared::RegisterManagementPolicyProviders() {
  DCHECK(standard_management_policy_provider_.get());
  management_policy_->RegisterProvider(
      standard_management_policy_provider_.get());
}

void PermissionsRequestFunction::InstallUIAbort(bool user_initiated) {
  results_ = Request::Results::Create(false);
SendResponse(true);

Release();  // Balanced in RunImpl().
}

RulesRegistryService* TestExtensionSystem::rules_registry_service() {
  return NULL;
}

bool PermissionsRemoveFunction::RunImpl() {
scoped_ptr<Remove::Params> params(Remove::Params::Create(*args_));
  EXTENSION_FUNCTION_VALIDATE(params.get());

scoped_refptr<PermissionSet> permissions =
      helpers::UnpackPermissionSet(params->permissions, &error_);
if (!permissions.get())
return false;

const extensions::Extension* extension = GetExtension();

// Make sure they're only trying to remove permissions supported by this API.
APIPermissionSet apis = permissions->apis();
for (APIPermissionSet::const_iterator i = apis.begin();
i != apis.end(); ++i) {
if (!i->info()->supports_optional()) {
error_ = ErrorUtils::FormatErrorMessage(
kNotWhitelistedError, i->name());
return false;
}
}

// Make sure we don't remove any required pemissions.
const PermissionSet* required = extension->required_permission_set();
scoped_refptr<PermissionSet> intersection(
PermissionSet::CreateIntersection(permissions.get(), required));
if (!intersection->IsEmpty()) {
error_ = kCantRemoveRequiredPermissionsError;
results_ = Remove::Results::Create(false);
return false;
}

PermissionsUpdater(profile()).RemovePermissions(extension, permissions.get());
results_ = Remove::Results::Create(true);
return true;
}

TestExtensionSystem::serial_connection_manager() {
  return NULL;
}

EventRouter* TestExtensionSystem::event_router() {
  return NULL;
}

ApiResourceManager<Socket>*TestExtensionSystem::socket_manager() {
  return socket_manager_.get();
}

StateStore* ExtensionSystemImpl::state_store() {
  return shared_->state_store();
}

StateStore* TestExtensionSystem::state_store() {
  return state_store_.get();
}

ExtensionSystem::ExtensionSystem() {
  if (Feature::GetCurrentChannel() == Feature::GetDefaultChannel())
    Feature::SetCurrentChannel(chrome::VersionInfo::GetChannel());
}

scoped_refptr<PermissionSet> UnpackPermissionSet(
    const Permissions& permissions, std::string* error) {
APIPermissionSet apis;
std::vector<std::string>* permissions_list = permissions.permissions.get();
if (permissions_list) {
PermissionsInfo* info = PermissionsInfo::GetInstance();
for (std::vector<std::string>::iterator it = permissions_list->begin();
it != permissions_list->end(); ++it) {
// This is a compromise: we currently can't switch to a blend of
// objects/strings all the way through the API. Until then, put this
// processing here.
// http://code.google.com/p/chromium/issues/detail?id=162042
if (it->find(kDelimiter) != std::string::npos) {
size_t delimiter = it->find(kDelimiter);
std::string permission_name = it->substr(0, delimiter);
std::string permission_arg = it->substr(delimiter + 1);

scoped_ptr<base::Value> permission_json(
base::JSONReader::Read(permission_arg));
if (!permission_json.get()) {
*error = ErrorUtils::FormatErrorMessage(kInvalidParameter, *it);
return NULL;
}

APIPermission* permission = NULL;

// Explicitly check the permissions that accept arguments until the bug
// referenced above is fixed.
const APIPermissionInfo* bluetooth_device_permission_info =
info->GetByID(APIPermission::kBluetoothDevice);
const APIPermissionInfo* usb_device_permission_info =
info->GetByID(APIPermission::kUsbDevice);
if (permission_name == bluetooth_device_permission_info->name()) {
permission = new BluetoothDevicePermission(
bluetooth_device_permission_info);
} else if (permission_name == usb_device_permission_info->name()) {
permission = new UsbDevicePermission(usb_device_permission_info);
} else {
*error = kUnsupportedPermissionId;
return NULL;
}

CHECK(permission);
if (!permission->FromValue(permission_json.get())) {
*error = ErrorUtils::FormatErrorMessage(kInvalidParameter, *it);
return NULL;
}
apis.insert(permission);
} else {
const APIPermissionInfo* permission_info = info->GetByName(*it);
if (!permission_info) {
*error = ErrorUtils::FormatErrorMessage(
kUnknownPermissionError, *it);
return NULL;
}
apis.insert(permission_info->id());
}
}
}

URLPatternSet origins;
if (permissions.origins.get()) {
for (std::vector<std::string>::iterator it = permissions.origins->begin();
it != permissions.origins->end(); ++it) {
      URLPattern origin(Extension::kValidHostPermissionSchemes);
URLPattern::ParseResult parse_result = origin.Parse(*it);
if (URLPattern::PARSE_SUCCESS != parse_result) {
*error = ErrorUtils::FormatErrorMessage(
kInvalidOrigin,
*it,
URLPattern::GetParseResultString(parse_result));
return NULL;
}
origins.AddPattern(origin);
}
}

return scoped_refptr<PermissionSet>(
new PermissionSet(apis, origins, URLPatternSet()));
}

void ExtensionSystemImpl::RegisterExtensionWithRequestContexts(
    const Extension* extension) {
  base::Time install_time;
  if (extension->location() != Extension::COMPONENT) {
    install_time = extension_service()->extension_prefs()->
        GetInstallTime(extension->id());
  }
  bool incognito_enabled =
      extension_service()->IsIncognitoEnabled(extension->id());
  BrowserThread::PostTask(
      BrowserThread::IO, FROM_HERE,
      base::Bind(&ExtensionInfoMap::AddExtension, info_map(),
                 make_scoped_refptr(extension), install_time,
                 incognito_enabled));
}

void PermissionsRequestFunction::InstallUIProceed() {
  PermissionsUpdater perms_updater(profile());
  perms_updater.AddPermissions(GetExtension(), requested_permissions_.get());

  results_ = Request::Results::Create(true);
  SendResponse(true);

  Release();  // Balanced in RunImpl().
 }

UserScriptMaster* ExtensionSystemImpl::user_script_master() {
  return shared_->user_script_master();
}

StateStore* ExtensionSystemImpl::Shared::state_store() {
  return state_store_.get();
}

ApiResourceManager<Socket>* ExtensionSystemImpl::socket_manager() {
  return socket_manager_.get();
}

ExtensionService* ExtensionSystemImpl::extension_service() {
  return shared_->extension_service();
}

ManagementPolicy* TestExtensionSystem::management_policy() {
  return management_policy_.get();
}

ExtensionSystemImpl::ExtensionSystemImpl(Profile* profile)
    : profile_(profile) {
  shared_ = ExtensionSystemSharedFactory::GetForProfile(profile);

  if (profile->IsOffTheRecord()) {
    extension_process_manager_.reset(ExtensionProcessManager::Create(profile));
  } else {
    shared_->InitPrefs();
  }
}

ExtensionSystem::~ExtensionSystem() {
}

TestExtensionSystem::TestExtensionSystem(Profile* profile)
    : profile_(profile),
      info_map_(new ExtensionInfoMap()) {
}

ExtensionSystemImpl::~ExtensionSystemImpl() {
  if (rules_registry_service_.get())
    rules_registry_service_->Shutdown();
}

ExtensionProcessManager* ExtensionSystemImpl::process_manager() {
  return extension_process_manager_.get();
}

void ExtensionSystemImpl::Shared::InitPrefs() {
  bool extensions_disabled =
      profile_->GetPrefs()->GetBoolean(prefs::kDisableExtensions) ||
      CommandLine::ForCurrentProcess()->HasSwitch(switches::kDisableExtensions);
  extension_prefs_ = ExtensionPrefs::Create(
      profile_->GetPrefs(),
      profile_->GetPath().AppendASCII(ExtensionService::kInstallDirectoryName),
      ExtensionPrefValueMapFactory::GetForProfile(profile_),
      extensions_disabled);
  lazy_background_task_queue_.reset(new LazyBackgroundTaskQueue(profile_));
  event_router_.reset(new EventRouter(profile_, extension_prefs_.get()));

  state_store_.reset(new StateStore(
      profile_,
      profile_->GetPath().AppendASCII(ExtensionService::kStateStoreName),
      true));
  rules_store_.reset(new StateStore(
      profile_,
      profile_->GetPath().AppendASCII(ExtensionService::kRulesStoreName),
      false));

  shell_window_geometry_cache_.reset(new ShellWindowGeometryCache(
      profile_, extension_prefs_.get()));

  blacklist_.reset(new Blacklist(extension_prefs_.get()));

  standard_management_policy_provider_.reset(
      new StandardManagementPolicyProvider(extension_prefs_.get()));
}

void TestExtensionSystem::CreateSocketManager() {
  BrowserThread::ID id;
  CHECK(BrowserThread::GetCurrentThreadIdentifier(&id));
  socket_manager_.reset(new ApiResourceManager<Socket>(id));
}

ExtensionService* ExtensionSystemImpl::Shared::extension_service() {
  return extension_service_.get();
}

ExtensionSystemImpl::usb_device_resource_manager() {
  return usb_device_resource_manager_.get();
}

void PermissionsRequestFunction::SetIgnoreUserGestureForTests(
    bool ignore) {
  ignore_user_gesture_for_tests = ignore;
}

void ExtensionSystemImpl::Shared::Init(bool extensions_enabled) {
  const CommandLine* command_line = CommandLine::ForCurrentProcess();

  message_service_.reset(new MessageService(lazy_background_task_queue_.get()));
  navigation_observer_.reset(new NavigationObserver(profile_));

  bool allow_noisy_errors = !command_line->HasSwitch(switches::kNoErrorDialogs);
  ExtensionErrorReporter::Init(allow_noisy_errors);

  user_script_master_ = new UserScriptMaster(profile_);

  bool autoupdate_enabled = true;
#if defined(OS_CHROMEOS)
  if (!extensions_enabled)
    autoupdate_enabled = false;
  else
    autoupdate_enabled = !command_line->HasSwitch(switches::kGuestSession);
#endif
  extension_service_.reset(new ExtensionService(
      profile_,
      CommandLine::ForCurrentProcess(),
      profile_->GetPath().AppendASCII(ExtensionService::kInstallDirectoryName),
      extension_prefs_.get(),
      blacklist_.get(),
      autoupdate_enabled,
      extensions_enabled));

  {
    management_policy_.reset(new ManagementPolicy);
    RegisterManagementPolicyProviders();
  }

  bool skip_session_extensions = false;
#if defined(OS_CHROMEOS)
  skip_session_extensions = !chromeos::UserManager::Get()->IsUserLoggedIn();
#endif
  extension_service_->component_loader()->AddDefaultComponentExtensions(
      skip_session_extensions);
  if (command_line->HasSwitch(switches::kLoadComponentExtension)) {
    CommandLine::StringType path_list = command_line->GetSwitchValueNative(
        switches::kLoadComponentExtension);
    StringTokenizerT<CommandLine::StringType,
        CommandLine::StringType::const_iterator> t(path_list,
                                                   FILE_PATH_LITERAL(","));
    while (t.GetNext()) {
      base::ThreadRestrictions::ScopedAllowIO allow_io;
      extension_service_->component_loader()->AddOrReplace(
          FilePath(t.token()));
    }
  }
  extension_service_->Init();

  if (extensions_enabled) {
    if (command_line->HasSwitch(switches::kLoadExtension)) {
      CommandLine::StringType path_list = command_line->GetSwitchValueNative(
          switches::kLoadExtension);
      StringTokenizerT<CommandLine::StringType,
          CommandLine::StringType::const_iterator> t(path_list,
                                                     FILE_PATH_LITERAL(","));
      while (t.GetNext()) {
        UnpackedInstaller::Create(extension_service_.get())->
            LoadFromCommandLine(FilePath(t.token()));
      }
    }
  }

  ChromeURLDataManager::AddDataSource(profile_,
      new ExtensionIconSource(profile_));

  CHECK(!ProfileManager::IsImportProcess(*command_line));
  if (g_browser_process->profile_manager()->will_import()) {
    extension_service_->InitEventRoutersAfterImport();
  } else {
    extension_service_->InitEventRouters();
  }

  extension_warning_service_.reset(new ExtensionWarningService(profile_));
  extension_warning_badge_service_.reset(
      new ExtensionWarningBadgeService(profile_));
  extension_warning_service_->AddObserver(
      extension_warning_badge_service_.get());
}

StateStore* ExtensionSystemImpl::rules_store() {
   return shared_->rules_store();
 }

void ExtensionSystemImpl::InitForRegularProfile(bool extensions_enabled) {
  DCHECK(!profile_->IsOffTheRecord());
  if (user_script_master() || extension_service())
    return;  // Already initialized.

  shared_->info_map();

  extension_process_manager_.reset(ExtensionProcessManager::Create(profile_));
  alarm_manager_.reset(new AlarmManager(profile_, &base::Time::Now));

  serial_connection_manager_.reset(new ApiResourceManager<SerialConnection>(
      BrowserThread::FILE));
  socket_manager_.reset(new ApiResourceManager<Socket>(BrowserThread::IO));
  usb_device_resource_manager_.reset(
      new ApiResourceManager<UsbDeviceResource>(BrowserThread::IO));

  rules_registry_service_.reset(new RulesRegistryService(profile_));
  rules_registry_service_->RegisterDefaultRulesRegistries();

  shared_->Init(extensions_enabled);
}

ExtensionInfoMap* ExtensionSystemImpl::info_map() {
  return shared_->info_map();
}

EventRouter* ExtensionSystemImpl::Shared::event_router() {
  return event_router_.get();
}

TestExtensionSystem::lazy_background_task_queue() {
  return NULL;
}

StateStore* TestExtensionSystem::rules_store() {
   return state_store_.get();
 }

void TestExtensionSystem::CreateExtensionProcessManager() {
  extension_process_manager_.reset(ExtensionProcessManager::Create(profile_));
}

    ExtensionSystemImpl::Shared::lazy_background_task_queue() {
  return lazy_background_task_queue_.get();
}

void ExtensionSystemImpl::Shutdown() {
  extension_process_manager_.reset();
}

bool PermissionsContainsFunction::RunImpl() {
scoped_ptr<Contains::Params> params(Contains::Params::Create(*args_));

scoped_refptr<PermissionSet> permissions =
      helpers::UnpackPermissionSet(params->permissions, &error_);
if (!permissions.get())
return false;

results_ = Contains::Results::Create(
GetExtension()->GetActivePermissions()->Contains(*permissions));
return true;
}

ExtensionSystem* ExtensionSystem::Get(Profile* profile) {
  return ExtensionSystemFactory::GetForProfile(profile);
}

void TestExtensionSystem::SetExtensionService(ExtensionService* service) {
  extension_service_.reset(service);
}

ExtensionWarningService* TestExtensionSystem::warning_service() {
  return NULL;
}

bool PermissionsRequestFunction::RunImpl() {
if (!user_gesture() && !ignore_user_gesture_for_tests) {
error_ = kUserGestureRequiredError;
return false;
}

scoped_ptr<Request::Params> params(Request::Params::Create(*args_));
EXTENSION_FUNCTION_VALIDATE(params.get());

requested_permissions_ =
      helpers::UnpackPermissionSet(params->permissions, &error_);
if (!requested_permissions_.get())
return false;

  extensions::ExtensionPrefs* prefs =
      profile()->GetExtensionService()->extension_prefs();
// Make sure they're only requesting permissions supported by this API.
APIPermissionSet apis = requested_permissions_->apis();
for (APIPermissionSet::const_iterator i = apis.begin();
i != apis.end(); ++i) {
if (!i->info()->supports_optional()) {
error_ = ErrorUtils::FormatErrorMessage(
kNotWhitelistedError, i->name());
return false;
}
}

// Filter out permissions that do not need to be listed in the optional
// section of the manifest.
scoped_refptr<extensions::PermissionSet>
manifest_required_requested_permissions =
PermissionSet::ExcludeNotInManifestPermissions(
requested_permissions_.get());

// The requested permissions must be defined as optional in the manifest.
if (!GetExtension()->optional_permission_set()->Contains(
*manifest_required_requested_permissions)) {
error_ = kNotInOptionalPermissionsError;
results_ = Request::Results::Create(false);
return false;
}

// We don't need to prompt the user if the requested permissions are a subset
// of the granted permissions set.
scoped_refptr<const PermissionSet> granted =
prefs->GetGrantedPermissions(GetExtension()->id());
if (granted.get() && granted->Contains(*requested_permissions_)) {
PermissionsUpdater perms_updater(profile());
perms_updater.AddPermissions(GetExtension(), requested_permissions_.get());
results_ = Request::Results::Create(true);
SendResponse(true);
return true;
}

// Filter out the granted permissions so we only prompt for new ones.
requested_permissions_ = PermissionSet::CreateDifference(
requested_permissions_.get(), granted.get());

AddRef();  // Balanced in InstallUIProceed() / InstallUIAbort().

// We don't need to show the prompt if there are no new warnings, or if
// we're skipping the confirmation UI. All extension types but INTERNAL
// are allowed to silently increase their permission level.
bool has_no_warnings = requested_permissions_->GetWarningMessages(
GetExtension()->GetType()).empty();
if (auto_confirm_for_tests == PROCEED || has_no_warnings) {
InstallUIProceed();
} else if (auto_confirm_for_tests == ABORT) {
// Pretend the user clicked cancel.
InstallUIAbort(true);
} else {
CHECK_EQ(DO_NOT_SKIP, auto_confirm_for_tests);
install_ui_.reset(new ExtensionInstallPrompt(GetAssociatedWebContents()));
install_ui_->ConfirmPermissions(
this, GetExtension(), requested_permissions_.get());
}

return true;
}

scoped_ptr<Permissions> PackPermissionSet(const PermissionSet* set) {
  Permissions* permissions(new Permissions());

  permissions->permissions.reset(new std::vector<std::string>());
  for (APIPermissionSet::const_iterator i = set->apis().begin();
       i != set->apis().end(); ++i) {
    scoped_ptr<base::Value> value(i->ToValue());
    if (!value) {
      permissions->permissions->push_back(i->name());
    } else {
      std::string name(i->name());
      std::string json;
      base::JSONWriter::Write(value.get(), &json);
      permissions->permissions->push_back(name + kDelimiter + json);
    }
  }

  permissions->origins.reset(new std::vector<std::string>());
  URLPatternSet hosts = set->explicit_hosts();
  for (URLPatternSet::const_iterator i = hosts.begin(); i != hosts.end(); ++i)
    permissions->origins->push_back(i->GetAsString());

  return scoped_ptr<Permissions>(permissions);
 }

ProfileKeyedService* TestExtensionSystem::Build(Profile* profile) {
  return new TestExtensionSystem(profile);
}

TestExtensionSystem::~TestExtensionSystem() {
}

RulesRegistryService* ExtensionSystemImpl::rules_registry_service() {
  return rules_registry_service_.get();
}

 ShellWindowGeometryCache* ExtensionSystemImpl::shell_window_geometry_cache() {
   return shared_->shell_window_geometry_cache();
 }

ExtensionService* TestExtensionSystem::CreateExtensionService(
    const CommandLine* command_line,
    const FilePath& install_directory,
    bool autoupdate_enabled) {
  bool extensions_disabled =
      command_line && command_line->HasSwitch(switches::kDisableExtensions);


  extension_prefs_ = ExtensionPrefs::Create(
      profile_->GetPrefs(),
      install_directory,
      ExtensionPrefValueMapFactory::GetForProfile(profile_),
      extensions_disabled);
  state_store_.reset(new StateStore(profile_, new TestingValueStore()));
  shell_window_geometry_cache_.reset(
      new ShellWindowGeometryCache(profile_, extension_prefs_.get()));
  blacklist_.reset(new Blacklist(extension_prefs_.get()));
  standard_management_policy_provider_.reset(
      new StandardManagementPolicyProvider(extension_prefs_.get()));
  management_policy_.reset(new ManagementPolicy());
  management_policy_->RegisterProvider(
      standard_management_policy_provider_.get());
  extension_service_.reset(new ExtensionService(profile_,
                                                command_line,
                                                install_directory,
                                                extension_prefs_.get(),
                                                blacklist_.get(),
                                                autoupdate_enabled,
                                                true));
  extension_service_->ClearProvidersForTesting();
  return extension_service_.get();
}

ManagementPolicy* ExtensionSystemImpl::Shared::management_policy() {
  return management_policy_.get();
}

     shell_window_geometry_cache() {
   return shell_window_geometry_cache_.get();
}

  void SetUpCommandLine(CommandLine* command_line) {
    ExtensionApiTest::SetUpCommandLine(command_line);
    command_line->AppendSwitch(switches::kEnableExperimentalExtensionApis);
  }

 ShellWindowGeometryCache* TestExtensionSystem::shell_window_geometry_cache() {
   return shell_window_geometry_cache_.get();
 }

void TestExtensionSystem::Shutdown() {
  extension_process_manager_.reset();
}

ExtensionWarningService* ExtensionSystemImpl::Shared::warning_service() {
  return extension_warning_service_.get();
}

ManagementPolicy* ExtensionSystemImpl::management_policy() {
  return shared_->management_policy();
}

TestExtensionSystem::usb_device_resource_manager() {
  return NULL;
}

EventRouter* ExtensionSystemImpl::event_router() {
  return shared_->event_router();
}

void ExtensionSystemImpl::InitForOTRProfile() {
  if (extension_service()) {
    rules_registry_service_.reset(new RulesRegistryService(profile_));
    rules_registry_service_->RegisterDefaultRulesRegistries();
  }
}

AlarmManager* TestExtensionSystem::alarm_manager() {
  return alarm_manager_.get();
}

UserScriptMaster* TestExtensionSystem::user_script_master() {
  return NULL;
}

Blacklist* ExtensionSystemImpl::blacklist() {
  return shared_->blacklist();
}

MessageService* ExtensionSystemImpl::message_service() {
  return shared_->message_service();
}

UserScriptMaster* ExtensionSystemImpl::Shared::user_script_master() {
  return user_script_master_.get();
}
