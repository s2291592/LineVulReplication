int gd_getin (void *in)
{
 	return (gdGetC((gdIOCtx *) in));
 }

char_init(GifCtx *ctx)
{
        ctx->a_count = 0;
}

output(code_int code, GifCtx *ctx)
{
	if (ctx->cur_bits == CUR_BITS_FINISHED) {
		return;
	}

    ctx->cur_accum &= masks[ ctx->cur_bits ];

    if( ctx->cur_bits > 0 )
        ctx->cur_accum |= ((long)code << ctx->cur_bits);
    else
        ctx->cur_accum = code;

    ctx->cur_bits += ctx->n_bits;

    while( ctx->cur_bits >= 8 ) {
        char_out( (unsigned int)(ctx->cur_accum & 0xff), ctx );
        ctx->cur_accum >>= 8;
        ctx->cur_bits -= 8;
    }

    /*
     * If the next entry is going to be too big for the code size,
     * then increase it, if possible.
     */
   if ( ctx->free_ent > ctx->maxcode || ctx->clear_flg ) {

            if( ctx->clear_flg ) {

                ctx->maxcode = MAXCODE (ctx->n_bits = ctx->g_init_bits);
                ctx->clear_flg = 0;

            } else {

                ++(ctx->n_bits);
                if ( ctx->n_bits == maxbits )
                    ctx->maxcode = maxmaxcode;
                else
                    ctx->maxcode = MAXCODE(ctx->n_bits);
            }
        }

    if( code == ctx->EOFCode ) {
        /*
         * At EOF, write the rest of the buffer.
         */
        while( ctx->cur_bits > 0 ) {
                char_out( (unsigned int)(ctx->cur_accum & 0xff), ctx);
                ctx->cur_accum >>= 8;
                ctx->cur_bits -= 8;
        }

		/* Flag that it's done to prevent re-entry. */
		ctx->cur_bits = CUR_BITS_FINISHED;

        flush_char(ctx);
    }
}

gdImagePtr gdImageCreateFromWBMPPtr (int size, void *data)
{
	gdImagePtr im;
	gdIOCtx *in = gdNewDynamicCtxEx(size, data, 0);
	im = gdImageCreateFromWBMPCtx(in);
	in->gd_free(in);
	return im;
}

void init_source (j_decompress_ptr cinfo)
{
	my_src_ptr src = (my_src_ptr) cinfo->src;

	/* We reset the empty-input-file flag for each image,
	 * but we don't clear the input buffer.
	 * This is correct behavior for reading a series of images from one source.
	 */
	src->start_of_file = TRUE;
}

static int CMYKToRGB(int c, int m, int y, int k, int inverted)
{
	if (inverted) {
		c = 255 - c;
		m = 255 - m;
		y = 255 - y;
		k = 255 - k;
	}
	return gdTrueColor((255 - c) * (255 - k) / 255, (255 - m) * (255 - k) / 255, (255 - y) * (255 - k) / 255);
}

void * gdImageGifPtr (gdImagePtr im, int *size)
{
void *rv;
gdIOCtx *out = gdNewDynamicCtx (2048, NULL);
  gdImageGifCtx (im, out);
  rv = gdDPExtractData (out, size);
out->gd_free (out);
return rv;
}

gdImagePtr gdImageCreateFromWBMPCtx (gdIOCtx * infile)
{
	/* FILE *wbmp_file; */
	Wbmp *wbmp;
	gdImagePtr im = NULL;
	int black, white;
	int col, row, pos;

	if (readwbmp (&gd_getin, infile, &wbmp)) {
		return NULL;
	}

	if (!(im = gdImageCreate (wbmp->width, wbmp->height))) {
		freewbmp (wbmp);
		return NULL;
	}

	/* create the background color */
	white = gdImageColorAllocate(im, 255, 255, 255);
	/* create foreground color */
	black = gdImageColorAllocate(im, 0, 0, 0);

	/* fill in image (in a wbmp 1 = white/ 0 = black) */
	pos = 0;
	for (row = 0; row < wbmp->height; row++) {
		for (col = 0; col < wbmp->width; col++) {
			if (wbmp->bitmap[pos++] == WBMP_WHITE) {
				gdImageSetPixel(im, col, row, white);
			} else {
				gdImageSetPixel(im, col, row, black);
			}
		}
	}

	freewbmp(wbmp);

	return im;
}

void gdImageWBMP (gdImagePtr im, int fg, FILE * outFile)
{
	gdIOCtx *out = gdNewFileCtx(outFile);
	gdImageWBMPCtx(im, fg, out);
	out->gd_free(out);
}

void gdImageJpeg (gdImagePtr im, FILE * outFile, int quality)
{
	gdIOCtx *out = gdNewFileCtx (outFile);
	gdImageJpegCtx (im, out, quality);
	out->gd_free (out);
}

gdImagePtr gdImageCreateFromJpegCtx (gdIOCtx * infile)
{
	return gdImageCreateFromJpegCtxEx(infile, 1);
}

static int colorstobpp(int colors)
{
	int bpp = 0;

	if(colors <= 2)
		bpp = 1;
	else if(colors <= 4)
		bpp = 2;
	else if(colors <= 8)
		bpp = 3;
	else if(colors <= 16)
		bpp = 4;
	else if(colors <= 32)
		bpp = 5;
	else if(colors <= 64)
		bpp = 6;
	else if(colors <= 128)
		bpp = 7;
	else if(colors <= 256)
		bpp = 8;

	return bpp;
}

void gdImageGif (gdImagePtr im, FILE * outFile)
{
  gdIOCtx *out = gdNewFileCtx (outFile);
  gdImageGifCtx (im, out);
  out->gd_free (out);
 }

char_out(int c, GifCtx *ctx)
{
        ctx->accum[ ctx->a_count++ ] = c;
        if( ctx->a_count >= 254 )
                flush_char(ctx);
}

gdImagePtr gdImageCreateFromJpegCtxEx (gdIOCtx * infile, int ignore_warning)
{
	struct jpeg_decompress_struct cinfo;
	struct jpeg_error_mgr jerr;
	jmpbuf_wrapper jmpbufw;
	/* volatile so we can gdFree them after longjmp */
	volatile JSAMPROW row = 0;
	volatile gdImagePtr im = 0;
	JSAMPROW rowptr[1];
	unsigned int i, j;
	int retval;
	JDIMENSION nrows;
	int channels = 3;
	int inverted = 0;

	memset (&cinfo, 0, sizeof (cinfo));
	memset (&jerr, 0, sizeof (jerr));

	jmpbufw.ignore_warning = ignore_warning;

	cinfo.err = jpeg_std_error (&jerr);
	cinfo.client_data = &jmpbufw;

	cinfo.err->emit_message = (void (*)(j_common_ptr,int)) php_jpeg_emit_message;

	if (setjmp (jmpbufw.jmpbuf) != 0) {
		/* we're here courtesy of longjmp */
		if (row) {
			gdFree (row);
		}
		if (im) {
			gdImageDestroy (im);
		}
		return 0;
	}

	cinfo.err->error_exit = fatal_jpeg_error;

	jpeg_create_decompress (&cinfo);

	jpeg_gdIOCtx_src (&cinfo, infile);

	/* 2.0.22: save the APP14 marker to check for Adobe Photoshop CMYK files with inverted components. */
	jpeg_save_markers(&cinfo, JPEG_APP0 + 14, 256);

	retval = jpeg_read_header (&cinfo, TRUE);
	if (retval != JPEG_HEADER_OK) {
		gd_error_ex(GD_WARNING, "gd-jpeg: warning: jpeg_read_header returned %d, expected %d", retval, JPEG_HEADER_OK);
	}

	if (cinfo.image_height > INT_MAX) {
		gd_error_ex(GD_WARNING, "gd-jpeg: warning: JPEG image height (%u) is greater than INT_MAX (%d) (and thus greater than gd can handle)", cinfo.image_height, INT_MAX);
	}

	if (cinfo.image_width > INT_MAX) {
		gd_error_ex(GD_WARNING, "gd-jpeg: warning: JPEG image width (%u) is greater than INT_MAX (%d) (and thus greater than gd can handle)", cinfo.image_width, INT_MAX);
	}

	im = gdImageCreateTrueColor ((int) cinfo.image_width, (int) cinfo.image_height);
	if (im == 0) {
		gd_error("gd-jpeg error: cannot allocate gdImage struct");
		goto error;
	}

	/* check if the resolution is specified */
	switch (cinfo.density_unit) {
	case 1:
		im->res_x = cinfo.X_density;
		im->res_y = cinfo.Y_density;
		break;
	case 2:
		im->res_x = DPCM2DPI(cinfo.X_density);
		im->res_y = DPCM2DPI(cinfo.Y_density);
		break;
	}

	/* 2.0.22: very basic support for reading CMYK colorspace files. Nice for
	 * thumbnails but there's no support for fussy adjustment of the
	 * assumed properties of inks and paper. */
	if ((cinfo.jpeg_color_space == JCS_CMYK) || (cinfo.jpeg_color_space == JCS_YCCK)) {
		cinfo.out_color_space = JCS_CMYK;
	} else {
		cinfo.out_color_space = JCS_RGB;
	}

	if (jpeg_start_decompress (&cinfo) != TRUE) {
		gd_error("gd-jpeg: warning: jpeg_start_decompress reports suspended data source");
	}

	/* REMOVED by TBB 2/12/01. This field of the structure is
	 * documented as private, and sure enough it's gone in the
	 * latest libjpeg, replaced by something else. Unfortunately
	 * there is still no right way to find out if the file was
	 * progressive or not; just declare your intent before you
	 * write one by calling gdImageInterlace(im, 1) yourself.
	 * After all, we're not really supposed to rework JPEGs and
	 * write them out again anyway. Lossy compression, remember?
	 */
#if 0
  gdImageInterlace (im, cinfo.progressive_mode != 0);
#endif

	if (cinfo.out_color_space == JCS_RGB) {
		if (cinfo.output_components != 3) {
			gd_error_ex(GD_WARNING, "gd-jpeg: error: JPEG color quantization request resulted in output_components == %d (expected 3 for RGB)", cinfo.output_components);
			goto error;
		}
		channels = 3;
	} else if (cinfo.out_color_space == JCS_CMYK) {
		jpeg_saved_marker_ptr marker;
		if (cinfo.output_components != 4)  {
			gd_error_ex(GD_WARNING, "gd-jpeg: error: JPEG color quantization request resulted in output_components == %d (expected 4 for CMYK)", cinfo.output_components);
			goto error;
		}
		channels = 4;
		marker = cinfo.marker_list;
		while (marker) {
			if ((marker->marker == (JPEG_APP0 + 14)) && (marker->data_length >= 12) && (!strncmp((const char *) marker->data, "Adobe", 5))) {
				inverted = 1;
				break;
			}
			marker = marker->next;
		}
	} else {
		gd_error_ex(GD_WARNING, "gd-jpeg: error: unexpected colorspace.");
		goto error;
	}

#if BITS_IN_JSAMPLE == 12
	gd_error("gd-jpeg: error: jpeg library was compiled for 12-bit precision. This is mostly useless, because JPEGs on the web are 8-bit and such versions of the jpeg library won't read or write them. GD doesn't support these unusual images. Edit your jmorecfg.h file to specify the correct precision and completely 'make clean' and 'make install' libjpeg again. Sorry.");
	goto error;
#endif /* BITS_IN_JSAMPLE == 12 */

	row = safe_emalloc(cinfo.output_width * channels, sizeof(JSAMPLE), 0);
	memset(row, 0, cinfo.output_width * channels * sizeof(JSAMPLE));
	rowptr[0] = row;

	if (cinfo.out_color_space == JCS_CMYK) {
		for (i = 0; i < cinfo.output_height; i++) {
			register JSAMPROW currow = row;
			register int *tpix = im->tpixels[i];
			nrows = jpeg_read_scanlines (&cinfo, rowptr, 1);
			if (nrows != 1) {
				gd_error_ex(GD_WARNING, "gd-jpeg: error: jpeg_read_scanlines returns %u, expected 1", nrows);
				goto error;
			}
			for (j = 0; j < cinfo.output_width; j++, currow += 4, tpix++) {
				*tpix = CMYKToRGB (currow[0], currow[1], currow[2], currow[3], inverted);
			}
		}
	} else {
		for (i = 0; i < cinfo.output_height; i++) {
			register JSAMPROW currow = row;
			register int *tpix = im->tpixels[i];
			nrows = jpeg_read_scanlines (&cinfo, rowptr, 1);
			if (nrows != 1) {
				gd_error_ex(GD_WARNING, "gd-jpeg: error: jpeg_read_scanlines returns %u, expected 1", nrows);
				goto error;
			}
			for (j = 0; j < cinfo.output_width; j++, currow += 3, tpix++) {
				*tpix = gdTrueColor (currow[0], currow[1], currow[2]);
			}
		}
	}

	if (jpeg_finish_decompress (&cinfo) != TRUE) {
		gd_error("gd-jpeg: warning: jpeg_finish_decompress reports suspended data source");
	}
	if (!ignore_warning) {
		if (cinfo.err->num_warnings > 0) {
			goto error;
		}
	}

	jpeg_destroy_decompress (&cinfo);
	gdFree (row);

	return im;

error:
	jpeg_destroy_decompress (&cinfo);
	if (row) {
		gdFree (row);
	}
	if (im) {
		gdImageDestroy (im);
	}
	return 0;
}

static int GIFNextPixel(gdImagePtr im, GifCtx *ctx)
{
	int r;

	if(ctx->CountDown == 0) {
		return EOF;
	}

	--(ctx->CountDown);

	r = gdImageGetPixel(im, ctx->curx, ctx->cury);

	BumpPixel(ctx);

	return r;
}

static void fatal_jpeg_error (j_common_ptr cinfo)
{
	jmpbuf_wrapper *jmpbufw;
	char buffer[JMSG_LENGTH_MAX];

	(*cinfo->err->format_message)(cinfo, buffer);
	gd_error_ex(GD_WARNING, "gd-jpeg: JPEG library reports unrecoverable error: %s", buffer);

	jmpbufw = (jmpbuf_wrapper *) cinfo->client_data;
	jpeg_destroy (cinfo);

	if (jmpbufw != 0) {
		longjmp (jmpbufw->jmpbuf, 1);
		gd_error_ex(GD_ERROR, "gd-jpeg: EXTREMELY fatal error: longjmp returned control; terminating");
	} else {
		gd_error_ex(GD_ERROR, "gd-jpeg: EXTREMELY fatal error: jmpbuf unrecoverable; terminating");
	}

	exit (99);
}

static void char_out(int c, GifCtx *ctx)
{
	ctx->accum[ctx->a_count++] = c;
	if(ctx->a_count >= 254) {
		flush_char(ctx);
	}
}

void gd_putout (int i, void *out)
{
	gdPutC(i, (gdIOCtx *) out);
}

void term_source (j_decompress_ptr cinfo)
{
#if 0
	* never used */
	my_src_ptr src = (my_src_ptr) cinfo->src;
#endif
}

static int comparewithmap(gdImagePtr im1, gdImagePtr im2, int c1, int c2, int *colorMap)
{
	if(!colorMap) {
		return c1 == c2;
	}

	if(-2 != colorMap[c1]) {
		return colorMap[c1] == c2;
	}

	return (colorMap[c1] = gdImageColorExactAlpha(im2, im1->red[c1], im1->green[c1], im1->blue[c1], im1->alpha[c1])) == c2;
}

gdImagePtr gdImageCreateFromJpegEx (FILE * inFile, int ignore_warning)
{
	gdImagePtr im;
	gdIOCtx *in = gdNewFileCtx(inFile);
	im = gdImageCreateFromJpegCtxEx(in, ignore_warning);
	in->gd_free (in);

	return im;
}

void jpeg_gdIOCtx_src (j_decompress_ptr cinfo, gdIOCtx * infile)
{
	my_src_ptr src;

	/* The source object and input buffer are made permanent so that a series
	 * of JPEG images can be read from the same file by calling jpeg_gdIOCtx_src
	 * only before the first one.  (If we discarded the buffer at the end of
	 * one image, we'd likely lose the start of the next one.)
	 * This makes it unsafe to use this manager and a different source
	 * manager serially with the same JPEG object.  Caveat programmer.
	 */
	if (cinfo->src == NULL) { /* first time for this JPEG object? */
		cinfo->src = (struct jpeg_source_mgr *)
		(*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT, sizeof (my_source_mgr));
		src = (my_src_ptr) cinfo->src;
		src->buffer = (unsigned char *) (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT, INPUT_BUF_SIZE * sizeof (unsigned char));

	}

	src = (my_src_ptr) cinfo->src;
	src->pub.init_source = init_source;
	src->pub.fill_input_buffer = fill_input_buffer;
	src->pub.skip_input_data = skip_input_data;
	src->pub.resync_to_restart = jpeg_resync_to_restart;	/* use default method */
	src->pub.term_source = term_source;
	src->infile = infile;
	src->pub.bytes_in_buffer = 0;	/* forces fill_input_buffer on first read */
	src->pub.next_input_byte = NULL;	/* until buffer loaded */
}

const char * gdJpegGetVersionString()
{
	switch(JPEG_LIB_VERSION) {
		case 62:
			return "6b";
			break;

		case 70:
			return "7";
			break;

		case 80:
			return "8";
			break;

		case 90:
			return "9 compatible";
			break;

		default:
			return "unknown";
 	}
 }

void gdImageWBMPCtx (gdImagePtr image, int fg, gdIOCtx * out)
{
int x, y, pos;
Wbmp *wbmp;

/* create the WBMP */
if ((wbmp = createwbmp (gdImageSX (image), gdImageSY (image), WBMP_WHITE)) == NULL) {
gd_error("Could not create WBMP");
		return;
}

/* fill up the WBMP structure */
pos = 0;
for (y = 0; y < gdImageSY(image); y++) {
for (x = 0; x < gdImageSX(image); x++) {
if (gdImageGetPixel (image, x, y) == fg) {
wbmp->bitmap[pos] = WBMP_BLACK;
}
pos++;
}
}

/* write the WBMP to a gd file descriptor */
if (writewbmp (wbmp, &gd_putout, out)) {
gd_error("Could not save WBMP");
}
/* des submitted this bugfix: gdFree the memory. */
freewbmp(wbmp);
}

safeboolean empty_output_buffer (j_compress_ptr cinfo)
{
	my_dest_ptr dest = (my_dest_ptr) cinfo->dest;

	if (gdPutBuf (dest->buffer, OUTPUT_BUF_SIZE, dest->outfile) != (size_t) OUTPUT_BUF_SIZE) {
		ERREXIT (cinfo, JERR_FILE_WRITE);
	}

	dest->pub.next_output_byte = dest->buffer;
	dest->pub.free_in_buffer = OUTPUT_BUF_SIZE;

	return TRUE;
}

void * gdImageWBMPPtr (gdImagePtr im, int *size, int fg)
{
void *rv;
gdIOCtx *out = gdNewDynamicCtx(2048, NULL);
	gdImageWBMPCtx(im, fg, out);
	rv = gdDPExtractData(out, size);
out->gd_free(out);

return rv;
}

cl_hash(register count_int chsize, GifCtx *ctx)          /* reset code table */

{

        register count_int *htab_p = ctx->htab+chsize;

        register long i;
        register long m1 = -1;

        i = chsize - 16;
        do {                            /* might use Sys V memset(3) here */
                *(htab_p-16) = m1;
                *(htab_p-15) = m1;
                *(htab_p-14) = m1;
                *(htab_p-13) = m1;
                *(htab_p-12) = m1;
                *(htab_p-11) = m1;
                *(htab_p-10) = m1;
                *(htab_p-9) = m1;
                *(htab_p-8) = m1;
                *(htab_p-7) = m1;
                *(htab_p-6) = m1;
                *(htab_p-5) = m1;
                *(htab_p-4) = m1;
                *(htab_p-3) = m1;
                *(htab_p-2) = m1;
                *(htab_p-1) = m1;
                htab_p -= 16;
        } while ((i -= 16) >= 0);

        for ( i += 16; i > 0; --i )
                *--htab_p = m1;
}

static long php_jpeg_emit_message(j_common_ptr jpeg_info, int level)
{
	char message[JMSG_LENGTH_MAX];
	jmpbuf_wrapper *jmpbufw;
	int ignore_warning = 0;

	jmpbufw = (jmpbuf_wrapper *) jpeg_info->client_data;

	if (jmpbufw != 0) {
		ignore_warning = jmpbufw->ignore_warning;
	}

	(jpeg_info->err->format_message)(jpeg_info,message);

	/* It is a warning message */
	if (level < 0) {
		/* display only the 1st warning, as would do a default libjpeg
		 * unless strace_level >= 3
		 */
		if ((jpeg_info->err->num_warnings == 0) || (jpeg_info->err->trace_level >= 3)) {
			if (!ignore_warning) {
				gd_error("gd-jpeg, libjpeg: recoverable error: %s\n", message);
			}
		}

		jpeg_info->err->num_warnings++;
	} else {
		/* strace msg, Show it if trace_level >= level. */
		if (jpeg_info->err->trace_level >= level) {
			if (!ignore_warning) {
				gd_error("gd-jpeg, libjpeg: strace message: %s\n", message);
			}
		}
	}
	return 1;
}

flush_char(GifCtx *ctx)
{
        if( ctx->a_count > 0 ) {
                gdPutC( ctx->a_count, ctx->g_outfile );
                gdPutBuf( ctx->accum, ctx->a_count, ctx->g_outfile );
                ctx->a_count = 0;
        }
}

colorstobpp(int colors)
{
    int bpp = 0;

    if ( colors <= 2 )
        bpp = 1;
    else if ( colors <= 4 )
        bpp = 2;
    else if ( colors <= 8 )
        bpp = 3;
    else if ( colors <= 16 )
        bpp = 4;
    else if ( colors <= 32 )
        bpp = 5;
    else if ( colors <= 64 )
        bpp = 6;
    else if ( colors <= 128 )
        bpp = 7;
    else if ( colors <= 256 )
        bpp = 8;
    return bpp;
    }

static void cl_hash(register count_int chsize, GifCtx *ctx) /* reset code table */
{
	register count_int *htab_p = ctx->htab+chsize;
	register long i;
	register long m1 = -1;

	i = chsize - 16;
	do { /* might use Sys V memset(3) here */
		*(htab_p - 16) = m1;
		*(htab_p - 15) = m1;
		*(htab_p - 14) = m1;
		*(htab_p - 13) = m1;
		*(htab_p - 12) = m1;
		*(htab_p - 11) = m1;
		*(htab_p - 10) = m1;
		*(htab_p - 9) = m1;
		*(htab_p - 8) = m1;
		*(htab_p - 7) = m1;
		*(htab_p - 6) = m1;
		*(htab_p - 5) = m1;
		*(htab_p - 4) = m1;
		*(htab_p - 3) = m1;
		*(htab_p - 2) = m1;
		*(htab_p - 1) = m1;
		htab_p -= 16;
	} while((i -= 16) >= 0);

	for(i += 16; i > 0; --i) {
		*--htab_p = m1;
	}
}

void gdImageJpegCtx (gdImagePtr im, gdIOCtx * outfile, int quality)
{
struct jpeg_compress_struct cinfo;
struct jpeg_error_mgr jerr;
int i, j, jidx;
/* volatile so we can gdFree it on return from longjmp */
volatile JSAMPROW row = 0;
JSAMPROW rowptr[1];
jmpbuf_wrapper jmpbufw;
JDIMENSION nlines;
char comment[255];

memset (&cinfo, 0, sizeof (cinfo));
memset (&jerr, 0, sizeof (jerr));

cinfo.err = jpeg_std_error (&jerr);
cinfo.client_data = &jmpbufw;
if (setjmp (jmpbufw.jmpbuf) != 0) {
/* we're here courtesy of longjmp */
if (row) {
gdFree (row);
}
		return;
}

cinfo.err->error_exit = fatal_jpeg_error;

jpeg_create_compress (&cinfo);

cinfo.image_width = im->sx;
cinfo.image_height = im->sy;
cinfo.input_components = 3;	/* # of color components per pixel */
cinfo.in_color_space = JCS_RGB;	/* colorspace of input image */
jpeg_set_defaults (&cinfo);

cinfo.density_unit = 1;
cinfo.X_density = im->res_x;
cinfo.Y_density = im->res_y;

if (quality >= 0) {
jpeg_set_quality (&cinfo, quality, TRUE);
}

/* If user requests interlace, translate that to progressive JPEG */
if (gdImageGetInterlaced (im)) {
jpeg_simple_progression (&cinfo);
}

jpeg_gdIOCtx_dest (&cinfo, outfile);

row = (JSAMPROW) safe_emalloc(cinfo.image_width * cinfo.input_components, sizeof(JSAMPLE), 0);
memset(row, 0, cinfo.image_width * cinfo.input_components * sizeof(JSAMPLE));
rowptr[0] = row;

jpeg_start_compress (&cinfo, TRUE);

if (quality >= 0) {
snprintf(comment, sizeof(comment)-1, "CREATOR: gd-jpeg v%s (using IJG JPEG v%d), quality = %d\n", GD_JPEG_VERSION, JPEG_LIB_VERSION, quality);
} else {
snprintf(comment, sizeof(comment)-1, "CREATOR: gd-jpeg v%s (using IJG JPEG v%d), default quality\n", GD_JPEG_VERSION, JPEG_LIB_VERSION);
}
jpeg_write_marker (&cinfo, JPEG_COM, (unsigned char *) comment, (unsigned int) strlen (comment));
if (im->trueColor) {

#if BITS_IN_JSAMPLE == 12
gd_error("gd-jpeg: error: jpeg library was compiled for 12-bit precision. This is mostly useless, because JPEGs on the web are 8-bit and such versions of the jpeg library won't read or write them. GD doesn't support these unusual images. Edit your jmorecfg.h file to specify the correct precision and completely 'make clean' and 'make install' libjpeg again. Sorry");
goto error;
#endif /* BITS_IN_JSAMPLE == 12 */

for (i = 0; i < im->sy; i++) {
for (jidx = 0, j = 0; j < im->sx; j++) {
int val = im->tpixels[i][j];

row[jidx++] = gdTrueColorGetRed (val);
row[jidx++] = gdTrueColorGetGreen (val);
row[jidx++] = gdTrueColorGetBlue (val);
}

nlines = jpeg_write_scanlines (&cinfo, rowptr, 1);
if (nlines != 1) {
gd_error_ex(GD_WARNING, "gd_jpeg: warning: jpeg_write_scanlines returns %u -- expected 1", nlines);
}
}
} else {
for (i = 0; i < im->sy; i++) {
for (jidx = 0, j = 0; j < im->sx; j++) {
int idx = im->pixels[i][j];

/* NB: Although gd RGB values are ints, their max value is
* 255 (see the documentation for gdImageColorAllocate())
* -- perfect for 8-bit JPEG encoding (which is the norm)
*/
#if BITS_IN_JSAMPLE == 8
row[jidx++] = im->red[idx];
row[jidx++] = im->green[idx];
row[jidx++] = im->blue[idx];
#elif BITS_IN_JSAMPLE == 12
row[jidx++] = im->red[idx] << 4;
row[jidx++] = im->green[idx] << 4;
row[jidx++] = im->blue[idx] << 4;
#else
#error IJG JPEG library BITS_IN_JSAMPLE value must be 8 or 12
#endif
}

nlines = jpeg_write_scanlines (&cinfo, rowptr, 1);
if (nlines != 1) {
gd_error_ex(GD_WARNING, "gd_jpeg: warning: jpeg_write_scanlines returns %u -- expected 1", nlines);
}
}
}

jpeg_finish_compress (&cinfo);
jpeg_destroy_compress (&cinfo);
gdFree (row);
}

static void cl_block (GifCtx *ctx) /* table clear for block compress */
{
	cl_hash((count_int) hsize, ctx);
	ctx->free_ent = ctx->ClearCode + 2;
	ctx->clear_flg = 1;

	output((code_int)ctx->ClearCode, ctx);
}

GIFNextPixel(gdImagePtr im, GifCtx *ctx)
{
        int r;

        if( ctx->CountDown == 0 )
                return EOF;

        --(ctx->CountDown);

        r = gdImageGetPixel(im, ctx->curx, ctx->cury);

        BumpPixel(ctx);

        return r;
}

void init_destination (j_compress_ptr cinfo)
{
	my_dest_ptr dest = (my_dest_ptr) cinfo->dest;

	/* Allocate the output buffer --- it will be released when done with image */
	dest->buffer = (unsigned char *) (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE, OUTPUT_BUF_SIZE * sizeof (unsigned char));

	dest->pub.next_output_byte = dest->buffer;
	dest->pub.free_in_buffer = OUTPUT_BUF_SIZE;
}

cl_block (GifCtx *ctx)             /* table clear for block compress */
{

        cl_hash ( (count_int) hsize, ctx );
        ctx->free_ent = ctx->ClearCode + 2;
        ctx->clear_flg = 1;

        output( (code_int)ctx->ClearCode, ctx);
}

static void BumpPixel(GifCtx *ctx)
{
	/* Bump the current X position */
	++(ctx->curx);

	/* If we are at the end of a scan line, set curx back to the beginning
	 * If we are interlaced, bump the cury to the appropriate spot,
	 * otherwise, just increment it. */
	if(ctx->curx == ctx->Width) {
		ctx->curx = 0;

		if(!ctx->Interlace) {
			++(ctx->cury);
		} else {
			switch(ctx->Pass) {

			case 0:
				ctx->cury += 8;
				if(ctx->cury >= ctx->Height) {
					++(ctx->Pass);
					ctx->cury = 4;
				}
				break;

			case 1:
				ctx->cury += 8;
				if(ctx->cury >= ctx->Height) {
					++(ctx->Pass);
					ctx->cury = 2;
				}
				break;

			case 2:
				ctx->cury += 4;
				if(ctx->cury >= ctx->Height) {
					++(ctx->Pass);
					ctx->cury = 1;
				}
				break;

			case 3:
				ctx->cury += 2;
				break;
			}
		}
	}
}

void term_destination (j_compress_ptr cinfo)
{
	my_dest_ptr dest = (my_dest_ptr) cinfo->dest;
	size_t datacount = OUTPUT_BUF_SIZE - dest->pub.free_in_buffer;

	/* Write any data remaining in the buffer */
	if (datacount > 0 && ((size_t)gdPutBuf (dest->buffer, datacount, dest->outfile) != datacount)) {
		ERREXIT (cinfo, JERR_FILE_WRITE);
	}
}

compress(int init_bits, gdIOCtxPtr outfile, gdImagePtr im, GifCtx *ctx)
{
    register long fcode;
    register code_int i /* = 0 */;
    register int c;
    register code_int ent;
    register code_int disp;
    register code_int hsize_reg;
    register int hshift;

    /*
     * Set up the globals:  g_init_bits - initial number of bits
     *                      g_outfile   - pointer to output file
     */
    ctx->g_init_bits = init_bits;
    ctx->g_outfile = outfile;

    /*
     * Set up the necessary values
     */
    ctx->offset = 0;
    ctx->out_count = 0;
    ctx->clear_flg = 0;
    ctx->in_count = 1;
    ctx->maxcode = MAXCODE(ctx->n_bits = ctx->g_init_bits);

    ctx->ClearCode = (1 << (init_bits - 1));
    ctx->EOFCode = ctx->ClearCode + 1;
    ctx->free_ent = ctx->ClearCode + 2;

    char_init(ctx);

    ent = GIFNextPixel( im, ctx );

    hshift = 0;
    for ( fcode = (long) hsize;  fcode < 65536L; fcode *= 2L )
        ++hshift;
    hshift = 8 - hshift;                /* set hash code range bound */

    hsize_reg = hsize;
    cl_hash( (count_int) hsize_reg, ctx );            /* clear hash table */

    output( (code_int)ctx->ClearCode, ctx );

#ifdef SIGNED_COMPARE_SLOW
    while ( (c = GIFNextPixel( im )) != (unsigned) EOF ) {
#else /*SIGNED_COMPARE_SLOW*/
    while ( (c = GIFNextPixel( im, ctx )) != EOF ) {  /* } */
#endif /*SIGNED_COMPARE_SLOW*/

        ++(ctx->in_count);

        fcode = (long) (((long) c << maxbits) + ent);
        i = (((code_int)c << hshift) ^ ent);    /* xor hashing */

        if ( HashTabOf (i) == fcode ) {
            ent = CodeTabOf (i);
            continue;
        } else if ( (long)HashTabOf (i) < 0 )      /* empty slot */
            goto nomatch;
        disp = hsize_reg - i;           /* secondary hash (after G. Knott) */
        if ( i == 0 )
            disp = 1;
probe:
        if ( (i -= disp) < 0 )
            i += hsize_reg;

        if ( HashTabOf (i) == fcode ) {
            ent = CodeTabOf (i);
            continue;
        }
        if ( (long)HashTabOf (i) > 0 )
            goto probe;
nomatch:
        output ( (code_int) ent, ctx );
        ++(ctx->out_count);
        ent = c;
#ifdef SIGNED_COMPARE_SLOW
        if ( (unsigned) ctx->free_ent < (unsigned) maxmaxcode) {
#else /*SIGNED_COMPARE_SLOW*/
        if ( ctx->free_ent < maxmaxcode ) {  /* } */
#endif /*SIGNED_COMPARE_SLOW*/
            CodeTabOf (i) = ctx->free_ent++; /* code -> hashtable */
            HashTabOf (i) = fcode;
        } else
                cl_block(ctx);
    }
    /*
     * Put out the final code.
     */
    output( (code_int)ent, ctx );
    ++(ctx->out_count);
    output( (code_int) ctx->EOFCode, ctx );
}

gdImagePtr gdImageCreateFromWBMP (FILE * inFile)
{
	gdImagePtr im;
	gdIOCtx *in = gdNewFileCtx(inFile);
	im = gdImageCreateFromWBMPCtx(in);
	in->gd_free(in);

	return im;
}

static void char_init(GifCtx *ctx)
{
	ctx->a_count = 0;
}

void jpeg_gdIOCtx_dest (j_compress_ptr cinfo, gdIOCtx * outfile)
{
	my_dest_ptr dest;

	/* The destination object is made permanent so that multiple JPEG images
	 * can be written to the same file without re-executing jpeg_stdio_dest.
	 * This makes it dangerous to use this manager and a different destination
	 * manager serially with the same JPEG object, because their private object
	 * sizes may be different.  Caveat programmer.
	 */
	if (cinfo->dest == NULL) { /* first time for this JPEG object? */
		cinfo->dest = (struct jpeg_destination_mgr *) (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT, sizeof (my_destination_mgr));
	}

	dest = (my_dest_ptr) cinfo->dest;
	dest->pub.init_destination = init_destination;
	dest->pub.empty_output_buffer = empty_output_buffer;
	dest->pub.term_destination = term_destination;
	dest->outfile = outfile;
}

GIFEncode(gdIOCtxPtr fp, int GWidth, int GHeight, int GInterlace, int Background, int Transparent, int BitsPerPixel, int *Red, int *Green, int *Blue, gdImagePtr im)
{
        int B;
        int RWidth, RHeight;
        int LeftOfs, TopOfs;
        int Resolution;
        int ColorMapSize;
        int InitCodeSize;
        int i;
		GifCtx ctx;

		memset(&ctx, 0, sizeof(ctx));
        ctx.Interlace = GInterlace;
		ctx.in_count = 1;

        ColorMapSize = 1 << BitsPerPixel;

        RWidth = ctx.Width = GWidth;
        RHeight = ctx.Height = GHeight;
        LeftOfs = TopOfs = 0;

        Resolution = BitsPerPixel;

        /*
         * Calculate number of bits we are expecting
         */
        ctx.CountDown = (long)ctx.Width * (long)ctx.Height;

        /*
         * Indicate which pass we are on (if interlace)
         */
        ctx.Pass = 0;

        /*
         * The initial code size
         */
        if( BitsPerPixel <= 1 )
                InitCodeSize = 2;
        else
                InitCodeSize = BitsPerPixel;

        /*
         * Set up the current x and y position
         */
        ctx.curx = ctx.cury = 0;

        /*
         * Write the Magic header
         */
        gdPutBuf(Transparent < 0 ? "GIF87a" : "GIF89a", 6, fp );

        /*
         * Write out the screen width and height
         */
        gifPutWord( RWidth, fp );
        gifPutWord( RHeight, fp );

        /*
         * Indicate that there is a global colour map
         */
        B = 0x80;       /* Yes, there is a color map */

        /*
         * OR in the resolution
         */
        B |= (Resolution - 1) << 5;

        /*
         * OR in the Bits per Pixel
         */
        B |= (BitsPerPixel - 1);

        /*
         * Write it out
         */
        gdPutC( B, fp );

        /*
         * Write out the Background colour
         */
        gdPutC( Background, fp );

        /*
         * Byte of 0's (future expansion)
         */
        gdPutC( 0, fp );

        /*
         * Write out the Global Colour Map
         */
        for( i=0; i<ColorMapSize; ++i ) {
                gdPutC( Red[i], fp );
                gdPutC( Green[i], fp );
                gdPutC( Blue[i], fp );
        }

	/*
	 * Write out extension for transparent colour index, if necessary.
	 */
	if ( Transparent >= 0 ) {
	    gdPutC( '!', fp );
	    gdPutC( 0xf9, fp );
	    gdPutC( 4, fp );
	    gdPutC( 1, fp );
	    gdPutC( 0, fp );
	    gdPutC( 0, fp );
	    gdPutC( (unsigned char) Transparent, fp );
	    gdPutC( 0, fp );
	}

        /*
         * Write an Image separator
         */
        gdPutC( ',', fp );

        /*
         * Write the Image header
         */

        gifPutWord( LeftOfs, fp );
        gifPutWord( TopOfs, fp );
        gifPutWord( ctx.Width, fp );
        gifPutWord( ctx.Height, fp );

        /*
         * Write out whether or not the image is interlaced
         */
        if( ctx.Interlace )
                gdPutC( 0x40, fp );
        else
                gdPutC( 0x00, fp );

        /*
         * Write out the initial code size
         */
        gdPutC( InitCodeSize, fp );

        /*
         * Go and actually compress the data
         */
        compress( InitCodeSize+1, fp, im, &ctx );

        /*
         * Write out a Zero-length packet (to end the series)
         */
        gdPutC( 0, fp );

        /*
         * Write the GIF file terminator
         */
        gdPutC( ';', fp );
}

gdImagePtr gdImageCreateFromJpegPtrEx (int size, void *data, int ignore_warning)
{
	gdImagePtr im;
	gdIOCtx *in = gdNewDynamicCtxEx(size, data, 0);
	im = gdImageCreateFromJpegCtxEx(in, ignore_warning);
	in->gd_free(in);

	return im;
}
