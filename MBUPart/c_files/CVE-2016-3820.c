WORD32 ih264d_end_of_pic(dec_struct_t *ps_dec,
                       UWORD8 u1_is_idr_slice,
                       UWORD16 u2_frame_num)
{
 dec_slice_params_t *ps_cur_slice = ps_dec->ps_cur_slice;
    WORD32 ret;

    ps_dec->u1_first_pb_nal_in_pic = 1;
    ps_dec->u2_mbx = 0xffff;
    ps_dec->u2_mby = 0;
 {
 dec_err_status_t * ps_err = ps_dec->ps_dec_err_status;
 if(ps_err->u1_err_flag & REJECT_CUR_PIC)
 {
            ih264d_err_pic_dispbuf_mgr(ps_dec);
 return ERROR_NEW_FRAME_EXPECTED;
 }
 }

    H264_MUTEX_LOCK(&ps_dec->process_disp_mutex);
    ret = ih264d_end_of_pic_processing(ps_dec);
 if(ret != OK)
 return ret;
    ps_dec->u2_total_mbs_coded = 0;
 /*--------------------------------------------------------------------*/
 /* ih264d_decode_pic_order_cnt - calculate the Pic Order Cnt                    */
 /* Needed to detect end of picture                                    */
 /*--------------------------------------------------------------------*/
 {
 pocstruct_t *ps_prev_poc = &ps_dec->s_prev_pic_poc;
 pocstruct_t *ps_cur_poc = &ps_dec->s_cur_pic_poc;
 if((0 == u1_is_idr_slice) && ps_cur_slice->u1_nal_ref_idc)
            ps_dec->u2_prev_ref_frame_num = ps_cur_slice->u2_frame_num;

 if(u1_is_idr_slice || ps_cur_slice->u1_mmco_equalto5)
            ps_dec->u2_prev_ref_frame_num = 0;

 if(ps_dec->ps_cur_sps->u1_gaps_in_frame_num_value_allowed_flag)
 {
            ret = ih264d_decode_gaps_in_frame_num(ps_dec, u2_frame_num);
 if(ret != OK)
 return ret;
 }

        ps_prev_poc->i4_prev_frame_num_ofst = ps_cur_poc->i4_prev_frame_num_ofst;
        ps_prev_poc->u2_frame_num = ps_cur_poc->u2_frame_num;
        ps_prev_poc->u1_mmco_equalto5 = ps_cur_slice->u1_mmco_equalto5;
 if(ps_cur_slice->u1_nal_ref_idc)
 {
            ps_prev_poc->i4_pic_order_cnt_lsb = ps_cur_poc->i4_pic_order_cnt_lsb;
            ps_prev_poc->i4_pic_order_cnt_msb = ps_cur_poc->i4_pic_order_cnt_msb;
            ps_prev_poc->i4_delta_pic_order_cnt_bottom =
                            ps_cur_poc->i4_delta_pic_order_cnt_bottom;
            ps_prev_poc->i4_delta_pic_order_cnt[0] =
                            ps_cur_poc->i4_delta_pic_order_cnt[0];
            ps_prev_poc->i4_delta_pic_order_cnt[1] =
                            ps_cur_poc->i4_delta_pic_order_cnt[1];
            ps_prev_poc->u1_bot_field = ps_cur_poc->u1_bot_field;
 }
 }

    H264_MUTEX_UNLOCK(&ps_dec->process_disp_mutex);

 return OK;
}

WORD32 ih264d_parse_end_of_sequence(dec_struct_t * ps_dec)
{
    WORD32 ret;

    ret = ih264d_end_of_pic_processing(ps_dec);
 return ret;
}

WORD32 ih264d_parse_inter_slice_data_cavlc(dec_struct_t * ps_dec,
 dec_slice_params_t * ps_slice,
                                           UWORD16 u2_first_mb_in_slice)
{
    UWORD32 uc_more_data_flag;
    WORD32 i2_cur_mb_addr;
    UWORD32 u1_num_mbs, u1_num_mbsNby2, u1_mb_idx;
    UWORD32 i2_mb_skip_run;
    UWORD32 u1_read_mb_type;

    UWORD32 u1_mbaff;
    UWORD32 u1_num_mbs_next, u1_end_of_row;
 const UWORD32 i2_pic_wdin_mbs = ps_dec->u2_frm_wd_in_mbs;
    UWORD32 u1_slice_end = 0;
    UWORD32 u1_tfr_n_mb = 0;
    UWORD32 u1_decode_nmb = 0;

 dec_bit_stream_t * const ps_bitstrm = ps_dec->ps_bitstrm;
    UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
    UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;
 deblk_mb_t *ps_cur_deblk_mb;
 dec_mb_info_t *ps_cur_mb_info;
 parse_pmbarams_t *ps_parse_mb_data = ps_dec->ps_parse_mb_data;
    UWORD32 u1_inter_mb_type;
    UWORD32 u1_deblk_mb_type;
    UWORD32 u1_mb_threshold;
    WORD32 ret = OK;

 /******************************************************/
 /* Initialisations specific to B or P slice           */
 /******************************************************/

 if(ps_slice->u1_slice_type == P_SLICE)
 {
        u1_inter_mb_type = P_MB;
        u1_deblk_mb_type = D_INTER_MB;
        u1_mb_threshold = 5;
 }
 else // B_SLICE
 {
        u1_inter_mb_type = B_MB;
        u1_deblk_mb_type = D_B_SLICE;
        u1_mb_threshold = 23;
 }
 /******************************************************/
 /* Slice Level Initialisations                        */
 /******************************************************/
    ps_dec->u1_qp = ps_slice->u1_slice_qp;
    ih264d_update_qp(ps_dec, 0);
    u1_mb_idx = ps_dec->u1_mb_idx;
    u1_num_mbs = u1_mb_idx;

    u1_num_mbsNby2 = 0;
    u1_mbaff = ps_slice->u1_mbaff_frame_flag;
    i2_cur_mb_addr = u2_first_mb_in_slice << u1_mbaff;
    i2_mb_skip_run = 0;
    uc_more_data_flag = 1;
    u1_read_mb_type = 0;

 while(!u1_slice_end)
 {
        UWORD8 u1_mb_type;

        ps_dec->pv_prev_mb_parse_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;

 if(i2_cur_mb_addr > ps_dec->ps_cur_sps->u2_max_mb_addr)
 {
 break;
 }


        ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs;
        ps_dec->u4_num_mbs_cur_nmb = u1_num_mbs;

        ps_cur_mb_info->u1_Mux = 0;
        ps_dec->u4_num_pmbair = (u1_num_mbs >> u1_mbaff);
        ps_cur_deblk_mb = ps_dec->ps_deblk_mbn + u1_num_mbs;

        ps_cur_mb_info->u1_end_of_slice = 0;

 /* Storing Default partition info */
        ps_parse_mb_data->u1_num_part = 1;
        ps_parse_mb_data->u1_isI_mb = 0;

 if((!i2_mb_skip_run) && (!u1_read_mb_type))
 {

            UWORD32 u4_bitstream_offset = *pu4_bitstrm_ofst;
            UWORD32 u4_word, u4_ldz;

 /***************************************************************/
 /* Find leading zeros in next 32 bits                          */
 /***************************************************************/
            NEXTBITS_32(u4_word, u4_bitstream_offset, pu4_bitstrm_buf);

            u4_ldz = CLZ(u4_word);

 /* Flush the ps_bitstrm */
            u4_bitstream_offset += (u4_ldz + 1);
 /* Read the suffix from the ps_bitstrm */
            u4_word = 0;
 if(u4_ldz)
 {
                GETBITS(u4_word, u4_bitstream_offset, pu4_bitstrm_buf,
                        u4_ldz);
 }
 *pu4_bitstrm_ofst = u4_bitstream_offset;
            i2_mb_skip_run = ((1 << u4_ldz) + u4_word - 1);
            COPYTHECONTEXT("mb_skip_run", i2_mb_skip_run);
            uc_more_data_flag = MORE_RBSP_DATA(ps_bitstrm);
            u1_read_mb_type = uc_more_data_flag;
 }

 /***************************************************************/
 /* Get the required information for decoding of MB                  */
 /* mb_x, mb_y , neighbour availablity,                              */
 /***************************************************************/
        ps_dec->pf_get_mb_info(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);

 /***************************************************************/
 /* Set the deblocking parameters for this MB                   */
 /***************************************************************/
 if(ps_dec->u4_app_disable_deblk_frm == 0)
            ih264d_set_deblocking_parameters(ps_cur_deblk_mb, ps_slice,
                                             ps_dec->u1_mb_ngbr_availablity,
                                             ps_dec->u1_cur_mb_fld_dec_flag);

 if(i2_mb_skip_run)
 {
 /* Set appropriate flags in ps_cur_mb_info and ps_dec */
            ps_dec->i1_prev_mb_qp_delta = 0;
            ps_dec->u1_sub_mb_num = 0;
            ps_cur_mb_info->u1_mb_type = MB_SKIP;
            ps_cur_mb_info->u1_mb_mc_mode = PRED_16x16;
            ps_cur_mb_info->u1_cbp = 0;

 {
 /* Storing Skip partition info */
 parse_part_params_t *ps_part_info = ps_dec->ps_part;
                ps_part_info->u1_is_direct = PART_DIRECT_16x16;
                ps_part_info->u1_sub_mb_num = 0;
                ps_dec->ps_part++;
 }

 /* Update Nnzs */
            ih264d_update_nnz_for_skipmb(ps_dec, ps_cur_mb_info, CAVLC);

            ps_cur_mb_info->ps_curmb->u1_mb_type = u1_inter_mb_type;
            ps_cur_deblk_mb->u1_mb_type |= u1_deblk_mb_type;

            i2_mb_skip_run--;
 }
 else
 {
            u1_read_mb_type = 0;
 /**************************************************************/
 /* Macroblock Layer Begins, Decode the u1_mb_type                */
 /**************************************************************/
 {
                UWORD32 u4_bitstream_offset = *pu4_bitstrm_ofst;
                UWORD32 u4_word, u4_ldz, u4_temp;


 /***************************************************************/
 /* Find leading zeros in next 32 bits                          */
 /***************************************************************/
                NEXTBITS_32(u4_word, u4_bitstream_offset, pu4_bitstrm_buf);
                u4_ldz = CLZ(u4_word);
 /* Flush the ps_bitstrm */
                u4_bitstream_offset += (u4_ldz + 1);
 /* Read the suffix from the ps_bitstrm */
                u4_word = 0;
 if(u4_ldz)
                    GETBITS(u4_word, u4_bitstream_offset, pu4_bitstrm_buf,
                            u4_ldz);
 *pu4_bitstrm_ofst = u4_bitstream_offset;
                u4_temp = ((1 << u4_ldz) + u4_word - 1);
 if(u4_temp > (UWORD32)(25 + u1_mb_threshold))
 return ERROR_MB_TYPE;
                u1_mb_type = u4_temp;
                COPYTHECONTEXT("u1_mb_type", u1_mb_type);
 }
            ps_cur_mb_info->u1_mb_type = u1_mb_type;

 /**************************************************************/
 /* Parse Macroblock data                                      */
 /**************************************************************/
 if(u1_mb_type < u1_mb_threshold)
 {
                ps_cur_mb_info->ps_curmb->u1_mb_type = u1_inter_mb_type;

                ret = ps_dec->pf_parse_inter_mb(ps_dec, ps_cur_mb_info, u1_num_mbs,
                                          u1_num_mbsNby2);
 if(ret != OK)
 return ret;
                ps_cur_deblk_mb->u1_mb_type |= u1_deblk_mb_type;
 }
 else
 {
 /* Storing Intra partition info */
                ps_parse_mb_data->u1_num_part = 0;
                ps_parse_mb_data->u1_isI_mb = 1;

 if((25 + u1_mb_threshold) == u1_mb_type)
 {
 /* I_PCM_MB */
                    ps_cur_mb_info->ps_curmb->u1_mb_type = I_PCM_MB;
                    ret = ih264d_parse_ipcm_mb(ps_dec, ps_cur_mb_info, u1_num_mbs);
 if(ret != OK)
 return ret;
                    ps_dec->u1_qp = 0;
 }
 else
 {
                    ret = ih264d_parse_imb_cavlc(
                                    ps_dec, ps_cur_mb_info, u1_num_mbs,
 (UWORD8)(u1_mb_type - u1_mb_threshold));
 if(ret != OK)
 return ret;
 }

                ps_cur_deblk_mb->u1_mb_type |= D_INTRA_MB;
 }
            uc_more_data_flag = MORE_RBSP_DATA(ps_bitstrm);
 }
        ps_cur_deblk_mb->u1_mb_qp = ps_dec->u1_qp;

 if(u1_mbaff)
 {
            ih264d_update_mbaff_left_nnz(ps_dec, ps_cur_mb_info);
 }
 /**************************************************************/
 /* Get next Macroblock address                                */
 /**************************************************************/
        i2_cur_mb_addr++;

        u1_num_mbs++;
        u1_num_mbsNby2++;
        ps_parse_mb_data++;

 /****************************************************************/
 /* Check for End Of Row and other flags that determine when to  */
 /* do DMA setup for N/2-Mb, Decode for N-Mb, and Transfer for   */
 /* N-Mb                                                         */
 /****************************************************************/
        u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;
        u1_end_of_row = (!u1_num_mbs_next) && (!(u1_mbaff && (u1_num_mbs & 0x01)));
        u1_slice_end = (!(uc_more_data_flag || i2_mb_skip_run));
        u1_tfr_n_mb = (u1_num_mbs == ps_dec->u1_recon_mb_grp) || u1_end_of_row
 || u1_slice_end;
        u1_decode_nmb = u1_tfr_n_mb || u1_slice_end;
        ps_cur_mb_info->u1_end_of_slice = u1_slice_end;

 /*u1_dma_nby2mb   = u1_decode_nmb ||
         (u1_num_mbsNby2 == ps_dec->u1_recon_mb_grp_pair);*/

 if(u1_decode_nmb)
 {
            ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx, u1_num_mbs);
            u1_num_mbsNby2 = 0;

 {
                ps_parse_mb_data = ps_dec->ps_parse_mb_data;
                ps_dec->ps_part = ps_dec->ps_parse_part_params;
 }
 }

 /*H264_DEC_DEBUG_PRINT("Pic: %d Mb_X=%d Mb_Y=%d",
         ps_slice->i4_poc >> ps_slice->u1_field_pic_flag,
         ps_dec->u2_mbx,ps_dec->u2_mby + (1 - ps_cur_mb_info->u1_topmb));
         H264_DEC_DEBUG_PRINT("u1_decode_nmb: %d", u1_decode_nmb);*/
 if(u1_decode_nmb)
 {



 if(ps_dec->u1_separate_parse)
 {
                ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,
                                     u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);
                ps_dec->ps_nmb_info +=  u1_num_mbs;
 }
 else
 {
                ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,
                                            u1_num_mbs_next, u1_tfr_n_mb,
                                            u1_end_of_row);
 }
            ps_dec->u2_total_mbs_coded += u1_num_mbs;
 if(u1_tfr_n_mb)
                u1_num_mbs = 0;
            u1_mb_idx = u1_num_mbs;
            ps_dec->u1_mb_idx = u1_num_mbs;

 }
 }

    ps_dec->u4_num_mbs_cur_nmb = 0;
    ps_dec->ps_cur_slice->u4_mbs_in_slice = i2_cur_mb_addr
 - (u2_first_mb_in_slice << u1_mbaff);


 return ret;
}

void ih264d_parse_end_of_stream(dec_struct_t * ps_dec)
{
    UNUSED(ps_dec);
 return;
}

WORD32 ih264d_mark_err_slice_skip(dec_struct_t * ps_dec,
WORD32 num_mb_skip,
UWORD8 u1_is_idr_slice,
UWORD16 u2_frame_num,
pocstruct_t *ps_cur_poc,
WORD32 prev_slice_err)
{
WORD32 i2_cur_mb_addr;
UWORD32 u1_num_mbs, u1_num_mbsNby2;
UWORD32 u1_mb_idx = ps_dec->u1_mb_idx;
UWORD32 i2_mb_skip_run;

UWORD32 u1_num_mbs_next, u1_end_of_row;
const UWORD32 i2_pic_wdin_mbs = ps_dec->u2_frm_wd_in_mbs;
UWORD32 u1_slice_end;
UWORD32 u1_tfr_n_mb;
UWORD32 u1_decode_nmb;
dec_bit_stream_t * const ps_bitstrm = ps_dec->ps_bitstrm;
dec_slice_params_t * ps_slice = ps_dec->ps_cur_slice;
UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;
deblk_mb_t *ps_cur_deblk_mb;
dec_mb_info_t *ps_cur_mb_info;
parse_pmbarams_t *ps_parse_mb_data;
UWORD32 u1_inter_mb_type;
UWORD32 u1_deblk_mb_type;
UWORD16 u2_total_mbs_coded;
UWORD32 u1_mbaff = ps_slice->u1_mbaff_frame_flag;
parse_part_params_t *ps_part_info;
WORD32 ret;


if(ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC)
{
ih264d_err_pic_dispbuf_mgr(ps_dec);
return 0;
}
ps_dec->ps_dpb_cmds->u1_long_term_reference_flag = 0;
if(prev_slice_err == 1)
{
/* first slice - missing/header corruption */
ps_dec->ps_cur_slice->u2_frame_num = u2_frame_num;


if(!ps_dec->u1_first_slice_in_stream)
{
ih264d_end_of_pic(ps_dec, u1_is_idr_slice,
ps_dec->ps_cur_slice->u2_frame_num);
ps_dec->s_cur_pic_poc.u2_frame_num =
ps_dec->ps_cur_slice->u2_frame_num;
}

{
WORD32 i, j, poc = 0;

ps_dec->ps_cur_slice->u2_first_mb_in_slice = 0;

ps_dec->pf_mvpred = ih264d_mvpred_nonmbaff;
ps_dec->p_form_mb_part_info = ih264d_form_mb_part_info_bp;
ps_dec->p_motion_compensate = ih264d_motion_compensate_bp;

if(ps_dec->ps_cur_pic != NULL)
poc = ps_dec->ps_cur_pic->i4_poc + 2;

j = 0;
for(i = 0; i < MAX_NUM_PIC_PARAMS; i++)
if(ps_dec->ps_pps[i].u1_is_valid == TRUE)
j = i;
{
//initialize slice params required by ih264d_start_of_pic to valid values
ps_dec->ps_cur_slice->u1_slice_type = P_SLICE;
ps_dec->ps_cur_slice->u1_nal_ref_idc = 1;
ps_dec->ps_cur_slice->u1_nal_unit_type = 1;
ret = ih264d_start_of_pic(ps_dec, poc, ps_cur_poc,
ps_dec->ps_cur_slice->u2_frame_num,
&ps_dec->ps_pps[j]);

if(ret != OK)
{
return ret;
}
}

ps_dec->ps_ref_pic_buf_lx[0][0]->u1_pic_buf_id = 0;

ps_dec->u4_output_present = 0;

{
ih264d_get_next_display_field(ps_dec,
ps_dec->ps_out_buffer,
&(ps_dec->s_disp_op));
/* If error code is non-zero then there is no buffer available for display,
hence avoid format conversion */

if(0 != ps_dec->s_disp_op.u4_error_code)
{
ps_dec->u4_fmt_conv_cur_row = ps_dec->s_disp_frame_info.u4_y_ht;
}
else
ps_dec->u4_output_present = 1;
}

if(ps_dec->u1_separate_parse == 1)
{
if(ps_dec->u4_dec_thread_created == 0)
{
ithread_create(ps_dec->pv_dec_thread_handle, NULL,
(void *)ih264d_decode_picture_thread,
(void *)ps_dec);

ps_dec->u4_dec_thread_created = 1;
}

if((ps_dec->u4_num_cores == 3) &&
((ps_dec->u4_app_disable_deblk_frm == 0) || ps_dec->i1_recon_in_thread3_flag)
&& (ps_dec->u4_bs_deblk_thread_created == 0))
{
ps_dec->u4_start_recon_deblk = 0;
ithread_create(ps_dec->pv_bs_deblk_thread_handle, NULL,
(void *)ih264d_recon_deblk_thread,
(void *)ps_dec);
ps_dec->u4_bs_deblk_thread_created = 1;

}
}
}
}
else
{
// Middle / last slice

dec_slice_struct_t *ps_parse_cur_slice;
ps_parse_cur_slice = ps_dec->ps_dec_slice_buf + ps_dec->u2_cur_slice_num;

if(ps_dec->u1_slice_header_done
&& ps_parse_cur_slice == ps_dec->ps_parse_cur_slice)
{
// Slice data corrupted
u1_num_mbs = ps_dec->u4_num_mbs_cur_nmb;

if(u1_num_mbs)
{
ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs - 1;
}
else
{
if(ps_dec->u1_separate_parse)
{
ps_cur_mb_info = ps_dec->ps_nmb_info - 1;
}
else
{
ps_cur_mb_info = ps_dec->ps_nmb_info
+ ps_dec->u4_num_mbs_prev_nmb - 1;
}
}

ps_dec->u2_mby = ps_cur_mb_info->u2_mby;
ps_dec->u2_mbx = ps_cur_mb_info->u2_mbx;

ps_dec->u1_mb_ngbr_availablity =
ps_cur_mb_info->u1_mb_ngbr_availablity;

// Going back 1 mb
ps_dec->pv_parse_tu_coeff_data = ps_dec->pv_prev_mb_parse_tu_coeff_data;
ps_dec->u2_cur_mb_addr--;
ps_dec->i4_submb_ofst -= SUB_BLK_SIZE;

if(u1_num_mbs)
{
// Parse/decode N-MB left unparsed
if (ps_dec->u1_pr_sl_type == P_SLICE
|| ps_dec->u1_pr_sl_type == B_SLICE)
{
ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx,    u1_num_mbs);
ps_dec->ps_part = ps_dec->ps_parse_part_params;
}

u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;
u1_end_of_row = (!u1_num_mbs_next)
&& (!(u1_mbaff && (u1_num_mbs & 0x01)));
u1_slice_end = 1;
u1_tfr_n_mb = 1;
ps_cur_mb_info->u1_end_of_slice = u1_slice_end;

if(ps_dec->u1_separate_parse)
{
ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,
u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);
ps_dec->ps_nmb_info += u1_num_mbs;
}
else
{
ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,
u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);
}
ps_dec->u2_total_mbs_coded += u1_num_mbs;
ps_dec->u1_mb_idx = 0;
ps_dec->u4_num_mbs_cur_nmb = 0;
}

if(ps_dec->u2_total_mbs_coded
>= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)
{
ps_dec->u1_pic_decode_done = 1;
return 0;
}

// Inserting new slice
ps_dec->u2_cur_slice_num++;
ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;
ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;
ps_dec->ps_parse_cur_slice++;

}
else
{
// Slice missing / header corrupted
ps_dec->ps_parse_cur_slice = ps_dec->ps_dec_slice_buf
+ ps_dec->u2_cur_slice_num;
}
}

/******************************************************/
/* Initializations to new slice                       */
/******************************************************/
{
WORD32 num_entries;
WORD32 size;
UWORD8 *pu1_buf;

num_entries = MAX_FRAMES;
if((1 >= ps_dec->ps_cur_sps->u1_num_ref_frames) &&
(0 == ps_dec->i4_display_delay))
{
num_entries = 1;
}
num_entries = ((2 * num_entries) + 1);
if(BASE_PROFILE_IDC != ps_dec->ps_cur_sps->u1_profile_idc)
{
num_entries *= 2;
}
size = num_entries * sizeof(void *);
size += PAD_MAP_IDX_POC * sizeof(void *);

pu1_buf = (UWORD8 *)ps_dec->pv_map_ref_idx_to_poc_buf;
pu1_buf += size * ps_dec->u2_cur_slice_num;
ps_dec->ps_parse_cur_slice->ppv_map_ref_idx_to_poc = (volatile void **)pu1_buf;
}

ps_dec->ps_cur_slice->u2_first_mb_in_slice = ps_dec->u2_total_mbs_coded << u1_mbaff;
ps_dec->ps_cur_slice->i1_slice_alpha_c0_offset = 0;
ps_dec->ps_cur_slice->i1_slice_beta_offset = 0;

if(ps_dec->ps_cur_slice->u1_field_pic_flag)
ps_dec->u2_prv_frame_num = ps_dec->ps_cur_slice->u2_frame_num;

ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice = ps_dec->u2_total_mbs_coded << u1_mbaff;
ps_dec->ps_parse_cur_slice->u2_log2Y_crwd =    ps_dec->ps_cur_slice->u2_log2Y_crwd;


if(ps_dec->u1_separate_parse)
{
ps_dec->ps_parse_cur_slice->pv_tu_coeff_data_start = ps_dec->pv_parse_tu_coeff_data;
}
else
{
ps_dec->pv_proc_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;
}

/******************************************************/
/* Initializations specific to P slice                */
/******************************************************/
u1_inter_mb_type = P_MB;
u1_deblk_mb_type = D_INTER_MB;

ps_dec->ps_cur_slice->u1_slice_type = P_SLICE;
ps_dec->ps_parse_cur_slice->slice_type = P_SLICE;
ps_dec->pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb;
ps_dec->ps_part = ps_dec->ps_parse_part_params;

/******************************************************/
/* Parsing / decoding the slice                       */
/******************************************************/
ps_dec->u1_slice_header_done = 2;
ps_dec->u1_qp = ps_slice->u1_slice_qp;
ih264d_update_qp(ps_dec, 0);
u1_mb_idx = ps_dec->u1_mb_idx;
ps_parse_mb_data = ps_dec->ps_parse_mb_data;
u1_num_mbs = u1_mb_idx;

u1_slice_end = 0;
u1_tfr_n_mb = 0;
u1_decode_nmb = 0;
u1_num_mbsNby2 = 0;
i2_cur_mb_addr = ps_dec->u2_total_mbs_coded;
i2_mb_skip_run = num_mb_skip;

while(!u1_slice_end)
{
UWORD8 u1_mb_type;

if(i2_cur_mb_addr > ps_dec->ps_cur_sps->u2_max_mb_addr)
break;

ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs;
ps_dec->u4_num_mbs_cur_nmb = u1_num_mbs;

ps_cur_mb_info->u1_Mux = 0;
ps_dec->u4_num_pmbair = (u1_num_mbs >> u1_mbaff);
ps_cur_deblk_mb = ps_dec->ps_deblk_mbn + u1_num_mbs;

ps_cur_mb_info->u1_end_of_slice = 0;

/* Storing Default partition info */
ps_parse_mb_data->u1_num_part = 1;
ps_parse_mb_data->u1_isI_mb = 0;

/**************************************************************/
/* Get the required information for decoding of MB            */
/**************************************************************/
/* mb_x, mb_y, neighbor availablity, */
if (u1_mbaff)
ih264d_get_mb_info_cavlc_mbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);
else
ih264d_get_mb_info_cavlc_nonmbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);

/* Set the deblocking parameters for this MB */
if(ps_dec->u4_app_disable_deblk_frm == 0)
{
ih264d_set_deblocking_parameters(ps_cur_deblk_mb, ps_slice,
ps_dec->u1_mb_ngbr_availablity,
ps_dec->u1_cur_mb_fld_dec_flag);
}

/* Set appropriate flags in ps_cur_mb_info and ps_dec */
ps_dec->i1_prev_mb_qp_delta = 0;
ps_dec->u1_sub_mb_num = 0;
ps_cur_mb_info->u1_mb_type = MB_SKIP;
ps_cur_mb_info->u1_mb_mc_mode = PRED_16x16;
ps_cur_mb_info->u1_cbp = 0;

/* Storing Skip partition info */
ps_part_info = ps_dec->ps_part;
ps_part_info->u1_is_direct = PART_DIRECT_16x16;
ps_part_info->u1_sub_mb_num = 0;
ps_dec->ps_part++;

/* Update Nnzs */
ih264d_update_nnz_for_skipmb(ps_dec, ps_cur_mb_info, CAVLC);

ps_cur_mb_info->ps_curmb->u1_mb_type = u1_inter_mb_type;
ps_cur_deblk_mb->u1_mb_type |= u1_deblk_mb_type;

i2_mb_skip_run--;

ps_cur_deblk_mb->u1_mb_qp = ps_dec->u1_qp;

if (u1_mbaff)
{
ih264d_update_mbaff_left_nnz(ps_dec, ps_cur_mb_info);
}

/**************************************************************/
/* Get next Macroblock address                                */
/**************************************************************/
i2_cur_mb_addr++;

u1_num_mbs++;
u1_num_mbsNby2++;
ps_parse_mb_data++;

/****************************************************************/
/* Check for End Of Row and other flags that determine when to  */
/* do DMA setup for N/2-Mb, Decode for N-Mb, and Transfer for   */
/* N-Mb                                                         */
/****************************************************************/
u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;
u1_end_of_row = (!u1_num_mbs_next) && (!(u1_mbaff && (u1_num_mbs & 0x01)));
u1_slice_end = !i2_mb_skip_run;
u1_tfr_n_mb = (u1_num_mbs == ps_dec->u1_recon_mb_grp) || u1_end_of_row
|| u1_slice_end;
u1_decode_nmb = u1_tfr_n_mb || u1_slice_end;
ps_cur_mb_info->u1_end_of_slice = u1_slice_end;

if(u1_decode_nmb)
{
ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx, u1_num_mbs);
u1_num_mbsNby2 = 0;

ps_parse_mb_data = ps_dec->ps_parse_mb_data;
ps_dec->ps_part = ps_dec->ps_parse_part_params;

if(ps_dec->u1_separate_parse)
{
ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,
u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);
ps_dec->ps_nmb_info +=  u1_num_mbs;
}
else
{
ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs, u1_num_mbs_next,
u1_tfr_n_mb, u1_end_of_row);
}
ps_dec->u2_total_mbs_coded += u1_num_mbs;
if(u1_tfr_n_mb)
u1_num_mbs = 0;
u1_mb_idx = u1_num_mbs;
ps_dec->u1_mb_idx = u1_num_mbs;
}
}

ps_dec->u4_num_mbs_cur_nmb = 0;
ps_dec->ps_cur_slice->u4_mbs_in_slice = i2_cur_mb_addr
- ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice;


H264_DEC_DEBUG_PRINT("Mbs in slice: %d\n", ps_dec->ps_cur_slice->u4_mbs_in_slice);

    ps_dec->u2_cur_slice_num++;

/* incremented here only if first slice is inserted */
if(ps_dec->u4_first_slice_in_pic != 0)
ps_dec->ps_parse_cur_slice++;

ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;
ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;

if(ps_dec->u2_total_mbs_coded
>= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)
{
ps_dec->u1_pic_decode_done = 1;
}

return 0;

}

WORD32 ih264d_parse_pmb_cabac(dec_struct_t * ps_dec,
 dec_mb_info_t * ps_cur_mb_info,
                              UWORD8 u1_mb_num,
                              UWORD8 u1_num_mbsNby2)
{
    UWORD32 u1_num_mb_part;
    UWORD32 uc_sub_mb;
 parse_pmbarams_t * ps_parse_mb_data = ps_dec->ps_parse_mb_data
 + u1_num_mbsNby2;
    WORD8 * pi1_ref_idx = ps_parse_mb_data->i1_ref_idx[0];
 const UWORD8 * pu1_num_mb_part = (const UWORD8 *)gau1_ih264d_num_mb_part;
 const UWORD32 u1_mb_type = ps_cur_mb_info->u1_mb_type;
    UWORD8 * pu1_col_info = ps_parse_mb_data->u1_col_info;
    UWORD32 u1_mb_mc_mode = u1_mb_type;
 ctxt_inc_mb_info_t * p_curr_ctxt = ps_dec->ps_curr_ctxt_mb_info;
 decoding_envirnoment_t * ps_cab_env = &ps_dec->s_cab_dec_env;
 dec_bit_stream_t * ps_bitstrm = ps_dec->ps_bitstrm;
    UWORD32 u4_sub_mb_pack = 0;
    WORD32 ret;

    UWORD8 u1_no_submb_part_size_lt8x8_flag = 1;
    ps_cur_mb_info->u1_tran_form8x8 = 0;
    ps_cur_mb_info->ps_curmb->u1_tran_form8x8 = 0;

    ps_cur_mb_info->u1_yuv_dc_block_flag = 0;

    p_curr_ctxt->u1_mb_type = CAB_P;
    ps_cur_mb_info->u1_mb_mc_mode = u1_mb_type;
    uc_sub_mb = ((u1_mb_type == PRED_8x8) | (u1_mb_type == PRED_8x8R0));

 /* Reading the subMB type */
 if(uc_sub_mb)
 {

        UWORD8 u1_colz = (PRED_8x8 << 6);
        u1_mb_mc_mode = 0;

 {
            UWORD8 u1_sub_mb_mode;
            u1_sub_mb_mode = ih264d_parse_submb_type_cabac(
 0, ps_cab_env, ps_bitstrm,
                            ps_dec->p_sub_mb_type_t);
 if(u1_sub_mb_mode > 3)
 return ERROR_SUB_MB_TYPE;

            u4_sub_mb_pack = (u4_sub_mb_pack << 8) | u1_sub_mb_mode;
 /* Storing collocated information */
 *pu1_col_info++ = u1_colz | ((UWORD8)(u1_sub_mb_mode << 4));
            COPYTHECONTEXT("sub_mb_type", u1_sub_mb_mode);
 /* check if Motion compensation is done below 8x8 */
 if(u1_sub_mb_mode != P_L0_8x8)
 {
                u1_no_submb_part_size_lt8x8_flag = 0;
 }
 }
 {
            UWORD8 u1_sub_mb_mode;
            u1_sub_mb_mode = ih264d_parse_submb_type_cabac(
 0, ps_cab_env, ps_bitstrm,
                            ps_dec->p_sub_mb_type_t);
 if(u1_sub_mb_mode > 3)
 return ERROR_SUB_MB_TYPE;

            u4_sub_mb_pack = (u4_sub_mb_pack << 8) | u1_sub_mb_mode;
 /* Storing collocated information */
 *pu1_col_info++ = u1_colz | ((UWORD8)(u1_sub_mb_mode << 4));
            COPYTHECONTEXT("sub_mb_type", u1_sub_mb_mode);
 /* check if Motion compensation is done below 8x8 */
 if(u1_sub_mb_mode != P_L0_8x8)
 {
                u1_no_submb_part_size_lt8x8_flag = 0;
 }
 }
 {
            UWORD8 u1_sub_mb_mode;
            u1_sub_mb_mode = ih264d_parse_submb_type_cabac(
 0, ps_cab_env, ps_bitstrm,
                            ps_dec->p_sub_mb_type_t);
 if(u1_sub_mb_mode > 3)
 return ERROR_SUB_MB_TYPE;

            u4_sub_mb_pack = (u4_sub_mb_pack << 8) | u1_sub_mb_mode;
 /* Storing collocated information */
 *pu1_col_info++ = u1_colz | ((UWORD8)(u1_sub_mb_mode << 4));
            COPYTHECONTEXT("sub_mb_type", u1_sub_mb_mode);
 /* check if Motion compensation is done below 8x8 */
 if(u1_sub_mb_mode != P_L0_8x8)
 {
                u1_no_submb_part_size_lt8x8_flag = 0;
 }
 }
 {
            UWORD8 u1_sub_mb_mode;
            u1_sub_mb_mode = ih264d_parse_submb_type_cabac(
 0, ps_cab_env, ps_bitstrm,
                            ps_dec->p_sub_mb_type_t);
 if(u1_sub_mb_mode > 3)
 return ERROR_SUB_MB_TYPE;

            u4_sub_mb_pack = (u4_sub_mb_pack << 8) | u1_sub_mb_mode;
 /* Storing collocated information */
 *pu1_col_info++ = u1_colz | ((UWORD8)(u1_sub_mb_mode << 4));
            COPYTHECONTEXT("sub_mb_type", u1_sub_mb_mode);
 /* check if Motion compensation is done below 8x8 */
 if(u1_sub_mb_mode != P_L0_8x8)
 {
                u1_no_submb_part_size_lt8x8_flag = 0;
 }
 }
        u1_num_mb_part = 4;
 }
 else
 {
        u1_num_mb_part = pu1_num_mb_part[u1_mb_type];
 /* Storing collocated Mb and SubMb mode information */
 *pu1_col_info++ = (u1_mb_type << 6);
 if(u1_mb_type)
 *pu1_col_info++ = (u1_mb_type << 6);
 }
 /* Decoding reference index 0: For simple profile the following   */
 /* conditions are always true (mb_field_decoding_flag == 0);      */
 /* (MbPartPredMode != PredL1)                                     */
 {
        WORD8 * pi1_top_ref_idx_ctx_inc_arr = p_curr_ctxt->i1_ref_idx;
        WORD8 * pi1_left_ref_idx_ctxt_inc = ps_dec->pi1_left_ref_idx_ctxt_inc;
        UWORD8 u1_mbaff = ps_dec->ps_cur_slice->u1_mbaff_frame_flag;
        UWORD8 uc_field = ps_cur_mb_info->u1_mb_field_decodingflag;
        UWORD8 uc_num_ref_idx_l0_active_minus1 =
 (ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[0]
 << (u1_mbaff & uc_field)) - 1;

 if((uc_num_ref_idx_l0_active_minus1 > 0) & (u1_mb_type != PRED_8x8R0))
 {
 /* force the routine to decode ref idx for each partition */
 *((UWORD32 *)pi1_ref_idx) = 0x01010101;
            ret = ih264d_parse_ref_idx_cabac(u1_num_mb_part, 0,
                                             uc_num_ref_idx_l0_active_minus1,
                                             u1_mb_mc_mode, pi1_ref_idx,
                                             pi1_left_ref_idx_ctxt_inc,
                                             pi1_top_ref_idx_ctx_inc_arr, ps_cab_env,
                                             ps_bitstrm, ps_dec->p_ref_idx_t);
 if(ret != OK)
 return ret;
 }
 else
 {
 /* When there exists only a single frame to predict from */
            pi1_left_ref_idx_ctxt_inc[0] = 0;
            pi1_left_ref_idx_ctxt_inc[1] = 0;
            pi1_top_ref_idx_ctx_inc_arr[0] = 0;
            pi1_top_ref_idx_ctx_inc_arr[1] = 0;
 *((UWORD32 *)pi1_ref_idx) = 0;
 }
 }

 {
        UWORD8 u1_p_idx, uc_i;
 parse_part_params_t * ps_part = ps_dec->ps_part;
        UWORD8 u1_sub_mb_mode, u1_num_subpart, u1_mb_part_width, u1_mb_part_height;
        UWORD8 u1_sub_mb_num;
 const UWORD8 * pu1_top_left_sub_mb_indx;
 mv_pred_t *ps_mv_start = ps_dec->ps_mv_cur + (u1_mb_num << 4);
        UWORD16 u2_sub_mb_num_pack = 0x028A;

 /* Loading the table pointers */
 const UWORD8 * pu1_mb_partw = (const UWORD8 *)gau1_ih264d_mb_partw;
 const UWORD8 * pu1_mb_parth = (const UWORD8 *)gau1_ih264d_mb_parth;
 const UWORD8 * pu1_sub_mb_indx_mod =
 (const UWORD8 *)(gau1_ih264d_submb_indx_mod)
 + (uc_sub_mb * 6);
 const UWORD8 * pu1_sub_mb_partw = (const UWORD8 *)gau1_ih264d_submb_partw;
 const UWORD8 * pu1_sub_mb_parth = (const UWORD8 *)gau1_ih264d_submb_parth;
 const UWORD8 * pu1_num_sub_mb_part =
 (const UWORD8 *)gau1_ih264d_num_submb_part;

 /*********************************************************/
 /* default initialisations for condition (uc_sub_mb == 0) */
 /* i.e. all are subpartitions of 8x8                     */
 /*********************************************************/
        u1_sub_mb_mode = 0;
        u1_num_subpart = 1;
        u1_mb_part_width = pu1_mb_partw[u1_mb_type];
        u1_mb_part_height = pu1_mb_parth[u1_mb_type];
        pu1_top_left_sub_mb_indx = pu1_sub_mb_indx_mod + (u1_mb_type << 1);
        u1_sub_mb_num = 0;

 /* Loop on number of partitions */
 for(uc_i = 0, u1_p_idx = 0; uc_i < u1_num_mb_part; uc_i++)
 {
            UWORD8 uc_j;
 if(uc_sub_mb)
 {
                u1_sub_mb_mode = u4_sub_mb_pack >> 24;
                u1_num_subpart = pu1_num_sub_mb_part[u1_sub_mb_mode];
                u1_mb_part_width = pu1_sub_mb_partw[u1_sub_mb_mode];
                u1_mb_part_height = pu1_sub_mb_parth[u1_sub_mb_mode];
                pu1_top_left_sub_mb_indx = pu1_sub_mb_indx_mod + (u1_sub_mb_mode << 1);
                u1_sub_mb_num = u2_sub_mb_num_pack >> 12;
                u4_sub_mb_pack <<= 8;
                u2_sub_mb_num_pack <<= 4;
 }
 /* Loop on Number of sub-partitions */
 for(uc_j = 0; uc_j < u1_num_subpart; uc_j++, pu1_top_left_sub_mb_indx++)
 {
 mv_pred_t * ps_mv;

                u1_sub_mb_num += *pu1_top_left_sub_mb_indx;
                ps_mv = ps_mv_start + u1_sub_mb_num;

 /* Storing Info for partitions */
                ps_part->u1_is_direct = PART_NOT_DIRECT;
                ps_part->u1_sub_mb_num = u1_sub_mb_num;
                ps_part->u1_partheight = u1_mb_part_height;
                ps_part->u1_partwidth = u1_mb_part_width;

 /* Increment partition Index */
                u1_p_idx++;
                ps_part++;

                ih264d_get_mvd_cabac(u1_sub_mb_num, 0, u1_mb_part_width,
                                     u1_mb_part_height, 1, ps_dec, ps_mv);
 }
 }
        ps_parse_mb_data->u1_num_part = u1_p_idx;
        ps_dec->ps_part = ps_part;
 }
 {
        UWORD8 u1_cbp;

 /* Read the Coded block pattern */
        u1_cbp = (WORD8)ih264d_parse_ctx_cbp_cabac(ps_dec);
        COPYTHECONTEXT("coded_block_pattern", u1_cbp);
        ps_cur_mb_info->u1_cbp = u1_cbp;
        p_curr_ctxt->u1_cbp = u1_cbp;
        p_curr_ctxt->u1_intra_chroma_pred_mode = 0;
        p_curr_ctxt->u1_yuv_dc_csbp &= 0xFE;
        ps_dec->pu1_left_yuv_dc_csbp[0] &= 0x6;

 if(u1_cbp > 47)
 return ERROR_CBP;

        ps_cur_mb_info->u1_tran_form8x8 = 0;
        ps_cur_mb_info->ps_curmb->u1_tran_form8x8 = 0;

 /* Read the transform8x8 u4_flag if present */
 if((ps_dec->s_high_profile.u1_transform8x8_present) && (u1_cbp & 0xf)
 && u1_no_submb_part_size_lt8x8_flag)
 {
            ps_cur_mb_info->u1_tran_form8x8 = ih264d_parse_transform8x8flag_cabac(
                            ps_dec, ps_cur_mb_info);
            COPYTHECONTEXT("transform_size_8x8_flag", ps_cur_mb_info->u1_tran_form8x8);
            p_curr_ctxt->u1_transform8x8_ctxt = ps_cur_mb_info->u1_tran_form8x8;
            ps_cur_mb_info->ps_curmb->u1_tran_form8x8 = ps_cur_mb_info->u1_tran_form8x8;

 }
 else
 {
            p_curr_ctxt->u1_transform8x8_ctxt = 0;
 }

 /* Read mb_qp_delta */
 if(u1_cbp)
 {
            WORD8 c_temp;
            ret = ih264d_parse_mb_qp_delta_cabac(ps_dec, &c_temp);
 if(ret != OK)
 return ret;
            COPYTHECONTEXT("mb_qp_delta", c_temp);
 if(c_temp != 0)
 {
                ret = ih264d_update_qp(ps_dec, c_temp);
 if(ret != OK)
 return ret;
 }
 }
 else
            ps_dec->i1_prev_mb_qp_delta = 0;



        ih264d_parse_residual4x4_cabac(ps_dec, ps_cur_mb_info, 0);
 if(EXCEED_OFFSET(ps_dec->ps_bitstrm))
 return ERROR_EOB_TERMINATE_T;
 }
 return OK;
}

WORD32 ih264d_parse_sps(dec_struct_t *ps_dec, dec_bit_stream_t *ps_bitstrm)
{
    UWORD8 i;
 dec_seq_params_t *ps_seq = NULL;
    UWORD8 u1_profile_idc, u1_level_idc, u1_seq_parameter_set_id;
    UWORD16 i2_max_frm_num;
    UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
    UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;
    UWORD8 u1_frm, uc_constraint_set0_flag, uc_constraint_set1_flag;

    UWORD32 u4_temp;
    WORD32 pic_height_in_map_units_minus1 = 0;
    UWORD32 u2_pic_wd = 0;
    UWORD32 u2_pic_ht = 0;
    UWORD32 u2_frm_wd_y = 0;
    UWORD32 u2_frm_ht_y = 0;
    UWORD32 u2_frm_wd_uv = 0;
    UWORD32 u2_frm_ht_uv = 0;
    UWORD32 u2_crop_offset_y = 0;
    UWORD32 u2_crop_offset_uv = 0;
    WORD32 ret;

 /* High profile related syntax element */
    WORD32 i4_i;
 /* G050 */
    UWORD8 u1_frame_cropping_flag, u1_frame_cropping_rect_left_ofst,
                    u1_frame_cropping_rect_right_ofst,
                    u1_frame_cropping_rect_top_ofst,
                    u1_frame_cropping_rect_bottom_ofst;
 /* G050 */
 /*--------------------------------------------------------------------*/
 /* Decode seq_parameter_set_id and profile and level values           */
 /*--------------------------------------------------------------------*/
    SWITCHONTRACE;
    u1_profile_idc = ih264d_get_bits_h264(ps_bitstrm, 8);
    COPYTHECONTEXT("SPS: profile_idc",u1_profile_idc);

 /* G050 */
    uc_constraint_set0_flag = ih264d_get_bit_h264(ps_bitstrm);
    uc_constraint_set1_flag = ih264d_get_bit_h264(ps_bitstrm);
    ih264d_get_bit_h264(ps_bitstrm);

 /*****************************************************/
 /* Read 5 bits for uc_constraint_set3_flag (1 bit)   */
 /* and reserved_zero_4bits (4 bits) - Sushant        */
 /*****************************************************/
    ih264d_get_bits_h264(ps_bitstrm, 5);
 /* G050 */

 /* Check whether particular profile is suported or not */
 /* Check whether particular profile is suported or not */
 if((u1_profile_idc != MAIN_PROFILE_IDC) &&

 (u1_profile_idc != BASE_PROFILE_IDC) &&

 (u1_profile_idc != HIGH_PROFILE_IDC)

 )
 {

 if((uc_constraint_set1_flag != 1) && (uc_constraint_set0_flag != 1))
 {
 if(NULL != ps_dec)
 {
                UWORD32 i4_error_code;
                i4_error_code = ERROR_FEATURE_UNAVAIL;
 return i4_error_code;
 }
 else
 {
 return (ERROR_FEATURE_UNAVAIL);
 }
 }
 }

    u1_level_idc = ih264d_get_bits_h264(ps_bitstrm, 8);



    COPYTHECONTEXT("SPS: u4_level_idc",u1_level_idc);

    u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 if(u4_temp & MASK_ERR_SEQ_SET_ID)
 return ERROR_INV_SPS_PPS_T;
    u1_seq_parameter_set_id = u4_temp;
    COPYTHECONTEXT("SPS: seq_parameter_set_id",
                    u1_seq_parameter_set_id);

 /*--------------------------------------------------------------------*/
 /* Find an seq param entry in seqparam array of decStruct             */
 /*--------------------------------------------------------------------*/

    ps_seq = ps_dec->pv_scratch_sps_pps;
 *ps_seq = ps_dec->ps_sps[u1_seq_parameter_set_id];

 if(NULL == ps_dec->ps_cur_sps)
        ps_dec->ps_cur_sps = ps_seq;

    ps_seq->u1_profile_idc = u1_profile_idc;
    ps_seq->u1_level_idc = u1_level_idc;
    ps_seq->u1_seq_parameter_set_id = u1_seq_parameter_set_id;

 /*******************************************************************/
 /* Initializations for high profile - Sushant                      */
 /*******************************************************************/
    ps_seq->i4_chroma_format_idc = 1;
    ps_seq->i4_bit_depth_luma_minus8 = 0;
    ps_seq->i4_bit_depth_chroma_minus8 = 0;
    ps_seq->i4_qpprime_y_zero_transform_bypass_flag = 0;
    ps_seq->i4_seq_scaling_matrix_present_flag = 0;
 if(u1_profile_idc == HIGH_PROFILE_IDC)
 {

 /* reading chroma_format_idc   */
        ps_seq->i4_chroma_format_idc = ih264d_uev(pu4_bitstrm_ofst,
                                                  pu4_bitstrm_buf);

 /* Monochrome is not supported */
 if(ps_seq->i4_chroma_format_idc != 1)
 {
 return ERROR_INV_SPS_PPS_T;
 }

 /* reading bit_depth_luma_minus8   */
        ps_seq->i4_bit_depth_luma_minus8 = ih264d_uev(pu4_bitstrm_ofst,
                                                      pu4_bitstrm_buf);

 if(ps_seq->i4_bit_depth_luma_minus8 != 0)
 {
 return ERROR_INV_SPS_PPS_T;
 }

 /* reading bit_depth_chroma_minus8   */
        ps_seq->i4_bit_depth_chroma_minus8 = ih264d_uev(pu4_bitstrm_ofst,
                                                        pu4_bitstrm_buf);

 if(ps_seq->i4_bit_depth_chroma_minus8 != 0)
 {
 return ERROR_INV_SPS_PPS_T;
 }

 /* reading qpprime_y_zero_transform_bypass_flag   */
        ps_seq->i4_qpprime_y_zero_transform_bypass_flag =
 (WORD32)ih264d_get_bit_h264(ps_bitstrm);

 if(ps_seq->i4_qpprime_y_zero_transform_bypass_flag != 0)
 {
 return ERROR_INV_SPS_PPS_T;
 }

 /* reading seq_scaling_matrix_present_flag   */
        ps_seq->i4_seq_scaling_matrix_present_flag =
 (WORD32)ih264d_get_bit_h264(ps_bitstrm);

 if(ps_seq->i4_seq_scaling_matrix_present_flag)
 {
 for(i4_i = 0; i4_i < 8; i4_i++)
 {
                ps_seq->u1_seq_scaling_list_present_flag[i4_i] =
                                ih264d_get_bit_h264(ps_bitstrm);

 /* initialize u1_use_default_scaling_matrix_flag[i4_i] to zero */
 /* before calling scaling list                             */
                ps_seq->u1_use_default_scaling_matrix_flag[i4_i] = 0;

 if(ps_seq->u1_seq_scaling_list_present_flag[i4_i])
 {
 if(i4_i < 6)
 {
                        ih264d_scaling_list(
                                        ps_seq->i2_scalinglist4x4[i4_i],
 16,
 &ps_seq->u1_use_default_scaling_matrix_flag[i4_i],
                                        ps_bitstrm);
 }
 else
 {
                        ih264d_scaling_list(
                                        ps_seq->i2_scalinglist8x8[i4_i - 6],
 64,
 &ps_seq->u1_use_default_scaling_matrix_flag[i4_i],
                                        ps_bitstrm);
 }
 }
 }
 }
 }
 /*--------------------------------------------------------------------*/
 /* Decode MaxFrameNum                                                 */
 /*--------------------------------------------------------------------*/
    u4_temp = 4 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 if(u4_temp > MAX_BITS_IN_FRAME_NUM)
 {
 return ERROR_INV_SPS_PPS_T;
 }
    ps_seq->u1_bits_in_frm_num = u4_temp;
    COPYTHECONTEXT("SPS: log2_max_frame_num_minus4",
 (ps_seq->u1_bits_in_frm_num - 4));

    i2_max_frm_num = (1 << (ps_seq->u1_bits_in_frm_num));
    ps_seq->u2_u4_max_pic_num_minus1 = i2_max_frm_num - 1;
 /*--------------------------------------------------------------------*/
 /* Decode picture order count and related values                      */
 /*--------------------------------------------------------------------*/
    u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);

 if(u4_temp > MAX_PIC_ORDER_CNT_TYPE)
 {
 return ERROR_INV_POC_TYPE_T;
 }
    ps_seq->u1_pic_order_cnt_type = u4_temp;
    COPYTHECONTEXT("SPS: pic_order_cnt_type",ps_seq->u1_pic_order_cnt_type);

    ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle = 1;
 if(ps_seq->u1_pic_order_cnt_type == 0)
 {
        u4_temp = 4 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 if(u4_temp > MAX_BITS_IN_POC_LSB)
 {
 return ERROR_INV_SPS_PPS_T;
 }
        ps_seq->u1_log2_max_pic_order_cnt_lsb_minus = u4_temp;
        ps_seq->i4_max_pic_order_cntLsb = (1 << u4_temp);
        COPYTHECONTEXT("SPS: log2_max_pic_order_cnt_lsb_minus4",(u4_temp - 4));
 }
 else if(ps_seq->u1_pic_order_cnt_type == 1)
 {
        ps_seq->u1_delta_pic_order_always_zero_flag = ih264d_get_bit_h264(
                        ps_bitstrm);
        COPYTHECONTEXT("SPS: delta_pic_order_always_zero_flag",
                        ps_seq->u1_delta_pic_order_always_zero_flag);

        ps_seq->i4_ofst_for_non_ref_pic = ih264d_sev(pu4_bitstrm_ofst,
                                                     pu4_bitstrm_buf);
        COPYTHECONTEXT("SPS: offset_for_non_ref_pic",
                        ps_seq->i4_ofst_for_non_ref_pic);

        ps_seq->i4_ofst_for_top_to_bottom_field = ih264d_sev(
                        pu4_bitstrm_ofst, pu4_bitstrm_buf);
        COPYTHECONTEXT("SPS: offset_for_top_to_bottom_field",
                        ps_seq->i4_ofst_for_top_to_bottom_field);

        u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 if(u4_temp > 255)
 return ERROR_INV_SPS_PPS_T;
        ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle = u4_temp;
        COPYTHECONTEXT("SPS: num_ref_frames_in_pic_order_cnt_cycle",
                        ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle);

 for(i = 0; i < ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle; i++)
 {
            ps_seq->i4_ofst_for_ref_frame[i] = ih264d_sev(
                            pu4_bitstrm_ofst, pu4_bitstrm_buf);
            COPYTHECONTEXT("SPS: offset_for_ref_frame",
                            ps_seq->i4_ofst_for_ref_frame[i]);
 }
 }

    u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);

 if((u4_temp > H264_MAX_REF_PICS))
 {
 return ERROR_NUM_REF;
 }
    ps_seq->u1_num_ref_frames = u4_temp;
    COPYTHECONTEXT("SPS: num_ref_frames",ps_seq->u1_num_ref_frames);

    ps_seq->u1_gaps_in_frame_num_value_allowed_flag = ih264d_get_bit_h264(
                    ps_bitstrm);
    COPYTHECONTEXT("SPS: gaps_in_frame_num_value_allowed_flag",
                    ps_seq->u1_gaps_in_frame_num_value_allowed_flag);

 /*--------------------------------------------------------------------*/
 /* Decode FrameWidth and FrameHeight and related values               */
 /*--------------------------------------------------------------------*/
    ps_seq->u2_frm_wd_in_mbs = 1
 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
    COPYTHECONTEXT("SPS: pic_width_in_mbs_minus1",
                    ps_seq->u2_frm_wd_in_mbs - 1);
    u2_pic_wd = (ps_seq->u2_frm_wd_in_mbs << 4);

    pic_height_in_map_units_minus1 = ih264d_uev(pu4_bitstrm_ofst,
                                                pu4_bitstrm_buf);
    ps_seq->u2_frm_ht_in_mbs = 1 + pic_height_in_map_units_minus1;

    u2_pic_ht = (ps_seq->u2_frm_ht_in_mbs << 4);

 /*--------------------------------------------------------------------*/
 /* Get the value of MaxMbAddress and Number of bits needed for it     */
 /*--------------------------------------------------------------------*/
    ps_seq->u2_max_mb_addr = (ps_seq->u2_frm_wd_in_mbs
 * ps_seq->u2_frm_ht_in_mbs) - 1;

    ps_seq->u2_total_num_of_mbs = ps_seq->u2_max_mb_addr + 1;

    ps_seq->u1_level_idc = ih264d_correct_level_idc(
                    u1_level_idc, ps_seq->u2_total_num_of_mbs);

    u1_frm = ih264d_get_bit_h264(ps_bitstrm);
    ps_seq->u1_frame_mbs_only_flag = u1_frm;

    COPYTHECONTEXT("SPS: frame_mbs_only_flag", u1_frm);

 if(!u1_frm)
 {
        u2_pic_ht <<= 1;
        ps_seq->u1_mb_aff_flag = ih264d_get_bit_h264(ps_bitstrm);
        COPYTHECONTEXT("SPS: mb_adaptive_frame_field_flag",
                        ps_seq->u1_mb_aff_flag);

 }
 else
        ps_seq->u1_mb_aff_flag = 0;

    ps_seq->u1_direct_8x8_inference_flag = ih264d_get_bit_h264(ps_bitstrm);

    COPYTHECONTEXT("SPS: direct_8x8_inference_flag",
                    ps_seq->u1_direct_8x8_inference_flag);

 /* G050 */
    u1_frame_cropping_flag = ih264d_get_bit_h264(ps_bitstrm);
    COPYTHECONTEXT("SPS: frame_cropping_flag",u1_frame_cropping_flag);

 if(u1_frame_cropping_flag)
 {
        u1_frame_cropping_rect_left_ofst = ih264d_uev(pu4_bitstrm_ofst,
                                                      pu4_bitstrm_buf);
        COPYTHECONTEXT("SPS: frame_cropping_rect_left_offset",
                        u1_frame_cropping_rect_left_ofst);
        u1_frame_cropping_rect_right_ofst = ih264d_uev(pu4_bitstrm_ofst,
                                                       pu4_bitstrm_buf);
        COPYTHECONTEXT("SPS: frame_cropping_rect_right_offset",
                        u1_frame_cropping_rect_right_ofst);
        u1_frame_cropping_rect_top_ofst = ih264d_uev(pu4_bitstrm_ofst,
                                                     pu4_bitstrm_buf);
        COPYTHECONTEXT("SPS: frame_cropping_rect_top_offset",
                        u1_frame_cropping_rect_top_ofst);
        u1_frame_cropping_rect_bottom_ofst = ih264d_uev(pu4_bitstrm_ofst,
                                                        pu4_bitstrm_buf);
        COPYTHECONTEXT("SPS: frame_cropping_rect_bottom_offset",
                        u1_frame_cropping_rect_bottom_ofst);
 }
 /* G050 */

    ps_seq->u1_vui_parameters_present_flag = ih264d_get_bit_h264(ps_bitstrm);
    COPYTHECONTEXT("SPS: vui_parameters_present_flag",
                    ps_seq->u1_vui_parameters_present_flag);

    u2_frm_wd_y = u2_pic_wd + (UWORD8)(PAD_LEN_Y_H << 1);
 if(1 == ps_dec->u4_share_disp_buf)
 {
 if(ps_dec->u4_app_disp_width > u2_frm_wd_y)
            u2_frm_wd_y = ps_dec->u4_app_disp_width;
 }

    u2_frm_ht_y = u2_pic_ht + (UWORD8)(PAD_LEN_Y_V << 2);
    u2_frm_wd_uv = u2_pic_wd + (UWORD8)(PAD_LEN_UV_H << 2);
    u2_frm_wd_uv = MAX(u2_frm_wd_uv, u2_frm_wd_y);

    u2_frm_ht_uv = (u2_pic_ht >> 1) + (UWORD8)(PAD_LEN_UV_V << 2);
    u2_frm_ht_uv = MAX(u2_frm_ht_uv, (u2_frm_ht_y >> 1));


 /* Calculate display picture width, height and start u4_ofst from YUV420 */
 /* pictute buffers as per cropping information parsed above             */
 {
        UWORD16 u2_rgt_ofst = 0;
        UWORD16 u2_lft_ofst = 0;
        UWORD16 u2_top_ofst = 0;
        UWORD16 u2_btm_ofst = 0;
        UWORD8 u1_frm_mbs_flag;
        UWORD8 u1_vert_mult_factor;
        WORD32 i4_cropped_ht, i4_cropped_wd;

 if(u1_frame_cropping_flag)
 {
 /* Calculate right and left u4_ofst for cropped picture           */
            u2_rgt_ofst = u1_frame_cropping_rect_right_ofst << 1;
            u2_lft_ofst = u1_frame_cropping_rect_left_ofst << 1;

 /* Know frame MBs only u4_flag                                      */
            u1_frm_mbs_flag = (1 == ps_seq->u1_frame_mbs_only_flag);

 /* Simplify the vertical u4_ofst calculation from field/frame     */
            u1_vert_mult_factor = (2 - u1_frm_mbs_flag);

 /* Calculate bottom and top u4_ofst for cropped  picture          */
            u2_btm_ofst = (u1_frame_cropping_rect_bottom_ofst
 << u1_vert_mult_factor);
            u2_top_ofst = (u1_frame_cropping_rect_top_ofst
 << u1_vert_mult_factor);
 }

 /* Calculate u4_ofst from start of YUV 420 picture buffer to start of*/
 /* cropped picture buffer                                           */
        u2_crop_offset_y = (u2_frm_wd_y * u2_top_ofst) + (u2_lft_ofst);
        u2_crop_offset_uv = (u2_frm_wd_uv * (u2_top_ofst >> 1))
 + (u2_lft_ofst >> 1) * YUV420SP_FACTOR;
 /* Calculate the display picture width and height based on crop      */
 /* information                                                       */
        i4_cropped_ht = u2_pic_ht - (u2_btm_ofst + u2_top_ofst);
        i4_cropped_wd = u2_pic_wd - (u2_rgt_ofst + u2_lft_ofst);

 if((i4_cropped_ht < MB_SIZE) || (i4_cropped_wd < MB_SIZE))
 {
 return ERROR_INV_SPS_PPS_T;
 }

 if((3 == ps_dec->i4_header_decoded) && (ps_dec->u2_pic_wd != u2_pic_wd))
 {
            ps_dec->u1_res_changed = 1;
 return IVD_RES_CHANGED;
 }
 if((3 == ps_dec->i4_header_decoded) && (ps_dec->u2_pic_ht != u2_pic_ht))
 {
            ps_dec->u1_res_changed = 1;
 return IVD_RES_CHANGED;
 }

 /* Check for unsupported resolutions */
 if((u2_pic_wd > H264_MAX_FRAME_WIDTH) || (u2_pic_ht > H264_MAX_FRAME_HEIGHT))
 {
 return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED;
 }

        ps_dec->u2_disp_height = i4_cropped_ht;

        ps_dec->u2_disp_width = i4_cropped_wd;

 }

 if(1 == ps_seq->u1_vui_parameters_present_flag)
 {
        ret = ih264d_parse_vui_parametres(&ps_seq->s_vui, ps_bitstrm);
 if(ret != OK)
 return ret;
 }

    ps_dec->u2_pic_wd = u2_pic_wd;
    ps_dec->u2_pic_ht = u2_pic_ht;

 /* Determining the Width and Height of Frame from that of Picture */
    ps_dec->u2_frm_wd_y = u2_frm_wd_y;
    ps_dec->u2_frm_ht_y = u2_frm_ht_y;

    ps_dec->u2_frm_wd_uv = u2_frm_wd_uv;
    ps_dec->u2_frm_ht_uv = u2_frm_ht_uv;
    ps_dec->s_pad_mgr.u1_pad_len_y_v = (UWORD8)(PAD_LEN_Y_V << (1 - u1_frm));
    ps_dec->s_pad_mgr.u1_pad_len_cr_v = (UWORD8)(PAD_LEN_UV_V << (1 - u1_frm));

    ps_dec->u2_frm_wd_in_mbs = ps_seq->u2_frm_wd_in_mbs;
    ps_dec->u2_frm_ht_in_mbs = ps_seq->u2_frm_ht_in_mbs;

    ps_dec->u2_crop_offset_y = u2_crop_offset_y;
    ps_dec->u2_crop_offset_uv = u2_crop_offset_uv;

 /* In case bitstream read has exceeded the filled size, then
       return an error */
 if(ps_bitstrm->u4_ofst > ps_bitstrm->u4_max_ofst)
 {
 return ERROR_INV_SPS_PPS_T;
 }
    ps_seq->u1_is_valid = TRUE;
    ps_dec->ps_sps[u1_seq_parameter_set_id] = *ps_seq;

 return OK;
}

WORD32 ih264d_start_of_pic(dec_struct_t *ps_dec,
WORD32 i4_poc,
pocstruct_t *ps_temp_poc,
UWORD16 u2_frame_num,
dec_pic_params_t *ps_pps)
{
pocstruct_t *ps_prev_poc = &ps_dec->s_cur_pic_poc;
pocstruct_t *ps_cur_poc = ps_temp_poc;

pic_buffer_t *pic_buf;

ivd_video_decode_op_t * ps_dec_output =
(ivd_video_decode_op_t *)ps_dec->pv_dec_out;
dec_slice_params_t *ps_cur_slice = ps_dec->ps_cur_slice;
dec_seq_params_t *ps_seq = ps_pps->ps_sps;
UWORD8 u1_bottom_field_flag = ps_cur_slice->u1_bottom_field_flag;
UWORD8 u1_field_pic_flag = ps_cur_slice->u1_field_pic_flag;
/* high profile related declarations */
high_profile_tools_t s_high_profile;
WORD32 ret;

H264_MUTEX_LOCK(&ps_dec->process_disp_mutex);

ps_prev_poc->i4_pic_order_cnt_lsb = ps_cur_poc->i4_pic_order_cnt_lsb;
ps_prev_poc->i4_pic_order_cnt_msb = ps_cur_poc->i4_pic_order_cnt_msb;
ps_prev_poc->i4_delta_pic_order_cnt_bottom =
ps_cur_poc->i4_delta_pic_order_cnt_bottom;
ps_prev_poc->i4_delta_pic_order_cnt[0] =
ps_cur_poc->i4_delta_pic_order_cnt[0];
ps_prev_poc->i4_delta_pic_order_cnt[1] =
ps_cur_poc->i4_delta_pic_order_cnt[1];
ps_prev_poc->u1_bot_field = ps_dec->ps_cur_slice->u1_bottom_field_flag;
ps_prev_poc->i4_prev_frame_num_ofst = ps_cur_poc->i4_prev_frame_num_ofst;
ps_prev_poc->u2_frame_num = u2_frame_num;
ps_dec->i1_prev_mb_qp_delta = 0;
ps_dec->i1_next_ctxt_idx = 0;


ps_dec->u4_nmb_deblk = 0;
if(ps_dec->u4_num_cores == 1)
ps_dec->u4_nmb_deblk = 1;



if(ps_seq->u1_mb_aff_flag == 1)
{
ps_dec->u4_nmb_deblk = 0;
if(ps_dec->u4_num_cores > 2)
ps_dec->u4_num_cores = 2;
}

ps_dec->u4_use_intrapred_line_copy = 0;



if (ps_seq->u1_mb_aff_flag == 0)
{
ps_dec->u4_use_intrapred_line_copy = 1;
}

ps_dec->u4_app_disable_deblk_frm = 0;
/* If degrade is enabled, set the degrade flags appropriately */
if(ps_dec->i4_degrade_type && ps_dec->i4_degrade_pics)
{
WORD32 degrade_pic;
ps_dec->i4_degrade_pic_cnt++;
degrade_pic = 0;

/* If degrade is to be done in all frames, then do not check further */
switch(ps_dec->i4_degrade_pics)
{
case 4:
{
degrade_pic = 1;
break;
}
case 3:
{
if(ps_cur_slice->u1_slice_type != I_SLICE)
degrade_pic = 1;

break;
}
case 2:
{

/* If pic count hits non-degrade interval or it is an islice, then do not degrade */
if((ps_cur_slice->u1_slice_type != I_SLICE)
&& (ps_dec->i4_degrade_pic_cnt
!= ps_dec->i4_nondegrade_interval))
degrade_pic = 1;

break;
}
case 1:
{
/* Check if the current picture is non-ref */
if(0 == ps_cur_slice->u1_nal_ref_idc)
{
degrade_pic = 1;
}
break;
}

}
if(degrade_pic)
{
if(ps_dec->i4_degrade_type & 0x2)
ps_dec->u4_app_disable_deblk_frm = 1;

/* MC degrading is done only for non-ref pictures */
if(0 == ps_cur_slice->u1_nal_ref_idc)
{
if(ps_dec->i4_degrade_type & 0x4)
ps_dec->i4_mv_frac_mask = 0;

if(ps_dec->i4_degrade_type & 0x8)
ps_dec->i4_mv_frac_mask = 0;
}
}
else
ps_dec->i4_degrade_pic_cnt = 0;
}

{
dec_err_status_t * ps_err = ps_dec->ps_dec_err_status;
if(ps_dec->u1_sl_typ_5_9
&& ((ps_cur_slice->u1_slice_type == I_SLICE)
|| (ps_cur_slice->u1_slice_type
== SI_SLICE)))
ps_err->u1_cur_pic_type = PIC_TYPE_I;
else
ps_err->u1_cur_pic_type = PIC_TYPE_UNKNOWN;

if(ps_err->u1_pic_aud_i == PIC_TYPE_I)
{
ps_err->u1_cur_pic_type = PIC_TYPE_I;
ps_err->u1_pic_aud_i = PIC_TYPE_UNKNOWN;
}

if(ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL)
{
if(ps_err->u1_err_flag)
ih264d_reset_ref_bufs(ps_dec->ps_dpb_mgr);
ps_err->u1_err_flag = ACCEPT_ALL_PICS;
}
}

if(ps_dec->u1_init_dec_flag && ps_dec->s_prev_seq_params.u1_eoseq_pending)
{
/* Reset the decoder picture buffers */
WORD32 j;
for(j = 0; j < MAX_DISP_BUFS_NEW; j++)
{

ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,
j,
BUF_MGR_REF);
ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,
ps_dec->au1_pic_buf_id_mv_buf_id_map[j],
BUF_MGR_REF);
ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,
j,
BUF_MGR_IO);
}

/* reset the decoder structure parameters related to buffer handling */
ps_dec->u1_second_field = 0;
ps_dec->i4_cur_display_seq = 0;

/********************************************************************/
/* indicate in the decoder output i4_status that some frames are being */
/* dropped, so that it resets timestamp and wait for a new sequence */
/********************************************************************/

ps_dec->s_prev_seq_params.u1_eoseq_pending = 0;
}
ret = ih264d_init_pic(ps_dec, u2_frame_num, i4_poc, ps_pps);
if(ret != OK)
return ret;

ps_dec->pv_parse_tu_coeff_data = ps_dec->pv_pic_tu_coeff_data;
ps_dec->pv_proc_tu_coeff_data  = ps_dec->pv_pic_tu_coeff_data;
ps_dec->ps_nmb_info = ps_dec->ps_frm_mb_info;
if(ps_dec->u1_separate_parse)
{
UWORD16 pic_wd;
UWORD16 pic_ht;
UWORD32 num_mbs;

pic_wd = ps_dec->u2_pic_wd;
pic_ht = ps_dec->u2_pic_ht;
num_mbs = (pic_wd * pic_ht) >> 8;

if(ps_dec->pu1_dec_mb_map)
{
memset((void *)ps_dec->pu1_dec_mb_map, 0, num_mbs);
}

if(ps_dec->pu1_recon_mb_map)
{

memset((void *)ps_dec->pu1_recon_mb_map, 0, num_mbs);
}

if(ps_dec->pu2_slice_num_map)
{
memset((void *)ps_dec->pu2_slice_num_map, 0,
(num_mbs * sizeof(UWORD16)));
}

}


ps_dec->ps_parse_cur_slice = &(ps_dec->ps_dec_slice_buf[0]);
ps_dec->ps_decode_cur_slice = &(ps_dec->ps_dec_slice_buf[0]);
ps_dec->ps_computebs_cur_slice = &(ps_dec->ps_dec_slice_buf[0]);

/* Initialize all the HP toolsets to zero */
ps_dec->s_high_profile.u1_scaling_present = 0;
ps_dec->s_high_profile.u1_transform8x8_present = 0;

/* Get Next Free Picture */
if(1 == ps_dec->u4_share_disp_buf)
{
UWORD32 i;
/* Free any buffer that is in the queue to be freed */
for(i = 0; i < MAX_DISP_BUFS_NEW; i++)
{
if(0 == ps_dec->u4_disp_buf_to_be_freed[i])
continue;
ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr, i,
BUF_MGR_IO);
ps_dec->u4_disp_buf_to_be_freed[i] = 0;
ps_dec->u4_disp_buf_mapping[i] = 0;

}
}
if(!(u1_field_pic_flag && 0 != ps_dec->u1_top_bottom_decoded)) //ps_dec->u1_second_field))
{
pic_buffer_t *ps_cur_pic;
WORD32 cur_pic_buf_id, cur_mv_buf_id;
col_mv_buf_t *ps_col_mv;
while(1)
{
ps_cur_pic = (pic_buffer_t *)ih264_buf_mgr_get_next_free(
(buf_mgr_t *)ps_dec->pv_pic_buf_mgr,
&cur_pic_buf_id);
if(ps_cur_pic == NULL)
{
ps_dec->i4_error_code = ERROR_UNAVAIL_PICBUF_T;
return ERROR_UNAVAIL_PICBUF_T;
}
if(0 == ps_dec->u4_disp_buf_mapping[cur_pic_buf_id])
{
break;
}

}
ps_col_mv = (col_mv_buf_t *)ih264_buf_mgr_get_next_free((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,
&cur_mv_buf_id);
if(ps_col_mv == NULL)
{
ps_dec->i4_error_code = ERROR_UNAVAIL_MVBUF_T;
return ERROR_UNAVAIL_MVBUF_T;
}

ps_dec->ps_cur_pic = ps_cur_pic;
ps_dec->u1_pic_buf_id = cur_pic_buf_id;
ps_cur_pic->u4_ts = ps_dec->u4_ts;


ps_cur_pic->u1_mv_buf_id = cur_mv_buf_id;
ps_dec->au1_pic_buf_id_mv_buf_id_map[cur_pic_buf_id] = cur_mv_buf_id;

ps_cur_pic->pu1_col_zero_flag = (UWORD8 *)ps_col_mv->pv_col_zero_flag;
ps_cur_pic->ps_mv = (mv_pred_t *)ps_col_mv->pv_mv;
ps_dec->au1_pic_buf_ref_flag[cur_pic_buf_id] = 0;
if(ps_dec->u1_first_slice_in_stream)
{
/*make first entry of list0 point to cur pic,so that if first Islice is in error, ref pic struct will have valid entries*/
ps_dec->ps_ref_pic_buf_lx[0] = ps_dec->ps_dpb_mgr->ps_init_dpb[0];
*(ps_dec->ps_dpb_mgr->ps_init_dpb[0][0]) = *ps_cur_pic;
}

if(!ps_dec->ps_cur_pic)
{
WORD32 j;
H264_DEC_DEBUG_PRINT("------- Display Buffers Reset --------\n");
for(j = 0; j < MAX_DISP_BUFS_NEW; j++)
{

ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,
j,
BUF_MGR_REF);
ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,
ps_dec->au1_pic_buf_id_mv_buf_id_map[j],
BUF_MGR_REF);
ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,
j,
BUF_MGR_IO);
}

ps_dec->i4_cur_display_seq = 0;
ps_dec->i4_prev_max_display_seq = 0;
ps_dec->i4_max_poc = 0;

ps_cur_pic = (pic_buffer_t *)ih264_buf_mgr_get_next_free(
(buf_mgr_t *)ps_dec->pv_pic_buf_mgr,
&cur_pic_buf_id);
if(ps_cur_pic == NULL)
{
ps_dec->i4_error_code = ERROR_UNAVAIL_PICBUF_T;
return ERROR_UNAVAIL_PICBUF_T;
}

ps_col_mv = (col_mv_buf_t *)ih264_buf_mgr_get_next_free((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,
&cur_mv_buf_id);
if(ps_col_mv == NULL)
{
ps_dec->i4_error_code = ERROR_UNAVAIL_MVBUF_T;
return ERROR_UNAVAIL_MVBUF_T;
}

ps_dec->ps_cur_pic = ps_cur_pic;
ps_dec->u1_pic_buf_id = cur_pic_buf_id;
ps_cur_pic->u4_ts = ps_dec->u4_ts;
ps_dec->apv_buf_id_pic_buf_map[cur_pic_buf_id] = (void *)ps_cur_pic;

ps_cur_pic->u1_mv_buf_id = cur_mv_buf_id;
ps_dec->au1_pic_buf_id_mv_buf_id_map[cur_pic_buf_id] = cur_mv_buf_id;

ps_cur_pic->pu1_col_zero_flag = (UWORD8 *)ps_col_mv->pv_col_zero_flag;
ps_cur_pic->ps_mv = (mv_pred_t *)ps_col_mv->pv_mv;
ps_dec->au1_pic_buf_ref_flag[cur_pic_buf_id] = 0;

}

ps_dec->ps_cur_pic->u1_picturetype = u1_field_pic_flag;
ps_dec->ps_cur_pic->u4_pack_slc_typ = SKIP_NONE;
H264_DEC_DEBUG_PRINT("got a buffer\n");
}
else
{
H264_DEC_DEBUG_PRINT("did not get a buffer\n");
}

ps_dec->u4_pic_buf_got = 1;

ps_dec->ps_cur_pic->i4_poc = i4_poc;
ps_dec->ps_cur_pic->i4_frame_num = u2_frame_num;
ps_dec->ps_cur_pic->i4_pic_num = u2_frame_num;
ps_dec->ps_cur_pic->i4_top_field_order_cnt = ps_pps->i4_top_field_order_cnt;
ps_dec->ps_cur_pic->i4_bottom_field_order_cnt =
ps_pps->i4_bottom_field_order_cnt;
ps_dec->ps_cur_pic->i4_avg_poc = ps_pps->i4_avg_poc;
ps_dec->ps_cur_pic->u4_time_stamp = ps_dec->u4_pts;

ps_dec->s_cur_pic = *(ps_dec->ps_cur_pic);
if(u1_field_pic_flag && u1_bottom_field_flag)
{
WORD32 i4_temp_poc;
WORD32 i4_top_field_order_poc, i4_bot_field_order_poc;
/* Point to odd lines, since it's bottom field */
ps_dec->s_cur_pic.pu1_buf1 += ps_dec->s_cur_pic.u2_frm_wd_y;
ps_dec->s_cur_pic.pu1_buf2 += ps_dec->s_cur_pic.u2_frm_wd_uv;
ps_dec->s_cur_pic.pu1_buf3 += ps_dec->s_cur_pic.u2_frm_wd_uv;
ps_dec->s_cur_pic.ps_mv +=
((ps_dec->u2_pic_ht * ps_dec->u2_pic_wd) >> 5);
ps_dec->s_cur_pic.pu1_col_zero_flag += ((ps_dec->u2_pic_ht
* ps_dec->u2_pic_wd) >> 5);
ps_dec->ps_cur_pic->u1_picturetype |= BOT_FLD;
i4_top_field_order_poc = ps_dec->ps_cur_pic->i4_top_field_order_cnt;
i4_bot_field_order_poc = ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;
i4_temp_poc = MIN(i4_top_field_order_poc,
i4_bot_field_order_poc);
ps_dec->ps_cur_pic->i4_avg_poc = i4_temp_poc;
}

ps_cur_slice->u1_mbaff_frame_flag = ps_seq->u1_mb_aff_flag
&& (!u1_field_pic_flag);

ps_dec->ps_cur_pic->u1_picturetype |= (ps_cur_slice->u1_mbaff_frame_flag
<< 2);

ps_dec->ps_cur_mb_row = ps_dec->ps_nbr_mb_row; //[0];
//Increment by 2 ,so that left mb (mbaff decrements by 2)  will always be valid
ps_dec->ps_cur_mb_row += 2;
ps_dec->ps_top_mb_row = ps_dec->ps_nbr_mb_row;
ps_dec->ps_top_mb_row += ((ps_dec->u2_frm_wd_in_mbs + 2) << (1 - ps_dec->ps_cur_sps->u1_frame_mbs_only_flag));
//Increment by 2 ,so that left mb (mbaff decrements by 2)  will always be valid
ps_dec->ps_top_mb_row += 2;

/* CHANGED CODE */
ps_dec->ps_mv_cur = ps_dec->s_cur_pic.ps_mv;
ps_dec->ps_mv_top = ps_dec->ps_mv_top_p[0];
/* CHANGED CODE */
ps_dec->u1_mv_top_p = 0;
ps_dec->u1_mb_idx = 0;
/* CHANGED CODE */
ps_dec->ps_mv_left = ps_dec->s_cur_pic.ps_mv;
ps_dec->u2_total_mbs_coded = 0;
ps_dec->i4_submb_ofst = -(SUB_BLK_SIZE);
ps_dec->u4_pred_info_idx = 0;
ps_dec->u4_pred_info_pkd_idx = 0;
ps_dec->u4_dma_buf_idx = 0;
ps_dec->ps_mv = ps_dec->s_cur_pic.ps_mv;
ps_dec->ps_mv_bank_cur = ps_dec->s_cur_pic.ps_mv;
ps_dec->pu1_col_zero_flag = ps_dec->s_cur_pic.pu1_col_zero_flag;
ps_dec->ps_part = ps_dec->ps_parse_part_params;
ps_dec->i2_prev_slice_mbx = -1;
ps_dec->i2_prev_slice_mby = 0;
ps_dec->u2_mv_2mb[0] = 0;

ps_dec->u2_mv_2mb[1] = 0;
ps_dec->u1_last_pic_not_decoded = 0;

    ps_dec->u2_cur_slice_num = 0;
ps_dec->u2_cur_slice_num_dec_thread = 0;
ps_dec->u2_cur_slice_num_bs = 0;
ps_dec->u4_intra_pred_line_ofst = 0;
ps_dec->pu1_cur_y_intra_pred_line = ps_dec->pu1_y_intra_pred_line;
ps_dec->pu1_cur_u_intra_pred_line = ps_dec->pu1_u_intra_pred_line;
ps_dec->pu1_cur_v_intra_pred_line = ps_dec->pu1_v_intra_pred_line;

ps_dec->pu1_cur_y_intra_pred_line_base = ps_dec->pu1_y_intra_pred_line;
ps_dec->pu1_cur_u_intra_pred_line_base = ps_dec->pu1_u_intra_pred_line;
ps_dec->pu1_cur_v_intra_pred_line_base = ps_dec->pu1_v_intra_pred_line;





ps_dec->pu1_prev_y_intra_pred_line = ps_dec->pu1_y_intra_pred_line
+ (ps_dec->u2_frm_wd_in_mbs * MB_SIZE);

ps_dec->pu1_prev_u_intra_pred_line = ps_dec->pu1_u_intra_pred_line
+ ps_dec->u2_frm_wd_in_mbs * BLK8x8SIZE * YUV420SP_FACTOR;
ps_dec->pu1_prev_v_intra_pred_line = ps_dec->pu1_v_intra_pred_line
+ ps_dec->u2_frm_wd_in_mbs * BLK8x8SIZE;

ps_dec->ps_deblk_mbn = ps_dec->ps_deblk_pic;
/* Initialize The Function Pointer Depending Upon the Entropy and MbAff Flag */
{
if(ps_cur_slice->u1_mbaff_frame_flag)
{
ps_dec->pf_compute_bs = ih264d_compute_bs_mbaff;
ps_dec->pf_mvpred = ih264d_mvpred_mbaff;
}
else
{
ps_dec->pf_compute_bs = ih264d_compute_bs_non_mbaff;
ps_dec->u1_cur_mb_fld_dec_flag = ps_cur_slice->u1_field_pic_flag;
}
}
/* Set up the Parameter for DMA transfer */
{
UWORD8 u1_field_pic_flag = ps_dec->ps_cur_slice->u1_field_pic_flag;

UWORD8 u1_mbaff = ps_cur_slice->u1_mbaff_frame_flag;

UWORD8 uc_lastmbs = (((ps_dec->u2_pic_wd) >> 4)
% (ps_dec->u1_recon_mb_grp >> u1_mbaff));
UWORD16 ui16_lastmbs_widthY =
(uc_lastmbs ? (uc_lastmbs << 4) : ((ps_dec->u1_recon_mb_grp
>> u1_mbaff) << 4));
UWORD16 ui16_lastmbs_widthUV =
uc_lastmbs ? (uc_lastmbs << 3) : ((ps_dec->u1_recon_mb_grp
>> u1_mbaff) << 3);

ps_dec->s_tran_addrecon.pu1_dest_y = ps_dec->s_cur_pic.pu1_buf1;
ps_dec->s_tran_addrecon.pu1_dest_u = ps_dec->s_cur_pic.pu1_buf2;
ps_dec->s_tran_addrecon.pu1_dest_v = ps_dec->s_cur_pic.pu1_buf3;

ps_dec->s_tran_addrecon.u2_frm_wd_y = ps_dec->u2_frm_wd_y
<< u1_field_pic_flag;
ps_dec->s_tran_addrecon.u2_frm_wd_uv = ps_dec->u2_frm_wd_uv
<< u1_field_pic_flag;

if(u1_field_pic_flag)
{
ui16_lastmbs_widthY += ps_dec->u2_frm_wd_y;
ui16_lastmbs_widthUV += ps_dec->u2_frm_wd_uv;
}

/* Normal Increment of Pointer */
ps_dec->s_tran_addrecon.u4_inc_y[0] = ((ps_dec->u1_recon_mb_grp << 4)
>> u1_mbaff);
ps_dec->s_tran_addrecon.u4_inc_uv[0] = ((ps_dec->u1_recon_mb_grp << 4)
>> u1_mbaff);

/* End of Row Increment */
ps_dec->s_tran_addrecon.u4_inc_y[1] = (ui16_lastmbs_widthY
+ (PAD_LEN_Y_H << 1)
+ ps_dec->s_tran_addrecon.u2_frm_wd_y
* ((15 << u1_mbaff) + u1_mbaff));
ps_dec->s_tran_addrecon.u4_inc_uv[1] = (ui16_lastmbs_widthUV
+ (PAD_LEN_UV_H << 2)
+ ps_dec->s_tran_addrecon.u2_frm_wd_uv
* ((15 << u1_mbaff) + u1_mbaff));

/* Assign picture numbers to each frame/field  */
/* only once per picture.                      */
ih264d_assign_pic_num(ps_dec);
ps_dec->s_tran_addrecon.u2_mv_top_left_inc = (ps_dec->u1_recon_mb_grp
<< 2) - 1 - (u1_mbaff << 2);
ps_dec->s_tran_addrecon.u2_mv_left_inc = ((ps_dec->u1_recon_mb_grp
>> u1_mbaff) - 1) << (4 + u1_mbaff);
}
/**********************************************************************/
/* High profile related initialization at pictrue level               */
/**********************************************************************/
if(ps_seq->u1_profile_idc == HIGH_PROFILE_IDC)
{
if((ps_seq->i4_seq_scaling_matrix_present_flag)
|| (ps_pps->i4_pic_scaling_matrix_present_flag))
{
ih264d_form_scaling_matrix_picture(ps_seq, ps_pps, ps_dec);
ps_dec->s_high_profile.u1_scaling_present = 1;
}
else
{
ih264d_form_default_scaling_matrix(ps_dec);
}

if(ps_pps->i4_transform_8x8_mode_flag)
{
ps_dec->s_high_profile.u1_transform8x8_present = 1;
}
}
else
{
ih264d_form_default_scaling_matrix(ps_dec);
}

/* required while reading the transform_size_8x8 u4_flag */
ps_dec->s_high_profile.u1_direct_8x8_inference_flag =
ps_seq->u1_direct_8x8_inference_flag;
ps_dec->s_high_profile.s_cavlc_ctxt = ps_dec->s_cavlc_ctxt;

ps_dec->i1_recon_in_thread3_flag = 1;
ps_dec->ps_frame_buf_ip_recon = &ps_dec->s_tran_addrecon;
if(ps_dec->u1_separate_parse)
{
memcpy(&ps_dec->s_tran_addrecon_parse, &ps_dec->s_tran_addrecon,
sizeof(tfr_ctxt_t));
if(ps_dec->u4_num_cores >= 3 && ps_dec->i1_recon_in_thread3_flag)
{
memcpy(&ps_dec->s_tran_iprecon, &ps_dec->s_tran_addrecon,
sizeof(tfr_ctxt_t));
ps_dec->ps_frame_buf_ip_recon = &ps_dec->s_tran_iprecon;
}
}


ih264d_init_deblk_tfr_ctxt(ps_dec,&(ps_dec->s_pad_mgr), &(ps_dec->s_tran_addrecon),
ps_dec->u2_frm_wd_in_mbs, 0);

ps_dec->ps_cur_deblk_mb = ps_dec->ps_deblk_pic;
ps_dec->u4_cur_deblk_mb_num = 0;

ps_dec->u4_deblk_mb_x = 0;
ps_dec->u4_deblk_mb_y = 0;
ps_dec->pu4_wt_ofsts = ps_dec->pu4_wts_ofsts_mat;

H264_MUTEX_UNLOCK(&ps_dec->process_disp_mutex);
return OK;
}

WORD32 ih264d_parse_pslice(dec_struct_t *ps_dec, UWORD16 u2_first_mb_in_slice)
{
 dec_pic_params_t * ps_pps = ps_dec->ps_cur_pps;
 dec_slice_params_t * ps_cur_slice = ps_dec->ps_cur_slice;
 dec_bit_stream_t *ps_bitstrm = ps_dec->ps_bitstrm;
    UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
    UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;
    UWORD8 u1_mbaff = ps_dec->ps_cur_slice->u1_mbaff_frame_flag; //ps_dec->ps_cur_sps->u1_mb_aff_flag;
    UWORD8 u1_field_pic_flag = ps_cur_slice->u1_field_pic_flag;

    UWORD32 u4_temp;
    WORD32 i_temp;
    WORD32 ret;

 /*--------------------------------------------------------------------*/
 /* Read remaining contents of the slice header                        */
 /*--------------------------------------------------------------------*/
 {
        WORD8 *pi1_buf;
        WORD16 *pi2_mv = ps_dec->s_default_mv_pred.i2_mv;
        WORD32 *pi4_mv = (WORD32*)pi2_mv;
        WORD16 *pi16_refFrame;

        pi1_buf = ps_dec->s_default_mv_pred.i1_ref_frame;
        pi16_refFrame = (WORD16*)pi1_buf;
 *pi4_mv = 0;
 *(pi4_mv + 1) = 0;
 *pi16_refFrame = OUT_OF_RANGE_REF;
        ps_dec->s_default_mv_pred.u1_col_ref_pic_idx = (UWORD8)-1;
        ps_dec->s_default_mv_pred.u1_pic_type = (UWORD8)-1;
 }

    ps_cur_slice->u1_num_ref_idx_active_override_flag = ih264d_get_bit_h264(
                    ps_bitstrm);

    COPYTHECONTEXT("SH: num_ref_idx_override_flag",
                    ps_cur_slice->u1_num_ref_idx_active_override_flag);

    u4_temp = ps_dec->ps_cur_pps->u1_num_ref_idx_lx_active[0];
 if(ps_cur_slice->u1_num_ref_idx_active_override_flag)
 {
        u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf) + 1;
 }

 {



        UWORD8 u1_max_ref_idx = MAX_FRAMES << u1_field_pic_flag;
 if(u4_temp > u1_max_ref_idx)
 {
 return ERROR_NUM_REF;
 }
        ps_cur_slice->u1_num_ref_idx_lx_active[0] = u4_temp;
        COPYTHECONTEXT("SH: num_ref_idx_l0_active_minus1",
                        ps_cur_slice->u1_num_ref_idx_lx_active[0] - 1);

 }

 {
        UWORD8 uc_refIdxReFlagL0 = ih264d_get_bit_h264(ps_bitstrm);
        COPYTHECONTEXT("SH: ref_pic_list_reordering_flag_l0",uc_refIdxReFlagL0);

 /* Initialize the Reference list once in Picture if the slice type    */
 /* of first slice is between 5 to 9 defined in table 7.3 of standard  */
 /* If picture contains both P & B slices then Initialize the Reference*/
 /* List only when it switches from P to B and B to P                     */
 {
            UWORD8 init_idx_flg = (ps_dec->u1_pr_sl_type
 != ps_dec->ps_cur_slice->u1_slice_type);
 if(ps_dec->u1_first_pb_nal_in_pic
 || (init_idx_flg & !ps_dec->u1_sl_typ_5_9)
 || ps_dec->u1_num_ref_idx_lx_active_prev
 != ps_cur_slice->u1_num_ref_idx_lx_active[0])
 {
                ih264d_init_ref_idx_lx_p(ps_dec);
 }
 if(ps_dec->u1_first_pb_nal_in_pic & ps_dec->u1_sl_typ_5_9)
                ps_dec->u1_first_pb_nal_in_pic = 0;
 }
 /* Store the value for future slices in the same picture */
        ps_dec->u1_num_ref_idx_lx_active_prev =
                        ps_cur_slice->u1_num_ref_idx_lx_active[0];

 /* Modified temporarily */
 if(uc_refIdxReFlagL0)
 {
            WORD8 ret;
            ps_dec->ps_ref_pic_buf_lx[0] = ps_dec->ps_dpb_mgr->ps_mod_dpb[0];
            ret = ih264d_ref_idx_reordering(ps_dec, 0);
 if(ret == -1)
 return ERROR_REFIDX_ORDER_T;
            ps_dec->ps_ref_pic_buf_lx[0] = ps_dec->ps_dpb_mgr->ps_mod_dpb[0];
 }
 else
            ps_dec->ps_ref_pic_buf_lx[0] =
                            ps_dec->ps_dpb_mgr->ps_init_dpb[0];
 }
 /* Create refIdx to POC mapping */
 {
 void **pui_map_ref_idx_to_poc_lx0, **pui_map_ref_idx_to_poc_lx1;
        WORD8 idx;
 struct pic_buffer_t *ps_pic;

        pui_map_ref_idx_to_poc_lx0 = ps_dec->ppv_map_ref_idx_to_poc + FRM_LIST_L0;
        pui_map_ref_idx_to_poc_lx0[0] = 0; //For ref_idx = -1
        pui_map_ref_idx_to_poc_lx0++;
 for(idx = 0; idx < ps_cur_slice->u1_num_ref_idx_lx_active[0]; idx++)
 {
            ps_pic = ps_dec->ps_ref_pic_buf_lx[0][idx];
            pui_map_ref_idx_to_poc_lx0[idx] = (ps_pic->pu1_buf1);
 }

 /* Bug Fix Deblocking */
        pui_map_ref_idx_to_poc_lx1 = ps_dec->ppv_map_ref_idx_to_poc + FRM_LIST_L1;
        pui_map_ref_idx_to_poc_lx1[0] = 0;

 if(u1_mbaff)
 {
 void **ppv_map_ref_idx_to_poc_lx_t, **ppv_map_ref_idx_to_poc_lx_b;
 void **ppv_map_ref_idx_to_poc_lx_t1, **ppv_map_ref_idx_to_poc_lx_b1;
 ppv_map_ref_idx_to_poc_lx_t = ps_dec->ppv_map_ref_idx_to_poc
 + TOP_LIST_FLD_L0;
            ppv_map_ref_idx_to_poc_lx_b = ps_dec->ppv_map_ref_idx_to_poc
 + BOT_LIST_FLD_L0;

 ppv_map_ref_idx_to_poc_lx_t[0] = 0; //  For ref_idx = -1
 ppv_map_ref_idx_to_poc_lx_t++;
            ppv_map_ref_idx_to_poc_lx_b[0] = 0; // For ref_idx = -1
            ppv_map_ref_idx_to_poc_lx_b++;

            idx = 0;
 for(idx = 0; idx < ps_cur_slice->u1_num_ref_idx_lx_active[0]; idx++)
 {
                ps_pic = ps_dec->ps_ref_pic_buf_lx[0][idx];
 ppv_map_ref_idx_to_poc_lx_t[0] = (ps_pic->pu1_buf1);
                ppv_map_ref_idx_to_poc_lx_b[1] = (ps_pic->pu1_buf1);

                ppv_map_ref_idx_to_poc_lx_b[0] = (ps_pic->pu1_buf1) + 1;
 ppv_map_ref_idx_to_poc_lx_t[1] = (ps_pic->pu1_buf1) + 1;

 ppv_map_ref_idx_to_poc_lx_t += 2;
                ppv_map_ref_idx_to_poc_lx_b += 2;
 }
            ppv_map_ref_idx_to_poc_lx_t1 = ps_dec->ppv_map_ref_idx_to_poc
 + TOP_LIST_FLD_L1;
            ppv_map_ref_idx_to_poc_lx_t1[0] = 0;
            ppv_map_ref_idx_to_poc_lx_b1 = ps_dec->ppv_map_ref_idx_to_poc
 + BOT_LIST_FLD_L1;
            ppv_map_ref_idx_to_poc_lx_b1[0] = 0;

 }

 if(ps_dec->u4_num_cores >= 3)
 {
            WORD32 num_entries;
            WORD32 size;

            num_entries = MAX_FRAMES;
 if((1 >= ps_dec->ps_cur_sps->u1_num_ref_frames) &&
 (0 == ps_dec->i4_display_delay))
 {
                num_entries = 1;
 }
            num_entries = ((2 * num_entries) + 1);
 if(BASE_PROFILE_IDC != ps_dec->ps_cur_sps->u1_profile_idc)
 {
                num_entries *= 2;
 }

            size = num_entries * sizeof(void *);
            size += PAD_MAP_IDX_POC * sizeof(void *);

            memcpy((void *)ps_dec->ps_parse_cur_slice->ppv_map_ref_idx_to_poc,
                   ps_dec->ppv_map_ref_idx_to_poc,
                   size);
 }


 }
 if(ps_pps->u1_wted_pred_flag)
 {
        ret = ih264d_parse_pred_weight_table(ps_cur_slice, ps_bitstrm);
 if(ret != OK)
 return ret;
        ih264d_form_pred_weight_matrix(ps_dec);
        ps_dec->pu4_wt_ofsts = ps_dec->pu4_wts_ofsts_mat;
 }
 else
 {
        ps_dec->ps_cur_slice->u2_log2Y_crwd = 0;
        ps_dec->pu4_wt_ofsts = ps_dec->pu4_wts_ofsts_mat;
 }

    ps_dec->ps_parse_cur_slice->u2_log2Y_crwd =
                    ps_dec->ps_cur_slice->u2_log2Y_crwd;

 if(u1_mbaff && (u1_field_pic_flag == 0))
 {
        ih264d_convert_frm_mbaff_list(ps_dec);
 }

 /* G050 */
 if(ps_cur_slice->u1_nal_ref_idc != 0)
 {
 if(!ps_dec->ps_dpb_cmds->u1_dpb_commands_read)
            ps_dec->u4_bitoffset = ih264d_read_mmco_commands(ps_dec);
 else
            ps_bitstrm->u4_ofst += ps_dec->u4_bitoffset;

 }
 /* G050 */

 if(ps_pps->u1_entropy_coding_mode == CABAC)
 {
        u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);

 if(u4_temp > MAX_CABAC_INIT_IDC)
 {
 return ERROR_INV_SLICE_HDR_T;
 }
        ps_cur_slice->u1_cabac_init_idc = u4_temp;
        COPYTHECONTEXT("SH: cabac_init_idc",ps_cur_slice->u1_cabac_init_idc);
 }

 /* Read slice_qp_delta */
    i_temp = ps_pps->u1_pic_init_qp
 + ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 if((i_temp < 0) || (i_temp > 51))
 {
 return ERROR_INV_RANGE_QP_T;
 }
    ps_cur_slice->u1_slice_qp = i_temp;
    COPYTHECONTEXT("SH: slice_qp_delta",
 (WORD8)(ps_cur_slice->u1_slice_qp - ps_pps->u1_pic_init_qp));

 if(ps_pps->u1_deblocking_filter_parameters_present_flag == 1)
 {
        u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 if(u4_temp > SLICE_BOUNDARY_DBLK_DISABLED)
 {
 return ERROR_INV_SLICE_HDR_T;
 }

        COPYTHECONTEXT("SH: disable_deblocking_filter_idc", u4_temp);
        ps_cur_slice->u1_disable_dblk_filter_idc = u4_temp;
 if(u4_temp != 1)
 {
            i_temp = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf)
 << 1;
 if((MIN_DBLK_FIL_OFF > i_temp) || (i_temp > MAX_DBLK_FIL_OFF))
 {
 return ERROR_INV_SLICE_HDR_T;
 }
            ps_cur_slice->i1_slice_alpha_c0_offset = i_temp;
            COPYTHECONTEXT("SH: slice_alpha_c0_offset_div2",
                            ps_cur_slice->i1_slice_alpha_c0_offset >> 1);

            i_temp = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf)
 << 1;
 if((MIN_DBLK_FIL_OFF > i_temp) || (i_temp > MAX_DBLK_FIL_OFF))
 {
 return ERROR_INV_SLICE_HDR_T;
 }
            ps_cur_slice->i1_slice_beta_offset = i_temp;
            COPYTHECONTEXT("SH: slice_beta_offset_div2",
                            ps_cur_slice->i1_slice_beta_offset >> 1);
 }
 else
 {
            ps_cur_slice->i1_slice_alpha_c0_offset = 0;
            ps_cur_slice->i1_slice_beta_offset = 0;
 }
 }
 else
 {
        ps_cur_slice->u1_disable_dblk_filter_idc = 0;
        ps_cur_slice->i1_slice_alpha_c0_offset = 0;
        ps_cur_slice->i1_slice_beta_offset = 0;
 }

    ps_dec->u1_slice_header_done = 2;

 if(ps_pps->u1_entropy_coding_mode)
 {
        SWITCHOFFTRACE; SWITCHONTRACECABAC;
        ps_dec->pf_parse_inter_slice = ih264d_parse_inter_slice_data_cabac;
        ps_dec->pf_parse_inter_mb = ih264d_parse_pmb_cabac;
        ih264d_init_cabac_contexts(P_SLICE, ps_dec);

 if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag)
            ps_dec->pf_get_mb_info = ih264d_get_mb_info_cabac_mbaff;
 else
            ps_dec->pf_get_mb_info = ih264d_get_mb_info_cabac_nonmbaff;
 }
 else
 {
        SWITCHONTRACE; SWITCHOFFTRACECABAC;
        ps_dec->pf_parse_inter_slice = ih264d_parse_inter_slice_data_cavlc;
        ps_dec->pf_parse_inter_mb = ih264d_parse_pmb_cavlc;
 if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag)
 {
            ps_dec->pf_get_mb_info = ih264d_get_mb_info_cavlc_mbaff;
 }
 else
            ps_dec->pf_get_mb_info = ih264d_get_mb_info_cavlc_nonmbaff;
 }

    ps_dec->u1_B = 0;
    ps_dec->pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb;
    ret = ps_dec->pf_parse_inter_slice(ps_dec, ps_cur_slice, u2_first_mb_in_slice);
 if(ret != OK)
 return ret;
 return OK;
}

WORD32 ih264d_parse_pmb_cavlc(dec_struct_t * ps_dec,
 dec_mb_info_t * ps_cur_mb_info,
                              UWORD8 u1_mb_num,
                              UWORD8 u1_num_mbsNby2)
{
    UWORD32 u1_num_mb_part;
    UWORD32 uc_sub_mb;
 dec_bit_stream_t * const ps_bitstrm = ps_dec->ps_bitstrm;
    UWORD32 * const pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
    UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;

 parse_pmbarams_t * ps_parse_mb_data = ps_dec->ps_parse_mb_data
 + u1_num_mbsNby2;
    WORD8 * pi1_ref_idx = ps_parse_mb_data->i1_ref_idx[0];
 const UWORD8 u1_mbaff = ps_dec->ps_cur_slice->u1_mbaff_frame_flag;
 const UWORD8 * pu1_num_mb_part = (const UWORD8 *)gau1_ih264d_num_mb_part;
    UWORD8 * pu1_col_info = ps_parse_mb_data->u1_col_info;

    UWORD32 u1_mb_type = ps_cur_mb_info->u1_mb_type;
    UWORD32 u4_sum_mb_mode_pack = 0;
    WORD32 ret;

    UWORD8 u1_no_submb_part_size_lt8x8_flag = 1;
    ps_cur_mb_info->u1_tran_form8x8 = 0;
    ps_cur_mb_info->ps_curmb->u1_tran_form8x8 = 0;

    ps_cur_mb_info->u1_yuv_dc_block_flag = 0;

    ps_cur_mb_info->u1_mb_mc_mode = u1_mb_type;
    uc_sub_mb = ((u1_mb_type == PRED_8x8) | (u1_mb_type == PRED_8x8R0));

 /* Reading the subMB type */
 if(uc_sub_mb)
 {
        WORD32 i;
        UWORD8 u1_colz = (PRED_8x8 << 6);

 for(i = 0; i < 4; i++)
 {
            UWORD32 ui_sub_mb_mode;

            UWORD32 u4_bitstream_offset = *pu4_bitstrm_ofst;
            UWORD32 u4_word, u4_ldz;

 /***************************************************************/
 /* Find leading zeros in next 32 bits                          */
 /***************************************************************/
            NEXTBITS_32(u4_word, u4_bitstream_offset, pu4_bitstrm_buf);
            u4_ldz = CLZ(u4_word);
 /* Flush the ps_bitstrm */
            u4_bitstream_offset += (u4_ldz + 1);
 /* Read the suffix from the ps_bitstrm */
            u4_word = 0;
 if(u4_ldz)
                GETBITS(u4_word, u4_bitstream_offset, pu4_bitstrm_buf,
                        u4_ldz);
 *pu4_bitstrm_ofst = u4_bitstream_offset;
            ui_sub_mb_mode = ((1 << u4_ldz) + u4_word - 1);

 if(ui_sub_mb_mode > 3)
 {
 return ERROR_SUB_MB_TYPE;
 }
 else
 {
                u4_sum_mb_mode_pack = (u4_sum_mb_mode_pack << 8) | ui_sub_mb_mode;
 /* Storing collocated information */
 *pu1_col_info++ = u1_colz | (UWORD8)(ui_sub_mb_mode << 4);

                COPYTHECONTEXT("sub_mb_type", ui_sub_mb_mode);
 }

 /* check if Motion compensation is done below 8x8 */
 if(ui_sub_mb_mode != P_L0_8x8)
 {
                u1_no_submb_part_size_lt8x8_flag = 0;
 }
 }

        u1_num_mb_part = 4;
 }
 else
 {
 *pu1_col_info++ = (u1_mb_type << 6);
 if(u1_mb_type)
 *pu1_col_info++ = (u1_mb_type << 6);
        u1_num_mb_part = pu1_num_mb_part[u1_mb_type];

 }

 /* Decoding reference index 0: For simple profile the following   */
 /* conditions are always true (mb_field_decoding_flag == 0);      */
 /* (MbPartPredMode != PredL1)                                     */

 {

        UWORD8 uc_field = ps_cur_mb_info->u1_mb_field_decodingflag;
        UWORD8 uc_num_ref_idx_l0_active_minus1 =
 (ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[0]
 << (u1_mbaff & uc_field)) - 1;

 if((uc_num_ref_idx_l0_active_minus1 > 0) & (u1_mb_type != PRED_8x8R0))
 {
 if(1 == uc_num_ref_idx_l0_active_minus1)
                ih264d_parse_pmb_ref_index_cavlc_range1(
                                u1_num_mb_part, ps_bitstrm, pi1_ref_idx,
                                uc_num_ref_idx_l0_active_minus1);
 else
 {
                ret = ih264d_parse_pmb_ref_index_cavlc(
                                u1_num_mb_part, ps_bitstrm, pi1_ref_idx,
                                uc_num_ref_idx_l0_active_minus1);
 if(ret != OK)
 return ret;
 }
 }
 else
 {
 /* When there exists only a single frame to predict from */
            UWORD8 uc_i;
 for(uc_i = 0; uc_i < u1_num_mb_part; uc_i++)
 /* Storing Reference Idx Information */
                pi1_ref_idx[uc_i] = 0;
 }
 }

 {
        UWORD8 u1_p_idx, uc_i;
 parse_part_params_t * ps_part = ps_dec->ps_part;
        UWORD8 u1_sub_mb_mode, u1_num_subpart, u1_mb_part_width, u1_mb_part_height;
        UWORD8 u1_sub_mb_num;
 const UWORD8 * pu1_top_left_sub_mb_indx;
 mv_pred_t * ps_mv, *ps_mv_start = ps_dec->ps_mv_cur + (u1_mb_num << 4);
 /* Loading the table pointers */
 const UWORD8 * pu1_mb_partw = (const UWORD8 *)gau1_ih264d_mb_partw;
 const UWORD8 * pu1_mb_parth = (const UWORD8 *)gau1_ih264d_mb_parth;
 const UWORD8 * pu1_sub_mb_indx_mod =
 (const UWORD8 *)(gau1_ih264d_submb_indx_mod)
 + (uc_sub_mb * 6);
 const UWORD8 * pu1_sub_mb_partw = (const UWORD8 *)gau1_ih264d_submb_partw;
 const UWORD8 * pu1_sub_mb_parth = (const UWORD8 *)gau1_ih264d_submb_parth;
 const UWORD8 * pu1_num_sub_mb_part =
 (const UWORD8 *)gau1_ih264d_num_submb_part;

        UWORD16 u2_sub_mb_num = 0x028A;

 /*********************************************************/
 /* default initialisations for condition (uc_sub_mb == 0) */
 /* i.e. all are subpartitions of 8x8                     */
 /*********************************************************/
        u1_sub_mb_mode = 0;
        u1_num_subpart = 1;
        u1_mb_part_width = pu1_mb_partw[u1_mb_type];
        u1_mb_part_height = pu1_mb_parth[u1_mb_type];
        pu1_top_left_sub_mb_indx = pu1_sub_mb_indx_mod + (u1_mb_type << 1);
        u1_sub_mb_num = 0;

 /* Loop on number of partitions */
 for(uc_i = 0, u1_p_idx = 0; uc_i < u1_num_mb_part; uc_i++)
 {
            UWORD8 uc_j;
 if(uc_sub_mb)
 {
                u1_sub_mb_mode = u4_sum_mb_mode_pack >> 24;
                u1_num_subpart = pu1_num_sub_mb_part[u1_sub_mb_mode];
                u1_mb_part_width = pu1_sub_mb_partw[u1_sub_mb_mode];
                u1_mb_part_height = pu1_sub_mb_parth[u1_sub_mb_mode];
                pu1_top_left_sub_mb_indx = pu1_sub_mb_indx_mod + (u1_sub_mb_mode << 1);
                u1_sub_mb_num = u2_sub_mb_num >> 12;
                u4_sum_mb_mode_pack <<= 8;
                u2_sub_mb_num <<= 4;
 }

 /* Loop on Number of sub-partitions */
 for(uc_j = 0; uc_j < u1_num_subpart; uc_j++, pu1_top_left_sub_mb_indx++)
 {
                WORD16 i2_mvx, i2_mvy;
                u1_sub_mb_num += *pu1_top_left_sub_mb_indx;
                ps_mv = ps_mv_start + u1_sub_mb_num;

 /* Reading the differential Mv from the bitstream */
 {
                    UWORD32 u4_bitstream_offset = *pu4_bitstrm_ofst;
                    UWORD32 u4_word, u4_ldz, u4_abs_val;

 /***************************************************************/
 /* Find leading zeros in next 32 bits                          */
 /***************************************************************/
                    NEXTBITS_32(u4_word, u4_bitstream_offset,
                                pu4_bitstrm_buf);
                    u4_ldz = CLZ(u4_word);

 /* Flush the ps_bitstrm */
                    u4_bitstream_offset += (u4_ldz + 1);

 /* Read the suffix from the ps_bitstrm */
                    u4_word = 0;
 if(u4_ldz)
                        GETBITS(u4_word, u4_bitstream_offset,
                                pu4_bitstrm_buf, u4_ldz);

 *pu4_bitstrm_ofst = u4_bitstream_offset;
                    u4_abs_val = ((1 << u4_ldz) + u4_word) >> 1;

 if(u4_word & 0x1)
                        i2_mvx = (-(WORD32)u4_abs_val);
 else
                        i2_mvx = (u4_abs_val);
 }
                COPYTHECONTEXT("MVD", i2_mvx);
                i2_mvy = ih264d_sev(pu4_bitstrm_ofst,
                                     pu4_bitstrm_buf);
                COPYTHECONTEXT("MVD", i2_mvy);

 /* Storing Info for partitions */
                ps_part->u1_is_direct = PART_NOT_DIRECT;
                ps_part->u1_sub_mb_num = u1_sub_mb_num;
                ps_part->u1_partheight = u1_mb_part_height;
                ps_part->u1_partwidth = u1_mb_part_width;

 /* Storing Mv residuals */
                ps_mv->i2_mv[0] = i2_mvx;
                ps_mv->i2_mv[1] = i2_mvy;

 /* Increment partition Index */
                u1_p_idx++;
                ps_part++;
 }
 }
        ps_parse_mb_data->u1_num_part = u1_p_idx;
        ps_dec->ps_part = ps_part;
 }

 {
        UWORD32 u4_cbp;

 /* Read the Coded block pattern */
        UWORD32 u4_bitstream_offset = *pu4_bitstrm_ofst;
        UWORD32 u4_word, u4_ldz;

 /***************************************************************/
 /* Find leading zeros in next 32 bits                          */
 /***************************************************************/
        NEXTBITS_32(u4_word, u4_bitstream_offset, pu4_bitstrm_buf);
        u4_ldz = CLZ(u4_word);
 /* Flush the ps_bitstrm */
        u4_bitstream_offset += (u4_ldz + 1);
 /* Read the suffix from the ps_bitstrm */
        u4_word = 0;
 if(u4_ldz)
            GETBITS(u4_word, u4_bitstream_offset, pu4_bitstrm_buf, u4_ldz);
 *pu4_bitstrm_ofst = u4_bitstream_offset;
        u4_cbp = ((1 << u4_ldz) + u4_word - 1);

 if(u4_cbp > 47)
 return ERROR_CBP;

        u4_cbp = *((UWORD8*)gau1_ih264d_cbp_inter + u4_cbp);
        COPYTHECONTEXT("coded_block_pattern", u4_cbp);
        ps_cur_mb_info->u1_cbp = u4_cbp;

 /* Read the transform8x8 u4_flag if present */
 if((ps_dec->s_high_profile.u1_transform8x8_present) && (u4_cbp & 0xf)
 && u1_no_submb_part_size_lt8x8_flag)
 {
            ps_cur_mb_info->u1_tran_form8x8 = ih264d_get_bit_h264(ps_bitstrm);
            COPYTHECONTEXT("transform_size_8x8_flag", ps_cur_mb_info->u1_tran_form8x8);
            ps_cur_mb_info->ps_curmb->u1_tran_form8x8 = ps_cur_mb_info->u1_tran_form8x8;
 }

 /* Read mb_qp_delta */
 if(u4_cbp)
 {
            WORD32 i_temp;

            UWORD32 u4_bitstream_offset = *pu4_bitstrm_ofst;
            UWORD32 u4_word, u4_ldz, u4_abs_val;

 /***************************************************************/
 /* Find leading zeros in next 32 bits                          */
 /***************************************************************/
            NEXTBITS_32(u4_word, u4_bitstream_offset, pu4_bitstrm_buf);
            u4_ldz = CLZ(u4_word);

 /* Flush the ps_bitstrm */
            u4_bitstream_offset += (u4_ldz + 1);

 /* Read the suffix from the ps_bitstrm */
            u4_word = 0;
 if(u4_ldz)
                GETBITS(u4_word, u4_bitstream_offset, pu4_bitstrm_buf,
                        u4_ldz);

 *pu4_bitstrm_ofst = u4_bitstream_offset;
            u4_abs_val = ((1 << u4_ldz) + u4_word) >> 1;

 if(u4_word & 0x1)
                i_temp = (-(WORD32)u4_abs_val);
 else
                i_temp = (u4_abs_val);

 if((i_temp < -26) || (i_temp > 25))
 return ERROR_INV_RANGE_QP_T;

            COPYTHECONTEXT("mb_qp_delta", i_temp);
 if(i_temp)
 {
                ret = ih264d_update_qp(ps_dec, (WORD8)i_temp);
 if(ret != OK)
 return ret;
 }

            ret = ih264d_parse_residual4x4_cavlc(ps_dec, ps_cur_mb_info, 0);
 if(ret != OK)
 return ret;
 if(EXCEED_OFFSET(ps_bitstrm))
 return ERROR_EOB_TERMINATE_T;
 }
 else
 {
            ih264d_update_nnz_for_skipmb(ps_dec, ps_cur_mb_info, CAVLC);
 }



 }

 return OK;
}

WORD32 ih264d_parse_filler_data(dec_struct_t * ps_dec,
 dec_bit_stream_t * ps_bitstrm)
{
    UNUSED(ps_dec);
    UNUSED(ps_bitstrm);
 return (0);
}

WORD32 ih264d_parse_inter_slice_data_cabac(dec_struct_t * ps_dec,
 dec_slice_params_t * ps_slice,
                                           UWORD16 u2_first_mb_in_slice)
{
    UWORD32 uc_more_data_flag;
    WORD32 i2_cur_mb_addr;
    UWORD32 u1_num_mbs, u1_num_mbsNby2, u1_mb_idx;
    UWORD32 u1_mbaff;
    UWORD32 u1_num_mbs_next, u1_end_of_row;
 const UWORD16 i2_pic_wdin_mbs = ps_dec->u2_frm_wd_in_mbs;
    UWORD32 u1_slice_end = 0;
    UWORD32 u1_tfr_n_mb = 0;
    UWORD32 u1_decode_nmb = 0;


 deblk_mb_t *ps_cur_deblk_mb;
 dec_mb_info_t *ps_cur_mb_info;

 parse_pmbarams_t *ps_parse_mb_data = ps_dec->ps_parse_mb_data;
    UWORD32 u1_inter_mb_skip_type;
    UWORD32 u1_inter_mb_type;
    UWORD32 u1_deblk_mb_type;
    UWORD32 u1_mb_threshold;
 dec_bit_stream_t * const ps_bitstrm = ps_dec->ps_bitstrm;
    WORD32 ret = OK;

 /******************************************************/
 /* Initialisations specific to B or P slice           */
 /******************************************************/
 if(ps_slice->u1_slice_type == P_SLICE)
 {
        u1_inter_mb_skip_type = CAB_P_SKIP;
        u1_inter_mb_type = P_MB;
        u1_deblk_mb_type = D_INTER_MB;
        u1_mb_threshold = 5;
 }
 else // B_SLICE
 {
        u1_inter_mb_skip_type = CAB_B_SKIP;
        u1_inter_mb_type = B_MB;
        u1_deblk_mb_type = D_B_SLICE;
        u1_mb_threshold = 23;
 }

 /******************************************************/
 /* Slice Level Initialisations                        */
 /******************************************************/
    i2_cur_mb_addr = u2_first_mb_in_slice;
    ps_dec->u1_qp = ps_slice->u1_slice_qp;
    ih264d_update_qp(ps_dec, 0);
    u1_mb_idx = ps_dec->u1_mb_idx;
    u1_num_mbs = u1_mb_idx;
    u1_num_mbsNby2 = 0;
    u1_mbaff = ps_slice->u1_mbaff_frame_flag;
    i2_cur_mb_addr = u2_first_mb_in_slice << u1_mbaff;
    uc_more_data_flag = 1;

 /* Initialisations specific to cabac */
 if(ps_bitstrm->u4_ofst & 0x07)
 {
        ps_bitstrm->u4_ofst += 8;
        ps_bitstrm->u4_ofst &= 0xFFFFFFF8;
 }

    ret = ih264d_init_cabac_dec_envirnoment(&(ps_dec->s_cab_dec_env), ps_bitstrm);
 if(ret != OK)
 return ret;

    ps_dec->i1_prev_mb_qp_delta = 0;

 while(!u1_slice_end)
 {
        UWORD8 u1_mb_type;
        UWORD32 u4_mb_skip;

        ps_dec->pv_prev_mb_parse_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;

 if(i2_cur_mb_addr > ps_dec->ps_cur_sps->u2_max_mb_addr)
 {
 break;
 }

        ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs;
        ps_dec->u4_num_mbs_cur_nmb = u1_num_mbs;

        ps_cur_mb_info->u1_Mux = 0;
        ps_dec->u4_num_pmbair = (u1_num_mbs >> u1_mbaff);
        ps_cur_deblk_mb = ps_dec->ps_deblk_mbn + u1_num_mbs;

        ps_cur_mb_info->u1_end_of_slice = 0;

 /* Storing Default partition info */
        ps_parse_mb_data->u1_num_part = 1;
        ps_parse_mb_data->u1_isI_mb = 0;

 /***************************************************************/
 /* Get the required information for decoding of MB             */
 /* mb_x, mb_y , neighbour availablity,                         */
 /***************************************************************/
        u4_mb_skip = ps_dec->pf_get_mb_info(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, 1);

 /*********************************************************************/
 /* initialize u1_tran_form8x8 to zero to aviod uninitialized accesses */
 /*********************************************************************/
        ps_cur_mb_info->u1_tran_form8x8 = 0;
        ps_cur_mb_info->ps_curmb->u1_tran_form8x8 = 0;

 /***************************************************************/
 /* Set the deblocking parameters for this MB                   */
 /***************************************************************/
 if(ps_dec->u4_app_disable_deblk_frm == 0)
            ih264d_set_deblocking_parameters(ps_cur_deblk_mb, ps_slice,
                                             ps_dec->u1_mb_ngbr_availablity,
                                             ps_dec->u1_cur_mb_fld_dec_flag);

 if(u4_mb_skip)
 {

 /* Set appropriate flags in ps_cur_mb_info and ps_dec */
            memset(ps_dec->ps_curr_ctxt_mb_info, 0, sizeof(ctxt_inc_mb_info_t));
            ps_dec->ps_curr_ctxt_mb_info->u1_mb_type = u1_inter_mb_skip_type;

            MEMSET_16BYTES(&ps_dec->pu1_left_mv_ctxt_inc[0][0], 0);

 *((UWORD32 *)ps_dec->pi1_left_ref_idx_ctxt_inc) = 0;
 *(ps_dec->pu1_left_yuv_dc_csbp) = 0;

            ps_dec->i1_prev_mb_qp_delta = 0;
            ps_cur_mb_info->u1_mb_type = MB_SKIP;
            ps_cur_mb_info->u1_cbp = 0;

 {
 /* Storing Skip partition info */
 parse_part_params_t *ps_part_info = ps_dec->ps_part;
                ps_part_info->u1_is_direct = PART_DIRECT_16x16;
                ps_part_info->u1_sub_mb_num = 0;
                ps_dec->ps_part++;
 }

 /* Update Nnzs */
            ih264d_update_nnz_for_skipmb(ps_dec, ps_cur_mb_info, CABAC);

            ps_cur_mb_info->ps_curmb->u1_mb_type = u1_inter_mb_type;
            ps_cur_deblk_mb->u1_mb_type |= u1_deblk_mb_type;
            ps_cur_deblk_mb->u1_mb_qp = ps_dec->u1_qp;

 }
 else
 {

 /* Macroblock Layer Begins */
 /* Decode the u1_mb_type */
            u1_mb_type = ih264d_parse_mb_type_cabac(ps_dec);
            ps_cur_mb_info->u1_mb_type = u1_mb_type;
 if(u1_mb_type > (25 + u1_mb_threshold))
 return ERROR_MB_TYPE;

 /* Parse Macroblock Data */
 if(u1_mb_type < u1_mb_threshold)
 {
                ps_cur_mb_info->ps_curmb->u1_mb_type = u1_inter_mb_type;
 *(ps_dec->pu1_left_yuv_dc_csbp) &= 0x6;

                ret = ps_dec->pf_parse_inter_mb(ps_dec, ps_cur_mb_info, u1_num_mbs,
                                          u1_num_mbsNby2);
 if(ret != OK)
 return ret;
                ps_cur_deblk_mb->u1_mb_qp = ps_dec->u1_qp;
                ps_cur_deblk_mb->u1_mb_type |= u1_deblk_mb_type;
 }
 else
 {
 /* Storing Intra partition info */
                ps_parse_mb_data->u1_num_part = 0;
                ps_parse_mb_data->u1_isI_mb = 1;

 if((25 + u1_mb_threshold) == u1_mb_type)
 {
 /* I_PCM_MB */
                    ps_cur_mb_info->ps_curmb->u1_mb_type = I_PCM_MB;
                    ret = ih264d_parse_ipcm_mb(ps_dec, ps_cur_mb_info, u1_num_mbs);
 if(ret != OK)
 return ret;
                    ps_cur_deblk_mb->u1_mb_qp = 0;
 }
 else
 {
 if(u1_mb_type == u1_mb_threshold)
                        ps_cur_mb_info->ps_curmb->u1_mb_type = I_4x4_MB;
 else
                        ps_cur_mb_info->ps_curmb->u1_mb_type = I_16x16_MB;

                    ret = ih264d_parse_imb_cabac(
                                    ps_dec, ps_cur_mb_info,
 (UWORD8)(u1_mb_type - u1_mb_threshold));
 if(ret != OK)
 return ret;
                    ps_cur_deblk_mb->u1_mb_qp = ps_dec->u1_qp;
 }
                ps_cur_deblk_mb->u1_mb_type |= D_INTRA_MB;

 }

 }

 if(u1_mbaff)
 {
            ih264d_update_mbaff_left_nnz(ps_dec, ps_cur_mb_info);
 }
 /* Next macroblock information */
        i2_cur_mb_addr++;

 if(ps_cur_mb_info->u1_topmb && u1_mbaff)
            uc_more_data_flag = 1;
 else
 {
            uc_more_data_flag = ih264d_decode_terminate(&ps_dec->s_cab_dec_env,
                                                      ps_bitstrm);
            uc_more_data_flag = !uc_more_data_flag;
            COPYTHECONTEXT("Decode Sliceterm",!uc_more_data_flag);
 }

        u1_num_mbs++;
        u1_num_mbsNby2++;
        ps_parse_mb_data++;

 /****************************************************************/
 /* Check for End Of Row and other flags that determine when to  */
 /* do DMA setup for N/2-Mb, Decode for N-Mb, and Transfer for   */
 /* N-Mb                                                         */
 /****************************************************************/
        u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;
        u1_end_of_row = (!u1_num_mbs_next) && (!(u1_mbaff && (u1_num_mbs & 0x01)));
        u1_slice_end = !uc_more_data_flag;
        u1_tfr_n_mb = (u1_num_mbs == ps_dec->u1_recon_mb_grp) || u1_end_of_row
 || u1_slice_end;
        u1_decode_nmb = u1_tfr_n_mb || u1_slice_end;
        ps_cur_mb_info->u1_end_of_slice = u1_slice_end;
 /*u1_dma_nby2mb   = u1_decode_nmb ||
         (u1_num_mbsNby2 == ps_dec->u1_recon_mb_grp_pair);*/

 if(u1_decode_nmb)
 {

            ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx, u1_num_mbs);
            u1_num_mbsNby2 = 0;

 {
                ps_parse_mb_data = ps_dec->ps_parse_mb_data;
                ps_dec->ps_part = ps_dec->ps_parse_part_params;
 }
 }

 /*H264_DEC_DEBUG_PRINT("Pic: %d Mb_X=%d Mb_Y=%d",
         ps_slice->i4_poc >> ps_slice->u1_field_pic_flag,
         ps_dec->u2_mbx,ps_dec->u2_mby + (1 - ps_cur_mb_info->u1_topmb));
         H264_DEC_DEBUG_PRINT("u1_decode_nmb: %d, u1_num_mbs: %d", u1_decode_nmb, u1_num_mbs);*/
 if(u1_decode_nmb)
 {

 if(ps_dec->u1_separate_parse)
 {
                ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,
                                     u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);
                ps_dec->ps_nmb_info +=  u1_num_mbs;
 }
 else
 {
                ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,
                                            u1_num_mbs_next, u1_tfr_n_mb,
                                            u1_end_of_row);
 }
            ps_dec->u2_total_mbs_coded += u1_num_mbs;
 if(u1_tfr_n_mb)
                u1_num_mbs = 0;
            u1_mb_idx = u1_num_mbs;
            ps_dec->u1_mb_idx = u1_num_mbs;

 }
 }


    ps_dec->u4_num_mbs_cur_nmb = 0;
    ps_dec->ps_cur_slice->u4_mbs_in_slice = i2_cur_mb_addr

 - (u2_first_mb_in_slice << u1_mbaff);

 return ret;
}

WORD32 ih264d_parse_pps(dec_struct_t * ps_dec, dec_bit_stream_t * ps_bitstrm)
{
    UWORD8 uc_temp;
 dec_seq_params_t * ps_sps = NULL;
 dec_pic_params_t * ps_pps = NULL;
    UWORD32 *pu4_bitstrm_buf = ps_dec->ps_bitstrm->pu4_buffer;
    UWORD32 *pu4_bitstrm_ofst = &ps_dec->ps_bitstrm->u4_ofst;

 /* Variables used for error resilience checks */
    UWORD32 u4_temp;
    WORD32 i_temp;

 /* For High profile related syntax elements */
    UWORD8 u1_more_data_flag;
    WORD32 i4_i;

 /*--------------------------------------------------------------------*/
 /* Decode pic_parameter_set_id and find corresponding pic params      */
 /*--------------------------------------------------------------------*/
    u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 if(u4_temp & MASK_ERR_PIC_SET_ID)
 return ERROR_INV_SPS_PPS_T;
    ps_pps = ps_dec->pv_scratch_sps_pps;
 *ps_pps = ps_dec->ps_pps[u4_temp];
    ps_pps->u1_pic_parameter_set_id = (WORD8)u4_temp;
    COPYTHECONTEXT("PPS: pic_parameter_set_id",ps_pps->u1_pic_parameter_set_id);

 /************************************************/
 /* initilization of High profile syntax element */
 /************************************************/
    ps_pps->i4_transform_8x8_mode_flag = 0;
    ps_pps->i4_pic_scaling_matrix_present_flag = 0;

 /*--------------------------------------------------------------------*/
 /* Decode seq_parameter_set_id and map it to a seq_parameter_set      */
 /*--------------------------------------------------------------------*/
    u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 if(u4_temp & MASK_ERR_SEQ_SET_ID)
 return ERROR_INV_SPS_PPS_T;
    COPYTHECONTEXT("PPS: seq_parameter_set_id",u4_temp);
    ps_sps = &ps_dec->ps_sps[u4_temp];
    ps_pps->ps_sps = ps_sps;

 /*--------------------------------------------------------------------*/
 /* Decode entropy_coding_mode                                         */
 /*--------------------------------------------------------------------*/
    ps_pps->u1_entropy_coding_mode = ih264d_get_bit_h264(ps_bitstrm);
    COPYTHECONTEXT("PPS: entropy_coding_mode_flag",ps_pps->u1_entropy_coding_mode);

    ps_pps->u1_pic_order_present_flag = ih264d_get_bit_h264(ps_bitstrm);
    COPYTHECONTEXT("PPS: pic_order_present_flag",ps_pps->u1_pic_order_present_flag);

 /*--------------------------------------------------------------------*/
 /* Decode num_slice_groups_minus1                                     */
 /*--------------------------------------------------------------------*/
    u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf) + 1;
 if(u4_temp != 1)
 {
        UWORD32 i4_error_code;
        i4_error_code = ERROR_FEATURE_UNAVAIL;
 return i4_error_code;
 }
    ps_pps->u1_num_slice_groups = u4_temp;
    COPYTHECONTEXT("PPS: num_slice_groups_minus1",ps_pps->u1_num_slice_groups -1);

 /*--------------------------------------------------------------------*/
 /* Other parameter set values                                         */
 /*--------------------------------------------------------------------*/
    u4_temp = 1 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 if(u4_temp > H264_MAX_REF_IDX)
 return ERROR_REF_IDX;
    ps_pps->u1_num_ref_idx_lx_active[0] = u4_temp;
    COPYTHECONTEXT("PPS: num_ref_idx_l0_active_minus1",
                    ps_pps->u1_num_ref_idx_lx_active[0] - 1);

    u4_temp = 1 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 if(u4_temp > H264_MAX_REF_IDX)
 return ERROR_REF_IDX;
    ps_pps->u1_num_ref_idx_lx_active[1] = u4_temp;
    COPYTHECONTEXT("PPS: num_ref_idx_l1_active_minus1",
                    ps_pps->u1_num_ref_idx_lx_active[1] - 1);

    ps_pps->u1_wted_pred_flag = ih264d_get_bit_h264(ps_bitstrm);
    COPYTHECONTEXT("PPS: weighted prediction u4_flag",ps_pps->u1_wted_pred_flag);
    uc_temp = ih264d_get_bits_h264(ps_bitstrm, 2);
    COPYTHECONTEXT("PPS: weighted_bipred_idc",uc_temp);
    ps_pps->u1_wted_bipred_idc = uc_temp;

 if(ps_pps->u1_wted_bipred_idc > MAX_WEIGHT_BIPRED_IDC)
 return ERROR_INV_SPS_PPS_T;

    i_temp = 26 + ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);

 if((i_temp < 0) || (i_temp > 51))
 return ERROR_INV_RANGE_QP_T;

    ps_pps->u1_pic_init_qp = i_temp;
    COPYTHECONTEXT("PPS: pic_init_qp_minus26",ps_pps->u1_pic_init_qp - 26);

    i_temp = 26 + ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);

 if((i_temp < 0) || (i_temp > 51))
 return ERROR_INV_RANGE_QP_T;

    ps_pps->u1_pic_init_qs = i_temp;
    COPYTHECONTEXT("PPS: pic_init_qs_minus26",ps_pps->u1_pic_init_qs - 26);

    i_temp = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 if((i_temp < -12) || (i_temp > 12))
 return ERROR_INV_RANGE_QP_T;
    ps_pps->i1_chroma_qp_index_offset = i_temp;
    COPYTHECONTEXT("PPS: chroma_qp_index_offset",ps_pps->i1_chroma_qp_index_offset);

 /***************************************************************************/
 /* initialize second_chroma_qp_index_offset to i1_chroma_qp_index_offset if */
 /* second_chroma_qp_index_offset is not present in bit-ps_bitstrm              */
 /***************************************************************************/
    ps_pps->i1_second_chroma_qp_index_offset =
                    ps_pps->i1_chroma_qp_index_offset;

    ps_pps->u1_deblocking_filter_parameters_present_flag = ih264d_get_bit_h264(
                    ps_bitstrm);
    COPYTHECONTEXT("PPS: deblocking_filter_control_present_flag",
                    ps_pps->u1_deblocking_filter_parameters_present_flag);
    ps_pps->u1_constrained_intra_pred_flag = ih264d_get_bit_h264(ps_bitstrm);
    COPYTHECONTEXT("PPS: constrained_intra_pred_flag",
                    ps_pps->u1_constrained_intra_pred_flag);
    ps_pps->u1_redundant_pic_cnt_present_flag = ih264d_get_bit_h264(ps_bitstrm);
    COPYTHECONTEXT("PPS: redundant_pic_cnt_present_flag",
                    ps_pps->u1_redundant_pic_cnt_present_flag);

 /* High profile related syntax elements */
    u1_more_data_flag = MORE_RBSP_DATA(ps_bitstrm);
 if(u1_more_data_flag && (ps_pps->ps_sps->u1_profile_idc == HIGH_PROFILE_IDC))
 {
 /* read transform_8x8_mode_flag  */
        ps_pps->i4_transform_8x8_mode_flag = (WORD32)ih264d_get_bit_h264(
                        ps_bitstrm);

 /* read pic_scaling_matrix_present_flag */
        ps_pps->i4_pic_scaling_matrix_present_flag =
 (WORD32)ih264d_get_bit_h264(ps_bitstrm);

 if(ps_pps->i4_pic_scaling_matrix_present_flag)
 {
 /* read the scaling matrices */
 for(i4_i = 0; i4_i < (6 + (ps_pps->i4_transform_8x8_mode_flag << 1)); i4_i++)
 {
                ps_pps->u1_pic_scaling_list_present_flag[i4_i] =
                                ih264d_get_bit_h264(ps_bitstrm);

 if(ps_pps->u1_pic_scaling_list_present_flag[i4_i])
 {
 if(i4_i < 6)
 {
                        ih264d_scaling_list(
                                        ps_pps->i2_pic_scalinglist4x4[i4_i],
 16,
 &ps_pps->u1_pic_use_default_scaling_matrix_flag[i4_i],
                                        ps_bitstrm);
 }
 else
 {
                        ih264d_scaling_list(
                                        ps_pps->i2_pic_scalinglist8x8[i4_i - 6],
 64,
 &ps_pps->u1_pic_use_default_scaling_matrix_flag[i4_i],
                                        ps_bitstrm);
 }
 }
 }
 }

 /* read second_chroma_qp_index_offset syntax element */
        ps_pps->i1_second_chroma_qp_index_offset = ih264d_sev(
                        pu4_bitstrm_ofst, pu4_bitstrm_buf);

 if((ps_pps->i1_second_chroma_qp_index_offset + 12) > 24)
 return ERROR_INV_RANGE_QP_T;
 }

 /* In case bitstream read has exceeded the filled size, then
       return an error */
 if(ps_bitstrm->u4_ofst > ps_bitstrm->u4_max_ofst + 8)
 {
 return ERROR_INV_SPS_PPS_T;
 }
    ps_pps->u1_is_valid = TRUE;
    ps_dec->ps_pps[ps_pps->u1_pic_parameter_set_id] = *ps_pps;
 return OK;
}

UWORD32 ih264d_correct_level_idc(UWORD32 u4_level_idc, UWORD32 u4_total_mbs)
{
    UWORD32 u4_max_mbs_allowed;

 switch(u4_level_idc)
 {
 case H264_LEVEL_1_0:
            u4_max_mbs_allowed = MAX_MBS_LEVEL_10;
 break;
 case H264_LEVEL_1_1:
            u4_max_mbs_allowed = MAX_MBS_LEVEL_11;
 break;
 case H264_LEVEL_1_2:
            u4_max_mbs_allowed = MAX_MBS_LEVEL_12;
 break;
 case H264_LEVEL_1_3:
            u4_max_mbs_allowed = MAX_MBS_LEVEL_13;
 break;
 case H264_LEVEL_2_0:
            u4_max_mbs_allowed = MAX_MBS_LEVEL_20;
 break;
 case H264_LEVEL_2_1:
            u4_max_mbs_allowed = MAX_MBS_LEVEL_21;
 break;
 case H264_LEVEL_2_2:
            u4_max_mbs_allowed = MAX_MBS_LEVEL_22;
 break;
 case H264_LEVEL_3_0:
            u4_max_mbs_allowed = MAX_MBS_LEVEL_30;
 break;
 case H264_LEVEL_3_1:
            u4_max_mbs_allowed = MAX_MBS_LEVEL_31;
 break;
 case H264_LEVEL_3_2:
            u4_max_mbs_allowed = MAX_MBS_LEVEL_32;
 break;
 case H264_LEVEL_4_0:
            u4_max_mbs_allowed = MAX_MBS_LEVEL_40;
 break;
 case H264_LEVEL_4_1:
            u4_max_mbs_allowed = MAX_MBS_LEVEL_41;
 break;
 case H264_LEVEL_4_2:
            u4_max_mbs_allowed = MAX_MBS_LEVEL_42;
 break;
 case H264_LEVEL_5_0:
            u4_max_mbs_allowed = MAX_MBS_LEVEL_50;
 break;
 case H264_LEVEL_5_1:
 default:
            u4_max_mbs_allowed = MAX_MBS_LEVEL_51;
 break;

 }

 /*correct of the level is incorrect*/
 if(u4_total_mbs > u4_max_mbs_allowed)
 {
 if(u4_total_mbs > MAX_MBS_LEVEL_50)
            u4_level_idc = H264_LEVEL_5_1;
 else if(u4_total_mbs > MAX_MBS_LEVEL_42)
            u4_level_idc = H264_LEVEL_5_0;
 else if(u4_total_mbs > MAX_MBS_LEVEL_41)
            u4_level_idc = H264_LEVEL_4_2;
 else if(u4_total_mbs > MAX_MBS_LEVEL_40)
            u4_level_idc = H264_LEVEL_4_1;
 else if(u4_total_mbs > MAX_MBS_LEVEL_32)
            u4_level_idc = H264_LEVEL_4_0;
 else if(u4_total_mbs > MAX_MBS_LEVEL_31)
            u4_level_idc = H264_LEVEL_3_2;
 else if(u4_total_mbs > MAX_MBS_LEVEL_30)
            u4_level_idc = H264_LEVEL_3_1;
 else if(u4_total_mbs > MAX_MBS_LEVEL_21)
            u4_level_idc = H264_LEVEL_3_0;
 else if(u4_total_mbs > MAX_MBS_LEVEL_20)
            u4_level_idc = H264_LEVEL_2_1;
 else if(u4_total_mbs > MAX_MBS_LEVEL_10)
            u4_level_idc = H264_LEVEL_2_0;
 }

 return (u4_level_idc);

}

WORD32 ih264d_parse_decode_slice(UWORD8 u1_is_idr_slice,
UWORD8 u1_nal_ref_idc,
dec_struct_t *ps_dec /* Decoder parameters */
)
{
dec_bit_stream_t * ps_bitstrm = ps_dec->ps_bitstrm;
dec_pic_params_t *ps_pps;
dec_seq_params_t *ps_seq;
dec_slice_params_t *ps_cur_slice = ps_dec->ps_cur_slice;
pocstruct_t s_tmp_poc;
WORD32 i_delta_poc[2];
WORD32 i4_poc = 0;
UWORD16 u2_first_mb_in_slice, u2_frame_num;
UWORD8 u1_field_pic_flag, u1_redundant_pic_cnt = 0, u1_slice_type;
UWORD32 u4_idr_pic_id = 0;
UWORD8 u1_bottom_field_flag, u1_pic_order_cnt_type;

UWORD8 u1_nal_unit_type;
UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;
WORD8 i1_is_end_of_poc;

WORD32 ret, end_of_frame;
WORD32 prev_slice_err, num_mb_skipped;
UWORD8 u1_mbaff;
pocstruct_t *ps_cur_poc;

UWORD32 u4_temp;
WORD32 i_temp;
UWORD32 u4_call_end_of_pic = 0;

/* read FirstMbInSlice  and slice type*/
ps_dec->ps_dpb_cmds->u1_dpb_commands_read_slc = 0;
u2_first_mb_in_slice = ih264d_uev(pu4_bitstrm_ofst,
pu4_bitstrm_buf);
if(u2_first_mb_in_slice
> (ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs))
{

return ERROR_CORRUPTED_SLICE;
}

/*we currently don not support ASO*/
if(((u2_first_mb_in_slice << ps_cur_slice->u1_mbaff_frame_flag)
<= ps_dec->u2_cur_mb_addr) && (ps_dec->u2_cur_mb_addr != 0)
&& (ps_dec->u4_first_slice_in_pic != 0))
{
return ERROR_CORRUPTED_SLICE;
}

COPYTHECONTEXT("SH: first_mb_in_slice",u2_first_mb_in_slice);

u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);

if(u4_temp > 9)
return ERROR_INV_SLC_TYPE_T;

u1_slice_type = u4_temp;
COPYTHECONTEXT("SH: slice_type",(u1_slice_type));
ps_dec->u1_sl_typ_5_9 = 0;
/* Find Out the Slice Type is 5 to 9 or not then Set the Flag   */
/* u1_sl_typ_5_9 = 1 .Which tells that all the slices in the Pic*/
/* will be of same type of current                            */
if(u1_slice_type > 4)
{
u1_slice_type -= 5;
ps_dec->u1_sl_typ_5_9 = 1;
}

{
UWORD32 skip;

if((ps_dec->i4_app_skip_mode == IVD_SKIP_PB)
|| (ps_dec->i4_dec_skip_mode == IVD_SKIP_PB))
{
UWORD32 u4_bit_stream_offset = 0;

if(ps_dec->u1_nal_unit_type == IDR_SLICE_NAL)
{
skip = 0;

ps_dec->i4_dec_skip_mode = IVD_SKIP_NONE;
}
else if((I_SLICE == u1_slice_type)
&& (1 >= ps_dec->ps_cur_sps->u1_num_ref_frames))
{
skip = 0;

ps_dec->i4_dec_skip_mode = IVD_SKIP_NONE;
}
else
{
skip = 1;
}

/* If one frame worth of data is already skipped, do not skip the next one */
if((0 == u2_first_mb_in_slice) && (1 == ps_dec->u4_prev_nal_skipped))
{
skip = 0;
}

if(skip)
{
ps_dec->u4_prev_nal_skipped = 1;
ps_dec->i4_dec_skip_mode = IVD_SKIP_PB;
return 0;
}
else
{
/* If the previous NAL was skipped, then
do not process that buffer in this call.
Return to app and process it in the next call.
This is necessary to handle cases where I/IDR is not complete in
the current buffer and application intends to fill the remaining part of the bitstream
later. This ensures we process only frame worth of data in every call */
if(1 == ps_dec->u4_prev_nal_skipped)
{
ps_dec->u4_return_to_app = 1;
return 0;
}
}
}

}

u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
if(u4_temp & MASK_ERR_PIC_SET_ID)
return ERROR_INV_SPS_PPS_T;
/* discard slice if pic param is invalid */
COPYTHECONTEXT("SH: pic_parameter_set_id", u4_temp);
ps_pps = &ps_dec->ps_pps[u4_temp];
if(FALSE == ps_pps->u1_is_valid)
{
return ERROR_INV_SPS_PPS_T;
}
ps_seq = ps_pps->ps_sps;
if(!ps_seq)
return ERROR_INV_SPS_PPS_T;
if(FALSE == ps_seq->u1_is_valid)
return ERROR_INV_SPS_PPS_T;

/* Get the frame num */
u2_frame_num = ih264d_get_bits_h264(ps_bitstrm,
ps_seq->u1_bits_in_frm_num);
//    H264_DEC_DEBUG_PRINT("FRAME %d First MB in slice: %d\n", u2_frame_num, u2_first_mb_in_slice);

COPYTHECONTEXT("SH: frame_num", u2_frame_num);
//    H264_DEC_DEBUG_PRINT("Second field: %d frame num: %d prv_frame_num: %d \n", ps_dec->u1_second_field, u2_frame_num, ps_dec->u2_prv_frame_num);

/* Get the field related flags  */
if(!ps_seq->u1_frame_mbs_only_flag)
{

u1_field_pic_flag = ih264d_get_bit_h264(ps_bitstrm);
COPYTHECONTEXT("SH: field_pic_flag", u1_field_pic_flag);
u1_bottom_field_flag = 0;

if(u1_field_pic_flag)
{
ps_dec->pu1_inv_scan = (UWORD8 *)gau1_ih264d_inv_scan_fld;
u1_bottom_field_flag = ih264d_get_bit_h264(ps_bitstrm);
COPYTHECONTEXT("SH: bottom_field_flag", u1_bottom_field_flag);

}
else
{
ps_dec->pu1_inv_scan = (UWORD8 *)gau1_ih264d_inv_scan;
}
}
else
{
u1_field_pic_flag = 0;
u1_bottom_field_flag = 0;

ps_dec->pu1_inv_scan = (UWORD8 *)gau1_ih264d_inv_scan;
}

u1_nal_unit_type = SLICE_NAL;
if(u1_is_idr_slice)
{
if(0 == u1_field_pic_flag)
{
ps_dec->u1_top_bottom_decoded = TOP_FIELD_ONLY | BOT_FIELD_ONLY;
}
u1_nal_unit_type = IDR_SLICE_NAL;
u4_idr_pic_id = ih264d_uev(pu4_bitstrm_ofst,
pu4_bitstrm_buf);
if(u4_idr_pic_id > 65535)
return ERROR_INV_SPS_PPS_T;
COPYTHECONTEXT("SH:  ", u4_idr_pic_id);
}

/* read delta pic order count information*/
i_delta_poc[0] = i_delta_poc[1] = 0;
s_tmp_poc.i4_pic_order_cnt_lsb = 0;
s_tmp_poc.i4_delta_pic_order_cnt_bottom = 0;
u1_pic_order_cnt_type = ps_seq->u1_pic_order_cnt_type;
if(u1_pic_order_cnt_type == 0)
{
i_temp = ih264d_get_bits_h264(
ps_bitstrm,
ps_seq->u1_log2_max_pic_order_cnt_lsb_minus);
if(i_temp < 0 || i_temp >= ps_seq->i4_max_pic_order_cntLsb)
return ERROR_INV_SPS_PPS_T;
s_tmp_poc.i4_pic_order_cnt_lsb = i_temp;
COPYTHECONTEXT("SH: pic_order_cnt_lsb", s_tmp_poc.i4_pic_order_cnt_lsb);

if((ps_pps->u1_pic_order_present_flag == 1) && (!u1_field_pic_flag))
{
s_tmp_poc.i4_delta_pic_order_cnt_bottom = ih264d_sev(
pu4_bitstrm_ofst, pu4_bitstrm_buf);
//if(s_tmp_poc.i4_delta_pic_order_cnt_bottom > ps_seq->i4_max_pic_order_cntLsb)
COPYTHECONTEXT("SH: delta_pic_order_cnt_bottom",
s_tmp_poc.i4_delta_pic_order_cnt_bottom);
}
}

s_tmp_poc.i4_delta_pic_order_cnt[0] = 0;
s_tmp_poc.i4_delta_pic_order_cnt[1] = 0;
if(u1_pic_order_cnt_type == 1
&& (!ps_seq->u1_delta_pic_order_always_zero_flag))
{
s_tmp_poc.i4_delta_pic_order_cnt[0] = ih264d_sev(pu4_bitstrm_ofst,
pu4_bitstrm_buf);
COPYTHECONTEXT("SH: delta_pic_order_cnt[0]",
s_tmp_poc.i4_delta_pic_order_cnt[0]);

if(ps_pps->u1_pic_order_present_flag && !u1_field_pic_flag)
{
s_tmp_poc.i4_delta_pic_order_cnt[1] = ih264d_sev(
pu4_bitstrm_ofst, pu4_bitstrm_buf);
COPYTHECONTEXT("SH: delta_pic_order_cnt[1]",
s_tmp_poc.i4_delta_pic_order_cnt[1]);
}
}

if(ps_pps->u1_redundant_pic_cnt_present_flag)
{
u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
if(u4_temp > MAX_REDUNDANT_PIC_CNT)
return ERROR_INV_SPS_PPS_T;
u1_redundant_pic_cnt = u4_temp;
COPYTHECONTEXT("SH: redundant_pic_cnt", u1_redundant_pic_cnt);
}

/*--------------------------------------------------------------------*/
/* Check if the slice is part of new picture                          */
/*--------------------------------------------------------------------*/
i1_is_end_of_poc = 0;
if(!ps_dec->u1_first_slice_in_stream)
{
i1_is_end_of_poc = ih264d_is_end_of_pic(u2_frame_num, u1_nal_ref_idc,
&s_tmp_poc, &ps_dec->s_cur_pic_poc,
ps_cur_slice, u1_pic_order_cnt_type,
u1_nal_unit_type, u4_idr_pic_id,
u1_field_pic_flag,
u1_bottom_field_flag);

/* since we support only Full frame decode, every new process should
* process a new pic
*/
if((ps_dec->u4_first_slice_in_pic == 2) && (i1_is_end_of_poc == 0))
{
/* if it is the first slice is process call ,it should be a new frame. If it is not
* reject current pic and dont add it to dpb
*/
ps_dec->ps_dec_err_status->u1_err_flag |= REJECT_CUR_PIC;
i1_is_end_of_poc = 1;
}
else
{
/* reset REJECT_CUR_PIC */
ps_dec->ps_dec_err_status->u1_err_flag &= MASK_REJECT_CUR_PIC;
}
}

/*--------------------------------------------------------------------*/
/* Check for error in slice and parse the missing/corrupted MB's      */
/* as skip-MB's in an inserted P-slice                                */
/*--------------------------------------------------------------------*/
u1_mbaff = ps_seq->u1_mb_aff_flag && (!u1_field_pic_flag);
prev_slice_err = 0;

if(i1_is_end_of_poc || ps_dec->u1_first_slice_in_stream)
{
if(u2_frame_num != ps_dec->u2_prv_frame_num
&& ps_dec->u1_top_bottom_decoded != 0
&& ps_dec->u1_top_bottom_decoded
!= (TOP_FIELD_ONLY | BOT_FIELD_ONLY))
{
ps_dec->u1_dangling_field = 1;
if(ps_dec->u4_first_slice_in_pic)
{
// first slice - dangling field
prev_slice_err = 1;
}
else
{
// last slice - dangling field
prev_slice_err = 2;
}

if(ps_dec->u1_top_bottom_decoded ==TOP_FIELD_ONLY)
ps_cur_slice->u1_bottom_field_flag = 1;
else
ps_cur_slice->u1_bottom_field_flag = 0;

num_mb_skipped = (ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)
- ps_dec->u2_total_mbs_coded;
ps_cur_poc = &ps_dec->s_cur_pic_poc;

u1_is_idr_slice = ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL;
}
else if(ps_dec->u4_first_slice_in_pic == 2)
{
if(u2_first_mb_in_slice > 0)
{
// first slice - missing/header corruption
prev_slice_err = 1;
num_mb_skipped = u2_first_mb_in_slice << u1_mbaff;
ps_cur_poc = &s_tmp_poc;

// initializing slice parameters
ps_cur_slice->u4_idr_pic_id = u4_idr_pic_id;
ps_cur_slice->u1_field_pic_flag = u1_field_pic_flag;
ps_cur_slice->u1_bottom_field_flag = u1_bottom_field_flag;
ps_cur_slice->i4_pic_order_cnt_lsb =
s_tmp_poc.i4_pic_order_cnt_lsb;
ps_cur_slice->u1_nal_unit_type = u1_nal_unit_type;
ps_cur_slice->u1_redundant_pic_cnt = u1_redundant_pic_cnt;
ps_cur_slice->u1_nal_ref_idc = u1_nal_ref_idc;
ps_cur_slice->u1_pic_order_cnt_type = u1_pic_order_cnt_type;
}
}
else
{

if(ps_dec->u4_first_slice_in_pic)
{
/* if valid slice header is not decoded do start of pic processing
* since in the current process call, frame num is not updated in the slice structure yet
* ih264d_is_end_of_pic is checked with valid frame num of previous process call,
* although i1_is_end_of_poc is set there could be  more slices in the frame,
* so conceal only till cur slice */
prev_slice_err = 1;
num_mb_skipped = u2_first_mb_in_slice << u1_mbaff;
}
else
{
/* since i1_is_end_of_poc is set ,means new frame num is encountered. so conceal the current frame
* completely */
prev_slice_err = 2;
num_mb_skipped = (ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)
- ps_dec->u2_total_mbs_coded;
}
ps_cur_poc = &s_tmp_poc;
}
}
else
{
if((u2_first_mb_in_slice << u1_mbaff) > ps_dec->u2_total_mbs_coded)
{
// previous slice - missing/corruption
prev_slice_err = 2;
num_mb_skipped = (u2_first_mb_in_slice << u1_mbaff)
- ps_dec->u2_total_mbs_coded;
ps_cur_poc = &s_tmp_poc;
}
else if((u2_first_mb_in_slice << u1_mbaff) < ps_dec->u2_total_mbs_coded)
{
return ERROR_CORRUPTED_SLICE;
}
}

if(prev_slice_err)
{
ret = ih264d_mark_err_slice_skip(ps_dec, num_mb_skipped, u1_is_idr_slice, u2_frame_num, ps_cur_poc, prev_slice_err);

if(ps_dec->u1_dangling_field == 1)
{
ps_dec->u1_second_field = 1 - ps_dec->u1_second_field;
ps_cur_slice->u1_bottom_field_flag = u1_bottom_field_flag;
ps_dec->u2_prv_frame_num = u2_frame_num;
ps_dec->u1_first_slice_in_stream = 0;
return ERROR_DANGLING_FIELD_IN_PIC;
}

if(prev_slice_err == 2)
{
ps_dec->u1_first_slice_in_stream = 0;
return ERROR_INCOMPLETE_FRAME;
}

if(ps_dec->u2_total_mbs_coded
>= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)
{
/* return if all MBs in frame are parsed*/
ps_dec->u1_first_slice_in_stream = 0;
return ERROR_IN_LAST_SLICE_OF_PIC;
}

if(ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC)
{
ih264d_err_pic_dispbuf_mgr(ps_dec);
return ERROR_NEW_FRAME_EXPECTED;
}

if(ret != OK)
return ret;

i1_is_end_of_poc = 0;

}

if (ps_dec->u4_first_slice_in_pic == 0)
ps_dec->ps_parse_cur_slice++;

ps_dec->u1_slice_header_done = 0;

/*--------------------------------------------------------------------*/
/* If the slice is part of new picture, do End of Pic processing.     */
/*--------------------------------------------------------------------*/
if(!ps_dec->u1_first_slice_in_stream)
{
UWORD8 uc_mbs_exceed = 0;

if(ps_dec->u2_total_mbs_coded
== (ps_dec->ps_cur_sps->u2_max_mb_addr + 1))
{
/*u2_total_mbs_coded is forced  to u2_max_mb_addr+ 1 at the end of decode ,so
,if it is first slice in pic dont consider u2_total_mbs_coded to detect new picture */
if(ps_dec->u4_first_slice_in_pic == 0)
uc_mbs_exceed = 1;
}

if(i1_is_end_of_poc || uc_mbs_exceed)
{

if(1 == ps_dec->u1_last_pic_not_decoded)
{
ret = ih264d_end_of_pic_dispbuf_mgr(ps_dec);

if(ret != OK)
return ret;

ret = ih264d_end_of_pic(ps_dec, u1_is_idr_slice, u2_frame_num);
if(ret != OK)
return ret;
#if WIN32
H264_DEC_DEBUG_PRINT(" ------ PIC SKIPPED ------\n");
#endif
return RET_LAST_SKIP;
}
else
{
ret = ih264d_end_of_pic(ps_dec, u1_is_idr_slice, u2_frame_num);
if(ret != OK)
return ret;
}

}
}

if(u1_field_pic_flag)
{
ps_dec->u2_prv_frame_num = u2_frame_num;
}

if(ps_cur_slice->u1_mmco_equalto5)
{
WORD32 i4_temp_poc;
WORD32 i4_top_field_order_poc, i4_bot_field_order_poc;

if(!ps_cur_slice->u1_field_pic_flag) // or a complementary field pair
{
i4_top_field_order_poc = ps_dec->ps_cur_pic->i4_top_field_order_cnt;
i4_bot_field_order_poc =
ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;
i4_temp_poc = MIN(i4_top_field_order_poc,
i4_bot_field_order_poc);
}
else if(!ps_cur_slice->u1_bottom_field_flag)
i4_temp_poc = ps_dec->ps_cur_pic->i4_top_field_order_cnt;
else
i4_temp_poc = ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;

ps_dec->ps_cur_pic->i4_top_field_order_cnt = i4_temp_poc
- ps_dec->ps_cur_pic->i4_top_field_order_cnt;
ps_dec->ps_cur_pic->i4_bottom_field_order_cnt = i4_temp_poc
- ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;
ps_dec->ps_cur_pic->i4_poc = i4_temp_poc;
ps_dec->ps_cur_pic->i4_avg_poc = i4_temp_poc;
}
if(ps_dec->u4_first_slice_in_pic == 2)
{
ret = ih264d_decode_pic_order_cnt(u1_is_idr_slice, u2_frame_num,
&ps_dec->s_prev_pic_poc,
&s_tmp_poc, ps_cur_slice, ps_pps,
u1_nal_ref_idc,
u1_bottom_field_flag,
u1_field_pic_flag, &i4_poc);
if(ret != OK)
return ret;
/* Display seq no calculations */
if(i4_poc >= ps_dec->i4_max_poc)
ps_dec->i4_max_poc = i4_poc;
/* IDR Picture or POC wrap around */
if(i4_poc == 0)
{
ps_dec->i4_prev_max_display_seq = ps_dec->i4_prev_max_display_seq
+ ps_dec->i4_max_poc
+ ps_dec->u1_max_dec_frame_buffering + 1;
ps_dec->i4_max_poc = 0;
}
}

/*--------------------------------------------------------------------*/
/* Copy the values read from the bitstream to the slice header and then*/
/* If the slice is first slice in picture, then do Start of Picture   */
/* processing.                                                        */
/*--------------------------------------------------------------------*/
ps_cur_slice->i4_delta_pic_order_cnt[0] = i_delta_poc[0];
ps_cur_slice->i4_delta_pic_order_cnt[1] = i_delta_poc[1];
ps_cur_slice->u4_idr_pic_id = u4_idr_pic_id;
ps_cur_slice->u2_first_mb_in_slice = u2_first_mb_in_slice;
ps_cur_slice->u1_field_pic_flag = u1_field_pic_flag;
ps_cur_slice->u1_bottom_field_flag = u1_bottom_field_flag;
ps_cur_slice->u1_slice_type = u1_slice_type;
ps_cur_slice->i4_pic_order_cnt_lsb = s_tmp_poc.i4_pic_order_cnt_lsb;

ps_cur_slice->u1_nal_unit_type = u1_nal_unit_type;
ps_cur_slice->u1_redundant_pic_cnt = u1_redundant_pic_cnt;
ps_cur_slice->u1_nal_ref_idc = u1_nal_ref_idc;
ps_cur_slice->u1_pic_order_cnt_type = u1_pic_order_cnt_type;

if(ps_seq->u1_frame_mbs_only_flag)
ps_cur_slice->u1_direct_8x8_inference_flag =
ps_seq->u1_direct_8x8_inference_flag;
else
ps_cur_slice->u1_direct_8x8_inference_flag = 1;

if(u1_slice_type == B_SLICE)
{
ps_cur_slice->u1_direct_spatial_mv_pred_flag = ih264d_get_bit_h264(
ps_bitstrm);
COPYTHECONTEXT("SH: direct_spatial_mv_pred_flag",
ps_cur_slice->u1_direct_spatial_mv_pred_flag);

if(ps_cur_slice->u1_direct_spatial_mv_pred_flag)
ps_cur_slice->pf_decodeDirect = ih264d_decode_spatial_direct;
else
ps_cur_slice->pf_decodeDirect = ih264d_decode_temporal_direct;
if(!((ps_pps->ps_sps->u1_mb_aff_flag) && (!u1_field_pic_flag)))
ps_dec->pf_mvpred = ih264d_mvpred_nonmbaffB;
}
else
{
if(!((ps_pps->ps_sps->u1_mb_aff_flag) && (!u1_field_pic_flag)))
ps_dec->pf_mvpred = ih264d_mvpred_nonmbaff;
}

if(ps_dec->u4_first_slice_in_pic == 2)
{
if(u2_first_mb_in_slice == 0)
{
ret = ih264d_start_of_pic(ps_dec, i4_poc, &s_tmp_poc, u2_frame_num, ps_pps);
if(ret != OK)
return ret;
}

ps_dec->u4_output_present = 0;

{
ih264d_get_next_display_field(ps_dec,
ps_dec->ps_out_buffer,
&(ps_dec->s_disp_op));
/* If error code is non-zero then there is no buffer available for display,
hence avoid format conversion */

if(0 != ps_dec->s_disp_op.u4_error_code)
{
ps_dec->u4_fmt_conv_cur_row = ps_dec->s_disp_frame_info.u4_y_ht;
}
else
ps_dec->u4_output_present = 1;
}
if(ps_dec->u1_separate_parse == 1)
{
if(ps_dec->u4_dec_thread_created == 0)
{
ithread_create(ps_dec->pv_dec_thread_handle, NULL,
(void *)ih264d_decode_picture_thread,
(void *)ps_dec);

ps_dec->u4_dec_thread_created = 1;
}

if((ps_dec->u4_num_cores == 3) &&
((ps_dec->u4_app_disable_deblk_frm == 0) || ps_dec->i1_recon_in_thread3_flag)
&& (ps_dec->u4_bs_deblk_thread_created == 0))
{
ps_dec->u4_start_recon_deblk = 0;
ithread_create(ps_dec->pv_bs_deblk_thread_handle, NULL,
(void *)ih264d_recon_deblk_thread,
(void *)ps_dec);
ps_dec->u4_bs_deblk_thread_created = 1;
}
}

}

/* INITIALIZATION of fn ptrs for MC and formMbPartInfo functions */
{
UWORD8 uc_nofield_nombaff;



uc_nofield_nombaff = ((ps_dec->ps_cur_slice->u1_field_pic_flag == 0)
&& (ps_dec->ps_cur_slice->u1_mbaff_frame_flag == 0)
&& (u1_slice_type != B_SLICE)
&& (ps_dec->ps_cur_pps->u1_wted_pred_flag == 0));

/* Initialise MC and formMbPartInfo fn ptrs one time based on profile_idc */

if(uc_nofield_nombaff)
{
ps_dec->p_form_mb_part_info = ih264d_form_mb_part_info_bp;
ps_dec->p_motion_compensate = ih264d_motion_compensate_bp;
}
else
{
ps_dec->p_form_mb_part_info = ih264d_form_mb_part_info_mp;
ps_dec->p_motion_compensate = ih264d_motion_compensate_mp;
}


}

/*
* Decide whether to decode the current picture or not
*/
{
dec_err_status_t * ps_err = ps_dec->ps_dec_err_status;
if(ps_err->u4_frm_sei_sync == u2_frame_num)
{
ps_err->u1_err_flag = ACCEPT_ALL_PICS;
ps_err->u4_frm_sei_sync = SYNC_FRM_DEFAULT;
}
ps_err->u4_cur_frm = u2_frame_num;
}

/* Decision for decoding if the picture is to be skipped */
{
WORD32 i4_skip_b_pic, i4_skip_p_pic;

i4_skip_b_pic = (ps_dec->u4_skip_frm_mask & B_SLC_BIT)
&& (B_SLICE == u1_slice_type) && (0 == u1_nal_ref_idc);

i4_skip_p_pic = (ps_dec->u4_skip_frm_mask & P_SLC_BIT)
&& (P_SLICE == u1_slice_type) && (0 == u1_nal_ref_idc);

/**************************************************************/
/* Skip the B picture if skip mask is set for B picture and   */
/* Current B picture is a non reference B picture or there is */
/* no user for reference B picture                            */
/**************************************************************/
if(i4_skip_b_pic)
{
ps_dec->ps_cur_pic->u4_pack_slc_typ |= B_SLC_BIT;
/* Don't decode the picture in SKIP-B mode if that picture is B */
/* and also it is not to be used as a reference picture         */
ps_dec->u1_last_pic_not_decoded = 1;

return OK;
}
/**************************************************************/
/* Skip the P picture if skip mask is set for P picture and   */
/* Current P picture is a non reference P picture or there is */
/* no user for reference P picture                            */
/**************************************************************/
if(i4_skip_p_pic)
{
ps_dec->ps_cur_pic->u4_pack_slc_typ |= P_SLC_BIT;
/* Don't decode the picture in SKIP-P mode if that picture is P */
/* and also it is not to be used as a reference picture         */
ps_dec->u1_last_pic_not_decoded = 1;

return OK;
}
}

{
UWORD16 u2_mb_x, u2_mb_y;

ps_dec->i4_submb_ofst = ((u2_first_mb_in_slice
<< ps_cur_slice->u1_mbaff_frame_flag) * SUB_BLK_SIZE)
- SUB_BLK_SIZE;
if(u2_first_mb_in_slice)
{
UWORD8 u1_mb_aff;
UWORD8 u1_field_pic;
UWORD16 u2_frm_wd_in_mbs;
u2_frm_wd_in_mbs = ps_seq->u2_frm_wd_in_mbs;
u1_mb_aff = ps_cur_slice->u1_mbaff_frame_flag;
u1_field_pic = ps_cur_slice->u1_field_pic_flag;

{
UWORD32 x_offset;
UWORD32 y_offset;
UWORD32 u4_frame_stride;
tfr_ctxt_t *ps_trns_addr; // = &ps_dec->s_tran_addrecon_parse;

if(ps_dec->u1_separate_parse)
{
ps_trns_addr = &ps_dec->s_tran_addrecon_parse;
}
else
{
ps_trns_addr = &ps_dec->s_tran_addrecon;
}
u2_mb_x = MOD(u2_first_mb_in_slice, u2_frm_wd_in_mbs);
u2_mb_y = DIV(u2_first_mb_in_slice, u2_frm_wd_in_mbs);

u2_mb_y <<= u1_mb_aff;

if((u2_mb_x > u2_frm_wd_in_mbs - 1)
|| (u2_mb_y > ps_dec->u2_frm_ht_in_mbs - 1))
{
return ERROR_CORRUPTED_SLICE;
}

u4_frame_stride = ps_dec->u2_frm_wd_y << u1_field_pic;
x_offset = u2_mb_x << 4;
y_offset = (u2_mb_y * u4_frame_stride) << 4;

ps_trns_addr->pu1_dest_y = ps_dec->s_cur_pic.pu1_buf1 + x_offset
+ y_offset;

u4_frame_stride = ps_dec->u2_frm_wd_uv << u1_field_pic;
x_offset >>= 1;
y_offset = (u2_mb_y * u4_frame_stride) << 3;

x_offset *= YUV420SP_FACTOR;

ps_trns_addr->pu1_dest_u = ps_dec->s_cur_pic.pu1_buf2 + x_offset
+ y_offset;
ps_trns_addr->pu1_dest_v = ps_dec->s_cur_pic.pu1_buf3 + x_offset
+ y_offset;

ps_trns_addr->pu1_mb_y = ps_trns_addr->pu1_dest_y;
ps_trns_addr->pu1_mb_u = ps_trns_addr->pu1_dest_u;
ps_trns_addr->pu1_mb_v = ps_trns_addr->pu1_dest_v;


// assign the deblock structure pointers to start of slice
if(ps_dec->u1_separate_parse == 1)
{
ps_dec->ps_deblk_mbn = ps_dec->ps_deblk_pic
+ (u2_first_mb_in_slice << u1_mb_aff);
}
else
{
ps_dec->ps_deblk_mbn = ps_dec->ps_deblk_pic
+ (u2_first_mb_in_slice << u1_mb_aff);
}

ps_dec->u2_cur_mb_addr = (u2_first_mb_in_slice << u1_mb_aff);

ps_dec->ps_mv_cur = ps_dec->s_cur_pic.ps_mv
+ ((u2_first_mb_in_slice << u1_mb_aff) << 4);
}
}
else
{
tfr_ctxt_t *ps_trns_addr;

if(ps_dec->u1_separate_parse)
{
ps_trns_addr = &ps_dec->s_tran_addrecon_parse;
}
else
{
ps_trns_addr = &ps_dec->s_tran_addrecon;
}

u2_mb_x = 0xffff;
u2_mb_y = 0;
// assign the deblock structure pointers to start of slice
ps_dec->u2_cur_mb_addr = 0;
ps_dec->ps_deblk_mbn = ps_dec->ps_deblk_pic;
ps_dec->ps_mv_cur = ps_dec->s_cur_pic.ps_mv;
ps_trns_addr->pu1_dest_y = ps_dec->s_cur_pic.pu1_buf1;
ps_trns_addr->pu1_dest_u = ps_dec->s_cur_pic.pu1_buf2;
ps_trns_addr->pu1_dest_v = ps_dec->s_cur_pic.pu1_buf3;

ps_trns_addr->pu1_mb_y = ps_trns_addr->pu1_dest_y;
ps_trns_addr->pu1_mb_u = ps_trns_addr->pu1_dest_u;
ps_trns_addr->pu1_mb_v = ps_trns_addr->pu1_dest_v;

}

ps_dec->ps_part = ps_dec->ps_parse_part_params;

ps_dec->u2_mbx =
(MOD(u2_first_mb_in_slice - 1, ps_seq->u2_frm_wd_in_mbs));
ps_dec->u2_mby =
(DIV(u2_first_mb_in_slice - 1, ps_seq->u2_frm_wd_in_mbs));
ps_dec->u2_mby <<= ps_cur_slice->u1_mbaff_frame_flag;
ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;
ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;
}

/* RBSP stop bit is used for CABAC decoding*/
ps_bitstrm->u4_max_ofst += ps_dec->ps_cur_pps->u1_entropy_coding_mode;

ps_dec->u1_B = (u1_slice_type == B_SLICE);
ps_dec->u4_next_mb_skip = 0;

ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice =
ps_dec->ps_cur_slice->u2_first_mb_in_slice;
ps_dec->ps_parse_cur_slice->slice_type =
ps_dec->ps_cur_slice->u1_slice_type;


ps_dec->u4_start_recon_deblk = 1;
{
WORD32 num_entries;
WORD32 size;
UWORD8 *pu1_buf;

num_entries = MAX_FRAMES;
if((1 >= ps_dec->ps_cur_sps->u1_num_ref_frames) &&
(0 == ps_dec->i4_display_delay))
{
num_entries = 1;
}
num_entries = ((2 * num_entries) + 1);
if(BASE_PROFILE_IDC != ps_dec->ps_cur_sps->u1_profile_idc)
{
num_entries *= 2;
}

size = num_entries * sizeof(void *);
size += PAD_MAP_IDX_POC * sizeof(void *);

pu1_buf = (UWORD8 *)ps_dec->pv_map_ref_idx_to_poc_buf;
pu1_buf += size * ps_dec->u2_cur_slice_num;
ps_dec->ps_parse_cur_slice->ppv_map_ref_idx_to_poc = ( void *)pu1_buf;
}

if(ps_dec->u1_separate_parse)
{
ps_dec->ps_parse_cur_slice->pv_tu_coeff_data_start = ps_dec->pv_parse_tu_coeff_data;
}
else
{
ps_dec->pv_proc_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;
}

if(u1_slice_type == I_SLICE)
{
ps_dec->ps_cur_pic->u4_pack_slc_typ |= I_SLC_BIT;

ret = ih264d_parse_islice(ps_dec, u2_first_mb_in_slice);

if(ps_dec->i4_pic_type != B_SLICE && ps_dec->i4_pic_type != P_SLICE)
ps_dec->i4_pic_type = I_SLICE;

}
else if(u1_slice_type == P_SLICE)
{
ps_dec->ps_cur_pic->u4_pack_slc_typ |= P_SLC_BIT;
ret = ih264d_parse_pslice(ps_dec, u2_first_mb_in_slice);
ps_dec->u1_pr_sl_type = u1_slice_type;
if(ps_dec->i4_pic_type != B_SLICE)
ps_dec->i4_pic_type = P_SLICE;
}
else if(u1_slice_type == B_SLICE)
{
ps_dec->ps_cur_pic->u4_pack_slc_typ |= B_SLC_BIT;
ret = ih264d_parse_bslice(ps_dec, u2_first_mb_in_slice);
ps_dec->u1_pr_sl_type = u1_slice_type;
ps_dec->i4_pic_type = B_SLICE;
}
else
return ERROR_INV_SLC_TYPE_T;

if(ps_dec->u1_slice_header_done)
{
/* set to zero to indicate a valid slice has been decoded */
/* first slice header successfully decoded */
ps_dec->u4_first_slice_in_pic = 0;
ps_dec->u1_first_slice_in_stream = 0;
}


if(ret != OK)
return ret;

    ps_dec->u2_cur_slice_num++;
/* storing last Mb X and MbY of the slice */
ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;
ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;

/* End of Picture detection */

if(ps_dec->u2_total_mbs_coded >= (ps_seq->u2_max_mb_addr + 1))
{
ps_dec->u1_pic_decode_done = 1;

}

{
dec_err_status_t * ps_err = ps_dec->ps_dec_err_status;
if((ps_err->u1_err_flag & REJECT_PB_PICS)
&& (ps_err->u1_cur_pic_type == PIC_TYPE_I))
{
ps_err->u1_err_flag = ACCEPT_ALL_PICS;
}
}

PRINT_BIN_BIT_RATIO(ps_dec)

return ret;
}
