WebRunnerBrowserContext::GetBackgroundSyncController() {
  return nullptr;
}

void SandboxPolicyFuchsia::Initialize(service_manager::SandboxType type) {
  DCHECK_NE(type, service_manager::SANDBOX_TYPE_INVALID);
  DCHECK_EQ(type_, service_manager::SANDBOX_TYPE_INVALID);

  type_ = type;

  if (base::CommandLine::ForCurrentProcess()->HasSwitch(
          service_manager::switches::kNoSandbox)) {
    type_ = service_manager::SANDBOX_TYPE_NO_SANDBOX;
  }

  if (type_ == service_manager::SANDBOX_TYPE_RENDERER) {
    service_directory_task_runner_ = base::ThreadTaskRunnerHandle::Get();
    service_directory_ =
        std::make_unique<base::fuchsia::FilteredServiceDirectory>(
            base::fuchsia::ComponentContext::GetDefault());
    for (const char* service_name : kRendererServices)
      service_directory_->AddService(service_name);
  }
}

ComponentControllerImpl::ComponentControllerImpl(WebContentRunner* runner)
    : runner_(runner),
      controller_binding_(this),
      frame_observer_binding_(this) {
DCHECK(runner);
}

content::ResourceContext* WebRunnerBrowserContext::GetResourceContext() {
  return resource_context_.get();
}

void SandboxPolicyFuchsia::UpdateLaunchOptionsForSandbox(
    base::LaunchOptions* options) {
  DCHECK_NE(type_, service_manager::SANDBOX_TYPE_INVALID);

  options->fds_to_remap.push_back(std::make_pair(STDERR_FILENO, STDERR_FILENO));

  if (type_ == service_manager::SANDBOX_TYPE_NO_SANDBOX) {
    options->spawn_flags = FDIO_SPAWN_CLONE_NAMESPACE | FDIO_SPAWN_CLONE_JOB;
    options->clear_environ = false;
    return;
  }

  options->paths_to_clone.push_back(base::GetPackageRoot());

  options->clear_environ = true;

  options->spawn_flags = 0;

  if (service_directory_) {
    options->paths_to_transfer.push_back(base::PathToTransfer{
        base::FilePath("/svc"), service_directory_->ConnectClient().release()});
  }
}

void FrameImpl::GetNavigationController(
    fidl::InterfaceRequest<chromium::web::NavigationController> controller) {
  controller_bindings_.AddBinding(this, std::move(controller));
}

base::FilePath WebRunnerBrowserContext::GetCachePath() const {
  NOTIMPLEMENTED();
  return base::FilePath();
}

WebRunnerBrowserContext::CreateMediaRequestContextForStoragePartition(
    const base::FilePath& partition_path,
    bool in_memory) {
  return nullptr;
}

 WebRunnerMainDelegate::CreateContentBrowserClient() {
   DCHECK(!browser_client_);
   browser_client_ = std::make_unique<WebRunnerContentBrowserClient>(
       std::move(context_channel_));
  return browser_client_.get();
}

WebRunnerBrowserMainParts::WebRunnerBrowserMainParts(
    zx::channel context_channel)
    : context_channel_(std::move(context_channel)) {}

void FrameImpl::LoadUrl(fidl::StringPtr url,
                        std::unique_ptr<chromium::web::LoadUrlParams> params) {
  GURL validated_url(*url);
  if (!validated_url.is_valid()) {
    DLOG(WARNING) << "Invalid URL: " << *url;
    return;
  }

  content::NavigationController::LoadURLParams params_converted(validated_url);
  params_converted.transition_type = ui::PageTransitionFromInt(
      ui::PAGE_TRANSITION_TYPED | ui::PAGE_TRANSITION_FROM_ADDRESS_BAR);
  web_contents_->GetController().LoadURLWithParams(params_converted);
 }

 void FrameImpl::Stop() {
  NOTIMPLEMENTED();
}

void ComponentControllerImpl::OnNavigationStateChanged(
    chromium::web::NavigationStateChangeDetails change,
    OnNavigationStateChangedCallback callback) {}

content::BrowserPluginGuestManager* WebRunnerBrowserContext::GetGuestManager() {
  return nullptr;
}

void ContextImpl::CreateFrame(
    fidl::InterfaceHandle<chromium::web::FrameObserver> observer,
fidl::InterfaceRequest<chromium::web::Frame> frame_request) {
auto web_contents = content::WebContents::Create(
content::WebContents::CreateParams(browser_context_, nullptr));
  frame_bindings_.AddBinding(
      std::make_unique<FrameImpl>(std::move(web_contents), observer.Bind()),
      std::move(frame_request));
}

 void WebRunnerBrowserMainParts::PreDefaultMainMessageLoopRun(
     base::OnceClosure quit_closure) {
   quit_closure_ = std::move(quit_closure);
 }

WebRunnerBrowserContext::GetSpecialStoragePolicy() {
  return nullptr;
}

void ComponentControllerImpl::Detach() {
  controller_binding_.set_error_handler(nullptr);
}

WebRunnerBrowserContext::GetDownloadManagerDelegate() {
  NOTIMPLEMENTED();
  return nullptr;
}

int WebRunnerMainDelegate::RunProcess(
    const std::string& process_type,
    const content::MainFunctionParams& main_function_params) {
  if (!process_type.empty())
    return -1;

  return WebRunnerBrowserMain(main_function_params);
}

WebRunnerContentBrowserClient::CreateBrowserMainParts(
const content::MainFunctionParams& parameters) {
DCHECK(context_channel_);
  return new WebRunnerBrowserMainParts(std::move(context_channel_));
}

SandboxPolicyFuchsia::~SandboxPolicyFuchsia() {
  if (service_directory_) {
    service_directory_task_runner_->DeleteSoon(FROM_HERE,
                                               std::move(service_directory_));
  }
}

WebRunnerBrowserContext::WebRunnerBrowserContext(base::FilePath data_dir_path)
    : data_dir_path_(std::move(data_dir_path)),
      net_log_(CreateNetLog()),
      resource_context_(new ResourceContext()) {
  BrowserContext::Initialize(this, GetPath());
 }

WebRunnerBrowserContext::GetSSLHostStateDelegate() {
  return nullptr;
}

ComponentControllerImpl::CreateForRequest(
    WebContentRunner* runner,
    fuchsia::sys::Package package,
    fuchsia::sys::StartupInfo startup_info,
    fidl::InterfaceRequest<fuchsia::sys::ComponentController>
        controller_request) {
  std::unique_ptr<ComponentControllerImpl> result{
      new ComponentControllerImpl(runner)};
  if (!result->BindToRequest(std::move(package), std::move(startup_info),
                             std::move(controller_request))) {
    return nullptr;
  }
  return result;
 }

 void ComponentControllerImpl::CreateView(
     fidl::InterfaceRequest<fuchsia::ui::viewsv1token::ViewOwner> view_owner,
     fidl::InterfaceRequest<fuchsia::sys::ServiceProvider> services) {
  DCHECK(frame_);
  DCHECK(!view_is_bound_);

  frame_->CreateView(std::move(view_owner), std::move(services));
  view_is_bound_ = true;
}

WebRunnerBrowserContext::GetPushMessagingService() {
  return nullptr;
}

 void InitLoggingFromCommandLine(const base::CommandLine& command_line) {
   base::FilePath log_filename;
   std::string filename = command_line.GetSwitchValueASCII(switches::kLogFile);
  if (filename.empty()) {
    base::PathService::Get(base::DIR_EXE, &log_filename);
    log_filename = log_filename.AppendASCII("webrunner.log");
  } else {
    log_filename = base::FilePath::FromUTF8Unsafe(filename);
  }

  logging::LoggingSettings settings;
  settings.logging_dest = logging::LOG_TO_ALL;
  settings.log_file = log_filename.value().c_str();
  settings.delete_old = logging::DELETE_OLD_LOG_FILE;
  logging::InitLogging(settings);
  logging::SetLogItems(true /* Process ID */, true /* Thread ID */,
                       true /* Timestamp */, false /* Tick count */);
}

void FrameImpl::Reload() {
  NOTIMPLEMENTED();
}

WebRunnerBrowserContext::GetPermissionControllerDelegate() {
  return nullptr;
}

 void FrameImpl::CreateView(
    fidl::InterfaceRequest<fuchsia::ui::viewsv1token::ViewOwner> view_owner,
    fidl::InterfaceRequest<fuchsia::sys::ServiceProvider> services) {
  ui::PlatformWindowInitProperties properties;
  properties.view_owner_request = std::move(view_owner);

  window_tree_host_ =
      std::make_unique<aura::WindowTreeHostPlatform>(std::move(properties));
  window_tree_host_->InitHost();
  window_tree_host_->window()->SetLayoutManager(new LayoutManagerImpl());
  window_tree_host_->window()->AddChild(web_contents_->GetNativeView());
  window_tree_host_->window()->Show();
  window_tree_host_->Show();
  web_contents_->GetNativeView()->Show();
}

base::FilePath WebRunnerBrowserContext::GetPath() const {
  return data_dir_path_;
}

ContextImpl::ContextImpl(content::BrowserContext* browser_context)
    : browser_context_(browser_context) {}

WebRunnerBrowserContext::GetBrowsingDataRemoverDelegate() {
  return nullptr;
}

bool WebRunnerMainDelegate::BasicStartupComplete(int* exit_code) {
  base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();
  InitLoggingFromCommandLine(*command_line);
  content_client_ = std::make_unique<WebRunnerContentClient>();
  SetContentClient(content_client_.get());
  return false;
}

 WebRunnerBrowserContext::~WebRunnerBrowserContext() {
   if (resource_context_) {
     content::BrowserThread::DeleteSoon(content::BrowserThread::IO, FROM_HERE,
                                        std::move(resource_context_));
   }
 }

void InitializeResourceBundle() {
  base::FilePath pak_file;
  bool result = base::PathService::Get(base::DIR_ASSETS, &pak_file);
  DCHECK(result);
  pak_file = pak_file.Append(FILE_PATH_LITERAL("webrunner.pak"));
  ui::ResourceBundle::InitSharedInstanceWithPakPath(pak_file);
}

WebRunnerBrowserContext::CreateRequestContextForStoragePartition(
    const base::FilePath& partition_path,
    bool in_memory,
    content::ProtocolHandlerMap* protocol_handlers,
    content::URLRequestInterceptorScopedVector request_interceptors) {
  return nullptr;
}

WebRunnerBrowserContext::GetBackgroundFetchDelegate() {
  return nullptr;
}

net::URLRequestContextGetter* WebRunnerBrowserContext::CreateRequestContext(
    content::ProtocolHandlerMap* protocol_handlers,
    content::URLRequestInterceptorScopedVector request_interceptors) {
  DCHECK(!url_request_getter_);
  url_request_getter_ = new WebRunnerURLRequestContextGetter(
      content::BrowserThread::GetTaskRunnerForThread(
          content::BrowserThread::IO),
      net_log_.get(), std::move(*protocol_handlers),
      std::move(request_interceptors));
  resource_context_->set_url_request_context_getter(url_request_getter_);
  return url_request_getter_.get();
}

FrameImpl::~FrameImpl() {
  window_tree_host_->Hide();
  window_tree_host_->compositor()->SetVisible(false);
}

void FrameImpl::GoForward() {
  NOTIMPLEMENTED();
}

void ComponentControllerImpl::Wait(WaitCallback callback) {
   termination_wait_callbacks_.push_back(std::move(callback));
 }

ComponentControllerImpl::~ComponentControllerImpl() {
  for (WaitCallback& next_callback : termination_wait_callbacks_) {
    next_callback(did_terminate_abnormally_ ? 1 : 0);
  }
}

void WebRunnerBrowserMainParts::PreMainMessageLoopRun() {
DCHECK(!screen_);

auto platform_screen = ui::OzonePlatform::GetInstance()->CreateScreen();
if (platform_screen) {
screen_ = std::make_unique<aura::ScreenOzone>(std::move(platform_screen));
} else {
// Use dummy display::Screen for Ozone platforms that don't provide
// PlatformScreen.
screen_ = std::make_unique<WebRunnerScreen>();
}

display::Screen::SetScreenInstance(screen_.get());

DCHECK(!browser_context_);
browser_context_ =
std::make_unique<WebRunnerBrowserContext>(GetWebContextDataDir());

  fidl::InterfaceRequest<chromium::web::Context> context_request(
      std::move(context_channel_));

  context_impl_ = std::make_unique<ContextImpl>(browser_context_.get());
context_binding_ = std::make_unique<fidl::Binding<chromium::web::Context>>(
      context_impl_.get(), std::move(context_request));

  // Quit the context process as soon as context is disconnected.
  context_binding_->set_error_handler(
      [this]() { std::move(quit_closure_).Run(); });
}

void WebRunnerMainDelegate::PreSandboxStartup() {
  InitializeResourceBundle();
}

void FrameImpl::GoBack() {
  NOTIMPLEMENTED();
}

bool ComponentControllerImpl::BindToRequest(
fuchsia::sys::Package package,
fuchsia::sys::StartupInfo startup_info,
fidl::InterfaceRequest<fuchsia::sys::ComponentController>
controller_request) {
DCHECK(!service_directory_);
DCHECK(!view_provider_binding_);

url_ = GURL(*package.resolved_url);
if (!url_.is_valid()) {
LOG(ERROR) << "Rejected invalid URL: " << url_;
return false;
}

if (controller_request.is_valid()) {
controller_binding_.Bind(std::move(controller_request));
controller_binding_.set_error_handler(
fit::bind_member(this, &ComponentControllerImpl::Kill));
}

  runner_->context()->CreateFrame(frame_observer_binding_.NewBinding(),
                                  frame_.NewRequest());
frame_->GetNavigationController(navigation_controller_.NewRequest());
navigation_controller_->LoadUrl(url_.spec(), nullptr);

// Create ServiceDirectory for the component and publish ViewProvider
// interface. ViewProvider will be used by the caller to create a view for the
// Frame. Note that these two operations must be done on the same/
// AsyncDispatcher in order to ensure that ServiceDirectory doesn't process
// incoming service requests before the service is published.
service_directory_ = std::make_unique<base::fuchsia::ServiceDirectory>(
std::move(startup_info.launch_info.directory_request));
view_provider_binding_ = std::make_unique<
base::fuchsia::ScopedServiceBinding<fuchsia::ui::viewsv1::ViewProvider>>(
service_directory_.get(), this);

return true;
}

WebRunnerBrowserContext::CreateZoomLevelDelegate(
    const base::FilePath& partition_path) {
  return nullptr;
}
