IMPEG2D_ERROR_CODES_T impeg2d_pre_pic_dec_proc(dec_state_t *ps_dec)
{
    WORD32 u4_get_disp;
 pic_buf_t *ps_disp_pic;
    IMPEG2D_ERROR_CODES_T e_error = (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;

    u4_get_disp = 0;
    ps_disp_pic = NULL;

 /* Field Picture */
 if(ps_dec->u2_picture_structure != FRAME_PICTURE)
 {
        ps_dec->u2_num_vert_mb       = (ps_dec->u2_vertical_size + 31) >> 5;

 if(ps_dec->u2_num_flds_decoded == 0)
 {
 pic_buf_t *ps_pic_buf;
            u4_get_disp = 1;

            ps_pic_buf = impeg2_buf_mgr_get_next_free(ps_dec->pv_pic_buf_mg, &ps_dec->i4_cur_buf_id);

 if (NULL == ps_pic_buf)
 {
 return IMPEG2D_NO_FREE_BUF_ERR;
 }

            impeg2_buf_mgr_set_status((buf_mgr_t *)ps_dec->pv_pic_buf_mg, ps_dec->i4_cur_buf_id, BUF_MGR_DISP);
            impeg2_buf_mgr_set_status((buf_mgr_t *)ps_dec->pv_pic_buf_mg, ps_dec->i4_cur_buf_id, BUF_MGR_REF);

            ps_pic_buf->u4_ts = ps_dec->u4_inp_ts;
            ps_pic_buf->e_pic_type = ps_dec->e_pic_type;
            ps_dec->ps_cur_pic = ps_pic_buf;
            ps_dec->s_cur_frm_buf.pu1_y = ps_pic_buf->pu1_y;
            ps_dec->s_cur_frm_buf.pu1_u = ps_pic_buf->pu1_u;
            ps_dec->s_cur_frm_buf.pu1_v = ps_pic_buf->pu1_v;
 }

 if(ps_dec->u2_picture_structure == TOP_FIELD)
 {
            ps_dec->u2_fld_parity = TOP;
 }
 else
 {
            ps_dec->u2_fld_parity = BOTTOM;
 }
        ps_dec->u2_field_dct           = 0;
        ps_dec->u2_read_dct_type        = 0;
        ps_dec->u2_read_motion_type     = 1;
        ps_dec->u2_fld_pic             = 1;
        ps_dec->u2_frm_pic             = 0;
        ps_dec->ps_func_forw_or_back     = gas_impeg2d_func_fld_fw_or_bk;
        ps_dec->ps_func_bi_direct       = gas_impeg2d_func_fld_bi_direct;
 }
 /* Frame Picture */
 else
 {
 pic_buf_t *ps_pic_buf;


        ps_dec->u2_num_vert_mb       = (ps_dec->u2_vertical_size + 15) >> 4;
        u4_get_disp = 1;
        ps_pic_buf = impeg2_buf_mgr_get_next_free(ps_dec->pv_pic_buf_mg, &ps_dec->i4_cur_buf_id);

 if (NULL == ps_pic_buf)
 {
 return IMPEG2D_NO_FREE_BUF_ERR;
 }
        impeg2_buf_mgr_set_status((buf_mgr_t *)ps_dec->pv_pic_buf_mg, ps_dec->i4_cur_buf_id, BUF_MGR_DISP);
        impeg2_buf_mgr_set_status((buf_mgr_t *)ps_dec->pv_pic_buf_mg, ps_dec->i4_cur_buf_id, BUF_MGR_REF);

        ps_pic_buf->u4_ts = ps_dec->u4_inp_ts;
        ps_pic_buf->e_pic_type = ps_dec->e_pic_type;
        ps_dec->ps_cur_pic = ps_pic_buf;
        ps_dec->s_cur_frm_buf.pu1_y = ps_pic_buf->pu1_y;
        ps_dec->s_cur_frm_buf.pu1_u = ps_pic_buf->pu1_u;
        ps_dec->s_cur_frm_buf.pu1_v = ps_pic_buf->pu1_v;


 if(ps_dec->u2_frame_pred_frame_dct == 0)
 {
            ps_dec->u2_read_dct_type    = 1;
            ps_dec->u2_read_motion_type = 1;
 }
 else
 {
            ps_dec->u2_read_dct_type    = 0;
            ps_dec->u2_read_motion_type = 0;
            ps_dec->u2_motion_type     = 2;
            ps_dec->u2_field_dct       = 0;
 }

        ps_dec->u2_fld_parity          = TOP;
        ps_dec->u2_fld_pic             = 0;
        ps_dec->u2_frm_pic             = 1;
        ps_dec->ps_func_forw_or_back     = gas_impeg2d_func_frm_fw_or_bk;
        ps_dec->ps_func_bi_direct       = gas_impeg2d_func_frm_bi_direct;
 }
    ps_dec->u2_def_dc_pred[Y_LUMA] = 128 << ps_dec->u2_intra_dc_precision;
    ps_dec->u2_def_dc_pred[U_CHROMA] = 128 << ps_dec->u2_intra_dc_precision;
    ps_dec->u2_def_dc_pred[V_CHROMA] = 128 << ps_dec->u2_intra_dc_precision;
    ps_dec->u2_num_mbs_left  = ps_dec->u2_num_horiz_mb * ps_dec->u2_num_vert_mb;
 if(u4_get_disp)
 {
 if(ps_dec->u4_num_frames_decoded > 1)
 {
            ps_disp_pic = impeg2_disp_mgr_get(&ps_dec->s_disp_mgr, &ps_dec->i4_disp_buf_id);
 }
        ps_dec->ps_disp_pic = ps_disp_pic;
 if(ps_disp_pic)
 {
 if(1 == ps_dec->u4_share_disp_buf)
 {
                ps_dec->ps_disp_frm_buf->pv_y_buf  = ps_disp_pic->pu1_y;
 if(IV_YUV_420P == ps_dec->i4_chromaFormat)
 {
                    ps_dec->ps_disp_frm_buf->pv_u_buf  = ps_disp_pic->pu1_u;
                    ps_dec->ps_disp_frm_buf->pv_v_buf  = ps_disp_pic->pu1_v;
 }
 else
 {
                    UWORD8 *pu1_buf;

                    pu1_buf = ps_dec->as_disp_buffers[ps_disp_pic->i4_buf_id].pu1_bufs[1];
                    ps_dec->ps_disp_frm_buf->pv_u_buf  = pu1_buf;

                    pu1_buf = ps_dec->as_disp_buffers[ps_disp_pic->i4_buf_id].pu1_bufs[2];
                    ps_dec->ps_disp_frm_buf->pv_v_buf  = pu1_buf;
 }
 }
 }
 }


 switch(ps_dec->e_pic_type)
 {
 case I_PIC:
 {
            ps_dec->pf_decode_slice = impeg2d_dec_i_slice;
 break;
 }
 case D_PIC:
 {
            ps_dec->pf_decode_slice = impeg2d_dec_d_slice;
 break;
 }
 case P_PIC:
 {
            ps_dec->pf_decode_slice = impeg2d_dec_p_b_slice;
            ps_dec->pu2_mb_type       = gau2_impeg2d_p_mb_type;
 break;
 }
 case B_PIC:
 {
            ps_dec->pf_decode_slice = impeg2d_dec_p_b_slice;
            ps_dec->pu2_mb_type       = gau2_impeg2d_b_mb_type;
 break;
 }
 default:
 return IMPEG2D_INVALID_PIC_TYPE;
 }

 /*************************************************************************/
 /* Set the reference pictures                                            */
 /*************************************************************************/

 /* Error resilience: If forward and backward pictures are going to be NULL*/
 /* then assign both to the current                                        */
 /* if one of them NULL then we will assign the non null to the NULL one   */

 if(ps_dec->e_pic_type == P_PIC)
 {
 if (NULL == ps_dec->as_recent_fld[1][0].pu1_y)
 {
            ps_dec->as_recent_fld[1][0] = ps_dec->s_cur_frm_buf;
 }
 if (NULL == ps_dec->as_recent_fld[1][1].pu1_y)
 {
            impeg2d_get_bottom_field_buf(&ps_dec->s_cur_frm_buf, &ps_dec->as_recent_fld[1][1],
                ps_dec->u2_frame_width);
 }

        ps_dec->as_ref_buf[FORW][TOP] = ps_dec->as_recent_fld[1][0];
        ps_dec->as_ref_buf[FORW][BOTTOM] = ps_dec->as_recent_fld[1][1];


 }
 else if(ps_dec->e_pic_type == B_PIC)
 {
 if((NULL == ps_dec->as_recent_fld[1][0].pu1_y) && (NULL == ps_dec->as_recent_fld[0][0].pu1_y))
 {
            ps_dec->as_recent_fld[1][0] = ps_dec->s_cur_frm_buf;
            impeg2d_get_bottom_field_buf(&ps_dec->s_cur_frm_buf, &ps_dec->as_recent_fld[1][1],
                ps_dec->u2_frame_width);
            ps_dec->as_recent_fld[0][0] = ps_dec->s_cur_frm_buf;
            ps_dec->as_recent_fld[0][1] = ps_dec->as_recent_fld[1][1];
 }
 else if ((NULL != ps_dec->as_recent_fld[1][0].pu1_y) && (NULL == ps_dec->as_recent_fld[0][0].pu1_y))
 {
            ps_dec->as_recent_fld[0][0] = ps_dec->as_recent_fld[1][0];
            ps_dec->as_recent_fld[0][1] = ps_dec->as_recent_fld[1][1];
 }
 else if ((NULL == ps_dec->as_recent_fld[1][0].pu1_y) && (NULL != ps_dec->as_recent_fld[0][0].pu1_y))
 {
            ps_dec->as_recent_fld[1][0] = ps_dec->as_recent_fld[0][0];
            ps_dec->as_recent_fld[1][1] = ps_dec->as_recent_fld[0][1];
 }

        ps_dec->as_ref_buf[FORW][TOP] = ps_dec->as_recent_fld[0][0];
        ps_dec->as_ref_buf[FORW][BOTTOM] = ps_dec->as_recent_fld[0][1];
        ps_dec->as_ref_buf[BACK][TOP] = ps_dec->as_recent_fld[1][0];
        ps_dec->as_ref_buf[BACK][BOTTOM] = ps_dec->as_recent_fld[1][1];


 }

 return e_error;
}

IMPEG2D_ERROR_CODES_T impeg2d_init_video_state(dec_state_t *ps_dec, e_video_type_t e_video_type)
{
 /*-----------------------------------------------------------------------*/
 /* Bit Stream  that conforms to MPEG-1 <ISO/IEC 11172-2> standard        */
 /*-----------------------------------------------------------------------*/
 if(e_video_type == MPEG_1_VIDEO)
 {
        ps_dec->u2_is_mpeg2 = 0;

 /*-------------------------------------------------------------------*/
 /* force MPEG-1 parameters for proper decoder behavior               */
 /* see ISO/IEC 13818-2 section D.9.14                                */
 /*-------------------------------------------------------------------*/
        ps_dec->u2_progressive_sequence         = 1;
        ps_dec->u2_intra_dc_precision           = 0;
        ps_dec->u2_picture_structure            = FRAME_PICTURE;
        ps_dec->u2_frame_pred_frame_dct         = 1;
        ps_dec->u2_concealment_motion_vectors   = 0;
        ps_dec->u2_q_scale_type                 = 0;
        ps_dec->u2_intra_vlc_format             = 0;
        ps_dec->u2_alternate_scan               = 0;
        ps_dec->u2_repeat_first_field           = 0;
        ps_dec->u2_progressive_frame            = 1;
        ps_dec->u2_frame_rate_extension_n       = 0;
        ps_dec->u2_frame_rate_extension_d       = 0;

        ps_dec->pf_vld_inv_quant                  = impeg2d_vld_inv_quant_mpeg1;
 /*-------------------------------------------------------------------*/
 /* Setting of parameters other than those mentioned in MPEG2 standard*/
 /* but used in decoding process.                                     */
 /*-------------------------------------------------------------------*/
 }
 /*-----------------------------------------------------------------------*/
 /* Bit Stream  that conforms to MPEG-2                                   */
 /*-----------------------------------------------------------------------*/
 else
 {
        ps_dec->u2_is_mpeg2                  = 1;
        ps_dec->u2_full_pel_forw_vector   = 0;
        ps_dec->u2_forw_f_code            = 7;
        ps_dec->u2_full_pel_back_vector   = 0;
        ps_dec->u2_back_f_code            = 7;
        ps_dec->pf_vld_inv_quant       = impeg2d_vld_inv_quant_mpeg2;


 }


    impeg2d_init_function_ptr(ps_dec);

 /* Set the frame Width and frame Height */
    ps_dec->u2_frame_height        = ALIGN16(ps_dec->u2_vertical_size);
    ps_dec->u2_frame_width         = ALIGN16(ps_dec->u2_horizontal_size);
    ps_dec->u2_num_horiz_mb         = (ps_dec->u2_horizontal_size + 15) >> 4;
 if (ps_dec->u2_frame_height > ps_dec->u2_create_max_height || ps_dec->u2_frame_width > ps_dec->u2_create_max_width)
 {
 return IMPEG2D_PIC_SIZE_NOT_SUPPORTED;
 }

    ps_dec->u2_num_flds_decoded = 0;

 /* Calculate the frame period */
 {
        UWORD32 numer;
        UWORD32 denom;
        numer = (UWORD32)gau2_impeg2_frm_rate_code[ps_dec->u2_frame_rate_code][1] *
 (UWORD32)(ps_dec->u2_frame_rate_extension_d + 1);

        denom = (UWORD32)gau2_impeg2_frm_rate_code[ps_dec->u2_frame_rate_code][0] *
 (UWORD32)(ps_dec->u2_frame_rate_extension_n + 1);
        ps_dec->u2_framePeriod = (numer * 1000 * 100) / denom;
 }


 if(VERTICAL_SCAN == ps_dec->u2_alternate_scan)
 {
    ps_dec->pu1_inv_scan_matrix = (UWORD8 *)gau1_impeg2_inv_scan_vertical;
 }
 else
 {
    ps_dec->pu1_inv_scan_matrix = (UWORD8 *)gau1_impeg2_inv_scan_zig_zag;
 }
 return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;
}

INLINE UWORD8 impeg2d_bit_stream_get_bit(stream_t *ps_stream)
{
UWORD32     u4_bit,u4_offset,u4_temp;
UWORD32     u4_curr_bit;

u4_offset               = ps_stream->u4_offset;
u4_curr_bit             = u4_offset & 0x1F;
u4_bit                  = ps_stream->u4_buf;

/* Move the current bit read from the current word to the
least significant bit positions of 'c'.*/
u4_bit                  >>= BITS_IN_INT - u4_curr_bit - 1;

u4_offset++;

/* If the last bit of the last word of the buffer has been read update
the currrent buf with next, and read next buf from bit stream buffer */

if (u4_curr_bit == 31)
{
ps_stream->u4_buf      = ps_stream->u4_buf_nxt;
        u4_temp             = *(ps_stream->pu4_buf_aligned)++;

        CONV_LE_TO_BE(ps_stream->u4_buf_nxt,u4_temp)
}
ps_stream->u4_offset          = u4_offset;

return (u4_bit & 0x1);
}

INLINE void impeg2d_bit_stream_flush(void* pv_ctxt, UWORD32 u4_no_of_bits)

{
stream_t *ps_stream = (stream_t *)pv_ctxt;

    FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)
return;
}

void impeg2d_post_pic_dec_proc(dec_state_t *ps_dec)
{

   WORD32 u4_update_pic_buf = 0;
 /*************************************************************************/
 /* Processing at the end of picture                                      */
 /*************************************************************************/
 if(ps_dec->u2_picture_structure != FRAME_PICTURE)
 {
        ps_dec->u2_num_vert_mb       = (ps_dec->u2_vertical_size + 31) >> 5;

 if(ps_dec->u2_num_flds_decoded == 1)
 {
            ps_dec->u2_num_flds_decoded = 0;
            u4_update_pic_buf = 1;
 }
 else
 {
            ps_dec->u2_num_flds_decoded = 1;
 }
 }
 else
 {
        u4_update_pic_buf = 1;
 }

 if(u4_update_pic_buf)
 {
        ps_dec->i4_frame_decoded = 1;
 if(ps_dec->e_pic_type != B_PIC)
 {
 /* In any sequence first two pictures have to be reference pictures */
 /* Adding of first picture in the sequence */
 if(ps_dec->aps_ref_pics[0] == NULL)
 {
                ps_dec->aps_ref_pics[0] = ps_dec->ps_cur_pic;
 }

 /* Adding of second picture in the sequence */
 else if(ps_dec->aps_ref_pics[1] == NULL)
 {
                ps_dec->aps_ref_pics[1] = ps_dec->ps_cur_pic;
                impeg2_disp_mgr_add(&ps_dec->s_disp_mgr, ps_dec->aps_ref_pics[0], ps_dec->aps_ref_pics[0]->i4_buf_id);
 }
 else
 {

                impeg2_disp_mgr_add(&ps_dec->s_disp_mgr, ps_dec->aps_ref_pics[1], ps_dec->aps_ref_pics[1]->i4_buf_id);
                impeg2_buf_mgr_release(ps_dec->pv_pic_buf_mg, ps_dec->aps_ref_pics[0]->i4_buf_id, BUF_MGR_REF);
                ps_dec->aps_ref_pics[0] = ps_dec->aps_ref_pics[1];
                ps_dec->aps_ref_pics[1] = ps_dec->ps_cur_pic;

 }
 }
 else
 {
            impeg2_disp_mgr_add(&ps_dec->s_disp_mgr, ps_dec->ps_cur_pic, ps_dec->ps_cur_pic->i4_buf_id);

            impeg2_buf_mgr_release(ps_dec->pv_pic_buf_mg, ps_dec->ps_cur_pic->i4_buf_id, BUF_MGR_REF);
 }

 }
 /*************************************************************************/
 /* Update the list of recent reference pictures                          */
 /*************************************************************************/
 if(ps_dec->e_pic_type != B_PIC)
 {
 switch(ps_dec->u2_picture_structure)
 {
 case FRAME_PICTURE:
 {
                ps_dec->as_recent_fld[0][0] = ps_dec->as_recent_fld[1][0];
                ps_dec->as_recent_fld[0][1] = ps_dec->as_recent_fld[1][1];

                ps_dec->as_recent_fld[1][0] = ps_dec->s_cur_frm_buf;
                impeg2d_get_bottom_field_buf(&ps_dec->s_cur_frm_buf, &ps_dec->as_recent_fld[1][1],
                ps_dec->u2_frame_width);
 break;
 }
 case TOP_FIELD:
 {
                ps_dec->as_recent_fld[0][0] = ps_dec->as_recent_fld[1][0];
                ps_dec->as_recent_fld[1][0] = ps_dec->s_cur_frm_buf;
 break;
 }
 case BOTTOM_FIELD:
 {
                ps_dec->as_recent_fld[0][1] = ps_dec->as_recent_fld[1][1];
                impeg2d_get_bottom_field_buf(&ps_dec->s_cur_frm_buf, &ps_dec->as_recent_fld[1][1],
                ps_dec->u2_frame_width);
 break;
 }
 }
 }
}

UWORD16 impeg2d_get_mb_addr_incr(stream_t *ps_stream)
{
UWORD16 u2_mb_addr_incr = 0;
    while (impeg2d_bit_stream_nxt(ps_stream,MB_ESCAPE_CODE_LEN) == MB_ESCAPE_CODE)
{
impeg2d_bit_stream_flush(ps_stream,MB_ESCAPE_CODE_LEN);
u2_mb_addr_incr += 33;
}
u2_mb_addr_incr += impeg2d_dec_vld_symbol(ps_stream,gai2_impeg2d_mb_addr_incr,MB_ADDR_INCR_LEN) +
MB_ADDR_INCR_OFFSET;
return(u2_mb_addr_incr);
}

IMPEG2D_ERROR_CODES_T impeg2d_dec_pic_hdr(dec_state_t *ps_dec)
{
stream_t *ps_stream;
ps_stream = &ps_dec->s_bit_stream;

impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);
/* Flush temporal reference */
impeg2d_bit_stream_get(ps_stream,10);

/* Picture type */
ps_dec->e_pic_type = (e_pic_type_t)impeg2d_bit_stream_get(ps_stream,3);
if((ps_dec->e_pic_type < I_PIC) || (ps_dec->e_pic_type > D_PIC))
{
impeg2d_next_code(ps_dec, PICTURE_START_CODE);
return IMPEG2D_INVALID_PIC_TYPE;
}

/* Flush vbv_delay */
impeg2d_bit_stream_get(ps_stream,16);

if(ps_dec->e_pic_type == P_PIC || ps_dec->e_pic_type == B_PIC)
{
ps_dec->u2_full_pel_forw_vector = impeg2d_bit_stream_get_bit(ps_stream);
ps_dec->u2_forw_f_code          = impeg2d_bit_stream_get(ps_stream,3);
}
if(ps_dec->e_pic_type == B_PIC)
{
ps_dec->u2_full_pel_back_vector = impeg2d_bit_stream_get_bit(ps_stream);
ps_dec->u2_back_f_code          = impeg2d_bit_stream_get(ps_stream,3);
}

if(ps_dec->u2_is_mpeg2 == 0)
{
ps_dec->au2_f_code[0][0] = ps_dec->au2_f_code[0][1] = ps_dec->u2_forw_f_code;
ps_dec->au2_f_code[1][0] = ps_dec->au2_f_code[1][1] = ps_dec->u2_back_f_code;
}

/*-----------------------------------------------------------------------*/
/*  Flush the extra bit value                                            */
/*                                                                       */
/*  while(impeg2d_bit_stream_nxt() == '1')                                  */
/*  {                                                                    */
/*      extra_bit_picture         1                                      */
/*      extra_information_picture 8                                      */

/*  }                                                                    */
/*  extra_bit_picture             1                                      */
/*-----------------------------------------------------------------------*/
    while (impeg2d_bit_stream_nxt(ps_stream,1) == 1)
{
impeg2d_bit_stream_get(ps_stream,9);
}
impeg2d_bit_stream_get_bit(ps_stream);
impeg2d_next_start_code(ps_dec);

return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;
}

void impeg2d_next_code(dec_state_t *ps_dec, UWORD32 u4_start_code_val)
{
stream_t *ps_stream;

ps_stream = &ps_dec->s_bit_stream;
impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);

    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val)
        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))
{

if (impeg2d_bit_stream_get(ps_stream,8) != 0)
{
/* Ignore stuffing bit errors. */
}

}
return;
}

void impeg2d_dec_user_data(dec_state_t *ps_dec)
{
UWORD32 u4_start_code;
stream_t *ps_stream;

ps_stream    = &ps_dec->s_bit_stream;
u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);


while(u4_start_code == USER_DATA_START_CODE)
{
impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);
        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)
{
impeg2d_bit_stream_flush(ps_stream,8);
}
u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
}
}

void impeg2d_dec_pic_data_thread(dec_state_t *ps_dec)
{
    WORD32 i4_continue_decode;

    WORD32 i4_cur_row, temp;
    UWORD32 u4_bits_read;
    WORD32 i4_dequeue_job;
    IMPEG2D_ERROR_CODES_T e_error;

    i4_cur_row = ps_dec->u2_mb_y + 1;

    i4_continue_decode = 1;

    i4_dequeue_job = 1;
 do
 {
 if(i4_cur_row > ps_dec->u2_num_vert_mb)
 {
            i4_continue_decode = 0;
 break;
 }

 {
 if((ps_dec->i4_num_cores> 1) && (i4_dequeue_job))
 {
 job_t s_job;
                IV_API_CALL_STATUS_T e_ret;
                UWORD8 *pu1_buf;

                e_ret = impeg2_jobq_dequeue(ps_dec->pv_jobq, &s_job, sizeof(s_job), 1, 1);
 if(e_ret != IV_SUCCESS)
 break;

 if(CMD_PROCESS == s_job.i4_cmd)
 {
                    pu1_buf = ps_dec->pu1_inp_bits_buf + s_job.i4_bistream_ofst;
                    impeg2d_bit_stream_init(&(ps_dec->s_bit_stream), pu1_buf,
 (ps_dec->u4_num_inp_bytes - s_job.i4_bistream_ofst) + 8);
                    i4_cur_row      = s_job.i2_start_mb_y;
                    ps_dec->i4_start_mb_y = s_job.i2_start_mb_y;
                    ps_dec->i4_end_mb_y = s_job.i2_end_mb_y;
                    ps_dec->u2_mb_x = 0;
                    ps_dec->u2_mb_y = ps_dec->i4_start_mb_y;
                    ps_dec->u2_num_mbs_left = (ps_dec->i4_end_mb_y - ps_dec->i4_start_mb_y) * ps_dec->u2_num_horiz_mb;

 }
 else
 {
                    WORD32 start_row;
                    WORD32 num_rows;
                    start_row = s_job.i2_start_mb_y << 4;
                    num_rows = MIN((s_job.i2_end_mb_y << 4), ps_dec->u2_vertical_size);
                    num_rows -= start_row;
                    impeg2d_format_convert(ps_dec, ps_dec->ps_disp_pic,
                                        ps_dec->ps_disp_frm_buf,
                                        start_row, num_rows);
 break;

 }

 }
            e_error = impeg2d_dec_slice(ps_dec);

 if ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE != e_error)
 {
                impeg2d_next_start_code(ps_dec);
 }
 }

 /* Detecting next slice start code */
 while(1)
 {
            u4_bits_read = impeg2d_bit_stream_nxt(&ps_dec->s_bit_stream,START_CODE_LEN);
            temp = u4_bits_read & 0xFF;
            i4_continue_decode = (((u4_bits_read >> 8) == 0x01) && (temp) && (temp <= 0xAF));

 if(i4_continue_decode)
 {
 /* If the slice is from the same row, then continue decoding without dequeue */
 if((temp - 1) == i4_cur_row)
 {
                    i4_dequeue_job = 0;
 break;
 }

 if(temp < ps_dec->i4_end_mb_y)
 {
                    i4_cur_row = ps_dec->u2_mb_y;
 }
 else
 {
                    i4_dequeue_job = 1;
 }
 break;

 }
 else
 break;
 }

 }while(i4_continue_decode);
 if(ps_dec->i4_num_cores > 1)
 {
 while(1)
 {
 job_t s_job;
            IV_API_CALL_STATUS_T e_ret;

            e_ret = impeg2_jobq_dequeue(ps_dec->pv_jobq, &s_job, sizeof(s_job), 1, 1);
 if(e_ret != IV_SUCCESS)
 break;
 if(CMD_FMTCONV == s_job.i4_cmd)
 {
                WORD32 start_row;
                WORD32 num_rows;
                start_row = s_job.i2_start_mb_y << 4;
                num_rows = MIN((s_job.i2_end_mb_y << 4), ps_dec->u2_vertical_size);
                num_rows -= start_row;
                impeg2d_format_convert(ps_dec, ps_dec->ps_disp_pic,
                                    ps_dec->ps_disp_frm_buf,
                                    start_row, num_rows);
 }
 }
 }
 else
 {
 if((NULL != ps_dec->ps_disp_pic) && ((0 == ps_dec->u4_share_disp_buf) || (IV_YUV_420P != ps_dec->i4_chromaFormat)))
            impeg2d_format_convert(ps_dec, ps_dec->ps_disp_pic,
                            ps_dec->ps_disp_frm_buf,
 0, ps_dec->u2_vertical_size);
 }
}

IMPEG2D_ERROR_CODES_T impeg2d_dec_slice(dec_state_t *ps_dec)
{
stream_t *ps_stream;
UWORD32 u4_slice_vertical_position;
UWORD32 u4_slice_vertical_position_extension;
IMPEG2D_ERROR_CODES_T e_error;

ps_stream = &ps_dec->s_bit_stream;

/*------------------------------------------------------------------------*/
/* All the profiles supported require restricted slice structure. Hence   */
/* there is no need to store slice_vertical_position. Note that max       */
/* height supported does not exceed 2800 and scalablity is not supported  */
/*------------------------------------------------------------------------*/

/* Remove the slice start code */
impeg2d_bit_stream_flush(ps_stream,START_CODE_PREFIX_LEN);
u4_slice_vertical_position = impeg2d_bit_stream_get(ps_stream, 8);
if(u4_slice_vertical_position > 2800)
{
u4_slice_vertical_position_extension = impeg2d_bit_stream_get(ps_stream, 3);
u4_slice_vertical_position += (u4_slice_vertical_position_extension << 7);
}

if((u4_slice_vertical_position > ps_dec->u2_num_vert_mb) ||
(u4_slice_vertical_position == 0))
{
return IMPEG2D_INVALID_VERT_SIZE;
}

// change the mb_y to point to slice_vertical_position
u4_slice_vertical_position--;
if (ps_dec->u2_mb_y != u4_slice_vertical_position)
{
ps_dec->u2_mb_y    = u4_slice_vertical_position;
ps_dec->u2_mb_x    = 0;
}
ps_dec->u2_first_mb = 1;

/*------------------------------------------------------------------------*/
/* Quant scale code decoding                                              */
/*------------------------------------------------------------------------*/
{
UWORD16 u2_quant_scale_code;
u2_quant_scale_code = impeg2d_bit_stream_get(ps_stream,5);
ps_dec->u1_quant_scale = (ps_dec->u2_q_scale_type) ?
gau1_impeg2_non_linear_quant_scale[u2_quant_scale_code] : (u2_quant_scale_code << 1);
}

if (impeg2d_bit_stream_nxt(ps_stream,1) == 1)

{
impeg2d_bit_stream_flush(ps_stream,9);
/* Flush extra bit information */
        while (impeg2d_bit_stream_nxt(ps_stream,1) == 1)
{
impeg2d_bit_stream_flush(ps_stream,9);
}
}
impeg2d_bit_stream_get_bit(ps_stream);

/* Reset the DC predictors to reset values given in Table 7.2 at the start*/
/* of slice data */
ps_dec->u2_def_dc_pred[Y_LUMA] = 128 << ps_dec->u2_intra_dc_precision;
ps_dec->u2_def_dc_pred[U_CHROMA] = 128 << ps_dec->u2_intra_dc_precision;
ps_dec->u2_def_dc_pred[V_CHROMA] = 128 << ps_dec->u2_intra_dc_precision;
/*------------------------------------------------------------------------*/
/* dec->DecMBsinSlice() implements the following psuedo code from standard*/
/* do                                                                     */
/* {                                                                      */
/*      macroblock()                                                      */
/* } while (impeg2d_bit_stream_nxt() != '000 0000 0000 0000 0000 0000')      */
/*------------------------------------------------------------------------*/

e_error = ps_dec->pf_decode_slice(ps_dec);
if ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE != e_error)
{
return e_error;
}

/* Check for the MBy index instead of number of MBs left, because the
* number of MBs left in case of multi-thread decode is the number of MBs
* in that row only
*/
if(ps_dec->u2_mb_y < ps_dec->u2_num_vert_mb)
impeg2d_next_start_code(ps_dec);

return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;
}

WORD16  impeg2d_get_luma_dc_diff(stream_t *ps_stream)
{
    UWORD16 u2_dc_size;
    WORD16  i2_dc_diff;

    u2_dc_size = impeg2d_dec_vld_symbol(ps_stream,gai2_impeg2d_dct_dc_size[0],
                        MPEG2_DCT_DC_LUMA_SIZE_LEN) +
                        MPEG2_DCT_DC_SIZE_OFFSET;
 if (u2_dc_size != 0)
 {
        i2_dc_diff = impeg2d_bit_stream_get(ps_stream,u2_dc_size);
 if ((i2_dc_diff & (1 << (u2_dc_size - 1))) == 0)
            i2_dc_diff -= (1 << u2_dc_size) - 1;
 }
 else
 {
        i2_dc_diff = 0;
 }
 return i2_dc_diff;
}

void impeg2d_get_frm_buf(yuv_buf_t *ps_frm_buf,UWORD8 *pu1_frm,UWORD32 u4_width,UWORD32 u4_height)
{
   UWORD32 u4_luma_size = u4_width * u4_height;
   UWORD32 u4_chroma_size = (u4_width * u4_height)>>2;

   ps_frm_buf->pu1_y = pu1_frm;
   ps_frm_buf->pu1_u = pu1_frm + u4_luma_size;
   ps_frm_buf->pu1_v = pu1_frm + u4_luma_size + u4_chroma_size;

}

IMPEG2D_ERROR_CODES_T impeg2d_dec_d_slice(dec_state_t *ps_dec)
{
UWORD32 i;
yuv_buf_t *ps_cur_frm_buf  = &ps_dec->s_cur_frm_buf;

stream_t *ps_stream       = &ps_dec->s_bit_stream;
UWORD8   *pu1_vld_buf;

WORD16 i2_dc_diff;
UWORD32 u4_frame_width = ps_dec->u2_frame_width;
UWORD32 u4_frm_offset = 0;
if(ps_dec->u2_picture_structure != FRAME_PICTURE)
{
u4_frame_width <<= 1;
if(ps_dec->u2_picture_structure == BOTTOM_FIELD)
{
u4_frm_offset = ps_dec->u2_frame_width;
}
}

do
{

UWORD32 u4_x_offset, u4_y_offset;
UWORD32 u4_blk_pos;
WORD16 i2_dc_val;

UWORD32 u4_dst_x_offset     = u4_frm_offset + (ps_dec->u2_mb_x << 4);
UWORD32 u4_dst_y_offset     = (ps_dec->u2_mb_y << 4) * u4_frame_width;
UWORD8 *pu1_vld_buf8        = ps_cur_frm_buf->pu1_y + u4_dst_x_offset + u4_dst_y_offset;
UWORD32 u4_dst_wd           = u4_frame_width;

/*------------------------------------------------------------------*/
/* Discard the Macroblock stuffing in case of MPEG-1 stream         */
/*------------------------------------------------------------------*/
        while(impeg2d_bit_stream_nxt(ps_stream,MB_STUFFING_CODE_LEN) == MB_STUFFING_CODE)
impeg2d_bit_stream_flush(ps_stream,MB_STUFFING_CODE_LEN);

/*------------------------------------------------------------------*/
/* Flush 2 bits from bitstream [MB_Type and MacroBlockAddrIncrement]*/
/*------------------------------------------------------------------*/
impeg2d_bit_stream_flush(ps_stream,1);

if(impeg2d_bit_stream_get(ps_stream, 1) != 0x01)
{
/* Ignore and continue decoding. */
}

/* Process LUMA blocks of the MB */
for(i = 0; i < NUM_LUMA_BLKS; ++i)
{

u4_x_offset    = gai2_impeg2_blk_x_off[i];
u4_y_offset    = gai2_impeg2_blk_y_off_frm[i] ;
u4_blk_pos     = (u4_y_offset * u4_dst_wd) + u4_x_offset;
pu1_vld_buf     = pu1_vld_buf8 + u4_blk_pos;

i2_dc_diff = impeg2d_get_luma_dc_diff(ps_stream);
i2_dc_val = ps_dec->u2_def_dc_pred[Y_LUMA] + i2_dc_diff;
ps_dec->u2_def_dc_pred[Y_LUMA] = i2_dc_val;
i2_dc_val = CLIP_U8(i2_dc_val);

ps_dec->pf_memset_8bit_8x8_block(pu1_vld_buf, i2_dc_val, u4_dst_wd);
}



/* Process U block of the MB */

u4_dst_x_offset                >>= 1;
u4_dst_y_offset                >>= 2;
u4_dst_wd                      >>= 1;
pu1_vld_buf                     = ps_cur_frm_buf->pu1_u + u4_dst_x_offset + u4_dst_y_offset;
i2_dc_diff                     = impeg2d_get_chroma_dc_diff(ps_stream);
i2_dc_val                      = ps_dec->u2_def_dc_pred[U_CHROMA] + i2_dc_diff;
ps_dec->u2_def_dc_pred[U_CHROMA] = i2_dc_val;
i2_dc_val = CLIP_U8(i2_dc_val);
ps_dec->pf_memset_8bit_8x8_block(pu1_vld_buf, i2_dc_val, u4_dst_wd);


/* Process V block of the MB */

pu1_vld_buf                     = ps_cur_frm_buf->pu1_v + u4_dst_x_offset + u4_dst_y_offset;
i2_dc_diff                     = impeg2d_get_chroma_dc_diff(ps_stream);
i2_dc_val                      = ps_dec->u2_def_dc_pred[V_CHROMA] + i2_dc_diff;
ps_dec->u2_def_dc_pred[V_CHROMA] = i2_dc_val;
i2_dc_val = CLIP_U8(i2_dc_val);
ps_dec->pf_memset_8bit_8x8_block(pu1_vld_buf, i2_dc_val, u4_dst_wd);

/* Common MB processing Steps */


ps_dec->u2_num_mbs_left--;
ps_dec->u2_mb_x++;

if(ps_dec->s_bit_stream.u4_offset > ps_dec->s_bit_stream.u4_max_offset)
{
return IMPEG2D_BITSTREAM_BUFF_EXCEEDED_ERR;
}
else if (ps_dec->u2_mb_x == ps_dec->u2_num_horiz_mb)
{
ps_dec->u2_mb_x = 0;
ps_dec->u2_mb_y++;

}

/* Flush end of macro block */
impeg2d_bit_stream_flush(ps_stream,1);
}
while(ps_dec->u2_num_mbs_left != 0 && impeg2d_bit_stream_nxt(&ps_dec->s_bit_stream,23) != 0x0);
return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;
}/* End of impeg2d_dec_d_slice() */

void impeg2d_peek_next_start_code(dec_state_t *ps_dec)
{
stream_t *ps_stream;
ps_stream = &ps_dec->s_bit_stream;

impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);

while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)
        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))
{
impeg2d_bit_stream_get(ps_stream,8);
}
return;
}

WORD16  impeg2d_get_chroma_dc_diff(stream_t *ps_stream)
{
    UWORD16 u2_dc_size;
    WORD16  i2_dc_diff;
    u2_dc_size = impeg2d_dec_vld_symbol(ps_stream,gai2_impeg2d_dct_dc_size[1],
                        MPEG2_DCT_DC_CHROMA_SIZE_LEN) +
                        MPEG2_DCT_DC_SIZE_OFFSET;
 if (u2_dc_size != 0)
 {
        i2_dc_diff = impeg2d_bit_stream_get(ps_stream,u2_dc_size);
 if ((i2_dc_diff & (1 << (u2_dc_size - 1))) == 0)
            i2_dc_diff -= (1 << u2_dc_size) - 1;
 }
 else
 {
        i2_dc_diff = 0;
 }
 return i2_dc_diff;
}

WORD32 impeg2d_get_slice_pos(dec_state_multi_core_t *ps_dec_state_multi_core)
{
    WORD32 u4_bits;
    WORD32 i4_row;


 dec_state_t *ps_dec = ps_dec_state_multi_core->ps_dec_state[0];
    WORD32 i4_prev_row;
 stream_t s_bitstrm;
    WORD32 i4_start_row;
    WORD32 i4_slice_bistream_ofst;
    WORD32 i;
    s_bitstrm = ps_dec->s_bit_stream;
    i4_prev_row = -1;

    ps_dec_state_multi_core->ps_dec_state[0]->i4_start_mb_y = 0;
    ps_dec_state_multi_core->ps_dec_state[1]->i4_start_mb_y = -1;
    ps_dec_state_multi_core->ps_dec_state[2]->i4_start_mb_y = -1;
    ps_dec_state_multi_core->ps_dec_state[3]->i4_start_mb_y = -1;

    ps_dec_state_multi_core->ps_dec_state[0]->i4_end_mb_y = ps_dec->u2_num_vert_mb;
    ps_dec_state_multi_core->ps_dec_state[1]->i4_end_mb_y = -1;
    ps_dec_state_multi_core->ps_dec_state[2]->i4_end_mb_y = -1;
    ps_dec_state_multi_core->ps_dec_state[3]->i4_end_mb_y = -1;

 if(ps_dec->i4_num_cores == 1)
 return 0;
 /* Reset the jobq to start of the jobq buffer */
    impeg2_jobq_reset((jobq_t *)ps_dec->pv_jobq);

    i4_start_row = -1;
    i4_slice_bistream_ofst = 0;
 while(1)
 {
        WORD32 i4_is_slice;

 if(s_bitstrm.u4_offset + START_CODE_LEN >= s_bitstrm.u4_max_offset)
 {
 break;
 }
        u4_bits = impeg2d_bit_stream_nxt(&s_bitstrm,START_CODE_LEN);

        i4_row = u4_bits & 0xFF;

 /* Detect end of frame */
        i4_is_slice = (((u4_bits >> 8) == 0x01) && (i4_row) && (i4_row <= ps_dec->u2_num_vert_mb));
 if(!i4_is_slice)
 break;

        i4_row -= 1;


 if(i4_prev_row != i4_row)
 {
 /* Create a job for previous slice row */
 if(i4_start_row != -1)
 {
 job_t s_job;
                IV_API_CALL_STATUS_T ret;
                s_job.i2_start_mb_y = i4_start_row;
                s_job.i2_end_mb_y = i4_row;
                s_job.i4_cmd = CMD_PROCESS;
                s_job.i4_bistream_ofst = i4_slice_bistream_ofst;
                ret = impeg2_jobq_queue(ps_dec->pv_jobq, &s_job, sizeof(s_job), 1, 0);
 if(ret != IV_SUCCESS)
 return ret;

 }
 /* Store current slice's bitstream offset */
            i4_slice_bistream_ofst = s_bitstrm.u4_offset >> 3;
            i4_slice_bistream_ofst -= (size_t)s_bitstrm.pv_bs_buf & 3;
            i4_prev_row = i4_row;

 /* Store current slice's row position */
            i4_start_row = i4_row;

 }


        impeg2d_bit_stream_flush(&s_bitstrm, START_CODE_LEN);

 /* Flush the bytes till a  start code is encountered  */
 while(impeg2d_bit_stream_nxt(&s_bitstrm, 24) != START_CODE_PREFIX)
 {
            impeg2d_bit_stream_get(&s_bitstrm, 8);

 if(s_bitstrm.u4_offset >= s_bitstrm.u4_max_offset)
 {
 break;
 }
 }
 }

 /* Create job for the last slice row */
 {
 job_t s_job;
        IV_API_CALL_STATUS_T e_ret;
        s_job.i2_start_mb_y = i4_start_row;
        s_job.i2_end_mb_y = ps_dec->u2_num_vert_mb;
        s_job.i4_cmd = CMD_PROCESS;
        s_job.i4_bistream_ofst = i4_slice_bistream_ofst;
        e_ret = impeg2_jobq_queue(ps_dec->pv_jobq, &s_job, sizeof(s_job), 1, 0);
 if(e_ret != IV_SUCCESS)
 return e_ret;

 }
 if((NULL != ps_dec->ps_disp_pic) && ((0 == ps_dec->u4_share_disp_buf) || (IV_YUV_420P != ps_dec->i4_chromaFormat)))
 {
 for(i = 0; i < ps_dec->u2_vertical_size; i+=64)
 {
 job_t s_job;
            IV_API_CALL_STATUS_T ret;
            s_job.i2_start_mb_y = i;
            s_job.i2_start_mb_y >>= 4;
            s_job.i2_end_mb_y = (i + 64);
            s_job.i2_end_mb_y >>= 4;
            s_job.i4_cmd = CMD_FMTCONV;
            s_job.i4_bistream_ofst = 0;
            ret = impeg2_jobq_queue(ps_dec->pv_jobq, &s_job, sizeof(s_job), 1, 0);
 if(ret != IV_SUCCESS)
 return ret;

 }
 }

    impeg2_jobq_terminate(ps_dec->pv_jobq);
    ps_dec->i4_bytes_consumed = s_bitstrm.u4_offset >> 3;
    ps_dec->i4_bytes_consumed -= ((size_t)s_bitstrm.pv_bs_buf & 3);

 return 0;
}

IMPEG2D_ERROR_CODES_T impeg2d_dec_pic_ext_data(dec_state_t *ps_dec)
{
stream_t *ps_stream;
UWORD32     u4_start_code;
IMPEG2D_ERROR_CODES_T e_error;

e_error = (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;

ps_stream      = &ps_dec->s_bit_stream;

u4_start_code   = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
while ( (u4_start_code == EXTENSION_START_CODE ||
u4_start_code == USER_DATA_START_CODE) &&
            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)
{
if(u4_start_code == USER_DATA_START_CODE)
{
impeg2d_dec_user_data(ps_dec);
}
else
{
impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);
u4_start_code   = impeg2d_bit_stream_nxt(ps_stream,EXT_ID_LEN);
switch(u4_start_code)
{
case QUANT_MATRIX_EXT_ID:
impeg2d_dec_quant_matrix_ext(ps_dec);
break;
case COPYRIGHT_EXT_ID:
impeg2d_dec_copyright_ext(ps_dec);
break;
case PIC_DISPLAY_EXT_ID:
impeg2d_dec_pic_disp_ext(ps_dec);
break;
case CAMERA_PARAM_EXT_ID:
impeg2d_dec_cam_param_ext(ps_dec);
break;
case ITU_T_EXT_ID:
impeg2d_dec_itu_t_ext(ps_dec);
break;
case PIC_SPATIAL_SCALABLE_EXT_ID:
case PIC_TEMPORAL_SCALABLE_EXT_ID:
e_error = IMPEG2D_SCALABLITY_NOT_SUP;
break;
default:
/* In case its a reserved extension code */
impeg2d_bit_stream_flush(ps_stream,EXT_ID_LEN);
impeg2d_next_start_code(ps_dec);
break;
}
}
u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
}
return e_error;
}

IMPEG2D_ERROR_CODES_T impeg2d_dec_seq_ext_data(dec_state_t *ps_dec)
{
stream_t *ps_stream;
UWORD32     u4_start_code;
IMPEG2D_ERROR_CODES_T e_error;

e_error = (IMPEG2D_ERROR_CODES_T) IVD_ERROR_NONE;

ps_stream      = &ps_dec->s_bit_stream;

u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
while( (u4_start_code == EXTENSION_START_CODE ||
u4_start_code == USER_DATA_START_CODE) &&
            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)
{
if(u4_start_code == USER_DATA_START_CODE)
{
impeg2d_dec_user_data(ps_dec);
}
else
{
impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);
u4_start_code   = impeg2d_bit_stream_nxt(ps_stream,EXT_ID_LEN);
switch(u4_start_code)
{
case SEQ_DISPLAY_EXT_ID:
impeg2d_dec_seq_disp_ext(ps_dec);
break;
case SEQ_SCALABLE_EXT_ID:
e_error = IMPEG2D_SCALABILITIY_NOT_SUPPORTED;
break;
default:
/* In case its a reserved extension code */
impeg2d_bit_stream_flush(ps_stream,EXT_ID_LEN);
impeg2d_peek_next_start_code(ps_dec);
break;
}
}
u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
}
return e_error;
}
