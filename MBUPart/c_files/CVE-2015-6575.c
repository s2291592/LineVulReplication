status_t SampleTable::findThumbnailSample(uint32_t *sample_index) {
 Mutex::Autolock autoLock(mLock);

 if (mSyncSampleOffset < 0) {
 *sample_index = 0;
 return OK;
 }

 uint32_t bestSampleIndex = 0;
 size_t maxSampleSize = 0;

 static const size_t kMaxNumSyncSamplesToScan = 20;


 size_t numSamplesToScan = mNumSyncSamples;
 if (numSamplesToScan > kMaxNumSyncSamplesToScan) {
        numSamplesToScan = kMaxNumSyncSamplesToScan;
 }

 for (size_t i = 0; i < numSamplesToScan; ++i) {
 uint32_t x = mSyncSamples[i];

 size_t sampleSize;
 status_t err = getSampleSize_l(x, &sampleSize);
 if (err != OK) {
 return err;
 }

 if (i == 0 || sampleSize > maxSampleSize) {
            bestSampleIndex = x;
            maxSampleSize = sampleSize;
 }
 }

 *sample_index = bestSampleIndex;

 return OK;
}

status_t SampleTable::setSyncSampleParams(off64_t data_offset, size_t data_size) {
if (mSyncSampleOffset >= 0 || data_size < 8) {
return ERROR_MALFORMED;
}

mSyncSampleOffset = data_offset;

uint8_t header[8];
if (mDataSource->readAt(
data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {
return ERROR_IO;
}

if (U32_AT(header) != 0) {
// Expected version = 0, flags = 0.
return ERROR_MALFORMED;
}

mNumSyncSamples = U32_AT(&header[4]);

if (mNumSyncSamples < 2) {

ALOGV("Table of sync samples is empty or has only a single entry!");
}

    uint64_t allocSize = mNumSyncSamples * sizeof(uint32_t);
if (allocSize > SIZE_MAX) {
return ERROR_OUT_OF_RANGE;
}

mSyncSamples = new uint32_t[mNumSyncSamples];
size_t size = mNumSyncSamples * sizeof(uint32_t);
if (mDataSource->readAt(mSyncSampleOffset + 8, mSyncSamples, size)
!= (ssize_t)size) {
return ERROR_IO;
}

for (size_t i = 0; i < mNumSyncSamples; ++i) {
mSyncSamples[i] = ntohl(mSyncSamples[i]) - 1;
}

return OK;
}

SampleTable::~SampleTable() {
 delete[] mSampleToChunkEntries;
    mSampleToChunkEntries = NULL;

 delete[] mSyncSamples;
    mSyncSamples = NULL;

 delete mCompositionDeltaLookup;
    mCompositionDeltaLookup = NULL;

 delete[] mCompositionTimeDeltaEntries;
    mCompositionTimeDeltaEntries = NULL;

 delete[] mSampleTimeEntries;
    mSampleTimeEntries = NULL;

 delete[] mTimeToSample;
    mTimeToSample = NULL;

 delete mSampleIterator;
    mSampleIterator = NULL;
}

void SampleTable::buildSampleEntriesTable() {
 Mutex::Autolock autoLock(mLock);

 if (mSampleTimeEntries != NULL) {
 return;
 }

    mSampleTimeEntries = new SampleTimeEntry[mNumSampleSizes];

 uint32_t sampleIndex = 0;
 uint32_t sampleTime = 0;

 for (uint32_t i = 0; i < mTimeToSampleCount; ++i) {
 uint32_t n = mTimeToSample[2 * i];
 uint32_t delta = mTimeToSample[2 * i + 1];

 for (uint32_t j = 0; j < n; ++j) {
 if (sampleIndex < mNumSampleSizes) {

                mSampleTimeEntries[sampleIndex].mSampleIndex = sampleIndex;

 uint32_t compTimeDelta =
                    mCompositionDeltaLookup->getCompositionTimeOffset(
                            sampleIndex);

                mSampleTimeEntries[sampleIndex].mCompositionTime =
                    sampleTime + compTimeDelta;
 }

 ++sampleIndex;
            sampleTime += delta;
 }
 }

    qsort(mSampleTimeEntries, mNumSampleSizes, sizeof(SampleTimeEntry),
 CompareIncreasingTime);
}

status_t SampleTable::findSyncSampleNear(
 uint32_t start_sample_index, uint32_t *sample_index, uint32_t flags) {
 Mutex::Autolock autoLock(mLock);

 *sample_index = 0;

 if (mSyncSampleOffset < 0) {
 *sample_index = start_sample_index;
 return OK;
 }

 if (mNumSyncSamples == 0) {
 *sample_index = 0;
 return OK;
 }

 uint32_t left = 0;
 uint32_t right_plus_one = mNumSyncSamples;
 while (left < right_plus_one) {
 uint32_t center = left + (right_plus_one - left) / 2;
 uint32_t x = mSyncSamples[center];

 if (start_sample_index < x) {
            right_plus_one = center;
 } else if (start_sample_index > x) {
            left = center + 1;
 } else {
 *sample_index = x;
 return OK;
 }
 }

 if (left == mNumSyncSamples) {
 if (flags == kFlagAfter) {
            ALOGE("tried to find a sync frame after the last one: %d", left);
 return ERROR_OUT_OF_RANGE;
 }
        flags = kFlagBefore;
 }
 else if (left == 0) {
 if (flags == kFlagBefore) {
            ALOGE("tried to find a sync frame before the first one: %d", left);

 }
        flags = kFlagAfter;
 }

 switch (flags) {
 case kFlagBefore:
 {
 --left;
 break;
 }
 case kFlagAfter:
 {
 break;
 }
 default:
 {
            CHECK(flags == kFlagClosest);

 status_t err = mSampleIterator->seekTo(start_sample_index);
 if (err != OK) {
 return err;
 }
 uint32_t sample_time = mSampleIterator->getSampleTime();

            err = mSampleIterator->seekTo(mSyncSamples[left]);
 if (err != OK) {
 return err;
 }
 uint32_t upper_time = mSampleIterator->getSampleTime();

            err = mSampleIterator->seekTo(mSyncSamples[left - 1]);
 if (err != OK) {
 return err;
 }
 uint32_t lower_time = mSampleIterator->getSampleTime();

 if (abs_difference(upper_time, sample_time) >
                abs_difference(sample_time, lower_time)) {
 --left;
 }
 break;
 }
 }

 *sample_index = mSyncSamples[left];
 return OK;
}

status_t SampleTable::getMaxSampleSize(size_t *max_size) {
 Mutex::Autolock autoLock(mLock);

 *max_size = 0;

 for (uint32_t i = 0; i < mNumSampleSizes; ++i) {
 size_t sample_size;
 status_t err = getSampleSize_l(i, &sample_size);

 if (err != OK) {
 return err;
 }

 if (sample_size > *max_size) {
 *max_size = sample_size;
 }
 }

 return OK;
}

status_t SampleTable::setChunkOffsetParams(
 uint32_t type, off64_t data_offset, size_t data_size) {
 if (mChunkOffsetOffset >= 0) {
 return ERROR_MALFORMED;
 }

    CHECK(type == kChunkOffsetType32 || type == kChunkOffsetType64);

    mChunkOffsetOffset = data_offset;
    mChunkOffsetType = type;

 if (data_size < 8) {
 return ERROR_MALFORMED;
 }

 uint8_t header[8];
 if (mDataSource->readAt(
                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {
 return ERROR_IO;
 }

 if (U32_AT(header) != 0) {
 return ERROR_MALFORMED;
 }

    mNumChunkOffsets = U32_AT(&header[4]);

 if (mChunkOffsetType == kChunkOffsetType32) {
 if (data_size < 8 + mNumChunkOffsets * 4) {
 return ERROR_MALFORMED;
 }
 } else {
 if (data_size < 8 + mNumChunkOffsets * 8) {
 return ERROR_MALFORMED;
 }
 }

 return OK;
}

status_t SampleTable::getSampleSize_l(
 uint32_t sampleIndex, size_t *sampleSize) {
 return mSampleIterator->getSampleSizeDirect(
            sampleIndex, sampleSize);
}

status_t SampleTable::setSampleSizeParams(
 uint32_t type, off64_t data_offset, size_t data_size) {
 if (mSampleSizeOffset >= 0) {
 return ERROR_MALFORMED;
 }

    CHECK(type == kSampleSizeType32 || type == kSampleSizeTypeCompact);

    mSampleSizeOffset = data_offset;

 if (data_size < 12) {
 return ERROR_MALFORMED;
 }

 uint8_t header[12];
 if (mDataSource->readAt(
                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {
 return ERROR_IO;
 }

 if (U32_AT(header) != 0) {
 return ERROR_MALFORMED;
 }

    mDefaultSampleSize = U32_AT(&header[4]);
    mNumSampleSizes = U32_AT(&header[8]);

 if (type == kSampleSizeType32) {
        mSampleSizeFieldSize = 32;

 if (mDefaultSampleSize != 0) {
 return OK;
 }

 if (data_size < 12 + mNumSampleSizes * 4) {
 return ERROR_MALFORMED;
 }
 } else {
 if ((mDefaultSampleSize & 0xffffff00) != 0) {
 return ERROR_MALFORMED;
 }

        mSampleSizeFieldSize = mDefaultSampleSize & 0xff;
        mDefaultSampleSize = 0;

 if (mSampleSizeFieldSize != 4 && mSampleSizeFieldSize != 8
 && mSampleSizeFieldSize != 16) {
 return ERROR_MALFORMED;
 }

 if (data_size < 12 + (mNumSampleSizes * mSampleSizeFieldSize + 4) / 8) {
 return ERROR_MALFORMED;
 }
 }

 return OK;
}

void SampleTable::CompositionDeltaLookup::setEntries(
 const uint32_t *deltaEntries, size_t numDeltaEntries) {
 Mutex::Autolock autolock(mLock);

    mDeltaEntries = deltaEntries;
    mNumDeltaEntries = numDeltaEntries;
    mCurrentDeltaEntry = 0;
    mCurrentEntrySampleIndex = 0;
}

uint32_t SampleTable::countChunkOffsets() const {
 return mNumChunkOffsets;
}

uint32_t SampleTable::countSamples() const {
 return mNumSampleSizes;
}

uint32_t SampleTable::CompositionDeltaLookup::getCompositionTimeOffset(
 uint32_t sampleIndex) {
 Mutex::Autolock autolock(mLock);

 if (mDeltaEntries == NULL) {
 return 0;
 }

 if (sampleIndex < mCurrentEntrySampleIndex) {
        mCurrentDeltaEntry = 0;
        mCurrentEntrySampleIndex = 0;
 }

 while (mCurrentDeltaEntry < mNumDeltaEntries) {
 uint32_t sampleCount = mDeltaEntries[2 * mCurrentDeltaEntry];
 if (sampleIndex < mCurrentEntrySampleIndex + sampleCount) {
 return mDeltaEntries[2 * mCurrentDeltaEntry + 1];
 }

        mCurrentEntrySampleIndex += sampleCount;
 ++mCurrentDeltaEntry;
 }

 return 0;
}

status_t SampleTable::setCompositionTimeToSampleParams(
off64_t data_offset, size_t data_size) {
ALOGI("There are reordered frames present.");

if (mCompositionTimeDeltaEntries != NULL || data_size < 8) {
return ERROR_MALFORMED;
}

uint8_t header[8];
if (mDataSource->readAt(
data_offset, header, sizeof(header))
< (ssize_t)sizeof(header)) {
return ERROR_IO;
}

if (U32_AT(header) != 0) {
// Expected version = 0, flags = 0.
return ERROR_MALFORMED;
}

size_t numEntries = U32_AT(&header[4]);

if (data_size != (numEntries + 1) * 8) {
return ERROR_MALFORMED;

}

mNumCompositionTimeDeltaEntries = numEntries;
    uint64_t allocSize = numEntries * 2 * sizeof(uint32_t);
if (allocSize > SIZE_MAX) {
return ERROR_OUT_OF_RANGE;
}

mCompositionTimeDeltaEntries = new uint32_t[2 * numEntries];

if (mDataSource->readAt(
data_offset + 8, mCompositionTimeDeltaEntries, numEntries * 8)
< (ssize_t)numEntries * 8) {
delete[] mCompositionTimeDeltaEntries;
mCompositionTimeDeltaEntries = NULL;

return ERROR_IO;
}

for (size_t i = 0; i < 2 * numEntries; ++i) {
mCompositionTimeDeltaEntries[i] = ntohl(mCompositionTimeDeltaEntries[i]);
}

mCompositionDeltaLookup->setEntries(
mCompositionTimeDeltaEntries, mNumCompositionTimeDeltaEntries);

return OK;
}

bool SampleTable::isValid() const {
 return mChunkOffsetOffset >= 0
 && mSampleToChunkOffset >= 0
 && mSampleSizeOffset >= 0
 && mTimeToSample != NULL;
}

status_t SampleTable::getMetaDataForSample(
 uint32_t sampleIndex,
 off64_t *offset,
 size_t *size,
 uint32_t *compositionTime,
 bool *isSyncSample,
 uint32_t *sampleDuration) {
 Mutex::Autolock autoLock(mLock);

 status_t err;
 if ((err = mSampleIterator->seekTo(sampleIndex)) != OK) {
 return err;
 }

 if (offset) {
 *offset = mSampleIterator->getSampleOffset();
 }

 if (size) {
 *size = mSampleIterator->getSampleSize();
 }

 if (compositionTime) {
 *compositionTime = mSampleIterator->getSampleTime();
 }

 if (isSyncSample) {
 *isSyncSample = false;
 if (mSyncSampleOffset < 0) {
 *isSyncSample = true;
 } else {
 size_t i = (mLastSyncSampleIndex < mNumSyncSamples)
 && (mSyncSamples[mLastSyncSampleIndex] <= sampleIndex)
 ? mLastSyncSampleIndex : 0;

 while (i < mNumSyncSamples && mSyncSamples[i] < sampleIndex) {
 ++i;
 }

 if (i < mNumSyncSamples && mSyncSamples[i] == sampleIndex) {
 *isSyncSample = true;
 }

            mLastSyncSampleIndex = i;
 }
 }

 if (sampleDuration) {
 *sampleDuration = mSampleIterator->getSampleDuration();
 }

 return OK;
}

uint32_t abs_difference(uint32_t time1, uint32_t time2) {
 return time1 > time2 ? time1 - time2 : time2 - time1;
}
