bool WebGraphicsContext3DCommandBufferImpl::ShouldUseSwapClient() {
  GpuChannelHostFactory* factory = GpuChannelHostFactory::instance();
  return factory && factory->IsMainThread() && swap_client_.get();
}

bool WebGraphicsContext3DCommandBufferImpl::Initialize(
    const WebGraphicsContext3D::Attributes& attributes) {
  DCHECK(!context_);
  TRACE_EVENT0("gpu", "WebGfxCtx3DCmdBfrImpl::initialize");
  GpuChannelHostFactory* factory = GpuChannelHostFactory::instance();
  if (!factory)
    return false;

  if (attributes.noExtensions || !attributes.canRecoverFromContextLoss)
    gpu_preference_ = gfx::PreferDiscreteGpu;

  bool retry = false;

  do {
    host_ = factory->EstablishGpuChannelSync(
        content::
        CAUSE_FOR_GPU_LAUNCH_WEBGRAPHICSCONTEXT3DCOMMANDBUFFERIMPL_INITIALIZE);
    if (!host_)
      return false;
    DCHECK(host_->state() == GpuChannelHost::kConnected);

    if (!retry) {
      if (host_->WillGpuSwitchOccur(true, gpu_preference_)) {
        host_->ForciblyCloseChannel();
        ClearSharedContexts();
        retry = true;
      }
    } else {
      retry = false;
    }
  } while (retry);

  const content::GPUInfo& gpu_info = host_->gpu_info();
  UMA_HISTOGRAM_ENUMERATION(
      "GPU.WebGraphicsContext3D_Init_CanLoseContext",
      attributes.canRecoverFromContextLoss * 2 + gpu_info.can_lose_context,
      4);
  if (attributes.canRecoverFromContextLoss == false) {
    if (gpu_info.can_lose_context)
      return false;
  }

  attributes_ = attributes;
  return true;
}

void WebGraphicsContext3DCommandBufferImpl::setVisibilityCHROMIUM(
    bool visible) {
  gl_->Flush();
  context_->SetSurfaceVisible(visible);
  if (!visible)
    gl_->FreeEverything();
}

void WebGraphicsContext3DCommandBufferImpl::OnContextLost(
    ContentGLContext::ContextLostReason reason) {
  context_lost_reason_ = convertReason(reason);
  if (context_lost_callback_) {
    context_lost_callback_->onContextLost();
  }
  if (attributes_.shareResources)
    ClearSharedContexts();
  if (ShouldUseSwapClient())
    swap_client_->OnViewContextSwapBuffersAborted();
}

void WebGraphicsContext3DCommandBufferImpl::reshape(int width, int height) {
cached_width_ = width;
cached_height_ = height;

gl_->ResizeCHROMIUM(width, height);
#ifdef FLIP_FRAMEBUFFER_VERTICALLY
  scanline_.reset(new uint8[width * 4]);
#endif  // FLIP_FRAMEBUFFER_VERTICALLY
}

bool WebGraphicsContext3DCommandBufferImpl::isContextLost() {
  return initialize_failed_ ||
      (context_ && context_->IsCommandBufferContextLost()) ||
      context_lost_reason_ != GL_NO_ERROR;
}

bool WebGraphicsContext3DCommandBufferImpl::setParentContext(
    WebGraphicsContext3D* parent_context) {
  WebGraphicsContext3DCommandBufferImpl* parent_context_impl =
      static_cast<WebGraphicsContext3DCommandBufferImpl*>(parent_context);
  return context_->SetParent(
      parent_context_impl ? parent_context_impl->context() : NULL);
}

void WebGraphicsContext3DCommandBufferImpl::FlipVertically(
uint8* framebuffer,
unsigned int width,
unsigned int height) {
  uint8* scanline = scanline_.get();
  if (!scanline)
return;
unsigned int row_bytes = width * 4;
unsigned int count = height / 2;
for (unsigned int i = 0; i < count; i++) {
uint8* row_a = framebuffer + i * row_bytes;
uint8* row_b = framebuffer + (height - i - 1) * row_bytes;
// TODO(kbr): this is where the multiplication of the alpha
// channel into the color buffer will need to occur if the
// user specifies the "premultiplyAlpha" flag in the context
// creation attributes.
memcpy(scanline, row_b, row_bytes);
memcpy(row_b, row_a, row_bytes);
memcpy(row_a, scanline, row_bytes);
}
}

WebGraphicsContext3DCommandBufferImpl::WebGraphicsContext3DCommandBufferImpl(
    int surface_id,
    const GURL& active_url,
    const base::WeakPtr<WebGraphicsContext3DSwapBuffersClient>& swap_client)
    : initialize_failed_(false),
      context_(NULL),
      gl_(NULL),
      host_(NULL),
      surface_id_(surface_id),
      active_url_(active_url),
      swap_client_(swap_client),
      memory_allocation_changed_callback_(0),
      context_lost_callback_(0),
      context_lost_reason_(GL_NO_ERROR),
      error_message_callback_(0),
      swapbuffers_complete_callback_(0),
      gpu_preference_(gfx::PreferIntegratedGpu),
      cached_width_(0),
      cached_height_(0),
      bound_fbo_(0),
      weak_ptr_factory_(ALLOW_THIS_IN_INITIALIZER_LIST(this)) {
}

void WebGraphicsContext3DCommandBufferImpl::postSubBufferCHROMIUM(
    int x, int y, int width, int height) {
  if (ShouldUseSwapClient())
    swap_client_->OnViewContextSwapBuffersPosted();
  gl_->PostSubBufferCHROMIUM(x, y, width, height);
  context_->Echo(base::Bind(
      &WebGraphicsContext3DCommandBufferImpl::OnSwapBuffersComplete,
      weak_ptr_factory_.GetWeakPtr()));
}

bool WebGraphicsContext3DCommandBufferImpl::MaybeInitializeGL() {
  if (context_)
    return true;
  if (initialize_failed_)
    return false;

  TRACE_EVENT0("gpu", "WebGfxCtx3DCmdBfrImpl::MaybeInitializeGL");

  const int alpha_size = attributes_.alpha ? 8 : 0;
  const int depth_size = attributes_.depth ? 24 : 0;
  const int stencil_size = attributes_.stencil ? 8 : 0;
  const int samples = attributes_.antialias ? 4 : 0;
  const int sample_buffers = attributes_.antialias ? 1 : 0;
  const int32 attribs[] = {
    ContentGLContext::ALPHA_SIZE, alpha_size,
    ContentGLContext::DEPTH_SIZE, depth_size,
    ContentGLContext::STENCIL_SIZE, stencil_size,
    ContentGLContext::SAMPLES, samples,
    ContentGLContext::SAMPLE_BUFFERS, sample_buffers,
    ContentGLContext::SHARE_RESOURCES, attributes_.shareResources ? 1 : 0,
    ContentGLContext::BIND_GENERATES_RESOURCES, 0,
    ContentGLContext::NONE,
  };

  const char* preferred_extensions = "*";

  {
    base::AutoLock lock(g_all_shared_contexts_lock.Get());
    ContentGLContext* share_group = NULL;
    if (attributes_.shareResources) {
      share_group = g_all_shared_contexts.Pointer()->empty() ?
          NULL : (*g_all_shared_contexts.Pointer()->begin())->context_;
    }

    if (surface_id_) {
      context_ = ContentGLContext::CreateViewContext(
          host_,
          surface_id_,
          share_group,
          preferred_extensions,
          attribs,
          active_url_,
          gpu_preference_);
    } else {
      context_ = ContentGLContext::CreateOffscreenContext(
          host_,
          gfx::Size(1, 1),
          share_group,
          preferred_extensions,
          attribs,
          active_url_,
          gpu_preference_);
    }
  }

  if (!context_)
    return false;

  gl_ = context_->GetImplementation();

  if (gl_ && attributes_.noExtensions)
    gl_->EnableFeatureCHROMIUM("webgl_enable_glsl_webgl_validation");

  context_->SetContextLostCallback(
      base::Bind(&WebGraphicsContext3DCommandBufferImpl::OnContextLost,
                 weak_ptr_factory_.GetWeakPtr()));

  context_->GetCommandBufferProxy()->SetOnConsoleMessageCallback(
      base::Bind(&WebGraphicsContext3DCommandBufferImpl::OnErrorMessage,
                 weak_ptr_factory_.GetWeakPtr()));

  const CommandLine& command_line = *CommandLine::ForCurrentProcess();
  if (command_line.HasSwitch(switches::kDisableGLSLTranslator)) {
    context_->DisableShaderTranslation();
  }

  {
    GLint alpha_bits = 0;
    getIntegerv(GL_ALPHA_BITS, &alpha_bits);
    attributes_.alpha = alpha_bits > 0;
    GLint depth_bits = 0;
    getIntegerv(GL_DEPTH_BITS, &depth_bits);
    attributes_.depth = depth_bits > 0;
    GLint stencil_bits = 0;
    getIntegerv(GL_STENCIL_BITS, &stencil_bits);
    attributes_.stencil = stencil_bits > 0;
    GLint samples = 0;
    getIntegerv(GL_SAMPLES, &samples);
    attributes_.antialias = samples > 0;
  }

  if (attributes_.shareResources) {
    base::AutoLock lock(g_all_shared_contexts_lock.Get());
    g_all_shared_contexts.Pointer()->insert(this);
  }

  context_->SetMemoryAllocationChangedCallback(base::Bind(
      &WebGraphicsContext3DCommandBufferImpl::OnMemoryAllocationChanged,
      weak_ptr_factory_.GetWeakPtr()));

  return true;
}

WGC3Denum WebGraphicsContext3DCommandBufferImpl::getGraphicsResetStatusARB() {
  if (context_->IsCommandBufferContextLost() &&
      context_lost_reason_ == GL_NO_ERROR) {
    return GL_UNKNOWN_CONTEXT_RESET_ARB;
  }

  return context_lost_reason_;
}

WGC3Denum convertReason(ContentGLContext::ContextLostReason reason) {
  switch (reason) {
  case ContentGLContext::kGuilty:
    return GL_GUILTY_CONTEXT_RESET_ARB;
  case ContentGLContext::kInnocent:
    return GL_INNOCENT_CONTEXT_RESET_ARB;
  case ContentGLContext::kUnknown:
    return GL_UNKNOWN_CONTEXT_RESET_ARB;
  }

  NOTREACHED();
  return GL_UNKNOWN_CONTEXT_RESET_ARB;
}

bool WebGraphicsContext3DCommandBufferImpl::makeContextCurrent() {
  if (!MaybeInitializeGL())
    return false;
  return ContentGLContext::MakeCurrent(context_);
}

    ~WebGraphicsContext3DCommandBufferImpl() {
  if (host_) {
    if (host_->WillGpuSwitchOccur(false, gpu_preference_)) {
      host_->ForciblyCloseChannel();
      ClearSharedContexts();
    }
  }

  {
    base::AutoLock lock(g_all_shared_contexts_lock.Get());
    g_all_shared_contexts.Pointer()->erase(this);
  }
  delete context_;
}
