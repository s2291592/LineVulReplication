vips_tracked_get_files( void )
{
	int n;

	vips_tracked_init(); 

	g_mutex_lock( vips_tracked_mutex );

	n = vips_tracked_files;

	g_mutex_unlock( vips_tracked_mutex );

	return( n );
}

vips_tracked_close( int fd )
{
	int result;

	g_mutex_lock( vips_tracked_mutex );

	g_assert( vips_tracked_files > 0 );

	vips_tracked_files -= 1;
#ifdef DEBUG_VERBOSE
	printf( "vips_tracked_close: %d (%d)\n", fd, vips_tracked_files );
#endif /*DEBUG_VERBOSE*/

	g_mutex_unlock( vips_tracked_mutex );

	result = close( fd );

	return( result );
}

vips_tracked_open( const char *pathname, int flags, ... )
{
	int fd;
	mode_t mode;
	va_list ap;

	/* mode_t is promoted to int in ..., so we have to pull it out as an
	 * int.
	 */
	va_start( ap, flags );
	mode = va_arg( ap, int );
	va_end( ap );

	if( (fd = vips__open( pathname, flags, mode )) == -1 )
		return( -1 );

	vips_tracked_init(); 

	g_mutex_lock( vips_tracked_mutex );

	vips_tracked_files += 1;
#ifdef DEBUG_VERBOSE
	printf( "vips_tracked_open: %s = %d (%d)\n", 
		pathname, fd, vips_tracked_files );
#endif /*DEBUG_VERBOSE*/

	g_mutex_unlock( vips_tracked_mutex );

	return( fd );
}

vips_strdup( VipsObject *object, const char *str )
{
	char *str_dup;

	str_dup = g_strdup( str );

        if( object ) {
		g_signal_connect( object, "postclose", 
			G_CALLBACK( vips_malloc_cb ), str_dup );
		object->local_memory += strlen( str );
	}

	return( str_dup );
}

vips_malloc_cb( VipsObject *object, char *buf )
{
	g_free( buf );
}

vips_free( void *buf )
{
	g_free( buf );

	return( 0 );
}

vips_tracked_init( void )
{
	static GOnce vips_tracked_once = G_ONCE_INIT;

	VIPS_ONCE( &vips_tracked_once, 
		(GThreadFunc) vips_tracked_init_mutex, NULL );
}

vips_tracked_get_allocs( void )
{
	int n;

	vips_tracked_init(); 

	g_mutex_lock( vips_tracked_mutex );

	n = vips_tracked_allocs;

	g_mutex_unlock( vips_tracked_mutex );

	return( n );
}

vips_tracked_get_mem( void )
{
	size_t mem;

	vips_tracked_init(); 

	g_mutex_lock( vips_tracked_mutex );

	mem = vips_tracked_mem;

	g_mutex_unlock( vips_tracked_mutex );

	return( mem );
}

vips_tracked_get_mem_highwater( void )
{
	size_t mx;

	vips_tracked_init(); 

	g_mutex_lock( vips_tracked_mutex );

	mx = vips_tracked_mem_highwater;

	g_mutex_unlock( vips_tracked_mutex );

	return( mx );
}

vips_tracked_free( void *s )
{
	/* Keep the size of the alloc in the previous 16 bytes. Ensures
	 * alignment rules are kept.
	 */
	void *start = (void *) ((char *) s - 16);
	size_t size = *((size_t *) start);

	g_mutex_lock( vips_tracked_mutex );

#ifdef DEBUG_VERBOSE
	printf( "vips_tracked_free: %p, %zd bytes\n", s, size ); 
#endif /*DEBUG_VERBOSE*/

	if( vips_tracked_allocs <= 0 ) 
		g_warning( "%s", _( "vips_free: too many frees" ) );
	if( vips_tracked_mem < size )
		g_warning( "%s", _( "vips_free: too much free" ) );

	vips_tracked_mem -= size;
	vips_tracked_allocs -= 1;

	g_mutex_unlock( vips_tracked_mutex );

	g_free( start );

	VIPS_GATE_FREE( size ); 
}
