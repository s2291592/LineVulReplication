rpl_daoack_print(netdissect_options *ndo,
const u_char *bp, u_int length)
{
const struct nd_rpl_daoack *daoack = (const struct nd_rpl_daoack *)bp;
const char *dagid_str = "<elided>";

ND_TCHECK2(*daoack, ND_RPL_DAOACK_MIN_LEN);
if (length < ND_RPL_DAOACK_MIN_LEN)
goto tooshort;

bp += ND_RPL_DAOACK_MIN_LEN;
length -= ND_RPL_DAOACK_MIN_LEN;
if(RPL_DAOACK_D(daoack->rpl_flags)) {
ND_TCHECK2(daoack->rpl_dagid, DAGID_LEN);
if (length < DAGID_LEN)
goto tooshort;
dagid_str = ip6addr_string (ndo, daoack->rpl_dagid);
bp += DAGID_LEN;
length -= DAGID_LEN;
}

ND_PRINT((ndo, " [dagid:%s,seq:%u,instance:%u,status:%u]",
dagid_str,
daoack->rpl_daoseq,
daoack->rpl_instanceid,
daoack->rpl_status));

/* no officially defined options for DAOACK, but print any we find */
if(ndo->ndo_vflag > 1) {
const struct rpl_dio_genoption *opt = (const struct rpl_dio_genoption *)bp;
rpl_dio_printopt(ndo, opt, length);
}
return;

trunc:
	ND_PRINT((ndo," [|dao-truncated]"));
return;

tooshort:
ND_PRINT((ndo," [|dao-length too short]"));
return;
}

icmp6_nodeinfo_print(netdissect_options *ndo, u_int icmp6len, const u_char *bp, const u_char *ep)
{
const struct icmp6_nodeinfo *ni6;
const struct icmp6_hdr *dp;
const u_char *cp;
size_t siz, i;
int needcomma;

if (ep < bp)
return;
dp = (const struct icmp6_hdr *)bp;
ni6 = (const struct icmp6_nodeinfo *)bp;
siz = ep - bp;

switch (ni6->ni_type) {
case ICMP6_NI_QUERY:
if (siz == sizeof(*dp) + 4) {
/* KAME who-are-you */
ND_PRINT((ndo," who-are-you request"));
break;
}
ND_PRINT((ndo," node information query"));

ND_TCHECK2(*dp, sizeof(*ni6));
ni6 = (const struct icmp6_nodeinfo *)dp;
ND_PRINT((ndo," ("));	/*)*/
switch (EXTRACT_16BITS(&ni6->ni_qtype)) {
case NI_QTYPE_NOOP:
ND_PRINT((ndo,"noop"));
break;
case NI_QTYPE_SUPTYPES:
ND_PRINT((ndo,"supported qtypes"));
i = EXTRACT_16BITS(&ni6->ni_flags);
if (i)
ND_PRINT((ndo," [%s]", (i & 0x01) ? "C" : ""));
break;
case NI_QTYPE_FQDN:
ND_PRINT((ndo,"DNS name"));
break;
case NI_QTYPE_NODEADDR:
ND_PRINT((ndo,"node addresses"));
i = ni6->ni_flags;
if (!i)
break;
/* NI_NODEADDR_FLAG_TRUNCATE undefined for query */
ND_PRINT((ndo," [%s%s%s%s%s%s]",
(i & NI_NODEADDR_FLAG_ANYCAST) ? "a" : "",
(i & NI_NODEADDR_FLAG_GLOBAL) ? "G" : "",
(i & NI_NODEADDR_FLAG_SITELOCAL) ? "S" : "",
(i & NI_NODEADDR_FLAG_LINKLOCAL) ? "L" : "",
(i & NI_NODEADDR_FLAG_COMPAT) ? "C" : "",
(i & NI_NODEADDR_FLAG_ALL) ? "A" : ""));
break;
default:
ND_PRINT((ndo,"unknown"));
break;
}

if (ni6->ni_qtype == NI_QTYPE_NOOP ||
ni6->ni_qtype == NI_QTYPE_SUPTYPES) {
if (siz != sizeof(*ni6))
if (ndo->ndo_vflag)
ND_PRINT((ndo,", invalid len"));
/*(*/
ND_PRINT((ndo,")"));
break;
}


/* XXX backward compat, icmp-name-lookup-03 */
if (siz == sizeof(*ni6)) {
ND_PRINT((ndo,", 03 draft"));
/*(*/
ND_PRINT((ndo,")"));
break;
}

switch (ni6->ni_code) {
case ICMP6_NI_SUBJ_IPV6:
if (!ND_TTEST2(*dp,
sizeof(*ni6) + sizeof(struct in6_addr)))
break;
if (siz != sizeof(*ni6) + sizeof(struct in6_addr)) {
if (ndo->ndo_vflag)
ND_PRINT((ndo,", invalid subject len"));
break;
}
ND_PRINT((ndo,", subject=%s",
ip6addr_string(ndo, ni6 + 1)));
break;
case ICMP6_NI_SUBJ_FQDN:
ND_PRINT((ndo,", subject=DNS name"));
cp = (const u_char *)(ni6 + 1);
if (cp[0] == ep - cp - 1) {
/* icmp-name-lookup-03, pascal string */
if (ndo->ndo_vflag)
ND_PRINT((ndo,", 03 draft"));
cp++;
ND_PRINT((ndo,", \""));
while (cp < ep) {
safeputchar(ndo, *cp);
cp++;
}
ND_PRINT((ndo,"\""));
} else
dnsname_print(ndo, cp, ep);
break;
case ICMP6_NI_SUBJ_IPV4:
if (!ND_TTEST2(*dp, sizeof(*ni6) + sizeof(struct in_addr)))
break;
if (siz != sizeof(*ni6) + sizeof(struct in_addr)) {
if (ndo->ndo_vflag)
ND_PRINT((ndo,", invalid subject len"));
break;
}
ND_PRINT((ndo,", subject=%s",
ipaddr_string(ndo, ni6 + 1)));
break;
default:
ND_PRINT((ndo,", unknown subject"));
break;
}

/*(*/
ND_PRINT((ndo,")"));
break;

case ICMP6_NI_REPLY:
if (icmp6len > siz) {
ND_PRINT((ndo,"[|icmp6: node information reply]"));
break;
}

needcomma = 0;

ND_TCHECK2(*dp, sizeof(*ni6));
ni6 = (const struct icmp6_nodeinfo *)dp;
ND_PRINT((ndo," node information reply"));
ND_PRINT((ndo," ("));	/*)*/
switch (ni6->ni_code) {
case ICMP6_NI_SUCCESS:
if (ndo->ndo_vflag) {
ND_PRINT((ndo,"success"));
needcomma++;
}
break;
case ICMP6_NI_REFUSED:
ND_PRINT((ndo,"refused"));
needcomma++;
if (siz != sizeof(*ni6))
if (ndo->ndo_vflag)
ND_PRINT((ndo,", invalid length"));
break;
case ICMP6_NI_UNKNOWN:
ND_PRINT((ndo,"unknown"));
needcomma++;
if (siz != sizeof(*ni6))
if (ndo->ndo_vflag)
ND_PRINT((ndo,", invalid length"));
break;
}

if (ni6->ni_code != ICMP6_NI_SUCCESS) {
/*(*/
ND_PRINT((ndo,")"));
break;
}

switch (EXTRACT_16BITS(&ni6->ni_qtype)) {
case NI_QTYPE_NOOP:
if (needcomma)
ND_PRINT((ndo,", "));
ND_PRINT((ndo,"noop"));
if (siz != sizeof(*ni6))
if (ndo->ndo_vflag)
ND_PRINT((ndo,", invalid length"));
break;
case NI_QTYPE_SUPTYPES:
if (needcomma)
ND_PRINT((ndo,", "));
ND_PRINT((ndo,"supported qtypes"));
i = EXTRACT_16BITS(&ni6->ni_flags);
if (i)
ND_PRINT((ndo," [%s]", (i & 0x01) ? "C" : ""));
break;
case NI_QTYPE_FQDN:
if (needcomma)
ND_PRINT((ndo,", "));
ND_PRINT((ndo,"DNS name"));
cp = (const u_char *)(ni6 + 1) + 4;
ND_TCHECK(cp[0]);
if (cp[0] == ep - cp - 1) {
/* icmp-name-lookup-03, pascal string */
if (ndo->ndo_vflag)
ND_PRINT((ndo,", 03 draft"));
cp++;
ND_PRINT((ndo,", \""));
while (cp < ep) {
safeputchar(ndo, *cp);
cp++;
}
ND_PRINT((ndo,"\""));
} else
dnsname_print(ndo, cp, ep);
if ((EXTRACT_16BITS(&ni6->ni_flags) & 0x01) != 0)
ND_PRINT((ndo," [TTL=%u]", EXTRACT_32BITS(ni6 + 1)));
break;
case NI_QTYPE_NODEADDR:
if (needcomma)
ND_PRINT((ndo,", "));
ND_PRINT((ndo,"node addresses"));
i = sizeof(*ni6);
while (i < siz) {
if (i + sizeof(struct in6_addr) + sizeof(int32_t) > siz)
break;
ND_PRINT((ndo," %s", ip6addr_string(ndo, bp + i)));
i += sizeof(struct in6_addr);
ND_PRINT((ndo,"(%d)", (int32_t)EXTRACT_32BITS(bp + i)));
i += sizeof(int32_t);
}
i = ni6->ni_flags;
if (!i)
break;
ND_PRINT((ndo," [%s%s%s%s%s%s%s]",
(i & NI_NODEADDR_FLAG_ANYCAST) ? "a" : "",
(i & NI_NODEADDR_FLAG_GLOBAL) ? "G" : "",
(i & NI_NODEADDR_FLAG_SITELOCAL) ? "S" : "",
(i & NI_NODEADDR_FLAG_LINKLOCAL) ? "L" : "",
(i & NI_NODEADDR_FLAG_COMPAT) ? "C" : "",
(i & NI_NODEADDR_FLAG_ALL) ? "A" : "",
(i & NI_NODEADDR_FLAG_TRUNCATE) ? "T" : ""));
break;
default:
if (needcomma)
ND_PRINT((ndo,", "));
ND_PRINT((ndo,"unknown"));
break;
}

/*(*/
ND_PRINT((ndo,")"));
break;
}
return;

trunc:
	ND_PRINT((ndo, "[|icmp6]"));
}

rpl_print(netdissect_options *ndo,
const struct icmp6_hdr *hdr,
const u_char *bp, u_int length)
{
int secured = hdr->icmp6_code & 0x80;
int basecode= hdr->icmp6_code & 0x7f;

if(secured) {
ND_PRINT((ndo, ", (SEC) [worktodo]"));
/* XXX
* the next header pointer needs to move forward to
* skip the secure part.
*/
return;
} else {
ND_PRINT((ndo, ", (CLR)"));
}

switch(basecode) {
case ND_RPL_DAG_IS:
ND_PRINT((ndo, "DODAG Information Solicitation"));
if(ndo->ndo_vflag) {
}
break;
case ND_RPL_DAG_IO:
ND_PRINT((ndo, "DODAG Information Object"));
if(ndo->ndo_vflag) {
rpl_dio_print(ndo, bp, length);
}
break;
case ND_RPL_DAO:
ND_PRINT((ndo, "Destination Advertisement Object"));
if(ndo->ndo_vflag) {
rpl_dao_print(ndo, bp, length);
}
break;
case ND_RPL_DAO_ACK:
ND_PRINT((ndo, "Destination Advertisement Object Ack"));
if(ndo->ndo_vflag) {
rpl_daoack_print(ndo, bp, length);
}
break;
default:
ND_PRINT((ndo, "RPL message, unknown code %u",hdr->icmp6_code));
break;
}
return;

#if 0
trunc:
	ND_PRINT((ndo," [|truncated]"));
return;
#endif

}

rpl_dao_print(netdissect_options *ndo,
const u_char *bp, u_int length)
{
const struct nd_rpl_dao *dao = (const struct nd_rpl_dao *)bp;
const char *dagid_str = "<elided>";

ND_TCHECK(*dao);
if (length < ND_RPL_DAO_MIN_LEN)
goto tooshort;

bp += ND_RPL_DAO_MIN_LEN;
length -= ND_RPL_DAO_MIN_LEN;
if(RPL_DAO_D(dao->rpl_flags)) {
ND_TCHECK2(dao->rpl_dagid, DAGID_LEN);
if (length < DAGID_LEN)
goto tooshort;
dagid_str = ip6addr_string (ndo, dao->rpl_dagid);
bp += DAGID_LEN;
length -= DAGID_LEN;
}

ND_PRINT((ndo, " [dagid:%s,seq:%u,instance:%u%s%s,%02x]",
dagid_str,
dao->rpl_daoseq,
dao->rpl_instanceid,
RPL_DAO_K(dao->rpl_flags) ? ",acK":"",
RPL_DAO_D(dao->rpl_flags) ? ",Dagid":"",
dao->rpl_flags));

if(ndo->ndo_vflag > 1) {
const struct rpl_dio_genoption *opt = (const struct rpl_dio_genoption *)bp;
rpl_dio_printopt(ndo, opt, length);
}
return;

trunc:
	ND_PRINT((ndo," [|truncated]"));
return;

tooshort:
ND_PRINT((ndo," [|length too short]"));
return;
}

icmp6_rrenum_print(netdissect_options *ndo, const u_char *bp, const u_char *ep)
{
const struct icmp6_router_renum *rr6;
const char *cp;
const struct rr_pco_match *match;
const struct rr_pco_use *use;
char hbuf[NI_MAXHOST];
int n;

if (ep < bp)
return;
rr6 = (const struct icmp6_router_renum *)bp;
cp = (const char *)(rr6 + 1);

ND_TCHECK(rr6->rr_reserved);
switch (rr6->rr_code) {
case ICMP6_ROUTER_RENUMBERING_COMMAND:
ND_PRINT((ndo,"router renum: command"));
break;
case ICMP6_ROUTER_RENUMBERING_RESULT:
ND_PRINT((ndo,"router renum: result"));
break;
case ICMP6_ROUTER_RENUMBERING_SEQNUM_RESET:
ND_PRINT((ndo,"router renum: sequence number reset"));
break;
default:
ND_PRINT((ndo,"router renum: code-#%d", rr6->rr_code));
break;
}

ND_PRINT((ndo,", seq=%u", EXTRACT_32BITS(&rr6->rr_seqnum)));

if (ndo->ndo_vflag) {
#define F(x, y)	((rr6->rr_flags) & (x) ? (y) : "")
ND_PRINT((ndo,"["));	/*]*/
if (rr6->rr_flags) {
ND_PRINT((ndo,"%s%s%s%s%s,", F(ICMP6_RR_FLAGS_TEST, "T"),
F(ICMP6_RR_FLAGS_REQRESULT, "R"),
F(ICMP6_RR_FLAGS_FORCEAPPLY, "A"),
F(ICMP6_RR_FLAGS_SPECSITE, "S"),
F(ICMP6_RR_FLAGS_PREVDONE, "P")));
}
ND_PRINT((ndo,"seg=%u,", rr6->rr_segnum));
ND_PRINT((ndo,"maxdelay=%u", EXTRACT_16BITS(&rr6->rr_maxdelay)));
if (rr6->rr_reserved)
ND_PRINT((ndo,"rsvd=0x%x", EXTRACT_32BITS(&rr6->rr_reserved)));
/*[*/
ND_PRINT((ndo,"]"));
#undef F
}

if (rr6->rr_code == ICMP6_ROUTER_RENUMBERING_COMMAND) {
match = (const struct rr_pco_match *)cp;
cp = (const char *)(match + 1);

ND_TCHECK(match->rpm_prefix);

if (ndo->ndo_vflag > 1)
ND_PRINT((ndo,"\n\t"));
else
ND_PRINT((ndo," "));
ND_PRINT((ndo,"match("));	/*)*/
switch (match->rpm_code) {
case RPM_PCO_ADD:	ND_PRINT((ndo,"add")); break;
case RPM_PCO_CHANGE:	ND_PRINT((ndo,"change")); break;
case RPM_PCO_SETGLOBAL:	ND_PRINT((ndo,"setglobal")); break;
default:		ND_PRINT((ndo,"#%u", match->rpm_code)); break;
}

if (ndo->ndo_vflag) {
ND_PRINT((ndo,",ord=%u", match->rpm_ordinal));
ND_PRINT((ndo,",min=%u", match->rpm_minlen));
ND_PRINT((ndo,",max=%u", match->rpm_maxlen));
}
if (addrtostr6(&match->rpm_prefix, hbuf, sizeof(hbuf)))
ND_PRINT((ndo,",%s/%u", hbuf, match->rpm_matchlen));
else
ND_PRINT((ndo,",?/%u", match->rpm_matchlen));
/*(*/
ND_PRINT((ndo,")"));

n = match->rpm_len - 3;
if (n % 4)
goto trunc;
n /= 4;
while (n-- > 0) {
use = (const struct rr_pco_use *)cp;
cp = (const char *)(use + 1);

ND_TCHECK(use->rpu_prefix);

if (ndo->ndo_vflag > 1)
ND_PRINT((ndo,"\n\t"));
else
ND_PRINT((ndo," "));
ND_PRINT((ndo,"use("));	/*)*/
if (use->rpu_flags) {
#define F(x, y)	((use->rpu_flags) & (x) ? (y) : "")
ND_PRINT((ndo,"%s%s,",
F(ICMP6_RR_PCOUSE_FLAGS_DECRVLTIME, "V"),
F(ICMP6_RR_PCOUSE_FLAGS_DECRPLTIME, "P")));
#undef F
}
if (ndo->ndo_vflag) {
ND_PRINT((ndo,"mask=0x%x,", use->rpu_ramask));
ND_PRINT((ndo,"raflags=0x%x,", use->rpu_raflags));
if (~use->rpu_vltime == 0)
ND_PRINT((ndo,"vltime=infty,"));
else
ND_PRINT((ndo,"vltime=%u,",
EXTRACT_32BITS(&use->rpu_vltime)));
if (~use->rpu_pltime == 0)
ND_PRINT((ndo,"pltime=infty,"));
else
ND_PRINT((ndo,"pltime=%u,",
EXTRACT_32BITS(&use->rpu_pltime)));
}
if (addrtostr6(&use->rpu_prefix, hbuf, sizeof(hbuf)))
ND_PRINT((ndo,"%s/%u/%u", hbuf, use->rpu_uselen,
use->rpu_keeplen));
else
ND_PRINT((ndo,"?/%u/%u", use->rpu_uselen,
use->rpu_keeplen));
/*(*/
ND_PRINT((ndo,")"));
}
}

return;

trunc:
	ND_PRINT((ndo,"[|icmp6]"));
}

rpl_dio_print(netdissect_options *ndo,
const u_char *bp, u_int length)
{
const struct nd_rpl_dio *dio = (const struct nd_rpl_dio *)bp;
const char *dagid_str;

ND_TCHECK(*dio);
dagid_str = ip6addr_string (ndo, dio->rpl_dagid);

ND_PRINT((ndo, " [dagid:%s,seq:%u,instance:%u,rank:%u,%smop:%s,prf:%u]",
dagid_str,
dio->rpl_dtsn,
dio->rpl_instanceid,
EXTRACT_16BITS(&dio->rpl_dagrank),
RPL_DIO_GROUNDED(dio->rpl_mopprf) ? "grounded,":"",
tok2str(rpl_mop_values, "mop%u", RPL_DIO_MOP(dio->rpl_mopprf)),
RPL_DIO_PRF(dio->rpl_mopprf)));

if(ndo->ndo_vflag > 1) {
const struct rpl_dio_genoption *opt = (const struct rpl_dio_genoption *)&dio[1];
rpl_dio_printopt(ndo, opt, length);
}
return;
trunc:
	ND_PRINT((ndo," [|truncated]"));
return;
}

icmp6_opt_print(netdissect_options *ndo, const u_char *bp, int resid)
{
const struct nd_opt_hdr *op;
const struct nd_opt_prefix_info *opp;
const struct nd_opt_mtu *opm;
const struct nd_opt_rdnss *oprd;
const struct nd_opt_dnssl *opds;
const struct nd_opt_advinterval *opa;
const struct nd_opt_homeagent_info *oph;
const struct nd_opt_route_info *opri;
const u_char *cp, *ep, *domp;
struct in6_addr in6;
const struct in6_addr *in6p;
size_t l;
u_int i;

#define ECHECK(var) if ((const u_char *)&(var) > ep - sizeof(var)) return

cp = bp;
/* 'ep' points to the end of available data. */
ep = ndo->ndo_snapend;

while (cp < ep) {
op = (const struct nd_opt_hdr *)cp;

ECHECK(op->nd_opt_len);
if (resid <= 0)
return;
if (op->nd_opt_len == 0)
goto trunc;
if (cp + (op->nd_opt_len << 3) > ep)
goto trunc;

ND_PRINT((ndo,"\n\t  %s option (%u), length %u (%u): ",
tok2str(icmp6_opt_values, "unknown", op->nd_opt_type),
op->nd_opt_type,
op->nd_opt_len << 3,
op->nd_opt_len));

switch (op->nd_opt_type) {
case ND_OPT_SOURCE_LINKADDR:
l = (op->nd_opt_len << 3) - 2;
print_lladdr(ndo, cp + 2, l);
break;
case ND_OPT_TARGET_LINKADDR:
l = (op->nd_opt_len << 3) - 2;
print_lladdr(ndo, cp + 2, l);
break;
case ND_OPT_PREFIX_INFORMATION:
opp = (const struct nd_opt_prefix_info *)op;
ND_TCHECK(opp->nd_opt_pi_prefix);
ND_PRINT((ndo,"%s/%u%s, Flags [%s], valid time %s",
ip6addr_string(ndo, &opp->nd_opt_pi_prefix),
opp->nd_opt_pi_prefix_len,
(op->nd_opt_len != 4) ? "badlen" : "",
bittok2str(icmp6_opt_pi_flag_values, "none", opp->nd_opt_pi_flags_reserved),
get_lifetime(EXTRACT_32BITS(&opp->nd_opt_pi_valid_time))));
ND_PRINT((ndo,", pref. time %s", get_lifetime(EXTRACT_32BITS(&opp->nd_opt_pi_preferred_time))));
break;
case ND_OPT_REDIRECTED_HEADER:
print_unknown_data(ndo, bp,"\n\t    ",op->nd_opt_len<<3);
/* xxx */
break;
case ND_OPT_MTU:
opm = (const struct nd_opt_mtu *)op;
ND_TCHECK(opm->nd_opt_mtu_mtu);
ND_PRINT((ndo," %u%s",
EXTRACT_32BITS(&opm->nd_opt_mtu_mtu),
(op->nd_opt_len != 1) ? "bad option length" : "" ));
break;
case ND_OPT_RDNSS:
oprd = (const struct nd_opt_rdnss *)op;
l = (op->nd_opt_len - 1) / 2;
ND_PRINT((ndo," lifetime %us,",
EXTRACT_32BITS(&oprd->nd_opt_rdnss_lifetime)));
for (i = 0; i < l; i++) {
ND_TCHECK(oprd->nd_opt_rdnss_addr[i]);
ND_PRINT((ndo," addr: %s",
ip6addr_string(ndo, &oprd->nd_opt_rdnss_addr[i])));
}
break;
case ND_OPT_DNSSL:
opds = (const struct nd_opt_dnssl *)op;
ND_PRINT((ndo," lifetime %us, domain(s):",
EXTRACT_32BITS(&opds->nd_opt_dnssl_lifetime)));
domp = cp + 8; /* domain names, variable-sized, RFC1035-encoded */
while (domp < cp + (op->nd_opt_len << 3) && *domp != '\0')
{
ND_PRINT((ndo, " "));
if ((domp = ns_nprint (ndo, domp, bp)) == NULL)
goto trunc;
}
break;
case ND_OPT_ADVINTERVAL:
opa = (const struct nd_opt_advinterval *)op;
ND_TCHECK(opa->nd_opt_adv_interval);
ND_PRINT((ndo," %ums", EXTRACT_32BITS(&opa->nd_opt_adv_interval)));
break;
case ND_OPT_HOMEAGENT_INFO:
oph = (const struct nd_opt_homeagent_info *)op;
ND_TCHECK(oph->nd_opt_hai_lifetime);
ND_PRINT((ndo," preference %u, lifetime %u",
EXTRACT_16BITS(&oph->nd_opt_hai_preference),
EXTRACT_16BITS(&oph->nd_opt_hai_lifetime)));
break;
case ND_OPT_ROUTE_INFO:
opri = (const struct nd_opt_route_info *)op;
ND_TCHECK(opri->nd_opt_rti_lifetime);
memset(&in6, 0, sizeof(in6));
in6p = (const struct in6_addr *)(opri + 1);
switch (op->nd_opt_len) {
case 1:
break;
case 2:
ND_TCHECK2(*in6p, 8);
memcpy(&in6, opri + 1, 8);
break;
case 3:
ND_TCHECK(*in6p);
memcpy(&in6, opri + 1, sizeof(in6));
break;
default:
goto trunc;
}
ND_PRINT((ndo," %s/%u", ip6addr_string(ndo, &in6),
opri->nd_opt_rti_prefixlen));
ND_PRINT((ndo,", pref=%s", get_rtpref(opri->nd_opt_rti_flags)));
ND_PRINT((ndo,", lifetime=%s",
get_lifetime(EXTRACT_32BITS(&opri->nd_opt_rti_lifetime))));
break;
default:
if (ndo->ndo_vflag <= 1) {
print_unknown_data(ndo,cp+2,"\n\t  ", (op->nd_opt_len << 3) - 2); /* skip option header */
return;
}
break;
}
/* do we want to see an additional hexdump ? */
if (ndo->ndo_vflag> 1)
print_unknown_data(ndo, cp+2,"\n\t    ", (op->nd_opt_len << 3) - 2); /* skip option header */

cp += op->nd_opt_len << 3;
resid -= op->nd_opt_len << 3;
}
return;

 trunc:
	ND_PRINT((ndo, "[ndp opt]"));
return;
#undef ECHECK
}

rpl_dio_printopt(netdissect_options *ndo,
const struct rpl_dio_genoption *opt,
u_int length)
{
if(length < RPL_DIO_GENOPTION_LEN) return;
length -= RPL_DIO_GENOPTION_LEN;

ND_TCHECK(opt->rpl_dio_len);

while((opt->rpl_dio_type == RPL_OPT_PAD0 &&
(const u_char *)opt < ndo->ndo_snapend) ||
ND_TTEST2(*opt,(opt->rpl_dio_len+2))) {

unsigned int optlen = opt->rpl_dio_len+2;
if(opt->rpl_dio_type == RPL_OPT_PAD0) {
optlen = 1;
ND_PRINT((ndo, " opt:pad0"));
} else {
ND_PRINT((ndo, " opt:%s len:%u ",
tok2str(rpl_subopt_values, "subopt:%u", opt->rpl_dio_type),
optlen));
if(ndo->ndo_vflag > 2) {
unsigned int paylen = opt->rpl_dio_len;
if(paylen > length) paylen = length;
hex_print(ndo,
" ",
((const uint8_t *)opt) + RPL_DIO_GENOPTION_LEN,  /* content of DIO option */
paylen);
}
}
opt = (const struct rpl_dio_genoption *)(((const char *)opt) + optlen);
length -= optlen;
}
return;
trunc:
	ND_PRINT((ndo," [|truncated]"));
return;
}

icmp6_print(netdissect_options *ndo,
const u_char *bp, u_int length, const u_char *bp2, int fragmented)
{
const struct icmp6_hdr *dp;
const struct ip6_hdr *ip;
const struct ip6_hdr *oip;
const struct udphdr *ouh;
int dport;
const u_char *ep;
u_int prot;

dp = (const struct icmp6_hdr *)bp;
ip = (const struct ip6_hdr *)bp2;
oip = (const struct ip6_hdr *)(dp + 1);
/* 'ep' points to the end of available data. */
ep = ndo->ndo_snapend;

ND_TCHECK(dp->icmp6_cksum);

if (ndo->ndo_vflag && !fragmented) {
uint16_t sum, udp_sum;

if (ND_TTEST2(bp[0], length)) {
udp_sum = EXTRACT_16BITS(&dp->icmp6_cksum);
sum = icmp6_cksum(ndo, ip, dp, length);
if (sum != 0)
ND_PRINT((ndo,"[bad icmp6 cksum 0x%04x -> 0x%04x!] ",
udp_sum,
in_cksum_shouldbe(udp_sum, sum)));
else
ND_PRINT((ndo,"[icmp6 sum ok] "));
}
}

ND_PRINT((ndo,"ICMP6, %s", tok2str(icmp6_type_values,"unknown icmp6 type (%u)",dp->icmp6_type)));

/* display cosmetics: print the packet length for printer that use the vflag now */
if (ndo->ndo_vflag && (dp->icmp6_type == ND_ROUTER_SOLICIT ||
dp->icmp6_type == ND_ROUTER_ADVERT ||
dp->icmp6_type == ND_NEIGHBOR_ADVERT ||
dp->icmp6_type == ND_NEIGHBOR_SOLICIT ||
dp->icmp6_type == ND_REDIRECT ||
dp->icmp6_type == ICMP6_HADISCOV_REPLY ||
dp->icmp6_type == ICMP6_MOBILEPREFIX_ADVERT ))
ND_PRINT((ndo,", length %u", length));

switch (dp->icmp6_type) {
case ICMP6_DST_UNREACH:
ND_TCHECK(oip->ip6_dst);
ND_PRINT((ndo,", %s", tok2str(icmp6_dst_unreach_code_values,"unknown unreach code (%u)",dp->icmp6_code)));
switch (dp->icmp6_code) {

case ICMP6_DST_UNREACH_NOROUTE: /* fall through */
case ICMP6_DST_UNREACH_ADMIN:
case ICMP6_DST_UNREACH_ADDR:
ND_PRINT((ndo," %s",ip6addr_string(ndo, &oip->ip6_dst)));
break;
case ICMP6_DST_UNREACH_BEYONDSCOPE:
ND_PRINT((ndo," %s, source address %s",
ip6addr_string(ndo, &oip->ip6_dst),
ip6addr_string(ndo, &oip->ip6_src)));
break;
case ICMP6_DST_UNREACH_NOPORT:
if ((ouh = get_upperlayer(ndo, (const u_char *)oip, &prot))
== NULL)
goto trunc;

dport = EXTRACT_16BITS(&ouh->uh_dport);
switch (prot) {
case IPPROTO_TCP:
ND_PRINT((ndo,", %s tcp port %s",
ip6addr_string(ndo, &oip->ip6_dst),
tcpport_string(ndo, dport)));
break;
case IPPROTO_UDP:
ND_PRINT((ndo,", %s udp port %s",
ip6addr_string(ndo, &oip->ip6_dst),
udpport_string(ndo, dport)));
break;
default:
ND_PRINT((ndo,", %s protocol %d port %d unreachable",
ip6addr_string(ndo, &oip->ip6_dst),
oip->ip6_nxt, dport));
break;
}
break;
default:
if (ndo->ndo_vflag <= 1) {
print_unknown_data(ndo, bp,"\n\t",length);
return;
}
break;
}
break;
case ICMP6_PACKET_TOO_BIG:
ND_TCHECK(dp->icmp6_mtu);
ND_PRINT((ndo,", mtu %u", EXTRACT_32BITS(&dp->icmp6_mtu)));
break;
case ICMP6_TIME_EXCEEDED:
ND_TCHECK(oip->ip6_dst);
switch (dp->icmp6_code) {
case ICMP6_TIME_EXCEED_TRANSIT:
ND_PRINT((ndo," for %s",
ip6addr_string(ndo, &oip->ip6_dst)));
break;
case ICMP6_TIME_EXCEED_REASSEMBLY:
ND_PRINT((ndo," (reassembly)"));
break;
default:
ND_PRINT((ndo,", unknown code (%u)", dp->icmp6_code));
break;
}
break;
case ICMP6_PARAM_PROB:
ND_TCHECK(oip->ip6_dst);
switch (dp->icmp6_code) {
case ICMP6_PARAMPROB_HEADER:
ND_PRINT((ndo,", erroneous - octet %u", EXTRACT_32BITS(&dp->icmp6_pptr)));
break;
case ICMP6_PARAMPROB_NEXTHEADER:
ND_PRINT((ndo,", next header - octet %u", EXTRACT_32BITS(&dp->icmp6_pptr)));
break;
case ICMP6_PARAMPROB_OPTION:
ND_PRINT((ndo,", option - octet %u", EXTRACT_32BITS(&dp->icmp6_pptr)));
break;
default:
ND_PRINT((ndo,", code-#%d",
dp->icmp6_code));
break;
}
break;
case ICMP6_ECHO_REQUEST:
case ICMP6_ECHO_REPLY:
ND_TCHECK(dp->icmp6_seq);
ND_PRINT((ndo,", seq %u", EXTRACT_16BITS(&dp->icmp6_seq)));
break;
case ICMP6_MEMBERSHIP_QUERY:
if (length == MLD_MINLEN) {
mld6_print(ndo, (const u_char *)dp);
} else if (length >= MLDV2_MINLEN) {
ND_PRINT((ndo," v2"));
mldv2_query_print(ndo, (const u_char *)dp, length);
} else {
ND_PRINT((ndo," unknown-version (len %u) ", length));
}
break;
case ICMP6_MEMBERSHIP_REPORT:
mld6_print(ndo, (const u_char *)dp);
break;
case ICMP6_MEMBERSHIP_REDUCTION:
mld6_print(ndo, (const u_char *)dp);
break;
case ND_ROUTER_SOLICIT:
#define RTSOLLEN 8
if (ndo->ndo_vflag) {
icmp6_opt_print(ndo, (const u_char *)dp + RTSOLLEN,
length - RTSOLLEN);
}
break;
case ND_ROUTER_ADVERT:
#define RTADVLEN 16
if (ndo->ndo_vflag) {
const struct nd_router_advert *p;

p = (const struct nd_router_advert *)dp;
ND_TCHECK(p->nd_ra_retransmit);
ND_PRINT((ndo,"\n\thop limit %u, Flags [%s]" \
", pref %s, router lifetime %us, reachable time %ums, retrans timer %ums",
(u_int)p->nd_ra_curhoplimit,
bittok2str(icmp6_opt_ra_flag_values,"none",(p->nd_ra_flags_reserved)),
get_rtpref(p->nd_ra_flags_reserved),
EXTRACT_16BITS(&p->nd_ra_router_lifetime),
EXTRACT_32BITS(&p->nd_ra_reachable),
EXTRACT_32BITS(&p->nd_ra_retransmit)));

icmp6_opt_print(ndo, (const u_char *)dp + RTADVLEN,
length - RTADVLEN);
}
break;
case ND_NEIGHBOR_SOLICIT:
{
const struct nd_neighbor_solicit *p;
p = (const struct nd_neighbor_solicit *)dp;
ND_TCHECK(p->nd_ns_target);
ND_PRINT((ndo,", who has %s", ip6addr_string(ndo, &p->nd_ns_target)));
if (ndo->ndo_vflag) {
#define NDSOLLEN 24
icmp6_opt_print(ndo, (const u_char *)dp + NDSOLLEN,
length - NDSOLLEN);
}
}
break;
case ND_NEIGHBOR_ADVERT:
{
const struct nd_neighbor_advert *p;

p = (const struct nd_neighbor_advert *)dp;
ND_TCHECK(p->nd_na_target);
ND_PRINT((ndo,", tgt is %s",
ip6addr_string(ndo, &p->nd_na_target)));
if (ndo->ndo_vflag) {
ND_PRINT((ndo,", Flags [%s]",
bittok2str(icmp6_nd_na_flag_values,
"none",
EXTRACT_32BITS(&p->nd_na_flags_reserved))));
#define NDADVLEN 24
icmp6_opt_print(ndo, (const u_char *)dp + NDADVLEN,
length - NDADVLEN);
#undef NDADVLEN
}
}
break;
case ND_REDIRECT:
#define RDR(i) ((const struct nd_redirect *)(i))
ND_TCHECK(RDR(dp)->nd_rd_dst);
ND_PRINT((ndo,", %s", ip6addr_string(ndo, &RDR(dp)->nd_rd_dst)));
ND_TCHECK(RDR(dp)->nd_rd_target);
ND_PRINT((ndo," to %s",
ip6addr_string(ndo, &RDR(dp)->nd_rd_target)));
#define REDIRECTLEN 40
if (ndo->ndo_vflag) {
icmp6_opt_print(ndo, (const u_char *)dp + REDIRECTLEN,
length - REDIRECTLEN);
}
break;
#undef REDIRECTLEN
#undef RDR
case ICMP6_ROUTER_RENUMBERING:
icmp6_rrenum_print(ndo, bp, ep);
break;
case ICMP6_NI_QUERY:
case ICMP6_NI_REPLY:
icmp6_nodeinfo_print(ndo, length, bp, ep);
break;
case IND_SOLICIT:
case IND_ADVERT:
break;
case ICMP6_V2_MEMBERSHIP_REPORT:
mldv2_report_print(ndo, (const u_char *) dp, length);
break;
case ICMP6_MOBILEPREFIX_SOLICIT: /* fall through */
case ICMP6_HADISCOV_REQUEST:
ND_TCHECK(dp->icmp6_data16[0]);
ND_PRINT((ndo,", id 0x%04x", EXTRACT_16BITS(&dp->icmp6_data16[0])));
break;
case ICMP6_HADISCOV_REPLY:
if (ndo->ndo_vflag) {
const struct in6_addr *in6;
const u_char *cp;

ND_TCHECK(dp->icmp6_data16[0]);
ND_PRINT((ndo,", id 0x%04x", EXTRACT_16BITS(&dp->icmp6_data16[0])));
cp = (const u_char *)dp + length;
in6 = (const struct in6_addr *)(dp + 1);
for (; (const u_char *)in6 < cp; in6++) {
ND_TCHECK(*in6);
ND_PRINT((ndo,", %s", ip6addr_string(ndo, in6)));
}
}
break;
case ICMP6_MOBILEPREFIX_ADVERT:
if (ndo->ndo_vflag) {
ND_TCHECK(dp->icmp6_data16[0]);
ND_PRINT((ndo,", id 0x%04x", EXTRACT_16BITS(&dp->icmp6_data16[0])));
ND_TCHECK(dp->icmp6_data16[1]);
if (dp->icmp6_data16[1] & 0xc0)
ND_PRINT((ndo," "));
if (dp->icmp6_data16[1] & 0x80)
ND_PRINT((ndo,"M"));
if (dp->icmp6_data16[1] & 0x40)
ND_PRINT((ndo,"O"));
#define MPADVLEN 8
icmp6_opt_print(ndo, (const u_char *)dp + MPADVLEN,
length - MPADVLEN);
}
break;
case ND_RPL_MESSAGE:
/* plus 4, because struct icmp6_hdr contains 4 bytes of icmp payload */
rpl_print(ndo, dp, &dp->icmp6_data8[0], length-sizeof(struct icmp6_hdr)+4);
break;
default:
ND_PRINT((ndo,", length %u", length));
if (ndo->ndo_vflag <= 1)
print_unknown_data(ndo, bp,"\n\t", length);
return;
}
if (!ndo->ndo_vflag)
ND_PRINT((ndo,", length %u", length));
return;
trunc:
	ND_PRINT((ndo, "[|icmp6]"));
}
