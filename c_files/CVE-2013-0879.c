void ProfileDependencyManager::AddComponent(
    ProfileKeyedBaseFactory* component) {
  all_components_.push_back(component);
  destruction_order_.clear();
}

  virtual ~SimpleAPIPermission() { }

scoped_refptr<Extension> LoadManifest(const std::string& dir,
                                      const std::string& test_file) {
  return LoadManifest(dir, test_file, Extension::NO_FLAGS);
}

std::string ProfileDependencyManager::DumpGraphvizDependency() {
  std::string result("digraph {\n");

  std::deque<ProfileKeyedBaseFactory*> components;
  std::copy(all_components_.begin(),
            all_components_.end(),
            std::back_inserter(components));

  std::deque<ProfileKeyedBaseFactory*>::iterator components_end =
      components.end();
  result.append("  /* Dependencies */\n");
  for (EdgeMap::const_iterator it = edges_.begin(); it != edges_.end(); ++it) {
    result.append("  ");
    result.append(it->second->name());
    result.append(" -> ");
    result.append(it->first->name());
    result.append(";\n");

    components_end = std::remove(components.begin(), components_end,
                                 it->second);
  }
  components.erase(components_end, components.end());

  result.append("\n  /* Toplevel attachments */\n");
  for (std::deque<ProfileKeyedBaseFactory*>::const_iterator it =
           components.begin(); it != components.end(); ++it) {
    result.append("  ");
    result.append((*it)->name());
    result.append(" -> Profile;\n");
  }

  result.append("\n  /* Toplevel profile */\n");
  result.append("  Profile [shape=box];\n");

  result.append("}\n");
  return result;
}

void ProfileDependencyManager::CreateProfileServices(Profile* profile,
                                                     bool is_testing_profile) {
#ifndef NDEBUG
  dead_profile_pointers_.erase(profile);
#endif

  AssertFactoriesBuilt();

  if (destruction_order_.empty())
    BuildDestructionOrder(profile);

  for (std::vector<ProfileKeyedBaseFactory*>::reverse_iterator rit =
           destruction_order_.rbegin(); rit != destruction_order_.rend();
       ++rit) {
    if (!profile->IsOffTheRecord()) {
      (*rit)->RegisterUserPrefsOnProfile(profile);
    }

    if (is_testing_profile && (*rit)->ServiceIsNULLWhileTesting()) {
      (*rit)->SetEmptyTestingFactory(profile);
    } else if ((*rit)->ServiceIsCreatedWithProfile()) {
      (*rit)->CreateServiceNow(profile);
    }
  }
}

APIPermission* APIPermissionInfo::CreateAPIPermission() const {
  return api_permission_constructor_ ?
    api_permission_constructor_(this) : new SimpleAPIPermission(this);
}

void ProfileDependencyManager::BuildDestructionOrder(Profile* profile) {
#if !defined(NDEBUG)
  if (CommandLine::ForCurrentProcess()->HasSwitch(
          switches::kDumpProfileDependencyGraph)) {
    FilePath dot_file =
        profile->GetPath().AppendASCII("profile-dependencies.dot");
    std::string contents = DumpGraphvizDependency();
    file_util::WriteFile(dot_file, contents.c_str(), contents.size());
  }
#endif

  std::deque<ProfileKeyedBaseFactory*> queue;
  std::copy(all_components_.begin(),
            all_components_.end(),
            std::back_inserter(queue));

  std::deque<ProfileKeyedBaseFactory*>::iterator queue_end = queue.end();
  for (EdgeMap::const_iterator it = edges_.begin();
       it != edges_.end(); ++it) {
    queue_end = std::remove(queue.begin(), queue_end, it->second);
  }
  queue.erase(queue_end, queue.end());

  std::vector<ProfileKeyedBaseFactory*> output;
  EdgeMap edges(edges_);
  while (!queue.empty()) {
    ProfileKeyedBaseFactory* node = queue.front();
    queue.pop_front();
    output.push_back(node);

    std::pair<EdgeMap::iterator, EdgeMap::iterator> range =
        edges.equal_range(node);
    EdgeMap::iterator it = range.first;
    while (it != range.second) {
      ProfileKeyedBaseFactory* dest = it->second;
      EdgeMap::iterator temp = it;
      it++;
      edges.erase(temp);

      bool has_incoming_edges = false;
      for (EdgeMap::iterator jt = edges.begin(); jt != edges.end(); ++jt) {
        if (jt->second == dest) {
          has_incoming_edges = true;
          break;
        }
      }

      if (!has_incoming_edges)
        queue.push_back(dest);
    }
  }

  if (edges.size()) {
    NOTREACHED() << "Dependency graph has a cycle. We are doomed.";
  }

  std::reverse(output.begin(), output.end());
  destruction_order_ = output;
}

const char* APIPermission::name() const {
  return info()->name();
}

bool Contains(const std::vector<string16>& warnings,
              const std::string& warning) {
  return IndexOf(warnings, warning) != warnings.size();
}

void ProfileDependencyManager::AssertFactoriesBuilt() {
  if (built_factories_)
    return;

#if defined(ENABLE_BACKGROUND)
  BackgroundContentsServiceFactory::GetInstance();
#endif
  BookmarkModelFactory::GetInstance();
#if defined(ENABLE_CAPTIVE_PORTAL_DETECTION)
  captive_portal::CaptivePortalServiceFactory::GetInstance();
#endif
  ChromeURLDataManagerFactory::GetInstance();
#if defined(ENABLE_PRINTING)
  CloudPrintProxyServiceFactory::GetInstance();
#endif
  CookieSettings::Factory::GetInstance();
#if defined(ENABLE_NOTIFICATIONS)
  DesktopNotificationServiceFactory::GetInstance();
#endif
  DownloadServiceFactory::GetInstance();
#if defined(ENABLE_EXTENSIONS)
  extensions::AppRestoreServiceFactory::GetInstance();
   extensions::BluetoothAPIFactory::GetInstance();
   extensions::CommandServiceFactory::GetInstance();
   extensions::CookiesAPIFactory::GetInstance();
   extensions::ExtensionSystemFactory::GetInstance();
   extensions::FontSettingsAPIFactory::GetInstance();
   extensions::IdleManagerFactory::GetInstance();
  extensions::ManagedModeAPIFactory::GetInstance();
  extensions::ProcessesAPIFactory::GetInstance();
  extensions::SuggestedLinksRegistryFactory::GetInstance();
  extensions::TabCaptureRegistryFactory::GetInstance();
  extensions::WebNavigationAPIFactory::GetInstance();
  ExtensionManagementAPIFactory::GetInstance();
#endif
  FaviconServiceFactory::GetInstance();
  FindBarStateFactory::GetInstance();
#if defined(USE_AURA)
  GesturePrefsObserverFactoryAura::GetInstance();
#endif
  GlobalErrorServiceFactory::GetInstance();
  GoogleURLTrackerFactory::GetInstance();
  HistoryServiceFactory::GetInstance();
  MediaGalleriesPreferencesFactory::GetInstance();
  NTPResourceCacheFactory::GetInstance();
  PasswordStoreFactory::GetInstance();
  PersonalDataManagerFactory::GetInstance();
#if !defined(OS_ANDROID)
  PinnedTabServiceFactory::GetInstance();
#endif
  PluginPrefsFactory::GetInstance();
#if defined(ENABLE_CONFIGURATION_POLICY) && !defined(OS_CHROMEOS)
  policy::UserPolicySigninServiceFactory::GetInstance();
#endif
  predictors::AutocompleteActionPredictorFactory::GetInstance();
  predictors::PredictorDatabaseFactory::GetInstance();
  predictors::ResourcePrefetchPredictorFactory::GetInstance();
  prerender::PrerenderManagerFactory::GetInstance();
  prerender::PrerenderLinkManagerFactory::GetInstance();
  ProfileSyncServiceFactory::GetInstance();
  ProtocolHandlerRegistryFactory::GetInstance();
#if defined(ENABLE_PROTECTOR_SERVICE)
  protector::ProtectorServiceFactory::GetInstance();
#endif
#if defined(ENABLE_SESSION_SERVICE)
  SessionServiceFactory::GetInstance();
#endif
  ShortcutsBackendFactory::GetInstance();
  ThumbnailServiceFactory::GetInstance();
  SigninManagerFactory::GetInstance();
#if defined(ENABLE_INPUT_SPEECH)
  SpeechInputExtensionManager::InitializeFactory();
  ChromeSpeechRecognitionPreferences::InitializeFactory();
#endif
  SpellcheckServiceFactory::GetInstance();
  TabRestoreServiceFactory::GetInstance();
  TemplateURLFetcherFactory::GetInstance();
  TemplateURLServiceFactory::GetInstance();
#if defined(ENABLE_THEMES)
  ThemeServiceFactory::GetInstance();
#endif
  TokenServiceFactory::GetInstance();
  UserStyleSheetWatcherFactory::GetInstance();
  VisitedLinkMasterFactory::GetInstance();
  WebDataServiceFactory::GetInstance();
#if defined(ENABLE_WEB_INTENTS)
  WebIntentsRegistryFactory::GetInstance();
#endif

  built_factories_ = true;
}

scoped_refptr<Extension> LoadManifest(const std::string& dir,
                                      const std::string& test_file,
                                      int extra_flags) {
  FilePath path;
  PathService::Get(chrome::DIR_TEST_DATA, &path);
  path = path.AppendASCII("extensions")
             .AppendASCII(dir)
             .AppendASCII(test_file);

  JSONFileValueSerializer serializer(path);
  std::string error;
  scoped_ptr<Value> result(serializer.Deserialize(NULL, &error));
  if (!result.get()) {
    EXPECT_EQ("", error);
    return NULL;
  }

  scoped_refptr<Extension> extension = Extension::Create(
      path.DirName(), Extension::INVALID,
      *static_cast<DictionaryValue*>(result.get()), extra_flags, &error);
  EXPECT_TRUE(extension) << error;
  return extension;
}

std::string APIPermission::ToString() const {
  return name();
}

ProfileDependencyManager* ProfileDependencyManager::GetInstance() {
  return Singleton<ProfileDependencyManager>::get();
}

void APIPermissionInfo::RegisterAllPermissions(
    PermissionsInfo* info) {

  struct PermissionRegistration {
    APIPermission::ID id;
    const char* name;
    int flags;
    int l10n_message_id;
    PermissionMessage::ID message_id;
    APIPermissionConstructor constructor;
  } PermissionsToRegister[] = {
    { APIPermission::kBackground, "background" },
    { APIPermission::kClipboardRead, "clipboardRead", kFlagNone,
      IDS_EXTENSION_PROMPT_WARNING_CLIPBOARD,
      PermissionMessage::kClipboard },
    { APIPermission::kClipboardWrite, "clipboardWrite" },
    { APIPermission::kDeclarativeWebRequest, "declarativeWebRequest" },
    { APIPermission::kDownloads, "downloads", kFlagNone,
      IDS_EXTENSION_PROMPT_WARNING_DOWNLOADS,
      PermissionMessage::kDownloads },
    { APIPermission::kExperimental, "experimental", kFlagCannotBeOptional },
    { APIPermission::kGeolocation, "geolocation", kFlagCannotBeOptional,
      IDS_EXTENSION_PROMPT_WARNING_GEOLOCATION,
      PermissionMessage::kGeolocation },
    { APIPermission::kNotification, "notifications" },
    { APIPermission::kUnlimitedStorage, "unlimitedStorage",
      kFlagCannotBeOptional },

    { APIPermission::kAppNotifications, "appNotifications" },

    { APIPermission::kActiveTab, "activeTab" },
    { APIPermission::kAlarms, "alarms" },
    { APIPermission::kBookmark, "bookmarks", kFlagNone,
      IDS_EXTENSION_PROMPT_WARNING_BOOKMARKS,
      PermissionMessage::kBookmarks },
    { APIPermission::kBrowsingData, "browsingData" },
    { APIPermission::kContentSettings, "contentSettings", kFlagNone,
      IDS_EXTENSION_PROMPT_WARNING_CONTENT_SETTINGS,
      PermissionMessage::kContentSettings },
    { APIPermission::kContextMenus, "contextMenus" },
    { APIPermission::kCookie, "cookies" },
    { APIPermission::kFileBrowserHandler, "fileBrowserHandler",
      kFlagCannotBeOptional },
    { APIPermission::kFontSettings, "fontSettings", kFlagCannotBeOptional },
    { APIPermission::kHistory, "history", kFlagNone,
      IDS_EXTENSION_PROMPT_WARNING_BROWSING_HISTORY,
      PermissionMessage::kBrowsingHistory },
    { APIPermission::kIdle, "idle" },
    { APIPermission::kInput, "input", kFlagNone,
      IDS_EXTENSION_PROMPT_WARNING_INPUT,
      PermissionMessage::kInput },
    { APIPermission::kManagement, "management", kFlagNone,
      IDS_EXTENSION_PROMPT_WARNING_MANAGEMENT,
      PermissionMessage::kManagement },
    { APIPermission::kPrivacy, "privacy", kFlagNone,
      IDS_EXTENSION_PROMPT_WARNING_PRIVACY,
      PermissionMessage::kPrivacy },
    { APIPermission::kStorage, "storage" },
    { APIPermission::kSyncFileSystem, "syncFileSystem" },
    { APIPermission::kTab, "tabs", kFlagNone,
      IDS_EXTENSION_PROMPT_WARNING_TABS,
      PermissionMessage::kTabs },
    { APIPermission::kTopSites, "topSites", kFlagNone,
      IDS_EXTENSION_PROMPT_WARNING_BROWSING_HISTORY,
      PermissionMessage::kBrowsingHistory },
    { APIPermission::kTts, "tts", 0, kFlagCannotBeOptional },
    { APIPermission::kTtsEngine, "ttsEngine", kFlagCannotBeOptional,
      IDS_EXTENSION_PROMPT_WARNING_TTS_ENGINE,
      PermissionMessage::kTtsEngine },
    { APIPermission::kWebNavigation, "webNavigation", kFlagNone,
      IDS_EXTENSION_PROMPT_WARNING_TABS, PermissionMessage::kTabs },
    { APIPermission::kWebRequest, "webRequest" },
    { APIPermission::kWebRequestBlocking, "webRequestBlocking" },
    { APIPermission::kWebView, "webview", kFlagCannotBeOptional },

    { APIPermission::kBookmarkManagerPrivate, "bookmarkManagerPrivate",
       kFlagCannotBeOptional },
     { APIPermission::kChromeosInfoPrivate, "chromeosInfoPrivate",
       kFlagCannotBeOptional },
     { APIPermission::kFileBrowserHandlerInternal, "fileBrowserHandlerInternal",
       kFlagCannotBeOptional },
     { APIPermission::kFileBrowserPrivate, "fileBrowserPrivate",
      kFlagCannotBeOptional },
    { APIPermission::kManagedModePrivate, "managedModePrivate",
      kFlagCannotBeOptional },
    { APIPermission::kMediaPlayerPrivate, "mediaPlayerPrivate",
      kFlagCannotBeOptional },
    { APIPermission::kMetricsPrivate, "metricsPrivate",
      kFlagCannotBeOptional },
    { APIPermission::kSystemPrivate, "systemPrivate",
      kFlagCannotBeOptional },
    { APIPermission::kCloudPrintPrivate, "cloudPrintPrivate",
      kFlagCannotBeOptional },
    { APIPermission::kInputMethodPrivate, "inputMethodPrivate",
      kFlagCannotBeOptional },
    { APIPermission::kEchoPrivate, "echoPrivate", kFlagCannotBeOptional },
    { APIPermission::kRtcPrivate, "rtcPrivate", kFlagCannotBeOptional },
    { APIPermission::kTerminalPrivate, "terminalPrivate",
      kFlagCannotBeOptional },
    { APIPermission::kWallpaperPrivate, "wallpaperPrivate",
      kFlagCannotBeOptional },
    { APIPermission::kWebRequestInternal, "webRequestInternal" },
    { APIPermission::kWebSocketProxyPrivate, "webSocketProxyPrivate",
      kFlagCannotBeOptional },
    { APIPermission::kWebstorePrivate, "webstorePrivate",
      kFlagCannotBeOptional },
    { APIPermission::kMediaGalleriesPrivate, "mediaGalleriesPrivate",
      kFlagCannotBeOptional },

    { APIPermission::kDebugger, "debugger",
      kFlagImpliesFullURLAccess | kFlagCannotBeOptional,
      IDS_EXTENSION_PROMPT_WARNING_DEBUGGER,
      PermissionMessage::kDebugger },
    { APIPermission::kDevtools, "devtools",
      kFlagImpliesFullURLAccess | kFlagCannotBeOptional },
    { APIPermission::kPageCapture, "pageCapture",
      kFlagImpliesFullURLAccess },
    { APIPermission::kTabCapture, "tabCapture",
      kFlagImpliesFullURLAccess },
    { APIPermission::kPlugin, "plugin",
      kFlagImpliesFullURLAccess | kFlagImpliesFullAccess |
          kFlagCannotBeOptional,
      IDS_EXTENSION_PROMPT_WARNING_FULL_ACCESS,
      PermissionMessage::kFullAccess },
    { APIPermission::kProxy, "proxy",
      kFlagImpliesFullURLAccess | kFlagCannotBeOptional },

    { APIPermission::kSerial, "serial", kFlagNone,
      IDS_EXTENSION_PROMPT_WARNING_SERIAL,
      PermissionMessage::kSerial },
    { APIPermission::kSocket, "socket", kFlagCannotBeOptional, 0,
      PermissionMessage::kNone, &::CreateAPIPermission<SocketPermission> },
    { APIPermission::kAppCurrentWindowInternal, "app.currentWindowInternal" },
    { APIPermission::kAppRuntime, "app.runtime" },
    { APIPermission::kAppWindow, "app.window" },
    { APIPermission::kAudioCapture, "audioCapture", kFlagNone,
      IDS_EXTENSION_PROMPT_WARNING_AUDIO_CAPTURE,
      PermissionMessage::kAudioCapture },
    { APIPermission::kVideoCapture, "videoCapture", kFlagNone,
      IDS_EXTENSION_PROMPT_WARNING_VIDEO_CAPTURE,
      PermissionMessage::kVideoCapture },
    { APIPermission::kFileSystem, "fileSystem" },
    { APIPermission::kFileSystemWrite, "fileSystem.write", kFlagNone,
      IDS_EXTENSION_PROMPT_WARNING_FILE_SYSTEM_WRITE,
      PermissionMessage::kFileSystemWrite },
    { APIPermission::kMediaGalleries, "mediaGalleries" },
    { APIPermission::kMediaGalleriesRead, "mediaGalleries.read" },
    { APIPermission::kMediaGalleriesAllAutoDetected,
      "mediaGalleries.allAutoDetected", kFlagNone,
      IDS_EXTENSION_PROMPT_WARNING_MEDIA_GALLERIES_ALL_GALLERIES,
      PermissionMessage::kMediaGalleriesAllGalleries },
    { APIPermission::kPushMessaging, "pushMessaging", kFlagCannotBeOptional },
    { APIPermission::kBluetooth, "bluetooth", kFlagNone,
      IDS_EXTENSION_PROMPT_WARNING_BLUETOOTH,
      PermissionMessage::kBluetooth },
    { APIPermission::kBluetoothDevice, "bluetoothDevice",
      kFlagNone, 0, PermissionMessage::kNone,
      &::CreateAPIPermission<BluetoothDevicePermission> },
    { APIPermission::kUsb, "usb", kFlagNone,
      IDS_EXTENSION_PROMPT_WARNING_USB,
      PermissionMessage::kUsb },
    { APIPermission::kSystemIndicator, "systemIndicator", kFlagNone,
      IDS_EXTENSION_PROMPT_WARNING_SYSTEM_INDICATOR,
      PermissionMessage::kSystemIndicator },
    { APIPermission::kPointerLock, "pointerLock" },
  };

  for (size_t i = 0; i < ARRAYSIZE_UNSAFE(PermissionsToRegister); ++i) {
    const PermissionRegistration& pr = PermissionsToRegister[i];
    info->RegisterPermission(
        pr.id, pr.name, pr.l10n_message_id,
        pr.message_id ? pr.message_id : PermissionMessage::kNone,
        pr.flags,
        pr.constructor);
  }

  info->RegisterAlias("unlimitedStorage", kOldUnlimitedStoragePermission);
  info->RegisterAlias("tabs", kWindowsPermission);
}

bool APIPermission::ManifestEntryForbidden() const {
  return false;
}

PermissionMessage APIPermissionInfo::GetMessage_() const {
  return PermissionMessage(
      message_id_, l10n_util::GetStringUTF16(l10n_message_id_));
}

  explicit SimpleAPIPermission(const APIPermissionInfo* permission)
    : APIPermission(permission) { }

APIPermission::~APIPermission() { }

ProfileDependencyManager::ProfileDependencyManager()
    : built_factories_(false) {
}

APIPermission::ID APIPermission::id() const {
  return info()->id();
}

void ProfileDependencyManager::AssertProfileWasntDestroyed(Profile* profile) {
  if (dead_profile_pointers_.find(profile) != dead_profile_pointers_.end()) {
    NOTREACHED() << "Attempted to access a Profile that was ShutDown(). This "
                 << "is most likely a heap smasher in progress. After "
                 << "ProfileKeyedService::Shutdown() completes, your service "
                 << "MUST NOT refer to depended Profile services again.";
  }
}

void ProfileDependencyManager::RemoveComponent(
    ProfileKeyedBaseFactory* component) {
  all_components_.erase(std::remove(all_components_.begin(),
                                    all_components_.end(),
                                    component),
                        all_components_.end());

  EdgeMap::iterator it = edges_.begin();
  while (it != edges_.end()) {
    EdgeMap::iterator temp = it;
    ++it;

    if (temp->first == component || temp->second == component)
      edges_.erase(temp);
  }

  destruction_order_.clear();
}
