void AudioInputRendererHost::OnDeviceStarted(
    int session_id, const std::string& device_id) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));
  SessionEntryMap::iterator it = session_entries_.find(session_id);
  if (it == session_entries_.end()) {
    DLOG(WARNING) << "AudioInputRendererHost::OnDeviceStarted()"
        " session does not exist.";
    return;
  }

  Send(new AudioInputMsg_NotifyDeviceStarted(it->second, device_id));
}

void AudioRendererHost::OnPlayStream(int stream_id) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));

  AudioEntry* entry = LookupById(stream_id);
  if (!entry) {
    SendErrorMessage(stream_id);
    return;
  }

  entry->controller->Play();
  if (media_observer_)
    media_observer_->OnSetAudioStreamPlaying(this, stream_id, true);
}

media::AudioOutputController* AudioRendererHost::LookupControllerByIdForTesting(
    int stream_id) {
  AudioEntry* const entry = LookupById(stream_id);
  return entry ? entry->controller : NULL;
}

void AudioRendererHost::OnCloseStream(int stream_id) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));

  if (media_observer_)
    media_observer_->OnSetAudioStreamStatus(this, stream_id, "closed");

  AudioEntry* entry = LookupById(stream_id);

  if (entry)
    CloseAndDeleteStream(entry);
}

void AudioInputRendererHost::OnCreateStream(
int stream_id, const media::AudioParameters& params,
const std::string& device_id, bool automatic_gain_control) {
VLOG(1) << "AudioInputRendererHost::OnCreateStream(stream_id="
<< stream_id << ")";
DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));
  DCHECK(LookupById(stream_id) == NULL);

media::AudioParameters audio_params(params);

if (media_stream_manager_->audio_input_device_manager()->
ShouldUseFakeDevice()) {
audio_params.Reset(media::AudioParameters::AUDIO_FAKE,
params.channel_layout(), params.sample_rate(),
params.bits_per_sample(), params.frames_per_buffer());
} else if (WebContentsCaptureUtil::IsWebContentsDeviceId(device_id)) {
audio_params.Reset(media::AudioParameters::AUDIO_VIRTUAL,
params.channel_layout(), params.sample_rate(),
params.bits_per_sample(), params.frames_per_buffer());
}

  DCHECK_GT(audio_params.frames_per_buffer(), 0);
uint32 buffer_size = audio_params.GetBytesPerBuffer();

// Create a new AudioEntry structure.
scoped_ptr<AudioEntry> entry(new AudioEntry());

uint32 mem_size = sizeof(media::AudioInputBufferParameters) + buffer_size;

// Create the shared memory and share it with the renderer process
// using a new SyncWriter object.
if (!entry->shared_memory.CreateAndMapAnonymous(mem_size)) {
// If creation of shared memory failed then send an error message.
SendErrorMessage(stream_id);
return;
}

scoped_ptr<AudioInputSyncWriter> writer(
new AudioInputSyncWriter(&entry->shared_memory));

if (!writer->Init()) {
SendErrorMessage(stream_id);
return;
}

// If we have successfully created the SyncWriter then assign it to the
// entry and construct an AudioInputController.
// TODO(henrika): replace CreateLowLatency() with Create() as soon
// as satish has ensured that Speech Input also uses the default low-
// latency path. See crbug.com/112472 for details.
entry->writer.reset(writer.release());
entry->controller = media::AudioInputController::CreateLowLatency(
audio_manager_,
this,
audio_params,
device_id,
entry->writer.get());

if (!entry->controller) {
SendErrorMessage(stream_id);
return;
}

// Set the initial AGC state for the audio input stream. Note that, the AGC
// is only supported in AUDIO_PCM_LOW_LATENCY mode.
if (params.format() == media::AudioParameters::AUDIO_PCM_LOW_LATENCY)
entry->controller->SetAutomaticGainControl(automatic_gain_control);

// If we have created the controller successfully create a entry and add it
// to the map.
entry->stream_id = stream_id;

audio_entries_.insert(std::make_pair(stream_id, entry.release()));
}

void AudioInputRendererHost::OnDestruct() const {
  BrowserThread::DeleteOnIOThread::Destruct(this);
}

void AudioRendererHost::OnPauseStream(int stream_id) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));

  AudioEntry* entry = LookupById(stream_id);
  if (!entry) {
    SendErrorMessage(stream_id);
    return;
  }

  entry->controller->Pause();
  if (media_observer_)
    media_observer_->OnSetAudioStreamPlaying(this, stream_id, false);
}

void AudioInputRendererHost::OnCreated(
    media::AudioInputController* controller) {
  BrowserThread::PostTask(
      BrowserThread::IO,
      FROM_HERE,
      base::Bind(
          &AudioInputRendererHost::DoCompleteCreation,
          this,
          make_scoped_refptr(controller)));
}

bool AudioRendererHost::OnMessageReceived(const IPC::Message& message,
                                          bool* message_was_ok) {
  bool handled = true;
  IPC_BEGIN_MESSAGE_MAP_EX(AudioRendererHost, message, *message_was_ok)
    IPC_MESSAGE_HANDLER(AudioHostMsg_CreateStream, OnCreateStream)
    IPC_MESSAGE_HANDLER(AudioHostMsg_AssociateStreamWithProducer,
                        OnAssociateStreamWithProducer)
    IPC_MESSAGE_HANDLER(AudioHostMsg_PlayStream, OnPlayStream)
    IPC_MESSAGE_HANDLER(AudioHostMsg_PauseStream, OnPauseStream)
    IPC_MESSAGE_HANDLER(AudioHostMsg_FlushStream, OnFlushStream)
    IPC_MESSAGE_HANDLER(AudioHostMsg_CloseStream, OnCloseStream)
    IPC_MESSAGE_HANDLER(AudioHostMsg_SetVolume, OnSetVolume)
    IPC_MESSAGE_UNHANDLED(handled = false)
  IPC_END_MESSAGE_MAP_EX()

  return handled;
}

void AudioRendererHost::OnPlaying(media::AudioOutputController* controller) {
  BrowserThread::PostTask(
      BrowserThread::IO,
      FROM_HERE,
      base::Bind(
          &AudioRendererHost::DoSendPlayingMessage,
          this,
          make_scoped_refptr(controller)));
}

void AudioRendererHost::OnFlushStream(int stream_id) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));

  AudioEntry* entry = LookupById(stream_id);
  if (!entry) {
    SendErrorMessage(stream_id);
    return;
  }

  entry->controller->Flush();
  if (media_observer_)
    media_observer_->OnSetAudioStreamStatus(this, stream_id, "flushed");
}

void AudioInputRendererHost::SendErrorMessage(int stream_id) {
  Send(new AudioInputMsg_NotifyStreamStateChanged(
      stream_id, media::AudioInputIPCDelegate::kError));
}

void AudioRendererHost::OnPaused(media::AudioOutputController* controller) {
  BrowserThread::PostTask(
      BrowserThread::IO,
      FROM_HERE,
      base::Bind(
          &AudioRendererHost::DoSendPausedMessage,
          this,
          make_scoped_refptr(controller)));
}

AudioInputRendererHost::AudioInputRendererHost(
    media::AudioManager* audio_manager,
    MediaStreamManager* media_stream_manager)
    : audio_manager_(audio_manager),
      media_stream_manager_(media_stream_manager) {
}

void AudioInputRendererHost::DeleteEntries() {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));

  for (AudioEntryMap::iterator i = audio_entries_.begin();
       i != audio_entries_.end(); ++i) {
    CloseAndDeleteStream(i->second);
  }
}

void ParamTraits<AudioParameters>::Log(const AudioParameters& p,
                                       std::string* l) {
  l->append(base::StringPrintf("<AudioParameters>"));
}

void AudioInputRendererHost::OnCloseStream(int stream_id) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));

  AudioEntry* entry = LookupById(stream_id);

  if (entry)
    CloseAndDeleteStream(entry);

  int session_id = LookupSessionById(stream_id);

  if (session_id)
    StopAndDeleteDevice(session_id);
}

void AudioInputRendererHost::StopAndDeleteDevice(int session_id) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));

  media_stream_manager_->audio_input_device_manager()->Stop(session_id);

  session_entries_.erase(session_id);
}

void AudioInputRendererHost::DeleteEntry(AudioEntry* entry) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));

  scoped_ptr<AudioEntry> entry_deleter(entry);

  audio_entries_.erase(entry->stream_id);
}

void AudioRendererHost::OnCreateStream(
int stream_id, const media::AudioParameters& params, int input_channels) {
DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));
  DCHECK(LookupById(stream_id) == NULL);

media::AudioParameters audio_params(params);
  uint32 buffer_size = media::AudioBus::CalculateMemorySize(audio_params);
  DCHECK_GT(buffer_size, 0U);
  DCHECK_LE(buffer_size,
            static_cast<uint32>(media::limits::kMaxPacketSizeInBytes));
  DCHECK_GE(input_channels, 0);
  DCHECK_LT(input_channels, media::limits::kMaxChannels);

// Calculate output and input memory size.
int output_memory_size = AudioBus::CalculateMemorySize(audio_params);
  DCHECK_GT(output_memory_size, 0);

int frames = audio_params.frames_per_buffer();
int input_memory_size =
AudioBus::CalculateMemorySize(input_channels, frames);

  DCHECK_GE(input_memory_size, 0);
scoped_ptr<AudioEntry> entry(new AudioEntry());

// Create the shared memory and share with the renderer process.
// For synchronized I/O (if input_channels > 0) then we allocate
// extra memory after the output data for the input data.
uint32 io_buffer_size = output_memory_size + input_memory_size;

uint32 shared_memory_size =
media::TotalSharedMemorySizeInBytes(io_buffer_size);
if (!entry->shared_memory.CreateAndMapAnonymous(shared_memory_size)) {
// If creation of shared memory failed then send an error message.
SendErrorMessage(stream_id);
return;
}

// Create sync reader and try to initialize it.
scoped_ptr<AudioSyncReader> reader(
new AudioSyncReader(&entry->shared_memory, params, input_channels));

if (!reader->Init()) {
SendErrorMessage(stream_id);
return;
}

// If we have successfully created the SyncReader then assign it to the
// entry and construct an AudioOutputController.
entry->reader.reset(reader.release());
entry->controller = media::AudioOutputController::Create(
audio_manager_, this, audio_params, entry->reader.get());

if (!entry->controller) {
SendErrorMessage(stream_id);
return;
}

// If we have created the controller successfully, create an entry and add it
// to the map.
entry->stream_id = stream_id;
audio_entries_.insert(std::make_pair(stream_id, entry.release()));
if (media_observer_)
media_observer_->OnSetAudioStreamStatus(this, stream_id, "created");
}

void AudioInputRendererHost::CloseAndDeleteStream(AudioEntry* entry) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));

  if (!entry->pending_close) {
    entry->controller->Close(base::Bind(&AudioInputRendererHost::DeleteEntry,
                                        this, entry));
    entry->pending_close = true;
  }
}

void AudioRendererHost::SendErrorMessage(int32 stream_id) {
  Send(new AudioMsg_NotifyStreamStateChanged(
      stream_id, media::AudioOutputIPCDelegate::kError));
}

void AudioRendererHost::CloseAndDeleteStream(AudioEntry* entry) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));

  if (!entry->pending_close) {
    entry->controller->Close(
        base::Bind(&AudioRendererHost::DeleteEntry, this, entry));
    entry->pending_close = true;
  }
}

AudioInputRendererHost::AudioEntry::~AudioEntry() {}

void AudioRendererHost::DoSendPlayingMessage(
    media::AudioOutputController* controller) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));

  AudioEntry* entry = LookupByController(controller);
  if (!entry)
    return;

  Send(new AudioMsg_NotifyStreamStateChanged(
      entry->stream_id, media::AudioOutputIPCDelegate::kPlaying));
}

void AudioRendererHost::DeleteEntry(AudioEntry* entry) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));

  scoped_ptr<AudioEntry> entry_deleter(entry);

  audio_entries_.erase(entry->stream_id);

  if (media_observer_)
    media_observer_->OnDeleteAudioStream(this, entry->stream_id);
}

AudioRendererHost::AudioRendererHost(
    media::AudioManager* audio_manager, MediaObserver* media_observer)
    : audio_manager_(audio_manager),
      media_observer_(media_observer) {
}

AudioRendererHost::AudioEntry* AudioRendererHost::LookupByController(
    media::AudioOutputController* controller) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));

  for (AudioEntryMap::iterator i = audio_entries_.begin();
       i != audio_entries_.end(); ++i) {
    if (!i->second->pending_close && controller == i->second->controller.get())
      return i->second;
  }
  return NULL;
}

void AudioInputRendererHost::OnRecordStream(int stream_id) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));

  AudioEntry* entry = LookupById(stream_id);
  if (!entry) {
    SendErrorMessage(stream_id);
    return;
  }

  entry->controller->Record();
}

void AudioInputRendererHost::OnSetVolume(int stream_id, double volume) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));

  AudioEntry* entry = LookupById(stream_id);
  if (!entry) {
    SendErrorMessage(stream_id);
    return;
  }

  entry->controller->SetVolume(volume);
}

void AudioInputRendererHost::DoCompleteCreation(
    media::AudioInputController* controller) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));

  AudioEntry* entry = LookupByController(controller);
  if (!entry)
    return;

  if (!peer_handle()) {
    NOTREACHED() << "Renderer process handle is invalid.";
    DeleteEntryOnError(entry);
    return;
  }

  if (!entry->controller->LowLatencyMode()) {
    NOTREACHED() << "Only low-latency mode is supported.";
    DeleteEntryOnError(entry);
    return;
  }

  base::SharedMemoryHandle foreign_memory_handle;
  if (!entry->shared_memory.ShareToProcess(peer_handle(),
                                           &foreign_memory_handle)) {
    DeleteEntryOnError(entry);
    return;
  }

  AudioInputSyncWriter* writer =
      static_cast<AudioInputSyncWriter*>(entry->writer.get());

#if defined(OS_WIN)
  base::SyncSocket::Handle foreign_socket_handle;
#else
  base::FileDescriptor foreign_socket_handle;
#endif

  if (!writer->PrepareForeignSocketHandle(peer_handle(),
                                          &foreign_socket_handle)) {
    DeleteEntryOnError(entry);
    return;
  }

  Send(new AudioInputMsg_NotifyStreamCreated(entry->stream_id,
      foreign_memory_handle, foreign_socket_handle,
      entry->shared_memory.created_size()));
}

void AudioRendererHost::DeleteEntryOnError(AudioEntry* entry) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));

  SendErrorMessage(entry->stream_id);

  if (media_observer_)
    media_observer_->OnSetAudioStreamStatus(this, entry->stream_id, "error");
  CloseAndDeleteStream(entry);
}

void AudioInputRendererHost::OnStartDevice(int stream_id, int session_id) {
  VLOG(1) << "AudioInputRendererHost::OnStartDevice(stream_id="
          << stream_id << ", session_id = " << session_id << ")";

  session_entries_[session_id] = stream_id;

  media_stream_manager_->audio_input_device_manager()->Start(session_id, this);
}

void AudioRendererHost::OnError(media::AudioOutputController* controller,
                                int error_code) {
  BrowserThread::PostTask(
      BrowserThread::IO,
      FROM_HERE,
      base::Bind(&AudioRendererHost::DoHandleError,
                 this, make_scoped_refptr(controller), error_code));
}

void AudioRendererHost::DoSendPausedMessage(
    media::AudioOutputController* controller) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));

  AudioEntry* entry = LookupByController(controller);
  if (!entry)
    return;

  Send(new AudioMsg_NotifyStreamStateChanged(
      entry->stream_id, media::AudioOutputIPCDelegate::kPaused));
}

void AudioInputRendererHost::OnChannelClosing() {
  BrowserMessageFilter::OnChannelClosing();

  DeleteEntries();
}

void AudioRendererHost::OnSetVolume(int stream_id, double volume) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));

  AudioEntry* entry = LookupById(stream_id);
  if (!entry) {
    SendErrorMessage(stream_id);
    return;
  }

  if (volume < 0 || volume > 1.0)
    return;
  entry->controller->SetVolume(volume);
  if (media_observer_)
    media_observer_->OnSetAudioStreamVolume(this, stream_id, volume);
}

AudioInputRendererHost::AudioEntry::AudioEntry()
    : stream_id(0),
      pending_close(false) {
}

AudioInputRendererHost::AudioEntry* AudioInputRendererHost::LookupByController(
    media::AudioInputController* controller) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));

  for (AudioEntryMap::iterator i = audio_entries_.begin();
       i != audio_entries_.end(); ++i) {
    if (controller == i->second->controller.get())
      return i->second;
  }
  return NULL;
}

void AudioInputRendererHost::OnAssociateStreamWithConsumer(int stream_id,
                                                           int render_view_id) {
  DVLOG(1) << "AudioInputRendererHost@" << this
           << "::OnAssociateStreamWithConsumer(stream_id=" << stream_id
           << ", render_view_id=" << render_view_id << ")";
}

void AudioInputRendererHost::OnData(media::AudioInputController* controller,
                                    const uint8* data,
                                    uint32 size) {
  NOTREACHED() << "Only low-latency mode is supported.";
}

void AudioInputRendererHost::DoHandleError(
    media::AudioInputController* controller,
    int error_code) {
  DLOG(WARNING) << "AudioInputRendererHost::DoHandleError(error_code="
                << error_code << ")";
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));

  AudioEntry* entry = LookupByController(controller);
  if (!entry)
    return;

  DeleteEntryOnError(entry);
}

void AudioInputRendererHost::OnDeviceStopped(int session_id) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));

  SessionEntryMap::iterator it = session_entries_.find(session_id);
  if (it == session_entries_.end())
    return;

  int stream_id = it->second;
  AudioEntry* entry = LookupById(stream_id);

  if (entry) {
    CloseAndDeleteStream(entry);
    Send(new AudioInputMsg_NotifyStreamStateChanged(
        stream_id, media::AudioInputIPCDelegate::kStopped));
  }

  session_entries_.erase(it);
}

AudioInputRendererHost::AudioEntry* AudioInputRendererHost::LookupById(
    int stream_id) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));

  AudioEntryMap::iterator i = audio_entries_.find(stream_id);
  if (i != audio_entries_.end())
    return i->second;
  return NULL;
}

void AudioInputRendererHost::DoSendRecordingMessage(
    media::AudioInputController* controller) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));
}

int AudioInputRendererHost::LookupSessionById(int stream_id) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));

  for (SessionEntryMap::iterator it = session_entries_.begin();
       it != session_entries_.end(); ++it) {
    if (stream_id == it->second) {
      return it->first;
    }
  }
  return 0;
}

void AudioRendererHost::OnAssociateStreamWithProducer(int stream_id,
                                                      int render_view_id) {
  DVLOG(1) << "AudioRendererHost@" << this
           << "::OnAssociateStreamWithProducer(stream_id=" << stream_id
           << ", render_view_id=" << render_view_id << ")";
}
