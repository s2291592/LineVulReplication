 status_t OMXNodeInstance::updateGraphicBufferInMeta_l(
         OMX_U32 portIndex, const sp<GraphicBuffer>& graphicBuffer,
         OMX::buffer_id buffer, OMX_BUFFERHEADERTYPE *header) {
     if (portIndex != kPortIndexInput && portIndex != kPortIndexOutput) {
         return BAD_VALUE;
     }

 BufferMeta *bufferMeta = (BufferMeta *)(header->pAppPrivate);
    bufferMeta->setGraphicBuffer(graphicBuffer);
 if (mMetadataType[portIndex] == kMetadataBufferTypeGrallocSource
 && header->nAllocLen >= sizeof(VideoGrallocMetadata)) {
 VideoGrallocMetadata &metadata = *(VideoGrallocMetadata *)(header->pBuffer);
        metadata.eType = kMetadataBufferTypeGrallocSource;
        metadata.pHandle = graphicBuffer == NULL ? NULL : graphicBuffer->handle;
 } else if (mMetadataType[portIndex] == kMetadataBufferTypeANWBuffer
 && header->nAllocLen >= sizeof(VideoNativeMetadata)) {
 VideoNativeMetadata &metadata = *(VideoNativeMetadata *)(header->pBuffer);
        metadata.eType = kMetadataBufferTypeANWBuffer;
        metadata.pBuffer = graphicBuffer == NULL ? NULL : graphicBuffer->getNativeBuffer();
        metadata.nFenceFd = -1;
 } else {
        CLOG_BUFFER(updateGraphicBufferInMeta, "%s:%u, %#x bad type (%d) or size (%u)",
            portString(portIndex), portIndex, buffer, mMetadataType[portIndex], header->nAllocLen);
 return BAD_VALUE;
 }

    CLOG_BUFFER(updateGraphicBufferInMeta, "%s:%u, %#x := %p",
            portString(portIndex), portIndex, buffer,
            graphicBuffer == NULL ? NULL : graphicBuffer->handle);
 return OK;
}

bool OMXNodeInstance::handleMessage(omx_message &msg) {
const sp<GraphicBufferSource>& bufferSource(getGraphicBufferSource());


if (msg.type == omx_message::FILL_BUFFER_DONE) {
OMX_BUFFERHEADERTYPE *buffer =
            findBufferHeader(msg.u.extended_buffer_data.buffer);

{
Mutex::Autolock _l(mDebugLock);
mOutputBuffersWithCodec.remove(buffer);

CLOG_BUMPED_BUFFER(
FBD, WITH_STATS(FULL_BUFFER(
msg.u.extended_buffer_data.buffer, buffer, msg.fenceFd)));

unbumpDebugLevel_l(kPortIndexOutput);
}

BufferMeta *buffer_meta =
static_cast<BufferMeta *>(buffer->pAppPrivate);

if (buffer->nOffset + buffer->nFilledLen < buffer->nOffset
|| buffer->nOffset + buffer->nFilledLen > buffer->nAllocLen) {
CLOG_ERROR(onFillBufferDone, OMX_ErrorBadParameter,
FULL_BUFFER(NULL, buffer, msg.fenceFd));
}
buffer_meta->CopyFromOMX(buffer);

if (bufferSource != NULL) {
// fix up the buffer info (especially timestamp) if needed
bufferSource->codecBufferFilled(buffer);

msg.u.extended_buffer_data.timestamp = buffer->nTimeStamp;

}
} else if (msg.type == omx_message::EMPTY_BUFFER_DONE) {
OMX_BUFFERHEADERTYPE *buffer =
            findBufferHeader(msg.u.buffer_data.buffer);

{
Mutex::Autolock _l(mDebugLock);
mInputBuffersWithCodec.remove(buffer);

CLOG_BUMPED_BUFFER(
EBD, WITH_STATS(EMPTY_BUFFER(msg.u.buffer_data.buffer, buffer, msg.fenceFd)));
}

if (bufferSource != NULL) {
// This is one of the buffers used exclusively by
// GraphicBufferSource.
// Don't dispatch a message back to ACodec, since it doesn't
// know that anyone asked to have the buffer emptied and will
// be very confused.
bufferSource->codecBufferEmptied(buffer, msg.fenceFd);
return true;
}
}

return false;
}

status_t OMXNodeInstance::fillBuffer(OMX::buffer_id buffer, int fenceFd) {
Mutex::Autolock autoLock(mLock);

    OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer);
header->nFilledLen = 0;
header->nOffset = 0;
header->nFlags = 0;

// meta now owns fenceFd
status_t res = storeFenceInMeta_l(header, fenceFd, kPortIndexOutput);
if (res != OK) {
CLOG_ERROR(fillBuffer::storeFenceInMeta, res, EMPTY_BUFFER(buffer, header, fenceFd));
return res;
}

{
Mutex::Autolock _l(mDebugLock);
mOutputBuffersWithCodec.add(header);
CLOG_BUMPED_BUFFER(fillBuffer, WITH_STATS(EMPTY_BUFFER(buffer, header, fenceFd)));
}

OMX_ERRORTYPE err = OMX_FillThisBuffer(mHandle, header);
if (err != OMX_ErrorNone) {
CLOG_ERROR(fillBuffer, err, EMPTY_BUFFER(buffer, header, fenceFd));
Mutex::Autolock _l(mDebugLock);
mOutputBuffersWithCodec.remove(header);
}
return StatusFromOMXError(err);
}

BufferMeta(size_t size)
: mSize(size),
          mIsBackup(false) {
}

status_t OMXNodeInstance::setInternalOption(
        OMX_U32 portIndex,
        IOMX::InternalOptionType type,
 const void *data,
 size_t size) {
    CLOG_CONFIG(setInternalOption, "%s(%d): %s:%u %zu@%p",
            asString(type), type, portString(portIndex), portIndex, size, data);
 switch (type) {
 case IOMX::INTERNAL_OPTION_SUSPEND:
 case IOMX::INTERNAL_OPTION_REPEAT_PREVIOUS_FRAME_DELAY:
 case IOMX::INTERNAL_OPTION_MAX_TIMESTAMP_GAP:
 case IOMX::INTERNAL_OPTION_MAX_FPS:
 case IOMX::INTERNAL_OPTION_START_TIME:
 case IOMX::INTERNAL_OPTION_TIME_LAPSE:
 {
 const sp<GraphicBufferSource> &bufferSource =
                getGraphicBufferSource();

 if (bufferSource == NULL || portIndex != kPortIndexInput) {
                CLOGW("setInternalOption is only for Surface input");
 return ERROR_UNSUPPORTED;
 }

 if (type == IOMX::INTERNAL_OPTION_SUSPEND) {
 if (size != sizeof(bool)) {
 return INVALID_OPERATION;
 }

 bool suspend = *(bool *)data;
                CLOG_CONFIG(setInternalOption, "suspend=%d", suspend);
                bufferSource->suspend(suspend);
 } else if (type ==
                    IOMX::INTERNAL_OPTION_REPEAT_PREVIOUS_FRAME_DELAY){
 if (size != sizeof(int64_t)) {
 return INVALID_OPERATION;
 }

 int64_t delayUs = *(int64_t *)data;
                CLOG_CONFIG(setInternalOption, "delayUs=%lld", (long long)delayUs);
 return bufferSource->setRepeatPreviousFrameDelayUs(delayUs);
 } else if (type ==
                    IOMX::INTERNAL_OPTION_MAX_TIMESTAMP_GAP){
 if (size != sizeof(int64_t)) {
 return INVALID_OPERATION;
 }

 int64_t maxGapUs = *(int64_t *)data;
                CLOG_CONFIG(setInternalOption, "gapUs=%lld", (long long)maxGapUs);
 return bufferSource->setMaxTimestampGapUs(maxGapUs);
 } else if (type == IOMX::INTERNAL_OPTION_MAX_FPS) {
 if (size != sizeof(float)) {
 return INVALID_OPERATION;
 }

 float maxFps = *(float *)data;
                CLOG_CONFIG(setInternalOption, "maxFps=%f", maxFps);
 return bufferSource->setMaxFps(maxFps);
 } else if (type == IOMX::INTERNAL_OPTION_START_TIME) {
 if (size != sizeof(int64_t)) {
 return INVALID_OPERATION;
 }

 int64_t skipFramesBeforeUs = *(int64_t *)data;
                CLOG_CONFIG(setInternalOption, "beforeUs=%lld", (long long)skipFramesBeforeUs);
                bufferSource->setSkipFramesBeforeUs(skipFramesBeforeUs);
 } else { // IOMX::INTERNAL_OPTION_TIME_LAPSE
 if (size != sizeof(int64_t) * 2) {
 return INVALID_OPERATION;
 }

 int64_t timePerFrameUs = ((int64_t *)data)[0];
 int64_t timePerCaptureUs = ((int64_t *)data)[1];
                CLOG_CONFIG(setInternalOption, "perFrameUs=%lld perCaptureUs=%lld",
 (long long)timePerFrameUs, (long long)timePerCaptureUs);

                bufferSource->setTimeLapseUs((int64_t *)data);
 }

 return OK;
 }

 default:
 return ERROR_UNSUPPORTED;
 }
}

status_t OMXNodeInstance::freeBuffer(
OMX_U32 portIndex, OMX::buffer_id buffer) {
Mutex::Autolock autoLock(mLock);
CLOG_BUFFER(freeBuffer, "%s:%u %#x", portString(portIndex), portIndex, buffer);


removeActiveBuffer(portIndex, buffer);

    OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer);
BufferMeta *buffer_meta = static_cast<BufferMeta *>(header->pAppPrivate);

OMX_ERRORTYPE err = OMX_FreeBuffer(mHandle, portIndex, header);
CLOG_IF_ERROR(freeBuffer, err, "%s:%u %#x", portString(portIndex), portIndex, buffer);

delete buffer_meta;
buffer_meta = NULL;
invalidateBufferID(buffer);

return StatusFromOMXError(err);
}

status_t OMXNodeInstance::emptyBuffer(
OMX::buffer_id buffer,
OMX_U32 rangeOffset, OMX_U32 rangeLength,

OMX_U32 flags, OMX_TICKS timestamp, int fenceFd) {
Mutex::Autolock autoLock(mLock);

    OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer);
BufferMeta *buffer_meta =
static_cast<BufferMeta *>(header->pAppPrivate);
sp<ABuffer> backup = buffer_meta->getBuffer(header, true /* backup */, false /* limit */);
sp<ABuffer> codec = buffer_meta->getBuffer(header, false /* backup */, false /* limit */);

// convert incoming ANW meta buffers if component is configured for gralloc metadata mode
// ignore rangeOffset in this case
if (mMetadataType[kPortIndexInput] == kMetadataBufferTypeGrallocSource
&& backup->capacity() >= sizeof(VideoNativeMetadata)
&& codec->capacity() >= sizeof(VideoGrallocMetadata)
&& ((VideoNativeMetadata *)backup->base())->eType
== kMetadataBufferTypeANWBuffer) {
VideoNativeMetadata &backupMeta = *(VideoNativeMetadata *)backup->base();
VideoGrallocMetadata &codecMeta = *(VideoGrallocMetadata *)codec->base();
CLOG_BUFFER(emptyBuffer, "converting ANWB %p to handle %p",
backupMeta.pBuffer, backupMeta.pBuffer->handle);
codecMeta.pHandle = backupMeta.pBuffer != NULL ? backupMeta.pBuffer->handle : NULL;
codecMeta.eType = kMetadataBufferTypeGrallocSource;
header->nFilledLen = rangeLength ? sizeof(codecMeta) : 0;
header->nOffset = 0;
} else {
// rangeLength and rangeOffset must be a subset of the allocated data in the buffer.
// corner case: we permit rangeOffset == end-of-buffer with rangeLength == 0.
if (rangeOffset > header->nAllocLen
|| rangeLength > header->nAllocLen - rangeOffset) {
CLOG_ERROR(emptyBuffer, OMX_ErrorBadParameter, FULL_BUFFER(NULL, header, fenceFd));
if (fenceFd >= 0) {
::close(fenceFd);
}
return BAD_VALUE;
}
header->nFilledLen = rangeLength;
header->nOffset = rangeOffset;

buffer_meta->CopyToOMX(header);
}

return emptyBuffer_l(header, flags, timestamp, (intptr_t)buffer, fenceFd);
}

status_t OMXNodeInstance::storeMetaDataInBuffers_l(
        OMX_U32 portIndex, OMX_BOOL enable, MetadataBufferType *type) {
 if (portIndex != kPortIndexInput && portIndex != kPortIndexOutput) {
        android_errorWriteLog(0x534e4554, "26324358");
 return BAD_VALUE;
 }

    OMX_INDEXTYPE index;
    OMX_STRING name = const_cast<OMX_STRING>(
 "OMX.google.android.index.storeMetaDataInBuffers");

    OMX_STRING nativeBufferName = const_cast<OMX_STRING>(
 "OMX.google.android.index.storeANWBufferInMetadata");
 MetadataBufferType negotiatedType;

 StoreMetaDataInBuffersParams params;
 InitOMXParams(&params);
    params.nPortIndex = portIndex;
    params.bStoreMetaData = enable;

    OMX_ERRORTYPE err = OMX_GetExtensionIndex(mHandle, nativeBufferName, &index);
    OMX_ERRORTYPE xerr = err;
 if (err == OMX_ErrorNone) {
        err = OMX_SetParameter(mHandle, index, &params);
 if (err == OMX_ErrorNone) {
            name = nativeBufferName; // set name for debugging
            negotiatedType = kMetadataBufferTypeANWBuffer;
 }
 }
 if (err != OMX_ErrorNone) {
        err = OMX_GetExtensionIndex(mHandle, name, &index);
        xerr = err;
 if (err == OMX_ErrorNone) {
            negotiatedType = kMetadataBufferTypeGrallocSource;
            err = OMX_SetParameter(mHandle, index, &params);
 }
 }

 if (err != OMX_ErrorNone) {
 if (err == OMX_ErrorUnsupportedIndex && portIndex == kPortIndexOutput) {
            CLOGW("component does not support metadata mode; using fallback");
 } else if (xerr != OMX_ErrorNone) {
            CLOG_ERROR(getExtensionIndex, xerr, "%s", name);
 } else {
            CLOG_ERROR(setParameter, err, "%s(%#x): %s:%u en=%d type=%d", name, index,
                    portString(portIndex), portIndex, enable, negotiatedType);
 }
        negotiatedType = mMetadataType[portIndex];
 } else {
 if (!enable) {
            negotiatedType = kMetadataBufferTypeInvalid;
 }
        mMetadataType[portIndex] = negotiatedType;
 }
    CLOG_CONFIG(storeMetaDataInBuffers, "%s:%u negotiated %s:%d",
            portString(portIndex), portIndex, asString(negotiatedType), negotiatedType);

 if (type != NULL) {
 *type = negotiatedType;
 }

 return StatusFromOMXError(err);
}

 OMX::buffer_id OMXNodeInstance::findBufferID(OMX_BUFFERHEADERTYPE *bufferHeader) {
 if (bufferHeader == NULL) {
 return 0;
 }
 Mutex::Autolock autoLock(mBufferIDLock);
 ssize_t index = mBufferHeaderToBufferID.indexOfKey(bufferHeader);
 if (index < 0) {
        CLOGW("findBufferID: bufferHeader %p not found", bufferHeader);
 return 0;
 }
 return mBufferHeaderToBufferID.valueAt(index);
}

OMX_BUFFERHEADERTYPE *OMXNodeInstance::findBufferHeader(OMX::buffer_id buffer) {
if (buffer == 0) {
return NULL;
}
Mutex::Autolock autoLock(mBufferIDLock);
ssize_t index = mBufferIDToBufferHeader.indexOfKey(buffer);
if (index < 0) {

CLOGW("findBufferHeader: buffer %u not found", buffer);
return NULL;
}
    return mBufferIDToBufferHeader.valueAt(index);
}

OMX_ERRORTYPE OMXNodeInstance::OnFillBufferDone(
        OMX_IN OMX_HANDLETYPE /* hComponent */,
        OMX_IN OMX_PTR pAppData,
        OMX_IN OMX_BUFFERHEADERTYPE* pBuffer) {
 OMXNodeInstance *instance = static_cast<OMXNodeInstance *>(pAppData);
 if (instance->mDying) {
 return OMX_ErrorNone;
 }
 int fenceFd = instance->retrieveFenceFromMeta_l(pBuffer, kPortIndexOutput);
 return instance->owner()->OnFillBufferDone(instance->nodeID(),
            instance->findBufferID(pBuffer), pBuffer, fenceFd);
}

     void CopyFromOMX(const OMX_BUFFERHEADERTYPE *header) {
 if (!mIsBackup) {
 return;
 }

        sp<ABuffer> codec = getBuffer(header, false /* backup */, true /* limit */);

        memcpy((OMX_U8 *)mMem->pointer() + header->nOffset, codec->data(), codec->size());
 }

status_t OMXNodeInstance::emptyGraphicBuffer(
        OMX_BUFFERHEADERTYPE *header, const sp<GraphicBuffer> &graphicBuffer,
        OMX_U32 flags, OMX_TICKS timestamp, int fenceFd) {
 Mutex::Autolock autoLock(mLock);
    OMX::buffer_id buffer = findBufferID(header);
 status_t err = updateGraphicBufferInMeta_l(kPortIndexInput, graphicBuffer, buffer, header);
 if (err != OK) {
        CLOG_ERROR(emptyGraphicBuffer, err, FULL_BUFFER(
 (intptr_t)header->pBuffer, header, fenceFd));
 return err;
 }

    header->nOffset = 0;
    header->nFilledLen = graphicBuffer == NULL ? 0 : header->nAllocLen;
 return emptyBuffer_l(header, flags, timestamp, (intptr_t)header->pBuffer, fenceFd);
}

OMXNodeInstance::OMXNodeInstance(
        OMX *owner, const sp<IOMXObserver> &observer, const char *name)
 : mOwner(owner),
      mNodeID(0),
      mHandle(NULL),
      mObserver(observer),
      mDying(false),
      mBufferIDCount(0)
{
    mName = ADebug::GetDebugName(name);
    DEBUG = ADebug::GetDebugLevelFromProperty(name, "debug.stagefright.omx-debug");
    ALOGV("debug level for %s is %d", name, DEBUG);
    DEBUG_BUMP = DEBUG;
    mNumPortBuffers[0] = 0;
    mNumPortBuffers[1] = 0;
    mDebugLevelBumpPendingBuffers[0] = 0;
    mDebugLevelBumpPendingBuffers[1] = 0;
    mMetadataType[0] = kMetadataBufferTypeInvalid;
    mMetadataType[1] = kMetadataBufferTypeInvalid;
    mIsSecure = AString(name).endsWith(".secure");
}

status_t OMXNodeInstance::allocateBuffer(
OMX_U32 portIndex, size_t size, OMX::buffer_id *buffer,

void **buffer_data) {
Mutex::Autolock autoLock(mLock);

    BufferMeta *buffer_meta = new BufferMeta(size);

OMX_BUFFERHEADERTYPE *header;

OMX_ERRORTYPE err = OMX_AllocateBuffer(
mHandle, &header, portIndex, buffer_meta, size);

if (err != OMX_ErrorNone) {
CLOG_ERROR(allocateBuffer, err, BUFFER_FMT(portIndex, "%zu@", size));
delete buffer_meta;
buffer_meta = NULL;

*buffer = 0;

return StatusFromOMXError(err);
}

CHECK_EQ(header->pAppPrivate, buffer_meta);

*buffer = makeBufferID(header);
*buffer_data = header->pBuffer;

addActiveBuffer(portIndex, *buffer);

sp<GraphicBufferSource> bufferSource(getGraphicBufferSource());
if (bufferSource != NULL && portIndex == kPortIndexInput) {
bufferSource->addCodecBuffer(header);
}
CLOG_BUFFER(allocateBuffer, NEW_BUFFER_FMT(*buffer, portIndex, "%zu@%p", size, *buffer_data));

return OK;
}

BufferMeta(const sp<GraphicBuffer> &graphicBuffer)
: mGraphicBuffer(graphicBuffer),
          mIsBackup(false) {
}

status_t OMXNodeInstance::createPersistentInputSurface(
        sp<IGraphicBufferProducer> *bufferProducer,
        sp<IGraphicBufferConsumer> *bufferConsumer) {
 String8 name("GraphicBufferSource");

    sp<IGraphicBufferProducer> producer;
    sp<IGraphicBufferConsumer> consumer;
 BufferQueue::createBufferQueue(&producer, &consumer);
    consumer->setConsumerName(name);
    consumer->setConsumerUsageBits(GRALLOC_USAGE_HW_VIDEO_ENCODER);

    sp<BufferQueue::ProxyConsumerListener> proxy =
 new BufferQueue::ProxyConsumerListener(NULL);
 status_t err = consumer->consumerConnect(proxy, false);
 if (err != NO_ERROR) {
        ALOGE("Error connecting to BufferQueue: %s (%d)",
                strerror(-err), err);
 return err;
 }

 *bufferProducer = producer;
 *bufferConsumer = consumer;

 return OK;
}

OMX::buffer_id OMXNodeInstance::makeBufferID(OMX_BUFFERHEADERTYPE *bufferHeader) {
 if (bufferHeader == NULL) {
 return 0;
 }
 Mutex::Autolock autoLock(mBufferIDLock);
    OMX::buffer_id buffer;
 do { // handle the very unlikely case of ID overflow
 if (++mBufferIDCount == 0) {
 ++mBufferIDCount;
 }
        buffer = (OMX::buffer_id)mBufferIDCount;
 } while (mBufferIDToBufferHeader.indexOfKey(buffer) >= 0);
    mBufferIDToBufferHeader.add(buffer, bufferHeader);
    mBufferHeaderToBufferID.add(bufferHeader, buffer);

     return buffer;
 }

OMX_ERRORTYPE OMXNodeInstance::OnEmptyBufferDone(
        OMX_IN OMX_HANDLETYPE /* hComponent */,
        OMX_IN OMX_PTR pAppData,
        OMX_IN OMX_BUFFERHEADERTYPE* pBuffer) {
 OMXNodeInstance *instance = static_cast<OMXNodeInstance *>(pAppData);
 if (instance->mDying) {
 return OMX_ErrorNone;
 }
 int fenceFd = instance->retrieveFenceFromMeta_l(pBuffer, kPortIndexOutput);
 return instance->owner()->OnEmptyBufferDone(instance->nodeID(),
            instance->findBufferID(pBuffer), pBuffer, fenceFd);
}

 void setGraphicBuffer(const sp<GraphicBuffer> &graphicBuffer) {

         mGraphicBuffer = graphicBuffer;
     }

BufferMeta(const sp<IMemory> &mem, bool is_backup = false)
: mMem(mem),
          mIsBackup(is_backup) {
}

status_t OMXNodeInstance::useBuffer(
OMX_U32 portIndex, const sp<IMemory> &params,
OMX::buffer_id *buffer, OMX_U32 allottedSize) {
Mutex::Autolock autoLock(mLock);
if (allottedSize > params->size()) {

return BAD_VALUE;
}

    BufferMeta *buffer_meta = new BufferMeta(params);

OMX_BUFFERHEADERTYPE *header;

OMX_ERRORTYPE err = OMX_UseBuffer(
mHandle, &header, portIndex, buffer_meta,
allottedSize, static_cast<OMX_U8 *>(params->pointer()));

if (err != OMX_ErrorNone) {
CLOG_ERROR(useBuffer, err, SIMPLE_BUFFER(
portIndex, (size_t)allottedSize, params->pointer()));

delete buffer_meta;
buffer_meta = NULL;

*buffer = 0;

return StatusFromOMXError(err);
}

CHECK_EQ(header->pAppPrivate, buffer_meta);

*buffer = makeBufferID(header);

addActiveBuffer(portIndex, *buffer);

sp<GraphicBufferSource> bufferSource(getGraphicBufferSource());
if (bufferSource != NULL && portIndex == kPortIndexInput) {
bufferSource->addCodecBuffer(header);
}

CLOG_BUFFER(useBuffer, NEW_BUFFER_FMT(
*buffer, portIndex, "%u(%zu)@%p", allottedSize, params->size(), params->pointer()));
return OK;
}

status_t OMXNodeInstance::createInputSurface(
        OMX_U32 portIndex, sp<IGraphicBufferProducer> *bufferProducer, MetadataBufferType *type) {
 Mutex::Autolock autolock(mLock);
 status_t err = createGraphicBufferSource(portIndex, NULL /* bufferConsumer */, type);

 if (err != OK) {
 return err;
 }

 *bufferProducer = mGraphicBufferSource->getIGraphicBufferProducer();
 return OK;
}

status_t StatusFromOMXError(OMX_ERRORTYPE err) {
 switch (err) {
 case OMX_ErrorNone:
 return OK;
 case OMX_ErrorUnsupportedSetting:
 case OMX_ErrorUnsupportedIndex:
 return ERROR_UNSUPPORTED;
 case OMX_ErrorInsufficientResources:
 return NO_MEMORY;
 default:
 return UNKNOWN_ERROR;
 }
}

status_t OMXNodeInstance::useGraphicBuffer(
OMX_U32 portIndex, const sp<GraphicBuffer>& graphicBuffer,
OMX::buffer_id *buffer) {
Mutex::Autolock autoLock(mLock);

// See if the newer version of the extension is present.
OMX_INDEXTYPE index;
if (OMX_GetExtensionIndex(
mHandle,
const_cast<OMX_STRING>("OMX.google.android.index.useAndroidNativeBuffer2"),
&index) == OMX_ErrorNone) {
return useGraphicBuffer2_l(portIndex, graphicBuffer, buffer);
}

OMX_STRING name = const_cast<OMX_STRING>(
"OMX.google.android.index.useAndroidNativeBuffer");
OMX_ERRORTYPE err = OMX_GetExtensionIndex(mHandle, name, &index);
if (err != OMX_ErrorNone) {
CLOG_ERROR(getExtensionIndex, err, "%s", name);

return StatusFromOMXError(err);
}

    BufferMeta *bufferMeta = new BufferMeta(graphicBuffer);

OMX_BUFFERHEADERTYPE *header;

OMX_VERSIONTYPE ver;
ver.s.nVersionMajor = 1;
ver.s.nVersionMinor = 0;
ver.s.nRevision = 0;
ver.s.nStep = 0;
UseAndroidNativeBufferParams params = {
sizeof(UseAndroidNativeBufferParams), ver, portIndex, bufferMeta,
&header, graphicBuffer,
};

err = OMX_SetParameter(mHandle, index, &params);

if (err != OMX_ErrorNone) {
CLOG_ERROR(setParameter, err, "%s(%#x): %s:%u meta=%p GB=%p", name, index,
portString(portIndex), portIndex, bufferMeta, graphicBuffer->handle);

delete bufferMeta;
bufferMeta = NULL;

*buffer = 0;

return StatusFromOMXError(err);
}

CHECK_EQ(header->pAppPrivate, bufferMeta);

*buffer = makeBufferID(header);

addActiveBuffer(portIndex, *buffer);
CLOG_BUFFER(useGraphicBuffer, NEW_BUFFER_FMT(
*buffer, portIndex, "GB=%p", graphicBuffer->handle));
return OK;
}

status_t OMXNodeInstance::updateGraphicBufferInMeta(

OMX_U32 portIndex, const sp<GraphicBuffer>& graphicBuffer,
OMX::buffer_id buffer) {
Mutex::Autolock autoLock(mLock);
    OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer);
return updateGraphicBufferInMeta_l(portIndex, graphicBuffer, buffer, header);
}

status_t OMXNodeInstance::createGraphicBufferSource(
        OMX_U32 portIndex, sp<IGraphicBufferConsumer> bufferConsumer, MetadataBufferType *type) {
 status_t err;

 const sp<GraphicBufferSource>& surfaceCheck = getGraphicBufferSource();
 if (surfaceCheck != NULL) {
 if (portIndex < NELEM(mMetadataType) && type != NULL) {
 *type = mMetadataType[portIndex];
 }
 return ALREADY_EXISTS;
 }

    err = storeMetaDataInBuffers_l(portIndex, OMX_TRUE, type);
 if (err != OK) {
 return err;
 }

    OMX_PARAM_PORTDEFINITIONTYPE def;
 InitOMXParams(&def);
    def.nPortIndex = portIndex;
    OMX_ERRORTYPE oerr = OMX_GetParameter(
            mHandle, OMX_IndexParamPortDefinition, &def);
 if (oerr != OMX_ErrorNone) {
        OMX_INDEXTYPE index = OMX_IndexParamPortDefinition;
        CLOG_ERROR(getParameter, oerr, "%s(%#x): %s:%u",
                asString(index), index, portString(portIndex), portIndex);
 return UNKNOWN_ERROR;
 }

 if (def.format.video.eColorFormat != OMX_COLOR_FormatAndroidOpaque) {
        CLOGW("createInputSurface requires COLOR_FormatSurface "
 "(AndroidOpaque) color format instead of %s(%#x)",
                asString(def.format.video.eColorFormat), def.format.video.eColorFormat);
 return INVALID_OPERATION;
 }

 uint32_t usageBits;
    oerr = OMX_GetParameter(
            mHandle, (OMX_INDEXTYPE)OMX_IndexParamConsumerUsageBits, &usageBits);
 if (oerr != OMX_ErrorNone) {
        usageBits = 0;
 }

    sp<GraphicBufferSource> bufferSource = new GraphicBufferSource(this,
            def.format.video.nFrameWidth,
            def.format.video.nFrameHeight,
            def.nBufferCountActual,
            usageBits,
            bufferConsumer);

 if ((err = bufferSource->initCheck()) != OK) {
 return err;
 }
    setGraphicBufferSource(bufferSource);

 return OK;
}
