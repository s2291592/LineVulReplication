void test_base64_encode(void)
{
  char buffer[16];
  size_t len = mutt_b64_encode(buffer, clear, sizeof(clear) - 1, sizeof(buffer));
  if (!TEST_CHECK(len == sizeof(encoded) - 1))
  {
    TEST_MSG("Expected: %zu", sizeof(encoded) - 1);
    TEST_MSG("Actual  : %zu", len);
  }
  if (!TEST_CHECK(strcmp(buffer, encoded) == 0))
  {
    TEST_MSG("Expected: %zu", encoded);
    TEST_MSG("Actual  : %zu", buffer);
  }
}

void mutt_rfc2047_encode(char **pd, const char *specials, int col, const char *charsets)
{
  char *e = NULL;
  size_t elen;

  if (!Charset || !*pd)
    return;

  if (!charsets || !*charsets)
    charsets = "utf-8";

  rfc2047_encode(*pd, strlen(*pd), col, Charset, charsets, &e, &elen, specials);

  FREE(pd);
  *pd = e;
}

static void hmac_md5(const char *password, char *challenge, unsigned char *response)
{
  struct Md5Ctx ctx;
  unsigned char ipad[MD5_BLOCK_LEN] = { 0 };
  unsigned char opad[MD5_BLOCK_LEN] = { 0 };
  unsigned char secret[MD5_BLOCK_LEN + 1];
  size_t secret_len;

  secret_len = strlen(password);

  /* passwords longer than MD5_BLOCK_LEN bytes are substituted with their MD5
   * digests */
  if (secret_len > MD5_BLOCK_LEN)
  {
    unsigned char hash_passwd[MD5_DIGEST_LEN];
    mutt_md5_bytes(password, secret_len, hash_passwd);
    mutt_str_strfcpy((char *) secret, (char *) hash_passwd, MD5_DIGEST_LEN);
    secret_len = MD5_DIGEST_LEN;
  }
  else
    mutt_str_strfcpy((char *) secret, password, sizeof(secret));

  memcpy(ipad, secret, secret_len);
  memcpy(opad, secret, secret_len);

  for (int i = 0; i < MD5_BLOCK_LEN; i++)
  {
    ipad[i] ^= 0x36;
    opad[i] ^= 0x5c;
  }

  /* inner hash: challenge and ipadded secret */
  mutt_md5_init_ctx(&ctx);
  mutt_md5_process_bytes(ipad, MD5_BLOCK_LEN, &ctx);
  mutt_md5_process(challenge, &ctx);
  mutt_md5_finish_ctx(&ctx, response);

  /* outer hash: inner hash and opadded secret */
  mutt_md5_init_ctx(&ctx);
  mutt_md5_process_bytes(opad, MD5_BLOCK_LEN, &ctx);
  mutt_md5_process_bytes(response, MD5_DIGEST_LEN, &ctx);
  mutt_md5_finish_ctx(&ctx, response);
}

enum ImapAuthRes imap_auth_gss(struct ImapData *idata, const char *method)
{
gss_buffer_desc request_buf, send_token;
gss_buffer_t sec_token;
gss_name_t target_name;
gss_ctx_id_t context;
gss_OID mech_name;
char server_conf_flags;
gss_qop_t quality;
int cflags;
OM_uint32 maj_stat, min_stat;
char buf1[GSS_BUFSIZE], buf2[GSS_BUFSIZE];
unsigned long buf_size;
int rc;

if (!mutt_bit_isset(idata->capabilities, AGSSAPI))
return IMAP_AUTH_UNAVAIL;

if (mutt_account_getuser(&idata->conn->account) < 0)
return IMAP_AUTH_FAILURE;

/* get an IMAP service ticket for the server */
snprintf(buf1, sizeof(buf1), "imap@%s", idata->conn->account.host);
request_buf.value = buf1;
request_buf.length = strlen(buf1);
maj_stat = gss_import_name(&min_stat, &request_buf, gss_nt_service_name, &target_name);
if (maj_stat != GSS_S_COMPLETE)
{
mutt_debug(2, "Couldn't get service name for [%s]\n", buf1);
return IMAP_AUTH_UNAVAIL;
}
else if (DebugLevel >= 2)
{
gss_display_name(&min_stat, target_name, &request_buf, &mech_name);
mutt_debug(2, "Using service name [%s]\n", (char *) request_buf.value);
gss_release_buffer(&min_stat, &request_buf);
}
/* Acquire initial credentials - without a TGT GSSAPI is UNAVAIL */
sec_token = GSS_C_NO_BUFFER;
context = GSS_C_NO_CONTEXT;

/* build token */
maj_stat = gss_init_sec_context(&min_stat, GSS_C_NO_CREDENTIAL, &context, target_name,
GSS_C_NO_OID, GSS_C_MUTUAL_FLAG | GSS_C_SEQUENCE_FLAG,
0, GSS_C_NO_CHANNEL_BINDINGS, sec_token, NULL,
&send_token, (unsigned int *) &cflags, NULL);
if (maj_stat != GSS_S_COMPLETE && maj_stat != GSS_S_CONTINUE_NEEDED)
{
print_gss_error(maj_stat, min_stat);
mutt_debug(1, "Error acquiring credentials - no TGT?\n");
gss_release_name(&min_stat, &target_name);

return IMAP_AUTH_UNAVAIL;
}

/* now begin login */
mutt_message(_("Authenticating (GSSAPI)..."));

imap_cmd_start(idata, "AUTHENTICATE GSSAPI");

/* expect a null continuation response ("+") */
do
rc = imap_cmd_step(idata);
while (rc == IMAP_CMD_CONTINUE);

if (rc != IMAP_CMD_RESPOND)
{
mutt_debug(2, "Invalid response from server: %s\n", buf1);
gss_release_name(&min_stat, &target_name);
goto bail;
}

/* now start the security context initialisation loop... */
mutt_debug(2, "Sending credentials\n");
mutt_b64_encode(buf1, send_token.value, send_token.length, sizeof(buf1) - 2);
gss_release_buffer(&min_stat, &send_token);
mutt_str_strcat(buf1, sizeof(buf1), "\r\n");
mutt_socket_send(idata->conn, buf1);

while (maj_stat == GSS_S_CONTINUE_NEEDED)
{
/* Read server data */
do
rc = imap_cmd_step(idata);
while (rc == IMAP_CMD_CONTINUE);

if (rc != IMAP_CMD_RESPOND)
{
mutt_debug(1, "#1 Error receiving server response.\n");
gss_release_name(&min_stat, &target_name);
goto bail;
}

    request_buf.length = mutt_b64_decode(buf2, idata->buf + 2);
request_buf.value = buf2;
sec_token = &request_buf;

/* Write client data */
maj_stat = gss_init_sec_context(
&min_stat, GSS_C_NO_CREDENTIAL, &context, target_name, GSS_C_NO_OID,
GSS_C_MUTUAL_FLAG | GSS_C_SEQUENCE_FLAG, 0, GSS_C_NO_CHANNEL_BINDINGS,
sec_token, NULL, &send_token, (unsigned int *) &cflags, NULL);
if (maj_stat != GSS_S_COMPLETE && maj_stat != GSS_S_CONTINUE_NEEDED)
{
print_gss_error(maj_stat, min_stat);
mutt_debug(1, "Error exchanging credentials\n");
gss_release_name(&min_stat, &target_name);

goto err_abort_cmd;
}
mutt_b64_encode(buf1, send_token.value, send_token.length, sizeof(buf1) - 2);
gss_release_buffer(&min_stat, &send_token);
mutt_str_strcat(buf1, sizeof(buf1), "\r\n");
mutt_socket_send(idata->conn, buf1);
}

gss_release_name(&min_stat, &target_name);

/* get security flags and buffer size */
do
rc = imap_cmd_step(idata);
while (rc == IMAP_CMD_CONTINUE);

if (rc != IMAP_CMD_RESPOND)
{
mutt_debug(1, "#2 Error receiving server response.\n");
goto bail;
}
  request_buf.length = mutt_b64_decode(buf2, idata->buf + 2);
request_buf.value = buf2;

maj_stat = gss_unwrap(&min_stat, context, &request_buf, &send_token, &cflags, &quality);
if (maj_stat != GSS_S_COMPLETE)
{
print_gss_error(maj_stat, min_stat);
mutt_debug(2, "Couldn't unwrap security level data\n");
gss_release_buffer(&min_stat, &send_token);
goto err_abort_cmd;
}
mutt_debug(2, "Credential exchange complete\n");

/* first octet is security levels supported. We want NONE */
server_conf_flags = ((char *) send_token.value)[0];
if (!(((char *) send_token.value)[0] & GSS_AUTH_P_NONE))
{
mutt_debug(2, "Server requires integrity or privacy\n");
gss_release_buffer(&min_stat, &send_token);
goto err_abort_cmd;
}

/* we don't care about buffer size if we don't wrap content. But here it is */
((char *) send_token.value)[0] = '\0';
buf_size = ntohl(*((long *) send_token.value));
gss_release_buffer(&min_stat, &send_token);
mutt_debug(2, "Unwrapped security level flags: %c%c%c\n",
(server_conf_flags & GSS_AUTH_P_NONE) ? 'N' : '-',
(server_conf_flags & GSS_AUTH_P_INTEGRITY) ? 'I' : '-',
(server_conf_flags & GSS_AUTH_P_PRIVACY) ? 'P' : '-');
mutt_debug(2, "Maximum GSS token size is %ld\n", buf_size);

/* agree to terms (hack!) */
buf_size = htonl(buf_size); /* not relevant without integrity/privacy */
memcpy(buf1, &buf_size, 4);
buf1[0] = GSS_AUTH_P_NONE;
/* server decides if principal can log in as user */
strncpy(buf1 + 4, idata->conn->account.user, sizeof(buf1) - 4);
request_buf.value = buf1;
request_buf.length = 4 + strlen(idata->conn->account.user);
maj_stat = gss_wrap(&min_stat, context, 0, GSS_C_QOP_DEFAULT, &request_buf,
&cflags, &send_token);
if (maj_stat != GSS_S_COMPLETE)
{
mutt_debug(2, "Error creating login request\n");
goto err_abort_cmd;
}

mutt_b64_encode(buf1, send_token.value, send_token.length, sizeof(buf1) - 2);
mutt_debug(2, "Requesting authorisation as %s\n", idata->conn->account.user);
mutt_str_strcat(buf1, sizeof(buf1), "\r\n");
mutt_socket_send(idata->conn, buf1);

/* Joy of victory or agony of defeat? */
do
rc = imap_cmd_step(idata);
while (rc == IMAP_CMD_CONTINUE);
if (rc == IMAP_CMD_RESPOND)
{
mutt_debug(1, "Unexpected server continuation request.\n");
goto err_abort_cmd;
}
if (imap_code(idata->buf))
{
/* flush the security context */
mutt_debug(2, "Releasing GSS credentials\n");
maj_stat = gss_delete_sec_context(&min_stat, &context, &send_token);
if (maj_stat != GSS_S_COMPLETE)
mutt_debug(1, "Error releasing credentials\n");

/* send_token may contain a notification to the server to flush
* credentials. RFC1731 doesn't specify what to do, and since this
* support is only for authentication, we'll assume the server knows
* enough to flush its own credentials */
gss_release_buffer(&min_stat, &send_token);

return IMAP_AUTH_SUCCESS;
}
else
goto bail;

err_abort_cmd:
mutt_socket_send(idata->conn, "*\r\n");
do
rc = imap_cmd_step(idata);
while (rc == IMAP_CMD_CONTINUE);

bail:
mutt_error(_("GSSAPI authentication failed."));
return IMAP_AUTH_FAILURE;
}

void test_base64_decode(void)
{
char buffer[16];
  int len = mutt_b64_decode(buffer, encoded);
if (!TEST_CHECK(len == sizeof(clear) - 1))
{
TEST_MSG("Expected: %zu", sizeof(clear) - 1);
TEST_MSG("Actual  : %zu", len);
}
buffer[len] = '\0';
if (!TEST_CHECK(strcmp(buffer, clear) == 0))
{
TEST_MSG("Expected: %s", clear);
TEST_MSG("Actual  : %s", buffer);
}
}

size_t mutt_b64_encode(char *out, const char *cin, size_t len, size_t olen)
{
  unsigned char *begin = (unsigned char *) out;
  const unsigned char *in = (const unsigned char *) cin;

  while ((len >= 3) && (olen > 10))
  {
    *out++ = B64Chars[in[0] >> 2];
    *out++ = B64Chars[((in[0] << 4) & 0x30) | (in[1] >> 4)];
    *out++ = B64Chars[((in[1] << 2) & 0x3c) | (in[2] >> 6)];
    *out++ = B64Chars[in[2] & 0x3f];
    olen -= 4;
    len -= 3;
    in += 3;
  }

  /* clean up remainder */
  if ((len > 0) && (olen > 4))
  {
    unsigned char fragment;

    *out++ = B64Chars[in[0] >> 2];
    fragment = (in[0] << 4) & 0x30;
    if (len > 1)
      fragment |= in[1] >> 4;
    *out++ = B64Chars[fragment];
    *out++ = (len < 2) ? '=' : B64Chars[(in[1] << 2) & 0x3c];
    *out++ = '=';
  }
  *out = '\0';
  return (out - (char *) begin);
}

enum ImapAuthRes imap_auth_cram_md5(struct ImapData *idata, const char *method)
{
char ibuf[LONG_STRING * 2], obuf[LONG_STRING];
unsigned char hmac_response[MD5_DIGEST_LEN];
int len;
int rc;

if (!mutt_bit_isset(idata->capabilities, ACRAM_MD5))
return IMAP_AUTH_UNAVAIL;

mutt_message(_("Authenticating (CRAM-MD5)..."));

/* get auth info */
if (mutt_account_getlogin(&idata->conn->account) < 0)
return IMAP_AUTH_FAILURE;
if (mutt_account_getpass(&idata->conn->account) < 0)
return IMAP_AUTH_FAILURE;

imap_cmd_start(idata, "AUTHENTICATE CRAM-MD5");

/* From RFC2195:
* The data encoded in the first ready response contains a presumptively
* arbitrary string of random digits, a timestamp, and the fully-qualified
* primary host name of the server. The syntax of the unencoded form must
* correspond to that of an RFC822 'msg-id' [RFC822] as described in [POP3].
*/
do
rc = imap_cmd_step(idata);
while (rc == IMAP_CMD_CONTINUE);

if (rc != IMAP_CMD_RESPOND)
{
mutt_debug(1, "Invalid response from server: %s\n", ibuf);
goto bail;
}

  len = mutt_b64_decode(obuf, idata->buf + 2);
if (len == -1)
{
mutt_debug(1, "Error decoding base64 response.\n");
goto bail;
}

obuf[len] = '\0';
mutt_debug(2, "CRAM challenge: %s\n", obuf);

/* The client makes note of the data and then responds with a string
* consisting of the user name, a space, and a 'digest'. The latter is
* computed by applying the keyed MD5 algorithm from [KEYED-MD5] where the
* key is a shared secret and the digested text is the timestamp (including
* angle-brackets).
*
* Note: The user name shouldn't be quoted. Since the digest can't contain
*   spaces, there is no ambiguity. Some servers get this wrong, we'll work
*   around them when the bug report comes in. Until then, we'll remain
*   blissfully RFC-compliant.
*/
hmac_md5(idata->conn->account.pass, obuf, hmac_response);
/* dubious optimisation I saw elsewhere: make the whole string in one call */
int off = snprintf(obuf, sizeof(obuf), "%s ", idata->conn->account.user);
mutt_md5_toascii(hmac_response, obuf + off);
mutt_debug(2, "CRAM response: %s\n", obuf);

/* ibuf must be long enough to store the base64 encoding of obuf,
* plus the additional debris */
mutt_b64_encode(ibuf, obuf, strlen(obuf), sizeof(ibuf) - 2);
mutt_str_strcat(ibuf, sizeof(ibuf), "\r\n");
mutt_socket_send(idata->conn, ibuf);

do
rc = imap_cmd_step(idata);
while (rc == IMAP_CMD_CONTINUE);

if (rc != IMAP_CMD_OK)
{
mutt_debug(1, "Error receiving server response.\n");
goto bail;
}

if (imap_code(idata->buf))
return IMAP_AUTH_SUCCESS;

bail:
mutt_error(_("CRAM-MD5 authentication failed."));
return IMAP_AUTH_FAILURE;
}

static size_t try_block(const char *d, size_t dlen, const char *fromcode,
                        const char *tocode, encoder_t *encoder, size_t *wlen)
{
  char buf[ENCWORD_LEN_MAX - ENCWORD_LEN_MIN + 1];
  const char *ib = NULL;
  char *ob = NULL;
  size_t ibl, obl;
  int count, len, len_b, len_q;

  if (fromcode)
  {
    iconv_t cd = mutt_ch_iconv_open(tocode, fromcode, 0);
    assert(cd != (iconv_t)(-1));
    ib = d;
    ibl = dlen;
    ob = buf;
    obl = sizeof(buf) - strlen(tocode);
    if (iconv(cd, (ICONV_CONST char **) &ib, &ibl, &ob, &obl) == (size_t)(-1) ||
        iconv(cd, NULL, NULL, &ob, &obl) == (size_t)(-1))
    {
      assert(errno == E2BIG);
      iconv_close(cd);
      assert(ib > d);
      return (ib - d == dlen) ? dlen : ib - d + 1;
    }
    iconv_close(cd);
  }
  else
  {
    if (dlen > (sizeof(buf) - strlen(tocode)))
      return (sizeof(buf) - strlen(tocode) + 1);
    memcpy(buf, d, dlen);
    ob = buf + dlen;
  }

  count = 0;
  for (char *p = buf; p < ob; p++)
  {
    unsigned char c = *p;
    assert(strchr(MimeSpecials, '?'));
    if ((c >= 0x7f) || (c < 0x20) || (*p == '_') ||
        ((c != ' ') && strchr(MimeSpecials, *p)))
    {
      count++;
    }
  }

  len = ENCWORD_LEN_MIN - 2 + strlen(tocode);
  len_b = len + (((ob - buf) + 2) / 3) * 4;
  len_q = len + (ob - buf) + 2 * count;

  /* Apparently RFC1468 says to use B encoding for iso-2022-jp. */
  if (mutt_str_strcasecmp(tocode, "ISO-2022-JP") == 0)
    len_q = ENCWORD_LEN_MAX + 1;

  if ((len_b < len_q) && (len_b <= ENCWORD_LEN_MAX))
  {
    *encoder = b_encoder;
    *wlen = len_b;
    return 0;
  }
  else if (len_q <= ENCWORD_LEN_MAX)
  {
    *encoder = q_encoder;
    *wlen = len_q;
    return 0;
  }
  else
    return dlen;
}

static int rfc2047_encode(const char *d, size_t dlen, int col, const char *fromcode,
                          const char *charsets, char **e, size_t *elen, const char *specials)
{
  int rc = 0;
  char *buf = NULL;
  size_t bufpos, buflen;
  char *t0 = NULL, *t1 = NULL, *t = NULL;
  char *s0 = NULL, *s1 = NULL;
  size_t ulen, r, wlen = 0;
  encoder_t encoder = NULL;
  char *tocode1 = NULL;
  const char *tocode = NULL;
  char *icode = "utf-8";

  /* Try to convert to UTF-8. */
  char *u = mutt_str_substr_dup(d, d + dlen);
  if (mutt_ch_convert_string(&u, fromcode, icode, 0) != 0)
  {
    rc = 1;
    icode = 0;
  }
  ulen = mutt_str_strlen(u);

  /* Find earliest and latest things we must encode. */
  s0 = s1 = t0 = t1 = 0;
  for (t = u; t < (u + ulen); t++)
  {
    if ((*t & 0x80) || ((*t == '=') && (t[1] == '?') && ((t == u) || HSPACE(*(t - 1)))))
    {
      if (!t0)
        t0 = t;
      t1 = t;
    }
    else if (specials && *t && strchr(specials, *t))
    {
      if (!s0)
        s0 = t;
      s1 = t;
    }
  }

  /* If we have something to encode, include RFC822 specials */
  if (t0 && s0 && (s0 < t0))
    t0 = s0;
  if (t1 && s1 && (s1 > t1))
    t1 = s1;

  if (!t0)
  {
    /* No encoding is required. */
    *e = u;
    *elen = ulen;
    return rc;
  }

  /* Choose target charset. */
  tocode = fromcode;
  if (icode)
  {
    tocode1 = mutt_ch_choose(icode, charsets, u, ulen, 0, 0);
    if (tocode1)
      tocode = tocode1;
    else
    {
      rc = 2;
      icode = 0;
    }
  }

  /* Hack to avoid labelling 8-bit data as us-ascii. */
  if (!icode && mutt_ch_is_us_ascii(tocode))
    tocode = "unknown-8bit";

  /* Adjust t0 for maximum length of line. */
  t = u + (ENCWORD_LEN_MAX + 1) - col - ENCWORD_LEN_MIN;
  if (t < u)
    t = u;
  if (t < t0)
    t0 = t;

  /* Adjust t0 until we can encode a character after a space. */
  for (; t0 > u; t0--)
  {
    if (!HSPACE(*(t0 - 1)))
      continue;
    t = t0 + 1;
    if (icode)
      while ((t < (u + ulen)) && CONTINUATION_BYTE(*t))
        t++;
    if ((try_block(t0, t - t0, icode, tocode, &encoder, &wlen) == 0) &&
        ((col + (t0 - u) + wlen) <= (ENCWORD_LEN_MAX + 1)))
    {
      break;
    }
  }

  /* Adjust t1 until we can encode a character before a space. */
  for (; t1 < (u + ulen); t1++)
  {
    if (!HSPACE(*t1))
      continue;
    t = t1 - 1;
    if (icode)
      while (CONTINUATION_BYTE(*t))
        t--;
    if ((try_block(t, t1 - t, icode, tocode, &encoder, &wlen) == 0) &&
        ((1 + wlen + (u + ulen - t1)) <= (ENCWORD_LEN_MAX + 1)))
    {
      break;
    }
  }

  /* We shall encode the region [t0,t1). */

  /* Initialise the output buffer with the us-ascii prefix. */
  buflen = 2 * ulen;
  buf = mutt_mem_malloc(buflen);
  bufpos = t0 - u;
  memcpy(buf, u, t0 - u);

  col += t0 - u;

  t = t0;
  while (true)
  {
    /* Find how much we can encode. */
    size_t n = choose_block(t, t1 - t, col, icode, tocode, &encoder, &wlen);
    if (n == (t1 - t))
    {
      /* See if we can fit the us-ascii suffix, too. */
      if ((col + wlen + (u + ulen - t1)) <= (ENCWORD_LEN_MAX + 1))
        break;
      n = t1 - t - 1;
      if (icode)
        while (CONTINUATION_BYTE(t[n]))
          n--;
      if (!n)
      {
        /* This should only happen in the really stupid case where the
           only word that needs encoding is one character long, but
           there is too much us-ascii stuff after it to use a single
           encoded word. We add the next word to the encoded region
           and try again. */
        assert(t1 < (u + ulen));
        for (t1++; (t1 < (u + ulen)) && !HSPACE(*t1); t1++)
          ;
        continue;
      }
      n = choose_block(t, n, col, icode, tocode, &encoder, &wlen);
    }

    /* Add to output buffer. */
    const char *line_break = "\n\t";
    const int lb_len = 2; /* strlen(line_break) */

    if ((bufpos + wlen + lb_len) > buflen)
    {
      buflen = bufpos + wlen + lb_len;
      mutt_mem_realloc(&buf, buflen);
    }
    r = encode_block(buf + bufpos, t, n, icode, tocode, encoder);
    assert(r == wlen);
    bufpos += wlen;
    memcpy(buf + bufpos, line_break, lb_len);
    bufpos += lb_len;

    col = 1;

    t += n;
  }

  /* Add last encoded word and us-ascii suffix to buffer. */
  buflen = bufpos + wlen + (u + ulen - t1);
  mutt_mem_realloc(&buf, buflen + 1);
  r = encode_block(buf + bufpos, t, t1 - t, icode, tocode, encoder);
  assert(r == wlen);
  bufpos += wlen;
  memcpy(buf + bufpos, t1, u + ulen - t1);

  FREE(&tocode1);
  FREE(&u);

  buf[buflen] = '\0';

  *e = buf;
  *elen = buflen + 1;
  return rc;
}

void mutt_rfc2047_decode(char **pd)
{
  if (!pd || !*pd)
    return;

  struct Buffer buf = { 0 }; /* Output buffer                          */
  char *s = *pd;             /* Read pointer                           */
  char *beg;                 /* Begin of encoded word                  */
  enum ContentEncoding enc;  /* ENCBASE64 or ENCQUOTEDPRINTABLE        */
  char *charset;             /* Which charset                          */
  size_t charsetlen;         /* Length of the charset                  */
  char *text;                /* Encoded text                           */
  size_t textlen;            /* Length of encoded text                 */

  /* Keep some state in case the next decoded word is using the same charset
   * and it happens to be split in the middle of a multibyte character.
   * See https://github.com/neomutt/neomutt/issues/1015
   */
  struct Buffer prev = { 0 }; /* Previously decoded word                */
  char *prev_charset = NULL;  /* Previously used charset                */
  size_t prev_charsetlen = 0; /* Length of the previously used charset  */

  while (*s)
  {
    beg = parse_encoded_word(s, &enc, &charset, &charsetlen, &text, &textlen);
    if (beg != s)
    {
      /* Some non-encoded text was found */
      size_t holelen = beg ? beg - s : mutt_str_strlen(s);

      /* Ignore whitespace between encoded words */
      if (beg && mutt_str_lws_len(s, holelen) == holelen)
      {
        s = beg;
        continue;
      }

      /* If we have some previously decoded text, add it now */
      if (prev.data)
      {
        finalize_chunk(&buf, &prev, prev_charset, prev_charsetlen);
      }

      /* Add non-encoded part */
      {
        if (AssumedCharset && *AssumedCharset)
        {
          char *conv = mutt_str_substr_dup(s, s + holelen);
          mutt_ch_convert_nonmime_string(&conv);
          mutt_buffer_addstr(&buf, conv);
          FREE(&conv);
        }
        else
        {
          mutt_buffer_add(&buf, s, holelen);
        }
      }
      s += holelen;
    }
    if (beg)
    {
      /* Some encoded text was found */
      text[textlen] = '\0';
      char *decoded = rfc2047_decode_word(text, textlen, enc);
      if (decoded == NULL)
      {
        return;
      }
      if (prev.data && ((prev_charsetlen != charsetlen) ||
                        (strncmp(prev_charset, charset, charsetlen) != 0)))
      {
        /* Different charset, convert the previous chunk and add it to the
         * final result */
        finalize_chunk(&buf, &prev, prev_charset, prev_charsetlen);
      }

      mutt_buffer_addstr(&prev, decoded);
      FREE(&decoded);
      prev_charset = charset;
      prev_charsetlen = charsetlen;
      s = text + textlen + 2; /* Skip final ?= */
    }
  }

  /* Save the last chunk */
  if (prev.data)
  {
    finalize_chunk(&buf, &prev, prev_charset, prev_charsetlen);
  }

  mutt_buffer_addch(&buf, '\0');
  *pd = buf.data;
}

int mutt_b64_decode(char *out, const char *in)
 {
   int len = 0;
   unsigned char digit4;

  do
  {
    const unsigned char digit1 = in[0];
    if ((digit1 > 127) || (base64val(digit1) == BAD))
      return -1;
    const unsigned char digit2 = in[1];
    if ((digit2 > 127) || (base64val(digit2) == BAD))
      return -1;
    const unsigned char digit3 = in[2];
    if ((digit3 > 127) || ((digit3 != '=') && (base64val(digit3) == BAD)))
      return -1;
    digit4 = in[3];
    if ((digit4 > 127) || ((digit4 != '=') && (base64val(digit4) == BAD)))
      return -1;
     in += 4;
 
     /* digits are already sanity-checked */
     *out++ = (base64val(digit1) << 2) | (base64val(digit2) >> 4);
     len++;
     if (digit3 != '=')
     {
       *out++ = ((base64val(digit2) << 4) & 0xf0) | (base64val(digit3) >> 2);
       len++;
       if (digit4 != '=')
       {
         *out++ = ((base64val(digit3) << 6) & 0xc0) | base64val(digit4);
         len++;
       }
    }
  } while (*in && digit4 != '=');

  return len;
}
