 void TabletModeWindowManager::Init() {

  {
    ScopedObserveWindowAnimation scoped_observe(GetTopWindow(), this,
                                                /*exiting_tablet_mode=*/false);
    ArrangeWindowsForTabletMode();
  }
  AddWindowCreationObservers();
  display::Screen::GetScreen()->AddObserver(this);
  Shell::Get()->AddShellObserver(this);
  Shell::Get()->session_controller()->AddObserver(this);
  Shell::Get()->overview_controller()->AddObserver(this);
  accounts_since_entering_tablet_.insert(
      Shell::Get()->session_controller()->GetActiveAccountId());
  event_handler_ = std::make_unique<wm::TabletModeEventHandler>();
 }

void TabletModeWindowManager::DisplayConfigurationChanged() {
  RemoveWindowCreationObservers();
  AddWindowCreationObservers();
  UpdateDeskContainersBackdrops();
}

  void DestroyTabletModeWindowManager() {
    Shell::Get()->tablet_mode_controller()->SetEnabledForTest(false);
    EXPECT_FALSE(TabletModeControllerTestApi().tablet_mode_window_manager());
  }

GetCarryOverWindowsInSplitView() {
  base::flat_map<aura::Window*, WindowStateType> windows;
  MruWindowTracker::WindowList mru_windows =
      Shell::Get()->mru_window_tracker()->BuildWindowForCycleList(kAllDesks);
  if (IsCarryOverCandidateForSplitView(mru_windows, 0u)) {
    if (wm::GetWindowState(mru_windows[0])->GetStateType() ==
        WindowStateType::kLeftSnapped) {
      windows.emplace(mru_windows[0], WindowStateType::kLeftSnapped);
      if (IsCarryOverCandidateForSplitView(mru_windows, 1u) &&
          wm::GetWindowState(mru_windows[1])->GetStateType() ==
              WindowStateType::kRightSnapped) {
        windows.emplace(mru_windows[1], WindowStateType::kRightSnapped);
      }
    } else if (wm::GetWindowState(mru_windows[0])->GetStateType() ==
               WindowStateType::kRightSnapped) {
      windows.emplace(mru_windows[0], WindowStateType::kRightSnapped);
      if (IsCarryOverCandidateForSplitView(mru_windows, 1u) &&
          wm::GetWindowState(mru_windows[1])->GetStateType() ==
              WindowStateType::kLeftSnapped) {
        windows.emplace(mru_windows[1], WindowStateType::kLeftSnapped);
      }
    }
  }
  return windows;
}

TabletModeWindowState::~TabletModeWindowState() {
   creator_->WindowStateDestroyed(window_);
 }

void TabletModeWindowManager::OnOverviewModeEndingAnimationComplete(
    bool canceled) {
  if (canceled)
    return;

  auto* split_view_controller = Shell::Get()->split_view_controller();

  MruWindowTracker::WindowList windows =
      Shell::Get()->mru_window_tracker()->BuildWindowListIgnoreModal(kAllDesks);
  for (auto* window : windows) {
    if (split_view_controller->left_window() != window &&
        split_view_controller->right_window() != window) {
      MaximizeIfSnapped(window);
    }
  }
}

 int TabletModeWindowManager::GetNumberOfManagedWindows() {
  return window_state_map_.size();
}

void TabletModeWindowManager::OnDisplayRemoved(
    const display::Display& display) {
  DisplayConfigurationChanged();
}

WindowStateType TabletModeWindowManager::GetDesktopWindowStateType(
    aura::Window* window) const {
  auto iter = window_state_map_.find(window);
  return iter == window_state_map_.end()
             ? wm::GetWindowState(window)->GetStateType()
             : iter->second->old_state()->GetType();
}

void TabletModeWindowManager::OnWindowBoundsChanged(
    aura::Window* window,
    const gfx::Rect& old_bounds,
    const gfx::Rect& new_bounds,
    ui::PropertyChangeReason reason) {
  if (!IsContainerWindow(window))
    return;

  auto* session = Shell::Get()->overview_controller()->overview_session();
  if (session)
    session->SuspendReposition();

  for (auto& pair : window_state_map_) {
    pair.second->UpdateWindowPosition(wm::GetWindowState(pair.first),
                                      /*animate=*/false);
  }
  if (session)
    session->ResumeReposition();
}

void TabletModeWindowManager::OnDisplayAdded(const display::Display& display) {
  DisplayConfigurationChanged();
}

void TabletModeWindowState::UpdateBounds(wm::WindowState* window_state,
                                         bool animated) {
  if (wm::IsDraggingTabs(window_state->window()))
    return;

  if (current_state_type_ == WindowStateType::kMinimized)
    return;

  gfx::Rect bounds_in_parent = GetBoundsInTabletMode(window_state);
  if (!bounds_in_parent.IsEmpty() &&
      bounds_in_parent != window_state->window()->bounds()) {
    if (!window_state->window()->IsVisible() || !animated) {
      window_state->SetBoundsDirect(bounds_in_parent);
    } else {
      if (enter_animation_type() == STEP_END) {
        window_state->SetBoundsDirectAnimated(bounds_in_parent,
                                              base::TimeDelta::FromSeconds(1),
                                              gfx::Tween::ZERO);
        set_enter_animation_type(DEFAULT);
        return;
      }
      if (window_state->IsMaximized())
        window_state->SetBoundsDirectCrossFade(bounds_in_parent);
      else if (window_state->IsSnapped())
        window_state->SetBoundsDirect(bounds_in_parent);
      else
        window_state->SetBoundsDirectAnimated(bounds_in_parent);
    }
  }
}

void TabletModeWindowManager::ArrangeWindowsForTabletMode() {
  MruWindowTracker::WindowList split_view_eligible_windows =
      Shell::Get()->mru_window_tracker()->BuildWindowForCycleList(kAllDesks);
  ScopedSkipUserSessionBlockedCheck scoped_skip_user_session_blocked_check;
  MruWindowTracker::WindowList activatable_windows =
      Shell::Get()->mru_window_tracker()->BuildWindowListIgnoreModal(kAllDesks);

  base::flat_map<aura::Window*, WindowStateType> windows_in_splitview =
      GetCarryOverWindowsInSplitView();
  int divider_position = CalculateCarryOverDividerPostion(windows_in_splitview);

  if (windows_in_splitview.empty()) {
    for (auto* window : activatable_windows)
      TrackWindow(window, /*entering_tablet_mode=*/true);
    return;
  }

  for (auto* window : activatable_windows) {
    bool snap = false;
    for (auto& iter : windows_in_splitview) {
      if (window == iter.first) {
        snap = true;
        break;
      }
    }
    TrackWindow(window, /*entering_tablet_mode=*/true, snap,
                /*animate_bounds_on_attach=*/false);
  }

  DoSplitViewTransition(windows_in_splitview, divider_position);
 }

gfx::Size GetMaximumSizeOfWindow(wm::WindowState* window_state) {
  DCHECK(window_state->CanMaximize() || window_state->CanResize());

  gfx::Size workspace_size =
      screen_util::GetMaximizedWindowBoundsInParent(window_state->window())
          .size();

  gfx::Size size = window_state->window()->delegate()
                       ? window_state->window()->delegate()->GetMaximumSize()
                       : gfx::Size();
  if (size.IsEmpty())
    return workspace_size;

  size.SetToMin(workspace_size);
  return size;
}

void TabletModeWindowManager::WindowStateDestroyed(aura::Window* window) {
  DCHECK(!window->HasObserver(this));

  auto it = window_state_map_.find(window);
  if (it != window_state_map_.end())
    window_state_map_.erase(it);
}

  TabletModeWindowManager* CreateTabletModeWindowManager() {
    EXPECT_FALSE(TabletModeControllerTestApi().tablet_mode_window_manager());
    Shell::Get()->tablet_mode_controller()->SetEnabledForTest(true);
    return TabletModeControllerTestApi().tablet_mode_window_manager();
  }

void TabletModeWindowManager::OnWindowPropertyChanged(aura::Window* window,
                                                      const void* key,
                                                      intptr_t old) {
  if (key == aura::client::kZOrderingKey &&
      window->GetProperty(aura::client::kZOrderingKey) !=
          ui::ZOrderLevel::kNormal) {
    ForgetWindow(window, false /* destroyed */);
  }
}

bool IsTopWindow(aura::Window* window) {
  DCHECK(window);
  return window == TabletModeWindowManager::GetTopWindow();
}

void SetWindowRestoreOverrides(aura::Window* window,
                               const gfx::Rect& bounds_override,
                               ui::WindowShowState window_state_override) {
  if (bounds_override.IsEmpty()) {
    window->ClearProperty(kRestoreWindowStateTypeOverrideKey);
    window->ClearProperty(kRestoreBoundsOverrideKey);
    return;
  }
  window->SetProperty(kRestoreWindowStateTypeOverrideKey,
                      ToWindowStateType(window_state_override));
  window->SetProperty(kRestoreBoundsOverrideKey,
                      new gfx::Rect(bounds_override));
}

gfx::Rect GetCenteredBounds(const gfx::Rect& bounds_in_parent,
                            wm::WindowState* state_object) {
  gfx::Rect work_area_in_parent =
      screen_util::GetDisplayWorkAreaBoundsInParent(state_object->window());
  work_area_in_parent.ClampToCenteredSize(bounds_in_parent.size());
  return work_area_in_parent;
}

  bool GetPostLayerVisibilityAndReset() {
    bool r = post_layer_visibility_;
    post_layer_visibility_ = false;
    return r;
  }

  ScopedObserveWindowAnimation(aura::Window* window,
                               TabletModeWindowManager* manager,
                               bool exiting_tablet_mode)
      : window_(window),
        manager_(manager),
        exiting_tablet_mode_(exiting_tablet_mode) {
    if (Shell::Get()->tablet_mode_controller() && window_) {
      Shell::Get()->tablet_mode_controller()->MaybeObserveBoundsAnimation(
          window_);
    }
  }

bool TabletModeWindowManager::IsTrackingWindow(aura::Window* window) {
  return base::Contains(window_state_map_, window);
}

void TabletModeWindowManager::OnWindowVisibilityChanged(aura::Window* window,
                                                        bool visible) {
  if (IsTrackingWindow(window))
    return;

  if (IsContainerWindow(window->parent()) &&
      base::Contains(added_windows_, window) && visible) {
    added_windows_.erase(window);
    window->RemoveObserver(this);
    TrackWindow(window);
    if (IsTrackingWindow(window)) {
      wm::WMEvent event(wm::WM_EVENT_ADDED_TO_WORKSPACE);
      wm::GetWindowState(window)->OnWMEvent(&event);
    }
  }
}

void TabletModeWindowState::LeaveTabletMode(wm::WindowState* window_state) {
  // Only do bounds change animation if the window is the top window or a window
  // showing in splitview, and the window has changed its state. Otherwise,
  // restore its bounds immediately.
EnterAnimationType animation_type =
      window_state->IsSnapped() || IsTopWindow(window_state->window())
? DEFAULT
: IMMEDIATE;
if (old_state_->GetType() == window_state->GetStateType() &&
!window_state->IsNormalStateType()) {
animation_type = IMMEDIATE;
}
old_state_->set_enter_animation_type(animation_type);
// Note: When we return we will destroy ourselves with the |our_reference|.
std::unique_ptr<wm::WindowState::State> our_reference =
window_state->SetStateObject(std::move(old_state_));
}

  aura::Window* CreateWindowInWatchedContainer(const InitParams& params) {
    aura::test::TestWindowDelegate* delegate = NULL;
    if (!params.can_maximize) {
      delegate = aura::test::TestWindowDelegate::CreateSelfDestroyingDelegate();
      delegate->set_window_component(HTCAPTION);
      if (!params.max_size.IsEmpty())
        delegate->set_maximum_size(params.max_size);
    }
    aura::Window* window = aura::test::CreateTestWindowWithDelegateAndType(
        delegate, params.type, 0, params.bounds, NULL, params.show_on_creation);
    int32_t behavior = aura::client::kResizeBehaviorNone;
    behavior |= params.can_resize ? aura::client::kResizeBehaviorCanResize : 0;
    behavior |=
        params.can_maximize ? aura::client::kResizeBehaviorCanMaximize : 0;
    window->SetProperty(aura::client::kResizeBehaviorKey, behavior);
    aura::Window* container =
        wm::GetSwitchableContainersForRoot(Shell::GetPrimaryRootWindow(),
                                           /*active_desk_only=*/true)[0];
    container->AddChild(window);
    return window;
  }

void TabletModeWindowState::OnWMEvent(wm::WindowState* window_state,
                                      const wm::WMEvent* event) {
  if (ignore_wm_events_) {
    return;
  }

  switch (event->type()) {
    case wm::WM_EVENT_TOGGLE_FULLSCREEN:
      ToggleFullScreen(window_state, window_state->delegate());
      break;
    case wm::WM_EVENT_FULLSCREEN:
      UpdateWindow(window_state, WindowStateType::kFullscreen,
                   true /* animated */);
      break;
    case wm::WM_EVENT_PIN:
      if (!Shell::Get()->screen_pinning_controller()->IsPinned())
        UpdateWindow(window_state, WindowStateType::kPinned,
                     true /* animated */);
      break;
    case wm::WM_EVENT_PIP:
      if (!window_state->IsPip()) {
        UpdateWindow(window_state, WindowStateType::kPip, true /* animated */);
      }
      break;
    case wm::WM_EVENT_TRUSTED_PIN:
      if (!Shell::Get()->screen_pinning_controller()->IsPinned())
        UpdateWindow(window_state, WindowStateType::kTrustedPinned,
                     true /* animated */);
      break;
    case wm::WM_EVENT_TOGGLE_MAXIMIZE_CAPTION:
    case wm::WM_EVENT_TOGGLE_VERTICAL_MAXIMIZE:
    case wm::WM_EVENT_TOGGLE_HORIZONTAL_MAXIMIZE:
    case wm::WM_EVENT_TOGGLE_MAXIMIZE:
    case wm::WM_EVENT_CYCLE_SNAP_LEFT:
    case wm::WM_EVENT_CYCLE_SNAP_RIGHT:
    case wm::WM_EVENT_CENTER:
    case wm::WM_EVENT_NORMAL:
    case wm::WM_EVENT_MAXIMIZE:
      UpdateWindow(window_state, GetMaximizedOrCenteredWindowType(window_state),
                   true /* animated */);
      return;
    case wm::WM_EVENT_SNAP_LEFT:
      window_state->set_bounds_changed_by_user(true);
      UpdateWindow(window_state,
                   GetSnappedWindowStateType(window_state,
                                             WindowStateType::kLeftSnapped),
                   false /* animated */);
      return;
    case wm::WM_EVENT_SNAP_RIGHT:
      window_state->set_bounds_changed_by_user(true);
      UpdateWindow(window_state,
                   GetSnappedWindowStateType(window_state,
                                             WindowStateType::kRightSnapped),
                   false /* animated */);
      return;
    case wm::WM_EVENT_MINIMIZE:
      UpdateWindow(window_state, WindowStateType::kMinimized,
                   true /* animated */);
      return;
    case wm::WM_EVENT_SHOW_INACTIVE:
    case wm::WM_EVENT_SYSTEM_UI_AREA_CHANGED:
      return;
    case wm::WM_EVENT_SET_BOUNDS: {
      gfx::Rect bounds_in_parent =
          (static_cast<const wm::SetBoundsEvent*>(event))->requested_bounds();
      if (bounds_in_parent.IsEmpty())
        return;

      if (wm::IsDraggingTabs(window_state->window()) ||
          IsTabDraggingSourceWindow(window_state->window())) {
        window_state->SetBoundsDirect(bounds_in_parent);
      } else if (current_state_type_ == WindowStateType::kMaximized) {
        window_state->SetRestoreBoundsInParent(bounds_in_parent);
      } else if (current_state_type_ != WindowStateType::kMinimized &&
                 current_state_type_ != WindowStateType::kFullscreen &&
                 current_state_type_ != WindowStateType::kPinned &&
                 current_state_type_ != WindowStateType::kTrustedPinned &&
                 current_state_type_ != WindowStateType::kLeftSnapped &&
                 current_state_type_ != WindowStateType::kRightSnapped) {
        bounds_in_parent = GetCenteredBounds(bounds_in_parent, window_state);
        if (bounds_in_parent != window_state->window()->bounds()) {
          const wm::SetBoundsEvent* bounds_event =
              static_cast<const wm::SetBoundsEvent*>(event);
          if (window_state->window()->IsVisible() && bounds_event->animate())
            window_state->SetBoundsDirectAnimated(bounds_in_parent);
          else
            window_state->SetBoundsDirect(bounds_in_parent);
        }
      }
      break;
    }
    case wm::WM_EVENT_ADDED_TO_WORKSPACE:
      if (current_state_type_ != WindowStateType::kMaximized &&
          current_state_type_ != WindowStateType::kFullscreen &&
          current_state_type_ != WindowStateType::kMinimized) {
        WindowStateType new_state =
            GetMaximizedOrCenteredWindowType(window_state);
        UpdateWindow(window_state, new_state, true /* animated */);
      }
      break;
    case wm::WM_EVENT_WORKAREA_BOUNDS_CHANGED:
      if (current_state_type_ != WindowStateType::kMinimized)
        UpdateBounds(window_state, true /* animated */);
      break;
    case wm::WM_EVENT_DISPLAY_BOUNDS_CHANGED:
      if (current_state_type_ != WindowStateType::kMinimized)
        UpdateBounds(window_state, false /* animated */);
      break;
  }
}

void TabletModeWindowManager::OnWindowDestroying(aura::Window* window) {
  if (IsContainerWindow(window)) {
    window->RemoveObserver(this);
    observed_container_windows_.erase(window);
  } else if (base::Contains(added_windows_, window)) {
    added_windows_.erase(window);
    window->RemoveObserver(this);
  } else {
    ForgetWindow(window, /*destroyed=*/true);
  }
}

gfx::Rect GetRestoreBounds(wm::WindowState* window_state) {
  if (window_state->IsMinimized() || window_state->IsMaximized() ||
      window_state->IsFullscreen()) {
    gfx::Rect restore_bounds = window_state->GetRestoreBoundsInScreen();
    if (!restore_bounds.IsEmpty())
      return restore_bounds;
  }
  return window_state->window()->GetBoundsInScreen();
}

int CalculateCarryOverDividerPostion(
    base::flat_map<aura::Window*, WindowStateType> windows_in_splitview) {
  aura::Window* left_window = nullptr;
  aura::Window* right_window = nullptr;
  for (auto& iter : windows_in_splitview) {
    if (iter.second == WindowStateType::kLeftSnapped)
      left_window = iter.first;
    else if (iter.second == WindowStateType::kRightSnapped)
      right_window = iter.first;
  }
  if (!left_window && !right_window)
    return -1;

  gfx::Rect work_area =
      display::Screen::GetScreen()
          ->GetDisplayNearestWindow(left_window ? left_window : right_window)
          .work_area();
  gfx::Rect left_window_bounds =
      left_window ? left_window->GetBoundsInScreen() : gfx::Rect();
  gfx::Rect right_window_bounds =
      right_window ? right_window->GetBoundsInScreen() : gfx::Rect();

  switch (GetCurrentScreenOrientation()) {
    case OrientationLockType::kLandscapePrimary:
      return left_window ? left_window_bounds.width()
                         : work_area.width() - right_window_bounds.width();
    case OrientationLockType::kPortraitPrimary:
      return left_window ? left_window_bounds.height()
                         : work_area.height() - right_window_bounds.height();
    case OrientationLockType::kLandscapeSecondary:
      return left_window ? work_area.width() - left_window_bounds.width()
                         : right_window_bounds.width();
    case OrientationLockType::kPortraitSecondary:
      return left_window ? work_area.height() - left_window_bounds.height()
                         : right_window_bounds.height();
    default:
      return Shell::Get()->split_view_controller()->GetDefaultDividerPosition(
          left_window ? left_window : right_window);
  }
}

  ~ScopedObserveWindowAnimation() {
    if (!Shell::Get()->tablet_mode_controller())
      return;

    if (!window_)
      return;

    if (window_->layer()->GetAnimator()->is_animating() &&
        (exiting_tablet_mode_ || manager_->IsTrackingWindow(window_))) {
      return;
    }

    Shell::Get()->tablet_mode_controller()->StopObservingAnimation(
        /*record_stats=*/false, /*delete_screenshot=*/true);
  }

void UpdateDeskContainersBackdrops() {
  for (auto* root : Shell::GetAllRootWindows()) {
    for (auto* desk_container : desks_util::GetDesksContainers(root)) {
      WorkspaceController* controller = GetWorkspaceController(desk_container);
      WorkspaceLayoutManager* layout_manager = controller->layout_manager();
      BackdropController* backdrop_controller =
          layout_manager->backdrop_controller();
      backdrop_controller->UpdateBackdrop();
    }
  }
}

bool TabletModeWindowManager::IsContainerWindow(aura::Window* window) {
  return base::Contains(observed_container_windows_, window);
}

void TabletModeWindowManager::ForgetWindow(aura::Window* window,
                                           bool destroyed) {
added_windows_.erase(window);
window->RemoveObserver(this);

WindowToState::iterator it = window_state_map_.find(window);
// A window may not be registered yet if the observer was
// registered in OnWindowHierarchyChanged.
if (it == window_state_map_.end())
return;

if (destroyed) {
// If the window is to-be-destroyed, remove it from |window_state_map_|
// immidietely. Otherwise it's possible to send a WMEvent to the to-be-
// destroyed window.  Note we should not restore its old previous window
// state object here since it will send unnecessary window state change
// events. The tablet window state object and the old window state object
// will be both deleted when the window is destroyed.
window_state_map_.erase(it);
} else {
// By telling the state object to revert, it will switch back the old
// State object and destroy itself, calling WindowStateDestroyed().
    it->second->LeaveTabletMode(wm::GetWindowState(it->first));
DCHECK(!IsTrackingWindow(window));
}
}

void TabletModeWindowManager::RemoveWindowCreationObservers() {
  for (aura::Window* window : observed_container_windows_)
    window->RemoveObserver(this);
  observed_container_windows_.clear();
}

void DoSplitViewTransition(
    base::flat_map<aura::Window*, WindowStateType> windows,
    int divider_position) {
  if (windows.empty())
    return;

  SplitViewController* split_view_controller =
      Shell::Get()->split_view_controller();
  if (!split_view_controller->InSplitViewMode())
    split_view_controller->InitDividerPositionForTransition(divider_position);

  for (auto& iter : windows) {
    split_view_controller->SnapWindow(
        iter.first, iter.second == WindowStateType::kLeftSnapped
                        ? SplitViewController::LEFT
                        : SplitViewController::RIGHT);
  }

  if (split_view_controller->InClamshellSplitViewMode() &&
      !Shell::Get()->overview_controller()->InOverviewSession()) {
    split_view_controller->EndSplitView();
  }
}

WindowStateType TabletModeWindowState::GetSnappedWindowStateType(
    wm::WindowState* window_state,
    WindowStateType target_state) {
  DCHECK(target_state == WindowStateType::kLeftSnapped ||
         target_state == WindowStateType::kRightSnapped);
  return CanSnapInSplitview(window_state->window())
             ? target_state
             : GetMaximizedOrCenteredWindowType(window_state);
}

void TabletModeWindowState::UpdateWindowPosition(wm::WindowState* window_state,
                                                 bool animate) {
  gfx::Rect bounds_in_parent = GetBoundsInTabletMode(window_state);
  if (bounds_in_parent == window_state->window()->GetTargetBounds())
    return;

  if (animate)
    window_state->SetBoundsDirectAnimated(bounds_in_parent);
  else
    window_state->SetBoundsDirect(bounds_in_parent);
}

void TabletModeWindowManager::SetIgnoreWmEventsForExit() {
  for (auto& pair : window_state_map_)
    pair.second->set_ignore_wm_events(true);
}

bool IsCarryOverCandidateForSplitView(
    const MruWindowTracker::WindowList& windows,
    size_t i) {
  return windows.size() > i && CanSnapInSplitview(windows[i]) &&
         !windows[i]->GetProperty(kIsShowingInOverviewKey) &&
         static_cast<ash::AppType>(windows[i]->GetProperty(
             aura::client::kAppType)) != AppType::ARC_APP;
}

  WindowStateType GetLastOldStateAndReset() {
    WindowStateType r = last_old_state_;
    last_old_state_ = WindowStateType::kDefault;
    return r;
  }

aura::Window* TabletModeWindowManager::GetTopWindow() {
  MruWindowTracker::WindowList windows =
      Shell::Get()->mru_window_tracker()->BuildWindowForCycleList(kActiveDesk);

  return windows.empty() ? nullptr : windows[0];
 }

void TabletModeWindowManager::ArrangeWindowsForClamshellMode(
    base::flat_map<aura::Window*, WindowStateType> windows_in_splitview) {
int divider_position = CalculateCarryOverDividerPostion(windows_in_splitview);

while (window_state_map_.size()) {
aura::Window* window = window_state_map_.begin()->first;
    ForgetWindow(window, /*destroyed=*/false);
}

if (IsClamshellSplitViewModeEnabled()) {
// Arriving here the window state has changed to its clamshell window state.
// Since we need to keep the windows that were in splitview still be snapped
// in clamshell mode, change its window state to the corresponding snapped
// window state.
DoSplitViewTransition(windows_in_splitview, divider_position);
}
}

void TabletModeWindowManager::OnActiveUserSessionChanged(
    const AccountId& account_id) {
  SplitViewController* split_view_controller =
      Shell::Get()->split_view_controller();

  split_view_controller->EndSplitView(
      SplitViewController::EndReason::kActiveUserChanged);

  if (accounts_since_entering_tablet_.count(account_id) == 0u) {
    base::flat_map<aura::Window*, WindowStateType> windows_in_splitview =
        GetCarryOverWindowsInSplitView();
    int divider_position =
        CalculateCarryOverDividerPostion(windows_in_splitview);
    DoSplitViewTransition(windows_in_splitview, divider_position);
    accounts_since_entering_tablet_.insert(account_id);
  } else {
    MruWindowTracker::WindowList windows =
        Shell::Get()->mru_window_tracker()->BuildWindowListIgnoreModal(
            kAllDesks);
    for (aura::Window* window : windows) {
      switch (wm::GetWindowState(window)->GetStateType()) {
        case WindowStateType::kLeftSnapped:
          if (split_view_controller->left_window() == nullptr) {
            split_view_controller->SnapWindow(window,
                                              SplitViewController::LEFT);
          }
          break;
        case WindowStateType::kRightSnapped:
          if (split_view_controller->right_window() == nullptr) {
            split_view_controller->SnapWindow(window,
                                              SplitViewController::RIGHT);
          }
          break;
        default:
          break;
      }
      if (split_view_controller->state() == SplitViewState::kBothSnapped)
        break;
    }
  }

  OverviewController* overview_controller = Shell::Get()->overview_controller();
  SplitViewState state = split_view_controller->state();
  if (state == SplitViewState::kLeftSnapped ||
      state == SplitViewState::kRightSnapped) {
    overview_controller->StartOverview();
  } else {
    overview_controller->EndOverview();
  }
}

bool TabletModeWindowManager::ShouldHandleWindow(aura::Window* window) {
  DCHECK(window);

  if (window->GetProperty(aura::client::kZOrderingKey) !=
      ui::ZOrderLevel::kNormal) {
    return false;
  }

  if (!wm::GetWindowState(window) ||
      wm::GetWindowState(window)->allow_set_bounds_direct()) {
    return false;
  }

  return window->type() == aura::client::WINDOW_TYPE_NORMAL;
}
