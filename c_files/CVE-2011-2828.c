void FaviconSource::OnFaviconDataAvailable(
    FaviconService::Handle request_handle,
    history::FaviconData favicon) {
  FaviconService* favicon_service =
      profile_->GetFaviconService(Profile::EXPLICIT_ACCESS);
  int request_id = cancelable_consumer_.GetClientData(favicon_service,
                                                      request_handle);

  if (favicon.is_valid()) {
    SendResponse(request_id, favicon.image_data);
  } else {
    SendDefaultResponse(request_id);
  }
 }

std::string FaviconSource::GetMimeType(const std::string&) const {
  return "image/png";
}

FaviconSource::~FaviconSource() {
}

void FaviconSource::StartDataRequest(const std::string& path,
bool is_incognito,
int request_id) {
FaviconService* favicon_service =
profile_->GetFaviconService(Profile::EXPLICIT_ACCESS);
if (favicon_service) {
    FaviconService::Handle handle;
if (path.empty()) {
SendDefaultResponse(request_id);
return;
}

if (path.size() > 8 && path.substr(0, 8) == "iconurl/") {
// TODO : Change GetFavicon to support combination of IconType.
handle = favicon_service->GetFavicon(
GURL(path.substr(8)),
history::FAVICON,
&cancelable_consumer_,
NewCallback(this, &FaviconSource::OnFaviconDataAvailable));
} else {
handle = favicon_service->GetFaviconForURL(
          GURL(path),
icon_types_,
&cancelable_consumer_,
NewCallback(this, &FaviconSource::OnFaviconDataAvailable));
}
// Attach the ChromeURLDataManager request ID to the history request.
cancelable_consumer_.SetClientData(favicon_service, handle, request_id);
} else {
SendResponse(request_id, NULL);
}
}

FaviconWebUIHandler::FaviconWebUIHandler() {
}

FaviconWebUIHandler::~FaviconWebUIHandler() {
}

void FaviconWebUIHandler::HandleGetFaviconDominantColor(const ListValue* args) {
std::string path;
CHECK(args->GetString(0, &path));
  DCHECK(StartsWithASCII(path, "chrome://favicon/", false)) << "path is "
                                                            << path;
  path = path.substr(arraysize("chrome://favicon/") - 1);

double id;
CHECK(args->GetDouble(1, &id));

FaviconService* favicon_service =
web_ui_->GetProfile()->GetFaviconService(Profile::EXPLICIT_ACCESS);
if (!favicon_service || path.empty())
return;

FaviconService::Handle handle = favicon_service->GetFaviconForURL(
GURL(path),
history::FAVICON,
&consumer_,
NewCallback(this, &FaviconWebUIHandler::OnFaviconDataAvailable));
consumer_.SetClientData(favicon_service, handle, static_cast<int>(id));
}

void FaviconWebUIHandler::OnFaviconDataAvailable(
FaviconService::Handle request_handle,
history::FaviconData favicon) {
FaviconService* favicon_service =
web_ui_->GetProfile()->GetFaviconService(Profile::EXPLICIT_ACCESS);
int id = consumer_.GetClientData(favicon_service, request_handle);

if (favicon.is_valid()) {
// TODO(estade): cache the response
    FundamentalValue id_value(id);
color_utils::GridSampler sampler;
SkColor color =
color_utils::CalculateKMeanColorOfPNG(favicon.image_data, 100, 665,
sampler);
std::string css_color = base::StringPrintf("rgb(%d, %d, %d)",
SkColorGetR(color),
SkColorGetG(color),
SkColorGetB(color));
    StringValue color_value(css_color);
    web_ui_->CallJavascriptFunction("ntp4.setFaviconDominantColor",
                                    id_value, color_value);
}
}

bool FaviconSource::ShouldReplaceExistingSource() const {
  return false;
}

void FaviconWebUIHandler::RegisterMessages() {
  web_ui_->RegisterMessageCallback("getFaviconDominantColor",
      NewCallback(this, &FaviconWebUIHandler::HandleGetFaviconDominantColor));
}

void FaviconSource::SendDefaultResponse(int request_id) {
  if (!default_favicon_.get()) {
    default_favicon_ =
        ResourceBundle::GetSharedInstance().LoadDataResourceBytes(
            IDR_DEFAULT_FAVICON);
}

  SendResponse(request_id, default_favicon_);
}
