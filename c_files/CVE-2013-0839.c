void OnCacheUpdatedForAddUploadedFile(
    const base::Closure& callback,
    GDataFileError /* error */,
    const std::string& /* resource_id */,
    const std::string& /* md5 */) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  if (!callback.is_null())
    callback.Run();
}

void GDataFileSystem::OnGetFileCompleteForCopy(
    const FilePath& remote_dest_file_path,
    const FileOperationCallback& callback,
    GDataFileError error,
    const FilePath& local_file_path,
    const std::string& unused_mime_type,
    GDataFileType file_type) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  DCHECK(!callback.is_null());

  if (error != GDATA_FILE_OK) {
    callback.Run(error);
    return;
  }

  DCHECK_EQ(REGULAR_FILE, file_type);
  BrowserThread::PostTask(
      BrowserThread::UI,
      FROM_HERE,
      base::Bind(&GDataFileSystem::TransferRegularFile,
                 ui_weak_ptr_,
                 local_file_path, remote_dest_file_path,
                 base::Bind(OnTransferRegularFileCompleteForCopy,
                            callback,
                            base::MessageLoopProxy::current())));
}

void GDataDirectoryService::GetEntryInfoPairByPaths(
    const FilePath& first_path,
    const FilePath& second_path,
    const GetEntryInfoPairCallback& callback) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  DCHECK(!callback.is_null());

  GetEntryInfoByPath(
      first_path,
      base::Bind(&GDataDirectoryService::GetEntryInfoPairByPathsAfterGetFirst,
                 weak_ptr_factory_.GetWeakPtr(),
                 first_path,
                 second_path,
                 callback));
}

void GDataFileSystem::GetFileByPath(
    const FilePath& file_path,
    const GetFileCallback& get_file_callback,
    const GetDownloadDataCallback& get_download_data_callback) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI) ||
         BrowserThread::CurrentlyOn(BrowserThread::IO));
  RunTaskOnUIThread(
      base::Bind(&GDataFileSystem::GetFileByPathOnUIThread,
                 ui_weak_ptr_,
                 file_path,
                 CreateRelayCallback(get_file_callback),
                 CreateRelayCallback(get_download_data_callback)));
}

void InitFromDBCallback(GDataFileError expected_error,
                        GDataFileError actual_error) {
  EXPECT_EQ(expected_error, actual_error);
}

void GDataDirectoryService::RefreshFile(scoped_ptr<GDataFile> fresh_file) {
  DCHECK(fresh_file.get());

  const std::string& resource_id = fresh_file->resource_id();
  GetEntryByResourceIdAsync(
      resource_id,
      base::Bind(&GDataDirectoryService::RefreshFileInternal,
                 base::Passed(&fresh_file)));
}

 void GDataDirectory::AddEntry(GDataEntry* entry) {
  entry->SetBaseNameFromTitle();

  int max_modifier = 1;
  FilePath full_file_name(entry->base_name());
  const std::string extension = full_file_name.Extension();
  const std::string file_name = full_file_name.RemoveExtension().value();
  while (FindChild(full_file_name.value())) {
    if (!extension.empty()) {
      full_file_name = FilePath(base::StringPrintf("%s (%d)%s",
                                                   file_name.c_str(),
                                                   ++max_modifier,
                                                   extension.c_str()));
    } else {
      full_file_name = FilePath(base::StringPrintf("%s (%d)",
                                                   file_name.c_str(),
                                                   ++max_modifier));
    }
  }
  entry->set_base_name(full_file_name.value());

  DVLOG(1) << "AddEntry: dir = " << GetFilePath().value()
           << ", file = " + entry->base_name()
           << ", parent resource = " << entry->parent_resource_id()
           << ", resource = " + entry->resource_id();

  if (directory_service_)
    directory_service_->AddEntryToResourceMap(entry);

  AddChild(entry);
  entry->SetParent(this);
}

void GetChildDirectoryPaths(GDataEntry* entry,
                            std::set<FilePath>* changed_dirs) {
  GDataDirectory* dir = entry->AsGDataDirectory();
  if (!dir)
    return;

  for (GDataDirectoryCollection::const_iterator it =
       dir->child_directories().begin();
       it != dir->child_directories().end(); ++it) {
    GDataDirectory* child_dir = it->second;
    changed_dirs->insert(child_dir->GetFilePath());
    GetChildDirectoryPaths(child_dir, changed_dirs);
  }
}

void GDataDirectoryService::InitFromDB(
    const FilePath& db_path,
    base::SequencedTaskRunner* blocking_task_runner,
    const FileOperationCallback& callback) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  DCHECK(!db_path.empty());
  DCHECK(blocking_task_runner);

  if (directory_service_db_.get()) {
    if (!callback.is_null())
      callback.Run(GDATA_FILE_ERROR_FAILED);
    return;
  }

  blocking_task_runner_ = blocking_task_runner;

  DVLOG(1) << "InitFromDB " << db_path.value();

  CreateDBParams* create_params =
      new CreateDBParams(db_path, blocking_task_runner);
  blocking_task_runner_->PostTaskAndReply(
      FROM_HERE,
      base::Bind(&CreateResourceMetadataDBOnBlockingPool,
                 create_params),
      base::Bind(&GDataDirectoryService::InitResourceMap,
                 weak_ptr_factory_.GetWeakPtr(),
                 base::Owned(create_params),
                 callback));
}

void CreateDocumentJsonFileOnBlockingPool(
    const FilePath& document_dir,
    const GURL& edit_url,
    const std::string& resource_id,
    GDataFileError* error,
    FilePath* temp_file_path,
    std::string* mime_type,
    GDataFileType* file_type) {
  DCHECK(error);
  DCHECK(temp_file_path);
  DCHECK(mime_type);
  DCHECK(file_type);

  *error = GDATA_FILE_ERROR_FAILED;

  if (file_util::CreateTemporaryFileInDir(document_dir, temp_file_path)) {
    std::string document_content = base::StringPrintf(
        "{\"url\": \"%s\", \"resource_id\": \"%s\"}",
        edit_url.spec().c_str(), resource_id.c_str());
    int document_size = static_cast<int>(document_content.size());
    if (file_util::WriteFile(*temp_file_path, document_content.data(),
                             document_size) == document_size) {
      *error = GDATA_FILE_OK;
    }
  }

  *mime_type = kMimeTypeJson;
  *file_type = HOSTED_DOCUMENT;
  if (*error != GDATA_FILE_OK)
      temp_file_path->clear();
}

void GDataFileSystem::InitializePreferenceObserver() {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  pref_registrar_.reset(new PrefChangeRegistrar());
  pref_registrar_->Init(profile_->GetPrefs());
  pref_registrar_->Add(prefs::kDisableGDataHostedFiles, this);
}

void GDataFileSystem::GetEntryInfoByPathAsyncOnUIThread(
    const FilePath& file_path,
    const GetEntryInfoCallback& callback) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  FindEntryByPathAsyncOnUIThread(
      file_path,
      base::Bind(&GDataFileSystem::OnGetEntryInfo,
                 ui_weak_ptr_,
                 callback));
}

GDataEntry* GDataDirectoryService::FindEntryByPathSync(
    const FilePath& file_path) {
  if (file_path == root_->GetFilePath())
    return root_.get();

  std::vector<FilePath::StringType> components;
  file_path.GetComponents(&components);
  GDataDirectory* current_dir = root_.get();

  for (size_t i = 1; i < components.size() && current_dir; ++i) {
    GDataEntry* entry = current_dir->FindChild(components[i]);
    if (!entry)
      return NULL;

    if (i == components.size() - 1)  // Last component.
      return entry;
    else
      current_dir = entry->AsGDataDirectory();
  }
  return NULL;
}

void GDataFileSystem::OnMoveEntryFromRootDirectoryCompleted(
    const FileOperationCallback& callback,
    const FilePath& file_path,
    const FilePath& dir_path,
    GDataErrorCode status,
    const GURL& document_url) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  DCHECK(!callback.is_null());

  GDataFileError error = util::GDataToGDataFileError(status);
  if (error == GDATA_FILE_OK) {
    GDataEntry* entry = directory_service_->FindEntryByPathSync(file_path);
    if (entry) {
      DCHECK_EQ(directory_service_->root(), entry->parent());
      directory_service_->MoveEntryToDirectory(dir_path, entry,
          base::Bind(
              &GDataFileSystem::OnMoveEntryToDirectoryWithFileOperationCallback,
              ui_weak_ptr_,
              callback));
      return;
    } else {
      error = GDATA_FILE_ERROR_NOT_FOUND;
    }
  }

  callback.Run(error);
}

ResourceMetadataDB::ResourceMetadataDB(const FilePath& db_path,
    base::SequencedTaskRunner* blocking_task_runner)
  : blocking_task_runner_(blocking_task_runner),
    db_path_(db_path) {
  DCHECK(blocking_task_runner_->RunsTasksOnCurrentThread());
}

void RunFileOperationCallbackHelper(
    const FileOperationCallback& callback,
    GDataFileError* error) {
  DCHECK(error);

  if (!callback.is_null())
    callback.Run(*error);
}

void GDataFileSystem::NotifyFileSystemToBeUnmounted() {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  DVLOG(1) << "File System is to be unmounted";
  FOR_EACH_OBSERVER(GDataFileSystemInterface::Observer, observers_,
                    OnFileSystemBeingUnmounted());
}

void GDataFileSystem::UpdateFileByEntryOnUIThread(
    const FileOperationCallback& callback,
    GDataEntry* entry) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  if (!entry || !entry->AsGDataFile()) {
    base::MessageLoopProxy::current()->PostTask(
        FROM_HERE,
        base::Bind(callback,
                   GDATA_FILE_ERROR_NOT_FOUND));
    return;
  }
  GDataFile* file = entry->AsGDataFile();

  cache_->GetFileOnUIThread(
      file->resource_id(),
      file->file_md5(),
      base::Bind(&GDataFileSystem::OnGetFileCompleteForUpdateFile,
                 ui_weak_ptr_,
                 callback));
}

void GDataDirectory::AddChild(GDataEntry* entry) {
  DCHECK(entry);

  GDataFile* file = entry->AsGDataFile();
  if (file)
    child_files_.insert(std::make_pair(entry->base_name(), file));

  GDataDirectory* directory = entry->AsGDataDirectory();
  if (directory)
    child_directories_.insert(std::make_pair(entry->base_name(), directory));
}

void GDataFileSystem::LoadRootFeedFromCacheForTesting() {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  feed_loader_->LoadFromCache(
      false,  // should_load_from_server.
      FilePath(),
      FindEntryCallback());
}

bool GDataDirectoryService::ParseFromString(
    const std::string& serialized_proto) {
  GDataRootDirectoryProto proto;
  if (!proto.ParseFromString(serialized_proto))
    return false;

  if (proto.version() != kProtoVersion) {
    LOG(ERROR) << "Incompatible proto detected (incompatible version): "
               << proto.version();
    return false;
  }

  if (!IsValidRootDirectoryProto(proto.gdata_directory()))
    return false;

  if (!root_->FromProto(proto.gdata_directory()))
    return false;

  origin_ = FROM_CACHE;
  largest_changestamp_ = proto.largest_changestamp();

  return true;
}

void GDataFileSystem::OnCreateDirectoryCompleted(
    const CreateDirectoryParams& params,
    GDataErrorCode status,
    scoped_ptr<base::Value> data) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  GDataFileError error = util::GDataToGDataFileError(status);
  if (error != GDATA_FILE_OK) {
    if (!params.callback.is_null())
      params.callback.Run(error);

    return;
  }

  base::DictionaryValue* dict_value = NULL;
  base::Value* created_entry = NULL;
  if (data.get() && data->GetAsDictionary(&dict_value) && dict_value)
    dict_value->Get("entry", &created_entry);
  error = AddNewDirectory(params.created_directory_path.DirName(),
                          created_entry);

  if (error != GDATA_FILE_OK) {
    if (!params.callback.is_null())
      params.callback.Run(error);

    return;
  }

  if (params.target_directory_path != params.created_directory_path &&
      params.is_recursive) {
    CreateDirectory(params.target_directory_path,
                    params.is_exclusive,
                    params.is_recursive,
                    params.callback);
    return;
  }

  if (!params.callback.is_null()) {
    params.callback.Run(GDATA_FILE_OK);
  }
}

void GDataFileSystem::SearchAsyncOnUIThread(
    const std::string& search_query,
    const GURL& next_feed,
    const SearchCallback& callback) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  scoped_ptr<std::vector<DocumentFeed*> > feed_list(
      new std::vector<DocumentFeed*>);

  ContentOrigin initial_origin = directory_service_->origin();
  feed_loader_->LoadFromServer(
      initial_origin,
      0, 0,  // We don't use change stamps when fetching search
      false,  // Stop fetching search results after first feed
      FilePath(),  // Not used.
      search_query,
      next_feed,
      std::string(),  // No directory resource ID.
      FindEntryCallback(),  // Not used.
      base::Bind(&GDataFileSystem::OnSearch, ui_weak_ptr_, callback));
}

GDataDirectory* AddDirectory(GDataDirectory* parent,
GDataDirectoryService* directory_service,
int sequence_id) {
  GDataDirectory* dir = new GDataDirectory(NULL, directory_service);
const std::string dir_name = "dir" + base::IntToString(sequence_id);
const std::string resource_id = std::string("dir_resource_id:") +
dir_name;
dir->set_title(dir_name);
dir->set_resource_id(resource_id);
GDataFileError error = GDATA_FILE_ERROR_FAILED;
FilePath moved_file_path;
directory_service->MoveEntryToDirectory(
parent->GetFilePath(),
dir,
base::Bind(&test_util::CopyResultsFromFileMoveCallback,
&error,
&moved_file_path));
test_util::RunBlockingPoolTask();
EXPECT_EQ(GDATA_FILE_OK, error);
EXPECT_EQ(parent->GetFilePath().AppendASCII(dir_name), moved_file_path);
return dir;
}

void GDataFileSystem::TransferFileFromLocalToRemote(
    const FilePath& local_src_file_path,
    const FilePath& remote_dest_file_path,
    const FileOperationCallback& callback) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  DCHECK(!callback.is_null());

  directory_service_->GetEntryInfoByPath(
      remote_dest_file_path.DirName(),
      base::Bind(
          &GDataFileSystem::TransferFileFromLocalToRemoteAfterGetEntryInfo,
          ui_weak_ptr_,
          local_src_file_path,
          remote_dest_file_path,
          callback));
}

void GDataFileSystem::FindEntryByPathAsyncOnUIThread(
    const FilePath& search_file_path,
    const FindEntryCallback& callback) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  if (directory_service_->origin() == INITIALIZING) {
    AddObserver(new InitialLoadObserver(
        this,
        base::Bind(&GDataFileSystem::FindEntryByPathSyncOnUIThread,
                   ui_weak_ptr_,
                   search_file_path,
                   callback)));
    return;
  } else if (directory_service_->origin() == UNINITIALIZED) {
    directory_service_->set_origin(INITIALIZING);
    feed_loader_->LoadFromCache(
        true,  // should_load_from_server
        search_file_path,
        base::Bind(&GDataFileSystem::RunAndNotifyInitialLoadFinished,
                   ui_weak_ptr_,
                   callback));
    return;
  }

  base::MessageLoopProxy::current()->PostTask(
      FROM_HERE,
      base::Bind(&GDataFileSystem::FindEntryByPathSyncOnUIThread,
                 ui_weak_ptr_,
                 search_file_path,
                 callback));
}

GDataFileError GDataFileSystem::UpdateFromFeedForTesting(
    const std::vector<DocumentFeed*>& feed_list,
    int64 start_changestamp,
    int64 root_feed_changestamp) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  return feed_loader_->UpdateFromFeed(feed_list,
                                      start_changestamp,
                                      root_feed_changestamp);
}

void GDataFileSystem::OnTransferCompleted(
    const FileOperationCallback& callback,
    GDataFileError error,
    scoped_ptr<UploadFileInfo> upload_file_info) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  DCHECK(upload_file_info.get());

  if (error == GDATA_FILE_OK && upload_file_info->entry.get()) {
    AddUploadedFile(UPLOAD_NEW_FILE,
                    upload_file_info->gdata_path.DirName(),
                    upload_file_info->entry.Pass(),
                    upload_file_info->file_path,
                    GDataCache::FILE_OPERATION_COPY,
                    base::Bind(&OnAddUploadFileCompleted, callback, error));
  } else if (!callback.is_null()) {
    callback.Run(error);
  }
}

void GDataDirectoryService::GetEntryInfoByPath(
    const FilePath& path,
    const GetEntryInfoCallback& callback) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  DCHECK(!callback.is_null());

  scoped_ptr<GDataEntryProto> entry_proto;
  GDataFileError error = GDATA_FILE_ERROR_FAILED;

  GDataEntry* entry = FindEntryByPathSync(path);
  if (entry) {
    entry_proto.reset(new GDataEntryProto);
    entry->ToProtoFull(entry_proto.get());
    error = GDATA_FILE_OK;
  } else {
    error = GDATA_FILE_ERROR_NOT_FOUND;
  }

  base::MessageLoopProxy::current()->PostTask(
      FROM_HERE,
      base::Bind(callback, error, base::Passed(&entry_proto)));
}

void GDataFileSystem::GetAvailableSpaceOnUIThread(
    const GetAvailableSpaceCallback& callback) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  DCHECK(!callback.is_null());

  if (gdata::util::IsDriveV2ApiEnabled()) {
    documents_service_->GetAboutResource(
      base::Bind(&GDataFileSystem::OnGetAboutResource,
                 ui_weak_ptr_,
                 callback));
    return;
  }

  documents_service_->GetAccountMetadata(
      base::Bind(&GDataFileSystem::OnGetAvailableSpace,
                 ui_weak_ptr_,
                 callback));
}

void GDataFileSystem::OnFilePathUpdated(const FileOperationCallback& callback,
                                        GDataFileError error,
                                        const FilePath& /* file_path */) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  if (!callback.is_null())
    callback.Run(error);
}

void GDataFileSystem::NotifyFileSystemMounted() {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  DVLOG(1) << "File System is mounted";
  FOR_EACH_OBSERVER(GDataFileSystemInterface::Observer, observers_,
                    OnFileSystemMounted());
}

FilePath GDataEntry::GetFilePath() const {
  FilePath path;
  if (parent())
    path = parent()->GetFilePath();
  path = path.Append(base_name());
  return path;
}

void GDataFileSystem::GetEntryInfoByEntryOnUIThread(
    const GetEntryInfoWithFilePathCallback& callback,
    GDataEntry* entry) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  if (entry) {
    scoped_ptr<GDataEntryProto> entry_proto(new GDataEntryProto);
    entry->ToProtoFull(entry_proto.get());
    CheckLocalModificationAndRun(
        entry_proto.Pass(),
        base::Bind(&RunGetEntryInfoWithFilePathCallback,
                   callback, entry->GetFilePath()));
  } else {
    callback.Run(GDATA_FILE_ERROR_NOT_FOUND,
                 FilePath(),
                 scoped_ptr<GDataEntryProto>());
  }
}

void OnAddUploadFileCompleted(
    const FileOperationCallback& callback,
    GDataFileError error) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  if (!callback.is_null())
    callback.Run(error);
}

void GDataFileSystem::GetFileByEntryOnUIThread(
    const GetFileCallback& get_file_callback,
    const GetDownloadDataCallback& get_download_data_callback,
    GDataEntry* entry) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  FilePath file_path;
  if (entry) {
    GDataFile* file = entry->AsGDataFile();
    if (file)
      file_path = file->GetFilePath();
  }

  if (file_path.empty()) {
    if (!get_file_callback.is_null()) {
      base::MessageLoopProxy::current()->PostTask(
          FROM_HERE,
          base::Bind(get_file_callback,
                     GDATA_FILE_ERROR_NOT_FOUND,
                     FilePath(),
                     std::string(),
                     REGULAR_FILE));
    }
    return;
  }

  GetFileByPath(file_path, get_file_callback, get_download_data_callback);
}

void GDataFile::SetBaseNameFromTitle() {
  if (is_hosted_document_) {
    base_name_ = EscapeUtf8FileName(title_ + document_extension_);
  } else {
    GDataEntry::SetBaseNameFromTitle();
   }
 }

void GDataFileSystem::OnGetFileSizeCompleteForUpdateFile(
    const FileOperationCallback& callback,
    const std::string& resource_id,
    const std::string& md5,
    const FilePath& cache_file_path,
    GDataFileError* error,
    int64* file_size) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  if (*error != GDATA_FILE_OK) {
    if (!callback.is_null())
      callback.Run(*error);
    return;
  }

  directory_service_->GetEntryByResourceIdAsync(resource_id,
      base::Bind(&GDataFileSystem::OnGetFileCompleteForUpdateFileByEntry,
          ui_weak_ptr_,
          callback,
          md5,
          *file_size,
          cache_file_path));
}

void GDataFileSystem::AddUploadedFile(
    UploadMode upload_mode,
    const FilePath& virtual_dir_path,
    scoped_ptr<DocumentEntry> entry,
    const FilePath& file_content_path,
    GDataCache::FileOperationType cache_operation,
    const base::Closure& callback) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  base::MessageLoopProxy::current()->PostTask(
      FROM_HERE,
      base::Bind(&GDataFileSystem::AddUploadedFileOnUIThread,
                 ui_weak_ptr_,
                 upload_mode,
                 virtual_dir_path,
                 base::Passed(&entry),
                 file_content_path,
                 cache_operation,
                 callback));
}

void GDataFileSystem::RequestDirectoryRefresh(const FilePath& file_path) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI) ||
         BrowserThread::CurrentlyOn(BrowserThread::IO));
  RunTaskOnUIThread(
      base::Bind(&GDataFileSystem::RequestDirectoryRefreshOnUIThread,
                 ui_weak_ptr_,
                 file_path));
}

void GDataFileSystem::RenameAfterGetEntryInfo(
    const FilePath& file_path,
    const FilePath::StringType& new_name,
    const FileMoveCallback& callback,
    GDataFileError error,
    scoped_ptr<GDataEntryProto> entry_proto) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  if (error != GDATA_FILE_OK) {
    if (!callback.is_null())
      callback.Run(error, file_path);
    return;
  }
  DCHECK(entry_proto.get());

  FilePath::StringType file_name = new_name;
  if (entry_proto->has_file_specific_info() &&
      entry_proto->file_specific_info().is_hosted_document()) {
    FilePath new_file(file_name);
    if (new_file.Extension() ==
        entry_proto->file_specific_info().document_extension()) {
      file_name = new_file.RemoveExtension().value();
    }
  }

  documents_service_->RenameResource(
      GURL(entry_proto->edit_url()),
      file_name,
      base::Bind(&GDataFileSystem::RenameFileOnFileSystem,
                 ui_weak_ptr_,
                 file_path,
                 file_name,
                 callback));
}

void GDataWapiFeedProcessor::ApplyFeedFromFileUrlMap(
    bool is_delta_feed,
    int64 feed_changestamp,
    FileResourceIdMap* file_map,
  std::set<FilePath>* changed_dirs) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  DCHECK(changed_dirs);

  if (!is_delta_feed) {  // Full update.
    directory_service_->root()->RemoveChildren();
    changed_dirs->insert(directory_service_->root()->GetFilePath());
  }
  directory_service_->set_largest_changestamp(feed_changestamp);

  scoped_ptr<GDataDirectoryService> orphaned_dir_service(
      new GDataDirectoryService);
  for (FileResourceIdMap::iterator it = file_map->begin();
       it != file_map->end();) {
    scoped_ptr<GDataEntry> entry(it->second);
    DCHECK_EQ(it->first, entry->resource_id());
    file_map->erase(it++);

    GDataEntry* old_entry =
        directory_service_->GetEntryByResourceId(entry->resource_id());
    GDataDirectory* dest_dir = NULL;
    if (entry->is_deleted()) {  // Deleted file/directory.
      DVLOG(1) << "Removing file " << entry->base_name();
      if (!old_entry)
        continue;

      dest_dir = old_entry->parent();
      if (!dest_dir) {
        NOTREACHED();
        continue;
      }
      RemoveEntryFromDirectoryAndCollectChangedDirectories(
          dest_dir, old_entry, changed_dirs);
    } else if (old_entry) {  // Change or move of existing entry.
      DVLOG(1) << "Changed file " << entry->base_name();
      dest_dir = old_entry->parent();
      if (!dest_dir) {
        NOTREACHED();
        continue;
      }
      if (old_entry->AsGDataDirectory() && entry->AsGDataDirectory()) {
        entry->AsGDataDirectory()->TakeOverEntries(
            old_entry->AsGDataDirectory());
      }
      RemoveEntryFromDirectoryAndCollectChangedDirectories(
          dest_dir, old_entry, changed_dirs);
      if (dest_dir->resource_id() != entry->parent_resource_id()) {
        changed_dirs->insert(dest_dir->GetFilePath());
        dest_dir = FindDirectoryForNewEntry(entry.get(),
                                            *file_map,
                                            orphaned_dir_service.get());
      }
      DCHECK(dest_dir);
      AddEntryToDirectoryAndCollectChangedDirectories(
          entry.release(),
          dest_dir,
          orphaned_dir_service.get(),
          changed_dirs);
    } else {  // Adding a new file.
      dest_dir = FindDirectoryForNewEntry(entry.get(),
                                          *file_map,
                                          orphaned_dir_service.get());
      DCHECK(dest_dir);
      AddEntryToDirectoryAndCollectChangedDirectories(
          entry.release(),
          dest_dir,
          orphaned_dir_service.get(),
          changed_dirs);
    }

    if (dest_dir && (dest_dir->parent() ||
        dest_dir == directory_service_->root()) &&
        dest_dir != orphaned_dir_service->root() && is_delta_feed) {
      changed_dirs->insert(dest_dir->GetFilePath());
    }
  }
  DCHECK(file_map->empty());
}

void GDataFileSystem::AddUploadedFileOnUIThread(
UploadMode upload_mode,
const FilePath& virtual_dir_path,
scoped_ptr<DocumentEntry> entry,
const FilePath& file_content_path,
GDataCache::FileOperationType cache_operation,
const base::Closure& callback) {
DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

// ScopedClosureRunner ensures that the specified callback is always invoked
// upon return or passed on.
base::ScopedClosureRunner callback_runner(callback);

if (!entry.get()) {
NOTREACHED();
return;
}

GDataEntry* dir_entry = directory_service_->FindEntryByPathSync(
virtual_dir_path);
if (!dir_entry)
return;

GDataDirectory* parent_dir  = dir_entry->AsGDataDirectory();
if (!parent_dir)
return;

scoped_ptr<GDataEntry> new_entry(
      GDataEntry::FromDocumentEntry(
          NULL, entry.get(), directory_service_.get()));
if (!new_entry.get())
return;

if (upload_mode == UPLOAD_EXISTING_FILE) {
// Remove an existing entry, which should be present.
const std::string& resource_id = new_entry->resource_id();
directory_service_->GetEntryByResourceIdAsync(resource_id,
base::Bind(&RemoveStaleEntryOnUpload, resource_id, parent_dir));
}

GDataFile* file = new_entry->AsGDataFile();
DCHECK(file);
const std::string& resource_id = file->resource_id();
const std::string& md5 = file->file_md5();
parent_dir->AddEntry(new_entry.release());

OnDirectoryChanged(virtual_dir_path);

if (upload_mode == UPLOAD_NEW_FILE) {
// Add the file to the cache if we have uploaded a new file.
cache_->StoreOnUIThread(resource_id,
md5,
file_content_path,
cache_operation,
base::Bind(&OnCacheUpdatedForAddUploadedFile,
callback_runner.Release()));
} else if (upload_mode == UPLOAD_EXISTING_FILE) {
// Clear the dirty bit if we have updated an existing file.
cache_->ClearDirtyOnUIThread(resource_id,
md5,
base::Bind(&OnCacheUpdatedForAddUploadedFile,
callback_runner.Release()));
} else {
NOTREACHED() << "Unexpected upload mode: " << upload_mode;
}
}

GDataFileError GDataWapiFeedProcessor::FeedToFileResourceMap(
const std::vector<DocumentFeed*>& feed_list,
FileResourceIdMap* file_map,
int64* feed_changestamp,
FeedToFileResourceMapUmaStats* uma_stats) {
DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
DCHECK(uma_stats);

GDataFileError error = GDATA_FILE_OK;
uma_stats->num_regular_files = 0;
uma_stats->num_hosted_documents = 0;
uma_stats->num_files_with_entry_kind.clear();
for (size_t i = 0; i < feed_list.size(); ++i) {
const DocumentFeed* feed = feed_list[i];

// Get upload url from the root feed. Links for all other collections will
// be handled in GDatadirectory::FromDocumentEntry();
if (i == 0) {
const Link* root_feed_upload_link =
feed->GetLinkByType(Link::RESUMABLE_CREATE_MEDIA);
if (root_feed_upload_link)
directory_service_->root()->set_upload_url(
root_feed_upload_link->href());
*feed_changestamp = feed->largest_changestamp();
DCHECK_GE(*feed_changestamp, 0);
}

for (ScopedVector<DocumentEntry>::const_iterator iter =
feed->entries().begin();
iter != feed->entries().end(); ++iter) {
DocumentEntry* doc = *iter;
      GDataEntry* entry = GDataEntry::FromDocumentEntry(
          NULL, doc, directory_service_);
// Some document entries don't map into files (i.e. sites).
if (!entry)
continue;
// Count the number of files.
GDataFile* as_file = entry->AsGDataFile();
if (as_file) {
if (as_file->is_hosted_document())
++uma_stats->num_hosted_documents;
else
++uma_stats->num_regular_files;
++uma_stats->num_files_with_entry_kind[as_file->kind()];
}

FileResourceIdMap::iterator map_entry =
file_map->find(entry->resource_id());

// An entry with the same self link may already exist, so we need to
// release the existing GDataEntry instance before overwriting the
// entry with another GDataEntry instance.
if (map_entry != file_map->end()) {
LOG(WARNING) << "Found duplicate file "
<< map_entry->second->base_name();

delete map_entry->second;
file_map->erase(map_entry);
}
file_map->insert(
std::pair<std::string, GDataEntry*>(entry->resource_id(), entry));
}
}

if (error != GDATA_FILE_OK) {
// If the code above fails to parse a feed, any GDataEntry instance
// added to |file_by_url| is not managed by a GDataDirectory instance,
// so we need to explicitly release them here.
STLDeleteValues(file_map);
}

return error;
}

void GDataFileSystem::CheckLocalModificationAndRunAfterGetCacheEntry(
    scoped_ptr<GDataEntryProto> entry_proto,
    const GetEntryInfoCallback& callback,
    bool success,
    const GDataCacheEntry& cache_entry) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  if (!success || !cache_entry.is_dirty()) {
    if (!callback.is_null())
      callback.Run(GDATA_FILE_OK, entry_proto.Pass());
    return;
  }

  const std::string& resource_id = entry_proto->resource_id();
  const std::string& md5 = entry_proto->file_specific_info().file_md5();
  cache_->GetFileOnUIThread(
      resource_id,
      md5,
      base::Bind(
          &GDataFileSystem::CheckLocalModificationAndRunAfterGetCacheFile,
          ui_weak_ptr_, base::Passed(&entry_proto), callback));
}

void GDataFileSystem::StartDownloadFileIfEnoughSpace(
    const GetFileFromCacheParams& params,
    const GURL& content_url,
    const FilePath& cache_file_path,
    bool* has_enough_space) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  if (!*has_enough_space) {
    if (!params.get_file_callback.is_null()) {
      params.get_file_callback.Run(GDATA_FILE_ERROR_NO_SPACE,
                                   cache_file_path,
                                   params.mime_type,
                                   REGULAR_FILE);
    }
    return;
  }

  documents_service_->DownloadFile(
      params.virtual_file_path,
      params.local_tmp_path,
      content_url,
      base::Bind(&GDataFileSystem::OnFileDownloaded,
                 ui_weak_ptr_,
                 params),
      params.get_download_data_callback);
}

void GDataFileSystem::CloseFile(const FilePath& file_path,
                                const FileOperationCallback& callback) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI) ||
         BrowserThread::CurrentlyOn(BrowserThread::IO));
  RunTaskOnUIThread(base::Bind(&GDataFileSystem::CloseFileOnUIThread,
                               ui_weak_ptr_,
                               file_path,
                               CreateRelayCallback(callback)));
}

void VerifyDirectoryService(GDataDirectoryService* directory_service) {
  ASSERT_TRUE(directory_service->root());

  GDataDirectory* dir1 = FindDirectory(directory_service, "drive/dir1");
  ASSERT_TRUE(dir1);
  GDataDirectory* dir2 = FindDirectory(directory_service, "drive/dir2");
  ASSERT_TRUE(dir2);
  GDataDirectory* dir3 = FindDirectory(directory_service, "drive/dir1/dir3");
  ASSERT_TRUE(dir3);

  GDataFile* file4 = FindFile(directory_service, "drive/dir1/file4");
  ASSERT_TRUE(file4);
  EXPECT_EQ(file4->parent(), dir1);

  GDataFile* file5 = FindFile(directory_service, "drive/dir1/file5");
  ASSERT_TRUE(file5);
  EXPECT_EQ(file5->parent(), dir1);

  GDataFile* file6 = FindFile(directory_service, "drive/dir2/file6");
  ASSERT_TRUE(file6);
  EXPECT_EQ(file6->parent(), dir2);

  GDataFile* file7 = FindFile(directory_service, "drive/dir2/file7");
  ASSERT_TRUE(file7);
  EXPECT_EQ(file7->parent(), dir2);

  GDataFile* file8 = FindFile(directory_service, "drive/dir2/file8");
  ASSERT_TRUE(file8);
  EXPECT_EQ(file8->parent(), dir2);

  GDataFile* file9 = FindFile(directory_service, "drive/dir1/dir3/file9");
  ASSERT_TRUE(file9);
  EXPECT_EQ(file9->parent(), dir3);

  GDataFile* file10 = FindFile(directory_service, "drive/dir1/dir3/file10");
  ASSERT_TRUE(file10);
  EXPECT_EQ(file10->parent(), dir3);

  EXPECT_EQ(dir1, directory_service->GetEntryByResourceId(
      "dir_resource_id:dir1"));
  EXPECT_EQ(dir2, directory_service->GetEntryByResourceId(
      "dir_resource_id:dir2"));
  EXPECT_EQ(dir3, directory_service->GetEntryByResourceId(
      "dir_resource_id:dir3"));
  EXPECT_EQ(file4, directory_service->GetEntryByResourceId(
      "file_resource_id:file4"));
  EXPECT_EQ(file5, directory_service->GetEntryByResourceId(
      "file_resource_id:file5"));
  EXPECT_EQ(file6, directory_service->GetEntryByResourceId(
      "file_resource_id:file6"));
  EXPECT_EQ(file7, directory_service->GetEntryByResourceId(
      "file_resource_id:file7"));
  EXPECT_EQ(file8, directory_service->GetEntryByResourceId(
      "file_resource_id:file8"));
  EXPECT_EQ(file9, directory_service->GetEntryByResourceId(
      "file_resource_id:file9"));
  EXPECT_EQ(file10, directory_service->GetEntryByResourceId(
      "file_resource_id:file10"));
}

GDataDirectoryService::~GDataDirectoryService() {
  ClearRoot();

  if (blocking_task_runner_ && directory_service_db_.get())
    blocking_task_runner_->DeleteSoon(FROM_HERE,
                                       directory_service_db_.release());
 }

void ResourceMetadataDB::Clear() {
  level_db_.reset();
  leveldb::DestroyDB(db_path_.value(), leveldb::Options());
  Init();
}

void GDataFileSystem::StopUpdates() {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  if (update_timer_.IsRunning())
    update_timer_.Stop();
}

void GetLocalFileSizeOnBlockingPool(const FilePath& local_file,
                                    GDataFileError* error,
                                    int64* file_size) {
  DCHECK(error);
  DCHECK(file_size);

  *file_size = 0;
  *error = file_util::GetFileSize(local_file, file_size) ?
      GDATA_FILE_OK :
      GDATA_FILE_ERROR_NOT_FOUND;
}

void ResourceMetadataDB::Init() {
  DCHECK(blocking_task_runner_->RunsTasksOnCurrentThread());
  DCHECK(!db_path_.empty());

  DVLOG(1) << "Init " << db_path_.value();

  leveldb::DB* level_db = NULL;
  leveldb::Options options;
  options.create_if_missing = true;
  leveldb::Status db_status = leveldb::DB::Open(options, db_path_.value(),
                                                &level_db);
  DCHECK(level_db);
  DCHECK(db_status.ok());
  level_db_.reset(level_db);
}

  StartFileUploadParams(const FilePath& in_local_file_path,
                        const FilePath& in_remote_file_path,
                        const FileOperationCallback& in_callback)
      : local_file_path(in_local_file_path),
        remote_file_path(in_remote_file_path),
        callback(in_callback) {}

void GDataFileSystem::OnGetEntryInfoForCreateFile(
    const FilePath& file_path,
    bool is_exclusive,
    const FileOperationCallback& callback,
    GDataFileError result,
    GDataEntry* entry) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  if (result != GDATA_FILE_ERROR_NOT_FOUND &&
      result != GDATA_FILE_OK) {
    if (!callback.is_null())
      callback.Run(result);
    return;
  }

  if (result == GDATA_FILE_OK) {
    if (is_exclusive ||
        !entry->AsGDataFile() ||
        entry->AsGDataFile()->is_hosted_document()) {
      if (!callback.is_null())
        callback.Run(GDATA_FILE_ERROR_EXISTS);
      return;
    }

    if (!callback.is_null())
      callback.Run(GDATA_FILE_OK);
    return;
  }

  TransferRegularFile(FilePath(kEmptyFilePath), file_path, callback);
}

void GDataFileSystem::RemoveEntryFromDirectory(
    const FilePath& dir_path,
    const FileMoveCallback& callback,
    GDataFileError error,
    const FilePath& file_path) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  GDataEntry* entry = directory_service_->FindEntryByPathSync(file_path);
  GDataEntry* dir = directory_service_->FindEntryByPathSync(dir_path);
  if (error == GDATA_FILE_OK) {
    if (!entry || !dir) {
      error = GDATA_FILE_ERROR_NOT_FOUND;
    } else {
      if (!dir->AsGDataDirectory())
        error = GDATA_FILE_ERROR_NOT_A_DIRECTORY;
    }
  }

  if (error != GDATA_FILE_OK ||
      dir->resource_id() == kGDataRootDirectoryResourceId) {
    if (!callback.is_null()) {
      MessageLoop::current()->PostTask(FROM_HERE,
          base::Bind(callback, error, file_path));
    }
    return;
  }

  documents_service_->RemoveResourceFromDirectory(
      dir->content_url(),
      entry->edit_url(),
      entry->resource_id(),
      base::Bind(&GDataFileSystem::RemoveEntryFromDirectoryOnFileSystem,
                 ui_weak_ptr_,
                 callback,
                 file_path,
                 dir_path));
}

GDataWapiFeedProcessor::~GDataWapiFeedProcessor() {
}

GDataFileSystem::~GDataFileSystem() {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  feed_loader_->RemoveObserver(this);

  documents_service_->CancelAll();
}

void GDataFileSystem::RenameFileOnFileSystem(
    const FilePath& file_path,
    const FilePath::StringType& new_name,
    const FileMoveCallback& callback,
    GDataErrorCode status,
    const GURL& document_url) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  const GDataFileError error = util::GDataToGDataFileError(status);
  if (error != GDATA_FILE_OK) {
    if (!callback.is_null())
      callback.Run(error, FilePath());
    return;
  }

  GDataEntry* entry = directory_service_->FindEntryByPathSync(file_path);
  if (!entry) {
    if (!callback.is_null())
      callback.Run(GDATA_FILE_ERROR_NOT_FOUND, FilePath());
    return;
  }

  DCHECK(entry->parent());
  entry->set_title(new_name);
  directory_service_->MoveEntryToDirectory(
      entry->parent()->GetFilePath(),
      entry,
      base::Bind(&GDataFileSystem::OnMoveEntryToDirectoryWithFileMoveCallback,
                 ui_weak_ptr_,
                 callback));
}

void GDataFileSystem::OnGetEntryInfoCompleteForCloseFile(
    const FilePath& file_path,
    const FileOperationCallback& callback,
    GDataFileError error,
    scoped_ptr<GDataEntryProto> entry_proto) {
  if (entry_proto.get() && !entry_proto->has_file_specific_info())
    error = GDATA_FILE_ERROR_NOT_FOUND;

  if (error != GDATA_FILE_OK) {
    if (!callback.is_null())
      callback.Run(error);
    return;
  }

  cache_->GetFileOnUIThread(
      entry_proto->resource_id(),
      entry_proto->file_specific_info().file_md5(),
      base::Bind(&GDataFileSystem::OnGetCacheFilePathCompleteForCloseFile,
                 ui_weak_ptr_,
                 file_path,
                 callback));
}

GDataDirectory::GDataDirectory(GDataDirectory* parent,
                               GDataDirectoryService* directory_service)
    : GDataEntry(parent, directory_service) {
file_info_.is_directory = true;
}

GDataFileError GDataFileSystem::RemoveEntryFromGData(
    const FilePath& file_path, std::string* resource_id) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  resource_id->clear();

  GDataEntry* entry = directory_service_->FindEntryByPathSync(file_path);

  if (!entry)
    return GDATA_FILE_ERROR_NOT_FOUND;

  if (!entry->parent())
    return GDATA_FILE_ERROR_ACCESS_DENIED;

  if (entry->AsGDataFile())
    *resource_id = entry->AsGDataFile()->resource_id();

  GDataDirectory* parent_dir = entry->parent();
  parent_dir->RemoveEntry(entry);

  OnDirectoryChanged(parent_dir->GetFilePath());
  return GDATA_FILE_OK;
}

void GDataFileSystem::GetEntryInfoByPath(const FilePath& file_path,
                                         const GetEntryInfoCallback& callback) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI) ||
         BrowserThread::CurrentlyOn(BrowserThread::IO));
  RunTaskOnUIThread(
      base::Bind(&GDataFileSystem::GetEntryInfoByPathAsyncOnUIThread,
                 ui_weak_ptr_,
                 file_path,
                 CreateRelayCallback(callback)));
}

void GDataFileSystem::TransferFileFromLocalToRemoteAfterGetEntryInfo(
    const FilePath& local_src_file_path,
    const FilePath& remote_dest_file_path,
    const FileOperationCallback& callback,
    GDataFileError error,
    scoped_ptr<GDataEntryProto> entry_proto) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  DCHECK(!callback.is_null());

  if (error != GDATA_FILE_OK) {
    callback.Run(error);
    return;
  }

  DCHECK(entry_proto.get());
  if (!entry_proto->file_info().is_directory()) {
    callback.Run(GDATA_FILE_ERROR_NOT_A_DIRECTORY);
    return;
  }

  std::string* resource_id = new std::string;
  util::PostBlockingPoolSequencedTaskAndReply(
      FROM_HERE,
      blocking_task_runner_,
      base::Bind(&GetDocumentResourceIdOnBlockingPool,
                 local_src_file_path,
                 resource_id),
      base::Bind(&GDataFileSystem::TransferFileForResourceId,
                 ui_weak_ptr_,
                 local_src_file_path,
                 remote_dest_file_path,
                 callback,
                 base::Owned(resource_id)));
}

void GDataFileSystem::OnDownloadStoredToCache(GDataFileError error,
                                              const std::string& resource_id,
                                              const std::string& md5) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
}

void GDataFileSystem::OnMoveEntryToDirectoryWithFileMoveCallback(
    const FileMoveCallback& callback,
    GDataFileError error,
    const FilePath& moved_file_path) {
  if (error == GDATA_FILE_OK)
    OnDirectoryChanged(moved_file_path.DirName());

  if (!callback.is_null())
    callback.Run(error, moved_file_path);
}

  static void Run(scoped_refptr<base::MessageLoopProxy> relay_proxy,
                  const base::Callback<void(T1, T2, T3, T4)>& callback,
                  T1 arg1,
                  T2 arg2,
                  T3 arg3,
                  T4 arg4) {
    if (callback.is_null())
      return;
    RunTaskOnThread(relay_proxy, base::Bind(callback, arg1, arg2, arg3, arg4));
  }

 std::string GDataEntry::EscapeUtf8FileName(const std::string& input) {
   std::string output;
  if (ReplaceChars(input, kSlash, std::string(kEscapedSlash), &output))
    return output;

  return input;
}

void OnTransferRegularFileCompleteForCopy(
    const FileOperationCallback& callback,
    scoped_refptr<base::MessageLoopProxy> relay_proxy,
    GDataFileError error) {
  if (!callback.is_null())
    relay_proxy->PostTask(FROM_HERE, base::Bind(callback, error));
}

GDataFileSystem::GDataFileSystem(
    Profile* profile,
    GDataCache* cache,
    DocumentsServiceInterface* documents_service,
    GDataUploaderInterface* uploader,
    DriveWebAppsRegistryInterface* webapps_registry,
    base::SequencedTaskRunner* blocking_task_runner)
    : profile_(profile),
      cache_(cache),
      uploader_(uploader),
      documents_service_(documents_service),
      webapps_registry_(webapps_registry),
      update_timer_(true /* retain_user_task */, true /* is_repeating */),
      hide_hosted_docs_(false),
      blocking_task_runner_(blocking_task_runner),
      ui_weak_ptr_factory_(ALLOW_THIS_IN_INITIALIZER_LIST(this)),
      ui_weak_ptr_(ui_weak_ptr_factory_.GetWeakPtr()) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
}

void GDataFileSystem::CopyOnUIThreadAfterGetEntryInfoPair(
    const FilePath& dest_file_path,
    const FileOperationCallback& callback,
    scoped_ptr<EntryInfoPairResult> result) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  DCHECK(!callback.is_null());
  DCHECK(result.get());

  if (result->first.error != GDATA_FILE_OK) {
    callback.Run(result->first.error);
    return;
  } else if (result->second.error != GDATA_FILE_OK) {
    callback.Run(result->second.error);
    return;
  }

  scoped_ptr<GDataEntryProto> src_file_proto = result->first.proto.Pass();
  scoped_ptr<GDataEntryProto> dest_parent_proto = result->second.proto.Pass();

  if (!dest_parent_proto->file_info().is_directory()) {
    callback.Run(GDATA_FILE_ERROR_NOT_A_DIRECTORY);
    return;
  } else if (src_file_proto->file_info().is_directory()) {
    callback.Run(GDATA_FILE_ERROR_INVALID_OPERATION);
    return;
  }

  if (src_file_proto->file_specific_info().is_hosted_document()) {
    CopyDocumentToDirectory(dest_file_path.DirName(),
                            src_file_proto->resource_id(),
                            dest_file_path.BaseName().RemoveExtension().value(),
                            callback);
    return;
  }

  const FilePath& src_file_path = result->first.path;
  GetFileByPath(src_file_path,
                base::Bind(&GDataFileSystem::OnGetFileCompleteForCopy,
                           ui_weak_ptr_,
                           dest_file_path,
                           callback),
                GetDownloadDataCallback());
}

void GDataFileSystem::OpenFileOnUIThread(const FilePath& file_path,
                                         const OpenFileCallback& callback) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  if (open_files_.find(file_path) != open_files_.end()) {
    MessageLoop::current()->PostTask(
        FROM_HERE,
        base::Bind(callback, GDATA_FILE_ERROR_IN_USE, FilePath()));
    return;
  }
  open_files_.insert(file_path);

  directory_service_->GetEntryInfoByPath(
      file_path,
      base::Bind(&GDataFileSystem::OnGetEntryInfoCompleteForOpenFile,
                 ui_weak_ptr_,
                 file_path,
                 base::Bind(&GDataFileSystem::OnOpenFileFinished,
                            ui_weak_ptr_,
                            file_path,
                            callback)));
}

void GDataFileSystem::OnFileDownloadedAndSpaceChecked(
    const GetFileFromCacheParams& params,
    GDataErrorCode status,
    const GURL& content_url,
    const FilePath& downloaded_file_path,
    bool* has_enough_space) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  GDataFileError error = util::GDataToGDataFileError(status);

  if (error == GDATA_FILE_OK) {
    if (*has_enough_space) {
      cache_->StoreOnUIThread(
          params.resource_id,
          params.md5,
          downloaded_file_path,
          GDataCache::FILE_OPERATION_MOVE,
          base::Bind(&GDataFileSystem::OnDownloadStoredToCache,
                     ui_weak_ptr_));
    } else {
      util::PostBlockingPoolSequencedTask(
          FROM_HERE,
          blocking_task_runner_,
          base::Bind(base::IgnoreResult(&file_util::Delete),
                     downloaded_file_path,
                     false /* recursive*/));
      error = GDATA_FILE_ERROR_NO_SPACE;
    }
  }

  if (!params.get_file_callback.is_null()) {
    params.get_file_callback.Run(error,
                                 downloaded_file_path,
                                 params.mime_type,
                                 REGULAR_FILE);
  }
}

void GDataFileSystem::OpenFile(const FilePath& file_path,
                               const OpenFileCallback& callback) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI) ||
         BrowserThread::CurrentlyOn(BrowserThread::IO));
  RunTaskOnUIThread(base::Bind(&GDataFileSystem::OpenFileOnUIThread,
                               ui_weak_ptr_,
                               file_path,
                               CreateRelayCallback(callback)));
}

void GDataFileSystem::MoveOnUIThread(const FilePath& src_file_path,
                                     const FilePath& dest_file_path,
                                     const FileOperationCallback& callback) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  DCHECK(!callback.is_null());

  directory_service_->GetEntryInfoPairByPaths(
      src_file_path,
      dest_file_path.DirName(),
      base::Bind(&GDataFileSystem::MoveOnUIThreadAfterGetEntryInfoPair,
                 ui_weak_ptr_,
                 dest_file_path,
                 callback));
}

void GDataFileSystem::AddObserver(
    GDataFileSystemInterface::Observer* observer) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  observers_.AddObserver(observer);
}

void GDataDirectoryService::FindEntryByPathAndRunSync(
    const FilePath& search_file_path,
    const FindEntryCallback& callback) {
  GDataEntry* entry = FindEntryByPathSync(search_file_path);
  callback.Run(entry ? GDATA_FILE_OK : GDATA_FILE_ERROR_NOT_FOUND, entry);
}

  static void Run(scoped_refptr<base::MessageLoopProxy> relay_proxy,
                  const base::Callback<void(T1, T2, scoped_ptr<T3>)>& callback,
                  T1 arg1,
                  T2 arg2,
                  scoped_ptr<T3> arg3) {
    if (callback.is_null())
      return;
    RunTaskOnThread(relay_proxy,
                    base::Bind(callback, arg1, arg2, base::Passed(&arg3)));
  }

void GDataFileSystem::OnGetFileCompleteForUpdateFileByEntry(
    const FileOperationCallback& callback,
    const std::string& md5,
    int64 file_size,
    const FilePath& cache_file_path,
    GDataEntry* entry) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  if (!entry || !entry->AsGDataFile()) {
    if (!callback.is_null())
      callback.Run(GDATA_FILE_ERROR_NOT_FOUND);
    return;
  }
  GDataFile* file = entry->AsGDataFile();

  uploader_->UploadExistingFile(
      file->upload_url(),
      file->GetFilePath(),
      cache_file_path,
      file_size,
      file->content_mime_type(),
      base::Bind(&GDataFileSystem::OnUpdatedFileUploaded,
                 ui_weak_ptr_,
                 callback));
}

void GDataEntry::ToProtoFull(GDataEntryProto* proto) const {
  if (AsGDataFileConst()) {
    AsGDataFileConst()->ToProto(proto);
  } else if (AsGDataDirectoryConst()) {
    ToProto(proto);
  } else {
    NOTREACHED();
  }
}

void GDataFileSystem::RunAndNotifyInitialLoadFinished(
    const FindEntryCallback& callback,
    GDataFileError error,
    GDataEntry* entry) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  if (!callback.is_null())
    callback.Run(error, entry);

  DVLOG(1) << "RunAndNotifyInitialLoadFinished";

  FOR_EACH_OBSERVER(GDataFileSystemInterface::Observer, observers_,
                    OnInitialLoadFinished());
}

void GDataFileSystem::CheckLocalModificationAndRunAfterGetFileInfo(
    scoped_ptr<GDataEntryProto> entry_proto,
    const GetEntryInfoCallback& callback,
    base::PlatformFileInfo* file_info,
    bool* get_file_info_result) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  if (!*get_file_info_result) {
    if (!callback.is_null())
      callback.Run(GDATA_FILE_ERROR_NOT_FOUND, scoped_ptr<GDataEntryProto>());
    return;
  }

  PlatformFileInfoProto entry_file_info;
  GDataEntry::ConvertPlatformFileInfoToProto(*file_info, &entry_file_info);
  *entry_proto->mutable_file_info() = entry_file_info;
  if (!callback.is_null())
    callback.Run(GDATA_FILE_OK, entry_proto.Pass());
}

bool IsValidRootDirectoryProto(const GDataDirectoryProto& proto) {
  const GDataEntryProto& entry_proto = proto.gdata_entry();
  if (entry_proto.title() != "drive") {
    LOG(ERROR) << "Incompatible proto detected (bad title): "
               << entry_proto.title();
    return false;
  }
  if (entry_proto.resource_id() != kGDataRootDirectoryResourceId) {
    LOG(ERROR) << "Incompatible proto detected (bad resource ID): "
               << entry_proto.resource_id();
    return false;
  }

  return true;
}

void ResourceMetadataDB::Save(
    const GDataDirectoryService::SerializedMap& serialized_resources) {
  DCHECK(blocking_task_runner_->RunsTasksOnCurrentThread());

  Clear();
  for (GDataDirectoryService::SerializedMap::const_iterator iter =
      serialized_resources.begin();
      iter != serialized_resources.end(); ++iter) {
    DVLOG(1) << "Saving resource " << iter->first << " to db";
    leveldb::Status status = level_db_->Put(leveldb::WriteOptions(),
                                            leveldb::Slice(iter->first),
                                            leveldb::Slice(iter->second));
    if (!status.ok()) {
      LOG(ERROR) << "leveldb Put failed of " << iter->first
                 << ", with " << status.ToString();
      NOTREACHED();
    }
  }
}

void GDataFileSystem::RemoveStaleEntryOnUpload(const std::string& resource_id,
                                               GDataDirectory* parent_dir,
                                               GDataEntry* existing_entry) {
  if (existing_entry &&
      existing_entry->parent() == parent_dir) {
    parent_dir->RemoveEntry(existing_entry);
  } else {
    LOG(ERROR) << "Entry for the existing file not found: " << resource_id;
  }
}

void GDataFileSystem::OnGetFileCompleteForTransferFile(
    const FilePath& local_dest_file_path,
    const FileOperationCallback& callback,
    GDataFileError error,
    const FilePath& local_file_path,
    const std::string& unused_mime_type,
    GDataFileType file_type) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  DCHECK(!callback.is_null());

  if (error != GDATA_FILE_OK) {
    callback.Run(error);
    return;
  }

  GDataFileError* copy_file_error =
      new GDataFileError(GDATA_FILE_OK);
  util::PostBlockingPoolSequencedTaskAndReply(
      FROM_HERE,
      blocking_task_runner_,
      base::Bind(&CopyLocalFileOnBlockingPool,
                 local_file_path,
                 local_dest_file_path,
                 copy_file_error),
      base::Bind(&RunFileOperationCallbackHelper,
                 callback,
                 base::Owned(copy_file_error)));
}

  static void Run(scoped_refptr<base::MessageLoopProxy> relay_proxy,
                  const base::Callback<void(T1)>& callback,
                  T1 arg1) {
    if (callback.is_null())
      return;
    RunTaskOnThread(relay_proxy, base::Bind(callback, arg1));
  }

GDataDirectoryService::GDataDirectoryService()
: blocking_task_runner_(NULL),
serialized_size_(0),
largest_changestamp_(0),
origin_(UNINITIALIZED),
weak_ptr_factory_(ALLOW_THIS_IN_INITIALIZER_LIST(this)) {
  root_.reset(new GDataDirectory(NULL, this));
if (!util::IsDriveV2ApiEnabled())
InitializeRootEntry(kGDataRootDirectoryResourceId);
}

GDataFileSystem::GetFileCompleteForOpenParams::~GetFileCompleteForOpenParams() {
}

void GDataFileSystem::OnDocumentFeedFetched(int num_accumulated_entries) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  FOR_EACH_OBSERVER(GDataFileSystemInterface::Observer, observers_,
                    OnDocumentFeedFetched(num_accumulated_entries));
}

void GDataFileSystem::Rename(const FilePath& file_path,
                             const FilePath::StringType& new_name,
                             const FileMoveCallback& callback) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  DCHECK(!callback.is_null());

  if (file_path.BaseName().value() == new_name) {
    callback.Run(GDATA_FILE_OK, file_path);
    return;
  }

  directory_service_->GetEntryInfoByPath(
      file_path,
      base::Bind(
          &GDataFileSystem::RenameAfterGetEntryInfo,
          ui_weak_ptr_,
          file_path,
          new_name,
          callback));
}

void GDataFileSystem::OnSearch(const SearchCallback& callback,
GetDocumentsParams* params,
GDataFileError error) {
DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

if (error != GDATA_FILE_OK) {
if (!callback.is_null())
callback.Run(error, GURL(), scoped_ptr<std::vector<SearchResultInfo> >());
return;
}

// The search results will be returned using virtual directory.
// The directory is not really part of the file system, so it has no parent or
// root.
std::vector<SearchResultInfo>* results(new std::vector<SearchResultInfo>());

DCHECK_EQ(1u, params->feed_list->size());
DocumentFeed* feed = params->feed_list->at(0);

// TODO(tbarzic): Limit total number of returned results for the query.
GURL next_feed;
feed->GetNextFeedURL(&next_feed);

if (feed->entries().empty()) {
scoped_ptr<std::vector<SearchResultInfo> > result_vec(results);
if (!callback.is_null())
callback.Run(error, next_feed, result_vec.Pass());
return;
}

// Go through all entires generated by the feed and add them to the search
// result directory.
for (size_t i = 0; i < feed->entries().size(); ++i) {
DocumentEntry* doc = const_cast<DocumentEntry*>(feed->entries()[i]);
    scoped_ptr<GDataEntry> entry(
        GDataEntry::FromDocumentEntry(NULL, doc, directory_service_.get()));

if (!entry.get())
continue;

DCHECK_EQ(doc->resource_id(), entry->resource_id());
DCHECK(!entry->is_deleted());

std::string entry_resource_id = entry->resource_id();

// This will do nothing if the entry is not already present in file system.
if (entry->AsGDataFile()) {
scoped_ptr<GDataFile> entry_as_file(entry.release()->AsGDataFile());
directory_service_->RefreshFile(entry_as_file.Pass());
// We shouldn't use entry object after this point.
DCHECK(!entry.get());
}

// We will need information about result entry to create info for callback.
// We can't use |entry| anymore, so we have to refetch entry from file
// system. Also, |entry| doesn't have file path set before |RefreshFile|
// call, so we can't get file path from there.
directory_service_->GetEntryByResourceIdAsync(entry_resource_id,
base::Bind(&AddEntryToSearchResults,
results,
callback,
base::Bind(&GDataFileSystem::CheckForUpdates, ui_weak_ptr_),
error,
i+1 == feed->entries().size(),
next_feed));
}
}

void GDataFileSystem::OnGetFileCompleteForOpenFile(
    const OpenFileCallback& callback,
    const GetFileCompleteForOpenParams& entry_proto,
    GDataFileError error,
    const FilePath& file_path,
    const std::string& mime_type,
    GDataFileType file_type) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  if (error != GDATA_FILE_OK) {
    if (!callback.is_null())
      callback.Run(error, FilePath());
    return;
  }

  DCHECK_EQ(REGULAR_FILE, file_type);

  cache_->MarkDirtyOnUIThread(
      entry_proto.resource_id,
      entry_proto.md5,
      base::Bind(&GDataFileSystem::OnMarkDirtyInCacheCompleteForOpenFile,
                 ui_weak_ptr_,
                 callback));
}

void GDataFileSystem::RemoveObserver(
    GDataFileSystemInterface::Observer* observer) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  observers_.RemoveObserver(observer);
}

void GDataDirectoryService::GetEntryInfoPairByPathsAfterGetSecond(
    const FilePath& second_path,
    const GetEntryInfoPairCallback& callback,
    scoped_ptr<EntryInfoPairResult> result,
    GDataFileError error,
    scoped_ptr<GDataEntryProto> entry_proto) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  DCHECK(!callback.is_null());
  DCHECK(result.get());

  result->second.path = second_path;
  result->second.error = error;
  result->second.proto = entry_proto.Pass();

  callback.Run(result.Pass());
}

void GDataFileSystem::CreateFile(const FilePath& file_path,
                                 bool is_exclusive,
                                 const FileOperationCallback& callback) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI) ||
         BrowserThread::CurrentlyOn(BrowserThread::IO));
  RunTaskOnUIThread(base::Bind(&GDataFileSystem::CreateFileOnUIThread,
                               ui_weak_ptr_,
                               file_path,
                               is_exclusive,
                               CreateRelayCallback(callback)));
}

void GDataFileSystem::GetAvailableSpace(
    const GetAvailableSpaceCallback& callback) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI) ||
         BrowserThread::CurrentlyOn(BrowserThread::IO));
  RunTaskOnUIThread(base::Bind(&GDataFileSystem::GetAvailableSpaceOnUIThread,
                               ui_weak_ptr_,
                               CreateRelayCallback(callback)));
}

void GDataFileSystem::OnGetEntryCompleteForCloseFile(
    const FilePath& file_path,
    const base::PlatformFileInfo& file_info,
    const FileOperationCallback& callback,
    GDataFileError error,
    GDataEntry* entry) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  if (error != GDATA_FILE_OK) {
    if (!callback.is_null())
      callback.Run(error);
    return;
  }

  DCHECK(entry);
  GDataFile* file = entry->AsGDataFile();
  if (!file || file->file_md5().empty() || file->is_hosted_document()) {
    if (!callback.is_null())
      callback.Run(GDATA_FILE_ERROR_INVALID_OPERATION);
    return;
  }
  DCHECK(!file->resource_id().empty());

  file->set_file_info(file_info);

  cache_->CommitDirtyOnUIThread(
      file->resource_id(),
      file->file_md5(),
      base::Bind(&GDataFileSystem::OnCommitDirtyInCacheCompleteForCloseFile,
                 ui_weak_ptr_,
                 callback));
}

void GDataFileSystem::RemoveOnUIThreadAfterGetEntryInfo(
    const FilePath& file_path,
    bool /* is_recursive */,
    const FileOperationCallback& callback,
    GDataFileError error,
    scoped_ptr<GDataEntryProto> entry_proto) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  if (error != GDATA_FILE_OK) {
    if (!callback.is_null()) {
      base::MessageLoopProxy::current()->PostTask(
          FROM_HERE, base::Bind(callback, error));
    }
    return;
  }

  DCHECK(entry_proto.get());
  documents_service_->DeleteDocument(
      GURL(entry_proto->edit_url()),
      base::Bind(&GDataFileSystem::OnRemovedDocument,
                 ui_weak_ptr_,
                 callback,
                 file_path));
}

void GDataFileSystem::UpdateFileByResourceId(
    const std::string& resource_id,
    const FileOperationCallback& callback) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI) ||
         BrowserThread::CurrentlyOn(BrowserThread::IO));
  RunTaskOnUIThread(
      base::Bind(&GDataFileSystem::UpdateFileByResourceIdOnUIThread,
                 ui_weak_ptr_,
                 resource_id,
                 CreateRelayCallback(callback)));
}

void GDataFileSystem::OnGetFileCompleteForUpdateFile(
    const FileOperationCallback& callback,
    GDataFileError error,
    const std::string& resource_id,
    const std::string& md5,
    const FilePath& cache_file_path) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  if (error != GDATA_FILE_OK) {
    if (!callback.is_null())
      callback.Run(error);
    return;
  }

  GDataFileError* get_size_error = new GDataFileError(GDATA_FILE_ERROR_FAILED);
  int64* file_size = new int64(-1);
  util::PostBlockingPoolSequencedTaskAndReply(
      FROM_HERE,
      blocking_task_runner_,
      base::Bind(&GetLocalFileSizeOnBlockingPool,
                 cache_file_path,
                 get_size_error,
                 file_size),
      base::Bind(&GDataFileSystem::OnGetFileSizeCompleteForUpdateFile,
                 ui_weak_ptr_,
                 callback,
                 resource_id,
                 md5,
                 cache_file_path,
                 base::Owned(get_size_error),
                 base::Owned(file_size)));
}

void GDataDirectoryService::RefreshFileInternal(
    scoped_ptr<GDataFile> fresh_file,
    GDataEntry* old_entry) {
  GDataDirectory* entry_parent = old_entry ? old_entry->parent() : NULL;
  if (entry_parent) {
    DCHECK_EQ(fresh_file->resource_id(), old_entry->resource_id());
    DCHECK(old_entry->AsGDataFile());

    entry_parent->RemoveEntry(old_entry);
    entry_parent->AddEntry(fresh_file.release());
  }
}

void GDataFileSystem::RequestDirectoryRefreshByEntry(
    const FilePath& directory_path,
    const std::string& directory_resource_id,
    const FileResourceIdMap& file_map,
    GDataEntry* directory_entry) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  if (!directory_entry || !directory_entry->AsGDataDirectory()) {
    LOG(ERROR) << "Directory entry is gone: " << directory_path.value()
               << ": " << directory_resource_id;
    return;
  }
  GDataDirectory* directory = directory_entry->AsGDataDirectory();

  directory->RemoveChildFiles();
  for (FileResourceIdMap::const_iterator it = file_map.begin();
       it != file_map.end(); ++it) {
    scoped_ptr<GDataEntry> entry(it->second);
    if (!entry->AsGDataFile())
      continue;
    directory->AddEntry(entry.release());
  }

  OnDirectoryChanged(directory_path);
  DVLOG(1) << "Directory refreshed: " << directory_path.value();
}

void GDataFileSystem::CreateFileOnUIThread(
    const FilePath& file_path,
    bool is_exclusive,
    const FileOperationCallback& callback) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  FindEntryByPathAsyncOnUIThread(
      file_path,
      base::Bind(&GDataFileSystem::OnGetEntryInfoForCreateFile,
                 ui_weak_ptr_,
                 file_path,
                 is_exclusive,
                 callback));
}

void GDataFileSystem::OnUpdateChecked(ContentOrigin initial_origin,
                                      GDataFileError error,
                                      GDataEntry* /* entry */) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  if (error != GDATA_FILE_OK) {
    directory_service_->set_origin(initial_origin);
  }
}

EntryInfoPairResult::EntryInfoPairResult() {
}

  static void Run(scoped_refptr<base::MessageLoopProxy> relay_proxy,
                  const base::Callback<void(T1, T2, T3)>& callback,
                  T1 arg1,
                  T2 arg2,
                  T3 arg3) {
    if (callback.is_null())
      return;
    RunTaskOnThread(relay_proxy, base::Bind(callback, arg1, arg2, arg3));
  }

GDataEntry* GDataDirectory::FromDocumentEntry(
    GDataDirectory* parent,
    DocumentEntry* doc,
    GDataDirectoryService* directory_service) {
  DCHECK(doc->is_folder());
  GDataDirectory* dir = new GDataDirectory(parent, directory_service);
  dir->title_ = UTF16ToUTF8(doc->title());
  // SetBaseNameFromTitle() must be called after |title_| is set.
  dir->SetBaseNameFromTitle();
  dir->file_info_.last_modified = doc->updated_time();
  dir->file_info_.last_accessed = doc->updated_time();
  dir->file_info_.creation_time = doc->published_time();
  dir->resource_id_ = doc->resource_id();
  dir->content_url_ = doc->content_url();
  dir->deleted_ = doc->deleted();
  const Link* edit_link = doc->GetLinkByType(Link::EDIT);
  DCHECK(edit_link) << "No edit link for dir " << dir->title_;
  if (edit_link)
    dir->edit_url_ = edit_link->href();
  const Link* parent_link = doc->GetLinkByType(Link::PARENT);
  if (parent_link)
    dir->parent_resource_id_ = ExtractResourceId(parent_link->href());

const Link* upload_link = doc->GetLinkByType(Link::RESUMABLE_CREATE_MEDIA);
if (upload_link)
    dir->upload_url_ = upload_link->href();
  return dir;
}

GDataFileError GDataFileSystem::AddNewDirectory(
const FilePath& directory_path, base::Value* entry_value) {
DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

if (!entry_value)
return GDATA_FILE_ERROR_FAILED;

scoped_ptr<DocumentEntry> doc_entry(DocumentEntry::CreateFrom(*entry_value));

if (!doc_entry.get())
return GDATA_FILE_ERROR_FAILED;

// Find parent directory element within the cached file system snapshot.
GDataEntry* entry = directory_service_->FindEntryByPathSync(directory_path);
if (!entry)
return GDATA_FILE_ERROR_FAILED;

// Check if parent is a directory since in theory since this is a callback
// something could in the meantime have nuked the parent dir and created a
// file with the exact same name.
GDataDirectory* parent_dir = entry->AsGDataDirectory();
if (!parent_dir)
return GDATA_FILE_ERROR_FAILED;

  GDataEntry* new_entry = GDataEntry::FromDocumentEntry(
      NULL, doc_entry.get(), directory_service_.get());
if (!new_entry)
return GDATA_FILE_ERROR_FAILED;

parent_dir->AddEntry(new_entry);

OnDirectoryChanged(directory_path);
return GDATA_FILE_OK;
}

void GDataFileSystem::StartFileUploadOnUIThreadAfterGetEntryInfo(
    const StartFileUploadParams& params,
    int64 file_size,
    std::string content_type,
    GDataFileError error,
    scoped_ptr<GDataEntryProto> entry_proto) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  if (entry_proto.get() && !entry_proto->file_info().is_directory())
    error = GDATA_FILE_ERROR_NOT_A_DIRECTORY;

  if (error != GDATA_FILE_OK) {
    if (!params.callback.is_null())
      params.callback.Run(error);
    return;
  }
  DCHECK(entry_proto.get());

  scoped_ptr<UploadFileInfo> upload_file_info(new UploadFileInfo);
  upload_file_info->file_path = params.local_file_path;
  upload_file_info->file_size = file_size;
  upload_file_info->gdata_path = params.remote_file_path;
  upload_file_info->title = params.remote_file_path.BaseName().value();
  upload_file_info->content_length = file_size;
  upload_file_info->all_bytes_present = true;
  upload_file_info->content_type = content_type;
  upload_file_info->initial_upload_location = GURL(entry_proto->upload_url());

  upload_file_info->completion_callback =
      base::Bind(&GDataFileSystem::OnTransferCompleted,
                 ui_weak_ptr_,
                 params.callback);

  uploader_->UploadNewFile(upload_file_info.Pass());
}

void CopyLocalFileOnBlockingPool(
    const FilePath& src_file_path,
    const FilePath& dest_file_path,
    GDataFileError* error) {
  DCHECK(error);

  *error = file_util::CopyFile(src_file_path, dest_file_path) ?
      GDATA_FILE_OK : GDATA_FILE_ERROR_FAILED;
}

void GDataEntry::ToProto(GDataEntryProto* proto) const {
  ConvertPlatformFileInfoToProto(file_info_, proto->mutable_file_info());

  proto->set_base_name(base_name_);
  proto->set_title(title_);
  proto->set_resource_id(resource_id_);
  proto->set_parent_resource_id(parent_resource_id_);
  proto->set_edit_url(edit_url_.spec());
  proto->set_content_url(content_url_.spec());
  proto->set_upload_url(upload_url_.spec());
}

void GDataEntry::SerializeToString(std::string* serialized_proto) const {
  const GDataFile* file = AsGDataFileConst();
  const GDataDirectory* dir = AsGDataDirectoryConst();

  if (file) {
    GDataEntryProto entry_proto;
    file->ToProto(&entry_proto);
    const bool ok = entry_proto.SerializeToString(serialized_proto);
    DCHECK(ok);
  } else if (dir) {
    GDataDirectoryProto dir_proto;
    dir->ToProto(&dir_proto);
    const bool ok = dir_proto.SerializeToString(serialized_proto);
    DCHECK(ok);
  }
}

void GDataFileSystem::GetFileByResourceIdOnUIThread(
    const std::string& resource_id,
    const GetFileCallback& get_file_callback,
    const GetDownloadDataCallback& get_download_data_callback) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  directory_service_->GetEntryByResourceIdAsync(resource_id,
      base::Bind(&GDataFileSystem::GetFileByEntryOnUIThread,
                 ui_weak_ptr_,
                 get_file_callback,
                 get_download_data_callback));
}

GDataEntry* GDataDirectoryService::GetEntryByResourceId(
    const std::string& resource) {
  ResourceMap::const_iterator iter = resource_map_.find(resource);
  return iter == resource_map_.end() ? NULL : iter->second;
}

void GDataDirectoryService::RemoveEntryFromResourceMap(GDataEntry* entry) {
  resource_map_.erase(entry->resource_id());
}

scoped_ptr<GDataEntryProtoVector> GDataDirectory::ToProtoVector() const {
  scoped_ptr<GDataEntryProtoVector> entries(new GDataEntryProtoVector);
  for (GDataFileCollection::const_iterator iter = child_files().begin();
       iter != child_files().end(); ++iter) {
    GDataEntryProto proto;
    iter->second->ToProto(&proto);
    entries->push_back(proto);
  }
  for (GDataDirectoryCollection::const_iterator iter =
           child_directories().begin();
       iter != child_directories().end(); ++iter) {
    GDataEntryProto proto;
    static_cast<const GDataEntry*>(iter->second)->ToProtoFull(&proto);
    entries->push_back(proto);
  }

  return entries.Pass();
}

void GDataFileSystem::OnGetEntryInfoCompleteForOpenFile(
    const FilePath& file_path,
    const OpenFileCallback& callback,
    GDataFileError error,
    scoped_ptr<GDataEntryProto> entry_proto) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  if (entry_proto.get() && !entry_proto->has_file_specific_info())
    error = GDATA_FILE_ERROR_NOT_FOUND;

  if (error == GDATA_FILE_OK) {
    if (entry_proto->file_specific_info().file_md5().empty() ||
        entry_proto->file_specific_info().is_hosted_document()) {
      error = GDATA_FILE_ERROR_INVALID_OPERATION;
    }
  }

  if (error != GDATA_FILE_OK) {
    if (!callback.is_null())
      callback.Run(error, FilePath());
    return;
  }

  DCHECK(!entry_proto->resource_id().empty());
  GetResolvedFileByPath(
      file_path,
      base::Bind(&GDataFileSystem::OnGetFileCompleteForOpenFile,
                 ui_weak_ptr_,
                 callback,
                 GetFileCompleteForOpenParams(
                     entry_proto->resource_id(),
                     entry_proto->file_specific_info().file_md5())),
      GetDownloadDataCallback(),
      error,
      entry_proto.get());
}

void GDataFile::ToProto(GDataEntryProto* proto) const {
  GDataEntry::ToProto(proto);
  DCHECK(!proto->file_info().is_directory());
  GDataFileSpecificInfo* file_specific_info =
      proto->mutable_file_specific_info();
  file_specific_info->set_thumbnail_url(thumbnail_url_.spec());
  file_specific_info->set_alternate_url(alternate_url_.spec());
  file_specific_info->set_content_mime_type(content_mime_type_);
  file_specific_info->set_file_md5(file_md5_);
  file_specific_info->set_document_extension(document_extension_);
  file_specific_info->set_is_hosted_document(is_hosted_document_);
}

void GDataFileSystem::Observe(int type,
                              const content::NotificationSource& source,
                              const content::NotificationDetails& details) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  if (type == chrome::NOTIFICATION_PREF_CHANGED) {
    PrefService* pref_service = profile_->GetPrefs();
    std::string* pref_name = content::Details<std::string>(details).ptr();
    if (*pref_name == prefs::kDisableGDataHostedFiles) {
      SetHideHostedDocuments(
          pref_service->GetBoolean(prefs::kDisableGDataHostedFiles));
    }
  } else {
    NOTREACHED();
  }
}

 const GDataFile* GDataEntry::AsGDataFileConst() const {
   return const_cast<GDataEntry*>(this)->AsGDataFile();
}

void GDataFileSystem::GetResolvedFileByPath(
    const FilePath& file_path,
    const GetFileCallback& get_file_callback,
    const GetDownloadDataCallback& get_download_data_callback,
    GDataFileError error,
    const GDataEntryProto* entry_proto) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  if (entry_proto && !entry_proto->has_file_specific_info())
    error = GDATA_FILE_ERROR_NOT_FOUND;

  if (error != GDATA_FILE_OK) {
    if (!get_file_callback.is_null()) {
      MessageLoop::current()->PostTask(
          FROM_HERE,
          base::Bind(get_file_callback,
                     GDATA_FILE_ERROR_NOT_FOUND,
                     FilePath(),
                     std::string(),
                     REGULAR_FILE));
    }
    return;
  }

  if (entry_proto->file_specific_info().is_hosted_document()) {
    GDataFileError* error =
        new GDataFileError(GDATA_FILE_OK);
    FilePath* temp_file_path = new FilePath;
    std::string* mime_type = new std::string;
    GDataFileType* file_type = new GDataFileType(REGULAR_FILE);
    util::PostBlockingPoolSequencedTaskAndReply(
        FROM_HERE,
        blocking_task_runner_,
        base::Bind(&CreateDocumentJsonFileOnBlockingPool,
                   cache_->GetCacheDirectoryPath(
                       GDataCache::CACHE_TYPE_TMP_DOCUMENTS),
                   GURL(entry_proto->file_specific_info().alternate_url()),
                   entry_proto->resource_id(),
                   error,
                   temp_file_path,
                   mime_type,
                   file_type),
        base::Bind(&RunGetFileCallbackHelper,
                   get_file_callback,
                   base::Owned(error),
                   base::Owned(temp_file_path),
                   base::Owned(mime_type),
                   base::Owned(file_type)));
    return;
  }

  FilePath local_tmp_path = cache_->GetCacheFilePath(
      entry_proto->resource_id(),
      entry_proto->file_specific_info().file_md5(),
      GDataCache::CACHE_TYPE_TMP,
      GDataCache::CACHED_FILE_FROM_SERVER);
  cache_->GetFileOnUIThread(
      entry_proto->resource_id(),
      entry_proto->file_specific_info().file_md5(),
      base::Bind(
          &GDataFileSystem::OnGetFileFromCache,
          ui_weak_ptr_,
          GetFileFromCacheParams(
              file_path,
              local_tmp_path,
              GURL(entry_proto->content_url()),
              entry_proto->resource_id(),
              entry_proto->file_specific_info().file_md5(),
              entry_proto->file_specific_info().content_mime_type(),
              get_file_callback,
              get_download_data_callback)));
}

void GDataDirectoryService::SaveToDB() {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  if (!blocking_task_runner_ || !directory_service_db_.get()) {
    NOTREACHED();
    return;
  }

  size_t serialized_size = 0;
  SerializedMap serialized_resources;
  for (ResourceMap::const_iterator iter = resource_map_.begin();
      iter != resource_map_.end(); ++iter) {
    GDataEntryProto proto;
    iter->second->ToProtoFull(&proto);
    std::string serialized_string;
    const bool ok = proto.SerializeToString(&serialized_string);
    DCHECK(ok);
    if (ok) {
      serialized_resources.insert(
          std::make_pair(std::string(kDBKeyResourceIdPrefix) + iter->first,
                         serialized_string));
      serialized_size += serialized_string.size();
    }
  }

  serialized_resources.insert(std::make_pair(kDBKeyVersion,
      base::IntToString(kProtoVersion)));
  serialized_resources.insert(std::make_pair(kDBKeyLargestChangestamp,
      base::IntToString(largest_changestamp_)));
  set_last_serialized(base::Time::Now());
  set_serialized_size(serialized_size);

  blocking_task_runner_->PostTask(
      FROM_HERE,
      base::Bind(&ResourceMetadataDB::Save,
                 base::Unretained(directory_service_db_.get()),
                 serialized_resources));
}

void GDataFileSystem::OnRequestDirectoryRefresh(
    GetDocumentsParams* params,
    GDataFileError error) {
  DCHECK(params);
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  const FilePath& directory_path = params->search_file_path;
  if (error != GDATA_FILE_OK) {
    LOG(ERROR) << "Failed to refresh directory: " << directory_path.value()
               << ": " << error;
    return;
  }

  int64 unused_delta_feed_changestamp = 0;
  FeedToFileResourceMapUmaStats unused_uma_stats;
  FileResourceIdMap file_map;
  GDataWapiFeedProcessor feed_processor(directory_service_.get());
  error = feed_processor.FeedToFileResourceMap(
      *params->feed_list,
      &file_map,
      &unused_delta_feed_changestamp,
      &unused_uma_stats);
  if (error != GDATA_FILE_OK) {
    LOG(ERROR) << "Failed to convert feed: " << directory_path.value()
               << ": " << error;
    return;
  }

  directory_service_->GetEntryByResourceIdAsync(params->directory_resource_id,
      base::Bind(&GDataFileSystem::RequestDirectoryRefreshByEntry,
                 ui_weak_ptr_,
                 directory_path,
                 params->directory_resource_id,
                 file_map));
}

void GDataFileSystem::OnOpenFileFinished(const FilePath& file_path,
                                         const OpenFileCallback& callback,
                                         GDataFileError result,
                                         const FilePath& cache_file_path) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  if (result != GDATA_FILE_OK)
    open_files_.erase(file_path);

  if (!callback.is_null())
    callback.Run(result, cache_file_path);
}

  CreateDBParams(const FilePath& db_path,
                 base::SequencedTaskRunner* blocking_task_runner)
                 : db_path(db_path),
                   blocking_task_runner(blocking_task_runner) {
  }

void GDataFileSystem::OnMoveEntryToDirectoryWithFileOperationCallback(
    const FileOperationCallback& callback,
    GDataFileError error,
    const FilePath& moved_file_path) {
  DCHECK(!callback.is_null());

  if (error == GDATA_FILE_OK)
    OnDirectoryChanged(moved_file_path.DirName());

  callback.Run(error);
}

void GDataFileSystem::CopyDocumentToDirectory(
    const FilePath& dir_path,
    const std::string& resource_id,
    const FilePath::StringType& new_name,
    const FileOperationCallback& callback) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  DCHECK(!callback.is_null());

  documents_service_->CopyDocument(resource_id, new_name,
      base::Bind(&GDataFileSystem::OnCopyDocumentCompleted,
                 ui_weak_ptr_,
                 dir_path,
                 callback));
}

static void CreateResourceMetadataDBOnBlockingPool(
    CreateDBParams* params) {
  DCHECK(params->blocking_task_runner->RunsTasksOnCurrentThread());
  DCHECK(!params->db_path.empty());

  params->db.reset(new ResourceMetadataDB(params->db_path,
                                               params->blocking_task_runner));
  params->db->Init();
  params->db->Read(&params->serialized_resources);
}

GDataEntry::GDataEntry(GDataDirectory* parent,
                       GDataDirectoryService* directory_service)
    : directory_service_(directory_service),
deleted_(false) {
  SetParent(parent);
}

GDataFileSystem::CreateDirectoryParams::~CreateDirectoryParams() {
}

void GDataFileSystem::CreateDirectory(
    const FilePath& directory_path,
    bool is_exclusive,
    bool is_recursive,
    const FileOperationCallback& callback) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI) ||
         BrowserThread::CurrentlyOn(BrowserThread::IO));
  RunTaskOnUIThread(base::Bind(&GDataFileSystem::CreateDirectoryOnUIThread,
                               ui_weak_ptr_,
                               directory_path,
                               is_exclusive,
                               is_recursive,
                               CreateRelayCallback(callback)));
}

void GDataFileSystem::Initialize() {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  documents_service_->Initialize(profile_);

  directory_service_.reset(new GDataDirectoryService);
  feed_loader_.reset(new GDataWapiFeedLoader(directory_service_.get(),
                                             documents_service_,
                                             webapps_registry_,
                                             cache_,
                                             blocking_task_runner_));
  feed_loader_->AddObserver(this);

  PrefService* pref_service = profile_->GetPrefs();
  hide_hosted_docs_ = pref_service->GetBoolean(prefs::kDisableGDataHostedFiles);

  InitializePreferenceObserver();
}

void GDataFileSystem::SetHideHostedDocuments(bool hide) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  if (hide == hide_hosted_docs_)
    return;

  hide_hosted_docs_ = hide;
  const FilePath root_path = directory_service_->root()->GetFilePath();

  FOR_EACH_OBSERVER(GDataFileSystemInterface::Observer, observers_,
                    OnDirectoryChanged(root_path));
}

void GDataFileSystem::CheckLocalModificationAndRun(
    scoped_ptr<GDataEntryProto> entry_proto,
    const GetEntryInfoCallback& callback) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  DCHECK(entry_proto.get());

  if (!entry_proto->has_file_specific_info() ||
      entry_proto->file_specific_info().is_hosted_document()) {
    if (!callback.is_null())
      callback.Run(GDATA_FILE_OK, entry_proto.Pass());
    return;
  }

  const std::string resource_id = entry_proto->resource_id();
  const std::string md5 = entry_proto->file_specific_info().file_md5();
  cache_->GetCacheEntryOnUIThread(
      resource_id,
      md5,
      base::Bind(
          &GDataFileSystem::CheckLocalModificationAndRunAfterGetCacheEntry,
          ui_weak_ptr_, base::Passed(&entry_proto), callback));
}

void GDataFileSystem::OnReadDirectory(
    const ReadDirectoryWithSettingCallback& callback,
    GDataFileError error,
    GDataEntry* entry) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  if (error != GDATA_FILE_OK) {
    if (!callback.is_null())
      callback.Run(error,
                   hide_hosted_docs_,
                   scoped_ptr<GDataEntryProtoVector>());
    return;
  }
  DCHECK(entry);

  GDataDirectory* directory = entry->AsGDataDirectory();
  if (!directory) {
    if (!callback.is_null())
      callback.Run(GDATA_FILE_ERROR_NOT_FOUND,
                   hide_hosted_docs_,
                   scoped_ptr<GDataEntryProtoVector>());
    return;
  }

  scoped_ptr<GDataEntryProtoVector> entries(directory->ToProtoVector());

  if (!callback.is_null())
    callback.Run(GDATA_FILE_OK, hide_hosted_docs_, entries.Pass());
}

void GDataFileSystem::ReadDirectoryByPathAsyncOnUIThread(
    const FilePath& file_path,
    const ReadDirectoryWithSettingCallback& callback) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  FindEntryByPathAsyncOnUIThread(
      file_path,
      base::Bind(&GDataFileSystem::OnReadDirectory,
                 ui_weak_ptr_,
                 callback));
}

GDataDirectory* GDataDirectory::AsGDataDirectory() {
   return this;
 }

GDataEntry* GDataFile::FromDocumentEntry(
    GDataDirectory* parent,
    DocumentEntry* doc,
    GDataDirectoryService* directory_service) {
  DCHECK(doc->is_hosted_document() || doc->is_file());
  GDataFile* file = new GDataFile(parent, directory_service);
  // For regular files, the 'filename' and 'title' attribute in the metadata
  // may be different (e.g. due to rename). To be consistent with the web
  // interface and other client to use the 'title' attribute, instead of
  // 'filename', as the file name in the local snapshot.
  file->title_ = UTF16ToUTF8(doc->title());

// Check if this entry is a true file, or...
if (doc->is_file()) {
    file->file_info_.size = doc->file_size();
    file->file_md5_ = doc->file_md5();

// The resumable-edit-media link should only be present for regular
// files as hosted documents are not uploadable.
const Link* upload_link = doc->GetLinkByType(Link::RESUMABLE_EDIT_MEDIA);
if (upload_link)
      file->upload_url_ = upload_link->href();
} else {
// ... a hosted document.
// Attach .g<something> extension to hosted documents so we can special
// case their handling in UI.
// TODO(zelidrag): Figure out better way how to pass entry info like kind
// to UI through the File API stack.
    file->document_extension_ = doc->GetHostedDocumentExtension();
// We don't know the size of hosted docs and it does not matter since
// is has no effect on the quota.
    file->file_info_.size = 0;
}
  file->kind_ = doc->kind();
  const Link* edit_link = doc->GetLinkByType(Link::EDIT);
  if (edit_link)
    file->edit_url_ = edit_link->href();
  file->content_url_ = doc->content_url();
  file->content_mime_type_ = doc->content_mime_type();
  file->resource_id_ = doc->resource_id();
  file->is_hosted_document_ = doc->is_hosted_document();
  file->file_info_.last_modified = doc->updated_time();
  file->file_info_.last_accessed = doc->updated_time();
  file->file_info_.creation_time = doc->published_time();
  file->deleted_ = doc->deleted();
  const Link* parent_link = doc->GetLinkByType(Link::PARENT);
  if (parent_link)
    file->parent_resource_id_ = ExtractResourceId(parent_link->href());
// SetBaseNameFromTitle() must be called after |title_|,
// |is_hosted_document_| and |document_extension_| are set.
  file->SetBaseNameFromTitle();

const Link* thumbnail_link = doc->GetLinkByType(Link::THUMBNAIL);
if (thumbnail_link)
    file->thumbnail_url_ = thumbnail_link->href();

const Link* alternate_link = doc->GetLinkByType(Link::ALTERNATE);
if (alternate_link)
    file->alternate_url_ = alternate_link->href();
  return file;
}

GDataFileSystem::GetFileFromCacheParams::~GetFileFromCacheParams() {
}

scoped_ptr<GDataEntry> GDataDirectoryService::FromProtoString(
const std::string& serialized_proto) {
GDataEntryProto entry_proto;
if (!entry_proto.ParseFromString(serialized_proto))
return scoped_ptr<GDataEntry>();

scoped_ptr<GDataEntry> entry;
if (entry_proto.file_info().is_directory()) {
    entry.reset(new GDataDirectory(NULL, this));
// Call GDataEntry::FromProto instead of GDataDirectory::FromProto because
// the proto does not include children.
if (!entry->FromProto(entry_proto)) {
NOTREACHED() << "FromProto (directory) failed";
entry.reset();
}
} else {
    scoped_ptr<GDataFile> file(new GDataFile(NULL, this));
// Call GDataFile::FromProto.
if (file->FromProto(entry_proto)) {
entry.reset(file.release());
} else {
NOTREACHED() << "FromProto (file) failed";
}
}
return entry.Pass();
}

void GDataFileSystem::StartUpdates() {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  DCHECK(!update_timer_.IsRunning());
  update_timer_.Start(FROM_HERE,
                      base::TimeDelta::FromSeconds(
                          kGDataUpdateCheckIntervalInSec),
                      base::Bind(&GDataFileSystem::CheckForUpdates,
                          ui_weak_ptr_));
}

void GDataFileSystem::Copy(const FilePath& src_file_path,
                           const FilePath& dest_file_path,
                           const FileOperationCallback& callback) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI) ||
         BrowserThread::CurrentlyOn(BrowserThread::IO));
  DCHECK(!callback.is_null());

  RunTaskOnUIThread(base::Bind(&GDataFileSystem::CopyOnUIThread,
                               ui_weak_ptr_,
                               src_file_path,
                               dest_file_path,
                               CreateRelayCallback(callback)));
}

void GDataFileSystem::OnRemovedDocument(
    const FileOperationCallback& callback,
    const FilePath& file_path,
    GDataErrorCode status,
    const GURL& document_url) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  GDataFileError error = util::GDataToGDataFileError(status);

  if (error == GDATA_FILE_OK)
    error = RemoveEntryFromFileSystem(file_path);

  if (!callback.is_null()) {
    callback.Run(error);
  }
}

void GDataFileSystem::OnGetEntryInfo(const GetEntryInfoCallback& callback,
                                    GDataFileError error,
                                    GDataEntry* entry) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  if (error != GDATA_FILE_OK) {
    if (!callback.is_null())
      callback.Run(error, scoped_ptr<GDataEntryProto>());
    return;
  }
  DCHECK(entry);

  scoped_ptr<GDataEntryProto> entry_proto(new GDataEntryProto);
  entry->ToProtoFull(entry_proto.get());

  CheckLocalModificationAndRun(entry_proto.Pass(), callback);
}

void GDataFileSystem::GetEntryInfoByResourceId(
    const std::string& resource_id,
    const GetEntryInfoWithFilePathCallback& callback) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI) ||
         BrowserThread::CurrentlyOn(BrowserThread::IO));
  RunTaskOnUIThread(
      base::Bind(&GDataFileSystem::GetEntryInfoByResourceIdOnUIThread,
                 ui_weak_ptr_,
                 resource_id,
                 CreateRelayCallback(callback)));
}

void GDataFileSystem::FindEntryByPathSyncOnUIThread(
    const FilePath& search_file_path,
    const FindEntryCallback& callback) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  directory_service_->FindEntryByPathAndRunSync(search_file_path, callback);
}

void GDataDirectoryService::MoveEntryToDirectory(
    const FilePath& directory_path,
    GDataEntry* entry,
    const FileMoveCallback& callback) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  DCHECK(entry);

  if (entry->parent())
    entry->parent()->RemoveChild(entry);

  GDataEntry* destination = FindEntryByPathSync(directory_path);
  FilePath moved_file_path;
  GDataFileError error = GDATA_FILE_ERROR_FAILED;
  if (!destination) {
    error = GDATA_FILE_ERROR_NOT_FOUND;
  } else if (!destination->AsGDataDirectory()) {
    error = GDATA_FILE_ERROR_NOT_A_DIRECTORY;
  } else {
    destination->AsGDataDirectory()->AddEntry(entry);
    moved_file_path = entry->GetFilePath();
    error = GDATA_FILE_OK;
  }
  if (!callback.is_null()) {
    base::MessageLoopProxy::current()->PostTask(
        FROM_HERE, base::Bind(callback, error, moved_file_path));
  }
}

void GDataFileSystem::ReadDirectoryByPath(
    const FilePath& file_path,
    const ReadDirectoryWithSettingCallback& callback) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI) ||
         BrowserThread::CurrentlyOn(BrowserThread::IO));
  RunTaskOnUIThread(
      base::Bind(&GDataFileSystem::ReadDirectoryByPathAsyncOnUIThread,
                 ui_weak_ptr_,
                 file_path,
                 CreateRelayCallback(callback)));
}

void GDataFileSystem::GetEntryInfoByResourceIdOnUIThread(
    const std::string& resource_id,
    const GetEntryInfoWithFilePathCallback& callback) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  directory_service_->GetEntryByResourceIdAsync(resource_id,
      base::Bind(&GDataFileSystem::GetEntryInfoByEntryOnUIThread,
                 ui_weak_ptr_,
                 callback));
}

GDataFile::GDataFile(GDataDirectory* parent,
                     GDataDirectoryService* directory_service)
    : GDataEntry(parent, directory_service),
kind_(DocumentEntry::UNKNOWN),
is_hosted_document_(false) {
file_info_.is_directory = false;
}

void GDataEntry::SetBaseNameFromTitle() {
   base_name_ = EscapeUtf8FileName(title_);
 }

void GDataFileSystem::UpdateFileByResourceIdOnUIThread(
    const std::string& resource_id,
    const FileOperationCallback& callback) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  directory_service_->GetEntryByResourceIdAsync(resource_id,
      base::Bind(&GDataFileSystem::UpdateFileByEntryOnUIThread,
                 ui_weak_ptr_,
                 callback));
}

RemoveEntryFromDirectoryAndCollectChangedDirectories(
    GDataDirectory* directory,
    GDataEntry* entry,
    std::set<FilePath>* changed_dirs) {
  GetChildDirectoryPaths(entry, changed_dirs);
  directory->RemoveEntry(entry);
}

void AddEntryToSearchResults(
    std::vector<SearchResultInfo>* results,
    const SearchCallback& callback,
    const base::Closure& entry_skipped_callback,
    GDataFileError error,
    bool run_callback,
    const GURL& next_feed,
    GDataEntry* entry) {
  if (entry) {
    const bool is_directory = entry->AsGDataDirectory() != NULL;
    results->push_back(SearchResultInfo(entry->GetFilePath(), is_directory));
  } else {
    if (!entry_skipped_callback.is_null())
      entry_skipped_callback.Run();
  }

  if (run_callback) {
    scoped_ptr<std::vector<SearchResultInfo> > result_vec(results);
    if (!callback.is_null())
      callback.Run(error, next_feed, result_vec.Pass());
  }
}

void GDataFileSystem::Move(const FilePath& src_file_path,
                           const FilePath& dest_file_path,
                           const FileOperationCallback& callback) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI) ||
         BrowserThread::CurrentlyOn(BrowserThread::IO));
  DCHECK(!callback.is_null());

  RunTaskOnUIThread(base::Bind(&GDataFileSystem::MoveOnUIThread,
                               ui_weak_ptr_,
                               src_file_path,
                               dest_file_path,
                               CreateRelayCallback(callback)));
}

void GDataFileSystem::GetFileByPathOnUIThread(
    const FilePath& file_path,
    const GetFileCallback& get_file_callback,
    const GetDownloadDataCallback& get_download_data_callback) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  directory_service_->GetEntryInfoByPath(
      file_path,
      base::Bind(&GDataFileSystem::OnGetEntryInfoCompleteForGetFileByPath,
                 ui_weak_ptr_,
                 file_path,
                 CreateRelayCallback(get_file_callback),
                 CreateRelayCallback(get_download_data_callback)));
}

void RunGetEntryInfoWithFilePathCallback(
    const GetEntryInfoWithFilePathCallback& callback,
    const FilePath& path,
    GDataFileError error,
    scoped_ptr<GDataEntryProto> entry_proto) {
  if (!callback.is_null())
    callback.Run(error, path, entry_proto.Pass());
}

  static void Run(scoped_refptr<base::MessageLoopProxy> relay_proxy,
                  const base::Callback<void(T1, T2)>& callback,
                  T1 arg1,
                  T2 arg2) {
    if (callback.is_null())
      return;
    RunTaskOnThread(relay_proxy, base::Bind(callback, arg1, arg2));
  }

GDataFile* AddFile(GDataDirectory* parent,
GDataDirectoryService* directory_service,
int sequence_id) {
  GDataFile* file = new GDataFile(NULL, directory_service);
const std::string title = "file" + base::IntToString(sequence_id);
const std::string resource_id = std::string("file_resource_id:") +
title;
file->set_title(title);
file->set_resource_id(resource_id);
file->set_file_md5(std::string("file_md5:") + title);
GDataFileError error = GDATA_FILE_ERROR_FAILED;
FilePath moved_file_path;
directory_service->MoveEntryToDirectory(
parent->GetFilePath(),
file,
base::Bind(&test_util::CopyResultsFromFileMoveCallback,
&error,
&moved_file_path));
test_util::RunBlockingPoolTask();
EXPECT_EQ(GDATA_FILE_OK, error);
EXPECT_EQ(parent->GetFilePath().AppendASCII(title), moved_file_path);
return file;
}

void RunTaskOnUIThread(const base::Closure& task) {
  RunTaskOnThread(
      BrowserThread::GetMessageLoopProxyForThread(BrowserThread::UI), task);
}

void GDataDirectoryService::GetEntryByResourceIdAsync(
    const std::string& resource_id,
    const GetEntryByResourceIdCallback& callback) {
  GDataEntry* entry = GetEntryByResourceId(resource_id);
  callback.Run(entry);
}

void GDataDirectoryService::GetEntryInfoPairByPathsAfterGetFirst(
    const FilePath& first_path,
    const FilePath& second_path,
    const GetEntryInfoPairCallback& callback,
    GDataFileError error,
    scoped_ptr<GDataEntryProto> entry_proto) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  DCHECK(!callback.is_null());

  scoped_ptr<EntryInfoPairResult> result(new EntryInfoPairResult);
  result->first.path = first_path;
  result->first.error = error;
  result->first.proto = entry_proto.Pass();

  if (error != GDATA_FILE_OK) {
    callback.Run(result.Pass());
    return;
  }

  GetEntryInfoByPath(
      second_path,
      base::Bind(&GDataDirectoryService::GetEntryInfoPairByPathsAfterGetSecond,
                 weak_ptr_factory_.GetWeakPtr(),
                 second_path,
                 callback,
                 base::Passed(&result)));
}

void GDataDirectory::RemoveChild(GDataEntry* entry) {
  DCHECK(entry);

  const std::string& base_name(entry->base_name());
  DCHECK_EQ(entry, FindChild(base_name));
  if (directory_service_)
    directory_service_->RemoveEntryFromResourceMap(entry);

  child_files_.erase(base_name);
  child_directories_.erase(base_name);
}

void GDataDirectoryService::InitializeRootEntry(const std::string& root_id) {
  root_.reset(new GDataDirectory(NULL, this));
root_->set_title(kGDataRootDirectory);
root_->SetBaseNameFromTitle();
root_->set_resource_id(root_id);
AddEntryToResourceMap(root_.get());
}

void GDataFileSystem::OnCopyDocumentCompleted(
const FilePath& dir_path,
const FileOperationCallback& callback,
GDataErrorCode status,
scoped_ptr<base::Value> data) {
DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
DCHECK(!callback.is_null());

GDataFileError error = util::GDataToGDataFileError(status);
if (error != GDATA_FILE_OK) {
callback.Run(error);
return;
}

scoped_ptr<DocumentEntry> doc_entry(DocumentEntry::ExtractAndParse(*data));
if (!doc_entry.get()) {
callback.Run(GDATA_FILE_ERROR_FAILED);
return;
}

  GDataEntry* entry = GDataEntry::FromDocumentEntry(
      NULL, doc_entry.get(), directory_service_.get());
if (!entry) {
callback.Run(GDATA_FILE_ERROR_FAILED);
return;
}

// |entry| was added in the root directory on the server, so we should
// first add it to |root_| to mirror the state and then move it to the
// destination directory by MoveEntryFromRootDirectory().
directory_service_->root()->AddEntry(entry);
MoveEntryFromRootDirectory(dir_path,
callback,
GDATA_FILE_OK,
entry->GetFilePath());
}

GDataFileError GDataFileSystem::RemoveEntryFromFileSystem(
    const FilePath& file_path) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  std::string resource_id;
  GDataFileError error = RemoveEntryFromGData(file_path, &resource_id);
  if (error != GDATA_FILE_OK)
    return error;

  if (!resource_id.empty())
    cache_->RemoveOnUIThread(resource_id, CacheOperationCallback());

  return GDATA_FILE_OK;
}

void GDataDirectory::RemoveChildren() {
  RemoveChildFiles();
  RemoveChildDirectories();
}

bool GDataFile::FromProto(const GDataEntryProto& proto) {
  DCHECK(!proto.file_info().is_directory());

  if (!GDataEntry::FromProto(proto))
    return false;

  thumbnail_url_ = GURL(proto.file_specific_info().thumbnail_url());
  alternate_url_ = GURL(proto.file_specific_info().alternate_url());
  content_mime_type_ = proto.file_specific_info().content_mime_type();
  file_md5_ = proto.file_specific_info().file_md5();
  document_extension_ = proto.file_specific_info().document_extension();
  is_hosted_document_ = proto.file_specific_info().is_hosted_document();

  return true;
}

void GDataFileSystem::OnFeedFromServerLoaded() {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  FOR_EACH_OBSERVER(GDataFileSystemInterface::Observer, observers_,
                    OnFeedFromServerLoaded());
}

FeedToFileResourceMapUmaStats::FeedToFileResourceMapUmaStats()
    : num_regular_files(0),
      num_hosted_documents(0) {
}

void GDataFileSystem::RequestDirectoryRefreshOnUIThreadAfterGetEntryInfo(
    const FilePath& file_path,
    GDataFileError error,
    scoped_ptr<GDataEntryProto> entry_proto) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  if (error != GDATA_FILE_OK ||
      !entry_proto->file_info().is_directory()) {
    LOG(ERROR) << "Directory entry not found: " << file_path.value();
    return;
  }

  feed_loader_->LoadFromServer(
      directory_service_->origin(),
      0,  // Not delta feed.
      0,  // Not used.
      true,  // multiple feeds
      file_path,
      std::string(),  // No search query
      GURL(), /* feed not explicitly set */
      entry_proto->resource_id(),
      FindEntryCallback(),  // Not used.
      base::Bind(&GDataFileSystem::OnRequestDirectoryRefresh,
                 ui_weak_ptr_));
}

void GDataFileSystem::OnGetCacheFilePathCompleteForCloseFile(
    const FilePath& file_path,
    const FileOperationCallback& callback,
    GDataFileError error,
    const std::string& resource_id,
    const std::string& md5,
    const FilePath& local_cache_path) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  if (error != GDATA_FILE_OK) {
    if (!callback.is_null())
      callback.Run(error);
    return;
  }

  base::PlatformFileInfo* file_info = new base::PlatformFileInfo;
  bool* get_file_info_result = new bool(false);
  util::PostBlockingPoolSequencedTaskAndReply(
      FROM_HERE,
      blocking_task_runner_,
      base::Bind(&GetFileInfoOnBlockingPool,
                 local_cache_path,
                 base::Unretained(file_info),
                 base::Unretained(get_file_info_result)),
      base::Bind(&GDataFileSystem::OnGetModifiedFileInfoCompleteForCloseFile,
                 ui_weak_ptr_,
                 file_path,
                 base::Owned(file_info),
                 base::Owned(get_file_info_result),
                 callback));
}

void GDataFileSystem::OnDirectoryChanged(const FilePath& directory_path) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  FOR_EACH_OBSERVER(GDataFileSystemInterface::Observer, observers_,
                    OnDirectoryChanged(directory_path));
}

void GetFileInfoOnBlockingPool(const FilePath& path,
                               base::PlatformFileInfo* file_info,
                               bool* result) {
  *result = file_util::GetFileInfo(path, file_info);
}

void GDataDirectory::ToProto(GDataDirectoryProto* proto) const {
  GDataEntry::ToProto(proto->mutable_gdata_entry());
  DCHECK(proto->gdata_entry().file_info().is_directory());

  for (GDataFileCollection::const_iterator iter = child_files_.begin();
       iter != child_files_.end(); ++iter) {
    GDataFile* file = iter->second;
    file->ToProto(proto->add_child_files());
  }
  for (GDataDirectoryCollection::const_iterator iter =
       child_directories_.begin();
       iter != child_directories_.end(); ++iter) {
    GDataDirectory* dir = iter->second;
    dir->ToProto(proto->add_child_directories());
  }
}

GDataFile* FindFile(GDataDirectoryService* directory_service,
                    const char* path) {
  return directory_service->FindEntryByPathSync(FilePath(path))->AsGDataFile();
}

void GDataDirectoryService::AddEntryToResourceMap(GDataEntry* entry) {
  DVLOG(1) << "AddEntryToResourceMap " << entry->resource_id();
  resource_map_.insert(std::make_pair(entry->resource_id(), entry));
}

EntryInfoResult::~EntryInfoResult() {
}

GDataFileError GDataWapiFeedProcessor::ApplyFeeds(
    const std::vector<DocumentFeed*>& feed_list,
    int64 start_changestamp,
    int64 root_feed_changestamp,
    std::set<FilePath>* changed_dirs) {
  bool is_delta_feed = start_changestamp != 0;

  directory_service_->set_origin(FROM_SERVER);

  int64 delta_feed_changestamp = 0;
  FeedToFileResourceMapUmaStats uma_stats;
  FileResourceIdMap file_map;
  GDataFileError error = FeedToFileResourceMap(feed_list,
                                               &file_map,
                                               &delta_feed_changestamp,
                                               &uma_stats);
  if (error != GDATA_FILE_OK)
    return error;

  ApplyFeedFromFileUrlMap(
      is_delta_feed,
      is_delta_feed ? delta_feed_changestamp : root_feed_changestamp,
      &file_map,
      changed_dirs);

  if (!is_delta_feed)
    UpdateFileCountUmaHistograms(uma_stats);

  return GDATA_FILE_OK;
}

void GDataDirectory::RemoveChildFiles() {
  for (GDataFileCollection::const_iterator iter = child_files_.begin();
       iter != child_files_.end(); ++iter) {
    if (directory_service_)
      directory_service_->RemoveEntryFromResourceMap(iter->second);
  }
  STLDeleteValues(&child_files_);
  child_files_.clear();
}

bool GDataEntry::FromProto(const GDataEntryProto& proto) {
  ConvertProtoToPlatformFileInfo(proto.file_info(), &file_info_);

  title_ = proto.title();
  resource_id_ = proto.resource_id();
  parent_resource_id_ = proto.parent_resource_id();
  edit_url_ = GURL(proto.edit_url());
  content_url_ = GURL(proto.content_url());
  upload_url_ = GURL(proto.upload_url());
  SetBaseNameFromTitle();

  if (!proto.has_upload_url()) {
    LOG(ERROR) << "Incompatible proto detected (no upload URL): "
               << proto.title();
    return false;
  }

  return true;
}

void GDataFileSystem::OnGetEntryInfoCompleteForGetFileByPath(
    const FilePath& file_path,
    const GetFileCallback& get_file_callback,
    const GetDownloadDataCallback& get_download_data_callback,
    GDataFileError error,
    scoped_ptr<GDataEntryProto> entry_proto) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  DCHECK(error != GDATA_FILE_OK ||
         (entry_proto.get() && !entry_proto->resource_id().empty()));
  GetResolvedFileByPath(file_path,
                        get_file_callback,
                        get_download_data_callback,
                        error,
                        entry_proto.get());
}

void ResourceMetadataDB::Read(
  GDataDirectoryService::SerializedMap* serialized_resources) {
  DCHECK(blocking_task_runner_->RunsTasksOnCurrentThread());
  DCHECK(serialized_resources);
  DVLOG(1) << "Read " << db_path_.value();

  scoped_ptr<leveldb::Iterator> iter(level_db_->NewIterator(
        leveldb::ReadOptions()));
  for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {
    DVLOG(1) << "Read, resource " << iter->key().ToString();
    serialized_resources->insert(std::make_pair(iter->key().ToString(),
                                                iter->value().ToString()));
  }
}

void GDataFileSystem::CheckLocalModificationAndRunAfterGetCacheFile(
    scoped_ptr<GDataEntryProto> entry_proto,
    const GetEntryInfoCallback& callback,
    GDataFileError error,
    const std::string& resource_id,
    const std::string& md5,
    const FilePath& local_cache_path) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  if (error != GDATA_FILE_OK) {
    if (!callback.is_null())
      callback.Run(GDATA_FILE_OK, entry_proto.Pass());
    return;
  }

  base::PlatformFileInfo* file_info = new base::PlatformFileInfo;
  bool* get_file_info_result = new bool(false);
  util::PostBlockingPoolSequencedTaskAndReply(
      FROM_HERE,
      blocking_task_runner_,
      base::Bind(&GetFileInfoOnBlockingPool,
                 local_cache_path,
                 base::Unretained(file_info),
                 base::Unretained(get_file_info_result)),
      base::Bind(&GDataFileSystem::CheckLocalModificationAndRunAfterGetFileInfo,
                 ui_weak_ptr_,
                 base::Passed(&entry_proto),
                 callback,
                 base::Owned(file_info),
                 base::Owned(get_file_info_result)));
}

GDataDirectory* GDataEntry::AsGDataDirectory() {
   return NULL;
 }

void GDataDirectory::RemoveEntry(GDataEntry* entry) {
  DCHECK(entry);

  RemoveChild(entry);
  delete entry;
}

void GDataFileSystem::TransferFileFromRemoteToLocal(
    const FilePath& remote_src_file_path,
    const FilePath& local_dest_file_path,
    const FileOperationCallback& callback) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  DCHECK(!callback.is_null());

  GetFileByPath(remote_src_file_path,
      base::Bind(&GDataFileSystem::OnGetFileCompleteForTransferFile,
                 ui_weak_ptr_,
                 local_dest_file_path,
                 callback),
      GetDownloadDataCallback());
}

  static void Run(scoped_refptr<base::MessageLoopProxy> relay_proxy,
                  const base::Callback<void(T1, scoped_ptr<T2>)>& callback,
                  T1 arg1,
                  scoped_ptr<T2> arg2) {
    if (callback.is_null())
      return;
    RunTaskOnThread(relay_proxy,
                    base::Bind(callback, arg1, base::Passed(&arg2)));
  }

void GDataFileSystem::CopyOnUIThread(const FilePath& src_file_path,
                                     const FilePath& dest_file_path,
                                     const FileOperationCallback& callback) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  DCHECK(!callback.is_null());

  directory_service_->GetEntryInfoPairByPaths(
      src_file_path,
      dest_file_path.DirName(),
      base::Bind(&GDataFileSystem::CopyOnUIThreadAfterGetEntryInfoPair,
                 ui_weak_ptr_,
                 dest_file_path,
                 callback));
}

void GDataFileSystem::CloseFileOnUIThread(
    const FilePath& file_path,
    const FileOperationCallback& callback) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  if (open_files_.find(file_path) == open_files_.end()) {
    MessageLoop::current()->PostTask(
        FROM_HERE,
        base::Bind(callback, GDATA_FILE_ERROR_NOT_FOUND));
    return;
  }

  GetEntryInfoByPathAsyncOnUIThread(
      file_path,
      base::Bind(&GDataFileSystem::OnGetEntryInfoCompleteForCloseFile,
                 ui_weak_ptr_,
                 file_path,
                 base::Bind(&GDataFileSystem::OnCloseFileFinished,
                            ui_weak_ptr_,
                            file_path,
                            callback)));
}

void GDataFileSystem::Search(const std::string& search_query,
                             const GURL& next_feed,
                             const SearchCallback& callback) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI) ||
         BrowserThread::CurrentlyOn(BrowserThread::IO));
  RunTaskOnUIThread(base::Bind(&GDataFileSystem::SearchAsyncOnUIThread,
                               ui_weak_ptr_,
                               search_query,
                               next_feed,
                               CreateRelayCallback(callback)));
}

void GDataDirectoryService::InitResourceMap(
    CreateDBParams* create_params,
    const FileOperationCallback& callback) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  DCHECK(create_params);
  DCHECK(!directory_service_db_.get());

  SerializedMap* serialized_resources = &create_params->serialized_resources;
  directory_service_db_ = create_params->db.Pass();
  if (serialized_resources->empty()) {
    origin_ = INITIALIZING;
    if (!callback.is_null())
      callback.Run(GDATA_FILE_ERROR_NOT_FOUND);
    return;
  }

  ClearRoot();

  int32 version = 0;
  SerializedMap::iterator iter = serialized_resources->find(kDBKeyVersion);
  if (iter == serialized_resources->end() ||
      !base::StringToInt(iter->second, &version) ||
      version != kProtoVersion) {
    if (!callback.is_null())
      callback.Run(GDATA_FILE_ERROR_FAILED);
    return;
  }
  serialized_resources->erase(iter);

  iter = serialized_resources->find(kDBKeyLargestChangestamp);
  if (iter == serialized_resources->end() ||
      !base::StringToInt64(iter->second, &largest_changestamp_)) {
    NOTREACHED() << "Could not find/parse largest_changestamp";
    if (!callback.is_null())
      callback.Run(GDATA_FILE_ERROR_FAILED);
    return;
  } else {
    DVLOG(1) << "InitResourceMap largest_changestamp_" << largest_changestamp_;
    serialized_resources->erase(iter);
  }

  ResourceMap resource_map;
  for (SerializedMap::const_iterator iter = serialized_resources->begin();
      iter != serialized_resources->end(); ++iter) {
    if (iter->first.find(kDBKeyResourceIdPrefix) != 0) {
      NOTREACHED() << "Incorrect prefix for db key " << iter->first;
      continue;
    }

    const std::string resource_id =
        iter->first.substr(strlen(kDBKeyResourceIdPrefix));
    scoped_ptr<GDataEntry> entry = FromProtoString(iter->second);
    if (entry.get()) {
      DVLOG(1) << "Inserting resource " << resource_id
               << " into resource_map";
      resource_map.insert(std::make_pair(resource_id, entry.release()));
    } else {
      NOTREACHED() << "Failed to parse GDataEntry for resource " << resource_id;
    }
  }

  for (ResourceMap::iterator iter = resource_map.begin();
      iter != resource_map.end(); ++iter) {
    GDataEntry* entry = iter->second;
    ResourceMap::iterator parent_it =
        resource_map.find(entry->parent_resource_id());
    if (parent_it != resource_map.end()) {
      GDataDirectory* parent = parent_it->second->AsGDataDirectory();
      if (parent) {
        DVLOG(1) << "Adding " << entry->resource_id()
                 << " as a child of " << parent->resource_id();
        parent->AddEntry(entry);
      } else {
        NOTREACHED() << "Parent is not a directory " << parent->resource_id();
      }
    } else if (entry->resource_id() == kGDataRootDirectoryResourceId) {
      root_.reset(entry->AsGDataDirectory());
      DCHECK(root_.get());
      AddEntryToResourceMap(root_.get());
    } else {
      NOTREACHED() << "Missing parent id " << entry->parent_resource_id()
                   << " for resource " << entry->resource_id();
    }
  }

  DCHECK(root_.get());
  DCHECK_EQ(resource_map.size(), resource_map_.size());
  DCHECK_EQ(resource_map.size(), serialized_resources->size());

  origin_ = FROM_CACHE;

  if (!callback.is_null())
    callback.Run(GDATA_FILE_OK);
}
