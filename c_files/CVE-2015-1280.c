void ServiceManagerConnectionImpl::RemoveConnectionFilter(int filter_id) {
  context_->RemoveConnectionFilter(filter_id);
}

std::unique_ptr<service_manager::Service> CreateMediaService() {
   return std::unique_ptr<service_manager::Service>(
       new ::media::MediaService(base::MakeUnique<CdmMojoMediaClient>()));
 }

ServiceManagerConnectionImpl::~ServiceManagerConnectionImpl() {
  context_->ShutDown();
}

void ServiceManagerConnectionImpl::AddServiceRequestHandler(
    const std::string& name,
    const ServiceRequestHandler& handler) {
  context_->AddServiceRequestHandler(name, handler);
}

void StartServiceInUtilityProcess(
    const std::string& service_name,
    const base::string16& process_name,
    SandboxType sandbox_type,
    service_manager::mojom::ServiceRequest request) {
  DCHECK_CURRENTLY_ON(BrowserThread::IO);
  UtilityProcessHost* process_host =
      UtilityProcessHost::Create(nullptr, nullptr);
  process_host->SetName(process_name);
  process_host->SetSandboxType(sandbox_type);
  process_host->Start();

  service_manager::mojom::ServiceFactoryPtr service_factory;
  BindInterface(process_host, mojo::MakeRequest(&service_factory));
  service_factory->CreateService(std::move(request), service_name);
}

void ServiceManagerConnectionImpl::Start() {
  context_->Start(
      base::Bind(&ServiceManagerConnectionImpl::OnConnectionLost,
                 weak_factory_.GetWeakPtr()));
}

void MediaInterfaceProxy::CreateRenderer(
    const std::string& audio_device_id,
    media::mojom::RendererRequest request) {
  DCHECK(thread_checker_.CalledOnValidThread());
  GetMediaInterfaceFactory()->CreateRenderer(audio_device_id,
                                             std::move(request));
}

UtilityServiceFactory::CreateNetworkService() {
  return base::MakeUnique<NetworkServiceImpl>(std::move(network_registry_));
}

  void Start(
      service_manager::mojom::ServicePtrInfo packaged_services_service_info,
      std::unique_ptr<BuiltinManifestProvider> manifest_provider) {
    BrowserThread::GetTaskRunnerForThread(BrowserThread::IO)
        ->PostTask(FROM_HERE,
                   base::Bind(&InProcessServiceManagerContext::StartOnIOThread,
                              this, base::Passed(&manifest_provider),
                              base::Passed(&packaged_services_service_info)));
  }

  InProcessServiceManagerContext() {}

    explicit MessageLoopObserver(base::WeakPtr<IOThreadContext> context)
        : context_(context) {
      base::MessageLoop::current()->AddDestructionObserver(this);
    }

  void AddEmbeddedServiceRequestHandlerOnIoThread(
      const std::string& name,
      const service_manager::EmbeddedServiceInfo& info) {
    DCHECK(io_thread_checker_.CalledOnValidThread());
    std::unique_ptr<service_manager::EmbeddedServiceRunner> service(
        new service_manager::EmbeddedServiceRunner(name, info));
    AddServiceRequestHandlerOnIoThread(
        name,
        base::Bind(&service_manager::EmbeddedServiceRunner::BindServiceRequest,
                   base::Unretained(service.get())));
    auto result =
        embedded_services_.insert(std::make_pair(name, std::move(service)));
    DCHECK(result.second);
  }

MediaInterfaceProxy::~MediaInterfaceProxy() {
  DVLOG(1) << __FUNCTION__;
  DCHECK(thread_checker_.CalledOnValidThread());
}

  int AddConnectionFilter(std::unique_ptr<ConnectionFilter> filter) {
    base::AutoLock lock(lock_);

    int id = ++next_filter_id_;

    CHECK_NE(id, kInvalidConnectionFilterId);

    connection_filters_[id] = std::move(filter);
    return id;
  }

  void AddServiceRequestHandler(const std::string& name,
                                const ServiceRequestHandler& handler) {
    io_task_runner_->PostTask(
        FROM_HERE, base::Bind(&ServiceManagerConnectionImpl::IOThreadContext::
                                  AddServiceRequestHandlerOnIoThread,
                              this, name, handler));
  }

void ServiceManagerConnection::SetForProcess(
    std::unique_ptr<ServiceManagerConnection> connection) {
  DCHECK(!g_connection_for_process.Get());
  g_connection_for_process.Get() = std::move(connection);
}

  void ShutDownOnIOThread() {
    DCHECK(io_thread_checker_.CalledOnValidThread());

    weak_factory_.InvalidateWeakPtrs();

    if (message_loop_observer_) {
      message_loop_observer_->ShutDown();
      message_loop_observer_ = nullptr;
    }

    scoped_refptr<IOThreadContext> keepalive(this);

    factory_bindings_.CloseAllBindings();
    service_context_.reset();

    ClearConnectionFiltersOnIOThread();

    request_handlers_.clear();
    embedded_services_.clear();
    child_binding_.Close();
  }

void UtilityServiceFactory::OnServiceQuit() {
  UtilityThread::Get()->ReleaseProcess();
}

ServiceManagerContext::ServiceManagerContext() {
service_manager::mojom::ServiceRequest packaged_services_request;
if (service_manager::ServiceManagerIsRemote()) {
auto invitation =
mojo::edk::IncomingBrokerClientInvitation::AcceptFromCommandLine(
mojo::edk::TransportProtocol::kLegacy);
packaged_services_request =
service_manager::GetServiceRequestFromCommandLine(invitation.get());
} else {
std::unique_ptr<BuiltinManifestProvider> manifest_provider =
base::MakeUnique<BuiltinManifestProvider>();

static const struct ManifestInfo {
const char* name;
int resource_id;
} kManifests[] = {
{mojom::kBrowserServiceName, IDR_MOJO_CONTENT_BROWSER_MANIFEST},
{mojom::kGpuServiceName, IDR_MOJO_CONTENT_GPU_MANIFEST},
{mojom::kPackagedServicesServiceName,
IDR_MOJO_CONTENT_PACKAGED_SERVICES_MANIFEST},
{mojom::kPluginServiceName, IDR_MOJO_CONTENT_PLUGIN_MANIFEST},
{mojom::kRendererServiceName, IDR_MOJO_CONTENT_RENDERER_MANIFEST},
{mojom::kUtilityServiceName, IDR_MOJO_CONTENT_UTILITY_MANIFEST},
{catalog::mojom::kServiceName, IDR_MOJO_CATALOG_MANIFEST},
};

for (size_t i = 0; i < arraysize(kManifests); ++i) {
manifest_provider->AddServiceManifest(kManifests[i].name,
kManifests[i].resource_id);
}
for (const auto& manifest :
GetContentClient()->browser()->GetExtraServiceManifests()) {
manifest_provider->AddServiceManifest(manifest.name,
manifest.resource_id);
}
in_process_context_ = new InProcessServiceManagerContext;

service_manager::mojom::ServicePtr packaged_services_service;
packaged_services_request = mojo::MakeRequest(&packaged_services_service);
in_process_context_->Start(packaged_services_service.PassInterface(),
std::move(manifest_provider));
}

packaged_services_connection_ = ServiceManagerConnection::Create(
std::move(packaged_services_request),
BrowserThread::GetTaskRunnerForThread(BrowserThread::IO));

service_manager::mojom::ServicePtr root_browser_service;
ServiceManagerConnection::SetForProcess(ServiceManagerConnection::Create(
mojo::MakeRequest(&root_browser_service),
BrowserThread::GetTaskRunnerForThread(BrowserThread::IO)));
auto* browser_connection = ServiceManagerConnection::GetForProcess();

service_manager::mojom::PIDReceiverPtr pid_receiver;
packaged_services_connection_->GetConnector()->StartService(
service_manager::Identity(mojom::kBrowserServiceName,
service_manager::mojom::kRootUserID),
std::move(root_browser_service), mojo::MakeRequest(&pid_receiver));
pid_receiver->SetPID(base::GetCurrentProcId());

service_manager::EmbeddedServiceInfo device_info;
#if defined(OS_ANDROID)
JNIEnv* env = base::android::AttachCurrentThread();
base::android::ScopedJavaGlobalRef<jobject> java_nfc_delegate;
java_nfc_delegate.Reset(Java_ContentNfcDelegate_create(env));
DCHECK(!java_nfc_delegate.is_null());

// See the comments on wake_lock_context_host.h and ContentNfcDelegate.java
// respectively for comments on those parameters.
device_info.factory =
base::Bind(&device::CreateDeviceService,
BrowserThread::GetTaskRunnerForThread(BrowserThread::FILE),
BrowserThread::GetTaskRunnerForThread(BrowserThread::IO),
base::Bind(&WakeLockContextHost::GetNativeViewForContext),
std::move(java_nfc_delegate));
#else
device_info.factory =
base::Bind(&device::CreateDeviceService,
BrowserThread::GetTaskRunnerForThread(BrowserThread::FILE),
BrowserThread::GetTaskRunnerForThread(BrowserThread::IO));
#endif
device_info.task_runner = base::ThreadTaskRunnerHandle::Get();
packaged_services_connection_->AddEmbeddedService(device::mojom::kServiceName,
device_info);

if (base::FeatureList::IsEnabled(features::kGlobalResourceCoordinator)) {
service_manager::EmbeddedServiceInfo resource_coordinator_info;
resource_coordinator_info.factory =
base::Bind(&resource_coordinator::ResourceCoordinatorService::Create);
packaged_services_connection_->AddEmbeddedService(
resource_coordinator::mojom::kServiceName, resource_coordinator_info);
}

ContentBrowserClient::StaticServiceMap services;
GetContentClient()->browser()->RegisterInProcessServices(&services);
for (const auto& entry : services) {
packaged_services_connection_->AddEmbeddedService(entry.first,
entry.second);
}

// This is safe to assign directly from any thread, because
// ServiceManagerContext must be constructed before anyone can call
// GetConnectorForIOThread().
g_io_thread_connector.Get() = browser_connection->GetConnector()->Clone();

ContentBrowserClient::OutOfProcessServiceMap out_of_process_services;
GetContentClient()->browser()->RegisterOutOfProcessServices(
&out_of_process_services);

out_of_process_services[data_decoder::mojom::kServiceName] = {
base::ASCIIToUTF16("Data Decoder Service"), SANDBOX_TYPE_UTILITY};

bool network_service_enabled =
base::FeatureList::IsEnabled(features::kNetworkService);
if (network_service_enabled) {
out_of_process_services[content::mojom::kNetworkServiceName] = {
base::ASCIIToUTF16("Network Service"), SANDBOX_TYPE_NETWORK};
}

if (base::FeatureList::IsEnabled(video_capture::kMojoVideoCapture)) {
out_of_process_services[video_capture::mojom::kServiceName] = {
base::ASCIIToUTF16("Video Capture Service"), SANDBOX_TYPE_NO_SANDBOX};
}

#if BUILDFLAG(ENABLE_MOJO_MEDIA_IN_UTILITY_PROCESS)
// TODO(xhwang): This is only used for test/experiment for now so it's okay
// to run it in an unsandboxed utility process. Fix CDM loading so that we can
// run it in the sandboxed utility process. See http://crbug.com/510604
  out_of_process_services[media::mojom::kMediaServiceName] = {
      base::ASCIIToUTF16("Media Service"), SANDBOX_TYPE_NO_SANDBOX};
#endif

for (const auto& service : out_of_process_services) {
packaged_services_connection_->AddServiceRequestHandler(
service.first, base::Bind(&StartServiceInUtilityProcess, service.first,
service.second.first, service.second.second));
}

#if BUILDFLAG(ENABLE_MOJO_MEDIA_IN_GPU_PROCESS)
packaged_services_connection_->AddServiceRequestHandler(
media::mojom::kMediaServiceName,
base::Bind(&StartServiceInGpuProcess, media::mojom::kMediaServiceName));
#endif

packaged_services_connection_->AddServiceRequestHandler(
shape_detection::mojom::kServiceName,
base::Bind(&StartServiceInGpuProcess,
shape_detection::mojom::kServiceName));

packaged_services_connection_->Start();

RegisterCommonBrowserInterfaces(browser_connection);
browser_connection->Start();

if (network_service_enabled) {
// Start the network service process as soon as possible, since it is
// critical to start up performance.
browser_connection->GetConnector()->StartService(
mojom::kNetworkServiceName);
}
}

service_manager::Connector* ServiceManagerConnectionImpl::GetConnector() {
  return connector_.get();
}

void UtilityServiceFactory::RegisterServices(ServiceMap* services) {
GetContentClient()->utility()->RegisterServices(services);

service_manager::EmbeddedServiceInfo video_capture_info;
video_capture_info.factory = base::Bind(&CreateVideoCaptureService);
services->insert(
std::make_pair(video_capture::mojom::kServiceName, video_capture_info));

#if BUILDFLAG(ENABLE_PEPPER_CDMS)
service_manager::EmbeddedServiceInfo info;
  info.factory = base::Bind(&CreateMediaService);
  services->insert(std::make_pair(media::mojom::kMediaServiceName, info));
#endif

service_manager::EmbeddedServiceInfo shape_detection_info;
shape_detection_info.factory =
base::Bind(&shape_detection::ShapeDetectionService::Create);
services->insert(std::make_pair(shape_detection::mojom::kServiceName,
shape_detection_info));

service_manager::EmbeddedServiceInfo data_decoder_info;
data_decoder_info.factory = base::Bind(&CreateDataDecoderService);
services->insert(
std::make_pair(data_decoder::mojom::kServiceName, data_decoder_info));

if (base::FeatureList::IsEnabled(features::kNetworkService)) {
GetContentClient()->utility()->RegisterNetworkBinders(
network_registry_.get());
service_manager::EmbeddedServiceInfo network_info;
network_info.factory = base::Bind(
&UtilityServiceFactory::CreateNetworkService, base::Unretained(this));
network_info.task_runner = ChildProcess::current()->io_task_runner();
services->insert(
std::make_pair(content::mojom::kNetworkServiceName, network_info));
}
}

  void RemoveConnectionFilter(int filter_id) {
    io_task_runner_->PostTask(
        FROM_HERE,
        base::Bind(&IOThreadContext::RemoveConnectionFilterOnIOThread, this,
                   filter_id));
  }

  void AddServiceManifest(base::StringPiece name, int resource_id) {
    std::string contents =
        GetContentClient()
            ->GetDataResource(resource_id, ui::ScaleFactor::SCALE_FACTOR_NONE)
            .as_string();
    DCHECK(!contents.empty());

    std::unique_ptr<base::Value> manifest_value =
        base::JSONReader::Read(contents);
    DCHECK(manifest_value);

    std::unique_ptr<base::Value> overlay_value =
        GetContentClient()->browser()->GetServiceManifestOverlay(name);

    service_manager::MergeManifestWithOverlay(manifest_value.get(),
                                              overlay_value.get());

    base::Optional<catalog::RequiredFileMap> required_files =
        catalog::RetrieveRequiredFiles(*manifest_value);
    if (required_files) {
      ChildProcessLauncher::SetRegisteredFilesForService(
          name.as_string(), std::move(*required_files));
    }

    auto result = manifests_.insert(
        std::make_pair(name.as_string(), std::move(manifest_value)));
    DCHECK(result.second) << "Duplicate manifest entry: " << name;
  }

  void ClearConnectionFiltersOnIOThread() {
    base::AutoLock lock(lock_);
    connection_filters_.clear();
  }

void UtilityServiceFactory::OnLoadFailed() {
  UtilityThreadImpl* utility_thread =
      static_cast<UtilityThreadImpl*>(UtilityThread::Get());
  utility_thread->Shutdown();
  utility_thread->ReleaseProcess();
}

  NullServiceProcessLauncherFactory() {}

ServiceManagerConnection::~ServiceManagerConnection() {}

service_manager::Connector* ServiceManagerContext::GetConnectorForIOThread() {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));
  return g_io_thread_connector.Get().get();
}

UtilityServiceFactory::~UtilityServiceFactory() {}

void StartServiceInGpuProcess(const std::string& service_name,
                              service_manager::mojom::ServiceRequest request) {
  DCHECK_CURRENTLY_ON(BrowserThread::IO);
  GpuProcessHost* process_host = GpuProcessHost::Get();
  if (!process_host) {
    DLOG(ERROR) << "GPU process host not available.";
    return;
  }

  service_manager::mojom::ServiceFactoryPtr service_factory;
  BindInterfaceInGpuProcess(mojo::MakeRequest(&service_factory));
  service_factory->CreateService(std::move(request), service_name);
}

void MediaInterfaceProxy::OnConnectionError() {
   DVLOG(1) << __FUNCTION__;
   DCHECK(thread_checker_.CalledOnValidThread());
 
   interface_factory_ptr_.reset();
 }

std::unique_ptr<service_manager::Service> CreateVideoCaptureService() {
  return base::MakeUnique<video_capture::ServiceImpl>();
}

  ~InProcessServiceManagerContext() {}

void ServiceManagerConnectionImpl::GetInterface(
    service_manager::mojom::InterfaceProvider* provider,
    const std::string& interface_name,
    mojo::ScopedMessagePipeHandle request_handle) {
  provider->GetInterface(interface_name, std::move(request_handle));
}

MediaInterfaceProxy::GetMediaInterfaceFactory() {
DVLOG(1) << __FUNCTION__;
DCHECK(thread_checker_.CalledOnValidThread());

if (!interface_factory_ptr_)
    ConnectToService();

DCHECK(interface_factory_ptr_);

return interface_factory_ptr_.get();
}

void ServiceManagerConnectionImpl::AddEmbeddedService(
    const std::string& name,
    const service_manager::EmbeddedServiceInfo& info) {
  context_->AddEmbeddedService(name, info);
}

  CdmMojoMediaClient() {}

void MediaInterfaceProxy::ConnectToService() {
DVLOG(1) << __FUNCTION__;
DCHECK(thread_checker_.CalledOnValidThread());
  DCHECK(!interface_factory_ptr_);

// Register frame services.
service_manager::mojom::InterfaceProviderPtr interfaces;
// TODO(xhwang): Replace this InterfaceProvider with a dedicated media host
// interface. See http://crbug.com/660573
auto provider = base::MakeUnique<media::MediaInterfaceProvider>(
mojo::MakeRequest(&interfaces));
#if BUILDFLAG(ENABLE_MOJO_CDM)
// TODO(slan): Wrap these into a RenderFrame specific ProvisionFetcher impl.
net::URLRequestContextGetter* context_getter =
BrowserContext::GetDefaultStoragePartition(
render_frame_host_->GetProcess()->GetBrowserContext())
->GetURLRequestContext();
provider->registry()->AddInterface(base::Bind(
&ProvisionFetcherImpl::Create, base::RetainedRef(context_getter)));
#endif  // BUILDFLAG(ENABLE_MOJO_CDM)
GetContentClient()->browser()->ExposeInterfacesToMediaService(
provider->registry(), render_frame_host_);

media_registries_.push_back(std::move(provider));

  // TODO(slan): Use the BrowserContext Connector instead. See crbug.com/638950.
media::mojom::MediaServicePtr media_service;
service_manager::Connector* connector =
ServiceManagerConnection::GetForProcess()->GetConnector();
connector->BindInterface(media::mojom::kMediaServiceName, &media_service);
media_service->CreateInterfaceFactory(MakeRequest(&interface_factory_ptr_),
                                        std::move(interfaces));
  interface_factory_ptr_.set_connection_error_handler(base::Bind(
      &MediaInterfaceProxy::OnConnectionError, base::Unretained(this)));
}

  void ShutDown() {
    if (!started_)
      return;

    bool posted = io_task_runner_->PostTask(
        FROM_HERE, base::Bind(&IOThreadContext::ShutDownOnIOThread, this));
    DCHECK(posted);
  }

void MediaInterfaceProxy::CreateVideoDecoder(
    media::mojom::VideoDecoderRequest request) {
  DCHECK(thread_checker_.CalledOnValidThread());
  GetMediaInterfaceFactory()->CreateVideoDecoder(std::move(request));
}

ServiceManagerConnection* ServiceManagerConnection::GetForProcess() {
  return g_connection_for_process.Get().get();
}

void MediaInterfaceProxy::CreateAudioDecoder(
    media::mojom::AudioDecoderRequest request) {
  DCHECK(thread_checker_.CalledOnValidThread());
  GetMediaInterfaceFactory()->CreateAudioDecoder(std::move(request));
}

int ServiceManagerConnectionImpl::AddConnectionFilter(
    std::unique_ptr<ConnectionFilter> filter) {
  return context_->AddConnectionFilter(std::move(filter));
}

ServiceManagerConnectionImpl::ServiceManagerConnectionImpl(
    service_manager::mojom::ServiceRequest request,
    scoped_refptr<base::SequencedTaskRunner> io_task_runner)
    : weak_factory_(this) {
  service_manager::mojom::ConnectorRequest connector_request;
  connector_ = service_manager::Connector::Create(&connector_request);

  std::unique_ptr<service_manager::Connector> io_thread_connector =
      connector_->Clone();
  context_ = new IOThreadContext(
      std::move(request), io_task_runner, std::move(io_thread_connector),
      std::move(connector_request));
}

void ServiceManagerConnectionImpl::OnConnectionLost() {
  if (!connection_lost_handler_.is_null())
    connection_lost_handler_.Run();
}

  IOThreadContext(
      service_manager::mojom::ServiceRequest service_request,
      scoped_refptr<base::SequencedTaskRunner> io_task_runner,
      std::unique_ptr<service_manager::Connector> io_thread_connector,
      service_manager::mojom::ConnectorRequest connector_request)
      : pending_service_request_(std::move(service_request)),
        io_task_runner_(io_task_runner),
        io_thread_connector_(std::move(io_thread_connector)),
        pending_connector_request_(std::move(connector_request)),
        child_binding_(this),
        weak_factory_(this) {
    io_thread_checker_.DetachFromThread();
  }

  void ShutDownOnIOThread() {
    service_manager_.reset();
    manifest_provider_.reset();
  }

void ServiceManagerConnectionImpl::SetConnectionLostClosure(
    const base::Closure& closure) {
  connection_lost_handler_ = closure;
}

  void AddEmbeddedService(const std::string& name,
                          const service_manager::EmbeddedServiceInfo& info) {
    io_task_runner_->PostTask(
        FROM_HERE, base::Bind(&ServiceManagerConnectionImpl::IOThreadContext::
                                  AddEmbeddedServiceRequestHandlerOnIoThread,
                              this, name, info));
  }
