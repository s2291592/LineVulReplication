static bool CheckH263(const uint8_t* buffer, int buffer_size) {
  RCHECK(buffer_size > 16);

  int offset = 0;
  bool seen_start_code = false;
  while (true) {
    if (!AdvanceToStartCode(buffer, buffer_size, &offset, 9, 22, 0x20)) {
      return seen_start_code;
    }

    BitReader reader(buffer + offset, 9);
    RCHECK(ReadBits(&reader, 22) == 0x20);

    reader.SkipBits(8);

    RCHECK(ReadBits(&reader, 2) == 2);

    reader.SkipBits(1 + 1 + 1);

    int format = ReadBits(&reader, 3);
    RCHECK(format != 0 && format != 6);  // Forbidden or reserved.

    if (format == 7) {
      int ufep = ReadBits(&reader, 3);
      if (ufep == 1) {
        format = ReadBits(&reader, 3);
        RCHECK(format != 0 && format != 7);  // Reserved.
        reader.SkipBits(11);
        RCHECK(ReadBits(&reader, 4) == 8);  // Not allowed.
      } else {
        RCHECK(ufep == 0);  // Only 0 and 1 allowed.
      }

      int picture_type_code = ReadBits(&reader, 3);
      RCHECK(picture_type_code != 6 && picture_type_code != 7);  // Reserved.

      reader.SkipBits(1 + 1 + 1);

      RCHECK(ReadBits(&reader, 3) == 1);  // Not allowed.
    }

    seen_start_code = true;
    offset += 9;
  }
}

static bool StartsWith(const uint8_t* buffer,
                       size_t buffer_size,
                       const char* prefix) {
  size_t prefix_size = strlen(prefix);
  return (prefix_size <= buffer_size &&
          memcmp(buffer, prefix, prefix_size) == 0);
}

bool BitReaderCore::Refill(int min_nbits) {
  DCHECK_LE(min_nbits, kRegWidthInBits);

  RefillCurrentRegister();
  if (min_nbits <= nbits_)
    return true;
  DCHECK_EQ(nbits_next_, 0);
  DCHECK_EQ(reg_next_, 0u);

  int max_nbytes = sizeof(reg_next_);

  const uint8_t* byte_stream_window;
  int window_size =
      byte_stream_provider_->GetBytes(max_nbytes, &byte_stream_window);
  DCHECK_GE(window_size, 0);
  DCHECK_LE(window_size, max_nbytes);
  if (window_size == 0)
    return false;

  reg_next_ = 0;
  memcpy(&reg_next_, byte_stream_window, window_size);
  reg_next_ = base::NetToHost64(reg_next_);
  nbits_next_ = window_size * 8;

  RefillCurrentRegister();

  return (nbits_ >= min_nbits);
}

static bool CheckDV(const uint8_t* buffer, int buffer_size) {
  RCHECK(buffer_size > 11);

  int offset = 0;
  int current_sequence_number = -1;
  int last_block_number[6] = {0};
  while (offset + 11 < buffer_size) {
    BitReader reader(buffer + offset, 11);

    int section = ReadBits(&reader, 3);
    RCHECK(section < 5);

    RCHECK(ReadBits(&reader, 1) == 1);

    reader.SkipBits(4);

    int sequence_number = ReadBits(&reader, 4);

    reader.SkipBits(1);

    RCHECK(ReadBits(&reader, 3) == 7);

    int block_number = ReadBits(&reader, 8);

    if (section == 0) {  // Header.
      reader.SkipBits(1);
      RCHECK(ReadBits(&reader, 1) == 0);
      RCHECK(ReadBits(&reader, 11) == 0x7ff);
      reader.SkipBits(4);
      RCHECK(ReadBits(&reader, 4) == 0xf);
      reader.SkipBits(4);
      RCHECK(ReadBits(&reader, 4) == 0xf);
      reader.SkipBits(4);
      RCHECK(ReadBits(&reader, 4) == 0xf);
      reader.SkipBits(3);
      RCHECK(ReadBits(&reader, 24) == 0xffffff);
      current_sequence_number = sequence_number;
      for (size_t i = 0; i < base::size(last_block_number); ++i)
        last_block_number[i] = -1;
    } else {
      RCHECK(sequence_number == current_sequence_number);
      RCHECK(block_number > last_block_number[section]);
      last_block_number[section] = block_number;
    }

    offset += 80;
  }
  return true;
}

static uint32_t Read32(const uint8_t* p) {
  return p[0] << 24 | p[1] << 16 | p[2] << 8 | p[3];
}

static bool CheckSrt(const uint8_t* buffer, int buffer_size) {
  RCHECK(buffer_size > 20);

  int offset = StartsWith(buffer, buffer_size, UTF8_BYTE_ORDER_MARK) ? 3 : 0;
  RCHECK(VerifyNumber(buffer, buffer_size, &offset, 100));
  RCHECK(VerifyCharacters(buffer, buffer_size, &offset, '\n', '\r'));

  while (VerifyCharacters(buffer, buffer_size, &offset, '\n', '\r')) {}
  --offset;  // Since VerifyCharacters() gobbled up the next non-CR/LF.

  RCHECK(VerifyNumber(buffer, buffer_size, &offset, 100));
  RCHECK(VerifyCharacters(buffer, buffer_size, &offset, ':', 0));
  RCHECK(VerifyNumber(buffer, buffer_size, &offset, 2));
  RCHECK(VerifyCharacters(buffer, buffer_size, &offset, ':', 0));
  RCHECK(VerifyNumber(buffer, buffer_size, &offset, 2));
  RCHECK(VerifyCharacters(buffer, buffer_size, &offset, ',', '.'));
  RCHECK(VerifyNumber(buffer, buffer_size, &offset, 3));
  RCHECK(VerifyCharacters(buffer, buffer_size, &offset, ' ', 0));
  RCHECK(VerifyCharacters(buffer, buffer_size, &offset, '-', 0));
  RCHECK(VerifyCharacters(buffer, buffer_size, &offset, '-', 0));
  RCHECK(VerifyCharacters(buffer, buffer_size, &offset, '>', 0));
  RCHECK(VerifyCharacters(buffer, buffer_size, &offset, ' ', 0));
  RCHECK(VerifyNumber(buffer, buffer_size, &offset, 100));
  RCHECK(VerifyCharacters(buffer, buffer_size, &offset, ':', 0));
  RCHECK(VerifyNumber(buffer, buffer_size, &offset, 2));
  RCHECK(VerifyCharacters(buffer, buffer_size, &offset, ':', 0));
  RCHECK(VerifyNumber(buffer, buffer_size, &offset, 2));
  RCHECK(VerifyCharacters(buffer, buffer_size, &offset, ',', '.'));
  RCHECK(VerifyNumber(buffer, buffer_size, &offset, 3));
  return true;
}

int BitReaderCore::bits_read() const {
  return bits_read_;
}

static bool CheckHls(const uint8_t* buffer, int buffer_size) {

  if (StartsWith(buffer, buffer_size, kHlsSignature)) {
    int offset = strlen(kHlsSignature);
    while (offset < buffer_size) {
      if (buffer[offset] == '#') {
        if (StartsWith(buffer + offset, buffer_size - offset, kHls1) ||
            StartsWith(buffer + offset, buffer_size - offset, kHls2) ||
            StartsWith(buffer + offset, buffer_size - offset, kHls3)) {
          return true;
        }
      }
      ++offset;
    }
  }
  return false;
}

static uint32_t Read32LE(const uint8_t* p) {
  return p[3] << 24 | p[2] << 16 | p[1] << 8 | p[0];
}

static bool CheckDts(const uint8_t* buffer, int buffer_size) {
// Reference: ETSI TS 102 114 V1.3.1 (2011-08)
// (http://www.etsi.org/deliver/etsi_ts/102100_102199/102114/01.03.01_60/ts_102114v010301p.pdf)
RCHECK(buffer_size > 11);

int offset = 0;
while (offset + 11 < buffer_size) {
BitReader reader(buffer + offset, 11);

// Verify sync word.
RCHECK(ReadBits(&reader, 32) == 0x7ffe8001);

// Skip frame type and deficit sample count.
reader.SkipBits(1 + 5);

// Verify CRC present flag.
RCHECK(ReadBits(&reader, 1) == 0);  // CPF must be 0.

// Verify number of PCM sample blocks.
RCHECK(ReadBits(&reader, 7) >= 5);

// Verify primary frame byte size.
int frame_size = ReadBits(&reader, 14);
RCHECK(frame_size >= 95);

// Skip audio channel arrangement.
reader.SkipBits(6);

// Verify core audio sampling frequency is an allowed value.
    RCHECK(kSamplingFrequencyValid[ReadBits(&reader, 4)]);

// Verify transmission bit rate is valid.
RCHECK(ReadBits(&reader, 5) <= 25);

// Verify reserved field is 0.
RCHECK(ReadBits(&reader, 1) == 0);

// Skip dynamic range flag, time stamp flag, auxiliary data flag, and HDCD.
reader.SkipBits(1 + 1 + 1 + 1);

// Verify extension audio descriptor flag is an allowed value.
    RCHECK(kExtAudioIdValid[ReadBits(&reader, 3)]);

// Skip extended coding flag and audio sync word insertion flag.
reader.SkipBits(1 + 1);

// Verify low frequency effects flag is an allowed value.
RCHECK(ReadBits(&reader, 2) != 3);

offset += frame_size + 1;
}
return true;
}

static MediaContainerName LookupContainerByFirst4(const uint8_t* buffer,
                                                  int buffer_size) {
  if (buffer_size < kMinimumContainerSize)
    return CONTAINER_UNKNOWN;

  uint32_t first4 = Read32(buffer);
  switch (first4) {
    case 0x1a45dfa3:
      if (CheckWebm(buffer, buffer_size))
        return CONTAINER_WEBM;
      break;

    case 0x3026b275:
      if (StartsWith(buffer,
                     buffer_size,
                     kAsfSignature,
                     sizeof(kAsfSignature))) {
        return CONTAINER_ASF;
      }
      break;

    case TAG('#','!','A','M'):
      if (StartsWith(buffer, buffer_size, kAmrSignature))
        return CONTAINER_AMR;
      break;

    case TAG('#','E','X','T'):
      if (CheckHls(buffer, buffer_size))
        return CONTAINER_HLS;
      break;

    case TAG('.','R','M','F'):
      if (buffer[4] == 0 && buffer[5] == 0)
        return CONTAINER_RM;
      break;

    case TAG('.','r','a','\xfd'):
      return CONTAINER_RM;

    case TAG('B','I','K','b'):
    case TAG('B','I','K','d'):
    case TAG('B','I','K','f'):
    case TAG('B','I','K','g'):
    case TAG('B','I','K','h'):
    case TAG('B','I','K','i'):
      if (CheckBink(buffer, buffer_size))
        return CONTAINER_BINK;
      break;

    case TAG('c','a','f','f'):
      if (CheckCaf(buffer, buffer_size))
        return CONTAINER_CAF;
      break;

    case TAG('D','E','X','A'):
      if (buffer_size > 15 &&
          Read16(buffer + 11) <= 2048 &&
          Read16(buffer + 13) <= 2048) {
        return CONTAINER_DXA;
      }
      break;

    case TAG('D','T','S','H'):
      if (Read32(buffer + 4) == TAG('D','H','D','R'))
        return CONTAINER_DTSHD;
      break;

    case 0x64a30100:
    case 0x64a30200:
    case 0x64a30300:
    case 0x64a30400:
    case 0x0001a364:
    case 0x0002a364:
    case 0x0003a364:
      if (Read32(buffer + 4) != 0 && Read32(buffer + 8) != 0)
        return CONTAINER_IRCAM;
      break;

    case TAG('f','L','a','C'):
      return CONTAINER_FLAC;

    case TAG('F','L','V',0):
    case TAG('F','L','V',1):
    case TAG('F','L','V',2):
    case TAG('F','L','V',3):
    case TAG('F','L','V',4):
      if (buffer[5] == 0 && Read32(buffer + 5) > 8)
        return CONTAINER_FLV;
      break;

    case TAG('F','O','R','M'):
      switch (Read32(buffer + 8)) {
        case TAG('A','I','F','F'):
        case TAG('A','I','F','C'):
          return CONTAINER_AIFF;
      }
      break;

    case TAG('M','A','C',' '):
      return CONTAINER_APE;

    case TAG('O','N','2',' '):
      if (Read32(buffer + 8) == TAG('O','N','2','f'))
        return CONTAINER_AVI;
      break;

    case TAG('O','g','g','S'):
      if (buffer[5] <= 7)
        return CONTAINER_OGG;
      break;

    case TAG('R','F','6','4'):
      if (buffer_size > 16 && Read32(buffer + 12) == TAG('d','s','6','4'))
        return CONTAINER_WAV;
      break;

    case TAG('R','I','F','F'):
      switch (Read32(buffer + 8)) {
        case TAG('A','V','I',' '):
        case TAG('A','V','I','X'):
        case TAG('A','V','I','\x19'):
        case TAG('A','M','V',' '):
          return CONTAINER_AVI;
        case TAG('W','A','V','E'):
          return CONTAINER_WAV;
      }
      break;

    case TAG('[','S','c','r'):
      if (StartsWith(buffer, buffer_size, kAssSignature))
        return CONTAINER_ASS;
      break;

    case TAG('\xef','\xbb','\xbf','['):
      if (StartsWith(buffer, buffer_size, kAssBomSignature))
        return CONTAINER_ASS;
      break;

    case 0x7ffe8001:
    case 0xfe7f0180:
    case 0x1fffe800:
    case 0xff1f00e8:
      if (CheckDts(buffer, buffer_size))
        return CONTAINER_DTS;
      break;

    case 0xb7d80020:
      if (StartsWith(buffer,
                     buffer_size,
                     kWtvSignature,
                     sizeof(kWtvSignature))) {
        return CONTAINER_WTV;
      }
      break;
  }

  uint32_t first3 = first4 & 0xffffff00;
  switch (first3) {
    case TAG('C','W','S',0):
    case TAG('F','W','S',0):
      return CONTAINER_SWF;

    case TAG('I','D','3',0):
      return CONTAINER_MP3;
  }

  uint32_t first2 = Read16(buffer);
  switch (first2) {
    case kAc3SyncWord:
      if (CheckAc3(buffer, buffer_size))
        return CONTAINER_AC3;
      if (CheckEac3(buffer, buffer_size))
        return CONTAINER_EAC3;
      break;

    case 0xfff0:
    case 0xfff1:
    case 0xfff8:
    case 0xfff9:
      if (CheckAac(buffer, buffer_size))
        return CONTAINER_AAC;
      break;
  }

  if (CheckMp3(buffer, buffer_size))
    return CONTAINER_MP3;

  return CONTAINER_UNKNOWN;
}

static bool StartsWith(const uint8_t* buffer,
                       size_t buffer_size,
                       const uint8_t* prefix,
                       size_t prefix_size) {
  return (prefix_size <= buffer_size &&
          memcmp(buffer, prefix, prefix_size) == 0);
 }

static bool CheckMpeg2TransportStream(const uint8_t* buffer, int buffer_size) {
  RCHECK(buffer_size >= 250);  // Want more than 1 packet to check.

  int offset = 0;
  int packet_length = -1;
  while (buffer[offset] != kMpeg2SyncWord && offset < 20) {
    ++offset;
  }

  while (offset + 6 < buffer_size) {
    BitReader reader(buffer + offset, 6);

    RCHECK(ReadBits(&reader, 8) == kMpeg2SyncWord);

    reader.SkipBits(1 + 1 + 1);

    int pid = ReadBits(&reader, 13);
    RCHECK(pid < 3 || pid > 15);

    reader.SkipBits(2);

    int adaptation_field_control = ReadBits(&reader, 2);
    RCHECK(adaptation_field_control != 0);

    if (adaptation_field_control >= 2) {
      reader.SkipBits(4);

      int adaptation_field_length = ReadBits(&reader, 8);
      if (adaptation_field_control == 2)
        RCHECK(adaptation_field_length == 183);
      else
        RCHECK(adaptation_field_length <= 182);
    }

    if (packet_length < 0) {
      if (buffer[offset + 188] == kMpeg2SyncWord)
        packet_length = 188;
      else if (buffer[offset + 192] == kMpeg2SyncWord)
        packet_length = 192;
      else if (buffer[offset + 204] == kMpeg2SyncWord)
        packet_length = 204;
      else
        packet_length = 208;
    }
    offset += packet_length;
  }
  return true;
}

BitReaderCore::BitReaderCore(ByteStreamProvider* byte_stream_provider)
    : byte_stream_provider_(byte_stream_provider),
      bits_read_(0),
      nbits_(0),
      reg_(0),
      nbits_next_(0),
      reg_next_(0) {
}

MediaContainerName DetermineContainer(const uint8_t* buffer, int buffer_size) {
  DCHECK(buffer);

  if (CheckMov(buffer, buffer_size))
    return CONTAINER_MOV;

  MediaContainerName result = LookupContainerByFirst4(buffer, buffer_size);
  if (result != CONTAINER_UNKNOWN)
    return result;

  if (CheckMpeg2ProgramStream(buffer, buffer_size))
    return CONTAINER_MPEG2PS;
  if (CheckMpeg2TransportStream(buffer, buffer_size))
    return CONTAINER_MPEG2TS;
  if (CheckMJpeg(buffer, buffer_size))
    return CONTAINER_MJPEG;
  if (CheckDV(buffer, buffer_size))
    return CONTAINER_DV;
  if (CheckH261(buffer, buffer_size))
    return CONTAINER_H261;
  if (CheckH263(buffer, buffer_size))
    return CONTAINER_H263;
  if (CheckH264(buffer, buffer_size))
    return CONTAINER_H264;
  if (CheckMpeg4BitStream(buffer, buffer_size))
    return CONTAINER_MPEG4BS;
  if (CheckVC1(buffer, buffer_size))
    return CONTAINER_VC1;
  if (CheckSrt(buffer, buffer_size))
    return CONTAINER_SRT;
  if (CheckGsm(buffer, buffer_size))
    return CONTAINER_GSM;

  int offset = 1;  // No need to start at byte 0 due to First4 check.
  if (AdvanceToStartCode(buffer, buffer_size, &offset, 4, 16, kAc3SyncWord)) {
    if (CheckAc3(buffer + offset, buffer_size - offset))
      return CONTAINER_AC3;
    if (CheckEac3(buffer + offset, buffer_size - offset))
      return CONTAINER_EAC3;
  }

  return CONTAINER_UNKNOWN;
}

static int Read16(const uint8_t* p) {
  return p[0] << 8 | p[1];
}

static uint32_t Read24(const uint8_t* p) {
  return p[0] << 16 | p[1] << 8 | p[2];
}

static uint64_t ReadBits(BitReader* reader, int num_bits) {
DCHECK_GE(reader->bits_available(), num_bits);
DCHECK((num_bits > 0) && (num_bits <= 64));
  uint64_t value;
  reader->ReadBits(num_bits, &value);
return value;
}

bool BitReaderCore::SkipBitsSmall(int num_bits) {
  DCHECK_GE(num_bits, 0);
  uint64_t dummy;
  while (num_bits >= kRegWidthInBits) {
    if (!ReadBitsInternal(kRegWidthInBits, &dummy))
      return false;
    num_bits -= kRegWidthInBits;
  }
  return ReadBitsInternal(num_bits, &dummy);
}

bool BitReaderCore::ReadFlag(bool* flag) {
  if (nbits_ == 0 && !Refill(1))
    return false;

  *flag = (reg_ & (UINT64_C(1) << (kRegWidthInBits - 1))) != 0;
  reg_ <<= 1;
  nbits_--;
  bits_read_++;
  return true;
}

static bool VerifyNumber(const uint8_t* buffer,
                         int buffer_size,
                         int* offset,
                         int max_digits) {
  RCHECK(*offset < buffer_size);

  while (isspace(buffer[*offset])) {
    ++(*offset);
    RCHECK(*offset < buffer_size);
  }

  int numSeen = 0;
  while (--max_digits >= 0 && isdigit(buffer[*offset])) {
    ++numSeen;
    ++(*offset);
    if (*offset >= buffer_size)
      return true;  // Out of space but seen a digit.
  }

  return (numSeen > 0);
}

static bool CheckMpeg2ProgramStream(const uint8_t* buffer, int buffer_size) {
  RCHECK(buffer_size > 14);

  int offset = 0;
  while (offset + 14 < buffer_size) {
    BitReader reader(buffer + offset, 14);

    RCHECK(ReadBits(&reader, 24) == 1);
    RCHECK(ReadBits(&reader, 8) == PACK_START_CODE);

    int mpeg_version = ReadBits(&reader, 2);
    if (mpeg_version == 0) {
      RCHECK(ReadBits(&reader, 2) == 2);
    } else {
      RCHECK(mpeg_version == 1);
    }

    reader.SkipBits(3);

    RCHECK(ReadBits(&reader, 1) == 1);

    reader.SkipBits(15);

    RCHECK(ReadBits(&reader, 1) == 1);

    reader.SkipBits(15);

    RCHECK(ReadBits(&reader, 1) == 1);

    if (mpeg_version == 0) {
      RCHECK(ReadBits(&reader, 1) == 1);

      reader.SkipBits(22);

      RCHECK(ReadBits(&reader, 1) == 1);

      offset += 12;
    } else {
      reader.SkipBits(22);

      RCHECK(ReadBits(&reader, 2) == 3);

      reader.SkipBits(5);

      int pack_stuffing_length = ReadBits(&reader, 3);
      offset += 14 + pack_stuffing_length;
    }

    while (offset + 6 < buffer_size && Read24(buffer + offset) == 1) {
      int stream_id = buffer[offset + 3];

      if (mpeg_version == 0)
        RCHECK(stream_id != 0xbc && stream_id < 0xf0);
      else
        RCHECK(stream_id != 0xfc && stream_id != 0xfd && stream_id != 0xfe);

      if (stream_id == PACK_START_CODE)  // back to outer loop.
        break;
      if (stream_id == PROGRAM_END_CODE)  // end of stream.
        return true;

      int pes_length = Read16(buffer + offset + 4);
      RCHECK(pes_length > 0);
      offset = offset + 6 + pes_length;
    }
  }
  return true;
}

void BitReaderCore::RefillCurrentRegister() {
  if (nbits_ == kRegWidthInBits || nbits_next_ == 0)
    return;

  reg_ |= (reg_next_ >> nbits_);

  int free_nbits = kRegWidthInBits - nbits_;
  if (free_nbits >= nbits_next_) {
    nbits_ += nbits_next_;
    reg_next_ = 0;
    nbits_next_ = 0;
    return;
  }

  nbits_ += free_nbits;
  reg_next_ <<= free_nbits;
  nbits_next_ -= free_nbits;
}

static bool CheckMov(const uint8_t* buffer, int buffer_size) {
  RCHECK(buffer_size > 8);

  int offset = 0;
  int valid_top_level_boxes = 0;
  while (offset + 8 < buffer_size) {
    uint32_t atomsize = Read32(buffer + offset);
    uint32_t atomtype = Read32(buffer + offset + 4);

    switch (atomtype) {
      case TAG('f', 't', 'y', 'p'):
      case TAG('p', 'd', 'i', 'n'):
      case TAG('b', 'l', 'o', 'c'):
      case TAG('m', 'o', 'o', 'v'):
      case TAG('m', 'o', 'o', 'f'):
      case TAG('m', 'f', 'r', 'a'):
      case TAG('m', 'd', 'a', 't'):
      case TAG('f', 'r', 'e', 'e'):
      case TAG('s', 'k', 'i', 'p'):
      case TAG('m', 'e', 't', 'a'):
      case TAG('m', 'e', 'c', 'o'):
      case TAG('s', 't', 'y', 'p'):
      case TAG('s', 'i', 'd', 'x'):
      case TAG('s', 's', 'i', 'x'):
      case TAG('p', 'r', 'f', 't'):
      case TAG('u', 'u', 'i', 'd'):
      case TAG('e', 'm', 's', 'g'):
        ++valid_top_level_boxes;
        break;
    }
    if (atomsize == 1) {
      if (offset + 16 > buffer_size)
        break;
      if (Read32(buffer + offset + 8) != 0)
        break;  // Offset is way past buffer size.
      atomsize = Read32(buffer + offset + 12);
    }
    if (atomsize == 0 || atomsize > static_cast<size_t>(buffer_size))
      break;  // Indicates the last atom or length too big.
    offset += atomsize;
  }
  return valid_top_level_boxes >= 2;
}

static bool CheckWebm(const uint8_t* buffer, int buffer_size) {
  RCHECK(buffer_size > 12);

  BitReader reader(buffer, buffer_size);

  RCHECK(GetElementId(&reader) == 0x1a45dfa3);

  int header_size = base::saturated_cast<int>(GetVint(&reader));
  RCHECK(reader.bits_available() / 8 >= header_size);

  while (reader.bits_available() > 0) {
    int tag = GetElementId(&reader);
    int tagsize = base::saturated_cast<int>(GetVint(&reader));
    switch (tag) {
      case 0x4286:  // EBMLVersion
      case 0x42f7:  // EBMLReadVersion
      case 0x42f2:  // EBMLMaxIdLength
      case 0x42f3:  // EBMLMaxSizeLength
      case 0x4287:  // DocTypeVersion
      case 0x4285:  // DocTypeReadVersion
      case 0xec:    // void
      case 0xbf:    // CRC32
        RCHECK(reader.bits_available() / 8 >= tagsize);
        RCHECK(reader.SkipBits(tagsize * 8));
        break;

      case 0x4282:  // EBMLDocType
        RCHECK(reader.bits_available() >= 32);
        switch (ReadBits(&reader, 32)) {
          case TAG('w', 'e', 'b', 'm') :
            return true;
          case TAG('m', 'a', 't', 'r') :
            RCHECK(reader.bits_available() >= 32);
            return (ReadBits(&reader, 32) == TAG('o', 's', 'k', 'a'));
        }
        return false;

      default:  // Unrecognized tag
        return false;
    }
  }
  return false;
}

static bool CheckGsm(const uint8_t* buffer, int buffer_size) {
  RCHECK(buffer_size >= 1024);  // Need enough data to do a decent check.

  int offset = 0;
  while (offset < buffer_size) {
    RCHECK((buffer[offset] & 0xf0) == 0xd0);
    offset += 33;
  }
  return true;
}

static bool CheckAac(const uint8_t* buffer, int buffer_size) {
  RCHECK(buffer_size > 6);

  int offset = 0;
  while (offset + 6 < buffer_size) {
    BitReader reader(buffer + offset, 6);

    RCHECK(ReadBits(&reader, 12) == 0xfff);

    reader.SkipBits(1);

    RCHECK(ReadBits(&reader, 2) == 0);

    reader.SkipBits(1 + 2);

    RCHECK(ReadBits(&reader, 4) != 15);  // Forbidden.

    reader.SkipBits(1 + 3 + 1 + 1 + 1 + 1);

    int size = ReadBits(&reader, 13);
    RCHECK(size > 0);
    offset += size;
  }
  return true;
}

static bool CheckMpeg4BitStream(const uint8_t* buffer, int buffer_size) {
  RCHECK(buffer_size > 4);

  int offset = 0;
  int sequence_start_count = 0;
  int sequence_end_count = 0;
  int visual_object_count = 0;
  int vop_count = 0;
  while (true) {
    if (!AdvanceToStartCode(buffer, buffer_size, &offset, 6, 24, 1)) {
      return (sequence_start_count > 0 && visual_object_count > 0);
    }

    BitReader reader(buffer + offset, 6);
    RCHECK(ReadBits(&reader, 24) == 1);

    int start_code = ReadBits(&reader, 8);
    RCHECK(start_code < 0x30 || start_code > 0xaf);  // 30..AF and
    RCHECK(start_code < 0xb7 || start_code > 0xb9);  // B7..B9 reserved

    switch (start_code) {
      case VISUAL_OBJECT_SEQUENCE_START_CODE: {
        ++sequence_start_count;
        int profile = ReadBits(&reader, 8);
        RCHECK(profile > 0);
        RCHECK(profile < 0x04 || profile > 0x10);
        RCHECK(profile < 0x13 || profile > 0x20);
        RCHECK(profile < 0x23 || profile > 0x31);
        RCHECK(profile < 0x35 || profile > 0x41);
        RCHECK(profile < 0x43 || profile > 0x60);
        RCHECK(profile < 0x65 || profile > 0x70);
        RCHECK(profile < 0x73 || profile > 0x80);
        RCHECK(profile < 0x83 || profile > 0x90);
        RCHECK(profile < 0x95 || profile > 0xa0);
        RCHECK(profile < 0xa4 || profile > 0xb0);
        RCHECK(profile < 0xb5 || profile > 0xc0);
        RCHECK(profile < 0xc3 || profile > 0xd0);
        RCHECK(profile < 0xe4);
        break;
      }

      case VISUAL_OBJECT_SEQUENCE_END_CODE:
        RCHECK(++sequence_end_count == sequence_start_count);
        break;

      case VISUAL_OBJECT_START_CODE: {
        ++visual_object_count;
        if (ReadBits(&reader, 1) == 1) {
          int visual_object_verid = ReadBits(&reader, 4);
          RCHECK(visual_object_verid > 0 && visual_object_verid < 3);
          RCHECK(ReadBits(&reader, 3) != 0);
        }
        int visual_object_type = ReadBits(&reader, 4);
        RCHECK(visual_object_type > 0 && visual_object_type < 6);
        break;
      }

      case VOP_START_CODE:
        RCHECK(++vop_count <= visual_object_count);
        break;
    }
    offset += 6;
  }
}

static bool CheckMp3(const uint8_t* buffer, int buffer_size) {
  int numSeen = 0;
  int offset = 0;

  while (offset < buffer_size && buffer[offset] == 0)
    ++offset;

  while (offset + 3 < buffer_size) {
    int framesize;
    RCHECK(ValidMpegAudioFrameHeader(
        buffer + offset, buffer_size - offset, &framesize));

    if (++numSeen > 10)
      return true;
    offset += framesize;
  }
  return numSeen > 2;
}

static bool CheckH261(const uint8_t* buffer, int buffer_size) {
  RCHECK(buffer_size > 16);

  int offset = 0;
  bool seen_start_code = false;
  while (true) {
    if (!AdvanceToStartCode(buffer, buffer_size, &offset, 4, 20, 0x10)) {
      return seen_start_code;
    }

    BitReader reader(buffer + offset, buffer_size - offset);
    RCHECK(ReadBits(&reader, 20) == 0x10);

    reader.SkipBits(5 + 6);

    int extra = ReadBits(&reader, 1);
    while (extra == 1) {
      if (!reader.SkipBits(8))
        return seen_start_code;
      if (!reader.ReadBits(1, &extra))
        return seen_start_code;
    }

    int next;
    if (!reader.ReadBits(16, &next))
      return seen_start_code;
    RCHECK(next == 1);

    seen_start_code = true;
    offset += 4;
  }
}

static bool CheckAc3(const uint8_t* buffer, int buffer_size) {

  RCHECK(buffer_size > 6);

  int offset = 0;
  while (offset + 6 < buffer_size) {
    BitReader reader(buffer + offset, 6);

    RCHECK(ReadBits(&reader, 16) == kAc3SyncWord);

    reader.SkipBits(16);

    int sample_rate_code = ReadBits(&reader, 2);
    RCHECK(sample_rate_code != 3);  // Reserved.

    int frame_size_code = ReadBits(&reader, 6);
    RCHECK(frame_size_code < 38);  // Undefined.

    RCHECK(ReadBits(&reader, 5) < 10);  // Normally 8 or 6, 16 used by EAC3.

    offset += kAc3FrameSizeTable[frame_size_code][sample_rate_code];
  }
  return true;
}

static inline bool VerifyCharacters(const uint8_t* buffer,
                                    int buffer_size,
                                    int* offset,
                                    char c1,
                                    char c2) {
  RCHECK(*offset < buffer_size);
  char c = static_cast<char>(buffer[(*offset)++]);
  return (c == c1 || (c == c2 && c2 != 0));
}

static bool CheckBink(const uint8_t* buffer, int buffer_size) {
  RCHECK(buffer_size >= 44);

  RCHECK(Read32LE(buffer + 8) > 0);

  int width = Read32LE(buffer + 20);
  RCHECK(width > 0 && width <= 32767);

  int height = Read32LE(buffer + 24);
  RCHECK(height > 0 && height <= 32767);

  RCHECK(Read32LE(buffer + 28) > 0);

  RCHECK(Read32LE(buffer + 32) > 0);

  return (Read32LE(buffer + 40) <= 256);
}

static bool CheckEac3(const uint8_t* buffer, int buffer_size) {

  RCHECK(buffer_size > 6);

  int offset = 0;
  while (offset + 6 < buffer_size) {
    BitReader reader(buffer + offset, 6);

    RCHECK(ReadBits(&reader, 16) == kAc3SyncWord);

    RCHECK(ReadBits(&reader, 2) != 3);

    reader.SkipBits(3);

    int frame_size = (ReadBits(&reader, 11) + 1) * 2;
    RCHECK(frame_size >= 7);

    reader.SkipBits(2 + 2 + 3 + 1);

    int bit_stream_id = ReadBits(&reader, 5);
    RCHECK(bit_stream_id >= 11 && bit_stream_id <= 16);

    offset += frame_size;
  }
  return true;
}

bool BitReaderCore::ReadBitsInternal(int num_bits, uint64_t* out) {
  DCHECK_GE(num_bits, 0);

  if (num_bits == 0) {
    *out = 0;
    return true;
  }

  if (num_bits > nbits_ && !Refill(num_bits)) {
     nbits_ = 0;
     reg_ = 0;
     return false;
   }
 
  bits_read_ += num_bits;

  if (num_bits == kRegWidthInBits) {
    *out = reg_;
    reg_ = 0;
    nbits_ = 0;
    return true;
  }

  *out = reg_ >> (kRegWidthInBits - num_bits);
  reg_ <<= num_bits;
  nbits_ -= num_bits;
  return true;
}

static bool ValidMpegAudioFrameHeader(const uint8_t* header,
                                      int header_size,
                                      int* framesize) {
  DCHECK_GE(header_size, 4);
  *framesize = 0;
  BitReader reader(header, 4);  // Header can only be 4 bytes long.

  RCHECK(ReadBits(&reader, 11) == 0x7ff);

  int version = ReadBits(&reader, 2);
  RCHECK(version != 1);  // Reserved.

  int layer = ReadBits(&reader, 2);
  RCHECK(layer != 0);

  reader.SkipBits(1);

  int bitrate_index = ReadBits(&reader, 4);
  RCHECK(bitrate_index != 0xf);

  int sampling_index = ReadBits(&reader, 2);
  RCHECK(sampling_index != 3);

  int padding = ReadBits(&reader, 1);

  int sampling_rate = kSampleRateTable[version][sampling_index];
  int bitrate;
  if (version == VERSION_1) {
    if (layer == LAYER_1)
      bitrate = kBitRateTableV1L1[bitrate_index];
    else if (layer == LAYER_2)
      bitrate = kBitRateTableV1L2[bitrate_index];
    else
      bitrate = kBitRateTableV1L3[bitrate_index];
  } else {
    if (layer == LAYER_1)
      bitrate = kBitRateTableV2L1[bitrate_index];
    else
      bitrate = kBitRateTableV2L23[bitrate_index];
  }
  if (layer == LAYER_1)
    *framesize = ((12000 * bitrate) / sampling_rate + padding) * 4;
  else
    *framesize = (144000 * bitrate) / sampling_rate + padding;
  return (bitrate > 0 && sampling_rate > 0);
}
