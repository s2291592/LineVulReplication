HostCache::HostCache(size_t max_entries)
    : max_entries_(max_entries), network_changes_(0) {}

RenderProcessHostImpl::GetInProcessRendererThreadForTesting() {
  return g_in_process_thread;
}

void RenderProcessHostImpl::DisableAudioDebugRecordings() {
  DCHECK_CURRENTLY_ON(BrowserThread::UI);

  BrowserThread::PostTaskAndReply(
      BrowserThread::FILE, FROM_HERE, base::Bind(&base::DoNothing),
      base::Bind(&RenderProcessHostImpl::SendDisableAecDumpToRenderer,
                 weak_factory_.GetWeakPtr()));

  if (audio_input_renderer_host_) {
    BrowserThread::PostTask(
        BrowserThread::IO, FROM_HERE,
        base::Bind(&AudioInputRendererHost::DisableDebugRecording,
                   audio_input_renderer_host_));
  }
}

bool RenderProcessHostImpl::StopWebRTCEventLog() {
  return webrtc_eventlog_host_.StopWebRTCEventLog();
}

bool Editor::Command::Execute(const String& parameter,
                              Event* triggering_event) const {
  if (!IsEnabled(triggering_event)) {
    if (!IsSupported() || !frame_ || !command_->allow_execution_when_disabled)
      return false;
  }

  if (source_ == kCommandFromMenuOrKeyBinding) {
    InputEvent::InputType input_type =
        InputTypeFromCommandType(command_->command_type, *frame_);
    if (input_type != InputEvent::InputType::kNone) {
      if (DispatchBeforeInputEditorCommand(
              EventTargetNodeForDocument(frame_->GetDocument()), input_type,
              GetTargetRanges()) != DispatchEventResult::kNotCanceled)
        return true;
    }
  }

  if (frame_->GetDocument()->GetFrame() != frame_)
    return false;

  GetFrame().GetDocument()->UpdateStyleAndLayoutIgnorePendingStylesheets();
  DEFINE_STATIC_LOCAL(SparseHistogram, command_histogram,
                      ("WebCore.Editing.Commands"));
  command_histogram.Sample(static_cast<int>(command_->command_type));
  return command_->execute(*frame_, triggering_event, source_, parameter);
}

static bool ExecuteTranspose(LocalFrame& frame,
Event*,
EditorCommandSource,
const String&) {
  frame.GetEditor().Transpose();
return true;
}

void VRDisplay::ProcessScheduledAnimations(double timestamp) {
// Check if we still have a valid context, the animation controller
// or document may have disappeared since we scheduled this.
Document* doc = this->GetDocument();
  if (!doc || display_blurred_ || !scripted_animation_controller_)
return;

TRACE_EVENT1("gpu", "VRDisplay::OnVSync", "frame", vr_frame_id_);

  AutoReset<bool> animating(&in_animation_frame_, true);
  pending_raf_ = false;
  scripted_animation_controller_->ServiceScriptedAnimations(timestamp);

// For GVR, we shut down normal vsync processing during VR presentation.
// Trigger any callbacks on window.rAF manually so that they run after
// completing the vrDisplay.rAF processing.
if (is_presenting_ && !capabilities_->hasExternalDisplay()) {
Platform::Current()->CurrentThread()->GetWebTaskRunner()->PostTask(
BLINK_FROM_HERE, WTF::Bind(&VRDisplay::ProcessScheduledWindowAnimations,
WrapWeakPersistent(this), timestamp));
}
}

static TriState SelectionListState(const FrameSelection& selection,
                                   const QualifiedName& tag_name) {
  if (selection.ComputeVisibleSelectionInDOMTreeDeprecated().IsCaret()) {
    if (EnclosingElementWithTag(
            selection.ComputeVisibleSelectionInDOMTreeDeprecated().Start(),
            tag_name))
      return kTrueTriState;
  } else if (selection.ComputeVisibleSelectionInDOMTreeDeprecated().IsRange()) {
    Element* start_element = EnclosingElementWithTag(
        selection.ComputeVisibleSelectionInDOMTreeDeprecated().Start(),
        tag_name);
    Element* end_element = EnclosingElementWithTag(
        selection.ComputeVisibleSelectionInDOMTreeDeprecated().End(), tag_name);

    if (start_element && end_element && start_element == end_element) {
      if (HasChildTags(*start_element, tag_name.Matches(ulTag) ? olTag : ulTag))
        return kFalseTriState;
      return kTrueTriState;
    }
  }

  return kFalseTriState;
}

static bool ExecuteUseCSS(LocalFrame& frame,
                          Event*,
                          EditorCommandSource,
                          const String& value) {
  frame.GetEditor().SetShouldStyleWithCSS(
      DeprecatedEqualIgnoringCase(value, "false"));
  return true;
}

void RenderProcessHostImpl::RegisterMojoInterfaces() {
  auto registry = base::MakeUnique<service_manager::InterfaceRegistry>(
      service_manager::mojom::kServiceManager_ConnectorSpec);

  channel_->AddAssociatedInterfaceForIOThread(
      base::Bind(&IndexedDBDispatcherHost::AddBinding, indexed_db_factory_));

#if defined(OS_ANDROID)
  AddUIThreadInterface(registry.get(),
                       GetGlobalJavaInterfaces()
                           ->CreateInterfaceFactory<device::BatteryMonitor>());
  AddUIThreadInterface(
      registry.get(), GetGlobalJavaInterfaces()
                          ->CreateInterfaceFactory<
                              shape_detection::mojom::FaceDetectionProvider>());
  AddUIThreadInterface(
      registry.get(),
      GetGlobalJavaInterfaces()
          ->CreateInterfaceFactory<shape_detection::mojom::BarcodeDetection>());
  AddUIThreadInterface(
      registry.get(),
      GetGlobalJavaInterfaces()
          ->CreateInterfaceFactory<shape_detection::mojom::TextDetection>());
#else
  AddUIThreadInterface(
      registry.get(), base::Bind(&device::BatteryMonitorImpl::Create));
  AddUIThreadInterface(
      registry.get(),
      base::Bind(&ForwardShapeDetectionRequest<
                 shape_detection::mojom::BarcodeDetectionRequest>));
  AddUIThreadInterface(
      registry.get(),
      base::Bind(&ForwardShapeDetectionRequest<
                 shape_detection::mojom::FaceDetectionProviderRequest>));
#endif
  AddUIThreadInterface(
      registry.get(),
      base::Bind(&PermissionServiceContext::CreateService,
                 base::Unretained(permission_service_context_.get())));
  AddUIThreadInterface(registry.get(), base::Bind(&ImageCaptureImpl::Create));

  AddUIThreadInterface(
      registry.get(),
      base::Bind(&PaymentAppContextImpl::CreatePaymentAppManager,
                 base::Unretained(
                     storage_partition_impl_->GetPaymentAppContext())));

  AddUIThreadInterface(
      registry.get(),
      base::Bind(&RenderProcessHostImpl::
                     CreateOffscreenCanvasCompositorFrameSinkProvider,
                 base::Unretained(this)));

  AddUIThreadInterface(registry.get(),
                       base::Bind(&OffscreenCanvasSurfaceFactoryImpl::Create));
  AddUIThreadInterface(
      registry.get(),
      base::Bind(&BackgroundSyncContext::CreateService,
                 base::Unretained(
                     storage_partition_impl_->GetBackgroundSyncContext())));
  AddUIThreadInterface(
      registry.get(),
      base::Bind(&PlatformNotificationContextImpl::CreateService,
                 base::Unretained(
                     storage_partition_impl_->GetPlatformNotificationContext()),
                 GetID()));
  AddUIThreadInterface(
      registry.get(),
      base::Bind(&RenderProcessHostImpl::CreateStoragePartitionService,
                 base::Unretained(this)));
  AddUIThreadInterface(
      registry.get(),
      base::Bind(&BroadcastChannelProvider::Connect,
                 base::Unretained(
                     storage_partition_impl_->GetBroadcastChannelProvider())));
  if (base::FeatureList::IsEnabled(features::kMemoryCoordinator)) {
    AddUIThreadInterface(
        registry.get(), base::Bind(&CreateMemoryCoordinatorHandle, GetID()));
  }

  scoped_refptr<base::SingleThreadTaskRunner> file_task_runner =
      BrowserThread::GetTaskRunnerForThread(BrowserThread::FILE);
  registry->AddInterface(base::Bind(&MimeRegistryImpl::Create),
                         file_task_runner);
#if BUILDFLAG(USE_MINIKIN_HYPHENATION)
  registry->AddInterface(base::Bind(&hyphenation::HyphenationImpl::Create),
                         file_task_runner);
#endif

#if defined(OS_ANDROID)
  AddUIThreadInterface(registry.get(),
                       base::Bind(&device::DeviceLightHost::Create));
  AddUIThreadInterface(registry.get(),
                       base::Bind(&device::DeviceMotionHost::Create));
  AddUIThreadInterface(registry.get(),
                       base::Bind(&device::DeviceOrientationHost::Create));
  AddUIThreadInterface(
      registry.get(),
      base::Bind(&device::DeviceOrientationAbsoluteHost::Create));
#else
  registry->AddInterface(base::Bind(&device::DeviceLightHost::Create));
  registry->AddInterface(base::Bind(&device::DeviceMotionHost::Create));
  registry->AddInterface(base::Bind(&device::DeviceOrientationHost::Create));
  registry->AddInterface(
      base::Bind(&device::DeviceOrientationAbsoluteHost::Create));
#endif  // defined(OS_ANDROID)

  registry->AddInterface(base::Bind(&device::GamepadMonitor::Create));

  registry->AddInterface(base::Bind(&RenderProcessHostImpl::CreateMusGpuRequest,
                                    base::Unretained(this)));

  registry->AddInterface(
      base::Bind(&VideoCaptureHost::Create,
                 BrowserMainLoop::GetInstance()->media_stream_manager()));

  AddUIThreadInterface(
      registry.get(), base::Bind(&WebSocketManager::CreateWebSocket, GetID(),
                                 MSG_ROUTING_NONE));

  if (!service_manager::ServiceManagerIsRemote()) {
    discardable_memory::DiscardableSharedMemoryManager* manager =
        BrowserMainLoop::GetInstance()->discardable_shared_memory_manager();
    registry->AddInterface(
        base::Bind(&discardable_memory::DiscardableSharedMemoryManager::Bind,
                   base::Unretained(manager)));
  }

  GetContentClient()->browser()->ExposeInterfacesToRenderer(registry.get(),
                                                            this);

  ServiceManagerConnection* service_manager_connection =
      BrowserContext::GetServiceManagerConnectionFor(browser_context_);
  std::unique_ptr<ConnectionFilterImpl> connection_filter(
      new ConnectionFilterImpl(child_connection_->child_identity(),
                               std::move(registry)));
  connection_filter_controller_ = connection_filter->controller();
  connection_filter_id_ = service_manager_connection->AddConnectionFilter(
      std::move(connection_filter));
}

void VRDisplay::BeginPresent() {
  Document* doc = this->GetDocument();
  if (capabilities_->hasExternalDisplay()) {
    ForceExitPresent();
    DOMException* exception = DOMException::Create(
        kInvalidStateError,
        "VR Presentation not implemented for this VRDisplay.");
    while (!pending_present_resolvers_.IsEmpty()) {
      ScriptPromiseResolver* resolver = pending_present_resolvers_.TakeFirst();
      resolver->Reject(exception);
    }
    ReportPresentationResult(
        PresentationResult::kPresentationNotSupportedByDisplay);
    return;
  } else {
    if (layer_.source().isHTMLCanvasElement()) {
    } else {
      DCHECK(layer_.source().isOffscreenCanvas());
      ForceExitPresent();
      DOMException* exception = DOMException::Create(
          kInvalidStateError, "OffscreenCanvas presentation not implemented.");
      while (!pending_present_resolvers_.IsEmpty()) {
        ScriptPromiseResolver* resolver =
            pending_present_resolvers_.TakeFirst();
        resolver->Reject(exception);
      }
      ReportPresentationResult(
          PresentationResult::kPresentationNotSupportedByDisplay);
      return;
    }
  }

  if (doc) {
    Platform::Current()->RecordRapporURL("VR.WebVR.PresentSuccess",
                                         WebURL(doc->Url()));
  }

  is_presenting_ = true;
  ReportPresentationResult(PresentationResult::kSuccess);

  UpdateLayerBounds();

  while (!pending_present_resolvers_.IsEmpty()) {
    ScriptPromiseResolver* resolver = pending_present_resolvers_.TakeFirst();
     resolver->Resolve();
   }
   OnPresentChange();
 }

static bool ExecuteUndo(LocalFrame& frame,
                        Event*,
                        EditorCommandSource,
                        const String&) {
  frame.GetEditor().Undo();
  return true;
}

bool FoobarIndexIsOdd(const std::string& foobarx_com) {
   return (foobarx_com[6] - '0') % 2 == 1;
 }

VREye StringToVREye(const String& which_eye) {
  if (which_eye == "left")
    return kVREyeLeft;
  if (which_eye == "right")
    return kVREyeRight;
  return kVREyeNone;
}

float HarfBuzzShaper::HarfBuzzRun::xPositionForOffset(unsigned offset)
{
    ASSERT(offset < m_numCharacters);
    unsigned glyphIndex = 0;
    float position = 0;
    if (rtl()) {
        while (glyphIndex < m_numGlyphs && m_glyphToCharacterIndexes[glyphIndex] > offset) {
            position += m_advances[glyphIndex];
            ++glyphIndex;
        }
        while (glyphIndex < m_numGlyphs - 1 && m_glyphToCharacterIndexes[glyphIndex] == m_glyphToCharacterIndexes[glyphIndex + 1]) {
            position += m_advances[glyphIndex];
            ++glyphIndex;
        }
        position += m_advances[glyphIndex];
    } else {
        while (glyphIndex < m_numGlyphs && m_glyphToCharacterIndexes[glyphIndex] < offset) {
            position += m_advances[glyphIndex];
            ++glyphIndex;
        }
    }
    return position;
}

static bool ExecuteMoveToEndOfParagraphAndModifySelection(LocalFrame& frame,
                                                          Event*,
                                                          EditorCommandSource,
                                                          const String&) {
  frame.Selection().Modify(
      SelectionModifyAlteration::kExtend, SelectionModifyDirection::kForward,
      TextGranularity::kParagraphBoundary, SetSelectionBy::kUser);
  return true;
}

void VRDisplay::OnSubmitFrameRendered() {
  pending_previous_frame_render_ = false;
}

  const UsbDevice::OpenCallback& callback() const { return callback_; }

bool VRDisplay::HasPendingActivity() const {
  return GetExecutionContext() && HasEventListeners();
}

std::string GenerateGetUserMediaWithOptionalSourceID(
    const std::string& function_name,
    const std::string& audio_source_id,
    const std::string& video_source_id) {
  const std::string audio_constraint =
      "audio: {optional: [{sourceId:\"" + audio_source_id + "\"}]}, ";

  const std::string video_constraint =
      "video: {optional: [{ sourceId:\"" + video_source_id + "\"}]}";
  return function_name + "({" + audio_constraint + video_constraint + "});";
}

  void Create() {
    Create(kDefaultDeviceId, url::Origin(GURL(kSecurityOrigin)), true, true);
  }

ImageLoader::ImageLoader(Element* element)
: m_element(element),
      m_derefElementTimer(this, &ImageLoader::timerFired),
m_hasPendingLoadEvent(false),
m_hasPendingErrorEvent(false),
m_imageComplete(true),
m_loadingImageDocument(false),
m_elementIsProtected(false),
m_suppressErrorEvents(false) {
RESOURCE_LOADING_DVLOG(1) << "new ImageLoader " << this;
}

void VRDisplay::OnDeactivate(
    device::mojom::blink::VRDisplayEventReason reason) {
  navigator_vr_->EnqueueVREvent(VRDisplayEvent::Create(
      EventTypeNames::vrdisplaydeactivate, true, false, this, reason));
}

void VRDisplay::OnActivate(device::mojom::blink::VRDisplayEventReason reason) {
  AutoReset<bool> activating(&in_display_activate_, true);
  navigator_vr_->DispatchVREvent(VRDisplayEvent::Create(
      EventTypeNames::vrdisplayactivate, true, false, this, reason));
}

bool RenderProcessHostImpl::OnMessageReceived(const IPC::Message& msg) {

  if (deleting_soon_ || fast_shutdown_started_)
    return false;

  mark_child_process_activity_time();
  if (msg.routing_id() == MSG_ROUTING_CONTROL) {
    IPC_BEGIN_MESSAGE_MAP(RenderProcessHostImpl, msg)
      IPC_MESSAGE_HANDLER(ChildProcessHostMsg_ShutdownRequest,
                          OnShutdownRequest)
      IPC_MESSAGE_HANDLER(RenderProcessHostMsg_SuddenTerminationChanged,
                          SuddenTerminationChanged)
      IPC_MESSAGE_HANDLER(ViewHostMsg_UserMetricsRecordAction,
                          OnUserMetricsRecordAction)
      IPC_MESSAGE_HANDLER(ViewHostMsg_Close_ACK, OnCloseACK)
#if BUILDFLAG(ENABLE_WEBRTC)
      IPC_MESSAGE_HANDLER(AecDumpMsg_RegisterAecDumpConsumer,
                          OnRegisterAecDumpConsumer)
      IPC_MESSAGE_HANDLER(AecDumpMsg_UnregisterAecDumpConsumer,
                          OnUnregisterAecDumpConsumer)
#endif
    IPC_END_MESSAGE_MAP()

    return true;
  }

  IPC::Listener* listener = listeners_.Lookup(msg.routing_id());
  if (!listener) {
    if (msg.is_sync()) {
      IPC::Message* reply = IPC::SyncMessage::GenerateReply(&msg);
      reply->set_reply_error();
      Send(reply);
    }
    return true;
  }
  return listener->OnMessageReceived(msg);
}

static bool ExecuteInsertNewlineInQuotedContent(LocalFrame& frame,
                                                Event*,
                                                EditorCommandSource,
                                                const String&) {
  DCHECK(frame.GetDocument());
  return TypingCommand::InsertParagraphSeparatorInQuotedContent(
      *frame.GetDocument());
}

static String ValueForeColor(const EditorInternalCommand&,
                             LocalFrame& frame,
                             Event*) {
  return ValueStyle(frame, CSSPropertyColor);
}

void AudioRendererHost::DidValidateRenderFrame(int stream_id, bool is_valid) {
  DCHECK_CURRENTLY_ON(BrowserThread::IO);

  if (is_valid)
    return;

  DLOG(WARNING) << "Render frame for stream (id=" << stream_id
                << ") no longer exists.";
  OnStreamError(stream_id);
}

static bool ExecuteMoveParagraphForward(LocalFrame& frame,
                                        Event*,
                                        EditorCommandSource,
                                        const String&) {
  frame.Selection().Modify(SelectionModifyAlteration::kMove,
                           SelectionModifyDirection::kForward,
                           TextGranularity::kParagraph, SetSelectionBy::kUser);
  return true;
}

void RenderProcessHostImpl::ConnectionFilterController::DisableFilter() {
  base::AutoLock lock(lock_);
  if (filter_)
    filter_->Disable();
}

void VRDisplay::OnSubmitFrameTransferred() {
  pending_submit_frame_ = false;
}

static unsigned VerticalScrollDistance(LocalFrame& frame) {
  Element* focused_element = frame.GetDocument()->FocusedElement();
  if (!focused_element)
    return 0;
  LayoutObject* layout_object = focused_element->GetLayoutObject();
  if (!layout_object || !layout_object->IsBox())
    return 0;
  LayoutBox& layout_box = ToLayoutBox(*layout_object);
  const ComputedStyle* style = layout_box.Style();
  if (!style)
    return 0;
  if (!(style->OverflowY() == EOverflow::kScroll ||
        style->OverflowY() == EOverflow::kAuto ||
        HasEditableStyle(*focused_element)))
    return 0;
  int height = std::min<int>(layout_box.ClientHeight().ToInt(),
                             frame.View()->VisibleHeight());
  return static_cast<unsigned>(
      max(max<int>(height * ScrollableArea::MinFractionToStepWhenPaging(),
                   height - ScrollableArea::MaxOverlapBetweenPages()),
          1));
}

InputEvent::InputType InputTypeFromCommandType(
    WebEditingCommandType command_type,
    LocalFrame& frame) {
  using CommandType = WebEditingCommandType;
  using InputType = InputEvent::InputType;

  if (command_type == CommandType::kInsertNewline)
    return frame.GetEditor().CanEditRichly() ? InputType::kInsertParagraph
                                             : InputType::kInsertLineBreak;

  switch (command_type) {
    case CommandType::kInsertBacktab:
    case CommandType::kInsertText:
      return InputType::kInsertText;
    case CommandType::kInsertLineBreak:
      return InputType::kInsertLineBreak;
    case CommandType::kInsertParagraph:
    case CommandType::kInsertNewlineInQuotedContent:
      return InputType::kInsertParagraph;
    case CommandType::kInsertHorizontalRule:
      return InputType::kInsertHorizontalRule;
    case CommandType::kInsertOrderedList:
      return InputType::kInsertOrderedList;
    case CommandType::kInsertUnorderedList:
      return InputType::kInsertUnorderedList;

    case CommandType::kDelete:
    case CommandType::kDeleteBackward:
    case CommandType::kDeleteBackwardByDecomposingPreviousCharacter:
      return InputType::kDeleteContentBackward;
    case CommandType::kDeleteForward:
      return InputType::kDeleteContentForward;
    case CommandType::kDeleteToBeginningOfLine:
      return InputType::kDeleteSoftLineBackward;
    case CommandType::kDeleteToEndOfLine:
      return InputType::kDeleteSoftLineForward;
    case CommandType::kDeleteWordBackward:
      return InputType::kDeleteWordBackward;
    case CommandType::kDeleteWordForward:
      return InputType::kDeleteWordForward;
    case CommandType::kDeleteToBeginningOfParagraph:
      return InputType::kDeleteHardLineBackward;
    case CommandType::kDeleteToEndOfParagraph:
      return InputType::kDeleteHardLineForward;
    case CommandType::kDeleteToMark:
      return InputType::kNone;

    case CommandType::kUndo:
      return InputType::kHistoryUndo;
    case CommandType::kRedo:
      return InputType::kHistoryRedo;

    case CommandType::kBold:
    case CommandType::kToggleBold:
      return InputType::kFormatBold;
    case CommandType::kItalic:
    case CommandType::kToggleItalic:
      return InputType::kFormatItalic;
    case CommandType::kUnderline:
    case CommandType::kToggleUnderline:
      return InputType::kFormatUnderline;
    case CommandType::kStrikethrough:
      return InputType::kFormatStrikeThrough;
    case CommandType::kSuperscript:
      return InputType::kFormatSuperscript;
    case CommandType::kSubscript:
      return InputType::kFormatSubscript;
    default:
      return InputType::kNone;
  }
}

static bool ExecuteToggleStyle(LocalFrame& frame,
                               EditorCommandSource source,
                               InputEvent::InputType input_type,
                               CSSPropertyID property_id,
                               const char* off_value,
                               const char* on_value) {

  bool style_is_present;
  if (frame.GetEditor().Behavior().ShouldToggleStyleBasedOnStartOfSelection())
    style_is_present =
        frame.GetEditor().SelectionStartHasStyle(property_id, on_value);
  else
    style_is_present = frame.GetEditor().SelectionHasStyle(
                           property_id, on_value) == kTrueTriState;

  EditingStyle* style = EditingStyle::Create(
      property_id, style_is_present ? off_value : on_value);
  return ApplyCommandToFrame(frame, source, input_type, style->Style());
}

static inline hb_script_t ICUScriptToHBScript(UScriptCode script)
{
    if (UNLIKELY(script == USCRIPT_INVALID_CODE))
        return HB_SCRIPT_INVALID;

    return hb_script_from_string(uscript_getShortName(script), -1);
}

static bool ExecuteDeleteToMark(LocalFrame& frame,
                                Event*,
                                EditorCommandSource,
                                const String&) {
  const EphemeralRange mark =
      frame.GetEditor().Mark().ToNormalizedEphemeralRange();
  if (mark.IsNotNull()) {
    frame.Selection().SetSelection(
        SelectionInDOMTree::Builder()
            .SetBaseAndExtent(
                UnionEphemeralRanges(mark, frame.GetEditor().SelectedRange()))
            .Build(),
        FrameSelection::kCloseTyping);
  }
  frame.GetEditor().PerformDelete();
  frame.GetEditor().SetMark(
      frame.Selection().ComputeVisibleSelectionInDOMTreeDeprecated());
  return true;
}

bool HarfBuzzShaper::createHarfBuzzRuns()
{
    if (m_normalizedBufferLength == 1)
        return createHarfBuzzRunsForSingleCharacter();

    Vector<CandidateRun> candidateRuns;
    if (!collectCandidateRuns(m_normalizedBuffer.get(),
        m_normalizedBufferLength, m_font, &candidateRuns, m_run.normalizeSpace()))
        return false;

    if (!resolveCandidateRuns(candidateRuns))
        return false;

    size_t length = candidateRuns.size();
    for (size_t i = 0; i < length; ) {
        CandidateRun& run = candidateRuns[i];
        CandidateRun lastMatchingRun = run;
        for (i++; i < length; i++) {
            if (candidateRuns[i].script != run.script
                || candidateRuns[i].fontData != run.fontData)
                break;
            lastMatchingRun = candidateRuns[i];
        }
        addHarfBuzzRun(run.start, lastMatchingRun.end, run.fontData, run.script);
    }
    return !m_harfBuzzRuns.isEmpty();
}

HarfBuzzRunCache::HarfBuzzRunCache()
{
}

    void set(T* ptr) { m_ptr = ptr; }

bool RenderProcessHostImpl::IsProcessBackgrounded() const {
  return is_process_backgrounded_;
}

void RenderProcessHostImpl::OnShutdownRequest() {
  if (pending_views_ || run_renderer_in_process() || GetActiveViewCount() > 0)
    return;

  for (auto& observer : observers_)
    observer.RenderProcessWillExit(this);

  Send(new ChildProcessMsg_Shutdown());
}

static inline bool pageIsBeingDismissed(Document* document) {
  return document->pageDismissalEventBeingDispatched() != Document::NoDismissal;
}

static inline bool matchesAdjacentRun(UScriptCode* scriptExtensions, int length,
    CandidateRun& adjacentRun)
{
    for (int i = 0; i < length; i++) {
        if (scriptExtensions[i] == adjacentRun.script)
            return true;
    }
    return false;
}

void RenderProcessHostImpl::OnAudioStreamRemoved() {
  DCHECK_GT(audio_stream_count_, 0);
  --audio_stream_count_;
  UpdateProcessPriority();
}

void AudioOutputAuthorizationHandler::TranslateDeviceID(
    AuthorizationCompletedCallback cb,
    const std::string& device_id,
    const url::Origin& security_origin,
    const MediaDeviceEnumeration& enumeration) const {
  DCHECK_CURRENTLY_ON(BrowserThread::IO);
  DCHECK(!media::AudioDeviceDescription::IsDefaultDevice(device_id));
  for (const MediaDeviceInfo& device_info :
       enumeration[MEDIA_DEVICE_TYPE_AUDIO_OUTPUT]) {
    if (content::DoesMediaDeviceIDMatchHMAC(salt_, security_origin, device_id,
                                            device_info.device_id)) {
      GetDeviceParameters(std::move(cb), device_info.device_id);
      return;
    }
  }
  cb.Run(media::OUTPUT_DEVICE_STATUS_ERROR_NOT_FOUND, false,
         media::AudioParameters::UnavailableDeviceParams(), std::string());
}

  void CreateDeviceAssociation(const std::string& input_device_id,
                               const std::string& output_device_id) {
    EXPECT_FALSE(IsValidDeviceId(input_device_id));
    EXPECT_FALSE(IsValidDeviceId(output_device_id));

    associations_[input_device_id] = output_device_id;
  }

 void Editor::AddToKillRing(const EphemeralRange& range) {
  if (should_start_new_kill_ring_sequence_)
    GetKillRing().StartNewSequence();

  DCHECK(!GetFrame().GetDocument()->NeedsLayoutTreeUpdate());
  String text = PlainText(range);
  GetKillRing().Append(text);
  should_start_new_kill_ring_sequence_ = false;
}

inline void ImageLoader::crossSiteOrCSPViolationOccurred(
    AtomicString imageSourceURL) {
  m_failedLoadURL = imageSourceURL;
}

String Editor::Command::Value(Event* triggering_event) const {
  if (!IsSupported() || !frame_)
    return String();
  return command_->value(*command_, *frame_, triggering_event);
}

static bool ExecuteMoveToEndOfDocumentAndModifySelection(LocalFrame& frame,
                                                         Event*,
                                                         EditorCommandSource,
                                                         const String&) {
  frame.Selection().Modify(
      SelectionModifyAlteration::kExtend, SelectionModifyDirection::kForward,
      TextGranularity::kDocumentBoundary, SetSelectionBy::kUser);
  return true;
}

static bool ExecuteJustifyRight(LocalFrame& frame,
                                Event*,
                                EditorCommandSource source,
                                const String&) {
  return ExecuteApplyParagraphStyle(frame, source,
                                    InputEvent::InputType::kFormatJustifyRight,
                                    CSSPropertyTextAlign, "right");
}

inline void HarfBuzzRunCache::remove(CachedShapingResults* node)
{
    CachedShapingResultsLRUNode* lruNode = *node->lru;

    m_harfBuzzRunLRU.erase(node->lru);
    m_harfBuzzRunMap.erase(lruNode->entry);
    delete lruNode;
    delete node;
}

  void OnTraceDataCollected(
      const scoped_refptr<base::RefCountedString>& events_str_ptr,
      bool has_more_events) {
    CHECK(!has_more_events);
    recorded_trace_data_ = events_str_ptr;
    message_loop_runner_->Quit();
  }

static ImageLoader::BypassMainWorldBehavior shouldBypassMainWorldCSP(
    ImageLoader* loader) {
  DCHECK(loader);
  DCHECK(loader->element());
  if (loader->element()->document().frame() &&
      loader->element()
          ->document()
          .frame()
          ->script()
          .shouldBypassMainWorldCSP())
    return ImageLoader::BypassMainWorldCSP;
  return ImageLoader::DoNotBypassMainWorldCSP;
}

HostCache::Entry::Entry(int error, const AddressList& addresses)
    : error_(error),
      addresses_(addresses),
      ttl_(base::TimeDelta::FromSeconds(-1)) {}

static bool ExecuteInsertUnorderedList(LocalFrame& frame,
                                       Event*,
                                       EditorCommandSource,
                                       const String&) {
  DCHECK(frame.GetDocument());
  return InsertListCommand::Create(*frame.GetDocument(),
                                   InsertListCommand::kUnorderedList)
      ->Apply();
}

bool Editor::Command::Execute(Event* triggering_event) const {
  return Execute(String(), triggering_event);
}

float HarfBuzzShaper::nextExpansionPerOpportunity()
{
    if (!m_expansionOpportunityCount) {
        ASSERT_NOT_REACHED(); // failures indicate that the logic in HarfBuzzShaper does not match to the one in expansionOpportunityCount()
        return 0;
    }
    if (!--m_expansionOpportunityCount) {
        float remaining = m_expansion;
        m_expansion = 0;
        return remaining;
    }
    m_expansion -= m_expansionPerOpportunity;
    return m_expansionPerOpportunity;
}

  FakeAudioManagerWithAssociations(
      scoped_refptr<base::SingleThreadTaskRunner> task_runner,
      media::AudioLogFactory* factory)
      : FakeAudioManager(task_runner, task_runner, factory) {}

static TriState StateUnderline(LocalFrame& frame, Event*) {
  return StateStyle(frame, CSSPropertyWebkitTextDecorationsInEffect,
                    "underline");
}

static inline void resolveRunBasedOnScriptExtensions(Vector<CandidateRun>& runs,
    CandidateRun& run, size_t i, size_t length, UScriptCode* scriptExtensions,
    int extensionsLength, size_t& nextResolvedRun)
{
    if (extensionsLength <= 1)
        return;

    if (i > 0 && matchesAdjacentRun(scriptExtensions, extensionsLength, runs[i - 1])) {
        run.script = runs[i - 1].script;
        return;
    }

    for (size_t j = i + 1; j < length; j++) {
        if (runs[j].script != USCRIPT_COMMON
            && runs[j].script != USCRIPT_INHERITED
            && matchesAdjacentRun(scriptExtensions, extensionsLength, runs[j])) {
            nextResolvedRun = j;
            break;
        }
    }
}

void RenderProcessHostImpl::RegisterAecDumpConsumerOnUIThread(int id) {
  DCHECK_CURRENTLY_ON(BrowserThread::UI);
  aec_dump_consumers_.push_back(id);

  if (WebRTCInternals::GetInstance()->IsAudioDebugRecordingsEnabled()) {
    base::FilePath file_with_extensions = GetAecDumpFilePathWithExtensions(
        WebRTCInternals::GetInstance()->GetAudioDebugRecordingsFilePath());
    EnableAecDumpForId(file_with_extensions, id);
  }
}

  void Pause() {
    host_->OnPauseStream(kStreamId);
    SyncWithAudioThread();
  }

void VRDisplay::ConnectVSyncProvider() {
DVLOG(1) << __FUNCTION__
<< ": IsPresentationFocused()=" << IsPresentationFocused()
<< " vr_v_sync_provider_.is_bound()="
<< vr_v_sync_provider_.is_bound();
if (!IsPresentationFocused() || vr_v_sync_provider_.is_bound())
return;
display_->GetVRVSyncProvider(mojo::MakeRequest(&vr_v_sync_provider_));
vr_v_sync_provider_.set_connection_error_handler(ConvertToBaseCallback(
WTF::Bind(&VRDisplay::OnVSyncConnectionError, WrapWeakPersistent(this))));
  if (pending_raf_ && !display_blurred_) {
pending_vsync_ = true;
vr_v_sync_provider_->GetVSync(ConvertToBaseCallback(
WTF::Bind(&VRDisplay::OnVSync, WrapWeakPersistent(this))));
}
}

static bool ExecuteMoveBackward(LocalFrame& frame,
                                Event*,
                                EditorCommandSource,
                                const String&) {
  frame.Selection().Modify(SelectionModifyAlteration::kMove,
                           SelectionModifyDirection::kBackward,
                           TextGranularity::kCharacter, SetSelectionBy::kUser);
  return true;
}

HostCache::Entry* HostCache::LookupInternal(const Key& key) {
  auto it = entries_.find(key);
  return (it != entries_.end()) ? &it->second : nullptr;
}

void RenderProcessHostImpl::OnChannelError() {
  ProcessDied(true /* already_dead */, nullptr);
}

  void Play() {
    host_->OnPlayStream(kStreamId);
    SyncWithAudioThread();
  }

void RenderProcessHostImpl::OnProcessLaunched() {
  if (deleting_soon_)
    return;

  if (child_process_launcher_) {
    DCHECK(child_process_launcher_->GetProcess().IsValid());
    DCHECK(!is_process_backgrounded_);

    channel_->Unpause(false /* flush */);

    if (child_connection_) {
      child_connection_->SetProcessHandle(
          child_process_launcher_->GetProcess().Handle());
    }

#if defined(OS_MACOSX)
    is_process_backgrounded_ =
        child_process_launcher_->GetProcess().IsProcessBackgrounded(
            MachBroker::GetInstance());
#else
    is_process_backgrounded_ =
        child_process_launcher_->GetProcess().IsProcessBackgrounded();
#endif  // defined(OS_MACOSX)

#if defined(OS_ANDROID)
    UpdateProcessPriority();
#endif

    CreateSharedRendererHistogramAllocator();
  }

  NotificationService::current()->Notify(NOTIFICATION_RENDERER_PROCESS_CREATED,
                                         Source<RenderProcessHost>(this),
                                         NotificationService::NoDetails());

  if (child_process_launcher_)
    channel_->Flush();

  if (IsReady()) {
    DCHECK(!sent_render_process_ready_);
    sent_render_process_ready_ = true;
    for (auto& observer : observers_)
      observer.RenderProcessReady(this);
  }

#if BUILDFLAG(ENABLE_WEBRTC)
  if (WebRTCInternals::GetInstance()->IsAudioDebugRecordingsEnabled()) {
    EnableAudioDebugRecordings(
        WebRTCInternals::GetInstance()->GetAudioDebugRecordingsFilePath());
  }
#endif
}

static void configureRequest(
    FetchRequest& request,
    ImageLoader::BypassMainWorldBehavior bypassBehavior,
    Element& element,
    const ClientHintsPreferences& clientHintsPreferences) {
  if (bypassBehavior == ImageLoader::BypassMainWorldCSP)
    request.setContentSecurityCheck(DoNotCheckContentSecurityPolicy);

  CrossOriginAttributeValue crossOrigin = crossOriginAttributeValue(
      element.fastGetAttribute(HTMLNames::crossoriginAttr));
  if (crossOrigin != CrossOriginAttributeNotSet) {
    request.setCrossOriginAccessControl(element.document().getSecurityOrigin(),
                                        crossOrigin);
  }

  if (clientHintsPreferences.shouldSendResourceWidth() &&
      isHTMLImageElement(element))
    request.setResourceWidth(toHTMLImageElement(element).getResourceWidth());
}

  void RunGetUserMediaAndCollectMeasures(const int time_to_sample_secs,
                                         const std::string& measure_filter,
                                         const std::string& graph_name) {
    ASSERT_TRUE(embedded_test_server()->InitializeAndWaitUntilReady());

    GURL url(embedded_test_server()->GetURL("/media/getusermedia.html"));
    NavigateToURL(shell(), url);

    DCHECK(time_to_sample_secs);
    ExecuteJavascriptAndWaitForOk(
        base::StringPrintf("%s({video: true}, 'myStreamName');",
                           kGetUserMediaAndGetStreamUp));

    StartTracing();

    ExecuteJavascriptAndWaitForOk(
        base::StringPrintf("waitAndStopVideoTrack(window['myStreamName'], %d);",
                           time_to_sample_secs));

    StopTracing();

    scoped_ptr<TraceAnalyzer> analyzer(CreateTraceAnalyzer());
    analyzer->AssociateBeginEndEvents();
    trace_analyzer::TraceEventVector events;
    DCHECK(measure_filter.size());
    analyzer->FindEvents(
        Query::EventNameIs(measure_filter),
        &events);
    ASSERT_GT(events.size(), 0u)
        << "Could not collect any samples during test, this is bad";

    std::string duration_us;
    std::string interarrival_us;
    for (size_t i = 0; i != events.size(); ++i) {
      duration_us.append(
          base::StringPrintf("%d,", static_cast<int>(events[i]->duration)));
    }

    for (size_t i = 1; i < events.size(); ++i) {
      interarrival_us.append(base::StringPrintf("%d,",
          static_cast<int>((events[i]->timestamp - events[i - 1]->timestamp) /
                           base::Time::kNanosecondsPerMicrosecond)));
    }

    perf_test::PrintResultList(
        graph_name, "", "sample_duration", duration_us, "us", true);

    perf_test::PrintResultList(
        graph_name, "", "interarrival_time", interarrival_us, "us", true);
  }

CachedShapingResultsLRUNode::~CachedShapingResultsLRUNode()
{
}

static bool ExecuteMoveDown(LocalFrame& frame,
                            Event*,
                            EditorCommandSource,
                            const String&) {
  return frame.Selection().Modify(
      SelectionModifyAlteration::kMove, SelectionModifyDirection::kForward,
      TextGranularity::kLine, SetSelectionBy::kUser);
}

static String ValueFontSize(const EditorInternalCommand&,
                            LocalFrame& frame,
                            Event*) {
  return ValueStyle(frame, CSSPropertyFontSize);
}

  void StartTracing() {
    CHECK(trace_log_ == NULL) << "Can only can start tracing once";
    trace_log_ = base::trace_event::TraceLog::GetInstance();
    base::trace_event::TraceOptions trace_options(
        base::trace_event::RECORD_UNTIL_FULL);
    trace_options.enable_sampling = true;
    trace_log_->SetEnabled(base::trace_event::CategoryFilter("video"),
                           base::trace_event::TraceLog::RECORDING_MODE,
                           trace_options);
    EXPECT_EQ(trace_log_->GetNumTracesRecorded(), 1);
  }

bool RenderProcessHostImpl::IsSuitableHost(RenderProcessHost* host,
                                           BrowserContext* browser_context,
                                           const GURL& site_url) {
  if (run_renderer_in_process()) {
    DCHECK_EQ(host->GetBrowserContext(), browser_context)
        << " Single-process mode does not support multiple browser contexts.";
    return true;
  }

  if (host->GetBrowserContext() != browser_context)
    return false;

  if (host->IsForGuestsOnly())
    return false;

  StoragePartition* dest_partition =
      BrowserContext::GetStoragePartitionForSite(browser_context, site_url);
  if (!host->InSameStoragePartition(dest_partition))
    return false;

  if (ChildProcessSecurityPolicyImpl::GetInstance()->HasWebUIBindings(
          host->GetID()) !=
      WebUIControllerFactoryRegistry::GetInstance()->UseWebUIBindingsForURL(
          browser_context, site_url)) {
    return false;
  }

  return GetContentClient()->browser()->IsSuitableHost(host, site_url);
}

  const UserMediaSizes& user_media() const { return user_media_; }

static TriState StateStrikethrough(LocalFrame& frame, Event*) {
  return StateStyle(frame, CSSPropertyWebkitTextDecorationsInEffect,
                    "line-through");
}

static bool ExecuteMakeTextWritingDirectionRightToLeft(LocalFrame& frame,
                                                       Event*,
                                                       EditorCommandSource,
                                                       const String&) {
  MutableStylePropertySet* style =
      MutableStylePropertySet::Create(kHTMLQuirksMode);
  style->SetProperty(CSSPropertyUnicodeBidi, CSSValueIsolate);
  style->SetProperty(CSSPropertyDirection, CSSValueRtl);
  frame.GetEditor().ApplyStyle(
      style, InputEvent::InputType::kFormatSetBlockTextDirection);
  return true;
}

void HarfBuzzShaper::setExpansion(float padding)
{
    m_expansion = padding;
    if (!m_expansion)
        return;

    bool isAfterExpansion = m_isAfterExpansion;
    m_expansionOpportunityCount = Character::expansionOpportunityCount(m_normalizedBuffer.get(), m_normalizedBufferLength, m_run.direction(), isAfterExpansion, m_run.textJustify());
    if (isAfterExpansion && !m_run.allowsTrailingExpansion()) {
        ASSERT(m_expansionOpportunityCount > 0);
        --m_expansionOpportunityCount;
    }

    if (m_expansionOpportunityCount)
        m_expansionPerOpportunity = m_expansion / m_expansionOpportunityCount;
    else
        m_expansionPerOpportunity = 0;
}

void HarfBuzzShaper::addHarfBuzzRun(unsigned startCharacter,
    unsigned endCharacter, const SimpleFontData* fontData,
    UScriptCode script)
{
    ASSERT(endCharacter > startCharacter);
    ASSERT(script != USCRIPT_INVALID_CODE);
    if (m_fallbackFonts)
        trackNonPrimaryFallbackFont(fontData);
    return m_harfBuzzRuns.append(HarfBuzzRun::create(fontData,
        startCharacter, endCharacter - startCharacter,
        TextDirectionToHBDirection(m_run.direction(), m_font->fontDescription().orientation(), fontData),
        ICUScriptToHBScript(script)));
}

static bool ExecuteDefaultParagraphSeparator(LocalFrame& frame,
                                             Event*,
                                             EditorCommandSource,
                                             const String& value) {
  if (DeprecatedEqualIgnoringCase(value, "div"))
    frame.GetEditor().SetDefaultParagraphSeparator(
        kEditorParagraphSeparatorIsDiv);
  else if (DeprecatedEqualIgnoringCase(value, "p"))
    frame.GetEditor().SetDefaultParagraphSeparator(
        kEditorParagraphSeparatorIsP);

  return true;
}

void AudioRendererHost::OnCreateStream(int stream_id,
                                       int render_frame_id,
                                       const media::AudioParameters& params) {
  DCHECK_CURRENTLY_ON(BrowserThread::IO);
  DVLOG(1) << "AudioRendererHost@" << this << "::OnCreateStream"
           << "(stream_id=" << stream_id << ")";

  std::string device_unique_id;
  const auto& auth_data = authorizations_.find(stream_id);
  if (auth_data != authorizations_.end()) {
    if (!auth_data->second.first) {
      content::bad_message::ReceivedBadMessage(
          this, bad_message::ARH_CREATED_STREAM_WITHOUT_AUTHORIZATION);
      return;
    }
    device_unique_id.swap(auth_data->second.second);
    authorizations_.erase(auth_data);
  }

  if (LookupById(stream_id)) {
    SendErrorMessage(stream_id);
    return;
  }
  if (render_frame_id <= 0) {
    SendErrorMessage(stream_id);
    return;
  }

  BrowserThread::PostTask(
      BrowserThread::UI, FROM_HERE,
      base::Bind(validate_render_frame_id_function_, render_process_id_,
                 render_frame_id,
                 base::Bind(&AudioRendererHost::DidValidateRenderFrame, this,
                            stream_id)));

  MediaObserver* const media_observer =
      GetContentClient()->browser()->GetMediaObserver();

  MediaInternals* const media_internals = MediaInternals::GetInstance();
  std::unique_ptr<media::AudioLog> audio_log = media_internals->CreateAudioLog(
      media::AudioLogFactory::AUDIO_OUTPUT_CONTROLLER);
  media_internals->SetWebContentsTitleForAudioLogEntry(
      stream_id, render_process_id_, render_frame_id, audio_log.get());
  delegates_.push_back(
      base::WrapUnique<AudioOutputDelegate>(new AudioOutputDelegateImpl(
          this, audio_manager_, std::move(audio_log), mirroring_manager_,
          media_observer, stream_id, render_frame_id, render_process_id_,
          params, device_unique_id)));
}

static bool ExecuteForeColor(LocalFrame& frame,
                             Event*,
                             EditorCommandSource source,
                             const String& value) {
  return ExecuteApplyStyle(frame, source, InputEvent::InputType::kNone,
                           CSSPropertyColor, value);
}

RenderProcessHostImpl::RenderProcessHostImpl(
    BrowserContext* browser_context,
    StoragePartitionImpl* storage_partition_impl,
    bool is_for_guests_only)
    : fast_shutdown_started_(false),
      deleting_soon_(false),
#ifndef NDEBUG
      is_self_deleted_(false),
#endif
      pending_views_(0),
      service_worker_ref_count_(0),
      shared_worker_ref_count_(0),
      is_worker_ref_count_disabled_(false),
      route_provider_binding_(this),
      visible_widgets_(0),
      is_process_backgrounded_(false),
      id_(ChildProcessHostImpl::GenerateChildProcessUniqueId()),
      browser_context_(browser_context),
      storage_partition_impl_(storage_partition_impl),
      sudden_termination_allowed_(true),
      ignore_input_events_(false),
      is_for_guests_only_(is_for_guests_only),
      gpu_observer_registered_(false),
      delayed_cleanup_needed_(false),
      within_process_died_observer_(false),
#if BUILDFLAG(ENABLE_WEBRTC)
      webrtc_eventlog_host_(id_),
#endif
      permission_service_context_(new PermissionServiceContext(this)),
      indexed_db_factory_(new IndexedDBDispatcherHost(
          id_,
          storage_partition_impl_->GetURLRequestContext(),
          storage_partition_impl_->GetIndexedDBContext(),
          ChromeBlobStorageContext::GetFor(browser_context_))),
      channel_connected_(false),
      sent_render_process_ready_(false),
#if defined(OS_ANDROID)
      never_signaled_(base::WaitableEvent::ResetPolicy::MANUAL,
                      base::WaitableEvent::InitialState::NOT_SIGNALED),
#endif
      instance_weak_factory_(
          new base::WeakPtrFactory<RenderProcessHostImpl>(this)),
      weak_factory_(this) {
  widget_helper_ = new RenderWidgetHelper();

  ChildProcessSecurityPolicyImpl::GetInstance()->Add(GetID());

  CHECK(!BrowserMainRunner::ExitedMainMessageLoop());
  RegisterHost(GetID(), this);
  g_all_hosts.Get().set_check_on_null_data(true);
  mark_child_process_activity_time();

  if (!GetBrowserContext()->IsOffTheRecord() &&
      !base::CommandLine::ForCurrentProcess()->HasSwitch(
          switches::kDisableGpuShaderDiskCache)) {
    BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,
                            base::Bind(&CacheShaderInfo, GetID(),
                                       storage_partition_impl_->GetPath()));
  }

#if defined(OS_MACOSX)
  if (BootstrapSandboxManager::ShouldEnable())
    AddObserver(BootstrapSandboxManager::GetInstance());
#endif

  InitializeChannelProxy();
}

static bool ExecuteFormatBlock(LocalFrame& frame,
                               Event*,
                               EditorCommandSource,
                               const String& value) {
  String tag_name = value.DeprecatedLower();
  if (tag_name[0] == '<' && tag_name[tag_name.length() - 1] == '>')
    tag_name = tag_name.Substring(1, tag_name.length() - 2);

  AtomicString local_name, prefix;
  if (!Document::ParseQualifiedName(AtomicString(tag_name), prefix, local_name,
                                    IGNORE_EXCEPTION_FOR_TESTING))
    return false;
  QualifiedName qualified_tag_name(prefix, local_name, xhtmlNamespaceURI);

  DCHECK(frame.GetDocument());
  FormatBlockCommand* command =
      FormatBlockCommand::Create(*frame.GetDocument(), qualified_tag_name);
  command->Apply();
  return command->DidApply();
}

 void VRDisplay::FocusChanged() {
   vr_v_sync_provider_.reset();
   ConnectVSyncProvider();
 }

static bool ExecuteScrollToBeginningOfDocument(LocalFrame& frame,
                                               Event*,
                                               EditorCommandSource,
                                               const String&) {
  return frame.GetEventHandler().BubblingScroll(kScrollBlockDirectionBackward,
                                                kScrollByDocument);
}

void RenderProcessHostImpl::PropagateBrowserCommandLineToRenderer(
    const base::CommandLine& browser_cmd,
    base::CommandLine* renderer_cmd) {
  static const char* const kSwitchNames[] = {
    switches::kAgcStartupMinVolume,
    switches::kAecRefinedAdaptiveFilter,
    switches::kAllowLoopbackInPeerConnection,
    switches::kAndroidFontsPath,
    switches::kAudioBufferSize,
    switches::kBlinkSettings,
    switches::kDefaultTileWidth,
    switches::kDefaultTileHeight,
    switches::kDisable2dCanvasImageChromium,
    switches::kDisable3DAPIs,
    switches::kDisableAcceleratedJpegDecoding,
    switches::kDisableAcceleratedVideoDecode,
    switches::kDisableBackgroundTimerThrottling,
    switches::kDisableBlinkFeatures,
    switches::kDisableBreakpad,
    switches::kDisablePreferCompositingToLCDText,
    switches::kDisableDatabases,
    switches::kDisableDisplayList2dCanvas,
    switches::kDisableDistanceFieldText,
    switches::kDisableFileSystem,
    switches::kDisableGestureRequirementForMediaPlayback,
    switches::kDisableGestureRequirementForPresentation,
    switches::kDisableGpuCompositing,
    switches::kDisableGpuMemoryBufferVideoFrames,
    switches::kDisableGpuVsync,
    switches::kDisableLowResTiling,
    switches::kDisableHistogramCustomizer,
    switches::kDisableLCDText,
    switches::kDisableLocalStorage,
    switches::kDisableLogging,
    switches::kDisableMediaSuspend,
    switches::kDisableNotifications,
    switches::kDisableOverlayScrollbar,
    switches::kDisablePepper3DImageChromium,
    switches::kDisablePermissionsAPI,
    switches::kDisablePresentationAPI,
    switches::kDisablePinch,
    switches::kDisableRGBA4444Textures,
    switches::kDisableRTCSmoothnessAlgorithm,
    switches::kDisableSeccompFilterSandbox,
    switches::kDisableSharedWorkers,
    switches::kDisableSlimmingPaintInvalidation,
    switches::kDisableSmoothScrolling,
    switches::kDisableSpeechAPI,
    switches::kDisableThreadedCompositing,
    switches::kDisableThreadedScrolling,
    switches::kDisableTouchAdjustment,
    switches::kDisableTouchDragDrop,
    switches::kDisableV8IdleTasks,
    switches::kDisableWebGLImageChromium,
    switches::kDomAutomationController,
    switches::kEnableBlinkFeatures,
    switches::kEnableBrowserSideNavigation,
    switches::kEnableColorCorrectRenderingDefaultMode,
    switches::kEnableDisplayList2dCanvas,
    switches::kEnableDistanceFieldText,
    switches::kEnableExperimentalCanvasFeatures,
    switches::kEnableExperimentalWebPlatformFeatures,
    switches::kEnableHeapProfiling,
    switches::kEnableGPUClientLogging,
    switches::kEnableGpuClientTracing,
    switches::kEnableGpuMemoryBufferVideoFrames,
    switches::kEnableGPUServiceLogging,
    switches::kEnableLowResTiling,
    switches::kEnableMediaSuspend,
    switches::kEnableInbandTextTracks,
    switches::kEnableLCDText,
    switches::kEnableLogging,
    switches::kEnableNetworkInformation,
    switches::kEnableOverlayScrollbar,
    switches::kEnablePinch,
    switches::kEnablePluginPlaceholderTesting,
    switches::kEnablePreciseMemoryInfo,
    switches::kEnablePrintBrowser,
    switches::kEnablePreferCompositingToLCDText,
    switches::kEnableRGBA4444Textures,
    switches::kEnableSkiaBenchmarking,
    switches::kEnableSlimmingPaintV2,
    switches::kEnableSlimmingPaintInvalidation,
    switches::kEnableSmoothScrolling,
    switches::kEnableStatsTable,
    switches::kEnableThreadedCompositing,
    switches::kEnableTouchDragDrop,
    switches::kEnableUseZoomForDSF,
    switches::kEnableViewport,
    switches::kEnableVp9InMp4,
    switches::kEnableVtune,
    switches::kEnableWebFontsInterventionTrigger,
    switches::kEnableWebFontsInterventionV2,
    switches::kEnableWebGLDraftExtensions,
    switches::kEnableWebGLImageChromium,
    switches::kEnableWebVR,
    switches::kExplicitlyAllowedPorts,
    switches::kForceDeviceScaleFactor,
    switches::kForceDisplayList2dCanvas,
    switches::kForceGpuMemAvailableMb,
    switches::kForceGpuRasterization,
    switches::kEnableCanvas2dDynamicRenderingModeSwitching,
    switches::kForceOverlayFullscreenVideo,
    switches::kFullMemoryCrashReport,
    switches::kInertVisualViewport,
    switches::kIPCConnectionTimeout,
    switches::kIsRunningInMash,
    switches::kJavaScriptFlags,
    switches::kLoggingLevel,
    switches::kMainFrameResizesAreOrientationChanges,
    switches::kMaxUntiledLayerWidth,
    switches::kMaxUntiledLayerHeight,
    switches::kMemoryMetrics,
    switches::kMojoLocalStorage,
    switches::kMSEAudioBufferSizeLimit,
    switches::kMSEVideoBufferSizeLimit,
    switches::kNoReferrers,
    switches::kNoSandbox,
    switches::kNoUseMusInRenderer,
    switches::kOverridePluginPowerSaverForTesting,
    switches::kPassiveListenersDefault,
    switches::kPpapiInProcess,
    switches::kProfilerTiming,
    switches::kReducedReferrerGranularity,
    switches::kReduceSecurityForTesting,
    switches::kRegisterPepperPlugins,
    switches::kRendererStartupDialog,
    switches::kRootLayerScrolls,
    switches::kShowPaintRects,
    switches::kSitePerProcess,
    switches::kStatsCollectionController,
    switches::kTestType,
    switches::kTopDocumentIsolation,
    switches::kTouchEventFeatureDetection,
    switches::kTouchTextSelectionStrategy,
    switches::kTraceConfigFile,
    switches::kTraceToConsole,
    switches::kUseFakeUIForMediaStream,
    switches::kUseGL,
    switches::kUseGpuInTests,
    switches::kUseMobileUserAgent,
    switches::kV,
    switches::kV8CacheStrategiesForCacheStorage,
    switches::kVideoThreads,
    switches::kVideoUnderflowThresholdMs,
    switches::kVModule,
    cc::switches::kCheckTilePriorityInversion,
    cc::switches::kDisableCompositedAntialiasing,
    cc::switches::kDisableThreadedAnimation,
    cc::switches::kEnableColorCorrectRendering,
    cc::switches::kEnableGpuBenchmarking,
    cc::switches::kEnableLayerLists,
    cc::switches::kEnableTileCompression,
    cc::switches::kEnableTrueColorRendering,
    cc::switches::kShowCompositedLayerBorders,
    cc::switches::kShowFPSCounter,
    cc::switches::kShowLayerAnimationBounds,
    cc::switches::kShowPropertyChangedRects,
    cc::switches::kShowScreenSpaceRects,
    cc::switches::kShowSurfaceDamageRects,
    cc::switches::kSlowDownRasterScaleFactor,
    cc::switches::kBrowserControlsHideThreshold,
    cc::switches::kBrowserControlsShowThreshold,

#if BUILDFLAG(ENABLE_PLUGINS)
    switches::kEnablePepperTesting,
#endif
#if BUILDFLAG(ENABLE_WEBRTC)
    switches::kDisableWebRtcHWDecoding,
    switches::kDisableWebRtcHWEncoding,
    switches::kEnableWebRtcStunOrigin,
    switches::kEnforceWebRtcIPPermissionCheck,
    switches::kForceWebRtcIPHandlingPolicy,
    switches::kWebRtcMaxCaptureFramerate,
#endif
    switches::kEnableLowEndDeviceMode,
    switches::kDisableLowEndDeviceMode,
#if defined(OS_ANDROID)
    switches::kDisableMediaSessionAPI,
    switches::kEnableContentIntentDetection,
    switches::kRendererWaitForJavaDebugger,
#endif
#if defined(OS_MACOSX)
    switches::kEnableSandboxLogging,
#endif
#if defined(OS_WIN)
    switches::kDisableWin32kLockDown,
    switches::kEnableWin7WebRtcHWH264Decoding,
    switches::kTrySupportedChannelLayouts,
    switches::kTraceExportEventsToETW,
#endif
#if defined(USE_OZONE)
    switches::kOzonePlatform,
#endif
#if defined(OS_CHROMEOS)
    switches::kDisableVaapiAcceleratedVideoEncode,
#endif
#if defined(ENABLE_IPC_FUZZER)
    switches::kIpcDumpDirectory,
    switches::kIpcFuzzerTestcase,
#endif
  };
  renderer_cmd->CopySwitchesFrom(browser_cmd, kSwitchNames,
                                 arraysize(kSwitchNames));

  BrowserChildProcessHostImpl::CopyFeatureAndFieldTrialFlags(renderer_cmd);

  if (browser_cmd.HasSwitch(switches::kTraceStartup) &&
      BrowserMainLoop::GetInstance()->is_tracing_startup_for_duration()) {
    renderer_cmd->AppendSwitchASCII(
        switches::kTraceStartup,
        browser_cmd.GetSwitchValueASCII(switches::kTraceStartup));
  }

#if BUILDFLAG(ENABLE_WEBRTC)
  if (!has_done_stun_trials &&
      browser_cmd.HasSwitch(switches::kWebRtcStunProbeTrialParameter)) {
    has_done_stun_trials = true;
    renderer_cmd->AppendSwitchASCII(
        switches::kWebRtcStunProbeTrialParameter,
        browser_cmd.GetSwitchValueASCII(
            switches::kWebRtcStunProbeTrialParameter));
  }
#endif

  if (GetBrowserContext()->IsOffTheRecord() &&
      !browser_cmd.HasSwitch(switches::kDisableDatabases)) {
    renderer_cmd->AppendSwitch(switches::kDisableDatabases);
  }

  if (browser_cmd.HasSwitch(switches::kWaitForDebuggerChildren)) {
    std::string value =
        browser_cmd.GetSwitchValueASCII(switches::kWaitForDebuggerChildren);
    if (value.empty() || value == switches::kRendererProcess) {
      renderer_cmd->AppendSwitch(switches::kWaitForDebugger);
    }
  }

  DCHECK(child_connection_);
  renderer_cmd->AppendSwitchASCII(switches::kPrimordialPipeToken,
                                  child_connection_->service_token());

#if defined(OS_WIN) && !defined(OFFICIAL_BUILD)
  if (renderer_cmd->HasSwitch(switches::kRendererStartupDialog) &&
      !renderer_cmd->HasSwitch(switches::kNoSandbox)) {
    renderer_cmd->AppendSwitch(switches::kNoSandbox);
  }
#endif
}

void CacheShaderInfo(int32_t id, base::FilePath path) {
  if (GetShaderCacheFactorySingleton())
    GetShaderCacheFactorySingleton()->SetCacheInfo(id, path);
}

Editor::Command::Command(const EditorInternalCommand* command,
                         EditorCommandSource source,
                         LocalFrame* frame)
    : command_(command), source_(source), frame_(command ? frame : nullptr) {
  if (!command)
    DCHECK(!frame_);
  else
    DCHECK(frame_);
}

  MediaStreamManager* GetMediaStreamManager() {
     return media_stream_manager_.get();
   }

 ScriptPromise VRDisplay::exitPresent(ScriptState* script_state) {
   ScriptPromiseResolver* resolver = ScriptPromiseResolver::Create(script_state);
   ScriptPromise promise = resolver->Promise();
 
  if (!is_presenting_) {
    DOMException* exception = DOMException::Create(
        kInvalidStateError, "VRDisplay is not presenting.");
    resolver->Reject(exception);
    return promise;
  }

  if (!display_) {
    DOMException* exception =
        DOMException::Create(kInvalidStateError, "VRService is not available.");
    resolver->Reject(exception);
    return promise;
  }
  display_->ExitPresent();

  resolver->Resolve();

  StopPresenting();

  return promise;
}

void HostCache::RecordEraseAll(EraseReason reason, base::TimeTicks now) {
  for (const auto& it : entries_)
    RecordErase(reason, now, it.second);
}

  scoped_refptr<ConnectionFilterController> controller() { return controller_; }

static bool ExecuteSelectParagraph(LocalFrame& frame,
                                   Event*,
                                   EditorCommandSource,
                                   const String&) {
  return ExpandSelectionToGranularity(frame, TextGranularity::kParagraph);
}

void ValidateRenderFrameId(int render_process_id,
                           int render_frame_id,
                           const base::Callback<void(bool)>& callback) {
  DCHECK_CURRENTLY_ON(BrowserThread::UI);
  const bool frame_exists = (render_frame_id == kRenderFrameId);
  BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,
                          base::Bind(callback, frame_exists));
}

void RenderProcessHostImpl::AddFilter(BrowserMessageFilter* filter) {
  filter->RegisterAssociatedInterfaces(channel_.get());
  channel_->AddFilter(filter->GetFilter());
}

bool RenderProcessHostImpl::IsForGuestsOnly() const {
  return is_for_guests_only_;
}

const AtomicString& VRDisplay::InterfaceName() const {
  return EventTargetNames::VRDisplay;
}

void VRDisplay::ProcessScheduledWindowAnimations(double timestamp) {
  TRACE_EVENT1("gpu", "VRDisplay::window.rAF", "frame", vr_frame_id_);
  auto doc = navigator_vr_->GetDocument();
  if (!doc)
    return;
   auto page = doc->GetPage();
   if (!page)
     return;
   page->Animator().ServiceScriptedAnimations(timestamp);
 }

static PassRefPtr<Image> ImageFromNode(const Node& node) {
  DCHECK(!node.GetDocument().NeedsLayoutTreeUpdate());
  DocumentLifecycle::DisallowTransitionScope disallow_transition(
      node.GetDocument().Lifecycle());

  LayoutObject* layout_object = node.GetLayoutObject();
  if (!layout_object)
    return nullptr;

  if (layout_object->IsCanvas()) {
    return toHTMLCanvasElement(const_cast<Node&>(node))
        .CopiedImage(kFrontBuffer, kPreferNoAcceleration,
                     kSnapshotReasonCopyToClipboard);
  }

  if (layout_object->IsImage()) {
    LayoutImage* layout_image = ToLayoutImage(layout_object);
    if (!layout_image)
      return nullptr;

    ImageResourceContent* cached_image = layout_image->CachedImage();
    if (!cached_image || cached_image->ErrorOccurred())
      return nullptr;
    return cached_image->GetImage();
  }

  return nullptr;
}

  UsbDeviceHandleTest()
      : io_thread_(base::TestIOThread::kAutoStart),
        scoped_task_environment_(
            base::test::ScopedTaskEnvironment::MainThreadType::UI) {}

void AudioOutputAuthorizationHandler::DeviceParametersReceived(
    AuthorizationCompletedCallback cb,
    bool should_send_id,
    const std::string& raw_device_id,
    const media::AudioParameters& output_params) const {
  DCHECK_CURRENTLY_ON(BrowserThread::IO);
  DCHECK(!raw_device_id.empty());

  cb.Run(media::OUTPUT_DEVICE_STATUS_OK, should_send_id,
         output_params.IsValid() ? output_params
                                 : TryToFixAudioParameters(output_params),
         raw_device_id);
}

static bool ExecuteFindString(LocalFrame& frame,
                              Event*,
                              EditorCommandSource,
                              const String& value) {
  return frame.GetEditor().FindString(value, kCaseInsensitive | kWrapAround);
}

static bool ExecuteBackColor(LocalFrame& frame,
                             Event*,
                             EditorCommandSource source,
                             const String& value) {
  return ExecuteApplyStyle(frame, source, InputEvent::InputType::kNone,
                           CSSPropertyBackgroundColor, value);
}

scoped_refptr<AudioRendererHost> RenderProcessHostImpl::audio_renderer_host()
    const {
  return audio_renderer_host_;
}

static TriState StateTextWritingDirectionNatural(LocalFrame& frame, Event*) {
  return StateTextWritingDirection(frame, NaturalWritingDirection);
}

static bool EnabledCut(LocalFrame& frame, Event*, EditorCommandSource source) {
  if (!CanWriteClipboard(frame, source))
    return false;
  if (source == kCommandFromMenuOrKeyBinding &&
      !frame.Selection().SelectionHasFocus())
    return false;
  return frame.GetEditor().CanDHTMLCut() || frame.GetEditor().CanCut();
}

static LocalFrame* TargetFrame(LocalFrame& frame, Event* event) {
  if (!event)
    return &frame;
  Node* node = event->target()->ToNode();
  if (!node)
    return &frame;
  return node->GetDocument().GetFrame();
}

VRDisplay::~VRDisplay() {}

static bool ExecuteMoveToEndOfParagraph(LocalFrame& frame,
                                        Event*,
                                        EditorCommandSource,
                                        const String&) {
  frame.Selection().Modify(
      SelectionModifyAlteration::kMove, SelectionModifyDirection::kForward,
      TextGranularity::kParagraphBoundary, SetSelectionBy::kUser);
  return true;
}

static TriState StateUnorderedList(LocalFrame& frame, Event*) {
  return SelectionListState(frame.Selection(), ulTag);
}

void RenderProcessHostImpl::OnProcessLaunchFailed(int error_code) {
  if (deleting_soon_)
    return;

  RendererClosedDetails details{base::TERMINATION_STATUS_LAUNCH_FAILED,
                                error_code};
  ProcessDied(true, &details);
}

void RenderProcessHostImpl::ResetChannelProxy() {
  if (!channel_)
    return;

  channel_.reset();
  channel_connected_ = false;
}

static bool ExecuteSubscript(LocalFrame& frame,
                             Event*,
                             EditorCommandSource source,
                             const String&) {
  return ExecuteToggleStyle(frame, source,
                            InputEvent::InputType::kFormatSubscript,
                            CSSPropertyVerticalAlign, "baseline", "sub");
}

AudioManager* AudioSystemImpl::GetAudioManager() const {
  return audio_manager_;
}

inline void HarfBuzzShaper::HarfBuzzRun::setGlyphAndPositions(unsigned index, uint16_t glyphId, float advance, float offsetX, float offsetY)
{
    m_glyphs[index] = glyphId;
    m_advances[index] = advance;
    m_offsets[index] = FloatSize(offsetX, offsetY);
}

void HostCache::Entry::CountHit(bool hit_is_stale) {
  ++total_hits_;
  if (hit_is_stale)
    ++stale_hits_;
}

static bool Supported(LocalFrame*) {
  return true;
}

static bool ExecuteRedo(LocalFrame& frame,
                        Event*,
                        EditorCommandSource,
                        const String&) {
  frame.GetEditor().Redo();
  return true;
}

  void AssertBadMsgReported() {
    EXPECT_EQ(render_process_host_.bad_msg_count() + host_->bad_msg_count, 1);
  }

AudioRendererHost::~AudioRendererHost() {
  DCHECK_CURRENTLY_ON(BrowserThread::IO);
  DCHECK(delegates_.empty());
}

void RenderProcessHostImpl::SendAecDumpFileToRenderer(
    int id,
    IPC::PlatformFileForTransit file_for_transit) {
  if (file_for_transit == IPC::InvalidPlatformFileForTransit())
    return;
  Send(new AecDumpMsg_EnableAecDump(id, file_for_transit));
}

void ImageLoader::setImage(ImageResourceContent* newImage) {
  setImageWithoutConsideringPendingLoadEvent(newImage);

  updatedHasPendingEvent();
}

void RenderProcessHostImpl::OnRegisterAecDumpConsumer(int id) {
  BrowserThread::PostTask(
      BrowserThread::UI, FROM_HERE,
      base::Bind(&RenderProcessHostImpl::RegisterAecDumpConsumerOnUIThread,
                 weak_factory_.GetWeakPtr(), id));
}

static bool ExecuteDeleteToBeginningOfParagraph(LocalFrame& frame,
                                                Event*,
                                                EditorCommandSource,
                                                const String&) {
  frame.GetEditor().DeleteWithDirection(DeleteDirection::kBackward,
                                        TextGranularity::kParagraphBoundary,
                                        true, false);
  return true;
}

static bool ExecuteMoveWordBackwardAndModifySelection(LocalFrame& frame,
                                                      Event*,
                                                      EditorCommandSource,
                                                      const String&) {
  frame.Selection().Modify(SelectionModifyAlteration::kExtend,
                           SelectionModifyDirection::kBackward,
                           TextGranularity::kWord, SetSelectionBy::kUser);
  return true;
}

static bool ExecuteMoveLeftAndModifySelection(LocalFrame& frame,
                                              Event*,
                                              EditorCommandSource,
                                              const String&) {
  frame.Selection().Modify(SelectionModifyAlteration::kExtend,
                           SelectionModifyDirection::kLeft,
                           TextGranularity::kCharacter, SetSelectionBy::kUser);
  return true;
}

float HarfBuzzShaper::adjustSpacing(HarfBuzzRun* currentRun, size_t glyphIndex, unsigned currentCharacterIndex, HarfBuzzRun* previousRun, float& offsetX, float& totalAdvance)
{
    float spacing = 0;
    UChar32 character = m_normalizedBuffer[currentCharacterIndex];
    if (m_letterSpacing && !Character::treatAsZeroWidthSpace(character))
        spacing += m_letterSpacing;

    bool treatAsSpace = Character::treatAsSpace(character);
    if (treatAsSpace && currentCharacterIndex && (character != '\t' || !m_run.allowTabs()))
        spacing += m_wordSpacingAdjustment;

    if (!m_expansionOpportunityCount)
        return spacing;

    if (treatAsSpace) {
        spacing += nextExpansionPerOpportunity();
        m_isAfterExpansion = true;
        return spacing;
    }

    if (m_run.textJustify() != TextJustify::TextJustifyAuto) {
        m_isAfterExpansion = false;
        return spacing;
    }

    if (U16_IS_LEAD(character) && currentCharacterIndex + 1 < m_normalizedBufferLength && U16_IS_TRAIL(m_normalizedBuffer[currentCharacterIndex + 1]))
        character = U16_GET_SUPPLEMENTARY(character, m_normalizedBuffer[currentCharacterIndex + 1]);
    if (!Character::isCJKIdeographOrSymbol(character)) {
        m_isAfterExpansion = false;
        return spacing;
    }

    if (!m_isAfterExpansion) {
        float expandBefore = nextExpansionPerOpportunity();
        if (expandBefore) {
            if (glyphIndex > 0) {
                currentRun->addAdvance(glyphIndex - 1, expandBefore);
                totalAdvance += expandBefore;
            } else if (previousRun) {
                previousRun->addAdvance(previousRun->numGlyphs() - 1, expandBefore);
                previousRun->setWidth(previousRun->width() + expandBefore);
                m_totalWidth += expandBefore;
            } else {
                offsetX += expandBefore;
                totalAdvance += expandBefore;
            }
        }
        if (!m_expansionOpportunityCount)
            return spacing;
    }

    spacing += nextExpansionPerOpportunity();
    m_isAfterExpansion = true;
    return spacing;
}

static ImageEventSender& errorEventSender() {
  DEFINE_STATIC_LOCAL(ImageEventSender, sender,
                      (ImageEventSender::create(EventTypeNames::error)));
  return sender;
}

  virtual ~MockAudioRendererHost() {
    EXPECT_TRUE(delegates_.empty());
  }

CachedShapingResultsLRUNode::CachedShapingResultsLRUNode(const CachedShapingResultsMap::iterator& cacheEntry)
    : entry(cacheEntry)
{
}

void VRDisplay::ContextDestroyed(ExecutionContext*) {
  ForceExitPresent();
  scripted_animation_controller_.Clear();
}

bool RenderProcessHost::ShouldUseProcessPerSite(BrowserContext* browser_context,
                                                const GURL& url) {
  const base::CommandLine& command_line =
      *base::CommandLine::ForCurrentProcess();
  if (command_line.HasSwitch(switches::kProcessPerSite))
    return true;

  if (WebUIControllerFactoryRegistry::GetInstance()->UseWebUIForURL(
          browser_context, url) &&
      !url.SchemeIs(kChromeDevToolsScheme)) {
    return true;
  }

  return GetContentClient()->browser()->ShouldUseProcessPerSite(browser_context,
                                                                url);
}

void RenderProcessHostImpl::OnAudioStreamAdded() {
  ++audio_stream_count_;
  UpdateProcessPriority();
}

void ImageLoader::dispatchPendingErrorEvent() {
  if (!m_hasPendingErrorEvent)
    return;
  m_hasPendingErrorEvent = false;

  if (element()->document().frame())
    element()->dispatchEvent(Event::create(EventTypeNames::error));

  updatedHasPendingEvent();
}

AudioRendererHost::DoGetOutputControllers() const {
  DCHECK_CURRENTLY_ON(BrowserThread::IO);

  RenderProcessHost::AudioOutputControllerList controllers;
  for (const auto& delegate : delegates_)
    controllers.push_back(delegate->GetController());

  return controllers;
}

static bool ExecuteInsertNewline(LocalFrame& frame,
                                 Event* event,
                                 EditorCommandSource,
                                 const String&) {
  LocalFrame* target_frame = blink::TargetFrame(frame, event);
  return target_frame->GetEventHandler().HandleTextInputEvent(
      "\n", event,
      target_frame->GetEditor().CanEditRichly() ? kTextEventInputKeyboard
                                                : kTextEventInputLineBreak);
}

net::URLRequestContext* GetRequestContext(
    scoped_refptr<net::URLRequestContextGetter> request_context,
    scoped_refptr<net::URLRequestContextGetter> media_request_context,
    ResourceType resource_type) {
  if (resource_type == RESOURCE_TYPE_MEDIA)
    return media_request_context->GetURLRequestContext();
  return request_context->GetURLRequestContext();
}

void RenderProcessHostImpl::DecrementSharedWorkerRefCount() {
  DCHECK_CURRENTLY_ON(BrowserThread::UI);
  DCHECK(!is_worker_ref_count_disabled_);
  DCHECK_GT(GetWorkerRefCount(), 0U);
  --shared_worker_ref_count_;
  if (GetWorkerRefCount() == 0)
    Cleanup();
}

RenderProcessHost::iterator RenderProcessHost::AllHostsIterator() {
  DCHECK_CURRENTLY_ON(BrowserThread::UI);
  return iterator(g_all_hosts.Pointer());
}

void RenderProcessHostImpl::InitializeChannelProxy() {
  scoped_refptr<base::SingleThreadTaskRunner> io_task_runner =
      BrowserThread::GetTaskRunnerForThread(BrowserThread::IO);

  service_manager::Connector* connector =
      BrowserContext::GetConnectorFor(browser_context_);
  if (!connector) {
    if (!ServiceManagerConnection::GetForProcess()) {
      service_manager::mojom::ServiceRequest request(&test_service_);
      ServiceManagerConnection::SetForProcess(ServiceManagerConnection::Create(
          std::move(request), io_task_runner));
    }
    connector = ServiceManagerConnection::GetForProcess()->GetConnector();
  }

  pending_connection_.reset(new mojo::edk::PendingProcessConnection);
  child_connection_.reset(new ChildConnection(
      mojom::kRendererServiceName,
      base::StringPrintf("%d_%d", id_, instance_id_++),
      pending_connection_.get(), connector, io_task_runner));

  IPC::mojom::ChannelBootstrapPtr bootstrap;
  GetRemoteInterfaces()->GetInterface(&bootstrap);
  std::unique_ptr<IPC::ChannelFactory> channel_factory =
      IPC::ChannelMojo::CreateServerFactory(
          bootstrap.PassInterface().PassHandle(), io_task_runner);

  ResetChannelProxy();

#if defined(OS_ANDROID)
  if (GetContentClient()->UsingSynchronousCompositing()) {
    channel_ = IPC::SyncChannel::Create(
        this, io_task_runner.get(), &never_signaled_);
  }
#endif  // OS_ANDROID
  if (!channel_)
    channel_.reset(new IPC::ChannelProxy(this, io_task_runner.get()));
  channel_->Init(std::move(channel_factory), true /* create_pipe_now */);

  channel_->GetRemoteAssociatedInterface(&remote_route_provider_);
  channel_->GetRemoteAssociatedInterface(&renderer_interface_);

  channel_->Pause();
}

static bool EnabledVisibleSelection(LocalFrame& frame,
                                    Event* event,
                                    EditorCommandSource source) {
  frame.GetDocument()->UpdateStyleAndLayoutIgnorePendingStylesheets();

  if (source == kCommandFromMenuOrKeyBinding &&
      !frame.Selection().SelectionHasFocus())
    return false;

  const VisibleSelection& selection =
      frame.GetEditor().SelectionForCommand(event);
  return (selection.IsCaret() && selection.IsContentEditable()) ||
         selection.IsRange();
}

  void SimulateError() {
    EXPECT_EQ(1u, host_->delegates_.size())
        << "Calls Create() before calling this method";

    EXPECT_CALL(*host_.get(), WasNotifiedOfError(kStreamId));

    host_->OnStreamError(kStreamId);
    SyncWithAudioThread();

    EXPECT_EQ(0u, host_->delegates_.size());
  }

static bool Enabled(LocalFrame&, Event*, EditorCommandSource) {
  return true;
}

void RenderProcessHostImpl::RemoveObserver(
    RenderProcessHostObserver* observer) {
  observers_.RemoveObserver(observer);
}

WebEditingCommandType WebEditingCommandTypeFromCommandName(
    const String& command_name) {
  const CommandNameEntry* result = std::lower_bound(
      std::begin(kCommandNameEntries), std::end(kCommandNameEntries),
      command_name, [](const CommandNameEntry& entry, const String& needle) {
        return CodePointCompareIgnoringASCIICase(needle, entry.name) > 0;
      });
  if (result != std::end(kCommandNameEntries) &&
      CodePointCompareIgnoringASCIICase(command_name, result->name) == 0)
    return result->type;
  return WebEditingCommandType::kInvalid;
}

RenderProcessHostImpl::GetRemoteInterfaces() {
  return child_connection_->GetRemoteInterfaces();
}

static bool CanWriteClipboard(LocalFrame& frame, EditorCommandSource source) {
  if (source == kCommandFromMenuOrKeyBinding)
    return true;
  Settings* settings = frame.GetSettings();
  bool default_value =
      (settings && settings->GetJavaScriptCanAccessClipboard()) ||
      UserGestureIndicator::ProcessingUserGesture();
  return frame.GetEditor().Client().CanCopyCut(&frame, default_value);
}

void HarfBuzzShaper::setFontFeatures()
{
    const FontDescription& description = m_font->fontDescription();

    static hb_feature_t noKern = { HB_TAG('k', 'e', 'r', 'n'), 0, 0, static_cast<unsigned>(-1) };
    static hb_feature_t noVkrn = { HB_TAG('v', 'k', 'r', 'n'), 0, 0, static_cast<unsigned>(-1) };
    switch (description.kerning()) {
    case FontDescription::NormalKerning:
        break;
    case FontDescription::NoneKerning:
        m_features.append(description.isVerticalAnyUpright() ? noVkrn : noKern);
        break;
    case FontDescription::AutoKerning:
        break;
    }

    static hb_feature_t noClig = { HB_TAG('c', 'l', 'i', 'g'), 0, 0, static_cast<unsigned>(-1) };
    static hb_feature_t noLiga = { HB_TAG('l', 'i', 'g', 'a'), 0, 0, static_cast<unsigned>(-1) };
    switch (description.commonLigaturesState()) {
    case FontDescription::DisabledLigaturesState:
        m_features.append(noLiga);
        m_features.append(noClig);
        break;
    case FontDescription::EnabledLigaturesState:
        break;
    case FontDescription::NormalLigaturesState:
        break;
    }
    static hb_feature_t dlig = { HB_TAG('d', 'l', 'i', 'g'), 1, 0, static_cast<unsigned>(-1) };
    switch (description.discretionaryLigaturesState()) {
    case FontDescription::DisabledLigaturesState:
        break;
    case FontDescription::EnabledLigaturesState:
        m_features.append(dlig);
        break;
    case FontDescription::NormalLigaturesState:
        break;
    }
    static hb_feature_t hlig = { HB_TAG('h', 'l', 'i', 'g'), 1, 0, static_cast<unsigned>(-1) };
    switch (description.historicalLigaturesState()) {
    case FontDescription::DisabledLigaturesState:
        break;
    case FontDescription::EnabledLigaturesState:
        m_features.append(hlig);
        break;
    case FontDescription::NormalLigaturesState:
        break;
    }
    static hb_feature_t noCalt = { HB_TAG('c', 'a', 'l', 't'), 0, 0, static_cast<unsigned>(-1) };
    switch (description.contextualLigaturesState()) {
    case FontDescription::DisabledLigaturesState:
        m_features.append(noCalt);
        break;
    case FontDescription::EnabledLigaturesState:
        break;
    case FontDescription::NormalLigaturesState:
        break;
    }

    static hb_feature_t hwid = { HB_TAG('h', 'w', 'i', 'd'), 1, 0, static_cast<unsigned>(-1) };
    static hb_feature_t twid = { HB_TAG('t', 'w', 'i', 'd'), 1, 0, static_cast<unsigned>(-1) };
    static hb_feature_t qwid = { HB_TAG('q', 'w', 'i', 'd'), 1, 0, static_cast<unsigned>(-1) };
    switch (description.widthVariant()) {
    case HalfWidth:
        m_features.append(hwid);
        break;
    case ThirdWidth:
        m_features.append(twid);
        break;
    case QuarterWidth:
        m_features.append(qwid);
        break;
    case RegularWidth:
        break;
    }

    FontFeatureSettings* settings = description.featureSettings();
    if (!settings)
        return;

    unsigned numFeatures = settings->size();
    for (unsigned i = 0; i < numFeatures; ++i) {
        hb_feature_t feature;
        const AtomicString& tag = settings->at(i).tag();
        feature.tag = HB_TAG(tag[0], tag[1], tag[2], tag[3]);
        feature.value = settings->at(i).value();
        feature.start = 0;
        feature.end = static_cast<unsigned>(-1);
        m_features.append(feature);
    }
}

bool AudioRendererHost::IsAuthorizationStarted(int stream_id) {
  DCHECK_CURRENTLY_ON(BrowserThread::IO);
  return authorizations_.find(stream_id) != authorizations_.end();
}

static bool ExecuteMoveToRightEndOfLine(LocalFrame& frame,
                                        Event*,
                                        EditorCommandSource,
                                        const String&) {
  frame.Selection().Modify(
      SelectionModifyAlteration::kMove, SelectionModifyDirection::kRight,
      TextGranularity::kLineBoundary, SetSelectionBy::kUser);
  return true;
}

 void VRDisplay::OnPresentChange() {
   if (is_presenting_ && !is_valid_device_for_presenting_) {
     DVLOG(1) << __FUNCTION__ << ": device not valid, not sending event";
     return;
  }
  navigator_vr_->EnqueueVREvent(VRDisplayEvent::Create(
      EventTypeNames::vrdisplaypresentchange, true, false, this, ""));
}

bool RenderProcessHostImpl::FastShutdownIfPossible() {
  if (run_renderer_in_process())
    return false;  // Single process mode never shuts down the renderer.

  if (!child_process_launcher_.get() || child_process_launcher_->IsStarting() ||
      !GetHandle())
    return false;  // Render process hasn't started or is probably crashed.

  if (!SuddenTerminationAllowed())
    return false;

  if (GetWorkerRefCount() != 0) {
    if (survive_for_worker_start_time_.is_null())
      survive_for_worker_start_time_ = base::TimeTicks::Now();
    return false;
  }

  fast_shutdown_started_ = true;

  ProcessDied(false /* already_dead */, nullptr);
  return true;
}

  ConnectionFilterImpl(
      const service_manager::Identity& child_identity,
      std::unique_ptr<service_manager::InterfaceRegistry> registry)
      : child_identity_(child_identity),
        registry_(std::move(registry)),
        controller_(new ConnectionFilterController(this)),
        weak_factory_(this) {
    thread_checker_.DetachFromThread();
  }

static bool ExecuteMoveToEndOfDocument(LocalFrame& frame,
                                       Event*,
                                       EditorCommandSource,
                                       const String&) {
  frame.Selection().Modify(
      SelectionModifyAlteration::kMove, SelectionModifyDirection::kForward,
      TextGranularity::kDocumentBoundary, SetSelectionBy::kUser);
  return true;
}

void AudioRendererHost::OnSetVolume(int stream_id, double volume) {
  DCHECK_CURRENTLY_ON(BrowserThread::IO);

  AudioOutputDelegate* delegate = LookupById(stream_id);
  if (!delegate) {
    SendErrorMessage(stream_id);
    return;
  }

  if (volume < 0 || volume > 1.0)
    return;
  delegate->OnSetVolume(volume);
}

static bool ExecuteJustifyCenter(LocalFrame& frame,
                                 Event*,
                                 EditorCommandSource source,
                                 const String&) {
  return ExecuteApplyParagraphStyle(frame, source,
                                    InputEvent::InputType::kFormatJustifyCenter,
                                    CSSPropertyTextAlign, "center");
}

void Editor::UnappliedEditing(UndoStep* cmd) {
  EventQueueScope scope;

  DispatchEditableContentChangedEvents(cmd->StartingRootEditableElement(),
                                       cmd->EndingRootEditableElement());
  DispatchInputEventEditableContentChanged(
      cmd->StartingRootEditableElement(), cmd->EndingRootEditableElement(),
      InputEvent::InputType::kHistoryUndo, g_null_atom,
      InputEvent::EventIsComposing::kNotComposing);

  const SelectionInDOMTree& new_selection = CorrectedSelectionAfterCommand(
      cmd->StartingSelection(), GetFrame().GetDocument());
  ChangeSelectionAfterCommand(
      new_selection,
      FrameSelection::kCloseTyping | FrameSelection::kClearTypingStyle);

  last_edit_command_ = nullptr;
  undo_stack_->RegisterRedoStep(cmd);
  RespondToChangedContents(new_selection.Base());
}

ExecutionContext* VRDisplay::GetExecutionContext() const {
  return ContextLifecycleObserver::GetExecutionContext();
}

Editor::Command Editor::CreateCommand(const String& command_name,
                                      EditorCommandSource source) {
  return Command(InternalCommand(command_name), source, frame_);
}

static String ValueStateOrNull(const EditorInternalCommand& self,
                               LocalFrame& frame,
                               Event* triggering_event) {
  if (self.state == StateNone)
    return String();
  return self.state(frame, triggering_event) == kTrueTriState ? "true"
                                                              : "false";
}

bool HarfBuzzRunCache::insert(const std::wstring& key, CachedShapingResults* data)
{
    std::pair<CachedShapingResultsMap::iterator, bool> results =
        m_harfBuzzRunMap.insert(CachedShapingResultsMap::value_type(key, data));

    if (!results.second)
        return false;

    CachedShapingResultsLRUNode* node = new CachedShapingResultsLRUNode(results.first);

    m_harfBuzzRunLRU.push_back(node);
    data->lru = --m_harfBuzzRunLRU.end();

    if (m_harfBuzzRunMap.size() > cHarfBuzzCacheMaxSize) {
        CachedShapingResultsLRUNode* lru = m_harfBuzzRunLRU.front();
        CachedShapingResults* foo = lru->entry->second;
        m_harfBuzzRunMap.erase(lru->entry);
        m_harfBuzzRunLRU.pop_front();
        delete foo;
        delete lru;
    }

    return true;
}

void HostCache::RecordLookup(LookupOutcome outcome,
                             base::TimeTicks now,
                             const Entry* entry) {
  CACHE_HISTOGRAM_ENUM("Lookup", outcome, MAX_LOOKUP_OUTCOME);
  switch (outcome) {
    case LOOKUP_MISS_ABSENT:
    case LOOKUP_MISS_STALE:
    case LOOKUP_HIT_VALID:
      break;
    case LOOKUP_HIT_STALE:
      CACHE_HISTOGRAM_TIME("LookupStale.ExpiredBy", now - entry->expires());
      CACHE_HISTOGRAM_COUNT("LookupStale.NetworkChanges",
                            network_changes_ - entry->network_changes());
      break;
    case MAX_LOOKUP_OUTCOME:
      NOTREACHED();
      break;
  }
}

void AudioRendererHost::OnRequestDeviceAuthorization(
    int stream_id,
    int render_frame_id,
    int session_id,
    const std::string& device_id,
    const url::Origin& security_origin) {
  DCHECK_CURRENTLY_ON(BrowserThread::IO);
  const base::TimeTicks auth_start_time = base::TimeTicks::Now();
  DVLOG(1) << "AudioRendererHost@" << this << "::OnRequestDeviceAuthorization"
           << "(stream_id=" << stream_id
           << ", render_frame_id=" << render_frame_id
           << ", session_id=" << session_id << ", device_id=" << device_id
           << ", security_origin=" << security_origin << ")";

  if (LookupById(stream_id) || IsAuthorizationStarted(stream_id))
    return;

  authorizations_.insert(
      std::make_pair(stream_id, std::make_pair(false, std::string())));

  authorization_handler_.RequestDeviceAuthorization(
      render_frame_id, session_id, device_id, security_origin,
      base::Bind(&AudioRendererHost::AuthorizationCompleted,
                 base::Unretained(this), stream_id, security_origin,
                 auth_start_time));
}

static bool ExecuteMoveWordLeft(LocalFrame& frame,
                                Event*,
                                EditorCommandSource,
                                const String&) {
  frame.Selection().Modify(SelectionModifyAlteration::kMove,
                           SelectionModifyDirection::kLeft,
                           TextGranularity::kWord, SetSelectionBy::kUser);
  return true;
}

bool HarfBuzzShaper::createHarfBuzzRunsForSingleCharacter()
{
    ASSERT(m_normalizedBufferLength == 1);
    UChar32 character = m_normalizedBuffer[0];
    if (!U16_IS_SINGLE(character))
        return false;
    const SimpleFontData* fontData = m_font->glyphDataForCharacter(character, false, m_run.normalizeSpace()).fontData;
    UErrorCode errorCode = U_ZERO_ERROR;
    UScriptCode script = uscript_getScript(character, &errorCode);
    if (U_FAILURE(errorCode))
        return false;
    addHarfBuzzRun(0, 1, fontData, script);
    return true;
}

HarfBuzzRunCache::~HarfBuzzRunCache()
{
    for (CachedShapingResultsMap::iterator it = m_harfBuzzRunMap.begin(); it != m_harfBuzzRunMap.end(); ++it)
        delete it->second;
    for (CachedShapingResultsLRU::iterator it = m_harfBuzzRunLRU.begin(); it != m_harfBuzzRunLRU.end(); ++it)
        delete *it;
}

 void VRDisplay::OnBlur() {
   display_blurred_ = true;
   vr_v_sync_provider_.reset();
   navigator_vr_->EnqueueVREvent(VRDisplayEvent::Create(
       EventTypeNames::vrdisplayblur, true, false, this, ""));
 }

void RenderProcessHostImpl::OnGpuSwitched() {
  RecomputeAndUpdateWebKitPreferences();
}

static bool ExecuteSelectLine(LocalFrame& frame,
                              Event*,
                              EditorCommandSource,
                              const String&) {
  return ExpandSelectionToGranularity(frame, TextGranularity::kLine);
}

static bool ExecuteDeleteForward(LocalFrame& frame,
                                 Event*,
                                 EditorCommandSource,
                                 const String&) {
  frame.GetEditor().DeleteWithDirection(
      DeleteDirection::kForward, TextGranularity::kCharacter, false, true);
  return true;
}

void RenderProcessHostImpl::ShutDownInProcessRenderer() {
  DCHECK(g_run_renderer_in_process_);

  switch (g_all_hosts.Pointer()->size()) {
    case 0:
      return;
    case 1: {
      RenderProcessHostImpl* host = static_cast<RenderProcessHostImpl*>(
          AllHostsIterator().GetCurrentValue());
      for (auto& observer : host->observers_)
        observer.RenderProcessHostDestroyed(host);
#ifndef NDEBUG
      host->is_self_deleted_ = true;
#endif
      delete host;
      return;
    }
    default:
      NOTREACHED() << "There should be only one RenderProcessHost when running "
                   << "in-process.";
  }
}

  void SetResult(UsbTransferStatus status,
                 scoped_refptr<net::IOBuffer> buffer,
                 size_t transferred) {
    status_ = status;
    transferred_ = transferred;
     run_loop_.Quit();
   }

bool ImageLoader::getImageAnimationPolicy(ImageAnimationPolicy& policy) {
  if (!element()->document().settings())
    return false;

  policy = element()->document().settings()->getImageAnimationPolicy();
  return true;
}

static bool ExecuteInsertTab(LocalFrame& frame,
                             Event* event,
                             EditorCommandSource,
                             const String&) {
  return TargetFrame(frame, event)
      ->GetEventHandler()
      .HandleTextInputEvent("\t", event);
}

HeapVector<VRLayer> VRDisplay::getLayers() {
  HeapVector<VRLayer> layers;

  if (is_presenting_) {
    layers.push_back(layer_);
  }

  return layers;
}

static bool ExecuteMoveParagraphBackward(LocalFrame& frame,
                                         Event*,
                                         EditorCommandSource,
                                         const String&) {
  frame.Selection().Modify(SelectionModifyAlteration::kMove,
                           SelectionModifyDirection::kBackward,
                           TextGranularity::kParagraph, SetSelectionBy::kUser);
  return true;
}

bool HarfBuzzShaper::shapeHarfBuzzRuns()
{
    HarfBuzzScopedPtr<hb_buffer_t> harfBuzzBuffer(hb_buffer_create(), hb_buffer_destroy);

    HarfBuzzRunCache& runCache = harfBuzzRunCache();
    const FontDescription& fontDescription = m_font->fontDescription();
    const String& localeString = fontDescription.locale();
    CString locale = localeString.latin1();
    HarfBuzzRun* previousRun = nullptr;

    for (unsigned i = 0; i < m_harfBuzzRuns.size(); ++i) {
        unsigned runIndex = m_run.rtl() ? m_harfBuzzRuns.size() - i - 1 : i;
        HarfBuzzRun* currentRun = m_harfBuzzRuns[runIndex].get();

        const SimpleFontData* currentFontData = currentRun->fontData();
        FontPlatformData* platformData = const_cast<FontPlatformData*>(&currentFontData->platformData());
        HarfBuzzFace* face = platformData->harfBuzzFace();
        if (!face)
            return false;

        hb_buffer_set_language(harfBuzzBuffer.get(), hb_language_from_string(locale.data(), locale.length()));
        hb_buffer_set_script(harfBuzzBuffer.get(), currentRun->script());
        hb_buffer_set_direction(harfBuzzBuffer.get(), currentRun->direction());

        const UChar* src = m_normalizedBuffer.get() + currentRun->startIndex();
        std::wstring key(src, src + currentRun->numCharacters());

        CachedShapingResults* cachedResults = runCache.find(key);
        if (cachedResults) {
            if (isValidCachedResult(m_font, currentRun->direction(),
                localeString, cachedResults)) {
                currentRun->applyShapeResult(cachedResults->buffer);
                setGlyphPositionsForHarfBuzzRun(currentRun,
                    cachedResults->buffer, previousRun);
                hb_buffer_clear_contents(harfBuzzBuffer.get());
                runCache.moveToBack(cachedResults);
                previousRun = currentRun;
                continue;
            }
            runCache.remove(cachedResults);
        }

        static const uint16_t preContext = space;
        hb_buffer_add_utf16(harfBuzzBuffer.get(), &preContext, 1, 1, 0);

        addToHarfBuzzBufferInternal(harfBuzzBuffer.get(),
            fontDescription, m_normalizedBuffer.get(), currentRun->startIndex(),
            currentRun->numCharacters());

        if (fontDescription.isVerticalAnyUpright())
            face->setScriptForVerticalGlyphSubstitution(harfBuzzBuffer.get());

        HarfBuzzScopedPtr<hb_font_t> harfBuzzFont(face->createFont(), hb_font_destroy);

        hb_shape(harfBuzzFont.get(), harfBuzzBuffer.get(), m_features.isEmpty() ? 0 : m_features.data(), m_features.size());
        currentRun->applyShapeResult(harfBuzzBuffer.get());
        setGlyphPositionsForHarfBuzzRun(currentRun, harfBuzzBuffer.get(), previousRun);

        runCache.insert(key, new CachedShapingResults(harfBuzzBuffer.get(), m_font, currentRun->direction(), localeString));

        harfBuzzBuffer.set(hb_buffer_create());

        previousRun = currentRun;
    }


    return true;
}

static bool EnabledInEditableText(LocalFrame& frame,
                                  Event* event,
                                  EditorCommandSource source) {
  frame.GetDocument()->UpdateStyleAndLayoutIgnorePendingStylesheets();
  if (source == kCommandFromMenuOrKeyBinding &&
      !frame.Selection().SelectionHasFocus())
    return false;
  return frame.GetEditor().SelectionForCommand(event).RootEditableElement();
}

static bool ExecuteSwapWithMark(LocalFrame& frame,
                                Event*,
                                EditorCommandSource,
                                const String&) {
  const VisibleSelection& mark = frame.GetEditor().Mark();
  const VisibleSelection& selection =
      frame.Selection().ComputeVisibleSelectionInDOMTreeDeprecated();
  if (mark.IsNone() || selection.IsNone())
    return false;
  frame.Selection().SetSelection(mark.AsSelection());
  frame.GetEditor().SetMark(selection);
  return true;
}

  void RemoveProcess(RenderProcessHost* host) {
    std::set<std::string> sites;
    for (SiteToProcessMap::const_iterator i = map_.begin(); i != map_.end();
         i++) {
      if (i->second == host)
        sites.insert(i->first);
    }
    for (std::set<std::string>::iterator i = sites.begin(); i != sites.end();
         i++) {
      SiteToProcessMap::iterator iter = map_.find(*i);
      if (iter != map_.end()) {
        DCHECK_EQ(iter->second, host);
        map_.erase(iter);
      }
    }
  }

void RenderProcessHostImpl::CreateOffscreenCanvasCompositorFrameSinkProvider(
    blink::mojom::OffscreenCanvasCompositorFrameSinkProviderRequest request) {
  DCHECK_CURRENTLY_ON(BrowserThread::UI);
  if (!offscreen_canvas_provider_) {
    offscreen_canvas_provider_.reset(
        new OffscreenCanvasCompositorFrameSinkProviderImpl());
  }
  offscreen_canvas_provider_->Add(std::move(request));
}

static bool ExecuteMoveParagraphForwardAndModifySelection(LocalFrame& frame,
                                                          Event*,
                                                          EditorCommandSource,
                                                          const String&) {
  frame.Selection().Modify(SelectionModifyAlteration::kExtend,
                           SelectionModifyDirection::kForward,
                           TextGranularity::kParagraph, SetSelectionBy::kUser);
  return true;
}

  void clearLoader() {
    m_loader = nullptr;
    m_scriptState.clear();
  }

static bool ExecuteInsertOrderedList(LocalFrame& frame,
                                     Event*,
                                     EditorCommandSource,
                                     const String&) {
  DCHECK(frame.GetDocument());
  return InsertListCommand::Create(*frame.GetDocument(),
                                   InsertListCommand::kOrderedList)
      ->Apply();
}

void Editor::ReappliedEditing(UndoStep* cmd) {
  EventQueueScope scope;

  DispatchEditableContentChangedEvents(cmd->StartingRootEditableElement(),
                                       cmd->EndingRootEditableElement());
  DispatchInputEventEditableContentChanged(
      cmd->StartingRootEditableElement(), cmd->EndingRootEditableElement(),
      InputEvent::InputType::kHistoryRedo, g_null_atom,
      InputEvent::EventIsComposing::kNotComposing);

  const SelectionInDOMTree& new_selection = CorrectedSelectionAfterCommand(
      cmd->EndingSelection(), GetFrame().GetDocument());
  ChangeSelectionAfterCommand(
      new_selection,
      FrameSelection::kCloseTyping | FrameSelection::kClearTypingStyle);

  last_edit_command_ = nullptr;
  undo_stack_->RegisterUndoStep(cmd);
  RespondToChangedContents(new_selection.Base());
}

bool RenderProcessHost::ShouldTryToUseExistingProcessHost(
    BrowserContext* browser_context,
    const GURL& url) {
  if (run_renderer_in_process())
    return true;

  if (SiteIsolationPolicy::UseDedicatedProcessesForAllSites())
    return false;

  if (g_all_hosts.Get().size() >= GetMaxRendererProcessCount())
    return true;

  return GetContentClient()->browser()->ShouldTryToUseExistingProcessHost(
      browser_context, url);
}

static bool ExecuteDeleteBackward(LocalFrame& frame,
                                  Event*,
                                  EditorCommandSource,
                                  const String&) {
  frame.GetEditor().DeleteWithDirection(
      DeleteDirection::kBackward, TextGranularity::kCharacter, false, true);
  return true;
}

   size_t transferred() const { return transferred_; }

static bool ExecuteSelectSentence(LocalFrame& frame,
                                  Event*,
                                  EditorCommandSource,
                                  const String&) {
  return ExpandSelectionToGranularity(frame, TextGranularity::kSentence);
}

HostCache::Entry::Entry(int error,
                        const AddressList& addresses,
                        base::TimeDelta ttl)
    : error_(error), addresses_(addresses), ttl_(ttl) {
  DCHECK(ttl >= base::TimeDelta());
}

bool RenderProcessHostImpl::Shutdown(int exit_code, bool wait) {
  if (run_renderer_in_process())
    return false;  // Single process mode never shuts down the renderer.

  if (!child_process_launcher_.get())
    return false;

  return child_process_launcher_->Terminate(exit_code, wait);
}

VRDisplay::VRDisplay(NavigatorVR* navigator_vr,
                     device::mojom::blink::VRDisplayPtr display,
                     device::mojom::blink::VRDisplayClientRequest request)
    : ContextLifecycleObserver(navigator_vr->GetDocument()),
      navigator_vr_(navigator_vr),
      capabilities_(new VRDisplayCapabilities()),
      eye_parameters_left_(new VREyeParameters()),
      eye_parameters_right_(new VREyeParameters()),
      display_(std::move(display)),
      submit_frame_client_binding_(this),
      display_client_binding_(this, std::move(request)) {}

AudioRendererHost::LookupIteratorById(int stream_id) {
  DCHECK_CURRENTLY_ON(BrowserThread::IO);

  return std::find_if(
      delegates_.begin(), delegates_.end(),
      [stream_id](const std::unique_ptr<AudioOutputDelegate>& d) {
        return d->GetStreamId() == stream_id;
      });
}

bool VRDisplay::IsPresentationFocused() {
  if (!navigator_vr_)
    return false;

  if (navigator_vr_->IsFocused())
    return true;

  auto doc = navigator_vr_->GetDocument();
  if (!doc)
    return false;


  Frame* frame = doc->GetFrame();
  for (; frame; frame = frame->Tree().Parent()) {
    if (!frame->IsLocalFrame())
      break;
    auto frame_doc = ToLocalFrame(frame)->GetDocument();
    if (frame_doc && frame_doc->hasFocus()) {
      DVLOG(3) << __FUNCTION__ << ": a parent frame is focused";
      return true;
    }
  }

  return false;
}

static bool ExecuteMoveRight(LocalFrame& frame,
                             Event*,
                             EditorCommandSource,
                             const String&) {
  return frame.Selection().Modify(
      SelectionModifyAlteration::kMove, SelectionModifyDirection::kRight,
      TextGranularity::kCharacter, SetSelectionBy::kUser);
}

static const EditorInternalCommand* InternalCommand(
    const String& command_name) {
  static const EditorInternalCommand kEditorCommands[] = {
      {WebEditingCommandType::kAlignJustified, ExecuteJustifyFull,
       SupportedFromMenuOrKeyBinding, EnabledInRichlyEditableText, StateNone,
       ValueStateOrNull, kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kAlignLeft, ExecuteJustifyLeft,
       SupportedFromMenuOrKeyBinding, EnabledInRichlyEditableText, StateNone,
       ValueStateOrNull, kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kAlignRight, ExecuteJustifyRight,
       SupportedFromMenuOrKeyBinding, EnabledInRichlyEditableText, StateNone,
       ValueStateOrNull, kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kBackColor, ExecuteBackColor, Supported,
       EnabledInRichlyEditableText, StateNone, ValueBackColor,
       kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kBackwardDelete, ExecuteDeleteBackward,
       SupportedFromMenuOrKeyBinding, EnabledInEditableText, StateNone,
       ValueStateOrNull, kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kBold, ExecuteToggleBold, Supported,
       EnabledInRichlyEditableText, StateBold, ValueStateOrNull,
       kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kCopy, ExecuteCopy, Supported, EnabledCopy,
       StateNone, ValueStateOrNull, kNotTextInsertion,
       kAllowExecutionWhenDisabled},
      {WebEditingCommandType::kCreateLink, ExecuteCreateLink, Supported,
       EnabledInRichlyEditableText, StateNone, ValueStateOrNull,
       kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kCut, ExecuteCut, Supported, EnabledCut,
       StateNone, ValueStateOrNull, kNotTextInsertion,
       kAllowExecutionWhenDisabled},
      {WebEditingCommandType::kDefaultParagraphSeparator,
       ExecuteDefaultParagraphSeparator, Supported, Enabled, StateNone,
       ValueDefaultParagraphSeparator, kNotTextInsertion,
       kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kDelete, ExecuteDelete, Supported, EnabledDelete,
       StateNone, ValueStateOrNull, kNotTextInsertion,
       kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kDeleteBackward, ExecuteDeleteBackward,
       SupportedFromMenuOrKeyBinding, EnabledInEditableText, StateNone,
       ValueStateOrNull, kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kDeleteBackwardByDecomposingPreviousCharacter,
       ExecuteDeleteBackwardByDecomposingPreviousCharacter,
       SupportedFromMenuOrKeyBinding, EnabledInEditableText, StateNone,
       ValueStateOrNull, kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kDeleteForward, ExecuteDeleteForward,
       SupportedFromMenuOrKeyBinding, EnabledInEditableText, StateNone,
       ValueStateOrNull, kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kDeleteToBeginningOfLine,
       ExecuteDeleteToBeginningOfLine, SupportedFromMenuOrKeyBinding,
       EnabledInEditableText, StateNone, ValueStateOrNull, kNotTextInsertion,
       kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kDeleteToBeginningOfParagraph,
       ExecuteDeleteToBeginningOfParagraph, SupportedFromMenuOrKeyBinding,
       EnabledInEditableText, StateNone, ValueStateOrNull, kNotTextInsertion,
       kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kDeleteToEndOfLine, ExecuteDeleteToEndOfLine,
       SupportedFromMenuOrKeyBinding, EnabledInEditableText, StateNone,
       ValueStateOrNull, kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kDeleteToEndOfParagraph,
       ExecuteDeleteToEndOfParagraph, SupportedFromMenuOrKeyBinding,
       EnabledInEditableText, StateNone, ValueStateOrNull, kNotTextInsertion,
       kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kDeleteToMark, ExecuteDeleteToMark,
       SupportedFromMenuOrKeyBinding, EnabledInEditableText, StateNone,
       ValueStateOrNull, kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kDeleteWordBackward, ExecuteDeleteWordBackward,
       SupportedFromMenuOrKeyBinding, EnabledInEditableText, StateNone,
       ValueStateOrNull, kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kDeleteWordForward, ExecuteDeleteWordForward,
       SupportedFromMenuOrKeyBinding, EnabledInEditableText, StateNone,
       ValueStateOrNull, kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kFindString, ExecuteFindString, Supported,
       Enabled, StateNone, ValueStateOrNull, kNotTextInsertion,
       kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kFontName, ExecuteFontName, Supported,
       EnabledInRichlyEditableText, StateNone, ValueFontName, kNotTextInsertion,
       kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kFontSize, ExecuteFontSize, Supported,
       EnabledInRichlyEditableText, StateNone, ValueFontSize, kNotTextInsertion,
       kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kFontSizeDelta, ExecuteFontSizeDelta, Supported,
       EnabledInRichlyEditableText, StateNone, ValueFontSizeDelta,
       kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kForeColor, ExecuteForeColor, Supported,
       EnabledInRichlyEditableText, StateNone, ValueForeColor,
       kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kFormatBlock, ExecuteFormatBlock, Supported,
       EnabledInRichlyEditableText, StateNone, ValueFormatBlock,
       kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kForwardDelete, ExecuteForwardDelete, Supported,
       EnabledInEditableText, StateNone, ValueStateOrNull, kNotTextInsertion,
       kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kHiliteColor, ExecuteBackColor, Supported,
       EnabledInRichlyEditableText, StateNone, ValueStateOrNull,
       kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kIgnoreSpelling, ExecuteIgnoreSpelling,
       SupportedFromMenuOrKeyBinding, EnabledInEditableText, StateNone,
       ValueStateOrNull, kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kIndent, ExecuteIndent, Supported,
       EnabledInRichlyEditableText, StateNone, ValueStateOrNull,
       kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kInsertBacktab, ExecuteInsertBacktab,
       SupportedFromMenuOrKeyBinding, EnabledInEditableText, StateNone,
       ValueStateOrNull, kIsTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kInsertHTML, ExecuteInsertHTML, Supported,
       EnabledInEditableText, StateNone, ValueStateOrNull, kNotTextInsertion,
       kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kInsertHorizontalRule,
       ExecuteInsertHorizontalRule, Supported, EnabledInRichlyEditableText,
       StateNone, ValueStateOrNull, kNotTextInsertion,
       kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kInsertImage, ExecuteInsertImage, Supported,
       EnabledInRichlyEditableText, StateNone, ValueStateOrNull,
       kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kInsertLineBreak, ExecuteInsertLineBreak,
       Supported, EnabledInEditableText, StateNone, ValueStateOrNull,
       kIsTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kInsertNewline, ExecuteInsertNewline,
       SupportedFromMenuOrKeyBinding, EnabledInEditableText, StateNone,
       ValueStateOrNull, kIsTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kInsertNewlineInQuotedContent,
       ExecuteInsertNewlineInQuotedContent, Supported,
       EnabledInRichlyEditableText, StateNone, ValueStateOrNull,
       kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kInsertOrderedList, ExecuteInsertOrderedList,
       Supported, EnabledInRichlyEditableText, StateOrderedList,
       ValueStateOrNull, kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kInsertParagraph, ExecuteInsertParagraph,
       Supported, EnabledInEditableText, StateNone, ValueStateOrNull,
       kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kInsertTab, ExecuteInsertTab,
       SupportedFromMenuOrKeyBinding, EnabledInEditableText, StateNone,
       ValueStateOrNull, kIsTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kInsertText, ExecuteInsertText, Supported,
       EnabledInEditableText, StateNone, ValueStateOrNull, kIsTextInsertion,
       kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kInsertUnorderedList, ExecuteInsertUnorderedList,
       Supported, EnabledInRichlyEditableText, StateUnorderedList,
       ValueStateOrNull, kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kItalic, ExecuteToggleItalic, Supported,
       EnabledInRichlyEditableText, StateItalic, ValueStateOrNull,
       kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kJustifyCenter, ExecuteJustifyCenter, Supported,
       EnabledInRichlyEditableText, StateJustifyCenter, ValueStateOrNull,
       kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kJustifyFull, ExecuteJustifyFull, Supported,
       EnabledInRichlyEditableText, StateJustifyFull, ValueStateOrNull,
       kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kJustifyLeft, ExecuteJustifyLeft, Supported,
       EnabledInRichlyEditableText, StateJustifyLeft, ValueStateOrNull,
       kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kJustifyNone, ExecuteJustifyLeft, Supported,
       EnabledInRichlyEditableText, StateNone, ValueStateOrNull,
       kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kJustifyRight, ExecuteJustifyRight, Supported,
       EnabledInRichlyEditableText, StateJustifyRight, ValueStateOrNull,
       kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kMakeTextWritingDirectionLeftToRight,
       ExecuteMakeTextWritingDirectionLeftToRight,
       SupportedFromMenuOrKeyBinding, EnabledInRichlyEditableText,
       StateTextWritingDirectionLeftToRight, ValueStateOrNull,
       kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kMakeTextWritingDirectionNatural,
       ExecuteMakeTextWritingDirectionNatural, SupportedFromMenuOrKeyBinding,
       EnabledInRichlyEditableText, StateTextWritingDirectionNatural,
       ValueStateOrNull, kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kMakeTextWritingDirectionRightToLeft,
       ExecuteMakeTextWritingDirectionRightToLeft,
       SupportedFromMenuOrKeyBinding, EnabledInRichlyEditableText,
       StateTextWritingDirectionRightToLeft, ValueStateOrNull,
       kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kMoveBackward, ExecuteMoveBackward,
       SupportedFromMenuOrKeyBinding, EnabledInEditableText, StateNone,
       ValueStateOrNull, kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kMoveBackwardAndModifySelection,
       ExecuteMoveBackwardAndModifySelection, SupportedFromMenuOrKeyBinding,
       EnabledVisibleSelection, StateNone, ValueStateOrNull, kNotTextInsertion,
       kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kMoveDown, ExecuteMoveDown,
       SupportedFromMenuOrKeyBinding, EnabledInEditableText, StateNone,
       ValueStateOrNull, kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kMoveDownAndModifySelection,
       ExecuteMoveDownAndModifySelection, SupportedFromMenuOrKeyBinding,
       EnabledVisibleSelection, StateNone, ValueStateOrNull, kNotTextInsertion,
       kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kMoveForward, ExecuteMoveForward,
       SupportedFromMenuOrKeyBinding, EnabledInEditableText, StateNone,
       ValueStateOrNull, kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kMoveForwardAndModifySelection,
       ExecuteMoveForwardAndModifySelection, SupportedFromMenuOrKeyBinding,
       EnabledVisibleSelection, StateNone, ValueStateOrNull, kNotTextInsertion,
       kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kMoveLeft, ExecuteMoveLeft,
       SupportedFromMenuOrKeyBinding, EnabledInEditableText, StateNone,
       ValueStateOrNull, kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kMoveLeftAndModifySelection,
       ExecuteMoveLeftAndModifySelection, SupportedFromMenuOrKeyBinding,
       EnabledVisibleSelection, StateNone, ValueStateOrNull, kNotTextInsertion,
       kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kMovePageDown, ExecuteMovePageDown,
       SupportedFromMenuOrKeyBinding, EnabledInEditableText, StateNone,
       ValueStateOrNull, kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kMovePageDownAndModifySelection,
       ExecuteMovePageDownAndModifySelection, SupportedFromMenuOrKeyBinding,
       EnabledVisibleSelection, StateNone, ValueStateOrNull, kNotTextInsertion,
       kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kMovePageUp, ExecuteMovePageUp,
       SupportedFromMenuOrKeyBinding, EnabledInEditableText, StateNone,
       ValueStateOrNull, kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kMovePageUpAndModifySelection,
       ExecuteMovePageUpAndModifySelection, SupportedFromMenuOrKeyBinding,
       EnabledVisibleSelection, StateNone, ValueStateOrNull, kNotTextInsertion,
       kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kMoveParagraphBackward,
       ExecuteMoveParagraphBackward, SupportedFromMenuOrKeyBinding,
       EnabledInEditableText, StateNone, ValueStateOrNull, kNotTextInsertion,
       kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kMoveParagraphBackwardAndModifySelection,
       ExecuteMoveParagraphBackwardAndModifySelection,
       SupportedFromMenuOrKeyBinding, EnabledVisibleSelection, StateNone,
       ValueStateOrNull, kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kMoveParagraphForward,
       ExecuteMoveParagraphForward, SupportedFromMenuOrKeyBinding,
       EnabledInEditableText, StateNone, ValueStateOrNull, kNotTextInsertion,
       kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kMoveParagraphForwardAndModifySelection,
       ExecuteMoveParagraphForwardAndModifySelection,
       SupportedFromMenuOrKeyBinding, EnabledVisibleSelection, StateNone,
       ValueStateOrNull, kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kMoveRight, ExecuteMoveRight,
       SupportedFromMenuOrKeyBinding, EnabledInEditableText, StateNone,
       ValueStateOrNull, kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kMoveRightAndModifySelection,
       ExecuteMoveRightAndModifySelection, SupportedFromMenuOrKeyBinding,
       EnabledVisibleSelection, StateNone, ValueStateOrNull, kNotTextInsertion,
       kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kMoveToBeginningOfDocument,
       ExecuteMoveToBeginningOfDocument, SupportedFromMenuOrKeyBinding,
       EnabledInEditableText, StateNone, ValueStateOrNull, kNotTextInsertion,
       kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kMoveToBeginningOfDocumentAndModifySelection,
       ExecuteMoveToBeginningOfDocumentAndModifySelection,
       SupportedFromMenuOrKeyBinding, EnabledVisibleSelection, StateNone,
       ValueStateOrNull, kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kMoveToBeginningOfLine,
       ExecuteMoveToBeginningOfLine, SupportedFromMenuOrKeyBinding,
       EnabledInEditableText, StateNone, ValueStateOrNull, kNotTextInsertion,
       kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kMoveToBeginningOfLineAndModifySelection,
       ExecuteMoveToBeginningOfLineAndModifySelection,
       SupportedFromMenuOrKeyBinding, EnabledVisibleSelection, StateNone,
       ValueStateOrNull, kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kMoveToBeginningOfParagraph,
       ExecuteMoveToBeginningOfParagraph, SupportedFromMenuOrKeyBinding,
       EnabledInEditableText, StateNone, ValueStateOrNull, kNotTextInsertion,
       kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kMoveToBeginningOfParagraphAndModifySelection,
       ExecuteMoveToBeginningOfParagraphAndModifySelection,
       SupportedFromMenuOrKeyBinding, EnabledVisibleSelection, StateNone,
       ValueStateOrNull, kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kMoveToBeginningOfSentence,
       ExecuteMoveToBeginningOfSentence, SupportedFromMenuOrKeyBinding,
       EnabledInEditableText, StateNone, ValueStateOrNull, kNotTextInsertion,
       kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kMoveToBeginningOfSentenceAndModifySelection,
       ExecuteMoveToBeginningOfSentenceAndModifySelection,
       SupportedFromMenuOrKeyBinding, EnabledVisibleSelection, StateNone,
       ValueStateOrNull, kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kMoveToEndOfDocument, ExecuteMoveToEndOfDocument,
       SupportedFromMenuOrKeyBinding, EnabledInEditableText, StateNone,
       ValueStateOrNull, kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kMoveToEndOfDocumentAndModifySelection,
       ExecuteMoveToEndOfDocumentAndModifySelection,
       SupportedFromMenuOrKeyBinding, EnabledVisibleSelection, StateNone,
       ValueStateOrNull, kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kMoveToEndOfLine, ExecuteMoveToEndOfLine,
       SupportedFromMenuOrKeyBinding, EnabledInEditableText, StateNone,
       ValueStateOrNull, kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kMoveToEndOfLineAndModifySelection,
       ExecuteMoveToEndOfLineAndModifySelection, SupportedFromMenuOrKeyBinding,
       EnabledVisibleSelection, StateNone, ValueStateOrNull, kNotTextInsertion,
       kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kMoveToEndOfParagraph,
       ExecuteMoveToEndOfParagraph, SupportedFromMenuOrKeyBinding,
       EnabledInEditableText, StateNone, ValueStateOrNull, kNotTextInsertion,
       kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kMoveToEndOfParagraphAndModifySelection,
       ExecuteMoveToEndOfParagraphAndModifySelection,
       SupportedFromMenuOrKeyBinding, EnabledVisibleSelection, StateNone,
       ValueStateOrNull, kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kMoveToEndOfSentence, ExecuteMoveToEndOfSentence,
       SupportedFromMenuOrKeyBinding, EnabledInEditableText, StateNone,
       ValueStateOrNull, kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kMoveToEndOfSentenceAndModifySelection,
       ExecuteMoveToEndOfSentenceAndModifySelection,
       SupportedFromMenuOrKeyBinding, EnabledVisibleSelection, StateNone,
       ValueStateOrNull, kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kMoveToLeftEndOfLine, ExecuteMoveToLeftEndOfLine,
       SupportedFromMenuOrKeyBinding, EnabledInEditableText, StateNone,
       ValueStateOrNull, kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kMoveToLeftEndOfLineAndModifySelection,
       ExecuteMoveToLeftEndOfLineAndModifySelection,
       SupportedFromMenuOrKeyBinding, EnabledInEditableText, StateNone,
       ValueStateOrNull, kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kMoveToRightEndOfLine,
       ExecuteMoveToRightEndOfLine, SupportedFromMenuOrKeyBinding,
       EnabledInEditableText, StateNone, ValueStateOrNull, kNotTextInsertion,
       kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kMoveToRightEndOfLineAndModifySelection,
       ExecuteMoveToRightEndOfLineAndModifySelection,
       SupportedFromMenuOrKeyBinding, EnabledInEditableText, StateNone,
       ValueStateOrNull, kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kMoveUp, ExecuteMoveUp,
       SupportedFromMenuOrKeyBinding, EnabledInEditableText, StateNone,
       ValueStateOrNull, kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kMoveUpAndModifySelection,
       ExecuteMoveUpAndModifySelection, SupportedFromMenuOrKeyBinding,
       EnabledVisibleSelection, StateNone, ValueStateOrNull, kNotTextInsertion,
       kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kMoveWordBackward, ExecuteMoveWordBackward,
       SupportedFromMenuOrKeyBinding, EnabledInEditableText, StateNone,
       ValueStateOrNull, kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kMoveWordBackwardAndModifySelection,
       ExecuteMoveWordBackwardAndModifySelection, SupportedFromMenuOrKeyBinding,
       EnabledVisibleSelection, StateNone, ValueStateOrNull, kNotTextInsertion,
       kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kMoveWordForward, ExecuteMoveWordForward,
       SupportedFromMenuOrKeyBinding, EnabledInEditableText, StateNone,
       ValueStateOrNull, kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kMoveWordForwardAndModifySelection,
       ExecuteMoveWordForwardAndModifySelection, SupportedFromMenuOrKeyBinding,
       EnabledVisibleSelection, StateNone, ValueStateOrNull, kNotTextInsertion,
       kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kMoveWordLeft, ExecuteMoveWordLeft,
       SupportedFromMenuOrKeyBinding, EnabledInEditableText, StateNone,
       ValueStateOrNull, kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kMoveWordLeftAndModifySelection,
       ExecuteMoveWordLeftAndModifySelection, SupportedFromMenuOrKeyBinding,
       EnabledVisibleSelection, StateNone, ValueStateOrNull, kNotTextInsertion,
       kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kMoveWordRight, ExecuteMoveWordRight,
       SupportedFromMenuOrKeyBinding, EnabledInEditableText, StateNone,
       ValueStateOrNull, kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kMoveWordRightAndModifySelection,
       ExecuteMoveWordRightAndModifySelection, SupportedFromMenuOrKeyBinding,
       EnabledVisibleSelection, StateNone, ValueStateOrNull, kNotTextInsertion,
       kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kOutdent, ExecuteOutdent, Supported,
       EnabledInRichlyEditableText, StateNone, ValueStateOrNull,
       kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kOverWrite, ExecuteToggleOverwrite,
       SupportedFromMenuOrKeyBinding, EnabledInRichlyEditableText, StateNone,
       ValueStateOrNull, kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kPaste, ExecutePaste, Supported, EnabledPaste,
       StateNone, ValueStateOrNull, kNotTextInsertion,
       kAllowExecutionWhenDisabled},
      {WebEditingCommandType::kPasteAndMatchStyle, ExecutePasteAndMatchStyle,
       Supported, EnabledPaste, StateNone, ValueStateOrNull, kNotTextInsertion,
       kAllowExecutionWhenDisabled},
      {WebEditingCommandType::kPasteGlobalSelection,
       ExecutePasteGlobalSelection, SupportedFromMenuOrKeyBinding, EnabledPaste,
       StateNone, ValueStateOrNull, kNotTextInsertion,
       kAllowExecutionWhenDisabled},
      {WebEditingCommandType::kPrint, ExecutePrint, Supported, Enabled,
       StateNone, ValueStateOrNull, kNotTextInsertion,
       kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kRedo, ExecuteRedo, Supported, EnabledRedo,
       StateNone, ValueStateOrNull, kNotTextInsertion,
       kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kRemoveFormat, ExecuteRemoveFormat, Supported,
       EnabledRangeInEditableText, StateNone, ValueStateOrNull,
       kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kScrollPageBackward, ExecuteScrollPageBackward,
       SupportedFromMenuOrKeyBinding, Enabled, StateNone, ValueStateOrNull,
       kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kScrollPageForward, ExecuteScrollPageForward,
       SupportedFromMenuOrKeyBinding, Enabled, StateNone, ValueStateOrNull,
       kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kScrollLineUp, ExecuteScrollLineUp,
       SupportedFromMenuOrKeyBinding, Enabled, StateNone, ValueStateOrNull,
       kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kScrollLineDown, ExecuteScrollLineDown,
       SupportedFromMenuOrKeyBinding, Enabled, StateNone, ValueStateOrNull,
       kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kScrollToBeginningOfDocument,
       ExecuteScrollToBeginningOfDocument, SupportedFromMenuOrKeyBinding,
       Enabled, StateNone, ValueStateOrNull, kNotTextInsertion,
       kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kScrollToEndOfDocument,
       ExecuteScrollToEndOfDocument, SupportedFromMenuOrKeyBinding, Enabled,
       StateNone, ValueStateOrNull, kNotTextInsertion,
       kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kSelectAll, ExecuteSelectAll, Supported,
       EnabledSelectAll, StateNone, ValueStateOrNull, kNotTextInsertion,
       kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kSelectLine, ExecuteSelectLine,
       SupportedFromMenuOrKeyBinding, EnabledVisibleSelection, StateNone,
       ValueStateOrNull, kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kSelectParagraph, ExecuteSelectParagraph,
       SupportedFromMenuOrKeyBinding, EnabledVisibleSelection, StateNone,
       ValueStateOrNull, kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kSelectSentence, ExecuteSelectSentence,
       SupportedFromMenuOrKeyBinding, EnabledVisibleSelection, StateNone,
       ValueStateOrNull, kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kSelectToMark, ExecuteSelectToMark,
       SupportedFromMenuOrKeyBinding, EnabledVisibleSelectionAndMark, StateNone,
       ValueStateOrNull, kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kSelectWord, ExecuteSelectWord,
       SupportedFromMenuOrKeyBinding, EnabledVisibleSelection, StateNone,
       ValueStateOrNull, kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kSetMark, ExecuteSetMark,
       SupportedFromMenuOrKeyBinding, EnabledVisibleSelection, StateNone,
       ValueStateOrNull, kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kStrikethrough, ExecuteStrikethrough, Supported,
       EnabledInRichlyEditableText, StateStrikethrough, ValueStateOrNull,
       kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kStyleWithCSS, ExecuteStyleWithCSS, Supported,
       Enabled, StateStyleWithCSS, ValueEmpty, kNotTextInsertion,
       kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kSubscript, ExecuteSubscript, Supported,
       EnabledInRichlyEditableText, StateSubscript, ValueStateOrNull,
       kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kSuperscript, ExecuteSuperscript, Supported,
       EnabledInRichlyEditableText, StateSuperscript, ValueStateOrNull,
       kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kSwapWithMark, ExecuteSwapWithMark,
       SupportedFromMenuOrKeyBinding, EnabledVisibleSelectionAndMark, StateNone,
       ValueStateOrNull, kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kToggleBold, ExecuteToggleBold,
       SupportedFromMenuOrKeyBinding, EnabledInRichlyEditableText, StateBold,
       ValueStateOrNull, kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kToggleItalic, ExecuteToggleItalic,
       SupportedFromMenuOrKeyBinding, EnabledInRichlyEditableText, StateItalic,
       ValueStateOrNull, kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kToggleUnderline, ExecuteUnderline,
       SupportedFromMenuOrKeyBinding, EnabledInRichlyEditableText,
       StateUnderline, ValueStateOrNull, kNotTextInsertion,
       kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kTranspose, ExecuteTranspose, Supported,
       EnableCaretInEditableText, StateNone, ValueStateOrNull,
       kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kUnderline, ExecuteUnderline, Supported,
       EnabledInRichlyEditableText, StateUnderline, ValueStateOrNull,
       kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kUndo, ExecuteUndo, Supported, EnabledUndo,
       StateNone, ValueStateOrNull, kNotTextInsertion,
       kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kUnlink, ExecuteUnlink, Supported,
       EnabledRangeInRichlyEditableText, StateNone, ValueStateOrNull,
       kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kUnscript, ExecuteUnscript,
       SupportedFromMenuOrKeyBinding, EnabledInRichlyEditableText, StateNone,
       ValueStateOrNull, kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kUnselect, ExecuteUnselect, Supported,
       EnabledUnselect, StateNone, ValueStateOrNull, kNotTextInsertion,
       kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kUseCSS, ExecuteUseCSS, Supported, Enabled,
       StateNone, ValueStateOrNull, kNotTextInsertion,
       kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kYank, ExecuteYank, SupportedFromMenuOrKeyBinding,
       EnabledInEditableText, StateNone, ValueStateOrNull, kNotTextInsertion,
       kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kYankAndSelect, ExecuteYankAndSelect,
       SupportedFromMenuOrKeyBinding, EnabledInEditableText, StateNone,
       ValueStateOrNull, kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
      {WebEditingCommandType::kAlignCenter, ExecuteJustifyCenter,
       SupportedFromMenuOrKeyBinding, EnabledInRichlyEditableText, StateNone,
       ValueStateOrNull, kNotTextInsertion, kDoNotAllowExecutionWhenDisabled},
  };
  static_assert(
      arraysize(kEditorCommands) + 1 ==
          static_cast<size_t>(WebEditingCommandType::kNumberOfCommandTypes),
      "must handle all valid WebEditingCommandType");

  WebEditingCommandType command_type =
      WebEditingCommandTypeFromCommandName(command_name);
  if (command_type == WebEditingCommandType::kInvalid)
    return nullptr;

  int command_index = static_cast<int>(command_type) - 1;
  DCHECK(command_index >= 0 &&
         command_index < static_cast<int>(arraysize(kEditorCommands)));
  return &kEditorCommands[command_index];
}

inline void ImageLoader::clearFailedLoadURL() {
  m_failedLoadURL = AtomicString();
}

static bool ExecuteMoveToBeginningOfLineAndModifySelection(LocalFrame& frame,
                                                           Event*,
                                                           EditorCommandSource,
                                                           const String&) {
  frame.Selection().Modify(
      SelectionModifyAlteration::kExtend, SelectionModifyDirection::kBackward,
      TextGranularity::kLineBoundary, SetSelectionBy::kUser);
  return true;
}

 void HostCache::ClearForHosts(
    const base::Callback<bool(const std::string&)>& host_filter) {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);

  if (host_filter.is_null()) {
    clear();
     return;
   }
 
   base::TimeTicks now = base::TimeTicks::Now();
   for (EntryMap::iterator it = entries_.begin(); it != entries_.end();) {
     EntryMap::iterator next_it = std::next(it);
 
     if (host_filter.Run(it->first.hostname)) {
       RecordErase(ERASE_CLEAR, now, it->second);
       entries_.erase(it);
     }
 
     it = next_it;
   }
 }

void SVGFEColorMatrixElement::svgAttributeChanged(const QualifiedName& attrName)
{
    if (!isSupportedAttribute(attrName)) {
        SVGFilterPrimitiveStandardAttributes::svgAttributeChanged(attrName);
        return;
    }

    SVGElement::InvalidationGuard invalidationGuard(this);

    if (attrName == SVGNames::typeAttr || attrName == SVGNames::valuesAttr) {
        primitiveAttributeChanged(attrName);
        return;
    }

    if (attrName == SVGNames::inAttr) {
        invalidate();
        return;
    }

    ASSERT_NOT_REACHED();
}

static bool ExecuteCreateLink(LocalFrame& frame,
                              Event*,
                              EditorCommandSource,
                              const String& value) {
  if (value.IsEmpty())
    return false;
  DCHECK(frame.GetDocument());
  return CreateLinkCommand::Create(*frame.GetDocument(), value)->Apply();
}

void RenderProcessHostImpl::WidgetRestored() {
  visible_widgets_++;
  UpdateProcessPriority();
  DCHECK(!is_process_backgrounded_);
}

bool RenderProcessHostImpl::Send(IPC::Message* msg) {
  TRACE_EVENT0("renderer_host", "RenderProcessHostImpl::Send");

  std::unique_ptr<IPC::Message> message(msg);

  if (!channel_)
    return false;

#if !defined(OS_ANDROID)
  DCHECK(!message->is_sync());
#else
  if (message->is_sync()) {
    if (!HasConnection())
      return false;

    if (child_process_launcher_.get() && child_process_launcher_->IsStarting())
      return false;
  }
#endif

  return channel_->Send(message.release());
}

void RenderProcessHostImpl::SendDisableAecDumpToRenderer() {
  Send(new AecDumpMsg_DisableAecDump());
}

void AudioRendererHost::OnStreamError(int stream_id) {
  DCHECK_CURRENTLY_ON(BrowserThread::IO);

  SendErrorMessage(stream_id);
  OnCloseStream(stream_id);
}

static bool ExecuteMoveWordRightAndModifySelection(LocalFrame& frame,
                                                   Event*,
                                                   EditorCommandSource,
                                                   const String&) {
  frame.Selection().Modify(SelectionModifyAlteration::kExtend,
                           SelectionModifyDirection::kRight,
                           TextGranularity::kWord, SetSelectionBy::kUser);
  return true;
}

 std::unique_ptr<base::ListValue> HostCache::GetAsListValue(
    bool include_staleness) const {
  std::unique_ptr<base::ListValue> entry_list(new base::ListValue());

  for (const auto& pair : entries_) {
    const Key& key = pair.first;
    const Entry& entry = pair.second;

    std::unique_ptr<base::DictionaryValue> entry_dict(
        new base::DictionaryValue());

    entry_dict->SetString(kHostnameKey, key.hostname);
    entry_dict->SetInteger(kAddressFamilyKey,
                           static_cast<int>(key.address_family));
    entry_dict->SetInteger(kFlagsKey, key.host_resolver_flags);

    if (include_staleness) {
      entry_dict->SetString(kExpirationKey,
                            NetLog::TickCountToString(entry.expires()));
      entry_dict->SetInteger(kTtlKey, entry.ttl().InMilliseconds());
      entry_dict->SetInteger(kNetworkChangesKey, entry.network_changes());
    } else {
      base::Time expiration_time =
          base::Time::Now() - (base::TimeTicks::Now() - entry.expires());
      entry_dict->SetString(
          kExpirationKey,
          base::Int64ToString(expiration_time.ToInternalValue()));
    }

    if (entry.error() != OK) {
      entry_dict->SetInteger(kErrorKey, entry.error());
    } else {
      const AddressList& addresses = entry.addresses();
      auto addresses_value = base::MakeUnique<base::ListValue>();
      for (size_t i = 0; i < addresses.size(); ++i)
        addresses_value->AppendString(addresses[i].ToStringWithoutPort());
      entry_dict->SetList(kAddressesKey, std::move(addresses_value));
    }

    entry_list->Append(std::move(entry_dict));
  }

  return entry_list;
}

bool AddressListFromListValue(const base::ListValue* value, AddressList* list) {
  list->clear();
  for (base::ListValue::const_iterator it = value->begin(); it != value->end();
       it++) {
    IPAddress address;
    std::string addr_string;
    if (!it->GetAsString(&addr_string) ||
        !address.AssignFromIPLiteral(addr_string)) {
      return false;
    }
    list->push_back(IPEndPoint(address, 0));
  }
  return true;
}

static bool ExecuteOutdent(LocalFrame& frame,
                           Event*,
                           EditorCommandSource,
                           const String&) {
  DCHECK(frame.GetDocument());
  return IndentOutdentCommand::Create(*frame.GetDocument(),
                                      IndentOutdentCommand::kOutdent)
      ->Apply();
}

static bool ExecuteApplyStyle(LocalFrame& frame,
                              EditorCommandSource source,
                              InputEvent::InputType input_type,
                              CSSPropertyID property_id,
                              CSSValueID property_value) {
  MutableStylePropertySet* style =
      MutableStylePropertySet::Create(kHTMLQuirksMode);
  style->SetProperty(property_id, property_value);
  return ApplyCommandToFrame(frame, source, input_type, style);
}

  void OnNotifyDeviceAuthorized(int stream_id,
                                media::OutputDeviceStatus device_status,
                                const media::AudioParameters& output_params,
                                const std::string& matched_device_id) {
    EXPECT_TRUE(IsValidDeviceId(matched_device_id));

    OnDeviceAuthorized(stream_id, device_status, output_params,
                       matched_device_id);
    auth_run_loop_->Quit();
  }

static bool ExecuteStyleWithCSS(LocalFrame& frame,
                                Event*,
                                EditorCommandSource,
                                const String& value) {
  frame.GetEditor().SetShouldStyleWithCSS(
      !DeprecatedEqualIgnoringCase(value, "false"));
  return true;
}

  std::string GetRawNondefaultId() {
    std::string id;
    BrowserThread::PostTask(
        BrowserThread::IO, FROM_HERE,
        base::Bind(
            &AudioOutputAuthorizationHandlerTest::GetRawNondefaultIdOnIOThread,
            base::Unretained(this), base::Unretained(&id)));
    SyncWithAllThreads();
    return id;
  }

static bool ExecuteMoveToEndOfSentenceAndModifySelection(LocalFrame& frame,
                                                         Event*,
                                                         EditorCommandSource,
                                                         const String&) {
  frame.Selection().Modify(
      SelectionModifyAlteration::kExtend, SelectionModifyDirection::kForward,
      TextGranularity::kSentenceBoundary, SetSelectionBy::kUser);
  return true;
}

bool HarfBuzzShaper::shape(GlyphBuffer* glyphBuffer)
{
if (!createHarfBuzzRuns())
return false;

    m_totalWidth = 0;
if (!shapeHarfBuzzRuns())
return false;

if (glyphBuffer && !fillGlyphBuffer(glyphBuffer))
return false;

return true;
}

RenderProcessHost* RenderProcessHostImpl::GetProcessHostForSite(
    BrowserContext* browser_context,
    const GURL& url) {
  SiteProcessMap* map = GetSiteProcessMapForBrowserContext(browser_context);

  std::string site =
      SiteInstance::GetSiteForURL(browser_context, url).possibly_invalid_spec();
  RenderProcessHost* host = map->FindProcess(site);
  if (host && (!host->MayReuseHost() ||
               !IsSuitableHost(host, browser_context, url))) {
    RecordAction(
        base::UserMetricsAction("BindingsMismatch_GetProcessHostPerSite"));
    map->RemoveProcess(host);
    host = NULL;
  }

  return host;
}

bool Editor::Command::IsEnabled(Event* triggering_event) const {
  if (!IsSupported() || !frame_)
    return false;
  return command_->is_enabled(*frame_, triggering_event, source_);
}

static bool ExecuteJustifyLeft(LocalFrame& frame,
                               Event*,
                               EditorCommandSource source,
                               const String&) {
  return ExecuteApplyParagraphStyle(frame, source,
                                    InputEvent::InputType::kFormatJustifyLeft,
                                    CSSPropertyTextAlign, "left");
}

int Editor::Command::IdForHistogram() const {
  return IsSupported() ? static_cast<int>(command_->command_type) : 0;
}

  SessionStorageHolder()
      : session_storage_namespaces_awaiting_close_(
            new std::map<int, SessionStorageNamespaceMap>) {
  }

void RenderProcessHostImpl::EnableSendQueue() {
  if (!channel_)
    InitializeChannelProxy();
}

static bool ExecuteUnscript(LocalFrame& frame,
                            Event*,
                            EditorCommandSource source,
                            const String&) {
  return ExecuteApplyStyle(frame, source, InputEvent::InputType::kNone,
                           CSSPropertyVerticalAlign, "baseline");
}

static bool ExecuteMoveWordRight(LocalFrame& frame,
                                 Event*,
                                 EditorCommandSource,
                                 const String&) {
  frame.Selection().Modify(SelectionModifyAlteration::kMove,
                           SelectionModifyDirection::kRight,
                           TextGranularity::kWord, SetSelectionBy::kUser);
  return true;
}

void VRDisplay::OnVSync(device::mojom::blink::VRPosePtr pose,
                         mojo::common::mojom::blink::TimeDeltaPtr time,
                         int16_t frame_id,
                         device::mojom::blink::VRVSyncProvider::Status error) {
   v_sync_connection_failed_ = false;
   switch (error) {
     case device::mojom::blink::VRVSyncProvider::Status::SUCCESS:
      break;
    case device::mojom::blink::VRVSyncProvider::Status::CLOSING:
      return;
  }
  pending_vsync_ = false;

  WTF::TimeDelta time_delta =
      WTF::TimeDelta::FromMicroseconds(time->microseconds);
  if (timebase_ < 0) {
    timebase_ = WTF::MonotonicallyIncreasingTime() - time_delta.InSecondsF();
  }

  frame_pose_ = std::move(pose);
  vr_frame_id_ = frame_id;

  Platform::Current()->CurrentThread()->GetWebTaskRunner()->PostTask(
      BLINK_FROM_HERE,
      WTF::Bind(&VRDisplay::ProcessScheduledAnimations,
                WrapWeakPersistent(this), timebase_ + time_delta.InSecondsF()));
}

void AudioRendererHost::OnCloseStream(int stream_id) {
  DCHECK_CURRENTLY_ON(BrowserThread::IO);
  authorizations_.erase(stream_id);

  auto i = LookupIteratorById(stream_id);

  if (i == delegates_.end())
    return;

  std::swap(*i, delegates_.back());
  delegates_.pop_back();
}

static TriState StateNone(LocalFrame&, Event*) {
  return kFalseTriState;
}

Editor::Command Editor::CreateCommand(const String& command_name) {
  return Command(InternalCommand(command_name), kCommandFromMenuOrKeyBinding,
                 frame_);
}

static inline bool resolveCandidateRuns(Vector<CandidateRun>& runs)
{
    UScriptCode scriptExtensions[USCRIPT_CODE_LIMIT];
    UErrorCode errorCode = U_ZERO_ERROR;
    size_t length = runs.size();
    size_t nextResolvedRun = 0;
    for (size_t i = 0; i < length; i++) {
        CandidateRun& run = runs[i];
        nextResolvedRun = 0;

        if (run.script == USCRIPT_INHERITED)
            run.script = i > 0 ? runs[i - 1].script : USCRIPT_COMMON;

        int extensionsLength = uscript_getScriptExtensions(run.character,
            scriptExtensions, sizeof(scriptExtensions) / sizeof(scriptExtensions[0]),
            &errorCode);
        if (U_FAILURE(errorCode))
            return false;

        resolveRunBasedOnScriptExtensions(runs, run, i, length,
            scriptExtensions, extensionsLength, nextResolvedRun);
        resolveRunBasedOnScriptValue(runs, run, i, length,
            nextResolvedRun);
        for (size_t j = i; j < nextResolvedRun; j++)
            runs[j].script = runs[nextResolvedRun].script;

        i = std::max(i, nextResolvedRun);
    }
    return true;
}

static TriState StateBold(LocalFrame& frame, Event*) {
  return StateStyle(frame, CSSPropertyFontWeight, "bold");
}

static bool ExecuteMovePageUpAndModifySelection(LocalFrame& frame,
                                                Event*,
                                                EditorCommandSource,
                                                const String&) {
  unsigned distance = VerticalScrollDistance(frame);
  if (!distance)
    return false;
  return ModifySelectionyWithPageGranularity(
      frame, SelectionModifyAlteration::kExtend, distance,
      SelectionModifyVerticalDirection::kUp);
}

void AudioRendererHost::OverrideDevicePermissionsForTesting(bool has_access) {
  authorization_handler_.OverridePermissionsForTesting(has_access);
}

const base::TimeTicks& RenderProcessHostImpl::GetInitTimeForNavigationMetrics()
    const {
  return init_time_;
}

void RenderProcessHostImpl::CreateMessageFilters() {
DCHECK_CURRENTLY_ON(BrowserThread::UI);
AddFilter(new ResourceSchedulerFilter(GetID()));
MediaInternals* media_internals = MediaInternals::GetInstance();
// Add BrowserPluginMessageFilter to ensure it gets the first stab at messages
// from guests.
scoped_refptr<BrowserPluginMessageFilter> bp_message_filter(
new BrowserPluginMessageFilter(GetID()));
AddFilter(bp_message_filter.get());

scoped_refptr<net::URLRequestContextGetter> request_context(
storage_partition_impl_->GetURLRequestContext());
scoped_refptr<RenderMessageFilter> render_message_filter(
new RenderMessageFilter(
GetID(), GetBrowserContext(), request_context.get(),
widget_helper_.get(), media_internals,
storage_partition_impl_->GetDOMStorageContext(),
storage_partition_impl_->GetCacheStorageContext()));
AddFilter(render_message_filter.get());

render_frame_message_filter_ = new RenderFrameMessageFilter(
GetID(),
#if BUILDFLAG(ENABLE_PLUGINS)
PluginServiceImpl::GetInstance(),
#else
nullptr,
#endif
GetBrowserContext(),
request_context.get(),
widget_helper_.get());
AddFilter(render_frame_message_filter_.get());

BrowserContext* browser_context = GetBrowserContext();
ResourceContext* resource_context = browser_context->GetResourceContext();

scoped_refptr<net::URLRequestContextGetter> media_request_context(
GetStoragePartition()->GetMediaURLRequestContext());

ResourceMessageFilter::GetContextsCallback get_contexts_callback(
base::Bind(&GetContexts, browser_context->GetResourceContext(),
request_context, media_request_context));

// Several filters need the Blob storage context, so fetch it in advance.
scoped_refptr<ChromeBlobStorageContext> blob_storage_context =
ChromeBlobStorageContext::GetFor(browser_context);

resource_message_filter_ = new ResourceMessageFilter(
GetID(), storage_partition_impl_->GetAppCacheService(),
blob_storage_context.get(),
storage_partition_impl_->GetFileSystemContext(),
storage_partition_impl_->GetServiceWorkerContext(),
get_contexts_callback);

AddFilter(resource_message_filter_.get());

media::AudioManager* audio_manager =
BrowserMainLoop::GetInstance()->audio_manager();
MediaStreamManager* media_stream_manager =
BrowserMainLoop::GetInstance()->media_stream_manager();
// The AudioInputRendererHost and AudioRendererHost needs to be available for
// lookup, so it's stashed in a member variable.
audio_input_renderer_host_ = new AudioInputRendererHost(
GetID(), base::GetProcId(GetHandle()), audio_manager,
media_stream_manager, AudioMirroringManager::GetInstance(),
BrowserMainLoop::GetInstance()->user_input_monitor());
AddFilter(audio_input_renderer_host_.get());
audio_renderer_host_ = new AudioRendererHost(
      GetID(), audio_manager, AudioMirroringManager::GetInstance(),
      media_stream_manager,
browser_context->GetResourceContext()->GetMediaDeviceIDSalt());
AddFilter(audio_renderer_host_.get());
AddFilter(
new MidiHost(GetID(), BrowserMainLoop::GetInstance()->midi_service()));
AddFilter(new AppCacheDispatcherHost(
storage_partition_impl_->GetAppCacheService(), GetID()));
AddFilter(new ClipboardMessageFilter(blob_storage_context));
AddFilter(new DOMStorageMessageFilter(
storage_partition_impl_->GetDOMStorageContext()));

#if BUILDFLAG(ENABLE_WEBRTC)
peer_connection_tracker_host_ = new PeerConnectionTrackerHost(
GetID(), webrtc_eventlog_host_.GetWeakPtr());
AddFilter(peer_connection_tracker_host_.get());
AddFilter(new MediaStreamDispatcherHost(
GetID(), browser_context->GetResourceContext()->GetMediaDeviceIDSalt(),
media_stream_manager));
AddFilter(new MediaStreamTrackMetricsHost());
#endif
#if BUILDFLAG(ENABLE_PLUGINS)
AddFilter(new PepperRendererConnection(GetID()));
#endif
AddFilter(new SpeechRecognitionDispatcherHost(
GetID(), storage_partition_impl_->GetURLRequestContext()));
AddFilter(new FileAPIMessageFilter(
GetID(), storage_partition_impl_->GetURLRequestContext(),
storage_partition_impl_->GetFileSystemContext(),
blob_storage_context.get(), StreamContext::GetFor(browser_context)));
AddFilter(new BlobDispatcherHost(
GetID(), blob_storage_context,
make_scoped_refptr(storage_partition_impl_->GetFileSystemContext())));
AddFilter(new FileUtilitiesMessageFilter(GetID()));
AddFilter(
new DatabaseMessageFilter(storage_partition_impl_->GetDatabaseTracker()));
#if defined(OS_MACOSX)
AddFilter(new TextInputClientMessageFilter());
#elif defined(OS_WIN)
AddFilter(new DWriteFontProxyMessageFilter());

// The FontCacheDispatcher is required only when we're using GDI rendering.
// TODO(scottmg): pdf/ppapi still require the renderer to be able to precache
// GDI fonts (http://crbug.com/383227), even when using DirectWrite. This
// should eventually be if (!ShouldUseDirectWrite()) guarded.
channel_->AddFilter(new FontCacheDispatcher());
#endif

message_port_message_filter_ = new MessagePortMessageFilter(
base::Bind(&RenderWidgetHelper::GetNextRoutingID,
base::Unretained(widget_helper_.get())));
AddFilter(message_port_message_filter_.get());

scoped_refptr<CacheStorageDispatcherHost> cache_storage_filter =
new CacheStorageDispatcherHost();
cache_storage_filter->Init(storage_partition_impl_->GetCacheStorageContext());
AddFilter(cache_storage_filter.get());

scoped_refptr<ServiceWorkerDispatcherHost> service_worker_filter =
new ServiceWorkerDispatcherHost(
GetID(), message_port_message_filter_.get(), resource_context);
service_worker_filter->Init(
storage_partition_impl_->GetServiceWorkerContext());
AddFilter(service_worker_filter.get());

AddFilter(new SharedWorkerMessageFilter(
GetID(), resource_context,
WorkerStoragePartition(
storage_partition_impl_->GetURLRequestContext(),
storage_partition_impl_->GetMediaURLRequestContext(),
storage_partition_impl_->GetAppCacheService(),
storage_partition_impl_->GetQuotaManager(),
storage_partition_impl_->GetFileSystemContext(),
storage_partition_impl_->GetDatabaseTracker(),
storage_partition_impl_->GetIndexedDBContext(),
storage_partition_impl_->GetServiceWorkerContext()),
message_port_message_filter_.get()));

#if BUILDFLAG(ENABLE_WEBRTC)
p2p_socket_dispatcher_host_ = new P2PSocketDispatcherHost(
resource_context, request_context.get());
AddFilter(p2p_socket_dispatcher_host_.get());
#endif

AddFilter(new TraceMessageFilter(GetID()));
AddFilter(new ResolveProxyMsgHelper(request_context.get()));
AddFilter(new QuotaDispatcherHost(
GetID(), storage_partition_impl_->GetQuotaManager(),
GetContentClient()->browser()->CreateQuotaPermissionContext()));

scoped_refptr<ServiceWorkerContextWrapper> service_worker_context(
static_cast<ServiceWorkerContextWrapper*>(
storage_partition_impl_->GetServiceWorkerContext()));
notification_message_filter_ = new NotificationMessageFilter(
GetID(), storage_partition_impl_->GetPlatformNotificationContext(),
resource_context, service_worker_context, browser_context);
AddFilter(notification_message_filter_.get());

AddFilter(new ProfilerMessageFilter(PROCESS_TYPE_RENDERER));
AddFilter(new HistogramMessageFilter());
AddFilter(new MemoryMessageFilter(this));
AddFilter(new PushMessagingMessageFilter(
GetID(), storage_partition_impl_->GetServiceWorkerContext()));
#if defined(OS_ANDROID)
AddFilter(new ScreenOrientationListenerAndroid());
synchronous_compositor_filter_ =
new SynchronousCompositorBrowserFilter(GetID());
AddFilter(synchronous_compositor_filter_.get());
#endif
}

  void StopTracing() {
    CHECK(message_loop_runner_.get() == NULL)
        << "Calling StopTracing more than once";
    trace_log_->SetDisabled();
    message_loop_runner_ = new MessageLoopRunner;
    trace_log_->Flush(base::Bind(
        &WebRtcGetUserMediaBrowserTest::OnTraceDataCollected,
        base::Unretained(this)));
    message_loop_runner_->Run();
  }

static inline float harfBuzzPositionToFloat(hb_position_t value)
{
    return static_cast<float>(value) / (1 << 16);
}

bool RenderProcessHostImpl::StartWebRTCEventLog(
    const base::FilePath& file_path) {
  return webrtc_eventlog_host_.StartWebRTCEventLog(file_path);
}

void RenderProcessHostImpl::DecrementServiceWorkerRefCount() {
  DCHECK_CURRENTLY_ON(BrowserThread::UI);
  DCHECK(!is_worker_ref_count_disabled_);
  DCHECK_GT(GetWorkerRefCount(), 0U);
  --service_worker_ref_count_;
  if (GetWorkerRefCount() == 0)
    Cleanup();
}

void ExpectTimeoutAndClose(scoped_refptr<UsbDeviceHandle> handle,
                           const base::Closure& quit_closure,
                           UsbTransferStatus status,
                           scoped_refptr<net::IOBuffer> buffer,
                           size_t transferred) {
  EXPECT_EQ(UsbTransferStatus::TIMEOUT, status);
  handle->Close();
  quit_closure.Run();
}

std::unique_ptr<HostCache> HostCache::CreateDefaultCache() {
#if defined(ENABLE_BUILT_IN_DNS)
  const size_t kDefaultMaxEntries = 1000;
#else
  const size_t kDefaultMaxEntries = 100;
#endif
  const size_t kSaneMaxEntries = 1 << 20;
  size_t max_entries = 0;
  base::StringToSizeT(base::FieldTrialList::FindFullName("HostCacheSize"),
                      &max_entries);
  if ((max_entries == 0) || (max_entries > kSaneMaxEntries))
    max_entries = kDefaultMaxEntries;
  return base::WrapUnique(new HostCache(max_entries));
}

bool ImageLoader::shouldLoadImmediately(const KURL& url) const {
  if (!url.isNull()) {
    Resource* resource = memoryCache()->resourceForURL(
        url, m_element->document().fetcher()->getCacheIdentifier());
    if (resource && !resource->errorOccurred())
      return true;
  }
  return (isHTMLObjectElement(m_element) || isHTMLEmbedElement(m_element));
}

  media::AudioManager* GetAudioManager() { return audio_manager_.get(); }

size_t RenderProcessHostImpl::GetWorkerRefCount() const {
  DCHECK_CURRENTLY_ON(BrowserThread::UI);
  return service_worker_ref_count_ + shared_worker_ref_count_;
}

const StaticRangeVector* Editor::Command::GetTargetRanges() const {
  const Node* target = EventTargetNodeForDocument(frame_->GetDocument());
  if (!IsSupported() || !frame_ || !target || !HasRichlyEditableStyle(*target))
    return nullptr;

  switch (command_->command_type) {
    case WebEditingCommandType::kDelete:
    case WebEditingCommandType::kDeleteBackward:
      return RangesFromCurrentSelectionOrExtendCaret(
          *frame_, SelectionModifyDirection::kBackward,
          TextGranularity::kCharacter);
    case WebEditingCommandType::kDeleteForward:
      return RangesFromCurrentSelectionOrExtendCaret(
          *frame_, SelectionModifyDirection::kForward,
          TextGranularity::kCharacter);
    case WebEditingCommandType::kDeleteToBeginningOfLine:
      return RangesFromCurrentSelectionOrExtendCaret(
          *frame_, SelectionModifyDirection::kBackward, TextGranularity::kLine);
    case WebEditingCommandType::kDeleteToBeginningOfParagraph:
      return RangesFromCurrentSelectionOrExtendCaret(
          *frame_, SelectionModifyDirection::kBackward,
          TextGranularity::kParagraph);
    case WebEditingCommandType::kDeleteToEndOfLine:
      return RangesFromCurrentSelectionOrExtendCaret(
          *frame_, SelectionModifyDirection::kForward, TextGranularity::kLine);
    case WebEditingCommandType::kDeleteToEndOfParagraph:
      return RangesFromCurrentSelectionOrExtendCaret(
          *frame_, SelectionModifyDirection::kForward,
          TextGranularity::kParagraph);
    case WebEditingCommandType::kDeleteWordBackward:
      return RangesFromCurrentSelectionOrExtendCaret(
          *frame_, SelectionModifyDirection::kBackward, TextGranularity::kWord);
    case WebEditingCommandType::kDeleteWordForward:
      return RangesFromCurrentSelectionOrExtendCaret(
          *frame_, SelectionModifyDirection::kForward, TextGranularity::kWord);
    default:
      return TargetRangesForInputEvent(*target);
  }
}

static EphemeralRange UnionEphemeralRanges(const EphemeralRange& range1,
                                           const EphemeralRange& range2) {
  const Position start_position =
      range1.StartPosition().CompareTo(range2.StartPosition()) <= 0
          ? range1.StartPosition()
          : range2.StartPosition();
  const Position end_position =
      range1.EndPosition().CompareTo(range2.EndPosition()) <= 0
          ? range1.EndPosition()
          : range2.EndPosition();
  return EphemeralRange(start_position, end_position);
}

RenderProcessHost* RenderProcessHost::GetExistingProcessHost(
    BrowserContext* browser_context,
    const GURL& site_url) {
  std::vector<RenderProcessHost*> suitable_renderers;
  suitable_renderers.reserve(g_all_hosts.Get().size());

  iterator iter(AllHostsIterator());
  while (!iter.IsAtEnd()) {
    if (iter.GetCurrentValue()->MayReuseHost() &&
        RenderProcessHostImpl::IsSuitableHost(iter.GetCurrentValue(),
                                              browser_context, site_url)) {
      suitable_renderers.push_back(iter.GetCurrentValue());
    }
    iter.Advance();
  }

  if (!suitable_renderers.empty()) {
    int suitable_count = static_cast<int>(suitable_renderers.size());
    int random_index = base::RandInt(0, suitable_count - 1);
    return suitable_renderers[random_index];
  }

  return NULL;
}

base::ProcessHandle RenderProcessHostImpl::GetHandle() const {
  if (run_renderer_in_process())
    return base::GetCurrentProcessHandle();

  if (!child_process_launcher_.get() || child_process_launcher_->IsStarting())
    return base::kNullProcessHandle;

  return child_process_launcher_->GetProcess().Handle();
}

bool SVGFEColorMatrixElement::isSupportedAttribute(const QualifiedName& attrName)
{
    DEFINE_STATIC_LOCAL(HashSet<QualifiedName>, supportedAttributes, ());
    if (supportedAttributes.isEmpty()) {
        supportedAttributes.add(SVGNames::typeAttr);
        supportedAttributes.add(SVGNames::valuesAttr);
        supportedAttributes.add(SVGNames::inAttr);
    }
    return supportedAttributes.contains<SVGAttributeHashTranslator>(attrName);
}

static bool ExecuteRemoveFormat(LocalFrame& frame,
                                Event*,
                                EditorCommandSource,
                                const String&) {
  frame.GetEditor().RemoveFormattingAndStyle();
  return true;
}

static bool EnabledDelete(LocalFrame& frame,
                          Event* event,
                          EditorCommandSource source) {
  switch (source) {
    case kCommandFromMenuOrKeyBinding:
      return frame.Selection().SelectionHasFocus() &&
             frame.GetEditor().CanDelete();
    case kCommandFromDOM:
      return EnabledInEditableText(frame, event, source);
  }
  NOTREACHED();
  return false;
}

void AudioOutputAuthorizationHandler::GetDeviceParameters(
AuthorizationCompletedCallback cb,
const std::string& raw_device_id) const {
DCHECK_CURRENTLY_ON(BrowserThread::IO);
DCHECK(!raw_device_id.empty());
  base::PostTaskAndReplyWithResult(
      // Note: In the case of a shutdown, the task to delete |audio_manager_| is
      // posted to the audio thread after the IO thread is stopped, so the task
      // to delete the audio manager hasn't been posted yet. This means that
      // unretained is safe here.
      // Mac is a special case. Since the audio manager lives on the UI thread
      // on Mac, this task is posted to the UI thread, but tasks posted to the
      // UI task runner will be ignored when the shutdown has progressed to
      // deleting the audio manager, so this is still safe.
      audio_manager_->GetTaskRunner(), FROM_HERE,
      base::Bind(&GetDeviceParametersOnDeviceThread,
                 base::Unretained(audio_manager_), raw_device_id),
base::Bind(&AudioOutputAuthorizationHandler::DeviceParametersReceived,
weak_factory_.GetWeakPtr(), std::move(cb), false,
raw_device_id));
}

void VRDisplay::OnDisconnected() {
  navigator_vr_->EnqueueVREvent(VRDisplayEvent::Create(
      EventTypeNames::vrdisplaydisconnect, true, false, this, "disconnect"));
}

static bool ExecuteMovePageDown(LocalFrame& frame,
                                Event*,
                                EditorCommandSource,
                                const String&) {
  unsigned distance = VerticalScrollDistance(frame);
  if (!distance)
    return false;
  return ModifySelectionyWithPageGranularity(
      frame, SelectionModifyAlteration::kMove, distance,
      SelectionModifyVerticalDirection::kDown);
}

HostCache::Entry::Entry(const HostCache::Entry& entry,
                        base::TimeTicks now,
                        base::TimeDelta ttl,
                        int network_changes)
    : error_(entry.error()),
      addresses_(entry.addresses()),
      ttl_(entry.ttl()),
      expires_(now + ttl),
      network_changes_(network_changes),
      total_hits_(0),
      stale_hits_(0) {}

bool Editor::ExecuteCommand(const String& command_name) {
  DCHECK(GetFrame().GetDocument()->IsActive());
  if (command_name == "DeleteToEndOfParagraph") {
    if (!DeleteWithDirection(DeleteDirection::kForward,
                             TextGranularity::kParagraphBoundary, true,
                             false)) {
      DeleteWithDirection(DeleteDirection::kForward,
                          TextGranularity::kCharacter, true, false);
    }
    return true;
  }
  if (command_name == "DeleteBackward")
    return CreateCommand(AtomicString("BackwardDelete")).Execute();
  if (command_name == "DeleteForward")
    return CreateCommand(AtomicString("ForwardDelete")).Execute();
  if (command_name == "AdvanceToNextMisspelling") {
    GetFrame().GetDocument()->UpdateStyleAndLayoutIgnorePendingStylesheets();

    GetSpellChecker().AdvanceToNextMisspelling(false);
    return true;
  }
  if (command_name == "ToggleSpellPanel") {
    GetFrame().GetDocument()->UpdateStyleAndLayoutIgnorePendingStylesheets();

    GetSpellChecker().ShowSpellingGuessPanel();
    return true;
  }
  return CreateCommand(command_name).Execute();
}

  void RequestDeviceAuthorizationWithBadOrigin(const std::string& device_id) {
    int session_id = 0;
    host_->OnRequestDeviceAuthorization(kStreamId, kRenderFrameId, session_id,
                                        device_id,
                                        url::Origin(GURL(kBadSecurityOrigin)));
    SyncWithAudioThread();
  }

static bool ExecuteDeleteBackwardByDecomposingPreviousCharacter(
    LocalFrame& frame,
    Event*,
    EditorCommandSource,
    const String&) {
  DLOG(ERROR) << "DeleteBackwardByDecomposingPreviousCharacter is not "
                 "implemented, doing DeleteBackward instead";
  frame.GetEditor().DeleteWithDirection(
      DeleteDirection::kBackward, TextGranularity::kCharacter, false, true);
  return true;
}

void CreateMemoryCoordinatorHandle(
    int render_process_id,
    mojom::MemoryCoordinatorHandleRequest request) {
  MemoryCoordinatorImpl::GetInstance()->CreateHandle(render_process_id,
                                                     std::move(request));
}

  MockAudioMirroringManager() {}

void AudioOutputAuthorizationHandler::RequestDeviceAuthorization(
    int render_frame_id,
    int session_id,
    const std::string& device_id,
    const url::Origin& security_origin,
    AuthorizationCompletedCallback cb) const {
  DCHECK_CURRENTLY_ON(BrowserThread::IO);

  if (!IsValidDeviceId(device_id)) {
    cb.Run(media::OUTPUT_DEVICE_STATUS_ERROR_NOT_FOUND, false,
           media::AudioParameters::UnavailableDeviceParams(), std::string());
    return;
  }

  if (media::AudioDeviceDescription::UseSessionIdToSelectDevice(session_id,
                                                                device_id)) {
    const StreamDeviceInfo* info =
        media_stream_manager_->audio_input_device_manager()
            ->GetOpenedDeviceInfoById(session_id);
    if (info && !info->device.matched_output_device_id.empty()) {
      media::AudioParameters output_params(
          media::AudioParameters::AUDIO_PCM_LOW_LATENCY,
          static_cast<media::ChannelLayout>(
              info->device.matched_output.channel_layout),
          info->device.matched_output.sample_rate, 16,
          info->device.matched_output.frames_per_buffer);
      output_params.set_effects(info->device.matched_output.effects);

      DeviceParametersReceived(std::move(cb), true,
                               info->device.matched_output_device_id,
                               output_params);
      return;
    }
  }

  if (media::AudioDeviceDescription::IsDefaultDevice(device_id)) {
    AccessChecked(std::move(cb), device_id, security_origin, true);
    return;
  }

  if (!MediaStreamManager::IsOriginAllowed(render_process_id_,
                                           security_origin)) {
    bad_message::ReceivedBadMessage(render_process_id_,
                                    bad_message::AOAH_UNAUTHORIZED_URL);
    return;
  }

  permission_checker_->CheckPermission(
      MEDIA_DEVICE_TYPE_AUDIO_OUTPUT, render_process_id_, render_frame_id,
      security_origin,
      base::Bind(&AudioOutputAuthorizationHandler::AccessChecked,
                 weak_factory_.GetWeakPtr(), std::move(cb), device_id,
                 security_origin));
}

static bool ExecuteScrollPageForward(LocalFrame& frame,
                                     Event*,
                                     EditorCommandSource,
                                     const String&) {
  return frame.GetEventHandler().BubblingScroll(kScrollBlockDirectionForward,
                                                kScrollByPage);
}

static bool ExecuteScrollToEndOfDocument(LocalFrame& frame,
                                         Event*,
                                         EditorCommandSource,
                                         const String&) {
  return frame.GetEventHandler().BubblingScroll(kScrollBlockDirectionForward,
                                                kScrollByDocument);
}

void ImageLoader::timerFired(TimerBase*) {
  m_keepAlive.clear();
}

  void Release(int old_route_id) {
    session_storage_namespaces_awaiting_close_->erase(old_route_id);
  }

static bool ExecuteDeleteWordBackward(LocalFrame& frame,
                                      Event*,
                                      EditorCommandSource,
                                      const String&) {
  frame.GetEditor().DeleteWithDirection(DeleteDirection::kBackward,
                                        TextGranularity::kWord, true, false);
  return true;
}

   bool WaitForResult() {
     run_loop_.Run();
     return success_;
   }

static ImageEventSender& loadEventSender() {
  DEFINE_STATIC_LOCAL(ImageEventSender, sender,
                      (ImageEventSender::create(EventTypeNames::load)));
  return sender;
}

  void SetVolume(double volume) {
    host_->OnSetVolume(kStreamId, volume);
    SyncWithAudioThread();
  }

void ImageLoader::dispatchPendingLoadEvents() {
  loadEventSender().dispatchPendingEvents();
}

IPC::PlatformFileForTransit CreateFileForProcess(base::FilePath file_path) {
  DCHECK_CURRENTLY_ON(BrowserThread::FILE);
  base::File dump_file(file_path,
                       base::File::FLAG_OPEN_ALWAYS | base::File::FLAG_APPEND);
  if (!dump_file.IsValid()) {
    VLOG(1) << "Could not open AEC dump file, error="
            << dump_file.error_details();
    return IPC::InvalidPlatformFileForTransit();
  }
  return IPC::TakePlatformFileForTransit(std::move(dump_file));
}

void RenderProcessHostImpl::ForceReleaseWorkerRefCounts() {
  DCHECK_CURRENTLY_ON(BrowserThread::UI);
  DCHECK(!is_worker_ref_count_disabled_);
  is_worker_ref_count_disabled_ = true;
  if (!GetWorkerRefCount())
    return;
  service_worker_ref_count_ = 0;
  shared_worker_ref_count_ = 0;
  Cleanup();
}

static bool ExecuteSetMark(LocalFrame& frame,
                           Event*,
                           EditorCommandSource,
                           const String&) {
  frame.GetEditor().SetMark(
      frame.Selection().ComputeVisibleSelectionInDOMTreeDeprecated());
  return true;
}

size_t RenderProcessHost::GetMaxRendererProcessCount() {
  if (g_max_renderer_count_override)
    return g_max_renderer_count_override;

#if defined(OS_ANDROID)
  return std::numeric_limits<size_t>::max();
#endif


  static size_t max_count = 0;
  if (!max_count) {
    const size_t kEstimatedWebContentsMemoryUsage =
#if defined(ARCH_CPU_64_BITS)
        60;  // In MB
#else
        40;  // In MB
#endif
    max_count = base::SysInfo::AmountOfPhysicalMemoryMB() / 2;
    max_count /= kEstimatedWebContentsMemoryUsage;

    const size_t kMinRendererProcessCount = 3;
    max_count = std::max(max_count, kMinRendererProcessCount);
    max_count = std::min(max_count, kMaxRendererProcessCount);
  }
  return max_count;
}

static bool ExecutePrint(LocalFrame& frame,
                         Event*,
                         EditorCommandSource,
                         const String&) {
  Page* page = frame.GetPage();
  if (!page)
    return false;
  return page->GetChromeClient().Print(&frame);
}

void ImageLoader::doUpdateFromElement(BypassMainWorldBehavior bypassBehavior,
                                      UpdateFromElementBehavior updateBehavior,
                                      const KURL& url,
                                      ReferrerPolicy referrerPolicy) {
  m_pendingTask.reset();
  std::unique_ptr<IncrementLoadEventDelayCount> loadDelayCounter;
  loadDelayCounter.swap(m_loadDelayCounter);

  Document& document = m_element->document();
  if (!document.isActive())
    return;

  AtomicString imageSourceURL = m_element->imageSourceURL();
  ImageResourceContent* newImage = nullptr;
  if (!url.isNull()) {
    ResourceLoaderOptions resourceLoaderOptions =
        ResourceFetcher::defaultResourceOptions();
    ResourceRequest resourceRequest(url);
    if (updateBehavior == UpdateForcedReload) {
      resourceRequest.setCachePolicy(WebCachePolicy::BypassingCache);
      resourceRequest.setPreviewsState(WebURLRequest::PreviewsNoTransform);
    }

    if (referrerPolicy != ReferrerPolicyDefault) {
      resourceRequest.setHTTPReferrer(SecurityPolicy::generateReferrer(
          referrerPolicy, url, document.outgoingReferrer()));
    }

    if (isHTMLPictureElement(element()->parentNode()) ||
        !element()->fastGetAttribute(HTMLNames::srcsetAttr).isNull())
      resourceRequest.setRequestContext(WebURLRequest::RequestContextImageSet);
    FetchRequest request(resourceRequest, element()->localName(),
                         resourceLoaderOptions);
    configureRequest(request, bypassBehavior, *m_element,
                     document.clientHintsPreferences());

    if (updateBehavior != UpdateForcedReload && document.settings() &&
        document.settings()->getFetchImagePlaceholders()) {
      request.setAllowImagePlaceholder();
    }

    newImage = ImageResourceContent::fetch(request, document.fetcher());

    if (!newImage && !pageIsBeingDismissed(&document)) {
      crossSiteOrCSPViolationOccurred(imageSourceURL);
      dispatchErrorEvent();
    } else {
      clearFailedLoadURL();
    }
  } else {
    if (!imageSourceURL.isNull()) {
      dispatchErrorEvent();
    }
    noImageResourceToLoad();
  }

  ImageResourceContent* oldImage = m_image.get();
  if (updateBehavior == UpdateSizeChanged && m_element->layoutObject() &&
      m_element->layoutObject()->isImage() && newImage == oldImage) {
    toLayoutImage(m_element->layoutObject())->intrinsicSizeChanged();
  } else {
    if (m_hasPendingLoadEvent) {
      loadEventSender().cancelEvent(this);
      m_hasPendingLoadEvent = false;
    }

    if (m_hasPendingErrorEvent && newImage) {
      errorEventSender().cancelEvent(this);
      m_hasPendingErrorEvent = false;
    }

    m_image = newImage;
    m_hasPendingLoadEvent = newImage;
    m_imageComplete = !newImage;

    updateLayoutObject();
    if (newImage) {
      newImage->addObserver(this);
    }
    if (oldImage) {
      oldImage->removeObserver(this);
    }
  }

  if (LayoutImageResource* imageResource = layoutImageResource())
    imageResource->resetAnimation();

  updatedHasPendingEvent();
}

static inline void resolveRunBasedOnScriptValue(Vector<CandidateRun>& runs,
    CandidateRun& run, size_t i, size_t length, size_t& nextResolvedRun)
{
    if (run.script != USCRIPT_COMMON)
        return;

    if (i > 0 && runs[i - 1].script != USCRIPT_COMMON) {
        run.script = runs[i - 1].script;
        return;
    }

    for (size_t j = i + 1; j < length; j++) {
        if (runs[j].script != USCRIPT_COMMON
            && runs[j].script != USCRIPT_INHERITED) {
            nextResolvedRun = j;
            break;
        }
    }
}

base::SingleThreadTaskRunner* AudioSystemImpl::GetTaskRunner() const {
  return audio_manager_->GetTaskRunner();
}

static bool ExecutePasteAndMatchStyle(LocalFrame& frame,
                                      Event*,
                                      EditorCommandSource source,
                                      const String&) {
  frame.GetEditor().PasteAsPlainText(source);
  return true;
}

 void VRDisplay::OnFocus() {
   display_blurred_ = false;
   ConnectVSyncProvider();
   navigator_vr_->EnqueueVREvent(VRDisplayEvent::Create(
      EventTypeNames::vrdisplayfocus, true, false, this, ""));
}

VREyeParameters* VRDisplay::getEyeParameters(const String& which_eye) {
  switch (StringToVREye(which_eye)) {
    case kVREyeLeft:
      return eye_parameters_left_;
    case kVREyeRight:
      return eye_parameters_right_;
    default:
      return nullptr;
  }
 }

static TriState StateStyleWithCSS(LocalFrame& frame, Event*) {
  return frame.GetEditor().ShouldStyleWithCSS() ? kTrueTriState
                                                : kFalseTriState;
}

static bool ExecuteMoveForwardAndModifySelection(LocalFrame& frame,
                                                 Event*,
                                                 EditorCommandSource,
                                                 const String&) {
  frame.Selection().Modify(SelectionModifyAlteration::kExtend,
                           SelectionModifyDirection::kForward,
                           TextGranularity::kCharacter, SetSelectionBy::kUser);
  return true;
}

static inline bool collectCandidateRuns(const UChar* normalizedBuffer,
    size_t bufferLength, const Font* font, Vector<CandidateRun>* runs, bool isSpaceNormalize)
{
    UTF16TextIterator iterator(normalizedBuffer, bufferLength);
    UChar32 character;
    unsigned startIndexOfCurrentRun = 0;

    if (!iterator.consume(character))
        return false;

    const SimpleFontData* nextFontData = font->glyphDataForCharacter(character, false, isSpaceNormalize).fontData;
    UErrorCode errorCode = U_ZERO_ERROR;
    UScriptCode nextScript = uscript_getScript(character, &errorCode);
    if (U_FAILURE(errorCode))
        return false;

    do {
        const UChar* currentCharacterPosition = iterator.characters();
        const SimpleFontData* currentFontData = nextFontData;
        UScriptCode currentScript = nextScript;

        UChar32 lastCharacter = character;
        for (iterator.advance(); iterator.consume(character); iterator.advance()) {
            if (Character::treatAsZeroWidthSpace(character))
                continue;
            if ((U_GET_GC_MASK(character) & U_GC_M_MASK)
                && currentFontData->canRenderCombiningCharacterSequence(
                    currentCharacterPosition,
                    iterator.glyphEnd() - currentCharacterPosition))
                continue;

            nextFontData = font->glyphDataForCharacter(character, false, isSpaceNormalize).fontData;
            nextScript = uscript_getScript(character, &errorCode);
            if (U_FAILURE(errorCode))
                return false;
            if (lastCharacter == zeroWidthJoiner)
                currentFontData = nextFontData;
            if ((nextFontData != currentFontData) || ((currentScript != nextScript) && (nextScript != USCRIPT_INHERITED) && (!uscript_hasScript(character, currentScript))))
                break;
            currentCharacterPosition = iterator.characters();
            lastCharacter = character;
        }

        CandidateRun run = { character, startIndexOfCurrentRun, iterator.offset(), currentFontData, currentScript };
        runs->append(run);

        startIndexOfCurrentRun = iterator.offset();
    } while (iterator.consume(character));

    return true;
}

static bool ExecuteDeleteToEndOfLine(LocalFrame& frame,
                                     Event*,
                                     EditorCommandSource,
                                     const String&) {
  frame.GetEditor().DeleteWithDirection(
      DeleteDirection::kForward, TextGranularity::kLineBoundary, true, false);
  return true;
}

static bool ExecuteMoveBackwardAndModifySelection(LocalFrame& frame,
                                                  Event*,
                                                  EditorCommandSource,
                                                  const String&) {
  frame.Selection().Modify(SelectionModifyAlteration::kExtend,
                           SelectionModifyDirection::kBackward,
                           TextGranularity::kCharacter, SetSelectionBy::kUser);
  return true;
}

void VRDisplay::OnChanged(device::mojom::blink::VRDisplayInfoPtr display) {
  Update(display);
}

void VRDisplay::OnPresentComplete(bool success) {
  if (success) {
    this->BeginPresent();
  } else {
    this->ForceExitPresent();
    DOMException* exception = DOMException::Create(
        kNotAllowedError, "Presentation request was denied.");

    while (!pending_present_resolvers_.IsEmpty()) {
      ScriptPromiseResolver* resolver = pending_present_resolvers_.TakeFirst();
      resolver->Reject(exception);
    }
  }
 }

static bool EnabledCopy(LocalFrame& frame, Event*, EditorCommandSource source) {
  if (!CanWriteClipboard(frame, source))
    return false;
  if (source == kCommandFromMenuOrKeyBinding &&
      !frame.Selection().SelectionHasFocus())
    return false;
  return frame.GetEditor().CanDHTMLCopy() || frame.GetEditor().CanCopy();
}

static bool ExecuteSelectWord(LocalFrame& frame,
                              Event*,
                              EditorCommandSource,
                              const String&) {
  return ExpandSelectionToGranularity(frame, TextGranularity::kWord);
}

bool Editor::Command::IsSupported() const {
  if (!command_)
    return false;
  switch (source_) {
    case kCommandFromMenuOrKeyBinding:
      return true;
    case kCommandFromDOM:
      return command_->is_supported_from_dom(frame_.Get());
  }
  NOTREACHED();
  return false;
}

AudioSystemImplTest()
      : use_audio_thread_(GetParam()), audio_thread_("AudioSystemThread") {
if (use_audio_thread_) {
audio_thread_.StartAndWaitForTesting();
audio_manager_.reset(
new media::MockAudioManager(audio_thread_.task_runner()));
} else {
audio_manager_.reset(new media::MockAudioManager(
base::ThreadTaskRunnerHandle::Get().get()));
}
    audio_manager_->SetInputStreamParameters(
        media::AudioParameters::UnavailableDeviceParams());
audio_system_ = media::AudioSystemImpl::Create(audio_manager_.get());
EXPECT_EQ(AudioSystem::Get(), audio_system_.get());
}

static bool ApplyCommandToFrame(LocalFrame& frame,
                                EditorCommandSource source,
                                InputEvent::InputType input_type,
                                StylePropertySet* style) {
  switch (source) {
    case kCommandFromMenuOrKeyBinding:
      frame.GetEditor().ApplyStyleToSelection(style, input_type);
      return true;
    case kCommandFromDOM:
      frame.GetEditor().ApplyStyle(style, input_type);
      return true;
  }
  NOTREACHED();
  return false;
}

   UsbTransferStatus status() const { return status_; }

void ValidateRenderFrameId(int render_process_id,
                           int render_frame_id,
                           const base::Callback<void(bool)>& callback) {
  DCHECK_CURRENTLY_ON(BrowserThread::UI);
  const bool frame_exists =
      !!RenderFrameHost::FromID(render_process_id, render_frame_id);
  BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,
                          base::Bind(callback, frame_exists));
}

void ImageLoader::setImageWithoutConsideringPendingLoadEvent(
    ImageResourceContent* newImage) {
  DCHECK(m_failedLoadURL.isEmpty());
  ImageResourceContent* oldImage = m_image.get();
  if (newImage != oldImage) {
    m_image = newImage;
    if (m_hasPendingLoadEvent) {
      loadEventSender().cancelEvent(this);
      m_hasPendingLoadEvent = false;
    }
    if (m_hasPendingErrorEvent) {
      errorEventSender().cancelEvent(this);
      m_hasPendingErrorEvent = false;
    }
    m_imageComplete = true;
    if (newImage) {
      newImage->addObserver(this);
    }
    if (oldImage) {
      oldImage->removeObserver(this);
    }
  }

  if (LayoutImageResource* imageResource = layoutImageResource())
    imageResource->resetAnimation();
}

HarfBuzzRunCache& harfBuzzRunCache()
{
    DEFINE_STATIC_LOCAL(HarfBuzzRunCache, globalHarfBuzzRunCache, ());
    return globalHarfBuzzRunCache;
}

void RenderProcessHostImpl::CreateStoragePartitionService(
    mojo::InterfaceRequest<mojom::StoragePartitionService> request) {
  if (base::CommandLine::ForCurrentProcess()->HasSwitch(
          switches::kMojoLocalStorage)) {
    storage_partition_impl_->Bind(std::move(request));
  }
}

void RenderProcessHostImpl::CreateMusGpuRequest(ui::mojom::GpuRequest request) {
  DCHECK_CURRENTLY_ON(BrowserThread::IO);
  if (!gpu_client_)
    gpu_client_.reset(new GpuClient(GetID()));
  gpu_client_->Add(std::move(request));
}

static TriState StateSubscript(LocalFrame& frame, Event*) {
  return StateStyle(frame, CSSPropertyVerticalAlign, "sub");
}

static bool ExecuteMoveToEndOfLineAndModifySelection(LocalFrame& frame,
                                                     Event*,
                                                     EditorCommandSource,
                                                     const String&) {
  frame.Selection().Modify(
      SelectionModifyAlteration::kExtend, SelectionModifyDirection::kForward,
      TextGranularity::kLineBoundary, SetSelectionBy::kUser);
  return true;
}

static bool ExecuteYank(LocalFrame& frame,
                        Event*,
                        EditorCommandSource,
                        const String&) {
  const String& yank_string = frame.GetEditor().GetKillRing().Yank();
  if (DispatchBeforeInputInsertText(
          EventTargetNodeForDocument(frame.GetDocument()), yank_string,
          InputEvent::InputType::kInsertFromYank) !=
      DispatchEventResult::kNotCanceled)
    return true;

  if (frame.GetDocument()->GetFrame() != &frame)
    return false;

  frame.GetDocument()->UpdateStyleAndLayoutIgnorePendingStylesheets();

  frame.GetEditor().InsertTextWithoutSendingTextEvent(
      yank_string, false, 0, InputEvent::InputType::kInsertFromYank);
  frame.GetEditor().GetKillRing().SetToYankedState();
  return true;
}

static bool ExecuteMoveRightAndModifySelection(LocalFrame& frame,
                                               Event*,
                                               EditorCommandSource,
                                               const String&) {
  frame.Selection().Modify(SelectionModifyAlteration::kExtend,
                           SelectionModifyDirection::kRight,
                           TextGranularity::kCharacter, SetSelectionBy::kUser);
  return true;
}

RenderProcessHostImpl::StartRtpDump(
    bool incoming,
    bool outgoing,
    const WebRtcRtpPacketCallback& packet_callback) {
  if (!p2p_socket_dispatcher_host_.get())
    return WebRtcStopRtpDumpCallback();

  BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,
                          base::Bind(&P2PSocketDispatcherHost::StartRtpDump,
                                     p2p_socket_dispatcher_host_, incoming,
                                     outgoing, packet_callback));

  if (stop_rtp_dump_callback_.is_null()) {
    stop_rtp_dump_callback_ =
        base::Bind(&P2PSocketDispatcherHost::StopRtpDumpOnUIThread,
                   p2p_socket_dispatcher_host_);
  }
  return stop_rtp_dump_callback_;
}

void RenderProcessHostImpl::Cleanup() {
  DCHECK_CURRENTLY_ON(BrowserThread::UI);
  if (run_renderer_in_process())
    return;

  if (within_process_died_observer_) {
    delayed_cleanup_needed_ = true;
    return;
  }
  delayed_cleanup_needed_ = false;

  if (listeners_.IsEmpty() && GetWorkerRefCount() > 0 &&
      survive_for_worker_start_time_.is_null()) {
    survive_for_worker_start_time_ = base::TimeTicks::Now();
  }

  if (!listeners_.IsEmpty() || GetWorkerRefCount() != 0)
    return;

#if BUILDFLAG(ENABLE_WEBRTC)
  if (is_initialized_)
    ClearWebRtcLogMessageCallback();
#endif

  if (!survive_for_worker_start_time_.is_null()) {
    UMA_HISTOGRAM_LONG_TIMES(
        "SharedWorker.RendererSurviveForWorkerTime",
        base::TimeTicks::Now() - survive_for_worker_start_time_);
  }

  DCHECK(!deleting_soon_);

  DCHECK_EQ(0, pending_views_);

  if (HasConnection()) {
    for (auto& observer : observers_) {
      observer.RenderProcessExited(
          this, base::TERMINATION_STATUS_NORMAL_TERMINATION, 0);
    }
  }
  for (auto& observer : observers_)
    observer.RenderProcessHostDestroyed(this);
  NotificationService::current()->Notify(
      NOTIFICATION_RENDERER_PROCESS_TERMINATED,
      Source<RenderProcessHost>(this), NotificationService::NoDetails());

  if (connection_filter_id_ !=
        ServiceManagerConnection::kInvalidConnectionFilterId) {
    ServiceManagerConnection* service_manager_connection =
        BrowserContext::GetServiceManagerConnectionFor(browser_context_);
    connection_filter_controller_->DisableFilter();
    service_manager_connection->RemoveConnectionFilter(connection_filter_id_);
    connection_filter_id_ =
        ServiceManagerConnection::kInvalidConnectionFilterId;
  }

#ifndef NDEBUG
  is_self_deleted_ = true;
#endif
  base::ThreadTaskRunnerHandle::Get()->DeleteSoon(FROM_HERE, this);
  deleting_soon_ = true;

  ResetChannelProxy();

  message_port_message_filter_ = NULL;

  DCHECK(!channel_);
  RemoveUserData(kSessionStorageHolderKey);

  UnregisterHost(GetID());

  instance_weak_factory_.reset(
      new base::WeakPtrFactory<RenderProcessHostImpl>(this));
}

   MockAudioRendererHost(base::RunLoop* auth_run_loop,
                         int render_process_id,
                         media::AudioManager* audio_manager,
                         AudioMirroringManager* mirroring_manager,
                         MediaStreamManager* media_stream_manager,
                         const std::string& salt)
       : AudioRendererHost(render_process_id,
                           audio_manager,
                           mirroring_manager,
                           media_stream_manager,
                           salt),
        shared_memory_length_(0),
        auth_run_loop_(auth_run_loop) {
    set_render_frame_id_validate_function_for_testing(&ValidateRenderFrameId);
  }

static bool EnabledRedo(LocalFrame& frame, Event*, EditorCommandSource) {
  return frame.GetEditor().CanRedo();
}

void HostCache::Set(const Key& key,
const Entry& entry,
base::TimeTicks now,
base::TimeDelta ttl) {
TRACE_EVENT0(kNetTracingCategory, "HostCache::Set");
DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
if (caching_is_disabled())
return;

auto it = entries_.find(key);
if (it != entries_.end()) {
bool is_stale = it->second.IsStale(now, network_changes_);
RecordSet(is_stale ? SET_UPDATE_STALE : SET_UPDATE_VALID, now, &it->second,
              entry);
// TODO(juliatuttle): Remember some old metadata (hit count or frequency or
// something like that) if it's useful for better eviction algorithms?
entries_.erase(it);
} else {
if (size() == max_entries_)
EvictOneEntry(now);
    RecordSet(SET_INSERT, now, nullptr, entry);
}

AddEntry(Key(key), Entry(entry, now, ttl, network_changes_));
}

void RenderProcessHostImpl::SetIsNeverSuitableForReuse() {
  is_never_suitable_for_reuse_ = true;
}

static TriState StateItalic(LocalFrame& frame, Event*) {
  return StateStyle(frame, CSSPropertyFontStyle, "italic");
}

void RenderProcessHostImpl::PurgeAndSuspend() {
  Send(new ChildProcessMsg_PurgeAndSuspend());
}

DEFINE_TRACE(VRDisplay) {
  EventTargetWithInlineData::Trace(visitor);
  ContextLifecycleObserver::Trace(visitor);
  visitor->Trace(navigator_vr_);
  visitor->Trace(capabilities_);
  visitor->Trace(stage_parameters_);
  visitor->Trace(eye_parameters_left_);
  visitor->Trace(eye_parameters_right_);
  visitor->Trace(layer_);
  visitor->Trace(rendering_context_);
  visitor->Trace(scripted_animation_controller_);
  visitor->Trace(pending_present_resolvers_);
}

url::Origin SecurityOrigin() {
  return url::Origin(GURL(kSecurityOriginString));
}

static bool ExecuteUnselect(LocalFrame& frame,
                            Event*,
                            EditorCommandSource,
                            const String&) {
  frame.Selection().Clear();
  return true;
}

static bool ExecutePasteGlobalSelection(LocalFrame& frame,
                                        Event*,
                                        EditorCommandSource source,
                                        const String&) {
  if (!CanReadClipboard(frame, source))
    return false;
  if (!frame.GetEditor().Behavior().SupportsGlobalSelection())
    return false;
  DCHECK_EQ(source, kCommandFromMenuOrKeyBinding);

  bool old_selection_mode = Pasteboard::GeneralPasteboard()->IsSelectionMode();
  Pasteboard::GeneralPasteboard()->SetSelectionMode(true);
  frame.GetEditor().Paste(source);
  Pasteboard::GeneralPasteboard()->SetSelectionMode(old_selection_mode);
  return true;
}

  void CreateWithoutWaitingForAuth(const std::string& device_id) {
    Create(device_id, url::Origin(GURL(kSecurityOrigin)), false, false);
  }

static void normalizeCharacters(const TextRun& run, unsigned length, UChar* destination, unsigned* destinationLength)
{
    unsigned position = 0;
    bool error = false;
    const UChar* source;
    String stringFor8BitRun;
    if (run.is8Bit()) {
        stringFor8BitRun = String::make16BitFrom8BitSource(run.characters8(), run.length());
        source = stringFor8BitRun.characters16();
    } else {
        source = run.characters16();
    }

    *destinationLength = 0;
    while (position < length) {
        UChar32 character;
        U16_NEXT(source, position, length, character);
        if (run.normalizeSpace() && Character::isNormalizedCanvasSpaceCharacter(character))
            character = space;
        else if (Character::treatAsSpace(character) && character != characterTabulation)
            character = space;
        else if (Character::treatAsZeroWidthSpaceInComplexScript(character))
            character = zeroWidthSpace;

        U16_APPEND(destination, *destinationLength, length, character, error);
        ASSERT_UNUSED(error, !error);
    }
}

void RenderProcessHostImpl::ShutdownForBadMessage(
    CrashReportMode crash_report_mode) {
  base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();
  if (command_line->HasSwitch(switches::kDisableKillAfterBadIPC))
    return;

  if (run_renderer_in_process()) {
    CHECK(false);
  }

  Shutdown(RESULT_CODE_KILLED_BAD_MESSAGE, false);

  if (crash_report_mode == CrashReportMode::GENERATE_CRASH_DUMP) {
    base::debug::DumpWithoutCrashing();
  }

  BrowserChildProcessHostImpl::HistogramBadMessageTerminated(
      PROCESS_TYPE_RENDERER);
}

Document* VRDisplay::GetDocument() {
  return navigator_vr_->GetDocument();
 }

bool HostCache::RestoreFromListValue(const base::ListValue& old_cache) {
  for (auto it = old_cache.begin(); it != old_cache.end(); it++) {
    const base::DictionaryValue* entry_dict;
    if (!it->GetAsDictionary(&entry_dict))
      return false;

    std::string hostname;
    int address_family;
    HostResolverFlags flags;
    int error = OK;
    std::string expiration;
    base::ListValue empty_list;
    const base::ListValue* addresses_value = &empty_list;
    AddressList address_list;

    if (!entry_dict->GetString(kHostnameKey, &hostname) ||
        !entry_dict->GetInteger(kFlagsKey, &flags) ||
        !entry_dict->GetInteger(kAddressFamilyKey, &address_family) ||
        !entry_dict->GetString(kExpirationKey, &expiration)) {
      return false;
    }

    if (!entry_dict->GetInteger(kErrorKey, &error) &&
        !entry_dict->GetList(kAddressesKey, &addresses_value)) {
      return false;
    }

    int64_t time_internal;
    if (!base::StringToInt64(expiration, &time_internal))
      return false;

    base::TimeTicks expiration_time =
        base::TimeTicks::Now() -
        (base::Time::Now() - base::Time::FromInternalValue(time_internal));

    Key key(hostname, static_cast<AddressFamily>(address_family), flags);
    if (error == OK &&
        !AddressListFromListValue(addresses_value, &address_list)) {
      return false;
    }

    auto found = entries_.find(key);
    if (found == entries_.end() && size() < max_entries_) {
      AddEntry(key, Entry(error, address_list, expiration_time,
                          network_changes_ - 1));
    }
  }
  return true;
}

void RenderProcessHostImpl::OnChannelConnected(int32_t peer_pid) {
  channel_connected_ = true;
  if (IsReady()) {
    DCHECK(!sent_render_process_ready_);
    sent_render_process_ready_ = true;
    for (auto& observer : observers_)
      observer.RenderProcessReady(this);
  }

#if defined(IPC_MESSAGE_LOG_ENABLED)
  Send(new ChildProcessMsg_SetIPCLoggingEnabled(
      IPC::Logging::GetInstance()->Enabled()));
#endif

  tracked_objects::ThreadData::Status status =
      tracked_objects::ThreadData::status();
  Send(new ChildProcessMsg_SetProfilerStatus(status));

  BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,
                          base::Bind(&AudioInputRendererHost::set_renderer_pid,
                                     audio_input_renderer_host_, peer_pid));
}

inline CachedShapingResults* HarfBuzzRunCache::find(const std::wstring& key) const
{
    CachedShapingResultsMap::const_iterator it = m_harfBuzzRunMap.find(key);

    return it != m_harfBuzzRunMap.end() ? it->second : 0;
}

static bool ExecuteScrollLineUp(LocalFrame& frame,
                                Event*,
                                EditorCommandSource,
                                const String&) {
  return frame.GetEventHandler().BubblingScroll(kScrollUpIgnoringWritingMode,
                                                kScrollByLine);
}

static bool EnabledRangeInEditableText(LocalFrame& frame,
                                       Event*,
                                       EditorCommandSource source) {
  frame.GetDocument()->UpdateStyleAndLayoutIgnorePendingStylesheets();
  if (source == kCommandFromMenuOrKeyBinding &&
      !frame.Selection().SelectionHasFocus())
    return false;
  return frame.Selection()
             .ComputeVisibleSelectionInDOMTreeDeprecated()
             .IsRange() &&
         frame.Selection()
             .ComputeVisibleSelectionInDOMTreeDeprecated()
             .IsContentEditable();
}

template<> const SVGEnumerationStringEntries& getStaticStringEntries<ColorMatrixType>()
{
    DEFINE_STATIC_LOCAL(SVGEnumerationStringEntries, entries, ());
    if (entries.isEmpty()) {
        entries.append(std::make_pair(FECOLORMATRIX_TYPE_MATRIX, "matrix"));
        entries.append(std::make_pair(FECOLORMATRIX_TYPE_SATURATE, "saturate"));
        entries.append(std::make_pair(FECOLORMATRIX_TYPE_HUEROTATE, "hueRotate"));
        entries.append(std::make_pair(FECOLORMATRIX_TYPE_LUMINANCETOALPHA, "luminanceToAlpha"));
    }
    return entries;
}

void RenderProcessHostImpl::GetAssociatedInterface(
    const std::string& name,
    mojom::AssociatedInterfaceAssociatedRequest request) {
  int32_t routing_id =
      associated_interface_provider_bindings_.dispatch_context();
  IPC::Listener* listener = listeners_.Lookup(routing_id);
  if (listener)
    listener->OnAssociatedInterfaceRequest(name, request.PassHandle());
}

  void Disable() {
    base::AutoLock lock(enabled_lock_);
    enabled_ = false;
  }

void VRDisplay::Update(const device::mojom::blink::VRDisplayInfoPtr& display) {
  display_id_ = display->index;
  display_name_ = display->displayName;
  is_connected_ = true;

  capabilities_->SetHasPosition(display->capabilities->hasPosition);
  capabilities_->SetHasExternalDisplay(
      display->capabilities->hasExternalDisplay);
  capabilities_->SetCanPresent(display->capabilities->canPresent);
  capabilities_->SetMaxLayers(display->capabilities->canPresent ? 1 : 0);

  bool is_valid = display->leftEye->renderWidth > 0;
  bool need_on_present_change = false;
  if (is_presenting_ && is_valid && !is_valid_device_for_presenting_) {
    need_on_present_change = true;
  }
  is_valid_device_for_presenting_ = is_valid;
  eye_parameters_left_->Update(display->leftEye);
  eye_parameters_right_->Update(display->rightEye);

  if (!display->stageParameters.is_null()) {
    if (!stage_parameters_)
      stage_parameters_ = new VRStageParameters();
    stage_parameters_->Update(display->stageParameters);
  } else {
    stage_parameters_ = nullptr;
  }

  if (need_on_present_change) {
    OnPresentChange();
  }
}

static bool SupportedFromMenuOrKeyBinding(LocalFrame*) {
  return false;
}

media::AudioParameters TryToFixAudioParameters(
    const media::AudioParameters& params) {
  DCHECK(!params.IsValid());
  media::AudioParameters params_copy(params);

  if (params.channels() > media::limits::kMaxChannels) {
    DCHECK(params.channel_layout() == media::CHANNEL_LAYOUT_DISCRETE);
    params_copy.set_channels_for_discrete(media::limits::kMaxChannels);
  }

  return params_copy.IsValid()
             ? params_copy
              : media::AudioParameters::UnavailableDeviceParams();
 }

AudioOutputAuthorizationHandler::~AudioOutputAuthorizationHandler() {
  DCHECK_CURRENTLY_ON(BrowserThread::IO);
}

int VRDisplay::requestAnimationFrame(FrameRequestCallback* callback) {
Document* doc = this->GetDocument();
if (!doc)
return 0;
  pending_raf_ = true;
if (!vr_v_sync_provider_.is_bound()) {
ConnectVSyncProvider();
} else if (!display_blurred_ && !pending_vsync_) {
pending_vsync_ = true;
vr_v_sync_provider_->GetVSync(ConvertToBaseCallback(
WTF::Bind(&VRDisplay::OnVSync, WrapWeakPersistent(this))));
}
callback->use_legacy_time_base_ = false;
return EnsureScriptedAnimationController(doc).RegisterCallback(callback);
}

void ImageLoader::imageNotifyFinished(ImageResourceContent* resource) {
  RESOURCE_LOADING_DVLOG(1)
      << "ImageLoader::imageNotifyFinished " << this
      << "; m_hasPendingLoadEvent=" << m_hasPendingLoadEvent;

  DCHECK(m_failedLoadURL.isEmpty());
  DCHECK_EQ(resource, m_image.get());

  m_imageComplete = true;

  if (m_image)
    m_image->updateImageAnimationPolicy();

  updateLayoutObject();

  if (m_image && m_image->getImage() && m_image->getImage()->isSVGImage())
    toSVGImage(m_image->getImage())->updateUseCounters(element()->document());

  if (!m_hasPendingLoadEvent)
    return;

  if (resource->errorOccurred()) {
    loadEventSender().cancelEvent(this);
    m_hasPendingLoadEvent = false;

    if (resource->resourceError().isAccessCheck()) {
      crossSiteOrCSPViolationOccurred(
          AtomicString(resource->resourceError().failingURL()));
    }

    if (!m_suppressErrorEvents)
      dispatchErrorEvent();

    updatedHasPendingEvent();
    return;
  }
  loadEventSender().dispatchEventSoon(this);
}

static bool ExecuteMoveUpAndModifySelection(LocalFrame& frame,
                                            Event*,
                                            EditorCommandSource,
                                            const String&) {
  frame.Selection().Modify(SelectionModifyAlteration::kExtend,
                           SelectionModifyDirection::kBackward,
                           TextGranularity::kLine, SetSelectionBy::kUser);
  return true;
}

static bool ExecuteFontSize(LocalFrame& frame,
                            Event*,
                            EditorCommandSource source,
                            const String& value) {
  CSSValueID size;
  if (!HTMLFontElement::CssValueFromFontSizeNumber(value, size))
    return false;
  return ExecuteApplyStyle(frame, source, InputEvent::InputType::kNone,
                           CSSPropertyFontSize, size);
}

static bool ExecuteInsertElement(LocalFrame& frame, HTMLElement* content) {
  DCHECK(frame.GetDocument());
  DocumentFragment* fragment = DocumentFragment::Create(*frame.GetDocument());
  DummyExceptionStateForTesting exception_state;
  fragment->AppendChild(content, exception_state);
  if (exception_state.HadException())
    return false;
  return ExecuteInsertFragment(frame, fragment);
}

void VRDisplay::UpdateLayerBounds() {
  if (!display_)
    return;

  device::mojom::blink::VRLayerBoundsPtr left_bounds =
      device::mojom::blink::VRLayerBounds::New();
  device::mojom::blink::VRLayerBoundsPtr right_bounds =
      device::mojom::blink::VRLayerBounds::New();

  if (layer_.leftBounds().size() == 4) {
    left_bounds->left = layer_.leftBounds()[0];
    left_bounds->top = layer_.leftBounds()[1];
    left_bounds->width = layer_.leftBounds()[2];
    left_bounds->height = layer_.leftBounds()[3];
  } else {
    left_bounds->left = 0.0f;
    left_bounds->top = 0.0f;
    left_bounds->width = 0.5f;
    left_bounds->height = 1.0f;
    layer_.setLeftBounds({0.0f, 0.0f, 0.5f, 1.0f});
  }

  if (layer_.rightBounds().size() == 4) {
    right_bounds->left = layer_.rightBounds()[0];
    right_bounds->top = layer_.rightBounds()[1];
    right_bounds->width = layer_.rightBounds()[2];
    right_bounds->height = layer_.rightBounds()[3];
  } else {
    right_bounds->left = 0.5f;
    right_bounds->top = 0.0f;
    right_bounds->width = 0.5f;
    right_bounds->height = 1.0f;
    layer_.setRightBounds({0.5f, 0.0f, 0.5f, 1.0f});
  }

  display_->UpdateLayerBounds(vr_frame_id_, std::move(left_bounds),
                              std::move(right_bounds), source_width_,
                              source_height_);
}

static void AppendCompositorCommandLineFlags(base::CommandLine* command_line) {
  command_line->AppendSwitchASCII(
      switches::kNumRasterThreads,
      base::IntToString(NumberOfRendererRasterThreads()));

  if (IsAsyncWorkerContextEnabled())
    command_line->AppendSwitch(switches::kEnableGpuAsyncWorkerContext);

  int msaa_sample_count = GpuRasterizationMSAASampleCount();
  if (msaa_sample_count >= 0) {
    command_line->AppendSwitchASCII(switches::kGpuRasterizationMSAASampleCount,
                                    base::IntToString(msaa_sample_count));
  }

  if (IsZeroCopyUploadEnabled())
    command_line->AppendSwitch(switches::kEnableZeroCopy);
  if (!IsPartialRasterEnabled())
    command_line->AppendSwitch(switches::kDisablePartialRaster);

  if (IsGpuMemoryBufferCompositorResourcesEnabled()) {
    command_line->AppendSwitch(
        switches::kEnableGpuMemoryBufferCompositorResources);
  }

  if (IsMainFrameBeforeActivationEnabled())
    command_line->AppendSwitch(cc::switches::kEnableMainFrameBeforeActivation);

  cc::BufferToTextureTargetMap image_targets;
  for (int usage_idx = 0; usage_idx <= static_cast<int>(gfx::BufferUsage::LAST);
       ++usage_idx) {
    gfx::BufferUsage usage = static_cast<gfx::BufferUsage>(usage_idx);
    for (int format_idx = 0;
         format_idx <= static_cast<int>(gfx::BufferFormat::LAST);
         ++format_idx) {
      gfx::BufferFormat format = static_cast<gfx::BufferFormat>(format_idx);
      uint32_t target = gpu::GetImageTextureTarget(format, usage);
      image_targets[std::make_pair(usage, format)] = target;
    }
  }
  command_line->AppendSwitchASCII(
      switches::kContentImageTextureTarget,
      cc::BufferToTextureTargetMapToString(image_targets));

  GpuDataManagerImpl* gpu_data_manager = GpuDataManagerImpl::GetInstance();
  DCHECK(gpu_data_manager);
  gpu_data_manager->AppendRendererCommandLine(command_line);

  if (base::CommandLine::ForCurrentProcess()->HasSwitch(
          switches::kEnableSlimmingPaintV2)) {
    command_line->AppendSwitch(cc::switches::kEnableLayerLists);
  }
}

static bool ExecuteForwardDelete(LocalFrame& frame,
                                 Event*,
                                 EditorCommandSource source,
                                 const String&) {
  EditingState editing_state;
  switch (source) {
    case kCommandFromMenuOrKeyBinding:
      frame.GetEditor().DeleteWithDirection(
          DeleteDirection::kForward, TextGranularity::kCharacter, false, true);
      return true;
    case kCommandFromDOM:
      DCHECK(frame.GetDocument());
      TypingCommand::ForwardDeleteKeyPressed(*frame.GetDocument(),
                                             &editing_state);
      if (editing_state.IsAborted())
        return false;
      return true;
  }
  NOTREACHED();
  return false;
}

void AudioRendererHost::AuthorizationCompleted(
    int stream_id,
    const url::Origin& security_origin,
    base::TimeTicks auth_start_time,
    media::OutputDeviceStatus status,
    bool should_send_id,
    const media::AudioParameters& params,
    const std::string& raw_device_id) {
  DCHECK_CURRENTLY_ON(BrowserThread::IO);
  auto auth_data = authorizations_.find(stream_id);
  if (auth_data == authorizations_.end())
    return;  // Stream was closed before finishing authorization

  UMALogDeviceAuthorizationTime(auth_start_time);
  if (status == media::OUTPUT_DEVICE_STATUS_OK) {
    auth_data->second.first = true;
    auth_data->second.second = raw_device_id;
    if (should_send_id) {
      std::string hashed_id = MediaStreamManager::GetHMACForMediaDeviceID(
          salt_, security_origin, raw_device_id);
      Send(new AudioMsg_NotifyDeviceAuthorized(stream_id, status, params,
                                               hashed_id));
    } else {
      Send(new AudioMsg_NotifyDeviceAuthorized(stream_id, status, params,
                                               std::string()));
    }
  } else {
    authorizations_.erase(auth_data);
    Send(new AudioMsg_NotifyDeviceAuthorized(
        stream_id, status, media::AudioParameters::UnavailableDeviceParams(),
        std::string()));
  }
}

void HostCache::RecordUpdateStale(AddressListDeltaType delta,
                                  const EntryStaleness& stale) {
  CACHE_HISTOGRAM_ENUM("UpdateStale.AddressListDelta", delta, MAX_DELTA_TYPE);
  switch (delta) {
    case DELTA_IDENTICAL:
      CACHE_HISTOGRAM_TIME("UpdateStale.ExpiredBy_Identical", stale.expired_by);
      CACHE_HISTOGRAM_COUNT("UpdateStale.NetworkChanges_Identical",
                            stale.network_changes);
      break;
    case DELTA_REORDERED:
      CACHE_HISTOGRAM_TIME("UpdateStale.ExpiredBy_Reordered", stale.expired_by);
      CACHE_HISTOGRAM_COUNT("UpdateStale.NetworkChanges_Reordered",
                            stale.network_changes);
      break;
    case DELTA_OVERLAP:
      CACHE_HISTOGRAM_TIME("UpdateStale.ExpiredBy_Overlap", stale.expired_by);
      CACHE_HISTOGRAM_COUNT("UpdateStale.NetworkChanges_Overlap",
                            stale.network_changes);
      break;
    case DELTA_DISJOINT:
      CACHE_HISTOGRAM_TIME("UpdateStale.ExpiredBy_Disjoint", stale.expired_by);
      CACHE_HISTOGRAM_COUNT("UpdateStale.NetworkChanges_Disjoint",
                            stale.network_changes);
      break;
    case MAX_DELTA_TYPE:
      NOTREACHED();
      break;
  }
}

bool VRDisplay::getFrameData(VRFrameData* frame_data) {
  if (!IsPresentationFocused() || !frame_pose_ || display_blurred_)
    return false;

  if (!frame_data)
    return false;

  if (depth_near_ == depth_far_)
    return false;

  return frame_data->Update(frame_pose_, eye_parameters_left_,
                            eye_parameters_right_, depth_near_, depth_far_);
}

  void GetInterface(const std::string& interface_name,
                    mojo::ScopedMessagePipeHandle handle) {
    DCHECK(thread_checker_.CalledOnValidThread());
    DCHECK_CURRENTLY_ON(BrowserThread::IO);
    service_manager::mojom::InterfaceProvider* provider = registry_.get();

    base::AutoLock lock(enabled_lock_);
    if (enabled_)
      provider->GetInterface(interface_name, std::move(handle));
  }

   void SetResult(bool success) {
     success_ = success;
     run_loop_.Quit();
   }

void VRDisplay::StopPresenting() {
  if (is_presenting_) {
    if (!capabilities_->hasExternalDisplay()) {
      if (layer_.source().isHTMLCanvasElement()) {
      } else {
      }
    } else {
    }
    is_presenting_ = false;
    OnPresentChange();
  }

  rendering_context_ = nullptr;
  context_gl_ = nullptr;
  pending_submit_frame_ = false;
  pending_previous_frame_render_ = false;
}

TestOpenCallback()
      : callback_(
            base::Bind(&TestOpenCallback::SetResult, base::Unretained(this))) {}

void ImageLoader::updatedHasPendingEvent() {
  bool wasProtected = m_elementIsProtected;
  m_elementIsProtected = m_hasPendingLoadEvent || m_hasPendingErrorEvent;
  if (wasProtected == m_elementIsProtected)
    return;

  if (m_elementIsProtected) {
    if (m_derefElementTimer.isActive())
      m_derefElementTimer.stop();
    else
      m_keepAlive = m_element;
  } else {
    DCHECK(!m_derefElementTimer.isActive());
    m_derefElementTimer.startOneShot(0, BLINK_FROM_HERE);
  }
}

ImageLoader::~ImageLoader() {}

int HarfBuzzShaper::offsetForPosition(float targetX)
{
    int charactersSoFar = 0;
    float currentX = 0;

    if (m_run.rtl()) {
        charactersSoFar = m_normalizedBufferLength;
        for (int i = m_harfBuzzRuns.size() - 1; i >= 0; --i) {
            charactersSoFar -= m_harfBuzzRuns[i]->numCharacters();
            float nextX = currentX + m_harfBuzzRuns[i]->width();
            float offsetForRun = targetX - currentX;
            if (offsetForRun >= 0 && offsetForRun <= m_harfBuzzRuns[i]->width()) {
                const unsigned index = m_harfBuzzRuns[i]->characterIndexForXPosition(offsetForRun);
                return charactersSoFar + index;
            }
            currentX = nextX;
        }
    } else {
        for (unsigned i = 0; i < m_harfBuzzRuns.size(); ++i) {
            float nextX = currentX + m_harfBuzzRuns[i]->width();
            float offsetForRun = targetX - currentX;
            if (offsetForRun >= 0 && offsetForRun <= m_harfBuzzRuns[i]->width()) {
                const unsigned index = m_harfBuzzRuns[i]->characterIndexForXPosition(offsetForRun);
                return charactersSoFar + index;
            }
            charactersSoFar += m_harfBuzzRuns[i]->numCharacters();
            currentX = nextX;
        }
    }

    return charactersSoFar;
}

static bool ExecuteMoveToLeftEndOfLineAndModifySelection(LocalFrame& frame,
                                                         Event*,
                                                         EditorCommandSource,
                                                         const String&) {
  frame.Selection().Modify(
      SelectionModifyAlteration::kExtend, SelectionModifyDirection::kLeft,
      TextGranularity::kLineBoundary, SetSelectionBy::kUser);
  return true;
}

inline void HarfBuzzShaper::HarfBuzzRun::applyShapeResult(hb_buffer_t* harfBuzzBuffer)
{
    m_numGlyphs = hb_buffer_get_length(harfBuzzBuffer);
    m_glyphs.resize(m_numGlyphs);
    m_advances.resize(m_numGlyphs);
    m_glyphToCharacterIndexes.resize(m_numGlyphs);
    m_offsets.resize(m_numGlyphs);
}

mojom::Renderer* RenderProcessHostImpl::GetRendererInterface() {
  return renderer_interface_.get();
}

static bool ExecuteIgnoreSpelling(LocalFrame& frame,
                                  Event*,
                                  EditorCommandSource,
                                  const String&) {
  frame.GetSpellChecker().IgnoreSpelling();
  return true;
}

void GetContexts(
    ResourceContext* resource_context,
    scoped_refptr<net::URLRequestContextGetter> request_context,
    scoped_refptr<net::URLRequestContextGetter> media_request_context,
    ResourceType resource_type,
    ResourceContext** resource_context_out,
    net::URLRequestContext** request_context_out) {
  *resource_context_out = resource_context;
  *request_context_out =
      GetRequestContext(request_context, media_request_context, resource_type);
}

void TestEvictionCallback(int* evict_count,
                          HostCache::Key* key_out,
                          const HostCache::Key& key,
                          const HostCache::Entry& entry) {
  ++*evict_count;
  *key_out = key;
}

inline void ImageLoader::dispatchErrorEvent() {
  m_hasPendingErrorEvent = true;
  errorEventSender().dispatchEventSoon(this);
}

static bool ExecuteMoveToBeginningOfSentence(LocalFrame& frame,
                                             Event*,
                                             EditorCommandSource,
                                             const String&) {
  frame.Selection().Modify(
      SelectionModifyAlteration::kMove, SelectionModifyDirection::kBackward,
      TextGranularity::kSentenceBoundary, SetSelectionBy::kUser);
  return true;
}

static bool ExecuteMoveToBeginningOfSentenceAndModifySelection(
    LocalFrame& frame,
    Event*,
    EditorCommandSource,
    const String&) {
  frame.Selection().Modify(
      SelectionModifyAlteration::kExtend, SelectionModifyDirection::kBackward,
      TextGranularity::kSentenceBoundary, SetSelectionBy::kUser);
  return true;
}

  void Detach() {
    base::AutoLock lock(lock_);
    filter_ = nullptr;
  }

static bool ExecuteFontSizeDelta(LocalFrame& frame,
                                 Event*,
                                 EditorCommandSource source,
                                 const String& value) {
  return ExecuteApplyStyle(frame, source, InputEvent::InputType::kNone,
                           CSSPropertyWebkitFontSizeDelta, value);
}

void RenderProcessHostImpl::FilterURL(RenderProcessHost* rph,
                                      bool empty_allowed,
                                      GURL* url) {
  ChildProcessSecurityPolicyImpl* policy =
      ChildProcessSecurityPolicyImpl::GetInstance();

  if (empty_allowed && url->is_empty())
    return;

  if (!url->is_valid()) {
    *url = GURL(url::kAboutBlankURL);
    return;
  }

  if (!policy->CanRequestURL(rph->GetID(), *url)) {
    VLOG(1) << "Blocked URL " << url->spec();
    *url = GURL(url::kAboutBlankURL);
  }
}

HarfBuzzShaper::HarfBuzzRun::~HarfBuzzRun()
{
}

void HostCache::RecordSet(SetOutcome outcome,
base::TimeTicks now,
const Entry* old_entry,
                          const Entry& new_entry) {
CACHE_HISTOGRAM_ENUM("Set", outcome, MAX_SET_OUTCOME);
switch (outcome) {
case SET_INSERT:
case SET_UPDATE_VALID:
// Nothing to log here.
break;
case SET_UPDATE_STALE: {
EntryStaleness stale;
old_entry->GetStaleness(now, network_changes_, &stale);
CACHE_HISTOGRAM_TIME("UpdateStale.ExpiredBy", stale.expired_by);
CACHE_HISTOGRAM_COUNT("UpdateStale.NetworkChanges",
stale.network_changes);
CACHE_HISTOGRAM_COUNT("UpdateStale.StaleHits", stale.stale_hits);
if (old_entry->error() == OK && new_entry.error() == OK) {
        AddressListDeltaType delta = FindAddressListDeltaType(
            old_entry->addresses(), new_entry.addresses());
RecordUpdateStale(delta, stale);
}
break;
}
case MAX_SET_OUTCOME:
NOTREACHED();
break;
}
}

void ImageLoader::dispatchPendingErrorEvents() {
  errorEventSender().dispatchPendingEvents();
}

  WebRtcConstraintsBrowserTest() : user_media_(GetParam()) {}

static bool ExecuteInsertHorizontalRule(LocalFrame& frame,
                                        Event*,
                                        EditorCommandSource,
                                        const String& value) {
  DCHECK(frame.GetDocument());
  HTMLHRElement* rule = HTMLHRElement::Create(*frame.GetDocument());
  if (!value.IsEmpty())
    rule->SetIdAttribute(AtomicString(value));
  return ExecuteInsertElement(frame, rule);
}

  void OnAudioParams(const AudioParameters& expected,
                     const AudioParameters& received) {
    EXPECT_TRUE(thread_checker_.CalledOnValidThread());
    EXPECT_EQ(expected.AsHumanReadableString(),
              received.AsHumanReadableString());
     AudioParametersReceived();
   }

void Editor::ApplyStyle(StylePropertySet* style,
                        InputEvent::InputType input_type) {
  switch (GetFrame()
              .Selection()
              .ComputeVisibleSelectionInDOMTreeDeprecated()
              .GetSelectionType()) {
    case kNoSelection:
      break;
    case kCaretSelection:
      ComputeAndSetTypingStyle(style, input_type);
      break;
    case kRangeSelection:
      if (style) {
        DCHECK(GetFrame().GetDocument());
        ApplyStyleCommand::Create(*GetFrame().GetDocument(),
                                  EditingStyle::Create(style), input_type)
            ->Apply();
      }
      break;
  }
}

static bool EnabledRangeInRichlyEditableText(LocalFrame& frame,
                                             Event*,
                                             EditorCommandSource source) {
  frame.GetDocument()->UpdateStyleAndLayoutIgnorePendingStylesheets();
  if (source == kCommandFromMenuOrKeyBinding &&
      !frame.Selection().SelectionHasFocus())
    return false;
  return frame.Selection()
             .ComputeVisibleSelectionInDOMTreeDeprecated()
             .IsRange() &&
         frame.Selection()
             .ComputeVisibleSelectionInDOMTreeDeprecated()
             .IsContentRichlyEditable();
}

void HarfBuzzShaper::setDrawRange(int from, int to)
{
    ASSERT_WITH_SECURITY_IMPLICATION(from >= 0);
    ASSERT_WITH_SECURITY_IMPLICATION(to <= m_run.length());
    m_fromIndex = from;
    m_toIndex = to;
}

static bool ExecuteDeleteWordForward(LocalFrame& frame,
                                     Event*,
                                     EditorCommandSource,
                                     const String&) {
  frame.GetEditor().DeleteWithDirection(DeleteDirection::kForward,
                                        TextGranularity::kWord, true, false);
  return true;
}

static bool EnabledVisibleSelectionAndMark(LocalFrame& frame,
                                           Event* event,
                                           EditorCommandSource source) {
  frame.GetDocument()->UpdateStyleAndLayoutIgnorePendingStylesheets();

  if (source == kCommandFromMenuOrKeyBinding &&
      !frame.Selection().SelectionHasFocus())
    return false;

  const VisibleSelection& selection =
      frame.GetEditor().SelectionForCommand(event);
  return ((selection.IsCaret() && selection.IsContentEditable()) ||
          selection.IsRange()) &&
         !frame.GetEditor().Mark().IsNone();
}

void Editor::Transpose() {
  if (!CanEdit())
return;

// TODO(editing-dev): The use of updateStyleAndLayoutIgnorePendingStylesheets
// needs to be audited. see http://crbug.com/590369 for more details.
  GetFrame().GetDocument()->UpdateStyleAndLayoutIgnorePendingStylesheets();

  const EphemeralRange& range = ComputeRangeForTranspose(GetFrame());
if (range.IsNull())
return;

// Transpose the two characters.
const String& text = PlainText(range);
if (text.length() != 2)
return;
const String& transposed = text.Right(1) + text.Left(1);

if (DispatchBeforeInputInsertText(
          EventTargetNodeForDocument(GetFrame().GetDocument()), transposed,
InputEvent::InputType::kInsertTranspose,
new StaticRangeVector(1, StaticRange::Create(range))) !=
DispatchEventResult::kNotCanceled)
return;

  // 'beforeinput' event handler may destroy document.
  if (frame_->GetDocument()->GetFrame() != frame_)
return;

// TODO(editing-dev): The use of updateStyleAndLayoutIgnorePendingStylesheets
// needs to be audited. see http://crbug.com/590369 for more details.
  GetFrame().GetDocument()->UpdateStyleAndLayoutIgnorePendingStylesheets();

// 'beforeinput' event handler may change selection, we need to re-calculate
// range.
  const EphemeralRange& new_range = ComputeRangeForTranspose(GetFrame());
if (new_range.IsNull())
return;

const String& new_text = PlainText(new_range);
if (new_text.length() != 2)
return;
const String& new_transposed = new_text.Right(1) + new_text.Left(1);

const SelectionInDOMTree& new_selection =
SelectionInDOMTree::Builder().SetBaseAndExtent(new_range).Build();

// Select the two characters.
if (CreateVisibleSelection(new_selection) !=
      GetFrame().Selection().ComputeVisibleSelectionInDOMTree())
    GetFrame().Selection().SetSelection(new_selection);

// Insert the transposed characters.
  ReplaceSelectionWithText(new_transposed, false, false,
                           InputEvent::InputType::kInsertTranspose);
}

void WaitForCallback() {
if (!use_audio_thread_) {
base::RunLoop().RunUntilIdle();
return;
}
    media::WaitableMessageLoopEvent event;
audio_thread_.task_runner()->PostTaskAndReply(
FROM_HERE, base::Bind(&base::DoNothing), event.GetClosure());
// Runs the loop and waits for the |audio_thread_| to call event's closure,
// which means AudioSystem reply containing device parameters is already
// queued on the main thread.
event.RunAndWait();
base::RunLoop().RunUntilIdle();
}

static bool ExecuteMovePageDownAndModifySelection(LocalFrame& frame,
                                                  Event*,
                                                  EditorCommandSource,
                                                  const String&) {
  unsigned distance = VerticalScrollDistance(frame);
  if (!distance)
    return false;
  return ModifySelectionyWithPageGranularity(
      frame, SelectionModifyAlteration::kExtend, distance,
      SelectionModifyVerticalDirection::kDown);
}

void ImageLoader::elementDidMoveToNewDocument() {
  if (m_loadDelayCounter)
    m_loadDelayCounter->documentChanged(m_element->document());
  clearFailedLoadURL();
  setImage(0);
}

void ImageLoader::dispatchPendingEvent(ImageEventSender* eventSender) {
  RESOURCE_LOADING_DVLOG(1) << "ImageLoader::dispatchPendingEvent " << this;
  DCHECK(eventSender == &loadEventSender() ||
         eventSender == &errorEventSender());
  const AtomicString& eventType = eventSender->eventType();
  if (eventType == EventTypeNames::load)
    dispatchPendingLoadEvent();
  if (eventType == EventTypeNames::error)
    dispatchPendingErrorEvent();
}

HostCache::Key Key(const std::string& hostname) {
  return HostCache::Key(hostname, ADDRESS_FAMILY_UNSPECIFIED, 0);
}

RenderProcessHost* RenderProcessHost::FromID(int render_process_id) {
  DCHECK_CURRENTLY_ON(BrowserThread::UI);
  return g_all_hosts.Get().Lookup(render_process_id);
}

void RenderProcessHostImpl::SetWebRtcLogMessageCallback(
    base::Callback<void(const std::string&)> callback) {
#if BUILDFLAG(ENABLE_WEBRTC)
  BrowserMainLoop::GetInstance()->media_stream_manager()->
      RegisterNativeLogCallback(GetID(), callback);
#endif
}

void ReportPresentationResult(PresentationResult result) {
  DEFINE_STATIC_LOCAL(
      EnumerationHistogram, vr_presentation_result_histogram,
      ("VRDisplayPresentResult",
       static_cast<int>(PresentationResult::kPresentationResultMax)));
  vr_presentation_result_histogram.Count(static_cast<int>(result));
}

void RenderProcessHostImpl::UpdateProcessPriority() {
  if (!child_process_launcher_.get() || child_process_launcher_->IsStarting()) {
    is_process_backgrounded_ = false;
    return;
  }

  if (base::CommandLine::ForCurrentProcess()->HasSwitch(
          switches::kDisableRendererPriorityManagement)) {
    return;
  }

  const bool should_background =
      visible_widgets_ == 0 && audio_stream_count_ == 0 &&
      !base::CommandLine::ForCurrentProcess()->HasSwitch(
          switches::kDisableRendererBackgrounding);

#if !defined(OS_ANDROID)
  if (is_process_backgrounded_ == should_background)
    return;
#endif

  TRACE_EVENT1("renderer_host", "RenderProcessHostImpl::UpdateProcessPriority",
               "should_background", should_background);
  is_process_backgrounded_ = should_background;

#if defined(OS_WIN)
  if (GetModuleHandle(L"cbstext.dll"))
    return;
#endif  // OS_WIN

  child_process_launcher_->SetProcessBackgrounded(should_background);

  Send(new ChildProcessMsg_SetProcessBackgrounded(should_background));
}

void RenderProcessHostImpl::OnMojoError(int render_process_id,
                                        const std::string& error) {
  LOG(ERROR) << "Terminating render process for bad Mojo message: " << error;

  base::debug::ScopedCrashKey error_key_value("mojo-message-error", error);
  bad_message::ReceivedBadMessage(render_process_id,
                                  bad_message::RPH_MOJO_PROCESS_ERROR);
}

void RenderProcessHostImpl::RecomputeAndUpdateWebKitPreferences() {
  std::unique_ptr<RenderWidgetHostIterator> widgets(
      RenderWidgetHostImpl::GetAllRenderWidgetHosts());
  while (RenderWidgetHost* widget = widgets->GetNextHost()) {
    RenderViewHost* rvh = RenderViewHost::From(widget);
    if (!rvh)
      continue;

    if (rvh->GetProcess()->GetID() != GetID())
      continue;

    rvh->OnWebkitPreferencesChanged();
  }
}

std::string GenerateGetUserMediaWithMandatorySourceID(
    const std::string& function_name,
    const std::string& audio_source_id,
    const std::string& video_source_id) {
  const std::string audio_constraint =
      "audio: {mandatory: { sourceId:\"" + audio_source_id + "\"}}, ";

  const std::string video_constraint =
      "video: {mandatory: { sourceId:\"" + video_source_id + "\"}}";
  return function_name + "({" + audio_constraint + video_constraint + "});";
}

TestCompletionCallback()
      : callback_(base::Bind(&TestCompletionCallback::SetResult,
                             base::Unretained(this))) {}

inline HarfBuzzShaper::HarfBuzzRun::HarfBuzzRun(const HarfBuzzRun& rhs)
    : m_fontData(rhs.m_fontData)
    , m_startIndex(rhs.m_startIndex)
    , m_numCharacters(rhs.m_numCharacters)
    , m_numGlyphs(rhs.m_numGlyphs)
    , m_direction(rhs.m_direction)
    , m_script(rhs.m_script)
    , m_glyphs(rhs.m_glyphs)
    , m_advances(rhs.m_advances)
    , m_glyphToCharacterIndexes(rhs.m_glyphToCharacterIndexes)
    , m_offsets(rhs.m_offsets)
    , m_width(rhs.m_width)
{
}

void HostCache::RecordErase(EraseReason reason,
                            base::TimeTicks now,
                            const Entry& entry) {
  HostCache::EntryStaleness stale;
  entry.GetStaleness(now, network_changes_, &stale);
  CACHE_HISTOGRAM_ENUM("Erase", reason, MAX_ERASE_REASON);
  if (stale.is_stale()) {
    CACHE_HISTOGRAM_TIME("EraseStale.ExpiredBy", stale.expired_by);
    CACHE_HISTOGRAM_COUNT("EraseStale.NetworkChanges", stale.network_changes);
    CACHE_HISTOGRAM_COUNT("EraseStale.StaleHits", entry.stale_hits());
  } else {
    CACHE_HISTOGRAM_TIME("EraseValid.ValidFor", -stale.expired_by);
  }
}

inline SVGFEColorMatrixElement::SVGFEColorMatrixElement(Document& document)
    : SVGFilterPrimitiveStandardAttributes(SVGNames::feColorMatrixTag, document)
    , m_values(SVGAnimatedNumberList::create(this, SVGNames::valuesAttr, SVGNumberList::create()))
    , m_in1(SVGAnimatedString::create(this, SVGNames::inAttr, SVGString::create()))
    , m_type(SVGAnimatedEnumeration<ColorMatrixType>::create(this, SVGNames::typeAttr, FECOLORMATRIX_TYPE_MATRIX))
{
    addToPropertyMap(m_values);
    addToPropertyMap(m_in1);
    addToPropertyMap(m_type);
}

bool RenderProcessHostImpl::IsWorkerRefCountDisabled() {
  DCHECK_CURRENTLY_ON(BrowserThread::UI);
  return is_worker_ref_count_disabled_;
}

void AudioRendererHost::OnPlayStream(int stream_id) {
  DCHECK_CURRENTLY_ON(BrowserThread::IO);

  AudioOutputDelegate* delegate = LookupById(stream_id);
  if (!delegate) {
    SendErrorMessage(stream_id);
    return;
  }

  delegate->OnPlayStream();
}

  void OnNotifyStreamCreated(
      int stream_id,
      base::SharedMemoryHandle handle,
      base::SyncSocket::TransitDescriptor socket_descriptor,
      uint32_t length) {
    shared_memory_.reset(new base::SharedMemory(handle, false));
    CHECK(shared_memory_->Map(length));
    CHECK(shared_memory_->memory());
    shared_memory_length_ = length;

    base::SyncSocket::Handle sync_socket_handle =
        base::SyncSocket::UnwrapHandle(socket_descriptor);
    sync_socket_.reset(new base::SyncSocket(sync_socket_handle));

    WasNotifiedOfCreation(stream_id, length);
  }

static bool ExecuteInsertBacktab(LocalFrame& frame,
                                 Event* event,
                                 EditorCommandSource,
                                 const String&) {
  return TargetFrame(frame, event)
      ->GetEventHandler()
      .HandleTextInputEvent("\t", event);
}

void RenderProcessHostImpl::OnUnregisterAecDumpConsumer(int id) {
  BrowserThread::PostTask(
      BrowserThread::UI, FROM_HERE,
      base::Bind(&RenderProcessHostImpl::UnregisterAecDumpConsumerOnUIThread,
                 weak_factory_.GetWeakPtr(), id));
}

void RenderProcessHostImpl::RemoveRoute(int32_t routing_id) {
  DCHECK(listeners_.Lookup(routing_id) != nullptr);
  listeners_.Remove(routing_id);
  Cleanup();
}

void RenderProcessHostImpl::OnCloseACK(int old_route_id) {
  SessionStorageHolder* holder =
      static_cast<SessionStorageHolder*>(GetUserData(kSessionStorageHolderKey));
  if (!holder)
    return;
  holder->Release(old_route_id);
}

  explicit ConnectionFilterController(ConnectionFilterImpl* filter)
      : filter_(filter) {}

static bool ExecuteMoveForward(LocalFrame& frame,
                               Event*,
                               EditorCommandSource,
                               const String&) {
  frame.Selection().Modify(SelectionModifyAlteration::kMove,
                           SelectionModifyDirection::kForward,
                           TextGranularity::kCharacter, SetSelectionBy::kUser);
  return true;
}

void VRDisplay::OnExitPresent() {
  StopPresenting();
}

CachedShapingResults::CachedShapingResults(hb_buffer_t* harfBuzzBuffer, const Font* fontData, hb_direction_t dirData, const String& newLocale)
    : buffer(harfBuzzBuffer)
    , font(*fontData)
    , dir(dirData)
    , locale(newLocale)
{
}

static bool ExecuteToggleItalic(LocalFrame& frame,
                                Event*,
                                EditorCommandSource source,
                                const String&) {
  return ExecuteToggleStyle(frame, source, InputEvent::InputType::kFormatItalic,
                            CSSPropertyFontStyle, "normal", "italic");
}

ScriptedAnimationController& VRDisplay::EnsureScriptedAnimationController(
    Document* doc) {
  if (!scripted_animation_controller_)
    scripted_animation_controller_ = ScriptedAnimationController::Create(doc);

  return *scripted_animation_controller_;
}

static bool ExecuteDelete(LocalFrame& frame,
                          Event*,
                          EditorCommandSource source,
                          const String&) {
  switch (source) {
    case kCommandFromMenuOrKeyBinding: {
      frame.GetEditor().PerformDelete();
      return true;
    }
    case kCommandFromDOM:
      DCHECK(frame.GetDocument());
      TypingCommand::DeleteKeyPressed(
          *frame.GetDocument(),
          frame.Selection().Granularity() == TextGranularity::kWord
              ? TypingCommand::kSmartDelete
              : 0);
      return true;
  }
  NOTREACHED();
  return false;
}

static TriState StateJustifyCenter(LocalFrame& frame, Event*) {
  return StateStyle(frame, CSSPropertyTextAlign, "center");
}

void RenderProcessHostImpl::IncrementSharedWorkerRefCount() {
  DCHECK_CURRENTLY_ON(BrowserThread::UI);
  DCHECK(!is_worker_ref_count_disabled_);
  ++shared_worker_ref_count_;
}

void Editor::Paste(EditorCommandSource source) {
  DCHECK(GetFrame().GetDocument());
  if (TryDHTMLPaste(kAllMimeTypes))
    return;  // DHTML did the whole operation
  if (!CanPaste())
    return;

  GetFrame().GetDocument()->UpdateStyleAndLayoutIgnorePendingStylesheets();

  if (source == kCommandFromMenuOrKeyBinding &&
      !GetFrame().Selection().SelectionHasFocus())
    return;

  GetSpellChecker().UpdateMarkersForWordsAffectedByEditing(false);
  ResourceFetcher* loader = GetFrame().GetDocument()->Fetcher();
  ResourceCacheValidationSuppressor validation_suppressor(loader);

  PasteMode paste_mode = GetFrame()
                                 .Selection()
                                 .ComputeVisibleSelectionInDOMTree()
                                 .IsContentRichlyEditable()
                             ? kAllMimeTypes
                             : kPlainTextOnly;

  if (source == kCommandFromMenuOrKeyBinding) {
    DataTransfer* data_transfer =
        DataTransfer::Create(DataTransfer::kCopyAndPaste, kDataTransferReadable,
                             DataObject::CreateFromPasteboard(paste_mode));

    if (DispatchBeforeInputDataTransfer(FindEventTargetFromSelection(),
                                        InputEvent::InputType::kInsertFromPaste,
                                        data_transfer) !=
        DispatchEventResult::kNotCanceled)
      return;
    if (frame_->GetDocument()->GetFrame() != frame_)
      return;
  }

  if (paste_mode == kAllMimeTypes)
    PasteWithPasteboard(Pasteboard::GeneralPasteboard());
  else
    PasteAsPlainTextWithPasteboard(Pasteboard::GeneralPasteboard());
}

void RenderProcessHostImpl::ReleaseOnCloseACK(
    RenderProcessHost* host,
    const SessionStorageNamespaceMap& sessions,
    int view_route_id) {
  DCHECK(host);
  if (sessions.empty())
    return;
  SessionStorageHolder* holder = static_cast<SessionStorageHolder*>(
      host->GetUserData(kSessionStorageHolderKey));
  if (!holder) {
    holder = new SessionStorageHolder();
    host->SetUserData(kSessionStorageHolderKey, holder);
  }
  holder->Hold(sessions, view_route_id);
}

void AudioSystemImpl::GetInputStreamParameters(
    const std::string& device_id,
    OnAudioParamsCallback on_params_cb) const {
  if (GetTaskRunner()->BelongsToCurrentThread()) {
    GetTaskRunner()->PostTask(
        FROM_HERE, base::Bind(on_params_cb, GetInputParametersOnDeviceThread(
                                                audio_manager_, device_id)));
    return;
  }
  base::PostTaskAndReplyWithResult(
      GetTaskRunner(), FROM_HERE,
      base::Bind(&GetInputParametersOnDeviceThread,
                 base::Unretained(audio_manager_), device_id),
       std::move(on_params_cb));
 }

  void Close() {
    host_->OnCloseStream(kStreamId);
    SyncWithAudioThread();
  }

static bool ExecuteMoveDownAndModifySelection(LocalFrame& frame,
                                              Event*,
                                              EditorCommandSource,
                                              const String&) {
  frame.Selection().Modify(SelectionModifyAlteration::kExtend,
                           SelectionModifyDirection::kForward,
                           TextGranularity::kLine, SetSelectionBy::kUser);
  return true;
}

  void RunTwoGetTwoGetUserMediaWithDifferentContraints(
      const std::string& constraints1,
      const std::string& constraints2,
      const std::string& expected_result) {
    ASSERT_TRUE(embedded_test_server()->InitializeAndWaitUntilReady());

    GURL url(embedded_test_server()->GetURL("/media/getusermedia.html"));
    NavigateToURL(shell(), url);

    std::string command = "twoGetUserMedia(" + constraints1 + ',' +
        constraints2 + ')';

    EXPECT_EQ(expected_result, ExecuteJavascriptAndReturnResult(command));
  }

size_t RenderProcessHost::GetActiveViewCount() {
  size_t num_active_views = 0;
  std::unique_ptr<RenderWidgetHostIterator> widgets(
      RenderWidgetHost::GetRenderWidgetHosts());
  while (RenderWidgetHost* widget = widgets->GetNextHost()) {
    if (widget->GetProcess()->GetID() == GetID())
      num_active_views++;
  }
  return num_active_views;
}

 void HostCache::AddEntry(const Key& key, const Entry& entry) {
  DCHECK_GT(max_entries_, size());
  DCHECK_EQ(0u, entries_.count(key));
  entries_.insert(std::make_pair(key, entry));
  DCHECK_GE(max_entries_, size());
}

AudioRendererHost::AudioRendererHost(int render_process_id,
media::AudioManager* audio_manager,
AudioMirroringManager* mirroring_manager,
MediaStreamManager* media_stream_manager,
const std::string& salt)
: BrowserMessageFilter(AudioMsgStart),
render_process_id_(render_process_id),
audio_manager_(audio_manager),
mirroring_manager_(mirroring_manager),
media_stream_manager_(media_stream_manager),
salt_(salt),
validate_render_frame_id_function_(&ValidateRenderFrameId),
      authorization_handler_(audio_manager_,
media_stream_manager,
render_process_id_,
salt) {
DCHECK(audio_manager_);
}

static TriState StateTextWritingDirectionLeftToRight(LocalFrame& frame,
                                                     Event*) {
  return StateTextWritingDirection(frame, LeftToRightWritingDirection);
}

  static std::unique_ptr<Task> create(ImageLoader* loader,
                                      UpdateFromElementBehavior updateBehavior,
                                      ReferrerPolicy referrerPolicy) {
    return WTF::makeUnique<Task>(loader, updateBehavior, referrerPolicy);
  }

void RenderProcessHostImpl::GetRoute(
    int32_t routing_id,
    mojom::AssociatedInterfaceProviderAssociatedRequest request) {
  DCHECK(request.is_pending());
  associated_interface_provider_bindings_.AddBinding(
      this, std::move(request), routing_id);
}

void RenderProcessHostImpl::OnAssociatedInterfaceRequest(
    const std::string& interface_name,
    mojo::ScopedInterfaceEndpointHandle handle) {
  if (interface_name == mojom::RouteProvider::Name_) {
    if (route_provider_binding_.is_bound())
      return;
    mojom::RouteProviderAssociatedRequest request;
    request.Bind(std::move(handle));
    route_provider_binding_.Bind(std::move(request));
  } else {
    LOG(ERROR) << "Request for unknown Channel-associated interface: "
               << interface_name;
  }
}

static bool ExecuteJustifyFull(LocalFrame& frame,
                               Event*,
                               EditorCommandSource source,
                               const String&) {
  return ExecuteApplyParagraphStyle(frame, source,
                                    InputEvent::InputType::kFormatJustifyFull,
                                    CSSPropertyTextAlign, "justify");
}

static bool ExecuteInsertFragment(LocalFrame& frame,
                                  DocumentFragment* fragment) {
  DCHECK(frame.GetDocument());
  return ReplaceSelectionCommand::Create(
             *frame.GetDocument(), fragment,
             ReplaceSelectionCommand::kPreventNesting,
             InputEvent::InputType::kNone)
      ->Apply();
}

static bool ExecuteMoveToBeginningOfParagraph(LocalFrame& frame,
                                              Event*,
                                              EditorCommandSource,
                                              const String&) {
  frame.Selection().Modify(
      SelectionModifyAlteration::kMove, SelectionModifyDirection::kBackward,
      TextGranularity::kParagraphBoundary, SetSelectionBy::kUser);
  return true;
}

static bool ExecuteStrikethrough(LocalFrame& frame,
                                 Event*,
                                 EditorCommandSource source,
                                 const String&) {
  CSSIdentifierValue* line_through =
      CSSIdentifierValue::Create(CSSValueLineThrough);
  return ExecuteToggleStyleInList(
      frame, source, InputEvent::InputType::kFormatStrikeThrough,
      CSSPropertyWebkitTextDecorationsInEffect, line_through);
}

bool RenderProcessHostImpl::MayReuseHost() {
  if (is_never_suitable_for_reuse_)
    return false;

  return GetContentClient()->browser()->MayReuseHost(this);
}

static bool ExecuteSuperscript(LocalFrame& frame,
                               Event*,
                               EditorCommandSource source,
                               const String&) {
  return ExecuteToggleStyle(frame, source,
                            InputEvent::InputType::kFormatSuperscript,
                            CSSPropertyVerticalAlign, "baseline", "super");
}

static bool ExecuteCopy(LocalFrame& frame,
                        Event*,
                        EditorCommandSource source,
                        const String&) {
  if (!CanWriteClipboard(frame, source))
    return false;
  frame.GetEditor().Copy(source);
  return true;
}

bool AudioRendererHost::OnMessageReceived(const IPC::Message& message) {
  bool handled = true;
  IPC_BEGIN_MESSAGE_MAP(AudioRendererHost, message)
    IPC_MESSAGE_HANDLER(AudioHostMsg_RequestDeviceAuthorization,
                        OnRequestDeviceAuthorization)
    IPC_MESSAGE_HANDLER(AudioHostMsg_CreateStream, OnCreateStream)
    IPC_MESSAGE_HANDLER(AudioHostMsg_PlayStream, OnPlayStream)
    IPC_MESSAGE_HANDLER(AudioHostMsg_PauseStream, OnPauseStream)
    IPC_MESSAGE_HANDLER(AudioHostMsg_CloseStream, OnCloseStream)
    IPC_MESSAGE_HANDLER(AudioHostMsg_SetVolume, OnSetVolume)
    IPC_MESSAGE_UNHANDLED(handled = false)
  IPC_END_MESSAGE_MAP()

  return handled;
}

bool RenderProcessHostImpl::FastShutdownForPageCount(size_t count) {
  if (GetActiveViewCount() == count)
    return FastShutdownIfPossible();
  return false;
}

  Task(ImageLoader* loader,
       UpdateFromElementBehavior updateBehavior,
       ReferrerPolicy referrerPolicy)
      : m_loader(loader),
        m_shouldBypassMainWorldCSP(shouldBypassMainWorldCSP(loader)),
        m_updateBehavior(updateBehavior),
        m_weakFactory(this),
        m_referrerPolicy(referrerPolicy) {
    ExecutionContext& context = m_loader->element()->document();
    InspectorInstrumentation::asyncTaskScheduled(&context, "Image", this);
    v8::Isolate* isolate = V8PerIsolateData::mainThreadIsolate();
    v8::HandleScope scope(isolate);
    if (!isolate->GetCurrentContext().IsEmpty()) {
      m_scriptState = ScriptState::current(isolate);
    } else {
      m_scriptState =
          ScriptState::forMainWorld(loader->element()->document().frame());
      DCHECK(m_scriptState);
    }
    m_requestURL =
        loader->imageSourceToKURL(loader->element()->imageSourceURL());
  }

void ImageLoader::dispatchPendingLoadEvent() {
  if (!m_hasPendingLoadEvent)
    return;
  if (!m_image)
    return;
  m_hasPendingLoadEvent = false;
  if (element()->document().frame())
    dispatchLoadEvent();

  updatedHasPendingEvent();
}

AudioRendererHostTest()
: log_factory(base::MakeUnique<media::FakeAudioLogFactory>()),
audio_manager_(base::MakeUnique<FakeAudioManagerWithAssociations>(
base::ThreadTaskRunnerHandle::Get(),
log_factory.get())),
render_process_host_(&browser_context_, &auth_run_loop_) {
base::CommandLine::ForCurrentProcess()->AppendSwitch(
switches::kUseFakeDeviceForMediaStream);
media_stream_manager_.reset(new MediaStreamManager(audio_manager_.get()));
host_ = new MockAudioRendererHost(
&auth_run_loop_, render_process_host_.GetID(), audio_manager_.get(),
        &mirroring_manager_, media_stream_manager_.get(), kSalt);

// Simulate IPC channel connected.
host_->set_peer_process_for_testing(base::Process::Current());
}

void RenderProcessHostImpl::GetAudioOutputControllers(
    const GetAudioOutputControllersCallback& callback) const {
  audio_renderer_host()->GetOutputControllers(callback);
}

void ImageLoader::updateFromElement(UpdateFromElementBehavior updateBehavior,
                                    ReferrerPolicy referrerPolicy) {
  AtomicString imageSourceURL = m_element->imageSourceURL();
  m_suppressErrorEvents = (updateBehavior == UpdateSizeChanged);

  if (updateBehavior == UpdateIgnorePreviousError)
    clearFailedLoadURL();

  if (!m_failedLoadURL.isEmpty() && imageSourceURL == m_failedLoadURL)
    return;

  if (m_loadingImageDocument && updateBehavior != UpdateForcedReload) {
    ImageResource* imageResource =
        ImageResource::create(imageSourceToKURL(m_element->imageSourceURL()));
    imageResource->setStatus(Resource::Pending);
    m_imageResourceForImageDocument = imageResource;
    setImage(imageResource->getContent());
    return;
  }

  if (m_pendingTask) {
    m_pendingTask->clearLoader();
    m_pendingTask.reset();
  }

  KURL url = imageSourceToKURL(imageSourceURL);
  if (shouldLoadImmediately(url)) {
    doUpdateFromElement(DoNotBypassMainWorldCSP, updateBehavior, url,
                        referrerPolicy);
    return;
  }
  if (imageSourceURL.isEmpty()) {
    ImageResourceContent* image = m_image.get();
    if (image) {
      image->removeObserver(this);
    }
    m_image = nullptr;
  }

  Document& document = m_element->document();
  if (document.isActive())
    enqueueImageLoadingMicroTask(updateBehavior, referrerPolicy);
}

void RenderProcessHostImpl::ProcessDied(bool already_dead,
                                        RendererClosedDetails* known_details) {

  DCHECK(!within_process_died_observer_);

  DCHECK(!deleting_soon_);

  base::TerminationStatus status = base::TERMINATION_STATUS_NORMAL_TERMINATION;
  int exit_code = 0;
  if (known_details) {
    status = known_details->status;
    exit_code = known_details->exit_code;
  } else if (child_process_launcher_.get()) {
    status = child_process_launcher_->GetChildTerminationStatus(already_dead,
                                                                &exit_code);
    if (already_dead && status == base::TERMINATION_STATUS_STILL_RUNNING) {
      status = base::TERMINATION_STATUS_PROCESS_CRASHED;
    }
  }

  RendererClosedDetails details(status, exit_code);

  child_process_launcher_.reset();
  is_dead_ = true;
  if (route_provider_binding_.is_bound())
    route_provider_binding_.Close();
  ResetChannelProxy();

  UpdateProcessPriority();
  DCHECK(!is_process_backgrounded_);

  within_process_died_observer_ = true;
  NotificationService::current()->Notify(
      NOTIFICATION_RENDERER_PROCESS_CLOSED, Source<RenderProcessHost>(this),
      Details<RendererClosedDetails>(&details));
  for (auto& observer : observers_)
    observer.RenderProcessExited(this, status, exit_code);
  within_process_died_observer_ = false;

  message_port_message_filter_ = NULL;

  RemoveUserData(kSessionStorageHolderKey);

  IDMap<IPC::Listener*>::iterator iter(&listeners_);
  while (!iter.IsAtEnd()) {
    iter.GetCurrentValue()->OnMessageReceived(FrameHostMsg_RenderProcessGone(
        iter.GetCurrentKey(), static_cast<int>(status), exit_code));
    iter.Advance();
  }

  EnableSendQueue();

  if (delayed_cleanup_needed_)
    Cleanup();

}

static bool ExecuteFontName(LocalFrame& frame,
                            Event*,
                            EditorCommandSource source,
                            const String& value) {
  return ExecuteApplyStyle(frame, source, InputEvent::InputType::kNone,
                           CSSPropertyFontFamily, value);
}

bool SVGFEColorMatrixElement::setFilterEffectAttribute(FilterEffect* effect, const QualifiedName& attrName)
{
FEColorMatrix* colorMatrix = static_cast<FEColorMatrix*>(effect);
if (attrName == SVGNames::typeAttr)
return colorMatrix->setType(m_type->currentValue()->enumValue());
    if (attrName == SVGNames::valuesAttr)
        return colorMatrix->setValues(m_values->currentValue()->toFloatVector());

ASSERT_NOT_REACHED();
return false;
}

static bool ExecuteToggleOverwrite(LocalFrame& frame,
                                   Event*,
                                   EditorCommandSource,
                                   const String&) {
  frame.GetEditor().ToggleOverwriteModeEnabled();
  return true;
}

  AudioOutputAuthorizationHandlerTest() {
    base::CommandLine::ForCurrentProcess()->AppendSwitch(
        switches::kUseFakeDeviceForMediaStream);

    thread_bundle_ = base::MakeUnique<TestBrowserThreadBundle>(
        TestBrowserThreadBundle::Options::REAL_IO_THREAD);
    audio_thread_ = base::MakeUnique<AudioManagerThread>();
     audio_manager_.reset(new media::FakeAudioManager(
         audio_thread_->task_runner(), audio_thread_->worker_task_runner(),
         &log_factory_));
     media_stream_manager_ =
         base::MakeUnique<MediaStreamManager>(audio_manager_.get());
    SyncWithAllThreads();
  }

    T* get() { return m_ptr; }

const HostCache::Entry* HostCache::Lookup(const Key& key,
                                          base::TimeTicks now) {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
  if (caching_is_disabled())
    return nullptr;

  HostCache::Entry* entry = LookupInternal(key);
  if (!entry) {
    RecordLookup(LOOKUP_MISS_ABSENT, now, nullptr);
    return nullptr;
  }
  if (entry->IsStale(now, network_changes_)) {
    RecordLookup(LOOKUP_MISS_STALE, now, entry);
    return nullptr;
  }

  entry->CountHit(/* hit_is_stale= */ false);
  RecordLookup(LOOKUP_HIT_VALID, now, entry);
  return entry;
}

void HostCache::OnNetworkChange() {
  ++network_changes_;
}

  void GetInputDevices(std::vector<std::string>* audio_ids,
                       std::vector<std::string>* video_ids) {
    GURL url(embedded_test_server()->GetURL("/media/getusermedia.html"));
    NavigateToURL(shell(), url);

    std::string devices_as_json = ExecuteJavascriptAndReturnResult(
        "getSources()");
    EXPECT_FALSE(devices_as_json.empty());

    int error_code;
    std::string error_message;
    scoped_ptr<base::Value> value(
        base::JSONReader::ReadAndReturnError(devices_as_json,
                                             base::JSON_ALLOW_TRAILING_COMMAS,
                                             &error_code,
                                             &error_message));

    ASSERT_TRUE(value.get() != NULL) << error_message;
    EXPECT_EQ(value->GetType(), base::Value::TYPE_LIST);

    base::ListValue* values;
    ASSERT_TRUE(value->GetAsList(&values));

    for (base::ListValue::iterator it = values->begin();
         it != values->end(); ++it) {
      const base::DictionaryValue* dict;
      std::string kind;
      std::string device_id;
      ASSERT_TRUE((*it)->GetAsDictionary(&dict));
      ASSERT_TRUE(dict->GetString("kind", &kind));
      ASSERT_TRUE(dict->GetString("id", &device_id));
      ASSERT_FALSE(device_id.empty());
      EXPECT_TRUE(kind == "audio" || kind == "video");
      if (kind == "audio") {
        audio_ids->push_back(device_id);
      } else if (kind == "video") {
        video_ids->push_back(device_id);
      }
    }
    ASSERT_FALSE(audio_ids->empty());
    ASSERT_FALSE(video_ids->empty());
  }

void RenderProcessHostImpl::WidgetHidden() {
  if (visible_widgets_ == 0)
    return;

  --visible_widgets_;
  if (visible_widgets_ == 0) {
    DCHECK(!is_process_backgrounded_);
    UpdateProcessPriority();
  }
}

PassRefPtrWillBeRawPtr<FilterEffect> SVGFEColorMatrixElement::build(SVGFilterBuilder* filterBuilder, Filter* filter)
{
    FilterEffect* input1 = filterBuilder->getEffectById(AtomicString(m_in1->currentValue()->value()));

    if (!input1)
        return nullptr;

    Vector<float> filterValues;
    ColorMatrixType filterType = m_type->currentValue()->enumValue();

    if (!hasAttribute(SVGNames::valuesAttr)) {
        switch (filterType) {
        case FECOLORMATRIX_TYPE_MATRIX:
            for (size_t i = 0; i < 20; i++)
                filterValues.append((i % 6) ? 0 : 1);
            break;
        case FECOLORMATRIX_TYPE_HUEROTATE:
            filterValues.append(0);
            break;
        case FECOLORMATRIX_TYPE_SATURATE:
            filterValues.append(1);
            break;
        default:
            break;
        }
    } else {
        RefPtrWillBeRawPtr<SVGNumberList> values = m_values->currentValue();
        size_t size = values->length();

        if ((filterType == FECOLORMATRIX_TYPE_MATRIX && size != 20)
            || (filterType == FECOLORMATRIX_TYPE_HUEROTATE && size != 1)
            || (filterType == FECOLORMATRIX_TYPE_SATURATE && size != 1))
            return nullptr;

        filterValues = values->toFloatVector();
    }

    RefPtrWillBeRawPtr<FilterEffect> effect = FEColorMatrix::create(filter, filterType, filterValues);
    effect->inputEffects().append(input1);
    return effect.release();
}

bool ModifySelectionyWithPageGranularity(
    LocalFrame& frame,
    SelectionModifyAlteration alter,
    unsigned vertical_distance,
    SelectionModifyVerticalDirection direction) {
  SelectionModifier selection_modifier(
      frame, frame.Selection().ComputeVisibleSelectionInDOMTree());
  if (!selection_modifier.ModifyWithPageGranularity(alter, vertical_distance,
                                                    direction)) {
    return false;
  }

  frame.Selection().SetSelection(selection_modifier.Selection().AsSelection(),
                                 FrameSelection::kCloseTyping |
                                     FrameSelection::kClearTypingStyle |
                                     FrameSelection::kUserTriggered,
                                 alter == SelectionModifyAlteration::kMove
                                     ? CursorAlignOnScroll::kAlways
                                     : CursorAlignOnScroll::kIfNeeded);
  return true;
}

 HostCache::~HostCache() {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
  RecordEraseAll(ERASE_DESTRUCT, base::TimeTicks::Now());
}

static bool ExecuteScrollLineDown(LocalFrame& frame,
                                  Event*,
                                  EditorCommandSource,
                                  const String&) {
  return frame.GetEventHandler().BubblingScroll(kScrollDownIgnoringWritingMode,
                                                kScrollByLine);
}

static TriState StateJustifyFull(LocalFrame& frame, Event*) {
  return StateStyle(frame, CSSPropertyTextAlign, "justify");
}

  std::string GetNondefaultInputId() {
    std::string nondefault_id;

    MediaDevicesManager::BoolDeviceTypes devices_to_enumerate;
    devices_to_enumerate[MEDIA_DEVICE_TYPE_AUDIO_INPUT] = true;
    media_stream_manager_->media_devices_manager()->EnumerateDevices(
        devices_to_enumerate,
        base::Bind(
            [](std::string* out, const MediaDeviceEnumeration& result) {
              CHECK(result[MediaDeviceType::MEDIA_DEVICE_TYPE_AUDIO_INPUT]
                        .size() > 1)
                  << "Expected to have a nondefault device.";
              *out = result[MediaDeviceType::MEDIA_DEVICE_TYPE_AUDIO_INPUT][1]
                         .device_id;
            },
            base::Unretained(&nondefault_id)));

    base::RunLoop().RunUntilIdle();

    return nondefault_id;
  }

  virtual ~MockAudioMirroringManager() {}

base::FilePath RenderProcessHostImpl::GetAecDumpFilePathWithExtensions(
    const base::FilePath& file) {
  return file.AddExtension(IntToStringType(base::GetProcId(GetHandle())))
      .AddExtension(kAecDumpFileNameAddition);
}

size_t HostCache::max_entries() const {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
  return max_entries_;
}

static bool ExecuteScrollPageBackward(LocalFrame& frame,
                                      Event*,
                                      EditorCommandSource,
                                      const String&) {
  return frame.GetEventHandler().BubblingScroll(kScrollBlockDirectionBackward,
                                                kScrollByPage);
}

void RenderProcessHostImpl::OnBadMessageReceived(const IPC::Message& message) {
  auto type = message.type();
  LOG(ERROR) << "bad message " << type << " terminating renderer.";

  base::debug::Alias(&type);

  bad_message::ReceivedBadMessage(this,
                                  bad_message::RPH_DESERIALIZATION_FAILED);
}

void RenderProcessHostImpl::AppendRendererCommandLine(
    base::CommandLine* command_line) {
  command_line->AppendSwitchASCII(switches::kProcessType,
                                  switches::kRendererProcess);

#if defined(OS_WIN)
  command_line->AppendArg(switches::kPrefetchArgumentRenderer);
#endif  // defined(OS_WIN)

  const base::CommandLine& browser_command_line =
      *base::CommandLine::ForCurrentProcess();
  PropagateBrowserCommandLineToRenderer(browser_command_line, command_line);

  const std::string locale =
      GetContentClient()->browser()->GetApplicationLocale();
  command_line->AppendSwitchASCII(switches::kLang, locale);

  GetContentClient()->browser()->AppendExtraCommandLineSwitches(command_line,
                                                                GetID());

  if (IsPinchToZoomEnabled())
    command_line->AppendSwitch(switches::kEnablePinch);

#if defined(OS_WIN)
  command_line->AppendSwitchASCII(
      switches::kDeviceScaleFactor,
      base::DoubleToString(display::win::GetDPIScale()));
#endif

  AppendCompositorCommandLineFlags(command_line);

  command_line->AppendSwitchASCII(switches::kServiceRequestChannelToken,
                                  child_connection_->service_token());
  command_line->AppendSwitchASCII(switches::kRendererClientId,
                                  std::to_string(GetID()));
}

static String ValueEmpty(const EditorInternalCommand&, LocalFrame&, Event*) {
  return g_empty_string;
}

void RenderProcessHostImpl::RegisterProcessHostForSite(
    BrowserContext* browser_context,
    RenderProcessHost* process,
    const GURL& url) {
  SiteProcessMap* map = GetSiteProcessMapForBrowserContext(browser_context);

  std::string site =
      SiteInstance::GetSiteForURL(browser_context, url).possibly_invalid_spec();
  if (!site.empty())
    map->RegisterProcess(site, process);
}

void AudioRendererHost::OnPauseStream(int stream_id) {
  DCHECK_CURRENTLY_ON(BrowserThread::IO);

  AudioOutputDelegate* delegate = LookupById(stream_id);
  if (!delegate) {
    SendErrorMessage(stream_id);
    return;
  }

  delegate->OnPauseStream();
}

static bool ExecuteMoveToBeginningOfParagraphAndModifySelection(
    LocalFrame& frame,
    Event*,
    EditorCommandSource,
    const String&) {
  frame.Selection().Modify(
      SelectionModifyAlteration::kExtend, SelectionModifyDirection::kBackward,
      TextGranularity::kParagraphBoundary, SetSelectionBy::kUser);
  return true;
}

void VRDisplay::Dispose() {
  display_client_binding_.Close();
  vr_v_sync_provider_.reset();
}

HostCache::Entry::~Entry() {}

void RemoveShaderInfo(int32_t id) {
  if (GetShaderCacheFactorySingleton())
    GetShaderCacheFactorySingleton()->RemoveCacheInfo(id);
}

Editor::Command::Command() : command_(0) {}

static bool ExecuteMovePageUp(LocalFrame& frame,
                              Event*,
                              EditorCommandSource,
                              const String&) {
  unsigned distance = VerticalScrollDistance(frame);
  if (!distance)
    return false;
  return ModifySelectionyWithPageGranularity(
      frame, SelectionModifyAlteration::kMove, distance,
      SelectionModifyVerticalDirection::kUp);
}

  MockRenderProcessHostWithSignaling(BrowserContext* context,
                                     base::RunLoop* auth_run_loop)
      : MockRenderProcessHost(context), auth_run_loop_(auth_run_loop) {}

static bool ExecuteMakeTextWritingDirectionNatural(LocalFrame& frame,
                                                   Event*,
                                                   EditorCommandSource,
                                                   const String&) {
  MutableStylePropertySet* style =
      MutableStylePropertySet::Create(kHTMLQuirksMode);
  style->SetProperty(CSSPropertyUnicodeBidi, CSSValueNormal);
  frame.GetEditor().ApplyStyle(
      style, InputEvent::InputType::kFormatSetBlockTextDirection);
  return true;
}

void RenderProcessHostImpl::AddObserver(RenderProcessHostObserver* observer) {
  observers_.AddObserver(observer);
}

CachedShapingResults::~CachedShapingResults()
{
    hb_buffer_destroy(buffer);
}

static bool HasChildTags(Element& element, const QualifiedName& tag_name) {
  return !element.getElementsByTagName(tag_name.LocalName())->IsEmpty();
}

bool Editor::ExecuteCommand(const String& command_name, const String& value) {
  DCHECK(GetFrame().GetDocument()->IsActive());
  if (!CanEdit() && command_name == "moveToBeginningOfDocument")
    return GetFrame().GetEventHandler().BubblingScroll(
        kScrollUpIgnoringWritingMode, kScrollByDocument);

  if (!CanEdit() && command_name == "moveToEndOfDocument")
    return GetFrame().GetEventHandler().BubblingScroll(
        kScrollDownIgnoringWritingMode, kScrollByDocument);

  if (command_name == "showGuessPanel") {
    GetFrame().GetDocument()->UpdateStyleAndLayoutIgnorePendingStylesheets();

    GetSpellChecker().ShowSpellingGuessPanel();
    return true;
  }

  return CreateCommand(command_name).Execute(value);
}

void Editor::ChangeSelectionAfterCommand(
    const SelectionInDOMTree& new_selection,
    FrameSelection::SetSelectionOptions options) {
  if (new_selection.IsNone())
    return;

  bool selection_did_not_change_dom_position =
      new_selection == GetFrame().Selection().GetSelectionInDOMTree();
  GetFrame().Selection().SetSelection(
      SelectionInDOMTree::Builder(new_selection)
          .SetIsHandleVisible(GetFrame().Selection().IsHandleVisible())
          .Build(),
      options);

  if (selection_did_not_change_dom_position) {
    Client().RespondToChangedSelection(
        frame_, GetFrame().Selection().GetSelectionInDOMTree().Type());
  }
}

  void SyncWith(scoped_refptr<base::SingleThreadTaskRunner> task_runner) {
    CHECK(task_runner);
    CHECK(!task_runner->BelongsToCurrentThread());
    base::WaitableEvent e = {base::WaitableEvent::ResetPolicy::MANUAL,
                             base::WaitableEvent::InitialState::NOT_SIGNALED};
    task_runner->PostTask(FROM_HERE, base::Bind(&base::WaitableEvent::Signal,
                                                base::Unretained(&e)));
    e.Wait();
  }

void AudioRendererHost::GetOutputControllers(
    const RenderProcessHost::GetAudioOutputControllersCallback&
        callback) const {
  BrowserThread::PostTaskAndReplyWithResult(
      BrowserThread::IO, FROM_HERE,
      base::Bind(&AudioRendererHost::DoGetOutputControllers, this), callback);
}

static bool ExecuteIndent(LocalFrame& frame,
                          Event*,
                          EditorCommandSource,
                          const String&) {
  DCHECK(frame.GetDocument());
  return IndentOutdentCommand::Create(*frame.GetDocument(),
                                      IndentOutdentCommand::kIndent)
      ->Apply();
}

static String ValueFormatBlock(const EditorInternalCommand&,
                               LocalFrame& frame,
                               Event*) {
  const VisibleSelection& selection =
      frame.Selection().ComputeVisibleSelectionInDOMTreeDeprecated();
  if (!selection.IsNonOrphanedCaretOrRange() || !selection.IsContentEditable())
    return "";
  Element* format_block_element =
      FormatBlockCommand::ElementForFormatBlockCommand(
          FirstEphemeralRangeOf(selection));
  if (!format_block_element)
    return "";
  return format_block_element->localName();
}

 ScriptPromise VRDisplay::requestPresent(ScriptState* script_state,
                                         const HeapVector<VRLayer>& layers) {
   ExecutionContext* execution_context = ExecutionContext::From(script_state);
   UseCounter::Count(execution_context, UseCounter::kVRRequestPresent);
   if (!execution_context->IsSecureContext()) {
    UseCounter::Count(execution_context,
                      UseCounter::kVRRequestPresentInsecureOrigin);
  }

  ReportPresentationResult(PresentationResult::kRequested);

  ScriptPromiseResolver* resolver = ScriptPromiseResolver::Create(script_state);
  ScriptPromise promise = resolver->Promise();

  if (!capabilities_->canPresent()) {
    DOMException* exception =
        DOMException::Create(kInvalidStateError, "VRDisplay cannot present.");
    resolver->Reject(exception);
    ReportPresentationResult(PresentationResult::kVRDisplayCannotPresent);
    return promise;
  }

  bool first_present = !is_presenting_;

  if (first_present && !UserGestureIndicator::UtilizeUserGesture() &&
      !in_display_activate_) {
    DOMException* exception = DOMException::Create(
        kInvalidStateError, "API can only be initiated by a user gesture.");
    resolver->Reject(exception);
    ReportPresentationResult(PresentationResult::kNotInitiatedByUserGesture);
    return promise;
  }

  if (layers.size() == 0 || layers.size() > capabilities_->maxLayers()) {
    ForceExitPresent();
    DOMException* exception =
        DOMException::Create(kInvalidStateError, "Invalid number of layers.");
    resolver->Reject(exception);
    ReportPresentationResult(PresentationResult::kInvalidNumberOfLayers);
    return promise;
  }

  if (layers[0].source().isNull()) {
    ForceExitPresent();
    DOMException* exception =
        DOMException::Create(kInvalidStateError, "Invalid layer source.");
    resolver->Reject(exception);
    ReportPresentationResult(PresentationResult::kInvalidLayerSource);
    return promise;
  }
  layer_ = layers[0];

  CanvasRenderingContext* rendering_context;
  if (layer_.source().isHTMLCanvasElement()) {
    rendering_context =
        layer_.source().getAsHTMLCanvasElement()->RenderingContext();
  } else {
    DCHECK(layer_.source().isOffscreenCanvas());
    rendering_context =
        layer_.source().getAsOffscreenCanvas()->RenderingContext();
  }

  if (!rendering_context || !rendering_context->Is3d()) {
    ForceExitPresent();
    DOMException* exception = DOMException::Create(
        kInvalidStateError, "Layer source must have a WebGLRenderingContext");
    resolver->Reject(exception);
    ReportPresentationResult(
        PresentationResult::kLayerSourceMissingWebGLContext);
    return promise;
  }

  rendering_context_ = ToWebGLRenderingContextBase(rendering_context);
  context_gl_ = rendering_context_->ContextGL();

  if ((layer_.leftBounds().size() != 0 && layer_.leftBounds().size() != 4) ||
      (layer_.rightBounds().size() != 0 && layer_.rightBounds().size() != 4)) {
    ForceExitPresent();
    DOMException* exception = DOMException::Create(
        kInvalidStateError,
        "Layer bounds must either be an empty array or have 4 values");
    resolver->Reject(exception);
    ReportPresentationResult(PresentationResult::kInvalidLayerBounds);
    return promise;
  }

  if (!pending_present_resolvers_.IsEmpty()) {
    pending_present_resolvers_.push_back(resolver);
  } else if (first_present) {
    bool secure_context =
        ExecutionContext::From(script_state)->IsSecureContext();
    if (!display_) {
      ForceExitPresent();
      DOMException* exception = DOMException::Create(
          kInvalidStateError, "The service is no longer active.");
      resolver->Reject(exception);
      return promise;
    }

    pending_present_resolvers_.push_back(resolver);
    submit_frame_client_binding_.Close();
    display_->RequestPresent(
        secure_context,
        submit_frame_client_binding_.CreateInterfacePtrAndBind(),
        ConvertToBaseCallback(
            WTF::Bind(&VRDisplay::OnPresentComplete, WrapPersistent(this))));
  } else {
    UpdateLayerBounds();
    resolver->Resolve();
    ReportPresentationResult(PresentationResult::kSuccessAlreadyPresenting);
  }

  return promise;
}

static String ValueStyle(LocalFrame& frame, CSSPropertyID property_id) {
  frame.GetDocument()->UpdateStyleAndLayoutIgnorePendingStylesheets();

  return frame.GetEditor().SelectionStartCSSPropertyValue(property_id);
}

bool RenderProcessHostImpl::IsReady() const {
  return GetHandle() && channel_connected_;
}

void RenderProcessHostImpl::UnregisterAecDumpConsumerOnUIThread(int id) {
  DCHECK_CURRENTLY_ON(BrowserThread::UI);
  for (std::vector<int>::iterator it = aec_dump_consumers_.begin();
       it != aec_dump_consumers_.end(); ++it) {
    if (*it == id) {
      aec_dump_consumers_.erase(it);
      break;
    }
  }
}

const UsbDeviceHandle::TransferCallback& callback() const {
    return callback_;
}

static bool ExecuteUnlink(LocalFrame& frame,
                          Event*,
                          EditorCommandSource,
                          const String&) {
  DCHECK(frame.GetDocument());
  return UnlinkCommand::Create(*frame.GetDocument())->Apply();
}

static bool ExecuteMoveToEndOfLine(LocalFrame& frame,
                                   Event*,
                                   EditorCommandSource,
                                   const String&) {
  frame.Selection().Modify(
      SelectionModifyAlteration::kMove, SelectionModifyDirection::kForward,
      TextGranularity::kLineBoundary, SetSelectionBy::kUser);
  return true;
}

static bool ExecutePaste(LocalFrame& frame,
                         Event*,
                         EditorCommandSource source,
                         const String&) {
  if (!CanReadClipboard(frame, source))
    return false;
  frame.GetEditor().Paste(source);
  return true;
}

static bool ExecuteInsertText(LocalFrame& frame,
                              Event*,
                              EditorCommandSource,
                              const String& value) {
  DCHECK(frame.GetDocument());
  TypingCommand::InsertText(*frame.GetDocument(), value, 0);
  return true;
}

bool Editor::Command::IsTextInsertion() const {
  return command_ && command_->is_text_insertion;
}

  const UsbDeviceHandle::ResultCallback& callback() const { return callback_; }

AudioOutputDelegate* AudioRendererHost::LookupById(int stream_id) {
  DCHECK_CURRENTLY_ON(BrowserThread::IO);

  auto i = LookupIteratorById(stream_id);
  return i != delegates_.end() ? i->get() : nullptr;
}
