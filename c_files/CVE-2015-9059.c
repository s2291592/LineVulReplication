baud_up (int baud)
{
	return term_baud_up(baud);
}

run_cmd(int fd, ...)
{
pid_t pid;
sigset_t sigm, sigm_old;

/* block signals, let child establish its own handlers */
sigemptyset(&sigm);
sigaddset(&sigm, SIGTERM);
sigprocmask(SIG_BLOCK, &sigm, &sigm_old);

pid = fork();
if ( pid < 0 ) {
sigprocmask(SIG_SETMASK, &sigm_old, NULL);
fd_printf(STO, "*** cannot fork: %s ***\r\n", strerror(errno));
return -1;
} else if ( pid ) {
/* father: picocom */
int status, r;

/* reset the mask */
sigprocmask(SIG_SETMASK, &sigm_old, NULL);
/* wait for child to finish */
do {
r = waitpid(pid, &status, 0);
} while ( r < 0 && errno == EINTR );
/* reset terminal (back to raw mode) */
term_apply(STI);
/* check and report child return status */
if ( WIFEXITED(status) ) {
fd_printf(STO, "\r\n*** exit status: %d ***\r\n",
WEXITSTATUS(status));
return WEXITSTATUS(status);
} else if ( WIFSIGNALED(status) ) {
fd_printf(STO, "\r\n*** killed by signal: %d ***\r\n",
WTERMSIG(status));
return -1;
} else {
fd_printf(STO, "\r\n*** abnormal termination: 0x%x ***\r\n", r);
return -1;
}
} else {
/* child: external program */
long fl;
		char cmd[512];
/* unmanage terminal, and reset it to canonical mode */
term_remove(STI);
/* unmanage serial port fd, without reset */
term_erase(fd);
/* set serial port fd to blocking mode */
fl = fcntl(fd, F_GETFL);
fl &= ~O_NONBLOCK;
fcntl(fd, F_SETFL, fl);
/* connect stdin and stdout to serial port */
close(STI);
close(STO);
dup2(fd, STI);
dup2(fd, STO);
		{
			/* build command-line *
			char *c, *ce;
			const char *s;
			int n;
			va_list vls;
			
			strcpy(cmd, EXEC);
			c = &cmd[sizeof(EXEC)- 1];
			ce = cmd + sizeof(cmd) - 1;
			va_start(vls, fd);
			while ( (s = va_arg(vls, const char *)) ) {
				n = strlen(s);
				if ( c + n + 1 >= ce ) break;
				memcpy(c, s, n); c += n;
				*c++ = ' ';
			}
			va_end(vls);
			*c = '\0';
}
/* run extenral command */
		fd_printf(STDERR_FILENO, "%s\n", &cmd[sizeof(EXEC) - 1]);
establish_child_signal_handlers();
sigprocmask(SIG_SETMASK, &sigm_old, NULL);
		execl("/bin/sh", "sh", "-c", cmd, NULL);
		exit(42);
}
}

read_filename (void)
{
	char fname[_POSIX_PATH_MAX];
	int r;

	fd_printf(STO, "\r\n*** file: ");
	r = fd_readline(STI, STO, fname, sizeof(fname));
	fd_printf(STO, "\r\n");
	if ( r < 0 ) 
		return NULL;
	else
		return strdup(fname);
}

fd_readline (int fdi, int fdo, char *b, int bsz)
{
	int r;
	unsigned char c;
	unsigned char *bp, *bpe;
	
	bp = (unsigned char *)b;
	bpe = (unsigned char *)b + bsz - 1;

	while (1) {
		r = read(fdi, &c, 1);
		if ( r <= 0 ) { r = -1; goto out; }

		switch (c) {
		case '\b':
		case '\x7f':
			if ( bp > (unsigned char *)b ) { 
				bp--;
				cput(fdo, '\b'); cput(fdo, ' '); cput(fdo, '\b');
			} else {
				cput(fdo, '\x07');
			}
			break;
		case '\x03': /* CTRL-c */
			r = -1;
			errno = EINTR;
			goto out;
		case '\r':
			*bp = '\0';
			r = bp - (unsigned char *)b; 
			goto out;
		default:
			if ( bp < bpe ) { *bp++ = c; cput(fdo, c); }
			else { cput(fdo, '\x07'); }
			break;
		}
	}

out:
	return r;
}

parse_map (char *s)
{
	char *m, *t;
	int f, flags, i;

	flags = 0;
	while ( (t = strtok(s, ", \t")) ) {
		for (i=0; (m = map_names[i].name); i++) {
			if ( ! strcmp(t, m) ) {
				f = map_names[i].flag;
				break;
			}
		}
		if ( m ) flags |= f;
		else { flags = -1; break; }
		s = NULL;
	}

	return flags;
}

bits_next (int bits)
{
	bits++;
	if (bits > 8) bits = 5;

	return bits;
}

uucp_unlock(void)
{
	if ( lockname[0] ) unlink(lockname);
	return 0;
}

baud_down (int baud)
{
	int nb;
	nb = term_baud_down(baud);
	if (nb == 0)
		nb = baud;
	return nb;
}

parse_args(int argc, char *argv[])
{
	int r;

	static struct option longOptions[] =
	{
		{"receive-cmd", required_argument, 0, 'v'},
		{"send-cmd", required_argument, 0, 's'},
        {"imap", required_argument, 0, 'I' },
        {"omap", required_argument, 0, 'O' },
        {"emap", required_argument, 0, 'E' },
		{"escape", required_argument, 0, 'e'},
		{"echo", no_argument, 0, 'c'},
		{"noinit", no_argument, 0, 'i'},
		{"noreset", no_argument, 0, 'r'},
		{"nolock", no_argument, 0, 'l'},
		{"flow", required_argument, 0, 'f'},
		{"baud", required_argument, 0, 'b'},
		{"parity", required_argument, 0, 'p'},
		{"databits", required_argument, 0, 'd'},
		{"help", no_argument, 0, 'h'},
		{0, 0, 0, 0}
	};

	r = 0;
	while (1) {
		int optionIndex = 0;
		int c;
		int map;

		/* no default error messages printed. */
		opterr = 0;

		c = getopt_long(argc, argv, "hirlcv:s:r:e:f:b:p:d:",
						longOptions, &optionIndex);

		if (c < 0)
			break;

		switch (c) {
		case 's':
			strncpy(opts.send_cmd, optarg, sizeof(opts.send_cmd));
			opts.send_cmd[sizeof(opts.send_cmd) - 1] = '\0';
			break;
		case 'v':
			strncpy(opts.receive_cmd, optarg, sizeof(opts.receive_cmd));
			opts.receive_cmd[sizeof(opts.receive_cmd) - 1] = '\0';
			break;
		case 'I':
			map = parse_map(optarg);
			if (map >= 0) opts.imap = map;
			else { fprintf(stderr, "Invalid --imap\n"); r = -1; }
			break;
		case 'O':
			map = parse_map(optarg);
			if (map >= 0) opts.omap = map;
			else { fprintf(stderr, "Invalid --omap\n"); r = -1; }
			break;
		case 'E':
			map = parse_map(optarg);
			if (map >= 0) opts.emap = map;
			else { fprintf(stderr, "Invalid --emap\n"); r = -1; }
			break;
		case 'c':
			opts.lecho = 1;
			break;
		case 'i':
			opts.noinit = 1;
			break;
		case 'r':
			opts.noreset = 1;
			break;
		case 'l':
#if defined (UUCP_LOCK_DIR) || defined (USE_FLOCK)
			opts.nolock = 1;
#endif
			break;
		case 'e':
			opts.escape = optarg[0] & 0x1f;
			break;
		case 'f':
			switch (optarg[0]) {
			case 'X':
			case 'x':
				opts.flow = FC_XONXOFF;
				break;
			case 'H':
			case 'h':
				opts.flow = FC_RTSCTS;
				break;
			case 'N':
			case 'n':
				opts.flow = FC_NONE;
				break;
			default:
				fprintf(stderr, "Invalid --flow: %c\n", optarg[0]);
				r = -1;
				break;
			}
			break;
		case 'b':
			opts.baud = atoi(optarg);
			break;
		case 'p':
			switch (optarg[0]) {
			case 'e':
				opts.parity = P_EVEN;
				break;
			case 'o':
				opts.parity = P_ODD;
				break;
			case 'n':
				opts.parity = P_NONE;
				break;
			default:
				fprintf(stderr, "Invalid --parity: %c\n", optarg[0]);
				r = -1;
				break;
			}
			break;
		case 'd':
			switch (optarg[0]) {
			case '5':
				opts.databits = 5;
				break;
			case '6':
				opts.databits = 6;
				break;
			case '7':
				opts.databits = 7;
				break;
			case '8':
				opts.databits = 8;
				break;
			default:
				fprintf(stderr, "Invalid --databits: %c\n", optarg[0]);
				r = -1;
				break;
			}
			break;
		case 'h':
			show_usage(argv[0]);
			exit(EXIT_SUCCESS);
		case '?':
		default:
			fprintf(stderr, "Unrecognized option(s)\n");
			r = -1;
			break;
		}
		if ( r < 0 ) {
			fprintf(stderr, "Run with '--help'.\n");
			exit(EXIT_FAILURE);
		}
	} /* while */

	if ( (argc - optind) < 1) {
		fprintf(stderr, "No port given\n");
		fprintf(stderr, "Run with '--help'.\n");
		exit(EXIT_FAILURE);
	}
	strncpy(opts.port, argv[optind], sizeof(opts.port) - 1);
	opts.port[sizeof(opts.port) - 1] = '\0';

	printf("picocom v%s\n", VERSION_STR);
	printf("\n");
	printf("port is        : %s\n", opts.port);
	printf("flowcontrol    : %s\n", flow_str[opts.flow]);
	printf("baudrate is    : %d\n", opts.baud);
	printf("parity is      : %s\n", parity_str[opts.parity]);
	printf("databits are   : %d\n", opts.databits);
	printf("escape is      : C-%c\n", 'a' + opts.escape - 1);
	printf("local echo is  : %s\n", opts.lecho ? "yes" : "no");
	printf("noinit is      : %s\n", opts.noinit ? "yes" : "no");
	printf("noreset is     : %s\n", opts.noreset ? "yes" : "no");
#if defined (UUCP_LOCK_DIR) || defined (USE_FLOCK)
	printf("nolock is      : %s\n", opts.nolock ? "yes" : "no");
#endif
	printf("send_cmd is    : %s\n", 
		   (opts.send_cmd[0] == '\0') ? "disabled" : opts.send_cmd);
	printf("receive_cmd is : %s\n", 
		   (opts.receive_cmd[0] == '\0') ? "disabled" : opts.receive_cmd);
	printf("imap is        : "); print_map(opts.imap);
	printf("omap is        : "); print_map(opts.omap);
	printf("emap is        : "); print_map(opts.emap);
	printf("\n");
}

do_map (char *b, int map, char c)
{
	int n;

	switch (c) {
	case '\x7f':
		/* DEL mapings */
		if ( map & M_DELBS ) {
			b[0] = '\x08'; n = 1;
		} else {
			b[0] = c; n = 1;
		}
		break;
	case '\x08':
		/* BS mapings */
		if ( map & M_BSDEL ) {
			b[0] = '\x7f'; n = 1;
		} else {
			b[0] = c; n = 1;
		}
		break;
	case '\x0d':
		/* CR mappings */
		if ( map & M_CRLF ) {
			b[0] = '\x0a'; n = 1;
		} else if ( map & M_CRCRLF ) {
			b[0] = '\x0d'; b[1] = '\x0a'; n = 2;
		} else if ( map & M_IGNCR ) {
			n = 0;
		} else {
			b[0] = c; n = 1;
		}
		break;
	case '\x0a':
		/* LF mappings */
		if ( map & M_LFCR ) {
			b[0] = '\x0d'; n = 1;
		} else if ( map & M_LFCRLF ) {
			b[0] = '\x0d'; b[1] = '\x0a'; n = 2;
		} else if ( map & M_IGNLF ) {
			n = 0;
		} else {
			b[0] = c; n = 1;
		}
		break;
	default:
		b[0] = c; n = 1;
		break;
	}

	return n;
}

print_map (int flags)
{
	int i;

	for (i = 0; i < M_NFLAGS; i++)
		if ( flags & (1 << i) )
			printf("%s,", map_names[i].name);
	printf("\n");
}

fatal (const char *format, ...)
{
	char *s, buf[256];
	va_list args;
	int len;

	term_reset(STO);
	term_reset(STI);
	
	va_start(args, format);
	len = vsnprintf(buf, sizeof(buf), format, args);
	buf[sizeof(buf) - 1] = '\0';
	va_end(args);
	
	s = "\r\nFATAL: ";
	writen_ni(STO, s, strlen(s));
	writen_ni(STO, buf, len);
	s = "\r\n";
	writen_ni(STO, s, strlen(s));

	/* wait a bit for output to drain */
	sleep(1);

#ifdef UUCP_LOCK_DIR
	uucp_unlock();
#endif
	
	exit(EXIT_FAILURE);
}

init_send_receive_history (void)
{
	char *home_directory;

	home_directory = getenv("HOME");
	if (home_directory) {
		send_receive_history_file_path = 
			malloc(strlen(home_directory) + 2 + 
				   strlen(SEND_RECEIVE_HISTFILE));
		strcpy(send_receive_history_file_path, home_directory);
		if (home_directory[strlen(home_directory)-1] != '/') {
			strcat(send_receive_history_file_path, "/");
		}
		strcat(send_receive_history_file_path, SEND_RECEIVE_HISTFILE);
		linenoiseHistoryLoad(send_receive_history_file_path);
	}
}

file_completion_cb (const char *buf, linenoiseCompletions *lc) 
{
	DIR *dirp;
	struct dirent *dp;
	char *basec, *basen, *dirc, *dirn;
	int baselen, dirlen;
	char *fullpath;
	struct stat filestat;

	basec = strdup(buf);
	dirc = strdup(buf);
	dirn = dirname(dirc);
	dirlen = strlen(dirn);
	basen = basename(basec);
	baselen = strlen(basen);
	dirp = opendir(dirn);

	if (dirp) {
		while ((dp = readdir(dirp)) != NULL) {
			if (strncmp(basen, dp->d_name, baselen) == 0) {
				/* add 2 extra bytes for possible / in middle & at end */
				fullpath = (char *) malloc(strlen(dp->d_name) + dirlen + 3);
				strcpy(fullpath, dirn);
				if (fullpath[dirlen-1] != '/')
					strcat(fullpath, "/");
				strcat(fullpath, dp->d_name);
				if (stat(fullpath, &filestat) == 0) {
					if (S_ISDIR(filestat.st_mode)) {
						strcat(fullpath, "/");
					}
					linenoiseAddCompletion(lc,fullpath);
				}
				free(fullpath);
			}
		}

		closedir(dirp);
	}
	free(basec);
	free(dirc);
}

do_command (unsigned char c)
{
static int dtr_up = 0;
int newbaud, newflow, newparity, newbits;
const char *xfr_cmd;
char *fname;
int r;

switch (c) {
case KEY_EXIT:
return 1;
case KEY_QUIT:
term_set_hupcl(tty_fd, 0);
term_flush(tty_fd);
term_apply(tty_fd);
term_erase(tty_fd);
return 1;
case KEY_STATUS:
show_status(dtr_up);
break;
case KEY_PULSE:
fd_printf(STO, "\r\n*** pulse DTR ***\r\n");
if ( term_pulse_dtr(tty_fd) < 0 )
fd_printf(STO, "*** FAILED\r\n");
break;
case KEY_TOGGLE:
if ( dtr_up )
r = term_lower_dtr(tty_fd);
else
r = term_raise_dtr(tty_fd);
if ( r >= 0 ) dtr_up = ! dtr_up;
fd_printf(STO, "\r\n*** DTR: %s ***\r\n",
dtr_up ? "up" : "down");
break;
case KEY_BAUD_UP:
case KEY_BAUD_DN:
if (c == KEY_BAUD_UP)
opts.baud = baud_up(opts.baud);
else
opts.baud = baud_down(opts.baud);
term_set_baudrate(tty_fd, opts.baud);
tty_q.len = 0; term_flush(tty_fd);
term_apply(tty_fd);
newbaud = term_get_baudrate(tty_fd, NULL);
if ( opts.baud != newbaud ) {
fd_printf(STO, "\r\n*** baud: %d (%d) ***\r\n",
opts.baud, newbaud);
} else {
fd_printf(STO, "\r\n*** baud: %d ***\r\n", opts.baud);
}
set_tty_write_sz(newbaud);
break;
case KEY_FLOW:
opts.flow = flow_next(opts.flow);
term_set_flowcntrl(tty_fd, opts.flow);
tty_q.len = 0; term_flush(tty_fd);
term_apply(tty_fd);
newflow = term_get_flowcntrl(tty_fd);
if ( opts.flow != newflow ) {
fd_printf(STO, "\r\n*** flow: %s (%s) ***\r\n",
flow_str[opts.flow], flow_str[newflow]);
} else {
fd_printf(STO, "\r\n*** flow: %s ***\r\n",
flow_str[opts.flow]);
}
break;
case KEY_PARITY:
opts.parity = parity_next(opts.parity);
term_set_parity(tty_fd, opts.parity);
tty_q.len = 0; term_flush(tty_fd);
term_apply(tty_fd);
newparity = term_get_parity(tty_fd);
if (opts.parity != newparity ) {
fd_printf(STO, "\r\n*** parity: %s (%s) ***\r\n",
parity_str[opts.parity],
parity_str[newparity]);
} else {
fd_printf(STO, "\r\n*** parity: %s ***\r\n",
parity_str[opts.parity]);
}
break;
case KEY_BITS:
opts.databits = bits_next(opts.databits);
term_set_databits(tty_fd, opts.databits);
tty_q.len = 0; term_flush(tty_fd);
term_apply(tty_fd);
newbits = term_get_databits(tty_fd);
if (opts.databits != newbits ) {
fd_printf(STO, "\r\n*** databits: %d (%d) ***\r\n",
opts.databits, newbits);
} else {
fd_printf(STO, "\r\n*** databits: %d ***\r\n",
opts.databits);
}
break;
case KEY_LECHO:
opts.lecho = ! opts.lecho;
fd_printf(STO, "\r\n*** local echo: %s ***\r\n",
opts.lecho ? "yes" : "no");
break;
case KEY_SEND:
case KEY_RECEIVE:
xfr_cmd = (c == KEY_SEND) ? opts.send_cmd : opts.receive_cmd;
if ( xfr_cmd[0] == '\0' ) {
fd_printf(STO, "\r\n*** command disabled ***\r\n");
break;
}
fname = read_filename();
if (fname == NULL) {
fd_printf(STO, "*** cannot read filename ***\r\n");
break;
}
		run_cmd(tty_fd, xfr_cmd, fname, NULL);
free(fname);
break;
case KEY_BREAK:
term_break(tty_fd);
fd_printf(STO, "\r\n*** break sent ***\r\n");
break;
default:
break;
}

return 0;
}

loop(void)
{
	enum {
		ST_COMMAND,
		ST_TRANSPARENT
	} state;
	fd_set rdset, wrset;
	int r, n;
	unsigned char c;

	tty_q.len = 0;
	state = ST_TRANSPARENT;

	while ( ! sig_exit ) {
		FD_ZERO(&rdset);
		FD_ZERO(&wrset);
		FD_SET(STI, &rdset);
		FD_SET(tty_fd, &rdset);
		if ( tty_q.len ) FD_SET(tty_fd, &wrset);

		r = select(tty_fd + 1, &rdset, &wrset, NULL, NULL);
		if ( r < 0 )  {
			if ( errno == EINTR )
				continue;
			else
				fatal("select failed: %d : %s", errno, strerror(errno));
		}

		if ( FD_ISSET(STI, &rdset) ) {

			/* read from terminal */

			do {
				n = read(STI, &c, 1);
			} while (n < 0 && errno == EINTR);
			if (n == 0) {
				fatal("stdin closed");
			} else if (n < 0) {
				/* is this really necessary? better safe than sory! */
				if ( errno != EAGAIN && errno != EWOULDBLOCK ) 
					fatal("read from stdin failed: %s", strerror(errno));
				else
					goto skip_proc_STI;
			}

			switch (state) {
			case ST_COMMAND:
				if ( c == opts.escape ) {
					/* pass the escape character down */
					if (tty_q.len + M_MAXMAP <= TTY_Q_SZ) {
						n = do_map((char *)tty_q.buff + tty_q.len, 
								   opts.omap, c);
						tty_q.len += n;
						if ( opts.lecho ) 
							map_and_write(STO, opts.emap, c);
					} else {
						fd_printf(STO, "\x07");
					}
				} else {
					/* process command key */
					if ( do_command(c) )
						/* picocom exit */
						return;
				}
				state = ST_TRANSPARENT;
				break;
			case ST_TRANSPARENT:
				if ( c == opts.escape ) {
					state = ST_COMMAND;
				} else {
					if (tty_q.len + M_MAXMAP <= TTY_Q_SZ) {
						n = do_map((char *)tty_q.buff + tty_q.len, 
								   opts.omap, c);
						tty_q.len += n;
						if ( opts.lecho ) 
							map_and_write(STO, opts.emap, c);
					} else 
						fd_printf(STO, "\x07");
				}
				break;
			default:
				assert(0);
				break;
			}
		}
	skip_proc_STI:

		if ( FD_ISSET(tty_fd, &rdset) ) {

			/* read from port */

			do {
				n = read(tty_fd, &c, 1);
			} while (n < 0 && errno == EINTR);
			if (n == 0) {
				fatal("term closed");
			} else if ( n < 0 ) {
				if ( errno != EAGAIN && errno != EWOULDBLOCK )
					fatal("read from term failed: %s", strerror(errno));
			} else {
				map_and_write(STO, opts.imap, c);
			}
		}

		if ( FD_ISSET(tty_fd, &wrset) ) {

			/* write to port */

			int sz;
			sz = (tty_q.len < tty_write_sz) ? tty_q.len : tty_write_sz;
			do {
				n = write(tty_fd, tty_q.buff, sz);
			} while ( n < 0 && errno == EINTR );
			if ( n <= 0 )
				fatal("write to term failed: %s", strerror(errno));
			memmove(tty_q.buff, tty_q.buff + n, tty_q.len - n);
			tty_q.len -= n;
		}
	}
}

 establish_child_signal_handlers (void)
 {
	struct sigaction dfl_action;

	/* Set up the structure to specify the default action. */
	dfl_action.sa_handler = SIG_DFL;
	sigemptyset (&dfl_action.sa_mask);
	dfl_action.sa_flags = 0;
	
	sigaction (SIGINT, &dfl_action, NULL);
 	sigaction (SIGTERM, &dfl_action, NULL);
 }

show_usage(char *name)
{
	char *s;

	s = strrchr(name, '/');
	s = s ? s+1 : name;

	printf("picocom v%s\n", VERSION_STR);

	printf("\nCompiled-in options:\n");
	printf("  TTY_Q_SZ is %d\n", TTY_Q_SZ);
#ifdef USE_HIGH_BAUD
	printf("  HIGH_BAUD is enabled\n");
#endif
#ifdef USE_FLOCK
	printf("  USE_FLOCK is enabled\n");
#endif
#ifdef UUCP_LOCK_DIR
	printf("  UUCP_LOCK_DIR is: %s\n", UUCP_LOCK_DIR);
#endif
#ifdef LINENOISE
	printf("  LINENOISE is enabled\n");
	printf("  SEND_RECEIVE_HISTFILE is: %s\n", SEND_RECEIVE_HISTFILE);
#endif
	
	printf("\nUsage is: %s [options] <tty device>\n", s);
	printf("Options are:\n");
	printf("  --<b>aud <baudrate>\n");
	printf("  --<f>low s (=soft) | h (=hard) | n (=none)\n");
	printf("  --<p>arity o (=odd) | e (=even) | n (=none)\n");
	printf("  --<d>atabits 5 | 6 | 7 | 8\n");
	printf("  --<e>scape <char>\n");
	printf("  --e<c>ho\n");
	printf("  --no<i>nit\n");
	printf("  --no<r>eset\n");
	printf("  --no<l>ock\n");
	printf("  --<s>end-cmd <command>\n");
	printf("  --recei<v>e-cmd <command>\n");
	printf("  --imap <map> (input mappings)\n");
	printf("  --omap <map> (output mappings)\n");
	printf("  --emap <map> (local-echo mappings)\n");
	printf("  --<h>elp\n");
	printf("<map> is a comma-separated list of one or more of:\n");
	printf("  crlf : map CR --> LF\n");
	printf("  crcrlf : map CR --> CR + LF\n");
	printf("  igncr : ignore CR\n");
	printf("  lfcr : map LF --> CR\n");
	printf("  lfcrlf : map LF --> CR + LF\n");
	printf("  ignlf : ignore LF\n");
	printf("  bsdel : map BS --> DEL\n");
	printf("  delbs : map DEL --> BS\n");
	printf("<?> indicates the equivalent short option.\n");
	printf("Short options are prefixed by \"-\" instead of by \"--\".\n");
}

cleanup_send_receive_history (void)
{
	if (send_receive_history_file_path)
		free(send_receive_history_file_path);
}

add_send_receive_history (char *fname)
{
	linenoiseHistoryAdd(fname);
	if (send_receive_history_file_path)
		linenoiseHistorySave(send_receive_history_file_path);
}

fd_printf (int fd, const char *format, ...)
{
	char buf[256];
	va_list args;
	int len;
	
	va_start(args, format);
	len = vsnprintf(buf, sizeof(buf), format, args);
	buf[sizeof(buf) - 1] = '\0';
	va_end(args);
	
	return writen_ni(fd, buf, len);
}

uucp_lockname(const char *dir, const char *file)
{
	char *p, *cp;
	struct stat sb;

	if ( ! dir || *dir == '\0' || stat(dir, &sb) != 0 )
		return -1;

	/* cut-off initial "/dev/" from file-name */
	p = strchr(file + 1, '/');
	p = p ? p + 1 : (char *)file;
	/* replace '/'s with '_'s in what remains (after making a copy) */
	p = cp = strdup(p);
	do { if ( *p == '/' ) *p = '_'; } while(*p++);
	/* build lockname */
	snprintf(lockname, sizeof(lockname), "%s/LCK..%s", dir, cp);
	/* destroy the copy */
	free(cp);

	return 0;
}

deadly_handler(int signum)
{
	if ( ! sig_exit ) {
		sig_exit = 1;
		kill(0, SIGTERM);
	}
}

uucp_lock(void)
{
	int r, fd, pid;
	char buf[16];
	mode_t m;

	if ( lockname[0] == '\0' ) return 0;

	fd = open(lockname, O_RDONLY);
	if ( fd >= 0 ) {
		r = read(fd, buf, sizeof(buf)); 
		close(fd);
		/* if r == 4, lock file is binary (old-style) */
		pid = (r == 4) ? *(int *)buf : strtol(buf, NULL, 10);
		if ( pid > 0 
			 && kill((pid_t)pid, 0) < 0 
			 && errno == ESRCH ) {
			/* stale lock file */
			printf("Removing stale lock: %s\n", lockname);
			sleep(1);
			unlink(lockname);
		} else {
			lockname[0] = '\0';
			errno = EEXIST;
			return -1;
		}
	}
	/* lock it */
	m = umask(022);
	fd = open(lockname, O_WRONLY|O_CREAT|O_EXCL, 0666);
	if ( fd < 0 ) { lockname[0] = '\0'; return -1; }
	umask(m);
	snprintf(buf, sizeof(buf), "%04d\n", getpid());
	write(fd, buf, strlen(buf));
	close(fd);

	return 0;
}

flow_next (int flow)
{
	switch(flow) {
	case FC_NONE:
		flow = FC_RTSCTS;
		break;
	case FC_RTSCTS:
		flow = FC_XONXOFF;
		break;
	case FC_XONXOFF:
		flow = FC_NONE;
		break;
	default:
		flow = FC_NONE;
		break;
	}

	return flow;
}
