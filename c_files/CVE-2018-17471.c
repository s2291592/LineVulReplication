std::unique_ptr<WebContents> WebContentsImpl::GetCreatedWindow(
    int process_id,
    int main_frame_widget_route_id) {
  auto key = std::make_pair(process_id, main_frame_widget_route_id);
  auto iter = pending_contents_.find(key);

  if (iter == pending_contents_.end())
    return nullptr;

  std::unique_ptr<WebContents> new_contents = std::move(iter->second);
  pending_contents_.erase(key);
  WebContentsImpl* raw_new_contents =
      static_cast<WebContentsImpl*>(new_contents.get());
  RemoveDestructionObserver(raw_new_contents);

  if (BrowserPluginGuest::IsGuest(raw_new_contents))
    return new_contents;

  if (!new_contents->GetMainFrame()->GetProcess()->IsInitializedAndNotDead() ||
      !new_contents->GetMainFrame()->GetView()) {
    return nullptr;
  }

  return new_contents;
}

  explicit MockDidOpenRequestedURLObserver(Shell* shell)
      : WebContentsObserver(shell->web_contents()) {}

void WebContentsImpl::CreateNewWidget(int32_t render_process_id,
                                      int32_t route_id,
                                      mojom::WidgetPtr widget,
                                      blink::WebPopupType popup_type) {
  CreateNewWidget(render_process_id, route_id, false, std::move(widget),
                  popup_type);
}

  void Wait() {
    if (!found_value_)
      run_loop_.Run();
  }

  explicit LoadStateWaiter(content::WebContents* contents)
      : web_contents_(contents) {
    contents->SetDelegate(this);
  }

  bool LoadStateMatches(content::WebContents* contents) {
    DCHECK(contents == web_contents_);
    return waiting_host_ == contents->GetLoadStateHost() &&
           waiting_state_ == contents->GetLoadState().state;
  }

void WebContentsImpl::CreateNewFullscreenWidget(int32_t render_process_id,
                                                int32_t route_id,
                                                mojom::WidgetPtr widget) {
  CreateNewWidget(render_process_id, route_id, true, std::move(widget),
                  blink::kWebPopupTypeNone);
}

void DownloadImageTestInternal(Shell* shell,
                               const GURL& image_url,
                               int expected_http_status,
                               int expected_number_of_images) {
  using ::testing::_;
  using ::testing::InvokeWithoutArgs;
  using ::testing::SizeIs;

  DownloadImageObserver download_image_observer;
  scoped_refptr<MessageLoopRunner> loop_runner =
      new MessageLoopRunner();

  EXPECT_CALL(download_image_observer,
              OnFinishDownloadImage(_, expected_http_status, _,
                                    SizeIs(expected_number_of_images), _));
  ON_CALL(download_image_observer, OnFinishDownloadImage(_, _, _, _, _))
      .WillByDefault(
          InvokeWithoutArgs(loop_runner.get(), &MessageLoopRunner::Quit));

  shell->LoadURL(GURL("about:blank"));
  shell->web_contents()->DownloadImage(
      image_url, false, 1024, false,
      base::BindOnce(&DownloadImageObserver::OnFinishDownloadImage,
                     base::Unretained(&download_image_observer)));

  loop_runner->Run();
}

  void CheckResourceLoaded(
      const GURL& url,
      const GURL& referrer,
      const std::string& load_method,
      content::ResourceType resource_type,
      const base::FilePath::StringPieceType& served_file_name,
      const std::string& mime_type,
      const std::string& ip_address,
      bool was_cached,
      bool first_network_request,
      const base::TimeTicks& before_request,
      const base::TimeTicks& after_request) {
    bool resource_load_info_found = false;
    for (const auto& resource_load_info : resource_load_infos_) {
      if (resource_load_info->url != url)
        continue;

      resource_load_info_found = true;
      int64_t file_size = -1;
      if (!served_file_name.empty()) {
        base::ScopedAllowBlockingForTesting allow_blocking;
        base::FilePath test_dir;
        ASSERT_TRUE(base::PathService::Get(content::DIR_TEST_DATA, &test_dir));
        base::FilePath served_file = test_dir.Append(served_file_name);
        ASSERT_TRUE(GetFileSize(served_file, &file_size));
      }
      EXPECT_EQ(referrer, resource_load_info->referrer);
      EXPECT_EQ(load_method, resource_load_info->method);
      EXPECT_EQ(resource_type, resource_load_info->resource_type);
      if (!first_network_request)
        EXPECT_GT(resource_load_info->request_id, 0);
      EXPECT_EQ(mime_type, resource_load_info->mime_type);
      ASSERT_TRUE(resource_load_info->network_info->ip_port_pair);
      EXPECT_EQ(ip_address,
                resource_load_info->network_info->ip_port_pair->host());
      EXPECT_EQ(was_cached, resource_load_info->was_cached);
      auto CheckTime = [before_request, after_request](auto actual) {
        EXPECT_LE(before_request, actual);
        EXPECT_GT(after_request, actual);
      };
      const net::LoadTimingInfo& timing = resource_load_info->load_timing_info;
      CheckTime(timing.request_start);
      CheckTime(timing.receive_headers_end);
      CheckTime(timing.send_start);
      CheckTime(timing.send_end);
      if (!was_cached) {
        CheckTime(timing.connect_timing.dns_start);
        CheckTime(timing.connect_timing.dns_end);
        CheckTime(timing.connect_timing.connect_start);
        CheckTime(timing.connect_timing.connect_end);
      }
      if (file_size != -1) {
        EXPECT_EQ(file_size, resource_load_info->raw_body_bytes);
        EXPECT_LT(file_size, resource_load_info->total_received_bytes);
      }
    }
    EXPECT_TRUE(resource_load_info_found);
  }

  explicit LoadStopNotificationObserver(NavigationController* controller)
      : WindowedNotificationObserver(NOTIFICATION_LOAD_STOP,
                                     Source<NavigationController>(controller)),
        session_index_(-1),
        controller_(nullptr) {}

void WebContentsImpl::DidCallFocus() {
// Any explicit focusing of another window while this WebContents is in
// fullscreen can be used to confuse the user, so drop fullscreen.
  if (IsFullscreenForCurrentTab())
    ExitFullscreen(true);
}

  void Wait() {
    run_loop_->Run();
    run_loop_ = std::make_unique<base::RunLoop>();
  }

  explicit UpdateTargetURLWaiter(WebContents* web_contents) {
    web_contents->SetDelegate(this);
  }

void WebContentsImpl::ExitFullscreenMode(bool will_cause_resize) {
  RenderWidgetHostView* const widget_view = GetFullscreenRenderWidgetHostView();
  if (widget_view) {
    RenderWidgetHostImpl::From(widget_view->GetRenderWidgetHost())
        ->ShutdownAndDestroyWidget(true);
  }

  if (delegate_) {
    delegate_->ExitFullscreenModeForTab(this);

    if (keyboard_lock_widget_)
      delegate_->CancelKeyboardLockRequest(this);
  }

  if (!will_cause_resize) {
    if (RenderWidgetHostView* rwhv = GetRenderWidgetHostView()) {
        if (RenderWidgetHost* render_widget_host = rwhv->GetRenderWidgetHost())
          render_widget_host->SynchronizeVisualProperties();
    }
  }

  current_fullscreen_frame_tree_node_id_ = RenderFrameHost::kNoFrameTreeNodeId;

  for (auto& observer : observers_) {
    observer.DidToggleFullscreenModeForTab(IsFullscreenForCurrentTab(),
                                           will_cause_resize);
  }

  if (display_cutout_host_impl_)
    display_cutout_host_impl_->DidExitFullscreen();
}

  void WillWaitForNewContents() { waiting_for_ = kNewContents; }

bool WebContentsImpl::OnMessageReceived(RenderFrameHostImpl* render_frame_host,
                                        const IPC::Message& message) {
  {
    WebUIImpl* web_ui = render_frame_host->web_ui();
    if (web_ui && web_ui->OnMessageReceived(message, render_frame_host))
      return true;
  }

  for (auto& observer : observers_) {
    if (observer.OnMessageReceived(message, render_frame_host))
      return true;
  }

  bool handled = true;
  IPC_BEGIN_MESSAGE_MAP_WITH_PARAM(WebContentsImpl, message, render_frame_host)
    IPC_MESSAGE_HANDLER(FrameHostMsg_DomOperationResponse,
                        OnDomOperationResponse)
    IPC_MESSAGE_HANDLER(FrameHostMsg_DidChangeThemeColor,
                        OnThemeColorChanged)
    IPC_MESSAGE_HANDLER(FrameHostMsg_DidFinishDocumentLoad,
                        OnDocumentLoadedInFrame)
    IPC_MESSAGE_HANDLER(FrameHostMsg_DidFinishLoad, OnDidFinishLoad)
    IPC_MESSAGE_HANDLER(FrameHostMsg_DidLoadResourceFromMemoryCache,
                        OnDidLoadResourceFromMemoryCache)
    IPC_MESSAGE_HANDLER(FrameHostMsg_DidDisplayInsecureContent,
                        OnDidDisplayInsecureContent)
    IPC_MESSAGE_HANDLER(FrameHostMsg_DidContainInsecureFormAction,
                        OnDidContainInsecureFormAction)
    IPC_MESSAGE_HANDLER(FrameHostMsg_DidRunInsecureContent,
                        OnDidRunInsecureContent)
    IPC_MESSAGE_HANDLER(FrameHostMsg_DidDisplayContentWithCertificateErrors,
                        OnDidDisplayContentWithCertificateErrors)
    IPC_MESSAGE_HANDLER(FrameHostMsg_DidRunContentWithCertificateErrors,
                        OnDidRunContentWithCertificateErrors)
    IPC_MESSAGE_HANDLER(FrameHostMsg_RegisterProtocolHandler,
                        OnRegisterProtocolHandler)
    IPC_MESSAGE_HANDLER(FrameHostMsg_UnregisterProtocolHandler,
                        OnUnregisterProtocolHandler)
    IPC_MESSAGE_HANDLER(FrameHostMsg_UpdatePageImportanceSignals,
                        OnUpdatePageImportanceSignals)
    IPC_MESSAGE_HANDLER(FrameHostMsg_Find_Reply, OnFindReply)
    IPC_MESSAGE_HANDLER(FrameHostMsg_UpdateFaviconURL, OnUpdateFaviconURL)
#if BUILDFLAG(ENABLE_PLUGINS)
    IPC_MESSAGE_HANDLER(FrameHostMsg_PepperInstanceCreated,
                        OnPepperInstanceCreated)
    IPC_MESSAGE_HANDLER(FrameHostMsg_PepperInstanceDeleted,
                        OnPepperInstanceDeleted)
    IPC_MESSAGE_HANDLER(FrameHostMsg_PepperPluginHung, OnPepperPluginHung)
    IPC_MESSAGE_HANDLER(FrameHostMsg_PepperStartsPlayback,
                        OnPepperStartsPlayback)
    IPC_MESSAGE_HANDLER(FrameHostMsg_PepperStopsPlayback,
                        OnPepperStopsPlayback)
    IPC_MESSAGE_HANDLER(FrameHostMsg_PluginCrashed, OnPluginCrashed)
    IPC_MESSAGE_HANDLER_GENERIC(BrowserPluginHostMsg_Attach,
                                OnBrowserPluginMessage(render_frame_host,
                                                       message))
#endif
    IPC_MESSAGE_UNHANDLED(handled = false)
  IPC_END_MESSAGE_MAP()

  return handled;
}

  LoadFinishedWaiter(WebContents* web_contents, const GURL& expected_url)
      : WebContentsObserver(web_contents),
        expected_url_(expected_url),
        run_loop_(new base::RunLoop()) {
    EXPECT_TRUE(web_contents != nullptr);
  }

  void Wait() { run_loop_->Run(); }

void WebContentsImpl::CreateNewWindow(
RenderFrameHost* opener,
int32_t render_view_route_id,
int32_t main_frame_route_id,
int32_t main_frame_widget_route_id,
const mojom::CreateNewWindowParams& params,
SessionStorageNamespace* session_storage_namespace) {
// We should have zero valid routing ids, or three valid routing IDs.
DCHECK_EQ((render_view_route_id == MSG_ROUTING_NONE),
(main_frame_route_id == MSG_ROUTING_NONE));
DCHECK_EQ((render_view_route_id == MSG_ROUTING_NONE),
(main_frame_widget_route_id == MSG_ROUTING_NONE));
DCHECK(opener);

int render_process_id = opener->GetProcess()->GetID();
SiteInstance* source_site_instance = opener->GetSiteInstance();

// The route IDs passed into this function can be trusted not to already
// be in use; they were allocated by the RenderWidgetHelper by the caller.
DCHECK(!RenderFrameHostImpl::FromID(render_process_id, main_frame_route_id));

// We usually create the new window in the same BrowsingInstance (group of
// script-related windows), by passing in the current SiteInstance.  However,
// if the opener is being suppressed (in a non-guest), we create a new
// SiteInstance in its own BrowsingInstance.
bool is_guest = BrowserPluginGuest::IsGuest(this);

// If the opener is to be suppressed, the new window can be in any process.
// Since routing ids are process specific, we must not have one passed in
// as argument here.
DCHECK(!params.opener_suppressed || render_view_route_id == MSG_ROUTING_NONE);

scoped_refptr<SiteInstance> site_instance =
params.opener_suppressed && !is_guest
? SiteInstance::CreateForURL(GetBrowserContext(), params.target_url)
: source_site_instance;

// We must assign the SessionStorageNamespace before calling Init().
//
// http://crbug.com/142685
const std::string& partition_id =
GetContentClient()->browser()->
GetStoragePartitionIdForSite(GetBrowserContext(),
site_instance->GetSiteURL());
StoragePartition* partition = BrowserContext::GetStoragePartition(
GetBrowserContext(), site_instance.get());
DOMStorageContextWrapper* dom_storage_context =
static_cast<DOMStorageContextWrapper*>(partition->GetDOMStorageContext());
SessionStorageNamespaceImpl* session_storage_namespace_impl =
static_cast<SessionStorageNamespaceImpl*>(session_storage_namespace);
CHECK(session_storage_namespace_impl->IsFromContext(dom_storage_context));

if (delegate_ &&
!delegate_->ShouldCreateWebContents(
this, opener, source_site_instance, render_view_route_id,
main_frame_route_id, main_frame_widget_route_id,
params.window_container_type, opener->GetLastCommittedURL(),
params.frame_name, params.target_url, partition_id,
session_storage_namespace)) {
// Note: even though we're not creating a WebContents here, it could have
// been created by the embedder so ensure that the RenderFrameHost is
// properly initialized.
// It's safe to only target the frame because the render process will not
// have a chance to create more frames at this point.
RenderFrameHostImpl* rfh =
RenderFrameHostImpl::FromID(render_process_id, main_frame_route_id);
if (rfh) {
DCHECK(rfh->IsRenderFrameLive());
rfh->Init();
}
return;
}

// Create the new web contents. This will automatically create the new
// WebContentsView. In the future, we may want to create the view separately.
CreateParams create_params(GetBrowserContext(), site_instance.get());
create_params.routing_id = render_view_route_id;
create_params.main_frame_routing_id = main_frame_route_id;
create_params.main_frame_widget_routing_id = main_frame_widget_route_id;
create_params.main_frame_name = params.frame_name;
create_params.opener_render_process_id = render_process_id;
create_params.opener_render_frame_id = opener->GetRoutingID();
create_params.opener_suppressed = params.opener_suppressed;
if (params.disposition == WindowOpenDisposition::NEW_BACKGROUND_TAB)
create_params.initially_hidden = true;
create_params.renderer_initiated_creation =
main_frame_route_id != MSG_ROUTING_NONE;

std::unique_ptr<WebContents> new_contents;
if (!is_guest) {
create_params.context = view_->GetNativeView();
create_params.initial_size = GetContainerBounds().size();
new_contents = WebContents::Create(create_params);
}  else {
new_contents = base::WrapUnique(
GetBrowserPluginGuest()->CreateNewGuestWindow(create_params));
}
WebContentsImpl* raw_new_contents =
static_cast<WebContentsImpl*>(new_contents.get());
raw_new_contents->GetController().SetSessionStorageNamespace(
partition_id, session_storage_namespace);

// If the new frame has a name, make sure any SiteInstances that can find
// this named frame have proxies for it.  Must be called after
// SetSessionStorageNamespace, since this calls CreateRenderView, which uses
// GetSessionStorageNamespace.
if (!params.frame_name.empty())
raw_new_contents->GetRenderManager()->CreateProxiesForNewNamedFrame();

// Save the window for later if we're not suppressing the opener (since it
// will be shown immediately).
if (!params.opener_suppressed) {
if (!is_guest) {
WebContentsView* new_view = raw_new_contents->view_.get();

// TODO(brettw): It seems bogus that we have to call this function on the
// newly created object and give it one of its own member variables.
new_view->CreateViewForWidget(
new_contents->GetRenderViewHost()->GetWidget(), false);
}
// Save the created window associated with the route so we can show it
// later.
//
// TODO(ajwong): This should be keyed off the RenderFrame routing id or the
// FrameTreeNode id instead of the routing id of the Widget for the main
// frame.  https://crbug.com/545684
DCHECK_NE(MSG_ROUTING_NONE, main_frame_widget_route_id);
pending_contents_[std::make_pair(render_process_id,
main_frame_widget_route_id)] =
std::move(new_contents);
AddDestructionObserver(raw_new_contents);
}

if (delegate_) {
delegate_->WebContentsCreated(this, render_process_id,
opener->GetRoutingID(), params.frame_name,
params.target_url, raw_new_contents);
}

if (opener) {
for (auto& observer : observers_) {
observer.DidOpenRequestedURL(raw_new_contents, opener, params.target_url,
params.referrer, params.disposition,
ui::PAGE_TRANSITION_LINK,
false,  // started_from_context_menu
true);  // renderer_initiated
}
}

// Any new WebContents opened while this WebContents is in fullscreen can be
// used to confuse the user, so drop fullscreen.
  if (IsFullscreenForCurrentTab())
    ExitFullscreen(true);

if (params.opener_suppressed) {
// When the opener is suppressed, the original renderer cannot access the
// new window.  As a result, we need to show and navigate the window here.
bool was_blocked = false;

base::WeakPtr<WebContentsImpl> weak_new_contents =
raw_new_contents->weak_factory_.GetWeakPtr();
if (delegate_) {
gfx::Rect initial_rect;

delegate_->AddNewContents(this, std::move(new_contents),
params.disposition, initial_rect,
params.mimic_user_gesture, &was_blocked);
if (!weak_new_contents)
return;  // The delegate deleted |new_contents| during AddNewContents().
}

if (!was_blocked) {
OpenURLParams open_params(params.target_url, params.referrer,
WindowOpenDisposition::CURRENT_TAB,
ui::PAGE_TRANSITION_LINK,
true /* is_renderer_initiated */);
open_params.user_gesture = params.mimic_user_gesture;

if (delegate_ && !is_guest &&
!delegate_->ShouldResumeRequestsForCreatedWindow()) {
DCHECK(weak_new_contents);
// We are in asynchronous add new contents path, delay opening url
weak_new_contents->delayed_open_url_params_.reset(
new OpenURLParams(open_params));
} else {
weak_new_contents->OpenURL(open_params);
}
}
}
}

void WebContentsImpl::CreateNewWidget(int32_t render_process_id,
                                      int32_t route_id,
                                      bool is_fullscreen,
                                      mojom::WidgetPtr widget,
                                      blink::WebPopupType popup_type) {
  RenderProcessHost* process = RenderProcessHost::FromID(render_process_id);
  if (!HasMatchingProcess(&frame_tree_, render_process_id)) {
    ReceivedBadMessage(process, bad_message::WCI_NEW_WIDGET_PROCESS_MISMATCH);
    return;
  }

  RenderWidgetHostImpl* widget_host = new RenderWidgetHostImpl(
      this, process, route_id, std::move(widget), IsHidden());

  RenderWidgetHostViewBase* widget_view =
      static_cast<RenderWidgetHostViewBase*>(
          view_->CreateViewForPopupWidget(widget_host));
  if (!widget_view)
    return;
  if (!is_fullscreen) {
    widget_view->SetPopupType(popup_type);
  }
  pending_widget_views_[std::make_pair(render_process_id, route_id)] =
      widget_view;
}

  const std::vector<GURL>& memory_cached_loaded_urls() const {
    return memory_cached_loaded_urls_;
  }

void WebContentsImpl::SetHasPictureInPictureVideo(
    bool has_picture_in_picture_video) {
  if (has_picture_in_picture_video == has_picture_in_picture_video_)
    return;
  has_picture_in_picture_video_ = has_picture_in_picture_video;
  NotifyNavigationStateChanged(INVALIDATE_TYPE_TAB);
}

void WebContentsImpl::EnsureOpenerProxiesExist(RenderFrameHost* source_rfh) {
  WebContentsImpl* source_web_contents = static_cast<WebContentsImpl*>(
      WebContents::FromRenderFrameHost(source_rfh));

  if (source_web_contents) {
    if (GetBrowserPluginEmbedder() &&
        GuestMode::IsCrossProcessFrameGuest(source_web_contents)) {
      return;
    }

    if (this != source_web_contents && GetBrowserPluginGuest()) {
      source_web_contents->GetRenderManager()->CreateRenderFrameProxy(
          GetSiteInstance());
    } else {
      RenderFrameHostImpl* source_rfhi =
          static_cast<RenderFrameHostImpl*>(source_rfh);
      source_rfhi->frame_tree_node()->render_manager()->CreateOpenerProxies(
          GetSiteInstance(), nullptr);
    }
   }
 }

  const GURL& WaitForUpdatedTargetURL() {
    if (updated_target_url_.has_value())
      return updated_target_url_.value();

    runner_ = new MessageLoopRunner();
    runner_->Run();
    return updated_target_url_.value();
  }

  explicit LoadProgressDelegateAndObserver(Shell* shell)
      : WebContentsObserver(shell->web_contents()),
        did_start_loading(false),
        did_stop_loading(false) {
    web_contents()->SetDelegate(this);
  }

  void Wait(net::LoadState load_state, const base::string16& host) {
    waiting_host_ = host;
    waiting_state_ = load_state;
    if (!LoadStateMatches(web_contents_)) {
      base::RunLoop run_loop;
      quit_closure_ = run_loop.QuitClosure();
      run_loop.Run();
      DCHECK(LoadStateMatches(web_contents_));
    }
  }

  void WillWaitForDialog() { waiting_for_ = kDialog; }

void WebContentsImpl::DispatchBeforeUnload() {
  GetMainFrame()->DispatchBeforeUnload(
      RenderFrameHostImpl::BeforeUnloadType::TAB_CLOSE, false);
}

 RenderFrameHost* WebContentsImpl::GetFocusedFrameIncludingInnerWebContents() {
  WebContentsImpl* contents = this;
  FrameTreeNode* focused_node = contents->frame_tree_.GetFocusedFrame();

  if (!focused_node)
    return nullptr;

  while (true) {
    contents = contents->node_.GetInnerWebContentsInFrame(focused_node);
    if (!contents)
      return focused_node->current_frame_host();

    focused_node = contents->frame_tree_.GetFocusedFrame();
    if (!focused_node)
      return contents->GetMainFrame();
  }
}

  FullscreenWebContentsObserver(WebContents* web_contents,
                                RenderFrameHost* wanted_rfh)
      : WebContentsObserver(web_contents), wanted_rfh_(wanted_rfh) {}

void WebContentsImpl::FullscreenStateChanged(RenderFrameHost* rfh,
                                             bool is_fullscreen) {
  int frame_tree_node_id = rfh->GetFrameTreeNodeId();
  auto it = fullscreen_frame_tree_nodes_.find(frame_tree_node_id);
  bool changed = false;

  if (is_fullscreen) {
    if (it == fullscreen_frame_tree_nodes_.end()) {
      fullscreen_frame_tree_nodes_.insert(frame_tree_node_id);
      changed = true;
    }
  } else {
    FrameTreeNode* ancestor =
        static_cast<RenderFrameHostImpl*>(rfh)->frame_tree_node();
    DCHECK(ancestor);

    for (it = fullscreen_frame_tree_nodes_.begin();
         it != fullscreen_frame_tree_nodes_.end();) {
      FrameTreeNode* node = FrameTreeNode::GloballyFindByID(*it);

      if (!node || frame_tree_node_id == *it ||
          node->IsDescendantOf(ancestor)) {
        it = fullscreen_frame_tree_nodes_.erase(it);
        changed = true;
      } else {
        ++it;
      }
    }
  }

  if (changed && fullscreen_frame_tree_nodes_.size() > 0) {
    unsigned int max_depth = 0;
    RenderFrameHost* max_depth_rfh = nullptr;

    for (auto node_id : fullscreen_frame_tree_nodes_) {
      FrameTreeNode* fullscreen_node = FrameTreeNode::GloballyFindByID(node_id);
      DCHECK(fullscreen_node);

      if (max_depth_rfh == nullptr || fullscreen_node->depth() > max_depth) {
        max_depth = fullscreen_node->depth();
        max_depth_rfh = fullscreen_node->current_frame_host();
      }
    }

    DCHECK(max_depth_rfh);
    if (max_depth_rfh->GetFrameTreeNodeId() ==
        current_fullscreen_frame_tree_node_id_)
      return;

    current_fullscreen_frame_tree_node_id_ =
        max_depth_rfh->GetFrameTreeNodeId();

    for (auto& observer : observers_)
      observer.DidAcquireFullscreen(max_depth_rfh);

    if (display_cutout_host_impl_)
      display_cutout_host_impl_->DidAcquireFullscreen(max_depth_rfh);
  } else if (fullscreen_frame_tree_nodes_.size() == 0) {
    current_fullscreen_frame_tree_node_id_ =
        RenderFrameHost::kNoFrameTreeNodeId;
  }
}
