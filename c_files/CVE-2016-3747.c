OMX_ERRORTYPE  omx_video::allocate_output_buffer(
        OMX_IN OMX_HANDLETYPE            hComp,
        OMX_INOUT OMX_BUFFERHEADERTYPE** bufferHdr,
        OMX_IN OMX_U32                   port,
        OMX_IN OMX_PTR                   appData,
        OMX_IN OMX_U32                   bytes)
{
 (void)hComp, (void)port;
    OMX_ERRORTYPE eRet = OMX_ErrorNone;
    OMX_BUFFERHEADERTYPE       *bufHdr= NULL; // buffer header
 unsigned                         i= 0; // Temporary counter
#ifdef _MSM8974_
 int align_size;
#endif
    DEBUG_PRINT_HIGH("allocate_output_buffer()for %u bytes", (unsigned int)bytes);
 if (!m_out_mem_ptr) {
 int nBufHdrSize        = 0;
        DEBUG_PRINT_HIGH("%s: size = %u, actual cnt %u", __FUNCTION__,
 (unsigned int)m_sOutPortDef.nBufferSize, (unsigned int)m_sOutPortDef.nBufferCountActual);
        nBufHdrSize        = m_sOutPortDef.nBufferCountActual * sizeof(OMX_BUFFERHEADERTYPE);

 /*
         * Memory for output side involves the following:
         * 1. Array of Buffer Headers
         * 2. Bitmask array to hold the buffer allocation details
         * In order to minimize the memory management entire allocation
         * is done in one step.
         */
        m_out_mem_ptr = (OMX_BUFFERHEADERTYPE  *)calloc(nBufHdrSize,1);

#ifdef USE_ION
        m_pOutput_ion = (struct venc_ion *) calloc(sizeof (struct venc_ion), m_sOutPortDef.nBufferCountActual);
 if (m_pOutput_ion == NULL) {
            DEBUG_PRINT_ERROR("ERROR: calloc() Failed for m_pOutput_ion");
 return OMX_ErrorInsufficientResources;
 }
#endif
        m_pOutput_pmem = (struct pmem *) calloc(sizeof(struct pmem), m_sOutPortDef.nBufferCountActual);
 if (m_pOutput_pmem == NULL) {
            DEBUG_PRINT_ERROR("ERROR: calloc() Failed for m_pOutput_pmem");
 return OMX_ErrorInsufficientResources;
 }
 if (m_out_mem_ptr && m_pOutput_pmem) {
            bufHdr          =  m_out_mem_ptr;

 for (i=0; i < m_sOutPortDef.nBufferCountActual ; i++) {
                bufHdr->nSize              = sizeof(OMX_BUFFERHEADERTYPE);
                bufHdr->nVersion.nVersion  = OMX_SPEC_VERSION;
                bufHdr->nAllocLen          = bytes;
                bufHdr->nFilledLen         = 0;
                bufHdr->pAppPrivate        = appData;
                bufHdr->nOutputPortIndex   = PORT_INDEX_OUT;
                bufHdr->pOutputPortPrivate = (OMX_PTR)&m_pOutput_pmem[i];
                bufHdr->pBuffer            = NULL;
                bufHdr++;
                m_pOutput_pmem[i].fd = -1;
#ifdef USE_ION
                m_pOutput_ion[i].ion_device_fd =-1;
                m_pOutput_ion[i].fd_ion_data.fd=-1;
                m_pOutput_ion[i].ion_alloc_data.handle = 0;
#endif
 }
 } else {
            DEBUG_PRINT_ERROR("ERROR: calloc() failed for m_out_mem_ptr/m_pOutput_pmem");
            eRet = OMX_ErrorInsufficientResources;
 }
 }

    DEBUG_PRINT_HIGH("actual cnt = %u", (unsigned int)m_sOutPortDef.nBufferCountActual);
 for (i=0; i< m_sOutPortDef.nBufferCountActual; i++) {
 if (BITMASK_ABSENT(&m_out_bm_count,i)) {
            DEBUG_PRINT_LOW("Found a Free Output Buffer %d",i);
 break;
 }
 }
 if (eRet == OMX_ErrorNone) {
 if (i < m_sOutPortDef.nBufferCountActual) {
#ifdef USE_ION
#ifdef _MSM8974_
            align_size = ((m_sOutPortDef.nBufferSize + 4095)/4096) * 4096;
            m_pOutput_ion[i].ion_device_fd = alloc_map_ion_memory(align_size,
 &m_pOutput_ion[i].ion_alloc_data,
 &m_pOutput_ion[i].fd_ion_data, ION_FLAG_CACHED);
#else
            m_pOutput_ion[i].ion_device_fd = alloc_map_ion_memory(m_sOutPortDef.nBufferSize,
 &m_pOutput_ion[i].ion_alloc_data,
 &m_pOutput_ion[i].fd_ion_data,ION_FLAG_CACHED);
#endif
 if (m_pOutput_ion[i].ion_device_fd < 0) {
                DEBUG_PRINT_ERROR("ERROR:ION device open() Failed");
 return OMX_ErrorInsufficientResources;
 }

            m_pOutput_pmem[i].fd = m_pOutput_ion[i].fd_ion_data.fd;
#else
            m_pOutput_pmem[i].fd = open (MEM_DEVICE,O_RDWR);
 if (m_pOutput_pmem[i].fd == 0) {
                m_pOutput_pmem[i].fd = open (MEM_DEVICE,O_RDWR);
 }

 if (m_pOutput_pmem[i].fd < 0) {
                DEBUG_PRINT_ERROR("ERROR: /dev/pmem_adsp open() failed");
 return OMX_ErrorInsufficientResources;
 }
#endif
            m_pOutput_pmem[i].size = m_sOutPortDef.nBufferSize;
            m_pOutput_pmem[i].offset = 0;

            m_pOutput_pmem[i].buffer = (OMX_U8 *)SECURE_BUFPTR;
 if(!secure_session) {
#ifdef _MSM8974_
                m_pOutput_pmem[i].buffer = (unsigned char *)mmap(NULL,
                    align_size,PROT_READ|PROT_WRITE,
                    MAP_SHARED,m_pOutput_pmem[i].fd,0);
#else
                m_pOutput_pmem[i].buffer = (unsigned char *)mmap(NULL,
                    m_pOutput_pmem[i].size,PROT_READ|PROT_WRITE,
                    MAP_SHARED,m_pOutput_pmem[i].fd,0);
#endif
 if (m_pOutput_pmem[i].buffer == MAP_FAILED) {
                    DEBUG_PRINT_ERROR("ERROR: MMAP_FAILED in o/p alloc buffer");
                close (m_pOutput_pmem[i].fd);
#ifdef USE_ION
                free_ion_memory(&m_pOutput_ion[i]);
#endif
 return OMX_ErrorInsufficientResources;
 }
 }
 else {
                m_pOutput_pmem[i].buffer = malloc(sizeof(OMX_U32) + sizeof(native_handle_t*));
 native_handle_t *handle = native_handle_create(1, 0);
                handle->data[0] = m_pOutput_pmem[i].fd;
 char *data = (char*) m_pOutput_pmem[i].buffer;
                OMX_U32 type = 1;
                memcpy(data, &type, sizeof(OMX_U32));
                memcpy(data + sizeof(OMX_U32), &handle, sizeof(native_handle_t*));
 }

 *bufferHdr = (m_out_mem_ptr + i );
 (*bufferHdr)->pBuffer = (OMX_U8 *)m_pOutput_pmem[i].buffer;
 (*bufferHdr)->pAppPrivate = appData;

            BITMASK_SET(&m_out_bm_count,i);

 if (dev_use_buf(&m_pOutput_pmem[i],PORT_INDEX_OUT,i) != true) {
                DEBUG_PRINT_ERROR("ERROR: dev_use_buf FAILED for o/p buf");
 return OMX_ErrorInsufficientResources;
 }
 } else {
            DEBUG_PRINT_ERROR("ERROR: All o/p buffers are allocated, invalid allocate buf call"
 "for index [%d] actual: %u", i, (unsigned int)m_sOutPortDef.nBufferCountActual);
 }
 }

 return eRet;
}

OMX_ERRORTYPE omx_video::free_input_buffer(OMX_BUFFERHEADERTYPE *bufferHdr)
{
unsigned int index = 0;
OMX_U8 *temp_buff ;

if (bufferHdr == NULL || m_inp_mem_ptr == NULL) {
DEBUG_PRINT_ERROR("ERROR: free_input: Invalid bufferHdr[%p] or m_inp_mem_ptr[%p]",
bufferHdr, m_inp_mem_ptr);
return OMX_ErrorBadParameter;
}

index = bufferHdr - ((!meta_mode_enable)?m_inp_mem_ptr:meta_buffer_hdr);
#ifdef _ANDROID_ICS_
if (meta_mode_enable) {
if (index < m_sInPortDef.nBufferCountActual) {
memset(&meta_buffer_hdr[index], 0, sizeof(meta_buffer_hdr[index]));
memset(&meta_buffers[index], 0, sizeof(meta_buffers[index]));
}
if (!mUseProxyColorFormat)
return OMX_ErrorNone;
else {
c2d_conv.close();
opaque_buffer_hdr[index] = NULL;
}
}
#endif
if (index < m_sInPortDef.nBufferCountActual && !mUseProxyColorFormat &&
dev_free_buf(&m_pInput_pmem[index],PORT_INDEX_IN) != true) {
DEBUG_PRINT_LOW("ERROR: dev_free_buf() Failed for i/p buf");

}

if (index < m_sInPortDef.nBufferCountActual && m_pInput_pmem) {
if (m_pInput_pmem[index].fd > 0 && input_use_buffer == false) {
DEBUG_PRINT_LOW("FreeBuffer:: i/p AllocateBuffer case");
if(!secure_session) {
munmap (m_pInput_pmem[index].buffer,m_pInput_pmem[index].size);

} else {
free(m_pInput_pmem[index].buffer);
}
close (m_pInput_pmem[index].fd);
#ifdef USE_ION
free_ion_memory(&m_pInput_ion[index]);
#endif
m_pInput_pmem[index].fd = -1;
} else if (m_pInput_pmem[index].fd > 0 && (input_use_buffer == true &&
m_use_input_pmem == OMX_FALSE)) {
DEBUG_PRINT_LOW("FreeBuffer:: i/p Heap UseBuffer case");
if (dev_free_buf(&m_pInput_pmem[index],PORT_INDEX_IN) != true) {

DEBUG_PRINT_ERROR("ERROR: dev_free_buf() Failed for i/p buf");
}
if(!secure_session) {
            munmap (m_pInput_pmem[index].buffer,m_pInput_pmem[index].size);
}
close (m_pInput_pmem[index].fd);
#ifdef USE_ION
free_ion_memory(&m_pInput_ion[index]);
#endif
m_pInput_pmem[index].fd = -1;
} else {
DEBUG_PRINT_ERROR("FreeBuffer:: fd is invalid or i/p PMEM UseBuffer case");
}
}
return OMX_ErrorNone;
}

OMX_ERRORTYPE  omx_video::empty_this_buffer_proxy(OMX_IN OMX_HANDLETYPE  hComp,
OMX_IN OMX_BUFFERHEADERTYPE* buffer)
{
(void)hComp;
OMX_U8 *pmem_data_buf = NULL;
int push_cnt = 0;
unsigned nBufIndex = 0;
OMX_ERRORTYPE ret = OMX_ErrorNone;
encoder_media_buffer_type *media_buffer = NULL;

#ifdef _MSM8974_
int fd = 0;
#endif
DEBUG_PRINT_LOW("ETBProxy: buffer->pBuffer[%p]", buffer->pBuffer);
if (buffer == NULL) {
DEBUG_PRINT_ERROR("ERROR: ETBProxy: Invalid buffer[%p]", buffer);
return OMX_ErrorBadParameter;
}

// Buffer sanity checks
if (meta_mode_enable && !mUsesColorConversion) {
//For color-conversion case, we have an internal buffer and not a meta buffer
bool met_error = false;
nBufIndex = buffer - meta_buffer_hdr;
if (nBufIndex >= m_sInPortDef.nBufferCountActual) {
DEBUG_PRINT_ERROR("ERROR: ETBProxy: Invalid meta-bufIndex = %u", nBufIndex);
return OMX_ErrorBadParameter;
}
media_buffer = (encoder_media_buffer_type *)meta_buffer_hdr[nBufIndex].pBuffer;
if (media_buffer) {
if (media_buffer->buffer_type != kMetadataBufferTypeCameraSource &&
media_buffer->buffer_type != kMetadataBufferTypeGrallocSource) {
met_error = true;
} else {
if (media_buffer->buffer_type == kMetadataBufferTypeCameraSource) {
if (media_buffer->meta_handle == NULL)
met_error = true;
else if ((media_buffer->meta_handle->numFds != 1 &&
media_buffer->meta_handle->numInts != 2))
met_error = true;
}
}
} else
met_error = true;
if (met_error) {
DEBUG_PRINT_ERROR("ERROR: Unkown source/metahandle in ETB call");
post_event ((unsigned long)buffer,0,OMX_COMPONENT_GENERATE_EBD);
return OMX_ErrorBadParameter;
}
} else {
nBufIndex = buffer - ((OMX_BUFFERHEADERTYPE *)m_inp_mem_ptr);
if (nBufIndex >= m_sInPortDef.nBufferCountActual) {
DEBUG_PRINT_ERROR("ERROR: ETBProxy: Invalid bufIndex = %u", nBufIndex);
return OMX_ErrorBadParameter;
}
}

pending_input_buffers++;
if (input_flush_progress == true) {
post_event ((unsigned long)buffer,0,
OMX_COMPONENT_GENERATE_EBD);
DEBUG_PRINT_ERROR("ERROR: ETBProxy: Input flush in progress");
return OMX_ErrorNone;
}
#ifdef _MSM8974_
if (!meta_mode_enable) {
fd = m_pInput_pmem[nBufIndex].fd;
}
#endif
#ifdef _ANDROID_ICS_
if (meta_mode_enable && !mUseProxyColorFormat) {
// Camera or Gralloc-source meta-buffers queued with pre-announced color-format
struct pmem Input_pmem_info;
if (!media_buffer) {
DEBUG_PRINT_ERROR("%s: invalid media_buffer",__FUNCTION__);
return OMX_ErrorBadParameter;
}
if (media_buffer->buffer_type == kMetadataBufferTypeCameraSource) {
Input_pmem_info.buffer = media_buffer;
Input_pmem_info.fd = media_buffer->meta_handle->data[0];
#ifdef _MSM8974_
fd = Input_pmem_info.fd;
#endif
Input_pmem_info.offset = media_buffer->meta_handle->data[1];
Input_pmem_info.size = media_buffer->meta_handle->data[2];
DEBUG_PRINT_LOW("ETB (meta-Camera) fd = %d, offset = %d, size = %d",
Input_pmem_info.fd, Input_pmem_info.offset,
Input_pmem_info.size);
} else {
private_handle_t *handle = (private_handle_t *)media_buffer->meta_handle;
Input_pmem_info.buffer = media_buffer;
Input_pmem_info.fd = handle->fd;
#ifdef _MSM8974_
fd = Input_pmem_info.fd;
#endif
Input_pmem_info.offset = 0;
Input_pmem_info.size = handle->size;
DEBUG_PRINT_LOW("ETB (meta-gralloc) fd = %d, offset = %d, size = %d",
Input_pmem_info.fd, Input_pmem_info.offset,
Input_pmem_info.size);
}
if (dev_use_buf(&Input_pmem_info,PORT_INDEX_IN,0) != true) {
DEBUG_PRINT_ERROR("ERROR: in dev_use_buf");
post_event ((unsigned long)buffer,0,OMX_COMPONENT_GENERATE_EBD);
return OMX_ErrorBadParameter;
}
} else if (meta_mode_enable && !mUsesColorConversion) {
// Graphic-source meta-buffers queued with opaque color-format
if (media_buffer->buffer_type == kMetadataBufferTypeGrallocSource) {
private_handle_t *handle = (private_handle_t *)media_buffer->meta_handle;
fd = handle->fd;
DEBUG_PRINT_LOW("ETB (opaque-gralloc) fd = %d, size = %d",
fd, handle->size);
} else {
DEBUG_PRINT_ERROR("ERROR: Invalid bufferType for buffer with Opaque"
" color format");
post_event ((unsigned long)buffer,0,OMX_COMPONENT_GENERATE_EBD);
return OMX_ErrorBadParameter;
}
} else if (input_use_buffer && !m_use_input_pmem)
#else
if (input_use_buffer && !m_use_input_pmem)

#endif
{
DEBUG_PRINT_LOW("Heap UseBuffer case, so memcpy the data");
pmem_data_buf = (OMX_U8 *)m_pInput_pmem[nBufIndex].buffer;
        memcpy (pmem_data_buf, (buffer->pBuffer + buffer->nOffset),
                buffer->nFilledLen);
DEBUG_PRINT_LOW("memcpy() done in ETBProxy for i/p Heap UseBuf");
} else if (mUseProxyColorFormat) {
// Gralloc-source buffers with color-conversion
fd = m_pInput_pmem[nBufIndex].fd;
DEBUG_PRINT_LOW("ETB (color-converted) fd = %d, size = %u",
fd, (unsigned int)buffer->nFilledLen);
} else if (m_sInPortDef.format.video.eColorFormat ==
OMX_COLOR_FormatYUV420SemiPlanar) {
//For the case where YUV420SP buffers are qeueued to component
//by sources other than camera (Apps via MediaCodec), conversion
//to vendor flavoured NV12 color format is required.
if (!dev_color_align(buffer, m_sInPortDef.format.video.nFrameWidth,
m_sInPortDef.format.video.nFrameHeight)) {
DEBUG_PRINT_ERROR("Failed to adjust buffer color");
post_event((unsigned long)buffer, 0, OMX_COMPONENT_GENERATE_EBD);
return OMX_ErrorUndefined;
}
}
#ifdef _MSM8974_
if (dev_empty_buf(buffer, pmem_data_buf,nBufIndex,fd) != true)
#else
if (dev_empty_buf(buffer, pmem_data_buf,0,0) != true)
#endif
{
DEBUG_PRINT_ERROR("ERROR: ETBProxy: dev_empty_buf failed");
#ifdef _ANDROID_ICS_
omx_release_meta_buffer(buffer);
#endif
post_event ((unsigned long)buffer,0,OMX_COMPONENT_GENERATE_EBD);
/*Generate an async error and move to invalid state*/
pending_input_buffers--;
if (hw_overload) {
return OMX_ErrorInsufficientResources;
}
return OMX_ErrorBadParameter;
}
return ret;
}

OMX_ERRORTYPE  omx_video::fill_this_buffer(OMX_IN OMX_HANDLETYPE  hComp,

OMX_IN OMX_BUFFERHEADERTYPE* buffer)
{
DEBUG_PRINT_LOW("FTB: buffer->pBuffer[%p]", buffer->pBuffer);
    if (m_state == OMX_StateInvalid) {
DEBUG_PRINT_ERROR("ERROR: FTB in Invalid State");
return OMX_ErrorInvalidState;
}

if (buffer == NULL ||(buffer->nSize != sizeof(OMX_BUFFERHEADERTYPE))) {
DEBUG_PRINT_ERROR("ERROR: omx_video::ftb-->Invalid buffer or size");
return OMX_ErrorBadParameter;
}

if (buffer->nVersion.nVersion != OMX_SPEC_VERSION) {
DEBUG_PRINT_ERROR("ERROR: omx_video::ftb-->OMX Version Invalid");
return OMX_ErrorVersionMismatch;
}

if (buffer->nOutputPortIndex != (OMX_U32)PORT_INDEX_OUT) {
DEBUG_PRINT_ERROR("ERROR: omx_video::ftb-->Bad port index");
return OMX_ErrorBadPortIndex;
}

if (!m_sOutPortDef.bEnabled) {
DEBUG_PRINT_ERROR("ERROR: omx_video::ftb-->port is disabled");
return OMX_ErrorIncorrectStateOperation;
}

post_event((unsigned long) hComp, (unsigned long)buffer,OMX_COMPONENT_GENERATE_FTB);
return OMX_ErrorNone;
}

OMX_ERRORTYPE  omx_video::empty_this_buffer(OMX_IN OMX_HANDLETYPE         hComp,
OMX_IN OMX_BUFFERHEADERTYPE* buffer)
{
OMX_ERRORTYPE ret1 = OMX_ErrorNone;

unsigned int nBufferIndex ;

DEBUG_PRINT_LOW("ETB: buffer = %p, buffer->pBuffer[%p]", buffer, buffer->pBuffer);
    if (m_state == OMX_StateInvalid) {
DEBUG_PRINT_ERROR("ERROR: Empty this buffer in Invalid State");
return OMX_ErrorInvalidState;
}

if (buffer == NULL || (buffer->nSize != sizeof(OMX_BUFFERHEADERTYPE))) {
DEBUG_PRINT_ERROR("ERROR: omx_video::etb--> buffer is null or buffer size is invalid");
return OMX_ErrorBadParameter;
}

if (buffer->nVersion.nVersion != OMX_SPEC_VERSION) {
DEBUG_PRINT_ERROR("ERROR: omx_video::etb--> OMX Version Invalid");
return OMX_ErrorVersionMismatch;
}

if (buffer->nInputPortIndex != (OMX_U32)PORT_INDEX_IN) {
DEBUG_PRINT_ERROR("ERROR: Bad port index to call empty_this_buffer");
return OMX_ErrorBadPortIndex;
}
if (!m_sInPortDef.bEnabled) {
DEBUG_PRINT_ERROR("ERROR: Cannot call empty_this_buffer while I/P port is disabled");
return OMX_ErrorIncorrectStateOperation;
}

nBufferIndex = buffer - ((!meta_mode_enable)?m_inp_mem_ptr:meta_buffer_hdr);

if (nBufferIndex > m_sInPortDef.nBufferCountActual ) {
DEBUG_PRINT_ERROR("ERROR: ETB: Invalid buffer index[%d]", nBufferIndex);
return OMX_ErrorBadParameter;
}

m_etb_count++;
DEBUG_PRINT_LOW("DBG: i/p nTimestamp = %u", (unsigned)buffer->nTimeStamp);
post_event ((unsigned long)hComp,(unsigned long)buffer,m_input_msg_id);
return OMX_ErrorNone;
}
