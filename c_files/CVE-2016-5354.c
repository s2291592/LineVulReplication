dissect_usb_video_endpoint_descriptor(proto_tree *parent_tree, tvbuff_t *tvb,
                                      guint8 descriptor_len)
{
    proto_tree *tree   = NULL;
    int         offset = 0;
    guint8      subtype;

    subtype = tvb_get_guint8(tvb, offset+2);

    if (parent_tree)
    {
        const gchar* subtype_str;

        subtype_str = val_to_str(subtype, vc_ep_descriptor_subtypes, "Unknown (0x%x)");
        tree = proto_tree_add_subtree_format(parent_tree, tvb, offset, descriptor_len,
                ett_descriptor_video_endpoint, NULL, "VIDEO CONTROL ENDPOINT DESCRIPTOR [%s]",
                subtype_str);
    }

    dissect_usb_descriptor_header(tree, tvb, offset, &vid_descriptor_type_vals_ext);
    proto_tree_add_item(tree, hf_usb_vid_epdesc_subtype, tvb, offset+2, 1, ENC_LITTLE_ENDIAN);
    offset += 3;

    if (subtype == EP_INTERRUPT)
    {
        proto_tree_add_item(tree, hf_usb_vid_epdesc_max_transfer_sz, tvb, offset, 2, ENC_LITTLE_ENDIAN);
        offset += 2;
    }

    /* Soak up descriptor bytes beyond those we know how to dissect */
    if (offset < descriptor_len)
        proto_tree_add_item(tree, hf_usb_vid_descriptor_data, tvb, offset, descriptor_len-offset, ENC_NA);

    return descriptor_len;
}

dissect_u3v_register(guint64 addr, proto_tree *branch, tvbuff_t *tvb, gint offset, gint length, u3v_conv_info_t * u3v_conv_info)
{
    gint isABRM = FALSE, isSBRM = FALSE, isSIRM = FALSE,isEIRM = FALSE;
    /* check if this is the access to one of the base address registers */
    if ( addr < 0x10000 ) {
        isABRM = TRUE;
        switch (addr) {
        case U3V_ABRM_GENCP_VERSION:
            proto_tree_add_item(branch, hf_u3v_bootstrap_GenCP_Version, tvb, offset, 4, ENC_LITTLE_ENDIAN);
            break;
        case U3V_ABRM_MANUFACTURER_NAME:
            if ( length <= 64 ) {
                proto_tree_add_item(branch, hf_u3v_bootstrap_Manufacturer_Name, tvb, offset, length, ENC_ASCII|ENC_NA);
            }
            break;
        case U3V_ABRM_MODEL_NAME:
            if ( length <= 64 ) {
                proto_tree_add_item(branch, hf_u3v_bootstrap_Model_Name, tvb, offset, length, ENC_ASCII|ENC_NA);
            }
            break;
        case U3V_ABRM_FAMILY_NAME:
            if ( length <= 64 ) {
                proto_tree_add_item(branch, hf_u3v_bootstrap_Family_Name, tvb, offset, length, ENC_ASCII|ENC_NA);
            }
            break;
        case U3V_ABRM_DEVICE_VERSION:
            if ( length <= 64 ) {
                proto_tree_add_item(branch, hf_u3v_bootstrap_Device_Version, tvb, offset, length, ENC_ASCII|ENC_NA);
            }
            break;
        case U3V_ABRM_MANUFACTURER_INFO:
            if ( length <= 64 ) {
                proto_tree_add_item(branch, hf_u3v_bootstrap_Manufacturer_Info, tvb, offset, length, ENC_ASCII|ENC_NA);
            }
            break;
        case U3V_ABRM_SERIAL_NUMBER:
            if ( length <= 64 ) {
                proto_tree_add_item(branch, hf_u3v_bootstrap_Serial_Number, tvb, offset, length, ENC_ASCII|ENC_NA);
            }
            break;
        case U3V_ABRM_USER_DEFINED_NAME:
            if ( length <= 64 ) {
                proto_tree_add_item(branch, hf_u3v_bootstrap_User_Defined_Name, tvb, offset, length, ENC_ASCII|ENC_NA);
            }
            break;
        case U3V_ABRM_DEVICE_CAPABILITY:
            proto_tree_add_item(branch, hf_u3v_bootstrap_Device_Capability, tvb, offset, 8, ENC_LITTLE_ENDIAN);
            break;
        case U3V_ABRM_MAXIMUM_DEVICE_RESPONSE_TIME:
            proto_tree_add_item(branch, hf_u3v_bootstrap_Maximum_Device_Response_Time, tvb, offset, 4, ENC_LITTLE_ENDIAN);
            break;
        case U3V_ABRM_MANIFEST_TABLE_ADDRESS:
            proto_tree_add_item(branch, hf_u3v_bootstrap_Manifest_Table_Address, tvb, offset, 8, ENC_LITTLE_ENDIAN);
            break;
        case U3V_ABRM_SBRM_ADDRESS:
            proto_tree_add_item(branch, hf_u3v_bootstrap_SBRM_Address, tvb, offset, 8, ENC_LITTLE_ENDIAN);
            break;
        case U3V_ABRM_DEVICE_CONFIGURATION:
            proto_tree_add_item(branch, hf_u3v_bootstrap_Device_Configuration, tvb, offset, 8, ENC_LITTLE_ENDIAN);
            break;
        case U3V_ABRM_HEARTBEAT_TIMEOUT:
            proto_tree_add_item(branch, hf_u3v_bootstrap_Heartbeat_Timeout, tvb, offset, 4, ENC_LITTLE_ENDIAN);
            break;
        case U3V_ABRM_MESSAGE_CHANNEL_CHANNEL_ID:
            proto_tree_add_item(branch, hf_u3v_bootstrap_Message_Channel_channel_id, tvb, offset, 4, ENC_LITTLE_ENDIAN);
            break;
        case U3V_ABRM_TIMESTAMP:
            proto_tree_add_item(branch, hf_u3v_bootstrap_Timestamp, tvb, offset, 8, ENC_LITTLE_ENDIAN);
            break;
        case U3V_ABRM_TIMESTAMP_LATCH:
            proto_tree_add_item(branch, hf_u3v_bootstrap_Timestamp_Latch, tvb, offset, 4, ENC_LITTLE_ENDIAN);
            break;
        case U3V_ABRM_TIMESTAMP_INCREMENT:
            proto_tree_add_item(branch, hf_u3v_bootstrap_Timestamp_Increment, tvb, offset, 8, ENC_LITTLE_ENDIAN);
            break;
        case U3V_ABRM_ACCESS_PRIVILEGE:
            proto_tree_add_item(branch, hf_u3v_bootstrap_Access_Privilege, tvb, offset, 4, ENC_LITTLE_ENDIAN);
            break;
        case U3V_ABRM_PROTOCOL_ENDIANESS:
            proto_tree_add_item(branch, hf_u3v_bootstrap_Protocol_Endianess, tvb, offset, 4, ENC_LITTLE_ENDIAN);
            break;
        case U3V_ABRM_IMPLEMENTATION_ENDIANESS:
            proto_tree_add_item(branch, hf_u3v_bootstrap_Implementation_Endianess, tvb, offset, 4, ENC_LITTLE_ENDIAN);
            break;
        default:
            isABRM = FALSE;
            break;
        }
    }
    if ( u3v_conv_info->sbrm_addr != 0 &&  (addr >= u3v_conv_info->sbrm_addr)) {
        guint64 map_offset = addr - u3v_conv_info->sbrm_addr;
        isSBRM = TRUE;
        switch(map_offset) {
        case U3V_SBRM_U3V_VERSION:
            proto_tree_add_item(branch, hf_u3v_bootstrap_U3V_Version, tvb, offset, 4, ENC_LITTLE_ENDIAN);
            break;
        case U3V_SBRM_U3VCP_CAPABILITY_REGISTER:
            proto_tree_add_item(branch, hf_u3v_bootstrap_U3VCP_Capability_Register, tvb, offset, 8, ENC_LITTLE_ENDIAN);
            break;
        case U3V_SBRM_U3VCP_CONFIGURATION_REGISTER:
            proto_tree_add_item(branch, hf_u3v_bootstrap_U3VCP_Configuration_Register, tvb, offset, 8, ENC_LITTLE_ENDIAN);
            break;
        case U3V_SBRM_MAXIMUM_COMMAND_TRANSFER_LENGTH:
            proto_tree_add_item(branch, hf_u3v_bootstrap_Maximum_Command_Transfer_Length, tvb, offset, 4, ENC_LITTLE_ENDIAN);
            break;
        case U3V_SBRM_MAXIMUM_ACKNOWLEDGE_TRANSFER_LENGTH:
            proto_tree_add_item(branch, hf_u3v_bootstrap_Maximum_Acknowledge_Transfer_Length, tvb, offset, 4, ENC_LITTLE_ENDIAN);
            break;
        case U3V_SBRM_NUMBER_OF_STREAM_CHANNELS:
            proto_tree_add_item(branch, hf_u3v_bootstrap_Number_of_Stream_Channels, tvb, offset, 4, ENC_LITTLE_ENDIAN);
            break;
        case U3V_SBRM_SIRM_ADDRESS:
            proto_tree_add_item(branch, hf_u3v_bootstrap_SIRM_Address, tvb, offset, 8, ENC_LITTLE_ENDIAN);
            break;
        case U3V_SBRM_SIRM_LENGTH:
            proto_tree_add_item(branch, hf_u3v_bootstrap_SIRM_Length, tvb, offset, 4, ENC_LITTLE_ENDIAN);
            break;
        case U3V_SBRM_EIRM_ADDRESS:
            proto_tree_add_item(branch, hf_u3v_bootstrap_EIRM_Address, tvb, offset, 8, ENC_LITTLE_ENDIAN);
            break;
        case U3V_SBRM_EIRM_LENGTH:
            proto_tree_add_item(branch, hf_u3v_bootstrap_EIRM_Length, tvb, offset, 4, ENC_LITTLE_ENDIAN);
            break;
        case U3V_SBRM_IIDC2_ADDRESS:
            proto_tree_add_item(branch, hf_u3v_bootstrap_IIDC2_Address, tvb, offset, 8, ENC_LITTLE_ENDIAN);
            break;
        case U3V_SBRM_CURRENT_SPEED:
            proto_tree_add_item(branch, hf_u3v_bootstrap_Current_Speed, tvb, offset, 4, ENC_LITTLE_ENDIAN);
            break;
        default:
            isSBRM = FALSE;
            break;
        }
    }
    if ( u3v_conv_info->sirm_addr != 0 &&  (addr >= u3v_conv_info->sirm_addr)) {
        guint64 map_offset = addr - u3v_conv_info->sirm_addr;
        isSIRM = TRUE;
        switch(map_offset) {
        case U3V_SIRM_SI_INFO:
            proto_tree_add_item(branch, hf_u3v_bootstrap_SI_Info, tvb, offset, 4, ENC_LITTLE_ENDIAN);
            break;
        case U3V_SIRM_SI_CONTROL:
            proto_tree_add_item(branch, hf_u3v_bootstrap_SI_Control, tvb, offset, 4, ENC_LITTLE_ENDIAN);
            break;
        case U3V_SIRM_SI_REQUIRED_PAYLOAD_SIZE:
            proto_tree_add_item(branch, hf_u3v_bootstrap_SI_Required_Payload_Size, tvb, offset, 8, ENC_LITTLE_ENDIAN);
            break;
        case U3V_SIRM_SI_REQUIRED_LEADER_SIZE:
            proto_tree_add_item(branch, hf_u3v_bootstrap_SI_Required_Leader_Size, tvb, offset, 4, ENC_LITTLE_ENDIAN);
            break;
        case U3V_SIRM_SI_REQUIRED_TRAILER_SIZE:
            proto_tree_add_item(branch, hf_u3v_bootstrap_SI_Required_Trailer_Size, tvb, offset, 4, ENC_LITTLE_ENDIAN);
            break;
        case U3V_SIRM_SI_MAXIMUM_LEADER_SIZE:
            proto_tree_add_item(branch, hf_u3v_bootstrap_SI_Maximum_Leader_Size, tvb, offset, 4, ENC_LITTLE_ENDIAN);
            break;
        case U3V_SIRM_SI_PAYLOAD_TRANSFER_SIZE:
            proto_tree_add_item(branch, hf_u3v_bootstrap_SI_Payload_Transfer_Size, tvb, offset, 4, ENC_LITTLE_ENDIAN);
            break;
        case U3V_SIRM_SI_PAYLOAD_TRANSFER_COUNT:
            proto_tree_add_item(branch, hf_u3v_bootstrap_SI_Payload_Transfer_Count, tvb, offset, 4, ENC_LITTLE_ENDIAN);
            break;
        case U3V_SIRM_SI_PAYLOAD_FINAL_TRANSFER1_SIZE:
            proto_tree_add_item(branch, hf_u3v_bootstrap_SI_Payload_Final_Transfer1_Size, tvb, offset, 4, ENC_LITTLE_ENDIAN);
            break;
        case U3V_SIRM_SI_PAYLOAD_FINAL_TRANSFER2_SIZE:
            proto_tree_add_item(branch, hf_u3v_bootstrap_SI_Payload_Final_Transfer2_Size, tvb, offset, 4, ENC_LITTLE_ENDIAN);
            break;
        case U3V_SIRM_SI_MAXIMUM_TRAILER_SIZE:
            proto_tree_add_item(branch, hf_u3v_bootstrap_SI_Maximum_Trailer_Size, tvb, offset, 4, ENC_LITTLE_ENDIAN);
            break;
        default:
            isSIRM = FALSE;
            break;
        }
    }
    if ( u3v_conv_info->eirm_addr != 0 &&  (addr >= u3v_conv_info->eirm_addr)) {
        guint64 map_offset = addr -u3v_conv_info->eirm_addr;
        isEIRM=TRUE;
        switch(map_offset) {
        case U3V_EIRM_EI_CONTROL:
            proto_tree_add_item(branch, hf_u3v_bootstrap_EI_Control, tvb, offset, 4, ENC_LITTLE_ENDIAN);
            break;
        case U3V_EIRM_MAXIMUM_EVENT_TRANSFER_LENGTH:
            proto_tree_add_item(branch, hf_u3v_bootstrap_Maximum_Event_Transfer_Length, tvb, offset, 4, ENC_LITTLE_ENDIAN);
            break;
        case U3V_EIRM_EVENT_TEST_CONTROL:
            proto_tree_add_item(branch, hf_u3v_bootstrap_Event_Test_Control, tvb, offset, 4, ENC_LITTLE_ENDIAN);
            break;
        default:
            isEIRM = FALSE;
            break;
        }
    }
    if(isABRM || isSBRM || isSIRM || isEIRM ) {
        return 1;
    }
    return 0;
}

dissect_usb_video_selector_unit(proto_tree *tree, tvbuff_t *tvb, int offset)
{
    guint8 num_inputs;

    num_inputs = tvb_get_guint8(tvb, offset);
    proto_tree_add_item(tree, hf_usb_vid_num_inputs, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    ++offset;

    if (num_inputs > 0)
    {
        proto_tree_add_item(tree, hf_usb_vid_sources, tvb, offset, num_inputs, ENC_NA);
        offset += num_inputs;
    }

    proto_tree_add_item(tree, hf_usb_vid_iSelector, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    ++offset;

    return offset;
}

dissect_usb_ms_control(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)
{
    gboolean is_request;
    usb_conv_info_t *usb_conv_info;
    usb_trans_info_t *usb_trans_info;
    int offset=0;
    usb_setup_dissector dissector = NULL;
    const usb_setup_dissector_table_t *tmp;

    /* Reject the packet if data or usb_trans_info are NULL */
    if (data == NULL || ((usb_conv_info_t *)data)->usb_trans_info == NULL)
        return 0;
    usb_conv_info = (usb_conv_info_t *)data;
    usb_trans_info = usb_conv_info->usb_trans_info;

    is_request=(pinfo->srcport==NO_ENDPOINT);

    /* See if we can find a class specific dissector for this request */
    for(tmp=setup_dissectors;tmp->dissector;tmp++){
        if (tmp->request == usb_trans_info->setup.request){
            dissector=tmp->dissector;
            break;
        }
    }
    /* No we could not find any class specific dissector for this request
     * return 0 and let USB try any of the standard requests.
     */
    if(!dissector){
        return 0;
    }

    col_set_str(pinfo->cinfo, COL_PROTOCOL, "USBMS");

    col_add_fstr(pinfo->cinfo, COL_INFO, "%s %s",
        val_to_str(usb_trans_info->setup.request, setup_request_names_vals, "Unknown type %x"),
        is_request?"Request":"Response");

    if(is_request){
        proto_tree_add_item(tree, hf_usb_ms_request, tvb, offset, 1, ENC_LITTLE_ENDIAN);
        offset += 1;
    }

    dissector(pinfo, tree, tvb, offset, is_request, usb_trans_info, usb_conv_info);
    return tvb_captured_length(tvb);
}

proto_register_usb_audio(void)
{
    static hf_register_info hf[] = {
        { &hf_midi_cable_number,
            { "Cable Number", "usbaudio.midi.cable_number", FT_UINT8, BASE_HEX,
              NULL, 0xF0, NULL, HFILL }},
        { &hf_midi_code_index,
            { "Code Index", "usbaudio.midi.code_index", FT_UINT8, BASE_HEX,
              VALS(code_index_vals), 0x0F, NULL, HFILL }},
        { &hf_midi_event,
            { "MIDI Event", "usbaudio.midi.event", FT_UINT24, BASE_HEX,
              NULL, 0, NULL, HFILL }},

        { &hf_ac_if_desc_subtype,
            { "Subtype", "usbaudio.ac_if_subtype", FT_UINT8, BASE_HEX|BASE_EXT_STRING,
                &ac_subtype_vals_ext, 0x00, "bDescriptorSubtype", HFILL }},
        { &hf_ac_if_hdr_ver,
            { "Version", "usbaudio.ac_if_hdr.bcdADC",
                FT_DOUBLE, BASE_NONE, NULL, 0, "bcdADC", HFILL }},
        { &hf_ac_if_hdr_total_len,
            { "Total length", "usbaudio.ac_if_hdr.wTotalLength",
              FT_UINT16, BASE_DEC, NULL, 0x00, "wTotalLength", HFILL }},
        { &hf_ac_if_hdr_bInCollection,
            { "Total number of interfaces", "usbaudio.ac_if_hdr.bInCollection",
              FT_UINT8, BASE_DEC, NULL, 0x00, "bInCollection", HFILL }},
        { &hf_ac_if_hdr_if_num,
            { "Interface number", "usbaudio.ac_if_hdr.baInterfaceNr",
              FT_UINT8, BASE_DEC, NULL, 0x00, "baInterfaceNr", HFILL }},
        { &hf_ac_if_input_terminalid,
            { "Terminal ID", "usbaudio.ac_if_input.bTerminalID",
              FT_UINT8, BASE_DEC, NULL, 0x00, "bTerminalID", HFILL }},
        { &hf_ac_if_input_terminaltype,
            { "Terminal Type", "usbaudio.ac_if_input.wTerminalType", FT_UINT16,
              BASE_HEX|BASE_EXT_STRING, &terminal_types_vals_ext, 0x00, "wTerminalType", HFILL }},
        { &hf_ac_if_input_assocterminal,
            { "Assoc Terminal", "usbaudio.ac_if_input.bAssocTerminal",
              FT_UINT8, BASE_DEC, NULL, 0x00, "bAssocTerminal", HFILL }},
        { &hf_ac_if_input_nrchannels,
            { "Number Channels", "usbaudio.ac_if_input.bNrChannels",
              FT_UINT8, BASE_DEC, NULL, 0x00, "bNrChannels", HFILL }},
        { &hf_ac_if_input_channelconfig,
            { "Channel Config", "usbaudio.ac_if_input.wChannelConfig",
              FT_UINT16, BASE_HEX, NULL, 0x00, "wChannelConfig", HFILL }},
        { &hf_ac_if_input_channelnames,
            { "Channel Names", "usbaudio.ac_if_input.iChannelNames",
              FT_UINT8, BASE_DEC, NULL, 0x00, "iChannelNames", HFILL }},
        { &hf_ac_if_input_terminal,
            { "Terminal", "usbaudio.ac_if_input.iTerminal",
              FT_UINT8, BASE_DEC, NULL, 0x00, "iTerminal", HFILL }},
        { &hf_ac_if_output_terminalid,
            { "Terminal ID", "usbaudio.ac_if_output.bTerminalID",
              FT_UINT8, BASE_DEC, NULL, 0x00, "bTerminalID", HFILL }},
        { &hf_ac_if_output_terminaltype,
            { "Terminal Type", "usbaudio.ac_if_output.wTerminalType", FT_UINT16,
               BASE_HEX|BASE_EXT_STRING, &terminal_types_vals_ext, 0x00, "wTerminalType", HFILL }},
        { &hf_ac_if_output_assocterminal,
            { "Assoc Terminal", "usbaudio.ac_if_output.bAssocTerminal",
              FT_UINT8, BASE_DEC, NULL, 0x00, "bAssocTerminal", HFILL }},
        { &hf_ac_if_output_sourceid,
            { "Source ID", "usbaudio.ac_if_output.bSourceID",
              FT_UINT8, BASE_DEC, NULL, 0x00, "bSourceID", HFILL }},
        { &hf_ac_if_output_terminal,
            { "Terminal", "usbaudio.ac_if_output.iTerminal",
              FT_UINT8, BASE_DEC, NULL, 0x00, "iTerminal", HFILL }},
        { &hf_ac_if_fu_unitid,
            { "Unit ID", "usbaudio.ac_if_fu.bUnitID",
              FT_UINT8, BASE_DEC, NULL, 0x00, "bUnitID", HFILL }},
        { &hf_ac_if_fu_sourceid,
            { "Source ID", "usbaudio.ac_if_fu.bSourceID",
              FT_UINT8, BASE_DEC, NULL, 0x00, "bSourceID", HFILL }},
        { &hf_ac_if_fu_controlsize,
            { "Control Size", "usbaudio.ac_if_fu.bControlSize",
              FT_UINT8, BASE_DEC, NULL, 0x00, "bControlSize", HFILL }},
        { &hf_ac_if_fu_controls,
            { "Controls", "usbaudio.ac_if_fu.bmaControls",
              FT_BYTES, BASE_NONE, NULL, 0x00, "bmaControls", HFILL }},
        { &hf_ac_if_fu_control,
            { "Control", "usbaudio.ac_if_fu.bmaControl",
              FT_UINT8, BASE_HEX, NULL, 0x00, "bmaControls", HFILL }},
        { &hf_ac_if_fu_controls_d0,
            { "Mute", "usbaudio.ac_if_fu.bmaControls.d0",
              FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},
        { &hf_ac_if_fu_controls_d1,
            { "Volume", "usbaudio.ac_if_fu.bmaControls.d1",
              FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},
        { &hf_ac_if_fu_controls_d2,
            { "Bass", "usbaudio.ac_if_fu.bmaControls.d2",
              FT_BOOLEAN, 8, NULL, 0x04, NULL, HFILL }},
        { &hf_ac_if_fu_controls_d3,
            { "Mid", "usbaudio.ac_if_fu.bmaControls.d3",
              FT_BOOLEAN, 8, NULL, 0x08, NULL, HFILL }},
        { &hf_ac_if_fu_controls_d4,
            { "Treble", "usbaudio.ac_if_fu.bmaControls.d4",
              FT_BOOLEAN, 8, NULL, 0x10, NULL, HFILL }},
        { &hf_ac_if_fu_controls_d5,
            { "Graphic Equalizer", "usbaudio.ac_if_fu.bmaControls.d5",
              FT_BOOLEAN, 8, NULL, 0x20, NULL, HFILL }},
        { &hf_ac_if_fu_controls_d6,
            { "Automatic Gain", "usbaudio.ac_if_fu.bmaControls.d6",
              FT_BOOLEAN, 8, NULL, 0x40, NULL, HFILL }},
        { &hf_ac_if_fu_controls_d7,
            { "Delay", "usbaudio.ac_if_fu.bmaControls.d7",
              FT_BOOLEAN, 8, NULL, 0x80, NULL, HFILL }},
        { &hf_ac_if_fu_controls_d8,
            { "Bass Boost", "usbaudio.ac_if_fu.bmaControls.d8",
              FT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},
        { &hf_ac_if_fu_controls_d9,
            { "Loudness", "usbaudio.ac_if_fu.bmaControls.d9",
              FT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},
        { &hf_ac_if_fu_controls_rsv,
            { "Reserved", "usbaudio.ac_if_fu.bmaControls.rsv",
              FT_UINT8, BASE_HEX, NULL, 0xFC, "Must be zero", HFILL }},
        { &hf_ac_if_fu_ifeature,
            { "Feature", "usbaudio.ac_if_fu.iFeature",
              FT_UINT8, BASE_DEC, NULL, 0x00, "iFeature", HFILL }},
        { &hf_as_if_desc_subtype,
            { "Subtype", "usbaudio.as_if_subtype", FT_UINT8, BASE_HEX|BASE_EXT_STRING,
                &as_subtype_vals_ext, 0x00, "bDescriptorSubtype", HFILL }},
        { &hf_as_if_gen_term_id,
            { "Terminal ID", "usbaudio.as_if_gen.bTerminalLink",
              FT_UINT8, BASE_DEC, NULL, 0x00, "bTerminalLink", HFILL }},
        { &hf_as_if_gen_delay,
            { "Interface delay in frames", "usbaudio.as_if_gen.bDelay",
              FT_UINT8, BASE_DEC, NULL, 0x00, "bDelay", HFILL }},
        { &hf_as_if_gen_format,
            { "Format", "usbaudio.as_if_gen.wFormatTag",
              FT_UINT16, BASE_HEX, NULL, 0x00, "wFormatTag", HFILL }},
        { &hf_as_if_ft_formattype,
            { "FormatType", "usbaudio.as_if_ft.bFormatType",
              FT_UINT8, BASE_DEC, NULL, 0x00, "wFormatType", HFILL }},
        { &hf_as_if_ft_maxbitrate,
            { "Max Bit Rate", "usbaudio.as_if_ft.wMaxBitRate",
              FT_UINT16, BASE_DEC, NULL, 0x00, "wMaxBitRate", HFILL }},
        { &hf_as_if_ft_nrchannels,
            { "Number Channels", "usbaudio.as_if_ft.bNrChannels",
              FT_UINT8, BASE_DEC, NULL, 0x00, "bNrChannels", HFILL }},
        { &hf_as_if_ft_subframesize,
            { "Subframe Size", "usbaudio.as_if_ft.bSubframeSize",
              FT_UINT8, BASE_DEC, NULL, 0x00, "bSubframeSize", HFILL }},
        { &hf_as_if_ft_bitresolution,
            { "Bit Resolution", "usbaudio.as_if_ft.bBitResolution",
              FT_UINT8, BASE_DEC, NULL, 0x00, "bBitResolution", HFILL }},
        { &hf_as_if_ft_samplesperframe,
            { "Samples Per Frame", "usbaudio.as_if_ft.wSamplesPerFrame",
              FT_UINT16, BASE_DEC, NULL, 0x00, "wSamplesPerFrame", HFILL }},
        { &hf_as_if_ft_samfreqtype,
            { "Samples Frequence Type", "usbaudio.as_if_ft.bSamFreqType",
              FT_UINT8, BASE_DEC, NULL, 0x00, "bSamFreqType", HFILL }},
        { &hf_as_if_ft_lowersamfreq,
            { "Lower Samples Frequence", "usbaudio.as_if_ft.tLowerSamFreq",
              FT_UINT24, BASE_DEC, NULL, 0x00, "tLowerSamFreq", HFILL }},
        { &hf_as_if_ft_uppersamfreq,
            { "Upper Samples Frequence", "usbaudio.as_if_ft.tUpperSamFreq",
              FT_UINT24, BASE_DEC, NULL, 0x00, "tUpperSamFreq", HFILL }},
        { &hf_as_if_ft_samfreq,
            { "Samples Frequence", "usbaudio.as_if_ft.tSamFreq",
              FT_UINT24, BASE_DEC, NULL, 0x00, "tSamFreq", HFILL }},
        { &hf_as_ep_desc_subtype,
            { "Subtype", "usbaudio.as_ep_subtype", FT_UINT8,
                BASE_HEX, NULL, 0x00, "bDescriptorSubtype", HFILL }},

        { &hf_sysex_msg_fragments,
            { "Message fragments", "usbaudio.sysex.fragments",
              FT_NONE, BASE_NONE, NULL, 0x00, NULL, HFILL }},
        { &hf_sysex_msg_fragment,
            { "Message fragment", "usbaudio.sysex.fragment",
              FT_FRAMENUM, BASE_NONE, NULL, 0x00, NULL, HFILL }},
        { &hf_sysex_msg_fragment_overlap,
            { "Message fragment overlap", "usbaudio.sysex.fragment.overlap",
              FT_BOOLEAN, 0, NULL, 0x00, NULL, HFILL }},
        { &hf_sysex_msg_fragment_overlap_conflicts,
            { "Message fragment overlapping with conflicting data",
              "usbaudio.sysex.fragment.overlap.conflicts",
              FT_BOOLEAN, 0, NULL, 0x00, NULL, HFILL }},
        { &hf_sysex_msg_fragment_multiple_tails,
            { "Message has multiple tail fragments",
              "usbaudio.sysex.fragment.multiple_tails",
              FT_BOOLEAN, 0, NULL, 0x00, NULL, HFILL }},
        { &hf_sysex_msg_fragment_too_long_fragment,
            { "Message fragment too long", "usbaudio.sysex.fragment.too_long_fragment",
              FT_BOOLEAN, 0, NULL, 0x00, NULL, HFILL }},
        { &hf_sysex_msg_fragment_error,
            { "Message defragmentation error", "usbaudio.sysex.fragment.error",
              FT_FRAMENUM, BASE_NONE, NULL, 0x00, NULL, HFILL }},
        { &hf_sysex_msg_fragment_count,
            { "Message fragment count", "usbaudio.sysex.fragment.count",
              FT_UINT32, BASE_DEC, NULL, 0x00, NULL, HFILL }},
        { &hf_sysex_msg_reassembled_in,
            { "Reassembled in", "usbaudio.sysex.reassembled.in",
              FT_FRAMENUM, BASE_NONE, NULL, 0x00, NULL, HFILL }},
        { &hf_sysex_msg_reassembled_length,
            { "Reassembled length", "usbaudio.sysex.reassembled.length",
              FT_UINT32, BASE_DEC, NULL, 0x00, NULL, HFILL }},
        { &hf_sysex_msg_reassembled_data,
            { "Reassembled data", "usbaudio.sysex.reassembled.data",
              FT_BYTES, BASE_NONE, NULL, 0x00, NULL, HFILL }}
    };

    static gint *usb_audio_subtrees[] = {
        &ett_usb_audio,
        &ett_usb_audio_desc,
        &ett_sysex_msg_fragment,
        &ett_sysex_msg_fragments,
        &ett_ac_if_fu_controls,
        &ett_ac_if_fu_controls0,
        &ett_ac_if_fu_controls1
    };

    static ei_register_info ei[] = {
        { &ei_usb_audio_undecoded, { "usbaudio.undecoded", PI_UNDECODED, PI_WARN, "Not dissected yet (report to wireshark.org)", EXPFILL }},
    };

    expert_module_t *expert_usb_audio;

    proto_usb_audio = proto_register_protocol("USB Audio", "USBAUDIO", "usbaudio");
    proto_register_field_array(proto_usb_audio, hf, array_length(hf));
    proto_register_subtree_array(usb_audio_subtrees, array_length(usb_audio_subtrees));
    expert_usb_audio = expert_register_protocol(proto_usb_audio);
    expert_register_field_array(expert_usb_audio, ei, array_length(ei));
    register_init_routine(&midi_data_reassemble_init);
    register_cleanup_routine(&midi_data_reassemble_cleanup);

    register_dissector("usbaudio", dissect_usb_audio_bulk, proto_usb_audio);
}

get_control_selector_values(guint8 entity_id, usb_conv_info_t *usb_conv_info)
{
    video_conv_info_t *video_conv_info;
    video_entity_t    *entity = NULL;
    value_string_ext  *selectors = NULL;

    if (usb_conv_info == NULL)
        return NULL;

    video_conv_info = (video_conv_info_t *)usb_conv_info->class_data;
    if (video_conv_info)
        entity = (video_entity_t*) wmem_tree_lookup32(video_conv_info->entities, entity_id);

    if (entity_id == 0)
    {
        /* Interface Request*/
        switch (usb_conv_info->interfaceSubclass)
        {
            case SC_VIDEOCONTROL:
                selectors = &cs_control_interface_ext;
                break;

            case SC_VIDEOSTREAMING:
                selectors = &cs_streaming_interface_ext;
                break;

            default:
                break;
        }
    }
    else if (entity)
    {
        switch (entity->subtype)
        {
            case VC_INPUT_TERMINAL:
                if (entity->terminalType == ITT_CAMERA)
                {
                    selectors = &cs_camera_terminal_ext;
                }
                break;

            case VC_PROCESSING_UNIT:
                selectors = &cs_processing_unit_ext;
                break;

            case VC_SELECTOR_UNIT:
                selectors = &cs_selector_unit_ext;
                break;

            default:
                break;
        }
    }

    return selectors;
}

dissect_usb_vid_control_value(proto_tree *tree, tvbuff_t *tvb, int offset, guint8 request)
{
    gint        value_size;
    const char *fallback_name;
    int         hf;

    switch (request)
    {
        case USB_SETUP_GET_DEF:
            hf = hf_usb_vid_control_default;
            fallback_name = "Default Value";
            break;

        case USB_SETUP_GET_MIN:
        case CONTROL_CHANGE_MIN:
            hf = hf_usb_vid_control_min;
            fallback_name = "Min Value";
            break;

        case USB_SETUP_GET_MAX:
        case CONTROL_CHANGE_MAX:
            hf = hf_usb_vid_control_max;
            fallback_name = "Max Value";
            break;

        case USB_SETUP_GET_RES:
            hf = hf_usb_vid_control_res;
            fallback_name = "Resolution";
            break;

        case USB_SETUP_GET_CUR:
        case USB_SETUP_SET_CUR:
        case CONTROL_CHANGE_VALUE:
            hf = hf_usb_vid_control_cur;
            fallback_name = "Current Value";
            break;

        /* @todo UVC 1.5 USB_SETUP_x_ALL?
         *       They are poorly specified.
         */

        default:
            hf = -1;
            fallback_name = "Value";
            break;
    }

    value_size = tvb_reported_length_remaining(tvb, offset);

    if (hf != -1)
    {
        header_field_info *hfinfo;
        hfinfo = proto_registrar_get_nth(hf);
        DISSECTOR_ASSERT(IS_FT_INT(hfinfo->type) || IS_FT_UINT(hfinfo->type));
    }

    if ((hf != -1) && (value_size <= 4))
    {
        proto_tree_add_item(tree, hf, tvb, offset, value_size, ENC_LITTLE_ENDIAN);
    }
    else
    {
        /* @todo Display as FT_BYTES with a big-endian disclaimer?
         * See https://bugs.wireshark.org/bugzilla/show_bug.cgi?id=7933
         */
        proto_tree_add_bytes_format(tree, hf_usb_vid_control_value, tvb, offset, value_size, NULL, "%s", fallback_name);
    }
}

dissect_bmControl(proto_tree *tree, tvbuff_t *tvb, int offset,
                  gint ett_subtree, const int** bm_items)
{
    guint8 bm_size = 0;

    bm_size = tvb_get_guint8(tvb, offset);
    proto_tree_add_item(tree, hf_usb_vid_bControlSize, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    ++offset;

    if (bm_size > 0)
    {
        proto_tree_add_bitmask_len(tree, tvb, offset, bm_size, hf_usb_vid_bmControl,
                                   ett_subtree, bm_items, &ei_usb_vid_bitmask_len, ENC_LITTLE_ENDIAN);
        offset += bm_size;
    }

    return offset;
}

dissect_usb_ms_bulk_heur(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
    const gchar usbc[] = {0x55, 0x53, 0x42, 0x43};
    const gchar usbs[] = {0x55, 0x53, 0x42, 0x53};
    if (tvb_reported_length(tvb) < 4)
        return FALSE;

    if (tvb_memeql(tvb, 0, usbc, sizeof(usbc)) == 0 ||
        tvb_memeql(tvb, 0, usbs, sizeof(usbs)) == 0) {
        dissect_usb_ms_bulk(tvb, pinfo, tree, data);
        return TRUE;
    }

    return FALSE;
}

dissect_usb_audio_bulk(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree, void *data)
{
    usb_conv_info_t *usb_conv_info;
    proto_tree      *tree;
    proto_item      *ti;
    gint             offset, length;
    gint             i;

    /* Reject the packet if data is NULL */
    if (data == NULL)
        return 0;
    usb_conv_info = (usb_conv_info_t *)data;

    col_set_str(pinfo->cinfo, COL_PROTOCOL, "USBAUDIO");

    ti   = proto_tree_add_protocol_format(parent_tree, proto_usb_audio, tvb, 0, -1, "USB Audio");
    tree = proto_item_add_subtree(ti, ett_usb_audio);

    length = tvb_reported_length(tvb);
    offset = 0;

    switch (usb_conv_info->interfaceSubclass)
    {
        case AUDIO_IF_SUBCLASS_MIDISTREAMING:
            col_set_str(pinfo->cinfo, COL_INFO, "USB-MIDI Event Packets");

            for (i = 0; i < length / 4; i++)
            {
                dissect_usb_midi_event(tvb, pinfo, tree, parent_tree, offset);
                offset += 4;
            }
            break;
        default:
            proto_tree_add_expert(tree, pinfo, &ei_usb_audio_undecoded, tvb, offset, length);
    }

    return length;
}

dissect_usb_video_extension_unit(proto_tree *tree, tvbuff_t *tvb, int offset)
{
    guint8 num_inputs;
    guint8 control_size;

    proto_tree_add_item(tree, hf_usb_vid_exten_guid,         tvb, offset,    16, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(tree, hf_usb_vid_exten_num_controls, tvb, offset+16,  1, ENC_LITTLE_ENDIAN);
    offset += 17;

    num_inputs = tvb_get_guint8(tvb, offset);
    proto_tree_add_item(tree, hf_usb_vid_num_inputs,   tvb, offset,  1, ENC_LITTLE_ENDIAN);
    ++offset;

    if (num_inputs > 0)
    {
        proto_tree_add_item(tree, hf_usb_vid_sources, tvb, offset, num_inputs, ENC_NA);
        offset += num_inputs;
    }

    control_size = tvb_get_guint8(tvb, offset);
    proto_tree_add_item(tree, hf_usb_vid_bControlSize, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    ++offset;

    if (control_size > 0)
    {
        if (control_size <= proto_registrar_get_length(hf_usb_vid_bmControl))
        {
            proto_tree_add_item(tree, hf_usb_vid_bmControl, tvb, offset, control_size,
                                ENC_LITTLE_ENDIAN);
        }
        else
        {
            /* Too big to display as integer */
            /* @todo Display as FT_BYTES with a big-endian disclaimer?
             * See https://bugs.wireshark.org/bugzilla/show_bug.cgi?id=7933
             */
            proto_tree_add_bytes_format(tree, hf_usb_vid_bmControl_bytes, tvb, offset, control_size, NULL, "bmControl");
        }
        offset += control_size;
    }

    proto_tree_add_item(tree, hf_usb_vid_iExtension, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    ++offset;

    return offset;
}

dissect_usb_audio_descriptor(tvbuff_t *tvb, packet_info *pinfo,
        proto_tree *tree, void *data)
{
    gint             offset = 0;
    usb_conv_info_t *usb_conv_info;
    proto_tree       *desc_tree = NULL;
    proto_item       *desc_tree_item;
    guint8           desc_len;
    guint8           desc_type;
    guint8           desc_subtype;
    const gchar     *subtype_str;

    usb_conv_info = (usb_conv_info_t *)data;
    if (!usb_conv_info || usb_conv_info->interfaceClass!=IF_CLASS_AUDIO)
        return 0;

    desc_len  = tvb_get_guint8(tvb, offset);
    desc_type = tvb_get_guint8(tvb, offset+1);

    if (desc_type==CS_INTERFACE &&
            usb_conv_info->interfaceSubclass==AUDIO_IF_SUBCLASS_AUDIOCONTROL) {

        desc_tree = proto_tree_add_subtree(tree, tvb, offset, desc_len,
                ett_usb_audio_desc, &desc_tree_item,
                "Class-specific Audio Control Interface Descriptor");

        dissect_usb_descriptor_header(desc_tree, tvb, offset,
            &aud_descriptor_type_vals_ext);
        offset += 2;

        desc_subtype = tvb_get_guint8(tvb, offset);
        proto_tree_add_item(desc_tree, hf_ac_if_desc_subtype,
                tvb, offset, 1, ENC_LITTLE_ENDIAN);
        subtype_str = try_val_to_str_ext(desc_subtype, &ac_subtype_vals_ext);
        if (subtype_str)
            proto_item_append_text(desc_tree_item, ": %s", subtype_str);
        offset++;

        switch(desc_subtype) {
            case AC_SUBTYPE_HEADER:
                /* these subfunctions return the number of bytes dissected,
                   this is not necessarily the length of the body
                   as some components are not yet dissected
                   we rely on the descriptor's length byte instead */
                dissect_ac_if_hdr_body(tvb, offset, pinfo, desc_tree, usb_conv_info);
                break;
            case AC_SUBTYPE_INPUT_TERMINAL:
                dissect_ac_if_input_terminal(tvb, offset, pinfo, desc_tree, usb_conv_info);
                break;
            case AC_SUBTYPE_OUTPUT_TERMINAL:
                dissect_ac_if_output_terminal(tvb, offset, pinfo, desc_tree, usb_conv_info);
                break;
            case AC_SUBTYPE_FEATURE_UNIT:
                dissect_ac_if_feature_unit(tvb, offset, pinfo, desc_tree, usb_conv_info);
                break;
            default:
                proto_tree_add_expert(desc_tree, pinfo, &ei_usb_audio_undecoded, tvb, offset-3, desc_len);
                break;
        }

    }
    else if (desc_type==CS_INTERFACE &&
            usb_conv_info->interfaceSubclass==AUDIO_IF_SUBCLASS_AUDIOSTREAMING) {

        desc_tree = proto_tree_add_subtree(tree, tvb, offset, desc_len,
                ett_usb_audio_desc, &desc_tree_item,
                "Class-specific Audio Streaming Interface Descriptor");

        dissect_usb_descriptor_header(desc_tree, tvb, offset,
            &aud_descriptor_type_vals_ext);
        offset += 2;

        desc_subtype = tvb_get_guint8(tvb, offset);
        proto_tree_add_item(desc_tree, hf_as_if_desc_subtype,
                tvb, offset, 1, ENC_LITTLE_ENDIAN);
        subtype_str = try_val_to_str_ext(desc_subtype, &as_subtype_vals_ext);
        if (subtype_str)
            proto_item_append_text(desc_tree_item, ": %s", subtype_str);
        offset++;

        switch(desc_subtype) {
            case AS_SUBTYPE_GENERAL:
                dissect_as_if_general_body(tvb, offset, pinfo,
                        desc_tree, usb_conv_info);
                break;
            case AS_SUBTYPE_FORMAT_TYPE:
                dissect_as_if_format_type_body(tvb, offset, pinfo,
                        desc_tree, usb_conv_info);
                break;
            default:
                proto_tree_add_expert(desc_tree, pinfo, &ei_usb_audio_undecoded, tvb, offset-3, desc_len);
                break;
        }
    }
    /* there are no class-specific endpoint descriptors for audio control */
    else if (desc_type == CS_ENDPOINT &&
            usb_conv_info->interfaceSubclass==AUDIO_IF_SUBCLASS_AUDIOSTREAMING) {

        desc_tree = proto_tree_add_subtree(tree, tvb, offset, desc_len,
                ett_usb_audio_desc, &desc_tree_item,
                "Class-specific Audio Streaming Endpoint Descriptor");

        dissect_usb_descriptor_header(desc_tree, tvb, offset,
            &aud_descriptor_type_vals_ext);
        offset += 2;

        proto_tree_add_item(desc_tree, hf_as_ep_desc_subtype,
                tvb, offset, 1, ENC_LITTLE_ENDIAN);
    }
    else
        return 0;

    return desc_len;
}

dissect_u3v_read_mem_cmd(proto_tree *u3v_telegram_tree, tvbuff_t *tvb, packet_info *pinfo, gint startoffset, gint length, u3v_conv_info_t *u3v_conv_info, gencp_transaction_t * gencp_trans)
{
    guint64 addr = 0;
    const gchar* address_string = NULL;
    gboolean is_custom_register = FALSE;
    guint16 count = 0;
    gint offset = startoffset;
    proto_item *item = NULL;

    addr = tvb_get_letoh64(tvb, offset);
    gencp_trans->address = addr;

    address_string = get_register_name_from_address(addr, &is_custom_register, u3v_conv_info);
    count = tvb_get_letohs(tvb, offset + 10);   /* Number of bytes to read from memory */

    gencp_trans->count = count;
    if ( 0xffffffff00000000 & addr ) {
        col_append_fstr(pinfo->cinfo, COL_INFO, " (0x%016" G_GINT64_MODIFIER "X (%d) bytes) %s", addr, count, address_string);
    } else {
        col_append_fstr(pinfo->cinfo, COL_INFO, " (0x%08X (%d) bytes)", (guint32)addr, count);
    }


    item = proto_tree_add_item(u3v_telegram_tree, hf_u3v_scd_readmem_cmd, tvb, offset, length, ENC_NA);
    u3v_telegram_tree = proto_item_add_subtree(item, ett_u3v_payload_cmd);

    /* address */
    if (is_known_bootstrap_register(addr, u3v_conv_info)) {
        item = proto_tree_add_uint64(u3v_telegram_tree, hf_u3v_address, tvb, offset, 8, addr);
        proto_item_append_text(item, " %s", address_string);
    } else {
        proto_tree_add_item(u3v_telegram_tree, hf_u3v_custom_memory_addr, tvb, offset, 8, ENC_LITTLE_ENDIAN);
    }
    offset += 8;

    /* reserved field */
    proto_tree_add_item(u3v_telegram_tree, hf_u3v_reserved, tvb, offset, 2, ENC_NA);
    offset += 2;

    /* count */
    proto_tree_add_item(u3v_telegram_tree, hf_u3v_count, tvb, offset, 2, ENC_LITTLE_ENDIAN);
}

dissect_u3v_read_mem_ack(proto_tree *u3v_telegram_tree, tvbuff_t *tvb, packet_info *pinfo, gint startoffset, gint length, u3v_conv_info_t *u3v_conv_info, gencp_transaction_t * gencp_trans)
{
    guint64 addr = 0;
    const gchar *address_string = NULL;
    gboolean is_custom_register = FALSE;
    gboolean have_address = (0 != gencp_trans->cmd_frame);
    proto_item *item = NULL;
    guint offset = startoffset;
    guint byte_count = (length);

    addr = gencp_trans->address;
    dissect_u3v_register_bases(addr, tvb, startoffset, u3v_conv_info);
    if (have_address) {
        address_string = get_register_name_from_address(addr, &is_custom_register, u3v_conv_info);
        /* Fill in Wireshark GUI Info column */
        col_append_fstr(pinfo->cinfo, COL_INFO, "%s", address_string);
    }


    /* Subtree initialization for Payload Data: READMEM_ACK */
    item = proto_tree_add_item(u3v_telegram_tree, hf_u3v_scd_ack_readmem_ack, tvb, startoffset, length, ENC_NA);
    u3v_telegram_tree = proto_item_add_subtree(item, ett_u3v_payload_cmd);

    /* Bootstrap register known address */
    if (have_address) {
        item = proto_tree_add_uint64(u3v_telegram_tree, hf_u3v_address, tvb, 0,0 , addr);
        PROTO_ITEM_SET_GENERATED(item);

        if (is_known_bootstrap_register(addr, u3v_conv_info)) {
            dissect_u3v_register(addr, u3v_telegram_tree, tvb, offset, byte_count, u3v_conv_info);
        } else {
            proto_tree_add_item(u3v_telegram_tree, hf_u3v_custom_memory_data, tvb, startoffset, length, ENC_NA);
        }
    }
}

dissect_ac_if_input_terminal(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,
        proto_tree *tree, usb_conv_info_t *usb_conv_info _U_)
{
    gint     offset_start;
    offset_start = offset;

    proto_tree_add_item(tree, hf_ac_if_input_terminalid, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;

    proto_tree_add_item(tree, hf_ac_if_input_terminaltype, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;

    proto_tree_add_item(tree, hf_ac_if_input_assocterminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;

    proto_tree_add_item(tree, hf_ac_if_input_nrchannels, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;

    proto_tree_add_item(tree, hf_ac_if_input_channelconfig, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;

    proto_tree_add_item(tree, hf_ac_if_input_channelnames, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;

    proto_tree_add_item(tree, hf_ac_if_input_terminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;

    return offset-offset_start;
}

dissect_u3v(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
    gint offset = 0;
    proto_tree *u3v_tree = NULL, *ccd_tree_flag, *u3v_telegram_tree = NULL, *ccd_tree = NULL;
    gint data_length = 0;
    gint req_id = 0;
    gint command_id = -1;
    gint status = 0;
    guint prefix = 0;
    proto_item *ti = NULL;
    proto_item *item = NULL;
    const char *command_string;
    usb_conv_info_t *usb_conv_info;
    gint stream_detected = FALSE;
    gint control_detected = FALSE;
    u3v_conv_info_t *u3v_conv_info = NULL;
    gencp_transaction_t *gencp_trans = NULL;

    usb_conv_info = (usb_conv_info_t *)data;

    /* decide if this packet belongs to U3V protocol */
    u3v_conv_info = (u3v_conv_info_t *)usb_conv_info->class_data;

     if (!u3v_conv_info) {
         u3v_conv_info = wmem_new0(wmem_file_scope(), u3v_conv_info_t);
         usb_conv_info->class_data = u3v_conv_info;
     }
 
     prefix = tvb_get_letohl(tvb, 0);
    if ((tvb_reported_length(tvb) >= 4) && ( ( U3V_CONTROL_PREFIX == prefix ) || ( U3V_EVENT_PREFIX == prefix ) ) ) {
        control_detected = TRUE;
    }

    if (((tvb_reported_length(tvb) >= 4) && (( U3V_STREAM_LEADER_PREFIX == prefix ) || ( U3V_STREAM_TRAILER_PREFIX == prefix )))
         || (usb_conv_info->endpoint == u3v_conv_info->ep_stream)) {
        stream_detected = TRUE;
    }

    /* initialize interface class/subclass in case no descriptors have been dissected yet */
    if ( control_detected || stream_detected){
        if ( usb_conv_info->interfaceClass  == IF_CLASS_UNKNOWN &&
             usb_conv_info->interfaceSubclass  == IF_SUBCLASS_UNKNOWN){
            usb_conv_info->interfaceClass = IF_CLASS_MISCELLANEOUS;
            usb_conv_info->interfaceSubclass = IF_SUBCLASS_MISC_U3V;
        }
    }

    if ( control_detected ) {
        /* Set the protocol column */
        col_set_str(pinfo->cinfo, COL_PROTOCOL, "U3V");

        /* Clear out stuff in the info column */
        col_clear(pinfo->cinfo, COL_INFO);

        /* Adds "USB3Vision" heading to protocol tree */
        /* We will add fields to this using the u3v_tree pointer */
        ti = proto_tree_add_item(tree, proto_u3v, tvb, offset, -1, ENC_NA);
        u3v_tree = proto_item_add_subtree(ti, ett_u3v);

        prefix = tvb_get_letohl(tvb, offset);
        command_id = tvb_get_letohs(tvb, offset+6);

        /* decode CCD ( DCI/DCE command data layout) */
        if ((prefix == U3V_CONTROL_PREFIX || prefix == U3V_EVENT_PREFIX) && ((command_id % 2) == 0)) {
            command_string = val_to_str(command_id,command_names,"Unknown Command (0x%x)");
            item = proto_tree_add_item(u3v_tree, hf_u3v_ccd_cmd, tvb, offset, 8, ENC_NA);
            proto_item_append_text(item, ": %s", command_string);
            ccd_tree = proto_item_add_subtree(item, ett_u3v_cmd);

            /* Add the prefix code: */
            proto_tree_add_item(ccd_tree, hf_u3v_gencp_prefix, tvb, offset, 4, ENC_LITTLE_ENDIAN);
            offset += 4;

            /* Add the flags */
            item = proto_tree_add_item(ccd_tree, hf_u3v_flag, tvb, offset, 2, ENC_LITTLE_ENDIAN);
            ccd_tree_flag  = proto_item_add_subtree(item, ett_u3v_flags);
            proto_tree_add_item(ccd_tree_flag, hf_u3v_acknowledge_required_flag, tvb, offset, 2, ENC_LITTLE_ENDIAN);

            offset += 2;
            col_append_fstr(pinfo->cinfo, COL_INFO, "> %s ", command_string);
        } else if (prefix == U3V_CONTROL_PREFIX && ((command_id % 2) == 1)) {
            command_string = val_to_str(command_id,command_names,"Unknown Acknowledge (0x%x)");
            item = proto_tree_add_item(u3v_tree, hf_u3v_ccd_ack, tvb, offset, 8, ENC_NA);
            proto_item_append_text(item, ": %s", command_string);
            ccd_tree = proto_item_add_subtree(item, ett_u3v_ack);

            /* Add the prefix code: */
            proto_tree_add_item(ccd_tree, hf_u3v_gencp_prefix, tvb, offset, 4, ENC_LITTLE_ENDIAN);
            offset += 4;

            /* Add the status: */
            proto_tree_add_item(ccd_tree, hf_u3v_status, tvb, offset, 2,ENC_LITTLE_ENDIAN);
            status = tvb_get_letohs(tvb, offset);
            offset += 2;
            col_append_fstr(pinfo->cinfo, COL_INFO, "< %s %s",
                    command_string,
                    val_to_str(status, status_names_short, "Unknown status (0x%04X)"));
        } else {
            return 0;
        }

        /* Add the command id*/
        proto_tree_add_item(ccd_tree, hf_u3v_command_id, tvb, offset, 2,ENC_LITTLE_ENDIAN);
        offset += 2;

        /* Parse the second part of both the command and the acknowledge header:
        0          15 16         31
        -------- -------- -------- --------
        |     status      |   acknowledge   |
        -------- -------- -------- --------
        |     length      |      req_id     |
        -------- -------- -------- --------

        Add the data length
        Number of valid data bytes in this message, not including this header. This
        represents the number of bytes of payload appended after this header */

        proto_tree_add_item(ccd_tree, hf_u3v_length, tvb, offset, 2, ENC_LITTLE_ENDIAN);
        data_length = tvb_get_letohs(tvb, offset);
        offset += 2;

        /* Add the request ID */
        proto_tree_add_item(ccd_tree, hf_u3v_request_id, tvb, offset, 2, ENC_LITTLE_ENDIAN);
        req_id = tvb_get_letohs(tvb, offset);
        offset += 2;

        /* Add telegram subtree */
        u3v_telegram_tree = proto_item_add_subtree(u3v_tree, ett_u3v);

        if (!PINFO_FD_VISITED(pinfo)) {
              if ((command_id % 2) == 0) {
                    /* This is a command */
                    gencp_trans = wmem_new(wmem_file_scope(), gencp_transaction_t);
                    gencp_trans->cmd_frame = pinfo->fd->num;
                    gencp_trans->ack_frame = 0;
                    gencp_trans->cmd_time = pinfo->fd->abs_ts;
                    /* add reference to current packet */
                    p_add_proto_data(wmem_file_scope(), pinfo, proto_u3v, req_id, gencp_trans);
                    /* add reference to current */
                    u3v_conv_info->trans_info = gencp_trans;
                } else {
                    gencp_trans = u3v_conv_info->trans_info;
                    if (gencp_trans) {
                        gencp_trans->ack_frame = pinfo->fd->num;
                        /* add reference to current packet */
                        p_add_proto_data(wmem_file_scope(), pinfo, proto_u3v, req_id, gencp_trans);
                    }
                }
         } else {
            gencp_trans = (gencp_transaction_t*)p_get_proto_data(wmem_file_scope(),pinfo, proto_u3v, req_id);
         }

        if (!gencp_trans) {
            /* create a "fake" gencp_trans structure */
            gencp_trans = wmem_new(wmem_packet_scope(), gencp_transaction_t);
            gencp_trans->cmd_frame = 0;
            gencp_trans->ack_frame = 0;
            gencp_trans->cmd_time = pinfo->fd->abs_ts;
        }

        /* dissect depending on command? */
        switch (command_id) {
        case U3V_READMEM_CMD:
            dissect_u3v_read_mem_cmd(u3v_telegram_tree, tvb, pinfo, offset, data_length,u3v_conv_info,gencp_trans);
            break;
        case U3V_WRITEMEM_CMD:
            dissect_u3v_write_mem_cmd(u3v_telegram_tree, tvb, pinfo, offset, data_length,u3v_conv_info,gencp_trans);
            break;
        case U3V_EVENT_CMD:
            dissect_u3v_event_cmd(u3v_telegram_tree, tvb, pinfo, offset, data_length);
            break;
        case U3V_READMEM_ACK:
            if ( U3V_STATUS_GENCP_SUCCESS == status ) {
                dissect_u3v_read_mem_ack(u3v_telegram_tree, tvb, pinfo, offset, data_length,u3v_conv_info,gencp_trans);
            }
            break;
        case U3V_WRITEMEM_ACK:
            dissect_u3v_write_mem_ack(u3v_telegram_tree, tvb, pinfo, offset, data_length, u3v_conv_info,gencp_trans);
            break;
        case U3V_PENDING_ACK:
            dissect_u3v_pending_ack(u3v_telegram_tree, tvb, pinfo, offset, data_length, u3v_conv_info,gencp_trans);
            break;
        default:
            proto_tree_add_item(u3v_telegram_tree, hf_u3v_payloaddata, tvb, offset, data_length, ENC_NA);
            break;
        }
        return data_length + 12;
    } else if ( stream_detected ) {
        /* this is streaming data */

        /* init this stream configuration */
        u3v_conv_info = (u3v_conv_info_t *)usb_conv_info->class_data;
        u3v_conv_info->ep_stream = usb_conv_info->endpoint;

        /* Set the protocol column */
        col_set_str(pinfo->cinfo, COL_PROTOCOL, "U3V");

        /* Clear out stuff in the info column */
        col_clear(pinfo->cinfo, COL_INFO);

        /* Adds "USB3Vision" heading to protocol tree */
        /* We will add fields to this using the u3v_tree pointer */
        ti = proto_tree_add_item(tree, proto_u3v, tvb, offset, -1, ENC_NA);
        u3v_tree = proto_item_add_subtree(ti, ett_u3v);

        if(tvb_captured_length(tvb) >=4) {
            prefix = tvb_get_letohl(tvb, offset);
            switch (prefix) {
            case U3V_STREAM_LEADER_PREFIX:
                dissect_u3v_stream_leader(u3v_tree, tvb, pinfo, usb_conv_info);
                break;
            case U3V_STREAM_TRAILER_PREFIX:
                dissect_u3v_stream_trailer(u3v_tree, tvb, pinfo, usb_conv_info);
                break;
            default:
                dissect_u3v_stream_payload(u3v_tree, tvb, pinfo, usb_conv_info);
                break;
            }
        }
        return tvb_captured_length(tvb);
    }
    return 0;
}

dissect_u3v_pending_ack(proto_tree *u3v_telegram_tree, tvbuff_t *tvb, packet_info *pinfo _U_, gint startoffset, gint length, u3v_conv_info_t *u3v_conv_info _U_, gencp_transaction_t *gencp_trans _U_)
{
    proto_item *item = NULL;
    guint offset = startoffset;

    /* Fill in Wireshark GUI Info column */
    col_append_fstr(pinfo->cinfo, COL_INFO, " %d ms", tvb_get_letohs(tvb, startoffset+2));

    item = proto_tree_add_item(u3v_telegram_tree, hf_u3v_ccd_pending_ack, tvb, startoffset, length, ENC_NA);
    u3v_telegram_tree = proto_item_add_subtree(item, ett_u3v_payload_cmd);

    /* reserved field */
    proto_tree_add_item(u3v_telegram_tree, hf_u3v_reserved, tvb, offset, 2, ENC_NA);
    offset += 2;

    proto_tree_add_item(u3v_telegram_tree, hf_u3v_time_to_completion, tvb, offset, 2, ENC_LITTLE_ENDIAN);
}

is_sysex_code(guint8 code)
{
    return (code == 0x04 || code == 0x05 || code == 0x06 || code == 0x07);
}

dissect_u3v_write_mem_cmd(proto_tree *u3v_telegram_tree, tvbuff_t *tvb, packet_info *pinfo, gint startoffset, gint length, u3v_conv_info_t *u3v_conv_info, gencp_transaction_t *gencp_trans)
{
    const gchar* address_string = NULL;
    gboolean is_custom_register = FALSE;
    guint64 addr = 0;
    guint byte_count = 0;
    proto_item *item = NULL;
    guint offset = startoffset + 8;

    addr = tvb_get_letoh64(tvb, startoffset);
    byte_count = length - 8;
    address_string = get_register_name_from_address(addr, &is_custom_register, u3v_conv_info);

    gencp_trans->address = addr;
    gencp_trans->count = byte_count;

    /* fill in Info column in Wireshark GUI */
    col_append_fstr(pinfo->cinfo, COL_INFO, "%s: %d bytes", address_string, byte_count);


    /* Subtree initialization for Payload Data: WRITEMEM_CMD */
    item = proto_tree_add_item(u3v_telegram_tree, hf_u3v_scd_writemem_cmd, tvb, startoffset, length, ENC_NA);
    u3v_telegram_tree = proto_item_add_subtree(item, ett_u3v_payload_cmd);

    if (is_known_bootstrap_register(addr, u3v_conv_info)) {
        item = proto_tree_add_uint64(u3v_telegram_tree, hf_u3v_address, tvb, startoffset, 8, addr);
        proto_item_append_text(item, " %s", address_string);
        dissect_u3v_register(addr, u3v_telegram_tree, tvb, offset, byte_count, u3v_conv_info);
    } else {
        proto_tree_add_item(u3v_telegram_tree, hf_u3v_custom_memory_addr, tvb, startoffset, 8, ENC_LITTLE_ENDIAN);
        proto_tree_add_item(u3v_telegram_tree, hf_u3v_custom_memory_data, tvb, startoffset + 8, byte_count, ENC_NA);
    }

}

dissect_usb_ms_get_max_lun(packet_info *pinfo _U_, proto_tree *tree, tvbuff_t *tvb, int offset, gboolean is_request, usb_trans_info_t *usb_trans_info _U_, usb_conv_info_t *usb_conv_info _U_)
{
    if(is_request){
        proto_tree_add_item(tree, hf_usb_ms_value, tvb, offset, 2, ENC_BIG_ENDIAN);
        offset += 2;

        proto_tree_add_item(tree, hf_usb_ms_index, tvb, offset, 2, ENC_BIG_ENDIAN);
        offset += 2;

        proto_tree_add_item(tree, hf_usb_ms_length, tvb, offset, 2, ENC_BIG_ENDIAN);
        /*offset += 2;*/
    } else {
        proto_tree_add_item(tree, hf_usb_ms_maxlun, tvb, offset, 1, ENC_BIG_ENDIAN);
        offset++;
    }
}

dissect_usb_video_processing_unit(proto_tree *tree, tvbuff_t *tvb, int offset)
{
    static const int *control_bits[] = {
        &hf_usb_vid_proc_control_D[0],
        &hf_usb_vid_proc_control_D[1],
        &hf_usb_vid_proc_control_D[2],
        &hf_usb_vid_proc_control_D[3],
        &hf_usb_vid_proc_control_D[4],
        &hf_usb_vid_proc_control_D[5],
        &hf_usb_vid_proc_control_D[6],
        &hf_usb_vid_proc_control_D[7],
        &hf_usb_vid_proc_control_D[8],
        &hf_usb_vid_proc_control_D[9],
        &hf_usb_vid_proc_control_D[10],
        &hf_usb_vid_proc_control_D[11],
        &hf_usb_vid_proc_control_D[12],
        &hf_usb_vid_proc_control_D[13],
        &hf_usb_vid_proc_control_D[14],
        &hf_usb_vid_proc_control_D[15],
        &hf_usb_vid_proc_control_D[16],
        &hf_usb_vid_proc_control_D[17],
        &hf_usb_vid_proc_control_D[18],
        NULL
    };

    DISSECTOR_ASSERT(array_length(control_bits) == (1+array_length(hf_usb_vid_proc_control_D)));

    proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_src_id, tvb, offset,   1, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(tree, hf_usb_vid_max_multiplier,        tvb, offset+1, 2, ENC_LITTLE_ENDIAN);
    offset += 3;

    offset = dissect_bmControl(tree, tvb, offset, ett_processing_controls, control_bits);

    proto_tree_add_item(tree, hf_usb_vid_iProcessing, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    ++offset;

    /* UVC 1.1 added bmVideoStandards */
    if (tvb_reported_length_remaining(tvb, offset) > 0)
    {
        static const int *standard_bits[] = {
            &hf_usb_vid_proc_standards_D[0],
            &hf_usb_vid_proc_standards_D[1],
            &hf_usb_vid_proc_standards_D[2],
            &hf_usb_vid_proc_standards_D[3],
            &hf_usb_vid_proc_standards_D[4],
            &hf_usb_vid_proc_standards_D[5],
            NULL
        };

        DISSECTOR_ASSERT(array_length(standard_bits) == (1+array_length(hf_usb_vid_proc_standards_D)));

        proto_tree_add_bitmask(tree, tvb, offset, hf_usb_vid_proc_standards,
                               ett_video_standards, standard_bits, ENC_NA);
        ++offset;
    }

    return offset;
}

dissect_usb_ms_reset(packet_info *pinfo _U_, proto_tree *tree, tvbuff_t *tvb, int offset, gboolean is_request, usb_trans_info_t *usb_trans_info _U_, usb_conv_info_t *usb_conv_info _U_)
{
    if(is_request){
        proto_tree_add_item(tree, hf_usb_ms_value, tvb, offset, 2, ENC_BIG_ENDIAN);
        offset += 2;

        proto_tree_add_item(tree, hf_usb_ms_index, tvb, offset, 2, ENC_BIG_ENDIAN);
        offset += 2;

        proto_tree_add_item(tree, hf_usb_ms_length, tvb, offset, 2, ENC_BIG_ENDIAN);
        /*offset += 2;*/
    } else {
        /* no data in reset response */
    }
}

dissect_usb_vid_interrupt(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)
{
    usb_conv_info_t *usb_conv_info;
    gint bytes_available;
    int  offset = 0;

    usb_conv_info   = (usb_conv_info_t *)data;
    bytes_available = tvb_reported_length_remaining(tvb, offset);

    col_set_str(pinfo->cinfo, COL_PROTOCOL, "USBVIDEO");

    if (bytes_available > 0)
    {
        guint8 originating_interface;
        guint8 originating_entity;

        originating_interface = tvb_get_guint8(tvb, offset) & INT_ORIGINATOR_MASK;
        proto_tree_add_item(tree, hf_usb_vid_interrupt_bStatusType, tvb, offset, 1, ENC_LITTLE_ENDIAN);
        offset++;

        originating_entity = tvb_get_guint8(tvb, offset);
        proto_tree_add_item(tree, hf_usb_vid_interrupt_bOriginator, tvb, offset, 1, ENC_LITTLE_ENDIAN);
        offset++;

        if (originating_interface == INT_VIDEOCONTROL)
        {
            guint8 control_sel;
            guint8 attribute;
            const gchar *control_name;

            proto_tree_add_item(tree, hf_usb_vid_control_interrupt_bEvent, tvb, offset, 1, ENC_LITTLE_ENDIAN);
            offset++;

            control_sel = tvb_get_guint8(tvb, offset);
            control_name = get_control_selector_name(originating_entity, control_sel, usb_conv_info);
            if (!control_name)
                control_name = "Unknown";

            proto_tree_add_uint_format_value(tree, hf_usb_vid_control_selector, tvb,
                                             offset, 1, control_sel, "%s (0x%02x)",
                                             control_name, control_sel);
            offset++;

            attribute = tvb_get_guint8(tvb, offset);
            proto_tree_add_item(tree, hf_usb_vid_interrupt_bAttribute, tvb, offset, 1, ENC_LITTLE_ENDIAN);
            offset++;

            switch (attribute)
            {
                case CONTROL_CHANGE_FAILURE:
                    proto_tree_add_item(tree, hf_usb_vid_request_error, tvb, offset, 1, ENC_LITTLE_ENDIAN);
                    offset++;
                    break;

                case CONTROL_CHANGE_INFO:
                    offset = dissect_usb_vid_control_info(tree, tvb, offset);
                    break;

                case CONTROL_CHANGE_VALUE:
                case CONTROL_CHANGE_MIN:
                case CONTROL_CHANGE_MAX:
                    dissect_usb_vid_control_value(tree, tvb, offset, attribute);
                    offset += tvb_reported_length_remaining(tvb, offset);
                    break;

                default:
                    proto_tree_add_item(tree, hf_usb_vid_value_data, tvb, offset, -1, ENC_NA);
                    offset += tvb_reported_length_remaining(tvb, offset);
                    break;
            }
        }
        else if (originating_interface == INT_VIDEOSTREAMING)
        {
            /* @todo */
        }
    }
    else
        offset = -2;

    return offset;
}

dissect_as_if_general_body(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,
        proto_tree *tree, usb_conv_info_t *usb_conv_info)
{
    audio_conv_info_t *audio_conv_info;
    gint               offset_start;

    /* the caller has already checked that usb_conv_info!=NULL */
    audio_conv_info = (audio_conv_info_t *)usb_conv_info->class_data;
    if (!audio_conv_info)
        return 0;

    offset_start = offset;

    if (audio_conv_info->ver_major==1) {
        proto_tree_add_item(tree, hf_as_if_gen_term_id,
                tvb, offset, 1, ENC_LITTLE_ENDIAN);
        offset++;
        proto_tree_add_item(tree, hf_as_if_gen_delay,
                tvb, offset, 1, ENC_LITTLE_ENDIAN);
        offset++;
        proto_tree_add_item(tree, hf_as_if_gen_format,
                tvb, offset, 2, ENC_LITTLE_ENDIAN);
        offset += 2;
    }

    return offset-offset_start;
}

dissect_usb_video_control_interface_descriptor(proto_tree *parent_tree, tvbuff_t *tvb,
                                               guint8 descriptor_len, packet_info *pinfo, usb_conv_info_t *usb_conv_info)
{
    video_conv_info_t *video_conv_info = NULL;
    video_entity_t    *entity          = NULL;
    proto_item *item          = NULL;
    proto_item *subtype_item  = NULL;
    proto_tree *tree          = NULL;
    guint8      entity_id     = 0;
    guint16     terminal_type = 0;
    int         offset        = 0;
    guint8      subtype;

    subtype = tvb_get_guint8(tvb, offset+2);

    if (parent_tree)
    {
        const gchar *subtype_str;

        subtype_str = val_to_str_ext(subtype, &vc_if_descriptor_subtypes_ext, "Unknown (0x%x)");

        tree = proto_tree_add_subtree_format(parent_tree, tvb, offset, descriptor_len,
                                   ett_descriptor_video_control, &item, "VIDEO CONTROL INTERFACE DESCRIPTOR [%s]",
                                   subtype_str);
    }

    /* Common fields */
    dissect_usb_descriptor_header(tree, tvb, offset, &vid_descriptor_type_vals_ext);
    subtype_item = proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_subtype, tvb, offset+2, 1, ENC_LITTLE_ENDIAN);
    offset += 3;

    if (subtype == VC_HEADER)
    {
        guint8 num_vs_interfaces;

        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_bcdUVC,            tvb, offset,   2, ENC_LITTLE_ENDIAN);
        proto_tree_add_item(tree, hf_usb_vid_ifdesc_wTotalLength,              tvb, offset+2, 2, ENC_LITTLE_ENDIAN);
        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_dwClockFrequency,  tvb, offset+4, 4, ENC_LITTLE_ENDIAN);

        num_vs_interfaces = tvb_get_guint8(tvb, offset+8);
        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_bInCollection,     tvb, offset+8, 1, ENC_LITTLE_ENDIAN);

        if (num_vs_interfaces > 0)
        {
            proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_baInterfaceNr, tvb, offset+9, num_vs_interfaces, ENC_NA);
        }

        offset += 9 + num_vs_interfaces;
    }
    else if ((subtype == VC_INPUT_TERMINAL) || (subtype == VC_OUTPUT_TERMINAL))
    {
        /* Fields common to input and output terminals */
        entity_id     = tvb_get_guint8(tvb, offset);
        terminal_type = tvb_get_letohs(tvb, offset+1);

        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_terminal_id,    tvb, offset,   1, ENC_LITTLE_ENDIAN);
        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_terminal_type,  tvb, offset+1, 2, ENC_LITTLE_ENDIAN);
        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_assoc_terminal, tvb, offset+3, 1, ENC_LITTLE_ENDIAN);
        offset += 4;

        if (subtype == VC_OUTPUT_TERMINAL)
        {
            proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_src_id, tvb, offset, 1, ENC_LITTLE_ENDIAN);
            ++offset;
        }

        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_iTerminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);
        ++offset;

        if (subtype == VC_INPUT_TERMINAL)
        {
            if (terminal_type == ITT_CAMERA)
            {
                offset = dissect_usb_video_camera_terminal(tree, tvb, offset);
            }
            else if (terminal_type == ITT_MEDIA_TRANSPORT_INPUT)
            {
                /* @todo */
            }
        }

        if (subtype == VC_OUTPUT_TERMINAL)
        {
            if (terminal_type == OTT_MEDIA_TRANSPORT_OUTPUT)
            {
                /* @todo */
            }
        }
    }
    else
    {
        /* Field common to extension / processing / selector / encoding units */
        entity_id = tvb_get_guint8(tvb, offset);
        proto_tree_add_item(tree, hf_usb_vid_control_ifdesc_unit_id, tvb, offset, 1, ENC_LITTLE_ENDIAN);
        ++offset;

        if (subtype == VC_PROCESSING_UNIT)
        {
            offset = dissect_usb_video_processing_unit(tree, tvb, offset);
        }
        else if (subtype == VC_SELECTOR_UNIT)
        {
            offset = dissect_usb_video_selector_unit(tree, tvb, offset);
        }
        else if (subtype == VC_EXTENSION_UNIT)
        {
            offset = dissect_usb_video_extension_unit(tree, tvb, offset);
        }
        else if (subtype == VC_ENCODING_UNIT)
        {
            /* @todo UVC 1.5 */
        }
        else
        {
            expert_add_info_format(pinfo, subtype_item, &ei_usb_vid_subtype_unknown,
                                   "Unknown VC subtype %u", subtype);
        }
    }

    /* Soak up descriptor bytes beyond those we know how to dissect */
    if (offset < descriptor_len)
    {
        proto_tree_add_item(tree, hf_usb_vid_descriptor_data, tvb, offset, descriptor_len-offset, ENC_NA);
        /* offset = descriptor_len; */
    }

    if (entity_id != 0)
        proto_item_append_text(item, " (Entity %d)", entity_id);

    if (subtype != VC_HEADER && usb_conv_info)
    {
        /* Switch to the usb_conv_info of the Video Control interface */
        usb_conv_info = get_usb_iface_conv_info(pinfo, usb_conv_info->interfaceNum);
        video_conv_info = (video_conv_info_t *)usb_conv_info->class_data;

        if (!video_conv_info)
        {
             video_conv_info = wmem_new(wmem_file_scope(), video_conv_info_t);
             video_conv_info->entities = wmem_tree_new(wmem_file_scope());
             usb_conv_info->class_data = video_conv_info;
         }
 
         entity = (video_entity_t*) wmem_tree_lookup32(video_conv_info->entities, entity_id);
        if (!entity)
        {
            entity = wmem_new(wmem_file_scope(), video_entity_t);
            entity->entityID     = entity_id;
            entity->subtype      = subtype;
            entity->terminalType = terminal_type;

            wmem_tree_insert32(video_conv_info->entities, entity_id, entity);
        }
    }

    return descriptor_len;
}

dissect_u3v_descriptors(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void *data _U_)
{
    guint8          type;
    gint            offset = 0;
    proto_item *    ti;
    proto_tree *    sub_tree;
    guint32         version;


    /* The descriptor must at least have a length and type field. */
    if (tvb_reported_length(tvb) < 2) {
        return 0;
    }

    /* skip len */
    type = tvb_get_guint8(tvb, 1);

    /* Check for U3V device info descriptor. */
    if (type != DESCRIPTOR_TYPE_U3V_INTERFACE) {
        return 0;
    }

    ti = proto_tree_add_item(tree, hf_u3v_device_info_descriptor, tvb, offset, -1, ENC_NA);
    tree = proto_item_add_subtree(ti, ett_u3v_device_info_descriptor);

    /* bLength */
    proto_tree_add_item(tree, hf_u3v_device_info_descriptor_bLength, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset++;

    /* bDescriptorType */
    ti = proto_tree_add_item(tree, hf_u3v_device_info_descriptor_bDescriptorType, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    proto_item_append_text(ti, " (U3V INTERFACE)");
    offset++;

    /* bDescriptorSubtype */
    proto_tree_add_item(tree, hf_u3v_device_info_descriptor_bDescriptorSubtype, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset++;

    /* bGenCPVersion */
    if (!tvb_bytes_exist(tvb, offset, 4)) {
        /* Version not completely in buffer -> break dissection here. */
        return offset;
    }
    version = tvb_get_letohl(tvb, offset);
    ti = proto_tree_add_item(tree, hf_u3v_device_info_descriptor_bGenCPVersion, tvb, offset, 4, ENC_NA);
    proto_item_append_text(ti, ": %u.%u", version >> 16, version & 0xFFFF);
    sub_tree = proto_item_add_subtree(ti, ett_u3v_device_info_descriptor_gencp_version);
    proto_tree_add_item(sub_tree, hf_u3v_device_info_descriptor_bGenCPVersion_minor, tvb, offset, 4, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(sub_tree, hf_u3v_device_info_descriptor_bGenCPVersion_major, tvb, offset, 4, ENC_LITTLE_ENDIAN);
    offset += 4;

    /* bU3VVersion */
    if (!tvb_bytes_exist(tvb, offset, 4)) {
        /* Version not completely in buffer -> break dissection here. */
        return offset;
    }
    version = tvb_get_letohl(tvb, offset);
    ti = proto_tree_add_item(tree, hf_u3v_device_info_descriptor_bU3VVersion, tvb, offset, 4, ENC_NA);
    proto_item_append_text(ti, ": %u.%u", version >> 16, version & 0xFFFF);
    sub_tree = proto_item_add_subtree(ti, ett_u3v_device_info_descriptor_u3v_version);
    proto_tree_add_item(sub_tree, hf_u3v_device_info_descriptor_bU3VVersion_minor, tvb, offset, 4, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(sub_tree, hf_u3v_device_info_descriptor_bU3VVersion_major, tvb, offset, 4, ENC_LITTLE_ENDIAN);
    offset += 4;

    /* iDeviceGUID */
    proto_tree_add_item(tree, hf_u3v_device_info_descriptor_iDeviceGUID, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset++;

    /* iVendorName */
    proto_tree_add_item(tree, hf_u3v_device_info_descriptor_iVendorName, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset++;

    /* iModelName */
    proto_tree_add_item(tree, hf_u3v_device_info_descriptor_iModelName, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset++;

    /* iFamilyName */
    proto_tree_add_item(tree, hf_u3v_device_info_descriptor_iFamilyName, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset++;

    /* iDeviceVersion */
    proto_tree_add_item(tree, hf_u3v_device_info_descriptor_iDeviceVersion, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset++;

    /* iManufacturerInfo */
    proto_tree_add_item(tree, hf_u3v_device_info_descriptor_iManufacturerInfo, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset++;

    /* iSerialNumber */
    proto_tree_add_item(tree, hf_u3v_device_info_descriptor_iSerialNumber, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset++;

    /* iUserDefinedName */
    proto_tree_add_item(tree, hf_u3v_device_info_descriptor_iUserDefinedName, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset++;

    /* bmSpeedSupport */
    proto_tree_add_bitmask(tree, tvb, offset, hf_u3v_device_info_descriptor_bmSpeedSupport,
                           ett_u3v_device_info_descriptor_speed_support, speed_support_fields, ENC_LITTLE_ENDIAN);

    offset++;

    return offset;
}

proto_reg_handoff_usb_audio(void)
{
    dissector_handle_t usb_audio_bulk_handle, usb_audio_descr_handle;

    usb_audio_descr_handle = create_dissector_handle(
            dissect_usb_audio_descriptor, proto_usb_audio);
    dissector_add_uint("usb.descriptor", IF_CLASS_AUDIO, usb_audio_descr_handle);

    usb_audio_bulk_handle = find_dissector("usbaudio");
    dissector_add_uint("usb.bulk", IF_CLASS_AUDIO, usb_audio_bulk_handle);

    sysex_handle = find_dissector_add_dependency("sysex", proto_usb_audio);
}

dissect_usb_vid_control_info(proto_tree *tree, tvbuff_t *tvb, int offset)
{
    static const int *capability_bits[] = {
        &hf_usb_vid_control_info_D[0],
        &hf_usb_vid_control_info_D[1],
        &hf_usb_vid_control_info_D[2],
        &hf_usb_vid_control_info_D[3],
        &hf_usb_vid_control_info_D[4],
        &hf_usb_vid_control_info_D[5],
        &hf_usb_vid_control_info_D[6],
        NULL
    };

    DISSECTOR_ASSERT(array_length(capability_bits) == (1+array_length(hf_usb_vid_control_info_D)));

    proto_tree_add_bitmask(tree, tvb, offset, hf_usb_vid_control_info,
                           ett_control_capabilities, capability_bits, ENC_NA);

    return offset+1;
}

dissect_u3v_event_cmd(proto_tree *u3v_telegram_tree, tvbuff_t *tvb, packet_info *pinfo, gint startoffset, gint length)
{
    gint32 eventid;
    gint offset = startoffset;
    proto_item *item = NULL;

    /* Get event ID */
    eventid = tvb_get_letohs(tvb, offset + 2);

    /* fill in Info column in Wireshark GUI */
    col_append_fstr(pinfo->cinfo, COL_INFO, "[ID: 0x%04X]", eventid);


    item = proto_tree_add_item(u3v_telegram_tree, hf_u3v_scd_event_cmd, tvb, offset, length, ENC_NA);
    u3v_telegram_tree = proto_item_add_subtree(item, ett_u3v_payload_cmd);

    offset += 2;

    /* Use range to determine type of event */
    if ((eventid >= 0x0000) && (eventid <= 0x8000)) {
        /* Standard ID */
        proto_tree_add_item(u3v_telegram_tree, hf_u3v_eventcmd_id, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    } else if ((eventid >= 0x8001) && (eventid <= 0x8FFF)) {
        /* Error */
        proto_tree_add_item(u3v_telegram_tree, hf_u3v_eventcmd_error_id, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    } else if ((eventid >= 0x9000) && (eventid <= 0xFFFF)) {
        /* Device specific */
        proto_tree_add_item(u3v_telegram_tree, hf_u3v_eventcmd_device_specific_id, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    }
    offset += 2;

    /* Timestamp (64 bit) associated with event */
    proto_tree_add_item(u3v_telegram_tree, hf_u3v_eventcmd_timestamp, tvb, offset, 8, ENC_LITTLE_ENDIAN);
    offset += 8;

    /* Data */
    if (length > offset ) {
        proto_tree_add_item(u3v_telegram_tree, hf_u3v_eventcmd_data, tvb, offset, length - 12, ENC_NA);
    }
}

proto_reg_handoff_u3v(void)
{
    dissector_handle_t u3v_handle = NULL;
    dissector_handle_t u3v_descr_handle = NULL;

    u3v_handle = find_dissector("u3v");
    dissector_add_uint("usb.bulk", IF_CLASS_MISCELLANEOUS, u3v_handle);
    heur_dissector_add("usb.bulk", dissect_u3v_heur, "USB3Vision Protocol", "u3v", proto_u3v,HEURISTIC_ENABLE);
    u3v_descr_handle = create_dissector_handle(dissect_u3v_descriptors, proto_u3v);
    dissector_add_uint("usb.descriptor", IF_CLASS_MISCELLANEOUS, u3v_descr_handle);
}

proto_register_u3v(void)
{
    static gint *ett[] = {
        &ett_u3v,
        &ett_u3v_cmd,
        &ett_u3v_flags,
        &ett_u3v_ack,
        &ett_u3v_payload_cmd,
        &ett_u3v_payload_ack,
        &ett_u3v_payload_ack_subtree,
        &ett_u3v_payload_cmd_subtree,
        &ett_u3v_bootstrap_fields,
        &ett_u3v_stream_leader,
        &ett_u3v_stream_trailer,
        &ett_u3v_stream_payload,
        &ett_u3v_device_info_descriptor,
        &ett_u3v_device_info_descriptor_speed_support,
        &ett_u3v_device_info_descriptor_gencp_version,
        &ett_u3v_device_info_descriptor_u3v_version,
    };

    proto_u3v = proto_register_protocol("USB 3 Vision", "U3V", "u3v");
    proto_register_field_array(proto_u3v, hf, array_length(hf));
    proto_register_subtree_array(ett, array_length(ett));
    register_dissector("u3v", dissect_u3v, proto_u3v);
}

dissect_as_if_format_type_body(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,
        proto_tree *tree, usb_conv_info_t *usb_conv_info)
{
    audio_conv_info_t *audio_conv_info;
    gint               offset_start;
    guint8 SamFreqType;
    guint8 format_type;

    /* the caller has already checked that usb_conv_info!=NULL */
    audio_conv_info = (audio_conv_info_t *)usb_conv_info->class_data;
    if (!audio_conv_info)
        return 0;

    offset_start = offset;

    proto_tree_add_item(tree, hf_as_if_ft_formattype, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    format_type = tvb_get_guint8(tvb, offset);
    offset++;


    switch(format_type){
        case 1:
            proto_tree_add_item(tree, hf_as_if_ft_nrchannels, tvb, offset, 1, ENC_LITTLE_ENDIAN);
            offset += 1;

            proto_tree_add_item(tree, hf_as_if_ft_subframesize, tvb, offset, 1, ENC_LITTLE_ENDIAN);
            offset += 1;

            proto_tree_add_item(tree, hf_as_if_ft_bitresolution, tvb, offset, 1, ENC_LITTLE_ENDIAN);
            offset += 1;

            proto_tree_add_item(tree, hf_as_if_ft_samfreqtype, tvb, offset, 1, ENC_LITTLE_ENDIAN);
            SamFreqType = tvb_get_guint8(tvb, offset);
            offset++;

            if(SamFreqType == 0){
                proto_tree_add_item(tree, hf_as_if_ft_lowersamfreq, tvb, offset, 3, ENC_LITTLE_ENDIAN);
                offset += 3;
                proto_tree_add_item(tree, hf_as_if_ft_uppersamfreq, tvb, offset, 3, ENC_LITTLE_ENDIAN);
                offset += 3;
            }else {
                while(SamFreqType){
                    proto_tree_add_item(tree, hf_as_if_ft_samfreq, tvb, offset, 3, ENC_LITTLE_ENDIAN);
                    offset += 3;
                    SamFreqType--;
                }
            }
        break;
        case 2:
            proto_tree_add_item(tree, hf_as_if_ft_maxbitrate, tvb, offset, 2, ENC_LITTLE_ENDIAN);
            offset += 2;

            proto_tree_add_item(tree, hf_as_if_ft_samplesperframe, tvb, offset, 2, ENC_LITTLE_ENDIAN);
            offset += 2;

            proto_tree_add_item(tree, hf_as_if_ft_samfreqtype, tvb, offset, 1, ENC_LITTLE_ENDIAN);
            SamFreqType = tvb_get_guint8(tvb, offset);
            offset++;

            if(SamFreqType == 0){
                proto_tree_add_item(tree, hf_as_if_ft_lowersamfreq, tvb, offset, 3, ENC_LITTLE_ENDIAN);
                offset += 3;
                proto_tree_add_item(tree, hf_as_if_ft_uppersamfreq, tvb, offset, 3, ENC_LITTLE_ENDIAN);
                offset += 3;
            }else {
                while(SamFreqType){
                    proto_tree_add_item(tree, hf_as_if_ft_samfreq, tvb, offset, 3, ENC_LITTLE_ENDIAN);
                    offset += 3;
                    SamFreqType--;
                }
            }
        break;
        default:
        break;
    }

    return offset-offset_start;
}

dissect_usb_video_streaming_input_header(proto_tree *tree, tvbuff_t *tvb, int offset)
{
    guint8 num_formats;
    guint8 bm_size;

    static const int *info_bits[] = {
        &hf_usb_vid_streaming_info_D[0],
        NULL
    };
    static const int *control_bits[] = {
        &hf_usb_vid_streaming_control_D[0],
        &hf_usb_vid_streaming_control_D[1],
        &hf_usb_vid_streaming_control_D[2],
        &hf_usb_vid_streaming_control_D[3],
        &hf_usb_vid_streaming_control_D[4],
        &hf_usb_vid_streaming_control_D[5],
        NULL
    };

    DISSECTOR_ASSERT(array_length(control_bits) == (1+array_length(hf_usb_vid_streaming_control_D)));

    num_formats = tvb_get_guint8(tvb, offset);
    proto_tree_add_item(tree, hf_usb_vid_streaming_ifdesc_bNumFormats, tvb, offset,   1, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(tree, hf_usb_vid_ifdesc_wTotalLength,          tvb, offset+1, 2, ENC_LITTLE_ENDIAN);
    offset += 3;

    dissect_usb_endpoint_address(tree, tvb, offset);
    offset++;

    proto_tree_add_bitmask(tree, tvb, offset, hf_usb_vid_streaming_bmInfo,
                           ett_streaming_info, info_bits, ENC_NA);

    proto_tree_add_item(tree, hf_usb_vid_streaming_terminal_link,        tvb, offset+1, 1, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(tree, hf_usb_vid_streaming_still_capture_method, tvb, offset+2, 1, ENC_LITTLE_ENDIAN);
    offset += 3;

    proto_tree_add_item(tree, hf_usb_vid_streaming_trigger_support,      tvb, offset,   1, ENC_NA);
    if (tvb_get_guint8(tvb, offset) > 0)
    {
        proto_tree_add_item(tree, hf_usb_vid_streaming_trigger_usage,    tvb, offset+1, 1, ENC_LITTLE_ENDIAN);
    }
    else
    {
        proto_tree_add_uint_format_value(tree, hf_usb_vid_streaming_trigger_usage, tvb, offset+1, 1, 0, "Not applicable");
    }

    offset += 2;

    /* NOTE: Can't use dissect_bmControl here because there's only one size
     *       field for (potentially) multiple bmControl fields
     */
    bm_size = tvb_get_guint8(tvb, offset);
    proto_tree_add_item(tree, hf_usb_vid_bControlSize, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    ++offset;

    if (bm_size > 0)
    {
        guint8 i;
        for (i=0; i<num_formats; ++i)
        {
            proto_tree_add_bitmask_len(tree, tvb, offset, bm_size, hf_usb_vid_bmControl,
                                       ett_streaming_controls, control_bits, &ei_usb_vid_bitmask_len,
                                       ENC_LITTLE_ENDIAN);
            offset += bm_size;
        }
    }

    return offset;
}

midi_data_reassemble_cleanup(void)
{
    reassembly_table_destroy(&midi_data_reassembly_table);
}

get_control_selector_name(guint8 entity_id, guint8 control_sel, usb_conv_info_t *usb_conv_info)
{
    const gchar      *control_name = NULL;
    value_string_ext *selectors = NULL;

    selectors = get_control_selector_values(entity_id, usb_conv_info);

    if (selectors)
        control_name = try_val_to_str_ext(control_sel, selectors);

    return control_name;
}

dissect_u3v_stream_payload(proto_tree *u3v_telegram_tree, tvbuff_t *tvb, packet_info *pinfo, usb_conv_info_t *usb_conv_info _U_)
{
    proto_item *item = NULL;

    /* Subtree initialization for Stream Leader */
    item = proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_payload, tvb, 0, -1, ENC_NA);
    u3v_telegram_tree = proto_item_add_subtree(item, ett_u3v_stream_payload);

    /* Data */
    proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_data, tvb, 0, -1, ENC_NA);

    /* Add payload type to information string */
    col_append_fstr(pinfo->cinfo, COL_INFO, "Stream Payload");
}

dissect_usb_vid_descriptor(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)
{
    int    offset = 0;
    guint8 descriptor_len;
    guint8 descriptor_type;
    gint   bytes_available;
    usb_conv_info_t  *usb_conv_info = (usb_conv_info_t *)data;

    tvbuff_t         *desc_tvb;

    descriptor_len  = tvb_get_guint8(tvb, offset);
    descriptor_type = tvb_get_guint8(tvb, offset+1);

    bytes_available = tvb_captured_length_remaining(tvb, offset);
    desc_tvb = tvb_new_subset(tvb, 0, bytes_available, descriptor_len);

    if (descriptor_type == CS_ENDPOINT)
    {
        offset = dissect_usb_video_endpoint_descriptor(tree, desc_tvb,
                                                       descriptor_len);
    }
    else if (descriptor_type == CS_INTERFACE)
    {
        if (usb_conv_info && usb_conv_info->interfaceSubclass == SC_VIDEOCONTROL)
        {
            offset = dissect_usb_video_control_interface_descriptor(tree, desc_tvb,
                                                                    descriptor_len,
                                                                    pinfo, usb_conv_info);
        }
        else if (usb_conv_info && usb_conv_info->interfaceSubclass == SC_VIDEOSTREAMING)
        {
            offset = dissect_usb_video_streaming_interface_descriptor(tree, desc_tvb,
                                                                      descriptor_len);
        }
    }
    /* else not something we recognize, just return offset = 0 */

    return offset;
}

dissect_u3v_stream_leader(proto_tree *u3v_telegram_tree, tvbuff_t *tvb, packet_info *pinfo, usb_conv_info_t *usb_conv_info _U_)
{
    guint32 offset = 0;
    guint32 payload_type = 0;
    guint64 block_id = 0;
    proto_item *item = NULL;

    /* Subtree initialization for Stream Leader */
    item = proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_leader, tvb, 0, -1, ENC_NA);
    u3v_telegram_tree = proto_item_add_subtree(item, ett_u3v_stream_leader);

    /* Add the prefix code: */
    proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_prefix, tvb, offset, 4, ENC_LITTLE_ENDIAN);
    offset += 4;

    /* reserved field */
    proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_reserved, tvb, offset, 2, ENC_NA);
    offset += 2;

    /* leader size */
    proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_leader_size, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;

    /* block id */
    block_id = tvb_get_letoh64(tvb, offset);
    proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_block_id, tvb, offset, 8, ENC_LITTLE_ENDIAN);
    offset += 8;

    /* reserved field */
    proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_reserved, tvb, offset, 2, ENC_NA);
    offset += 2;

    /* payload type */
    payload_type = tvb_get_letohs(tvb, offset);
    proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_payload_type, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;

    /* Add payload type to information string */
    col_append_fstr(pinfo->cinfo, COL_INFO, "Stream Leader  [ Block ID: %" G_GINT64_MODIFIER "u , Type %s]",
                    block_id,
                    val_to_str(payload_type, payload_type_names, "Unknown Payload Type"));

    if (payload_type == U3V_STREAM_PAYLOAD_IMAGE ||
        payload_type == U3V_STREAM_PAYLOAD_IMAGE_EXT_CHUNK ||
        payload_type == U3V_STREAM_PAYLOAD_CHUNK) {
        /* timestamp */
        proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_timestamp, tvb, offset, 8, ENC_LITTLE_ENDIAN);
        offset += 8;
    }

    if (payload_type == U3V_STREAM_PAYLOAD_IMAGE ||
        payload_type == U3V_STREAM_PAYLOAD_IMAGE_EXT_CHUNK ) {
        /* pixel format */
        proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_pixel_format, tvb, offset, 4, ENC_LITTLE_ENDIAN);
        offset += 4;

        /* size_x */
        proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_size_x, tvb, offset, 4, ENC_LITTLE_ENDIAN);
        offset += 4;

        /* size_y */
        proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_size_y, tvb, offset, 4, ENC_LITTLE_ENDIAN);
        offset += 4;

        /* offset_x */
        proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_offset_x, tvb, offset, 4, ENC_LITTLE_ENDIAN);
        offset += 4;

        /* offset_x */
        proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_offset_y, tvb, offset, 4, ENC_LITTLE_ENDIAN);
        offset += 4;

        /* padding_x */
        proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_padding_x, tvb, offset, 2, ENC_LITTLE_ENDIAN);
        /* offset += 2; */

        /* reserved field */
        proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_reserved, tvb, offset, 2, ENC_NA);
        /* offset += 2; */
    }
}

dissect_usb_vid_probe(proto_tree *parent_tree, tvbuff_t *tvb, int offset)
{
    proto_tree *tree;

    static const int *hint_bits[] = {
        &hf_usb_vid_probe_hint_D[0],
        &hf_usb_vid_probe_hint_D[1],
        &hf_usb_vid_probe_hint_D[2],
        &hf_usb_vid_probe_hint_D[3],
        &hf_usb_vid_probe_hint_D[4],
        NULL
    };

    DISSECTOR_ASSERT(array_length(hint_bits) == (1+array_length(hf_usb_vid_probe_hint_D)));

    tree = proto_tree_add_subtree(parent_tree, tvb, offset, -1, ett_video_probe, NULL, "Probe/Commit Info");

    proto_tree_add_bitmask(tree, tvb, offset, hf_usb_vid_probe_hint,
                           ett_probe_hint, hint_bits, ENC_LITTLE_ENDIAN);

    proto_tree_add_item(tree, hf_usb_vid_format_index,         tvb, offset+2,  1, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(tree, hf_usb_vid_frame_index,          tvb, offset+3,  1, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(tree, hf_usb_vid_frame_interval,       tvb, offset+4,  4, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(tree, hf_usb_vid_probe_key_frame_rate, tvb, offset+8,  2, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(tree, hf_usb_vid_probe_p_frame_rate,   tvb, offset+10, 2, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(tree, hf_usb_vid_probe_comp_quality,   tvb, offset+12, 2, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(tree, hf_usb_vid_probe_comp_window,    tvb, offset+14, 2, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(tree, hf_usb_vid_probe_delay,          tvb, offset+16, 2, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(tree, hf_usb_vid_probe_max_frame_sz,   tvb, offset+18, 4, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(tree, hf_usb_vid_probe_max_payload_sz, tvb, offset+22, 4, ENC_LITTLE_ENDIAN);
    offset += 26;

    /* UVC 1.1 fields */
    if (tvb_reported_length_remaining(tvb, offset) > 0)
    {
        static const int *framing_bits[] = {
            &hf_usb_vid_probe_framing_D[0],
            &hf_usb_vid_probe_framing_D[1],
            NULL
        };

        DISSECTOR_ASSERT(array_length(framing_bits) == (1+array_length(hf_usb_vid_probe_framing_D)));

        proto_tree_add_item(tree, hf_usb_vid_probe_clock_freq,     tvb, offset, 4, ENC_LITTLE_ENDIAN);
        offset += 4;

        proto_tree_add_bitmask(tree, tvb, offset, hf_usb_vid_probe_framing,
                               ett_probe_framing, framing_bits, ENC_NA);
        offset++;

        proto_tree_add_item(tree, hf_usb_vid_probe_preferred_ver, tvb, offset,   1, ENC_LITTLE_ENDIAN);
        proto_tree_add_item(tree, hf_usb_vid_probe_min_ver,       tvb, offset+1, 1, ENC_LITTLE_ENDIAN);
        proto_tree_add_item(tree, hf_usb_vid_probe_max_ver,       tvb, offset+2, 1, ENC_LITTLE_ENDIAN);
        offset += 3;
    }

    return offset;
}

dissect_u3v_register_bases(guint64 addr, tvbuff_t *tvb, gint offset, u3v_conv_info_t * u3v_conv_info)
{
    if ( addr < 0x10000 ) {
        switch (addr) {
        case U3V_ABRM_SBRM_ADDRESS:
            u3v_conv_info->sbrm_addr = tvb_get_letoh64(tvb, offset);
            break;
        case U3V_ABRM_MANIFEST_TABLE_ADDRESS:
            u3v_conv_info->manifest_addr = tvb_get_letoh64(tvb, offset);
            break;
        }
    }
    if ( u3v_conv_info->sbrm_addr != 0 &&  (addr >= u3v_conv_info->sbrm_addr)) {
        addr -= u3v_conv_info->sbrm_addr;
        switch(addr) {
        case U3V_SBRM_SIRM_ADDRESS:
            u3v_conv_info->sirm_addr = tvb_get_letoh64(tvb, offset);
            break;
        case U3V_SBRM_EIRM_ADDRESS:
            u3v_conv_info->eirm_addr = tvb_get_letoh64(tvb, offset);
            break;
        case U3V_SBRM_IIDC2_ADDRESS:
            u3v_conv_info->iidc2_addr = tvb_get_letoh64(tvb, offset);
            break;
        }
    }
}

dissect_usb_ms_bulk(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree, void* data)
{
    usb_conv_info_t *usb_conv_info;
    usb_ms_conv_info_t *usb_ms_conv_info;
    proto_tree *tree;
    proto_item *ti;
    guint32 signature=0;
    int offset=0;
    gboolean is_request;
    itl_nexus_t *itl;
    itlq_nexus_t *itlq;

    /* Reject the packet if data is NULL */
    if (data == NULL)
        return 0;
    usb_conv_info = (usb_conv_info_t *)data;

    /* verify that we do have a usb_ms_conv_info */
    usb_ms_conv_info=(usb_ms_conv_info_t *)usb_conv_info->class_data;
    if(!usb_ms_conv_info){
        usb_ms_conv_info=wmem_new(wmem_file_scope(), usb_ms_conv_info_t);
         usb_ms_conv_info->itl=wmem_tree_new(wmem_file_scope());
         usb_ms_conv_info->itlq=wmem_tree_new(wmem_file_scope());
         usb_conv_info->class_data=usb_ms_conv_info;
     }
 
     is_request=(pinfo->srcport==NO_ENDPOINT);
 
     col_set_str(pinfo->cinfo, COL_PROTOCOL, "USBMS");

    col_clear(pinfo->cinfo, COL_INFO);


    ti = proto_tree_add_protocol_format(parent_tree, proto_usb_ms, tvb, 0, -1, "USB Mass Storage");
    tree = proto_item_add_subtree(ti, ett_usb_ms);

    signature=tvb_get_letohl(tvb, offset);


    /*
     * SCSI CDB inside CBW
     */
    if(is_request&&(signature==0x43425355)&&(tvb_reported_length(tvb)==31)){
        tvbuff_t *cdb_tvb;
        int cdbrlen, cdblen;
        guint8 lun, flags;
        guint32 datalen;

        /* dCBWSignature */
        proto_tree_add_item(tree, hf_usb_ms_dCBWSignature, tvb, offset, 4, ENC_LITTLE_ENDIAN);
        offset+=4;

        /* dCBWTag */
        proto_tree_add_item(tree, hf_usb_ms_dCBWTag, tvb, offset, 4, ENC_LITTLE_ENDIAN);
        offset+=4;

        /* dCBWDataTransferLength */
        proto_tree_add_item(tree, hf_usb_ms_dCBWDataTransferLength, tvb, offset, 4, ENC_LITTLE_ENDIAN);
        datalen=tvb_get_letohl(tvb, offset);
        offset+=4;

        /* dCBWFlags */
        proto_tree_add_item(tree, hf_usb_ms_dCBWFlags, tvb, offset, 1, ENC_LITTLE_ENDIAN);
        flags=tvb_get_guint8(tvb, offset);
        offset+=1;

        /* dCBWLUN */
        proto_tree_add_item(tree, hf_usb_ms_dCBWTarget, tvb, offset, 1, ENC_LITTLE_ENDIAN);
        proto_tree_add_item(tree, hf_usb_ms_dCBWLUN, tvb, offset, 1, ENC_LITTLE_ENDIAN);
        lun=tvb_get_guint8(tvb, offset)&0x0f;
        offset+=1;

        /* make sure we have a ITL structure for this LUN */
        itl=(itl_nexus_t *)wmem_tree_lookup32(usb_ms_conv_info->itl, lun);
        if(!itl){
            itl=wmem_new(wmem_file_scope(), itl_nexus_t);
            itl->cmdset=0xff;
            itl->conversation=NULL;
            wmem_tree_insert32(usb_ms_conv_info->itl, lun, itl);
        }

        /* make sure we have an ITLQ structure for this LUN/transaction */
        itlq=(itlq_nexus_t *)wmem_tree_lookup32(usb_ms_conv_info->itlq, pinfo->num);
        if(!itlq){
            itlq=wmem_new(wmem_file_scope(), itlq_nexus_t);
            itlq->lun=lun;
            itlq->scsi_opcode=0xffff;
            itlq->task_flags=0;
            if(datalen){
                if(flags&0x80){
                    itlq->task_flags|=SCSI_DATA_READ;
                } else {
                    itlq->task_flags|=SCSI_DATA_WRITE;
                }
            }
            itlq->data_length=datalen;
            itlq->bidir_data_length=0;
            itlq->fc_time=pinfo->abs_ts;
            itlq->first_exchange_frame=pinfo->num;
            itlq->last_exchange_frame=0;
            itlq->flags=0;
            itlq->alloc_len=0;
            itlq->extra_data=NULL;
            wmem_tree_insert32(usb_ms_conv_info->itlq, pinfo->num, itlq);
        }

        /* dCBWCBLength */
        proto_tree_add_item(tree, hf_usb_ms_dCBWCBLength, tvb, offset, 1, ENC_LITTLE_ENDIAN);
        cdbrlen=tvb_get_guint8(tvb, offset)&0x1f;
        offset+=1;

        cdblen=cdbrlen;
        if(cdblen>tvb_captured_length_remaining(tvb, offset)){
            cdblen=tvb_captured_length_remaining(tvb, offset);
        }
        if(cdblen){
            cdb_tvb=tvb_new_subset(tvb, offset, cdblen, cdbrlen);
            dissect_scsi_cdb(cdb_tvb, pinfo, parent_tree, SCSI_DEV_UNKNOWN, itlq, itl);
        }
        return tvb_captured_length(tvb);
    }


    /*
     * SCSI RESPONSE inside CSW
     */
    if((!is_request)&&(signature==0x53425355)&&(tvb_reported_length(tvb)==13)){
        guint8 status;

        /* dCSWSignature */
        proto_tree_add_item(tree, hf_usb_ms_dCSWSignature, tvb, offset, 4, ENC_LITTLE_ENDIAN);
        offset+=4;

        /* dCSWTag */
        proto_tree_add_item(tree, hf_usb_ms_dCBWTag, tvb, offset, 4, ENC_LITTLE_ENDIAN);
        offset+=4;

        /* dCSWDataResidue */
        proto_tree_add_item(tree, hf_usb_ms_dCSWDataResidue, tvb, offset, 4, ENC_LITTLE_ENDIAN);
        offset+=4;

        /* dCSWStatus */
        proto_tree_add_item(tree, hf_usb_ms_dCSWStatus, tvb, offset, 1, ENC_LITTLE_ENDIAN);
        status=tvb_get_guint8(tvb, offset);
        /*offset+=1;*/

        itlq=(itlq_nexus_t *)wmem_tree_lookup32_le(usb_ms_conv_info->itlq, pinfo->num);
        if(!itlq){
            return tvb_captured_length(tvb);
        }
        itlq->last_exchange_frame=pinfo->num;

        itl=(itl_nexus_t *)wmem_tree_lookup32(usb_ms_conv_info->itl, itlq->lun);
        if(!itl){
            return tvb_captured_length(tvb);
        }

        if(!status){
            dissect_scsi_rsp(tvb, pinfo, parent_tree, itlq, itl, 0);
        } else {
            /* just send "check condition" */
            dissect_scsi_rsp(tvb, pinfo, parent_tree, itlq, itl, 0x02);
        }
        return tvb_captured_length(tvb);
    }

    /*
     * Ok it was neither CDB not STATUS so just assume it is either data in/out
     */
    itlq=(itlq_nexus_t *)wmem_tree_lookup32_le(usb_ms_conv_info->itlq, pinfo->num);
    if(!itlq){
        return tvb_captured_length(tvb);
    }

    itl=(itl_nexus_t *)wmem_tree_lookup32(usb_ms_conv_info->itl, itlq->lun);
    if(!itl){
        return tvb_captured_length(tvb);
    }

    dissect_scsi_payload(tvb, pinfo, parent_tree, is_request, itlq, itl, 0);
    return tvb_captured_length(tvb);
}

dissect_usb_video_colorformat(proto_tree *tree, tvbuff_t *tvb, int offset)
{
    proto_tree_add_item(tree, hf_usb_vid_color_primaries,          tvb, offset,   1, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(tree, hf_usb_vid_transfer_characteristics, tvb, offset+1, 1, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(tree, hf_usb_vid_matrix_coefficients,      tvb, offset+2, 1, ENC_LITTLE_ENDIAN);
    offset +=3;

    return offset;
}

get_register_name_from_address(guint64 addr, gboolean* is_custom_register, u3v_conv_info_t * u3v_conv_info)
{
    const gchar* address_string = NULL;
    guint32 offset_address;

    if (is_custom_register != NULL) {
        *is_custom_register = FALSE;
    }

    /* check if this is the access to one of the base address registers */
    if ( addr < 0x10000 ) {
        offset_address = (guint32)addr;
        address_string = try_val_to_str(offset_address, bootstrap_register_names_abrm);
    }
    if ( u3v_conv_info && u3v_conv_info->sbrm_addr != 0 &&  (addr >= u3v_conv_info->sbrm_addr)) {
        offset_address = (guint32)( addr - u3v_conv_info->sbrm_addr);
        address_string = try_val_to_str(offset_address, bootstrap_register_names_sbrm);
    }
    if ( u3v_conv_info && u3v_conv_info->sirm_addr != 0 &&  (addr >= u3v_conv_info->sirm_addr)) {
        offset_address = (guint32)( addr - u3v_conv_info->sirm_addr);
        address_string = try_val_to_str(offset_address, bootstrap_register_names_sirm);
    }
    if ( u3v_conv_info && u3v_conv_info->eirm_addr != 0 &&  (addr >= u3v_conv_info->eirm_addr)) {
        offset_address = (guint32)( addr - u3v_conv_info->eirm_addr);
        address_string = try_val_to_str(offset_address, bootstrap_register_names_eirm);
    }

    if (!address_string) {
        address_string = wmem_strdup_printf(wmem_packet_scope(), "[Addr:0x%016" G_GINT64_MODIFIER "X]", addr);
        if (is_custom_register != NULL) {
            *is_custom_register = TRUE;
        }
    }

    return address_string;
}

dissect_u3v_write_mem_ack(proto_tree *u3v_telegram_tree, tvbuff_t *tvb, packet_info *pinfo, gint startoffset, gint length, u3v_conv_info_t *u3v_conv_info , gencp_transaction_t * gencp_trans)
{
    guint64 addr = 0;
    gint offset = startoffset;
    const gchar *address_string = NULL;
    gboolean is_custom_register = FALSE;
    gboolean have_address = (0 != gencp_trans->cmd_frame);
    proto_item *item = NULL;

    addr = gencp_trans->address;
    if (have_address) {
        address_string = get_register_name_from_address(addr, &is_custom_register, u3v_conv_info);

        /* Fill in Wireshark GUI Info column */
        col_append_fstr(pinfo->cinfo, COL_INFO, "%s", address_string);
    }

    item = proto_tree_add_item(u3v_telegram_tree, hf_u3v_scd_writemem_ack, tvb, startoffset, length, ENC_NA);
    u3v_telegram_tree = proto_item_add_subtree(item, ett_u3v_payload_cmd);

    if (have_address) {
            item = proto_tree_add_uint64(u3v_telegram_tree, hf_u3v_address, tvb, 0,0 , addr);
            PROTO_ITEM_SET_GENERATED(item);
        }
    /* Number of bytes successfully written to the device register map */
    if ( length == 4 ) {

        /* reserved field */
        proto_tree_add_item(u3v_telegram_tree, hf_u3v_reserved, tvb, offset, 2, ENC_NA);
        offset += 2;

        proto_tree_add_item(u3v_telegram_tree, hf_u3v_count, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    }
}

dissect_usb_video_streaming_interface_descriptor(proto_tree *parent_tree, tvbuff_t *tvb,
                                                 guint8 descriptor_len)
{
    proto_tree  *tree;
    int          offset = 0;
    const gchar *subtype_str;
    guint8       subtype;

    subtype = tvb_get_guint8(tvb, offset+2);

    subtype_str = val_to_str_ext(subtype, &vs_if_descriptor_subtypes_ext, "Unknown (0x%x)");
    tree = proto_tree_add_subtree_format(parent_tree, tvb, offset, descriptor_len,
            ett_descriptor_video_streaming, NULL, "VIDEO STREAMING INTERFACE DESCRIPTOR [%s]",
            subtype_str);

    dissect_usb_descriptor_header(tree, tvb, offset, &vid_descriptor_type_vals_ext);
    proto_tree_add_item(tree, hf_usb_vid_streaming_ifdesc_subtype, tvb, offset+2, 1, ENC_LITTLE_ENDIAN);
    offset += 3;

    switch (subtype)
    {
        case VS_INPUT_HEADER:
            offset = dissect_usb_video_streaming_input_header(tree, tvb, offset);
            break;

        case VS_FORMAT_UNCOMPRESSED:
        case VS_FORMAT_MJPEG:
        case VS_FORMAT_FRAME_BASED:
            offset = dissect_usb_video_format(tree, tvb, offset, subtype);
            break;

        /* @todo MPEG2, H.264, VP8, Still Image Frame */
        /* @todo Obsolete UVC-1.0 descriptors? */

        case VS_FRAME_UNCOMPRESSED:
        case VS_FRAME_MJPEG:
        case VS_FRAME_FRAME_BASED:
            offset = dissect_usb_video_frame(tree, tvb, offset, subtype);
            break;

        case VS_COLORFORMAT:
            offset = dissect_usb_video_colorformat(tree, tvb, offset);
            break;

        default:
            break;
    }

    /* Soak up descriptor bytes beyond those we know how to dissect */
    if (offset < descriptor_len)
        proto_tree_add_item(tree, hf_usb_vid_descriptor_data, tvb, offset, descriptor_len-offset, ENC_NA);

    return descriptor_len;
}

dissect_u3v_heur(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
{
    guint32 prefix;
    usb_conv_info_t *usb_conv_info;

    /* all control and meta data packets of U3V contain at least the prefix */
    if (tvb_reported_length(tvb) < 4)
        return FALSE;
    prefix = tvb_get_letohl(tvb, 0);

    /* check if stream endpoint has been already set up for this conversation */
    usb_conv_info = (usb_conv_info_t *)data;
    if (!usb_conv_info)
        return FALSE;

    /* either right prefix or the endpoint of the interface descriptor
       set the correct class and subclass */
    if ((U3V_STREAM_LEADER_PREFIX  == prefix) || (U3V_STREAM_TRAILER_PREFIX == prefix) ||
        (U3V_CONTROL_PREFIX        == prefix) || (U3V_EVENT_PREFIX          == prefix) ||
        ((usb_conv_info->interfaceClass == IF_CLASS_MISCELLANEOUS &&
          usb_conv_info->interfaceSubclass == IF_SUBCLASS_MISC_U3V))) {
        dissect_u3v(tvb, pinfo, tree, data);
        return TRUE;
    }

    return FALSE;
}

dissect_usb_video_format(proto_tree *tree, tvbuff_t *tvb, int offset,
                         guint8 subtype)
{
    static const int *interlace_bits[] = {
        &hf_usb_vid_is_interlaced,
        &hf_usb_vid_interlaced_fields,
        &hf_usb_vid_field_1_first,
        &hf_usb_vid_field_pattern,
        NULL
    };

    proto_item *desc_item;
    guint8 format_index;

    /* Augment the descriptor root item with the index of this descriptor */
    format_index = tvb_get_guint8(tvb, offset);
    desc_item = proto_tree_get_parent(tree);
    proto_item_append_text(desc_item, "  (Format %u)", format_index);

    proto_tree_add_item(tree, hf_usb_vid_format_index,                  tvb, offset,    1, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(tree, hf_usb_vid_format_num_frame_descriptors,  tvb, offset+1,  1, ENC_LITTLE_ENDIAN);
    offset += 2;

    if ((subtype == VS_FORMAT_UNCOMPRESSED) || (subtype == VS_FORMAT_FRAME_BASED))
    {
        /* Augment the descriptor root item with the format's four-character-code */
        char fourcc[5];
        tvb_memcpy(tvb, (guint8 *)fourcc, offset, 4);
        fourcc[4] = '\0';
        proto_item_append_text(desc_item, ": %s", fourcc);

        proto_tree_add_item(tree, hf_usb_vid_format_guid, tvb, offset,   16, ENC_LITTLE_ENDIAN);
        proto_tree_add_item(tree, hf_usb_vid_format_bits_per_pixel,        tvb, offset+16, 1, ENC_LITTLE_ENDIAN);
        offset += 17;
    }
    else if (subtype == VS_FORMAT_MJPEG)
    {
        static const int * flags[] = {
            &hf_usb_vid_mjpeg_fixed_samples,
            NULL
        };

        proto_tree_add_bitmask(tree, tvb, offset, hf_usb_vid_mjpeg_flags, ett_mjpeg_flags, flags, ENC_NA);
        offset++;
    }
    else
    {
        /* We should only be called for known format descriptor subtypes */
        DISSECTOR_ASSERT_NOT_REACHED();
    }

    proto_tree_add_item(tree, hf_usb_vid_default_frame_index, tvb, offset,   1, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(tree, hf_usb_vid_aspect_ratio_x,      tvb, offset+1, 1, ENC_LITTLE_ENDIAN);
    proto_tree_add_item(tree, hf_usb_vid_aspect_ratio_y,      tvb, offset+2, 1, ENC_LITTLE_ENDIAN);
    offset += 3;

#if 0
    /* @todo Display "N/A" if Camera Terminal does not support scanning mode control */
    if (something)
        proto_tree_add_uint_format_value(tree, hf_usb_vid_interlace_flags, tvb, offset, 1, tvb_get_guint8(tvb, offset), "Not applicable");
#endif

    proto_tree_add_bitmask(tree, tvb, offset, hf_usb_vid_interlace_flags,
                                ett_interlace_flags, interlace_bits, ENC_NA);
    offset++;

    proto_tree_add_item(tree, hf_usb_vid_copy_protect, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset++;

    if (subtype == VS_FORMAT_FRAME_BASED)
    {
        proto_tree_add_item(tree, hf_usb_vid_variable_size, tvb, offset, 1, ENC_NA);
        offset++;
    }

    return offset;
}

dissect_ac_if_feature_unit(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,
        proto_tree *tree, usb_conv_info_t *usb_conv_info _U_)
{
    gint     offset_start;
    guint8 controlsize;
    proto_tree *bitmap_tree;
    proto_item *ti;

    static const int *fu_controls0[] = {
        &hf_ac_if_fu_controls_d0,
        &hf_ac_if_fu_controls_d1,
        &hf_ac_if_fu_controls_d2,
        &hf_ac_if_fu_controls_d3,
        &hf_ac_if_fu_controls_d4,
        &hf_ac_if_fu_controls_d5,
        &hf_ac_if_fu_controls_d6,
        &hf_ac_if_fu_controls_d7,
        NULL };

    static const int *fu_controls1[] = {
        &hf_ac_if_fu_controls_d8,
        &hf_ac_if_fu_controls_d9,
        &hf_ac_if_fu_controls_rsv,
        NULL };

    offset_start = offset;

    proto_tree_add_item(tree, hf_ac_if_fu_unitid, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;

    proto_tree_add_item(tree, hf_ac_if_fu_sourceid, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;

    proto_tree_add_item(tree, hf_ac_if_fu_controlsize, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    controlsize = tvb_get_guint8(tvb, offset) + 1;
    offset += 1;

    ti = proto_tree_add_item(tree, hf_ac_if_fu_controls, tvb, offset, controlsize, ENC_NA);
    bitmap_tree = proto_item_add_subtree(ti, ett_ac_if_fu_controls);

    proto_tree_add_bitmask(bitmap_tree, tvb, offset, hf_ac_if_fu_control, ett_ac_if_fu_controls0, fu_controls0, ENC_LITTLE_ENDIAN);

    if(controlsize >= 1){
        proto_tree_add_bitmask(bitmap_tree, tvb, offset + 1, hf_ac_if_fu_control, ett_ac_if_fu_controls1, fu_controls1, ENC_LITTLE_ENDIAN);
    }

    offset += controlsize;

    proto_tree_add_item(tree, hf_ac_if_fu_ifeature, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;

    return offset-offset_start;
}

dissect_usb_video_camera_terminal(proto_tree *tree, tvbuff_t *tvb, int offset)
{
    static const int *control_bits[] = {
        &hf_usb_vid_cam_control_D[0],
        &hf_usb_vid_cam_control_D[1],
        &hf_usb_vid_cam_control_D[2],
        &hf_usb_vid_cam_control_D[3],
        &hf_usb_vid_cam_control_D[4],
        &hf_usb_vid_cam_control_D[5],
        &hf_usb_vid_cam_control_D[6],
        &hf_usb_vid_cam_control_D[7],
        &hf_usb_vid_cam_control_D[8],
        &hf_usb_vid_cam_control_D[9],
        &hf_usb_vid_cam_control_D[10],
        &hf_usb_vid_cam_control_D[11],
        &hf_usb_vid_cam_control_D[12],
        &hf_usb_vid_cam_control_D[13],
        &hf_usb_vid_cam_control_D[14],
        &hf_usb_vid_cam_control_D[15],
        &hf_usb_vid_cam_control_D[16],
        &hf_usb_vid_cam_control_D[17],
        &hf_usb_vid_cam_control_D[18],
        &hf_usb_vid_cam_control_D[19],
        &hf_usb_vid_cam_control_D[20],
        &hf_usb_vid_cam_control_D[21],
        NULL
    };

    DISSECTOR_ASSERT(array_length(control_bits) == (1+array_length(hf_usb_vid_cam_control_D)));

    proto_tree_add_item(tree, hf_usb_vid_cam_objective_focal_len_min,  tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;
    proto_tree_add_item(tree, hf_usb_vid_cam_objective_focal_len_max,  tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;
    proto_tree_add_item(tree, hf_usb_vid_cam_ocular_focal_len, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;

    offset = dissect_bmControl(tree, tvb, offset, ett_camera_controls, control_bits);

    return offset;
}

dissect_ac_if_hdr_body(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,
        proto_tree *tree, usb_conv_info_t *usb_conv_info)
{
    gint     offset_start;
    guint16  bcdADC;
    guint8   ver_major;
    double   ver;
    guint8   if_in_collection, i;
    audio_conv_info_t *audio_conv_info;


    offset_start = offset;

    bcdADC = tvb_get_letohs(tvb, offset);
    ver_major = USB_AUDIO_BCD44_TO_DEC(bcdADC>>8);
    ver = ver_major + USB_AUDIO_BCD44_TO_DEC(bcdADC&0xFF) / 100.0;

    proto_tree_add_double_format_value(tree, hf_ac_if_hdr_ver,
            tvb, offset, 2, ver, "%2.2f", ver);
    audio_conv_info = (audio_conv_info_t *)usb_conv_info->class_data;
     if(!audio_conv_info) {
         audio_conv_info = wmem_new(wmem_file_scope(), audio_conv_info_t);
         usb_conv_info->class_data = audio_conv_info;
         /* XXX - set reasonable default values for all components
            that are not filled in by this function */
     }
     audio_conv_info->ver_major = ver_major;
     offset += 2;

    /* version 1 refers to the Basic Audio Device specification,
       version 2 is the Audio Device class specification, see above */
    if (ver_major==1) {
        proto_tree_add_item(tree, hf_ac_if_hdr_total_len,
                tvb, offset, 2, ENC_LITTLE_ENDIAN);
        offset += 2;
        if_in_collection = tvb_get_guint8(tvb, offset);
        proto_tree_add_item(tree, hf_ac_if_hdr_bInCollection,
                tvb, offset, 1, ENC_LITTLE_ENDIAN);
        offset++;

        for (i=0; i<if_in_collection; i++) {
            proto_tree_add_item(tree, hf_ac_if_hdr_if_num,
                    tvb, offset, 1, ENC_LITTLE_ENDIAN);
            offset++;
        }
    }

    return offset-offset_start;
}

is_known_bootstrap_register(guint64 addr, u3v_conv_info_t * u3v_conv_info)
{
    const gchar* address_string = NULL;
    guint32 offset_address;
    /* check if this is the access to one of the base address registers */
    if ( addr < 0x10000 ) {
        offset_address = (guint32)addr;
        address_string = try_val_to_str(offset_address, bootstrap_register_names_abrm);
    }
    if ( u3v_conv_info->sbrm_addr != 0 &&  (addr >= u3v_conv_info->sbrm_addr)) {
        offset_address = (guint32)( addr - u3v_conv_info->sbrm_addr);
        address_string = try_val_to_str(offset_address, bootstrap_register_names_sbrm);
    }
    if ( u3v_conv_info->sirm_addr != 0 &&  (addr >= u3v_conv_info->sirm_addr)) {
        offset_address = (guint32)( addr - u3v_conv_info->sirm_addr);
        address_string = try_val_to_str(offset_address, bootstrap_register_names_sirm);
    }
    if ( u3v_conv_info->eirm_addr != 0 &&  (addr >= u3v_conv_info->eirm_addr)) {
        offset_address = (guint32)( addr - u3v_conv_info->eirm_addr);
        address_string = try_val_to_str(offset_address, bootstrap_register_names_eirm);
    }
    return address_string != NULL;
}

proto_register_usb_vid(void)
{
    static hf_register_info hf[] = {
        /***** Setup *****/
            { &hf_usb_vid_request,
                    { "bRequest", "usbvideo.setup.bRequest", FT_UINT8, BASE_HEX, VALS(setup_request_names_vals), 0x0,
                            NULL, HFILL }
            },

            { &hf_usb_vid_length,
                    { "wLength", "usbvideo.setup.wLength", FT_UINT16, BASE_DEC, NULL, 0x0,
                            NULL, HFILL }
            },

        /***** Request Error Control *****/
            { &hf_usb_vid_request_error,
                    { "bRequestErrorCode", "usbvideo.reqerror.code",
                            FT_UINT8, BASE_DEC | BASE_EXT_STRING,
                            &request_error_codes_ext, 0,
                            "Request Error Code", HFILL }
            },

        /***** Unit/Terminal Controls *****/
            { &hf_usb_vid_control_selector,
                    { "Control Selector", "usbvideo.control.selector", FT_UINT8, BASE_HEX, NULL, 0x0,
                            "ID of the control within its entity", HFILL }
            },

            { &hf_usb_vid_control_entity,
                    { "Entity", "usbvideo.control.entity", FT_UINT8, BASE_HEX, NULL, 0x0,
                            "Unit or terminal to which the control belongs", HFILL }
            },

            { &hf_usb_vid_control_interface,
                    { "Interface", "usbvideo.control.interface", FT_UINT8, BASE_HEX, NULL, 0x0,
                            "Interface to which the control belongs", HFILL }
            },

            { &hf_usb_vid_control_info,
                    { "Info (Capabilities/State)", "usbvideo.control.info",
                            FT_UINT8, BASE_HEX, NULL, 0,
                            "Control capabilities and current state", HFILL }
            },

            { &hf_usb_vid_control_info_D[0],
                    { "Supports GET", "usbvideo.control.info.D0",
                            FT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<0),
                            NULL, HFILL }
            },

            { &hf_usb_vid_control_info_D[1],
                    { "Supports SET", "usbvideo.control.info.D1",
                            FT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<1),
                            NULL, HFILL }
            },

            { &hf_usb_vid_control_info_D[2],
                    { "Disabled due to automatic mode", "usbvideo.control.info.D2",
                            FT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<2),
                            NULL, HFILL }
            },

            { &hf_usb_vid_control_info_D[3],
                    { "Autoupdate", "usbvideo.control.info.D3",
                            FT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<3),
                            NULL, HFILL }
            },

            { &hf_usb_vid_control_info_D[4],
                    { "Asynchronous", "usbvideo.control.info.D4",
                            FT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<4),
                            NULL, HFILL }
            },

            { &hf_usb_vid_control_info_D[5],
                    { "Disabled due to incompatibility with Commit state", "usbvideo.control.info.D5",
                            FT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<5),
                            NULL, HFILL }
            },

            { &hf_usb_vid_control_info_D[6],
                    { "Reserved", "usbvideo.control.info.D6",
                            FT_UINT8, BASE_HEX, NULL, (3<<6),
                            NULL, HFILL }
            },

            { &hf_usb_vid_control_length,
                    { "Control Length", "usbvideo.control.len",
                            FT_UINT16, BASE_DEC, NULL, 0,
                            "Control size in bytes", HFILL }
            },

            { &hf_usb_vid_control_default,
                    { "Default value", "usbvideo.control.value.default",
                            FT_UINT32, BASE_DEC_HEX, NULL, 0,
                            NULL, HFILL }
            },

            { &hf_usb_vid_control_min,
                    { "Minimum value", "usbvideo.control.value.min",
                            FT_UINT32, BASE_DEC_HEX, NULL, 0,
                            NULL, HFILL }
            },

            { &hf_usb_vid_control_max,
                    { "Maximum value", "usbvideo.control.value.max",
                            FT_UINT32, BASE_DEC_HEX, NULL, 0,
                            NULL, HFILL }
            },

            { &hf_usb_vid_control_res,
                    { "Resolution", "usbvideo.control.value.res",
                            FT_UINT32, BASE_DEC_HEX, NULL, 0,
                            NULL, HFILL }
            },

            { &hf_usb_vid_control_cur,
                    { "Current value", "usbvideo.control.value.cur",
                            FT_UINT32, BASE_DEC_HEX, NULL, 0,
                            NULL, HFILL }
            },

        /***** Terminal Descriptors *****/

            /* @todo Decide whether to unify .name fields */
            { &hf_usb_vid_control_ifdesc_iTerminal,
                    { "iTerminal", "usbvideo.terminal.name", FT_UINT8, BASE_DEC, NULL, 0x0,
                            "String Descriptor describing this terminal", HFILL }
            },

            /* @todo Decide whether to unify .terminal.id and .unit.id under .entityID */
            { &hf_usb_vid_control_ifdesc_terminal_id,
                    { "bTerminalID", "usbvideo.terminal.id", FT_UINT8, BASE_DEC, NULL, 0x0,
                            NULL, HFILL }
            },

            { &hf_usb_vid_control_ifdesc_terminal_type,
                    { "wTerminalType", "usbvideo.terminal.type",
                            FT_UINT16, BASE_HEX | BASE_EXT_STRING, &vc_terminal_types_ext, 0,
                            NULL, HFILL }
            },

            { &hf_usb_vid_control_ifdesc_assoc_terminal,
                    { "bAssocTerminal", "usbvideo.terminal.assocTerminal", FT_UINT8, BASE_DEC, NULL, 0x0,
                            "Associated Terminal", HFILL }
            },

        /***** Camera Terminal Descriptor *****/

            { &hf_usb_vid_cam_objective_focal_len_min,
                    { "wObjectiveFocalLengthMin", "usbvideo.camera.objectiveFocalLengthMin",
                            FT_UINT16, BASE_DEC, NULL, 0,
                            "Minimum Focal Length for Optical Zoom", HFILL }
            },

            { &hf_usb_vid_cam_objective_focal_len_max,
                    { "wObjectiveFocalLengthMax", "usbvideo.camera.objectiveFocalLengthMax",
                            FT_UINT16, BASE_DEC, NULL, 0,
                            "Minimum Focal Length for Optical Zoom", HFILL }
            },

            { &hf_usb_vid_cam_ocular_focal_len,
                    { "wOcularFocalLength", "usbvideo.camera.ocularFocalLength",
                            FT_UINT16, BASE_DEC, NULL, 0,
                            "Ocular Focal Length for Optical Zoom", HFILL }
            },

            { &hf_usb_vid_cam_control_D[0],
                    { "Scanning Mode", "usbvideo.camera.control.D0",
                            FT_BOOLEAN,
                            array_length(hf_usb_vid_cam_control_D),
                            TFS(&tfs_yes_no), (1<<0),
                            NULL, HFILL }
            },

            { &hf_usb_vid_cam_control_D[1],
                    { "Auto Exposure Mode", "usbvideo.camera.control.D1",
                            FT_BOOLEAN,
                            array_length(hf_usb_vid_cam_control_D),
                            TFS(&tfs_yes_no), (1<<1),
                            NULL, HFILL }
            },

            { &hf_usb_vid_cam_control_D[2],
                    { "Auto Exposure Priority", "usbvideo.camera.control.D2",
                            FT_BOOLEAN,
                            array_length(hf_usb_vid_cam_control_D),
                            TFS(&tfs_yes_no), (1<<2),
                            NULL, HFILL }
            },

            { &hf_usb_vid_cam_control_D[3],
                    { "Exposure Time (Absolute)", "usbvideo.camera.control.D3",
                            FT_BOOLEAN,
                            array_length(hf_usb_vid_cam_control_D),
                            TFS(&tfs_yes_no), (1<<3),
                            NULL, HFILL }
            },

            { &hf_usb_vid_cam_control_D[4],
                    { "Exposure Time (Relative)", "usbvideo.camera.control.D4",
                            FT_BOOLEAN,
                            array_length(hf_usb_vid_cam_control_D),
                            TFS(&tfs_yes_no), (1<<4),
                            NULL, HFILL }
            },

            { &hf_usb_vid_cam_control_D[5],
                    { "Focus (Absolute)", "usbvideo.camera.control.D5",
                            FT_BOOLEAN,
                            array_length(hf_usb_vid_cam_control_D),
                            TFS(&tfs_yes_no), (1<<5),
                            NULL, HFILL }
            },

            { &hf_usb_vid_cam_control_D[6],
                    { "Focus (Relative)", "usbvideo.camera.control.D6",
                            FT_BOOLEAN,
                            array_length(hf_usb_vid_cam_control_D),
                            TFS(&tfs_yes_no), (1<<6),
                            NULL, HFILL }
            },

            { &hf_usb_vid_cam_control_D[7],
                    { "Iris (Absolute)", "usbvideo.camera.control.D7",
                            FT_BOOLEAN,
                            array_length(hf_usb_vid_cam_control_D),
                            TFS(&tfs_yes_no), (1<<7),
                            NULL, HFILL }
            },

            { &hf_usb_vid_cam_control_D[8],
                    { "Iris (Relative)", "usbvideo.camera.control.D8",
                            FT_BOOLEAN,
                            array_length(hf_usb_vid_cam_control_D),
                            TFS(&tfs_yes_no), (1<<8),
                            NULL, HFILL }
            },

            { &hf_usb_vid_cam_control_D[9],
                    { "Zoom (Absolute)", "usbvideo.camera.control.D9",
                            FT_BOOLEAN,
                            array_length(hf_usb_vid_cam_control_D),
                            TFS(&tfs_yes_no), (1<<9),
                            NULL, HFILL }
            },

            { &hf_usb_vid_cam_control_D[10],
                    { "Zoom (Relative)", "usbvideo.camera.control.D10",
                            FT_BOOLEAN,
                            array_length(hf_usb_vid_cam_control_D),
                            TFS(&tfs_yes_no), (1<<10),
                            NULL, HFILL }
            },

            { &hf_usb_vid_cam_control_D[11],
                    { "PanTilt (Absolute)", "usbvideo.camera.control.D11",
                            FT_BOOLEAN,
                            array_length(hf_usb_vid_cam_control_D),
                            TFS(&tfs_yes_no), (1<<11),
                            NULL, HFILL }
            },

            { &hf_usb_vid_cam_control_D[12],
                    { "PanTilt (Relative)", "usbvideo.camera.control.D12",
                            FT_BOOLEAN,
                            array_length(hf_usb_vid_cam_control_D),
                            TFS(&tfs_yes_no), (1<<12),
                            NULL, HFILL }
            },

            { &hf_usb_vid_cam_control_D[13],
                    { "Roll (Absolute)", "usbvideo.camera.control.D13",
                            FT_BOOLEAN,
                            array_length(hf_usb_vid_cam_control_D),
                            TFS(&tfs_yes_no), (1<<13),
                            NULL, HFILL }
            },

            { &hf_usb_vid_cam_control_D[14],
                    { "Roll (Relative)", "usbvideo.camera.control.D14",
                            FT_BOOLEAN,
                            array_length(hf_usb_vid_cam_control_D),
                            TFS(&tfs_yes_no), (1<<14),
                            NULL, HFILL }
            },

            { &hf_usb_vid_cam_control_D[15],
                    { "D15", "usbvideo.camera.control.D15",
                            FT_BOOLEAN,
                            array_length(hf_usb_vid_cam_control_D),
                            TFS(&tfs_yes_no), (1<<15),
                            "Reserved", HFILL }
            },

            { &hf_usb_vid_cam_control_D[16],
                    { "D16", "usbvideo.camera.control.D16",
                            FT_BOOLEAN,
                            array_length(hf_usb_vid_cam_control_D),
                            TFS(&tfs_yes_no), (1<<16),
                            "Reserved", HFILL }
            },

            { &hf_usb_vid_cam_control_D[17],
                    { "Auto Focus", "usbvideo.camera.control.D17",
                            FT_BOOLEAN,
                            array_length(hf_usb_vid_cam_control_D),
                            TFS(&tfs_yes_no), (1<<17),
                            NULL, HFILL }
            },

            { &hf_usb_vid_cam_control_D[18],
                    { "Privacy", "usbvideo.camera.control.D18",
                            FT_BOOLEAN,
                            array_length(hf_usb_vid_cam_control_D),
                            TFS(&tfs_yes_no), (1<<18),
                            NULL, HFILL }
            },

            { &hf_usb_vid_cam_control_D[19],
                    { "Focus (Simple)", "usbvideo.camera.control.D19",
                            FT_BOOLEAN,
                            array_length(hf_usb_vid_cam_control_D),
                            TFS(&tfs_yes_no), (1<<19),
                            NULL, HFILL }
            },

            { &hf_usb_vid_cam_control_D[20],
                    { "Window", "usbvideo.camera.control.D20",
                            FT_BOOLEAN,
                            array_length(hf_usb_vid_cam_control_D),
                            TFS(&tfs_yes_no), (1<<20),
                            NULL, HFILL }
            },

            { &hf_usb_vid_cam_control_D[21],
                    { "Region of Interest", "usbvideo.camera.control.D21",
                            FT_BOOLEAN,
                            array_length(hf_usb_vid_cam_control_D),
                            TFS(&tfs_yes_no), (1<<21),
                            NULL, HFILL }
            },

        /***** Unit Descriptors *****/

            { &hf_usb_vid_control_ifdesc_unit_id,
                    { "bUnitID", "usbvideo.unit.id", FT_UINT8, BASE_DEC, NULL, 0x0,
                            NULL, HFILL }
            },

            { &hf_usb_vid_num_inputs,
                    { "bNrInPins", "usbvideo.unit.numInputs",
                            FT_UINT8, BASE_DEC, NULL, 0,
                            "Number of input pins", HFILL }
            },

            { &hf_usb_vid_sources,
                    { "baSourceID", "usbvideo.unit.sources",
                            FT_BYTES, BASE_NONE, NULL, 0,
                            "Input entity IDs", HFILL }
            },


        /***** Processing Unit Descriptor *****/

            { &hf_usb_vid_iProcessing,
                    { "iProcessing", "usbvideo.processor.name", FT_UINT8, BASE_DEC, NULL, 0x0,
                            "String Descriptor describing this terminal", HFILL }
            },

            { &hf_usb_vid_proc_control_D[0],
                    { "Brightness", "usbvideo.processor.control.D0",
                            FT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<0),
                            NULL, HFILL }
            },

            { &hf_usb_vid_proc_control_D[1],
                    { "Contrast", "usbvideo.processor.control.D1",
                            FT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<1),
                            NULL, HFILL }
            },

            { &hf_usb_vid_proc_control_D[2],
                    { "Hue", "usbvideo.processor.control.D2",
                            FT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<2),
                            NULL, HFILL }
            },

            { &hf_usb_vid_proc_control_D[3],
                    { "Saturation", "usbvideo.processor.control.D3",
                            FT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<3),
                            NULL, HFILL }
            },

            { &hf_usb_vid_proc_control_D[4],
                    { "Sharpness", "usbvideo.processor.control.D4",
                            FT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<4),
                            NULL, HFILL }
            },

            { &hf_usb_vid_proc_control_D[5],
                    { "Gamma", "usbvideo.processor.control.D5",
                            FT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<5),
                            NULL, HFILL }
            },

            { &hf_usb_vid_proc_control_D[6],
                    { "White Balance Temperature", "usbvideo.processor.control.D6",
                            FT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<6),
                            NULL, HFILL }
            },

            { &hf_usb_vid_proc_control_D[7],
                    { "White Balance Component", "usbvideo.processor.control.D7",
                            FT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<7),
                            NULL, HFILL }
            },

            { &hf_usb_vid_proc_control_D[8],
                    { "Backlight Compensation", "usbvideo.processor.control.D8",
                            FT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<8),
                            NULL, HFILL }
            },

            { &hf_usb_vid_proc_control_D[9],
                    { "Gain", "usbvideo.processor.control.D9",
                            FT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<9),
                            NULL, HFILL }
            },

            { &hf_usb_vid_proc_control_D[10],
                    { "Power Line Frequency", "usbvideo.processor.control.D10",
                            FT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<10),
                            NULL, HFILL }
            },

            { &hf_usb_vid_proc_control_D[11],
                    { "Hue, Auto", "usbvideo.processor.control.D11",
                            FT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<11),
                            NULL, HFILL }
            },

            { &hf_usb_vid_proc_control_D[12],
                    { "White Balance Temperature, Auto", "usbvideo.processor.control.D12",
                            FT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<12),
                            NULL, HFILL }
            },

            { &hf_usb_vid_proc_control_D[13],
                    { "White Balance Component, Auto", "usbvideo.processor.control.D13",
                            FT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<13),
                            NULL, HFILL }
            },

            { &hf_usb_vid_proc_control_D[14],
                    { "Digital Multiplier", "usbvideo.processor.control.D14",
                            FT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<14),
                            NULL, HFILL }
            },

            { &hf_usb_vid_proc_control_D[15],
                    { "Digital Multiplier Limit", "usbvideo.processor.control.D15",
                            FT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<15),
                            "Reserved", HFILL }
            },

            { &hf_usb_vid_proc_control_D[16],
                    { "Analog Video Standard", "usbvideo.processor.control.D16",
                            FT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<16),
                            "Reserved", HFILL }
            },

            { &hf_usb_vid_proc_control_D[17],
                    { "Analog Video Lock Status", "usbvideo.processor.control.D17",
                            FT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<17),
                            NULL, HFILL }
            },

            { &hf_usb_vid_proc_control_D[18],
                    { "Contrast, Auto", "usbvideo.processor.control.D18",
                            FT_BOOLEAN, 24, TFS(&tfs_yes_no), (1<<18),
                            NULL, HFILL }
            },

            { &hf_usb_vid_proc_standards,
                    { "bmVideoStandards", "usbvideo.processor.standards",
                            FT_UINT8, BASE_HEX, NULL, 0,
                            "Supported analog video standards", HFILL }
            },

            { &hf_usb_vid_proc_standards_D[0],
                    { "None", "usbvideo.processor.standards.D0",
                            FT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<0),
                            NULL, HFILL }
            },

            { &hf_usb_vid_proc_standards_D[1],
                    { "NTSC - 525/60", "usbvideo.processor.standards.D1",
                            FT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<1),
                            NULL, HFILL }
            },

            { &hf_usb_vid_proc_standards_D[2],
                    { "PAL - 625/50", "usbvideo.processor.standards.D2",
                            FT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<2),
                            NULL, HFILL }
            },

            { &hf_usb_vid_proc_standards_D[3],
                    { "SECAM - 625/50", "usbvideo.processor.standards.D3",
                            FT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<3),
                            NULL, HFILL }
            },

            { &hf_usb_vid_proc_standards_D[4],
                    { "NTSC - 625/50", "usbvideo.processor.standards.D4",
                            FT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<4),
                            NULL, HFILL }
            },

            { &hf_usb_vid_proc_standards_D[5],
                    { "PAL - 525/60", "usbvideo.processor.standards.D5",
                            FT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<5),
                            NULL, HFILL }
            },

            { &hf_usb_vid_max_multiplier,
                    { "wMaxMultiplier", "usbvideo.processor.maxMultiplier",
                            FT_UINT16, BASE_DEC, NULL, 0,
                            "100 x max digital multiplication", HFILL }
            },

        /***** Selector Unit Descriptor *****/

            { &hf_usb_vid_iSelector,
                    { "iSelector", "usbvideo.selector.name", FT_UINT8, BASE_DEC, NULL, 0x0,
                            "String Descriptor describing this terminal", HFILL }
            },

        /***** Extension Unit Descriptor *****/

            { &hf_usb_vid_iExtension,
                    { "iExtension", "usbvideo.extension.name", FT_UINT8, BASE_DEC, NULL, 0x0,
                            "String Descriptor describing this terminal", HFILL }
            },

            { &hf_usb_vid_exten_guid,
                    { "guid", "usbvideo.extension.guid",
                            FT_GUID, BASE_NONE, NULL, 0,
                            "Identifier", HFILL }
            },

            { &hf_usb_vid_exten_num_controls,
                    { "bNumControls", "usbvideo.extension.numControls",
                            FT_UINT8, BASE_DEC, NULL, 0,
                            "Number of controls", HFILL }
            },

        /***** Probe/Commit *****/

            { &hf_usb_vid_probe_hint,
                    { "bmHint", "usbvideo.probe.hint",
                            FT_UINT16, BASE_HEX, NULL, 0,
                            "Fields to hold constant during negotiation", HFILL }
            },

            { &hf_usb_vid_probe_hint_D[0],
                    { "dwFrameInterval", "usbvideo.probe.hint.D0",
                            FT_BOOLEAN, 5, TFS(&probe_hint_meaning), (1<<0),
                            "Frame Rate", HFILL }
            },
            { &hf_usb_vid_probe_hint_D[1],
                    { "wKeyFrameRate", "usbvideo.probe.hint.D1",
                            FT_BOOLEAN, 5, TFS(&probe_hint_meaning), (1<<1),
                            "Key Frame Rate", HFILL }
            },
            { &hf_usb_vid_probe_hint_D[2],
                    { "wPFrameRate", "usbvideo.probe.hint.D2",
                            FT_BOOLEAN, 5, TFS(&probe_hint_meaning), (1<<2),
                            "P-Frame Rate", HFILL }
            },
            { &hf_usb_vid_probe_hint_D[3],
                    { "wCompQuality", "usbvideo.probe.hint.D3",
                            FT_BOOLEAN, 5, TFS(&probe_hint_meaning), (1<<3),
                            "Compression Quality", HFILL }
            },
            { &hf_usb_vid_probe_hint_D[4],
                    { "wCompWindowSize", "usbvideo.probe.hint.D4",
                            FT_BOOLEAN, 5, TFS(&probe_hint_meaning), (1<<4),
                            "Compression Window Size", HFILL }
            },

            { &hf_usb_vid_probe_key_frame_rate,
                    { "wKeyFrameRate", "usbvideo.probe.keyFrameRate",
                            FT_UINT16, BASE_DEC, NULL, 0,
                            "Key frame rate", HFILL }
            },

            { &hf_usb_vid_probe_p_frame_rate,
                    { "wPFrameRate", "usbvideo.probe.pFrameRate",
                            FT_UINT16, BASE_DEC, NULL, 0,
                            "P frame rate", HFILL }
            },

            { &hf_usb_vid_probe_comp_quality,
                    { "wCompQuality", "usbvideo.probe.compQuality",
                            FT_UINT16, BASE_DEC, NULL, 0,
                            "Compression quality [0-10000]", HFILL }
            },

            { &hf_usb_vid_probe_comp_window,
                    { "wCompWindow", "usbvideo.probe.compWindow",
                            FT_UINT16, BASE_DEC, NULL, 0,
                            "Window size for average bit rate control", HFILL }
            },
            { &hf_usb_vid_probe_delay,
                    { "wDelay", "usbvideo.probe.delay",
                            FT_UINT16, BASE_DEC, NULL, 0,
                            "Latency in ms from capture to USB", HFILL }
            },
            { &hf_usb_vid_probe_max_frame_sz,
                    { "dwMaxVideoFrameSize", "usbvideo.probe.maxVideoFrameSize",
                            FT_UINT32, BASE_DEC, NULL, 0,
                            NULL, HFILL }
            },
            { &hf_usb_vid_probe_max_payload_sz,
                    { "dwMaxPayloadTransferSize", "usbvideo.probe.maxPayloadTransferSize",
                            FT_UINT32, BASE_DEC, NULL, 0,
                            NULL, HFILL }
            },
            { &hf_usb_vid_probe_clock_freq,
                    { "dwClockFrequency", "usbvideo.probe.clockFrequency",
                            FT_UINT32, BASE_DEC, NULL, 0,
                            "Device clock frequency in Hz", HFILL }
            },

            { &hf_usb_vid_probe_framing,
                    { "bmFramingInfo", "usbvideo.probe.framing",
                            FT_UINT16, BASE_HEX, NULL, 0,
                            NULL, HFILL }
            },

            { &hf_usb_vid_probe_framing_D[0],
                    { "Frame ID required", "usbvideo.probe.framing.D0",
                            FT_BOOLEAN, 2, TFS(&tfs_yes_no), (1<<0),
                            NULL, HFILL }
            },
            { &hf_usb_vid_probe_framing_D[1],
                    { "EOF utilized", "usbvideo.probe.framing.D1",
                            FT_BOOLEAN, 2, TFS(&tfs_yes_no), (1<<1),
                            NULL, HFILL }
            },

            { &hf_usb_vid_probe_preferred_ver,
                    { "bPreferredVersion", "usbvideo.probe.preferredVersion",
                            FT_UINT8, BASE_DEC, NULL, 0,
                            "Preferred payload format version", HFILL }
            },
            { &hf_usb_vid_probe_min_ver,
                    { "bMinVersion", "usbvideo.probe.minVersion",
                            FT_UINT8, BASE_DEC, NULL, 0,
                            "Min supported payload format version", HFILL }
            },
            { &hf_usb_vid_probe_max_ver,
                    { "bPreferredVersion", "usbvideo.probe.maxVer",
                            FT_UINT8, BASE_DEC, NULL, 0,
                            "Max supported payload format version", HFILL }
            },

            { &hf_usb_vid_control_ifdesc_dwClockFrequency,
                    { "dwClockFrequency", "usbvideo.probe.clockFrequency",
                            FT_UINT32, BASE_DEC, NULL, 0,
                            "Device clock frequency (Hz) for selected format", HFILL }
            },

        /***** Format Descriptors *****/

            { &hf_usb_vid_format_index,
                    { "bFormatIndex", "usbvideo.format.index",
                            FT_UINT8, BASE_DEC, NULL, 0,
                            "Index of this format descriptor", HFILL }
            },

            { &hf_usb_vid_format_num_frame_descriptors,
                    { "bNumFrameDescriptors", "usbvideo.format.numFrameDescriptors",
                            FT_UINT8, BASE_DEC, NULL, 0,
                            "Number of frame descriptors for this format", HFILL }
            },

            { &hf_usb_vid_format_guid,
                    { "guidFormat", "usbvideo.format.guid",
                            FT_GUID, BASE_NONE, NULL, 0,
                            "Stream encoding format", HFILL }
            },

            { &hf_usb_vid_format_bits_per_pixel,
                    { "bBitsPerPixel", "usbvideo.format.bitsPerPixel",
                            FT_UINT8, BASE_DEC, NULL, 0,
                            "Bits per pixel", HFILL }
            },

            { &hf_usb_vid_default_frame_index,
                    { "bDefaultFrameIndex", "usbvideo.format.defaultFrameIndex",
                            FT_UINT8, BASE_DEC, NULL, 0,
                            "Optimum frame index for this stream", HFILL }
            },

            { &hf_usb_vid_aspect_ratio_x,
                    { "bAspectRatioX", "usbvideo.format.aspectRatioX",
                            FT_UINT8, BASE_DEC, NULL, 0,
                            "X dimension of picture aspect ratio", HFILL }
            },

            { &hf_usb_vid_aspect_ratio_y,
                    { "bAspectRatioY", "usbvideo.format.aspectRatioY",
                            FT_UINT8, BASE_DEC, NULL, 0,
                            "Y dimension of picture aspect ratio", HFILL }
            },

            { &hf_usb_vid_interlace_flags,
                    { "bmInterlaceFlags", "usbvideo.format.interlace",
                            FT_UINT8, BASE_HEX, NULL, 0x0,
                            NULL, HFILL }
            },

            { &hf_usb_vid_is_interlaced,
                    { "Interlaced stream", "usbvideo.format.interlace.D0",
                            FT_BOOLEAN, 8, TFS(&is_interlaced_meaning), (1<<0),
                            NULL, HFILL }
            },

            { &hf_usb_vid_interlaced_fields,
                    { "Fields per frame", "usbvideo.format.interlace.D1",
                            FT_BOOLEAN, 8, TFS(&interlaced_fields_meaning), (1<<1),
                            NULL, HFILL }
            },

            { &hf_usb_vid_field_1_first,
                    { "Field 1 first", "usbvideo.format.interlace.D2",
                            FT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<2),
                            NULL, HFILL }
            },

            { &hf_usb_vid_field_pattern,
                    { "Field pattern", "usbvideo.format.interlace.pattern",
                            FT_UINT8, BASE_DEC | BASE_EXT_STRING,
                            &field_pattern_meaning_ext, (3<<4),
                            NULL, HFILL }
            },

            { &hf_usb_vid_copy_protect,
                    { "bCopyProtect", "usbvideo.format.copyProtect",
                            FT_UINT8, BASE_DEC, VALS(copy_protect_meaning), 0,
                            NULL, HFILL }
            },

            { &hf_usb_vid_variable_size,
                    { "Variable size", "usbvideo.format.variableSize",
                            FT_BOOLEAN, BASE_DEC, NULL, 0,
                            NULL, HFILL }
            },

        /***** MJPEG Format Descriptor *****/

            { &hf_usb_vid_mjpeg_flags,
                    { "bmFlags", "usbvideo.mjpeg.flags",
                            FT_UINT8, BASE_HEX, NULL, 0,
                            "Characteristics", HFILL }
            },

            { &hf_usb_vid_mjpeg_fixed_samples,
                    { "Fixed size samples", "usbvideo.mjpeg.fixed_size",
                            FT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<0),
                            NULL, HFILL }
            },

        /***** Frame Descriptors *****/

            { &hf_usb_vid_frame_index,
                    { "bFrameIndex", "usbvideo.frame.index",
                            FT_UINT8, BASE_DEC, NULL, 0,
                            "Index of this frame descriptor", HFILL }
            },

            { &hf_usb_vid_frame_capabilities,
                    { "bmCapabilities", "usbvideo.frame.capabilities",
                            FT_UINT8, BASE_HEX, NULL, 0,
                            "Capabilities", HFILL }
            },

            { &hf_usb_vid_frame_stills_supported,
                    { "Still image", "usbvideo.frame.stills",
                            FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), (1<<0),
                            NULL, HFILL }
            },

            { &hf_usb_vid_frame_interval,
                    { "dwFrameInterval", "usbvideo.frame.interval",
                            FT_UINT32, BASE_DEC, NULL, 0,
                            "Frame interval multiple of 100 ns", HFILL }
            },

            { &hf_usb_vid_frame_fixed_frame_rate,
                    { "Fixed frame rate", "usbvideo.frame.fixedRate",
                            FT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<1),
                            NULL, HFILL }
            },
            { &hf_usb_vid_frame_width,
                    { "wWidth", "usbvideo.frame.width",
                            FT_UINT16, BASE_DEC, NULL, 0,
                            "Width of frame in pixels", HFILL }
            },
            { &hf_usb_vid_frame_height,
                    { "wHeight", "usbvideo.frame.height",
                            FT_UINT16, BASE_DEC, NULL, 0,
                            "Height of frame in pixels", HFILL }
            },
            { &hf_usb_vid_frame_min_bit_rate,
                    { "dwMinBitRate", "usbvideo.frame.minBitRate",
                            FT_UINT32, BASE_DEC, NULL, 0,
                            "Minimum bit rate in bps", HFILL }
            },
            { &hf_usb_vid_frame_max_bit_rate,
                    { "dwMaxBitRate", "usbvideo.frame.maxBitRate",
                            FT_UINT32, BASE_DEC, NULL, 0,
                            "Maximum bit rate in bps", HFILL }
            },

            { &hf_usb_vid_frame_max_frame_sz,
                    { "dwMaxVideoFrameBufferSize", "usbvideo.frame.maxBuffer",
                            FT_UINT32, BASE_DEC, NULL, 0,
                            "Maximum bytes per frame", HFILL }
            },
            { &hf_usb_vid_frame_default_interval,
                    { "dwDefaultFrameInterval", "usbvideo.frame.interval.default",
                            FT_UINT32, BASE_DEC, NULL, 0,
                            "Suggested default", HFILL }
            },

            { &hf_usb_vid_frame_interval_type,
                    { "bFrameIntervalType", "usbvideo.frame.interval.type",
                            FT_UINT8, BASE_DEC, NULL, 0,
                            "Frame rate control (continuous/discrete)", HFILL }
            },

            { &hf_usb_vid_frame_min_interval,
                    { "dwMinFrameInterval", "usbvideo.frame.interval.min",
                            FT_UINT32, BASE_DEC, NULL, 0,
                            "Shortest frame interval (* 100 ns)", HFILL }
            },

            { &hf_usb_vid_frame_max_interval,
                    { "dwMaxFrameInterval", "usbvideo.frame.interval.max",
                            FT_UINT32, BASE_DEC, NULL, 0,
                            "Longest frame interval (* 100 ns)", HFILL }
            },
            { &hf_usb_vid_frame_step_interval,
                    { "dwMinFrameInterval", "usbvideo.frame.interval.step",
                            FT_UINT32, BASE_DEC, NULL, 0,
                            "Granularity of frame interval (* 100 ns)", HFILL }
            },

            { &hf_usb_vid_frame_bytes_per_line,
                    { "dwBytesPerLine", "usbvideo.frame.bytesPerLine",
                            FT_UINT32, BASE_DEC, NULL, 0,
                            "Fixed number of bytes per video line", HFILL }
            },

        /***** Colorformat Descriptor *****/

            { &hf_usb_vid_color_primaries,
                    { "bColorPrimaries", "usbvideo.color.primaries",
                            FT_UINT8, BASE_DEC | BASE_EXT_STRING,
                            &color_primaries_meaning_ext, 0,
                            NULL, HFILL }
            },

            { &hf_usb_vid_transfer_characteristics,
                    { "bTransferCharacteristics", "usbvideo.color.transferCharacteristics",
                            FT_UINT8, BASE_DEC | BASE_EXT_STRING,
                            &color_transfer_characteristics_ext, 0,
                            NULL, HFILL }
            },

            { &hf_usb_vid_matrix_coefficients,
                    { "bMatrixCoefficients", "usbvideo.color.matrixCoefficients",
                            FT_UINT8, BASE_DEC | BASE_EXT_STRING,
                            &matrix_coefficients_meaning_ext, 0,
                            NULL, HFILL }
            },

        /***** Video Control Header Descriptor *****/

            { &hf_usb_vid_control_ifdesc_bcdUVC,
                    { "bcdUVC", "usbvideo.bcdUVC",
                            FT_UINT16, BASE_HEX, NULL, 0,
                            "Video Device Class Specification release number", HFILL }
            },

            { &hf_usb_vid_control_ifdesc_bInCollection,
                    { "bInCollection", "usbvideo.numStreamingInterfaces",
                            FT_UINT8, BASE_DEC, NULL, 0,
                            "Number of VideoStreaming interfaces", HFILL }
            },

            { &hf_usb_vid_control_ifdesc_baInterfaceNr,
                    { "baInterfaceNr", "usbvideo.streamingInterfaceNumbers",
                            FT_BYTES, BASE_NONE, NULL, 0,
                            "Interface numbers of VideoStreaming interfaces", HFILL }},

        /***** Video Streaming Input Header Descriptor *****/

            { &hf_usb_vid_streaming_ifdesc_bNumFormats,
                    { "bNumFormats", "usbvideo.streaming.numFormats",
                            FT_UINT8, BASE_DEC, NULL, 0,
                            "Number of video payload format descriptors", HFILL }
            },

            { &hf_usb_vid_streaming_bmInfo,
                    { "bmInfo", "usbvideo.streaming.info",
                            FT_UINT8, BASE_HEX, NULL, 0,
                            "Capabilities", HFILL }
            },

            { &hf_usb_vid_streaming_info_D[0],
                    { "Dynamic Format Change", "usbvideo.streaming.info.D0",
                            FT_BOOLEAN, 8, TFS(&tfs_yes_no), (1<<0),
                            "Dynamic Format Change", HFILL }
            },

            { &hf_usb_vid_streaming_control_D[0],
                    { "wKeyFrameRate", "usbvideo.streaming.control.D0",
                            FT_BOOLEAN, 6, TFS(&tfs_yes_no), (1<<0),
                            "Probe and Commit support", HFILL }
            },

            { &hf_usb_vid_streaming_control_D[1],
                    { "wPFrameRate", "usbvideo.streaming.control.D1",
                            FT_BOOLEAN, 6, TFS(&tfs_yes_no), (1<<1),
                            "Probe and Commit support", HFILL }
            },

            { &hf_usb_vid_streaming_control_D[2],
                    { "wCompQuality", "usbvideo.streaming.control.D2",
                            FT_BOOLEAN, 6, TFS(&tfs_yes_no), (1<<2),
                            "Probe and Commit support", HFILL }
            },

            { &hf_usb_vid_streaming_control_D[3],
                    { "wCompWindowSize", "usbvideo.streaming.control.D3",
                            FT_BOOLEAN, 6, TFS(&tfs_yes_no), (1<<3),
                            "Probe and Commit support", HFILL }
            },

            { &hf_usb_vid_streaming_control_D[4],
                    { "Generate Key Frame", "usbvideo.streaming.control.D4",
                            FT_BOOLEAN, 6, TFS(&tfs_yes_no), (1<<4),
                            "Probe and Commit support", HFILL }
            },

            { &hf_usb_vid_streaming_control_D[5],
                    { "Update Frame Segment", "usbvideo.streaming.control.D5",
                            FT_BOOLEAN, 6, TFS(&tfs_yes_no), (1<<5),
                            "Probe and Commit support", HFILL }
            },

            { &hf_usb_vid_streaming_terminal_link,
                    { "bTerminalLink", "usbvideo.streaming.terminalLink", FT_UINT8, BASE_DEC, NULL, 0x0,
                            "Output terminal ID", HFILL }
            },

            { &hf_usb_vid_streaming_still_capture_method,
                    { "bStillCaptureMethod", "usbvideo.streaming.stillCaptureMethod",
                            FT_UINT8, BASE_DEC | BASE_EXT_STRING,
                            &vs_still_capture_methods_ext, 0,
                            "Method of Still Image Capture", HFILL }
            },

            { &hf_usb_vid_streaming_trigger_support,
                    { "HW Triggering", "usbvideo.streaming.triggerSupport",
                            FT_BOOLEAN, BASE_DEC, TFS(&tfs_supported_not_supported), 0,
                            "Is HW triggering supported", HFILL }
            },

            { &hf_usb_vid_streaming_trigger_usage,
                    { "bTriggerUsage", "usbvideo.streaming.triggerUsage",
                            FT_UINT8, BASE_DEC, VALS(vs_trigger_usage), 0,
                            "How host SW should respond to trigger", HFILL }
            },

        /***** Interrupt URB *****/

            { &hf_usb_vid_interrupt_bStatusType,
                    { "Status Type", "usbvideo.interrupt.statusType",
                            FT_UINT8, BASE_HEX, VALS(interrupt_status_types), 0xF,
                            NULL, HFILL }
            },

            { &hf_usb_vid_interrupt_bAttribute,
                    { "Change Type", "usbvideo.interrupt.attribute",
                            FT_UINT8, BASE_HEX | BASE_EXT_STRING,
                            &control_change_types_ext, 0,
                            "Type of control change", HFILL }
            },

            { &hf_usb_vid_interrupt_bOriginator,
                    { "Originator", "usbvideo.interrupt.originator",
                            FT_UINT8, BASE_DEC, NULL, 0,
                            "ID of the entity that reports this interrupt", HFILL }
            },

            { &hf_usb_vid_control_interrupt_bEvent,
                    { "Event", "usbvideo.interrupt.controlEvent",
                            FT_UINT8, BASE_HEX, VALS(control_interrupt_events), 0,
                            "Type of event", HFILL }
            },

        /***** Video Control Endpoint Descriptor *****/

            { &hf_usb_vid_epdesc_subtype,
                    { "Subtype", "usbvideo.ep.descriptorSubType",
                            FT_UINT8, BASE_DEC, VALS(vc_ep_descriptor_subtypes), 0,
                            "Descriptor Subtype", HFILL }
            },

            { &hf_usb_vid_epdesc_max_transfer_sz,
                    { "wMaxTransferSize", "usbvideo.ep.maxInterruptSize", FT_UINT16,
                      BASE_DEC, NULL, 0x0, "Max interrupt structure size", HFILL }
            },

        /***** Fields used in multiple contexts *****/

            { &hf_usb_vid_ifdesc_wTotalLength,
                    { "wTotalLength", "usbvideo.totalLength",
                            FT_UINT16, BASE_DEC, NULL, 0,
                            "Video interface descriptor size", HFILL }
            },

            { &hf_usb_vid_bControlSize,
                    { "bControlSize", "usbvideo.bmcontrolSize",
                            FT_UINT8, BASE_DEC, NULL, 0,
                            "Size of bmControls field", HFILL }
            },

            { &hf_usb_vid_bmControl,
                    { "bmControl", "usbvideo.availableControls",
                            FT_UINT32, BASE_HEX, NULL, 0,
                            "Available controls", HFILL }
            },

            { &hf_usb_vid_bmControl_bytes,
                    { "bmControl", "usbvideo.availableControls.bytes",
                            FT_BYTES, BASE_NONE, NULL, 0,
                            "Available controls", HFILL }
            },

            { &hf_usb_vid_control_ifdesc_src_id,
                    { "bSourceID", "usbvideo.sourceID", FT_UINT8, BASE_DEC, NULL, 0x0,
                            "Entity to which this terminal/unit is connected", HFILL }
            },

        /**********/

            { &hf_usb_vid_control_ifdesc_subtype,
                    { "Subtype", "usbvideo.control.descriptorSubType",
                            FT_UINT8, BASE_DEC | BASE_EXT_STRING,
                            &vc_if_descriptor_subtypes_ext, 0,
                            "Descriptor Subtype", HFILL }
            },

            { &hf_usb_vid_streaming_ifdesc_subtype,
                    { "Subtype", "usbvideo.streaming.descriptorSubType",
                            FT_UINT8, BASE_DEC | BASE_EXT_STRING,
                            &vs_if_descriptor_subtypes_ext, 0,
                            "Descriptor Subtype", HFILL }
            },

            { &hf_usb_vid_descriptor_data,
                    { "Descriptor data", "usbvideo.descriptor_data", FT_BYTES, BASE_NONE, NULL, 0x0,
                            NULL, HFILL }
            },

            { &hf_usb_vid_control_data,
                    { "Control data", "usbvideo.control_data", FT_BYTES, BASE_NONE, NULL, 0x0,
                            NULL, HFILL }
            },

            { &hf_usb_vid_control_value,
                    { "Control value", "usbvideo.control_value", FT_BYTES, BASE_NONE, NULL, 0x0,
                            NULL, HFILL }
            },

            { &hf_usb_vid_value_data,
                    { "Value data", "usbvideo.value_data", FT_BYTES, BASE_NONE, NULL, 0x0,
                            NULL, HFILL }
            },
    };

    static gint *usb_vid_subtrees[] = {
            &ett_usb_vid,
            &ett_descriptor_video_endpoint,
            &ett_descriptor_video_control,
            &ett_descriptor_video_streaming,
            &ett_camera_controls,
            &ett_processing_controls,
            &ett_streaming_controls,
            &ett_streaming_info,
            &ett_interlace_flags,
            &ett_frame_capability_flags,
            &ett_mjpeg_flags,
            &ett_video_probe,
            &ett_probe_hint,
            &ett_probe_framing,
            &ett_video_standards,
            &ett_control_capabilities
    };

    static ei_register_info ei[] = {
        { &ei_usb_vid_subtype_unknown, { "usbvideo.subtype.unknown", PI_UNDECODED, PI_WARN, "Unknown VC subtype", EXPFILL }},
        { &ei_usb_vid_bitmask_len, { "usbvideo.bitmask_len_error", PI_UNDECODED, PI_WARN, "Only least-significant bytes decoded", EXPFILL }},
    };

    expert_module_t* expert_usb_vid;

    proto_usb_vid = proto_register_protocol("USB Video", "USBVIDEO", "usbvideo");
    proto_register_field_array(proto_usb_vid, hf, array_length(hf));
    proto_register_subtree_array(usb_vid_subtrees, array_length(usb_vid_subtrees));
    expert_usb_vid = expert_register_protocol(proto_usb_vid);
    expert_register_field_array(expert_usb_vid, ei, array_length(ei));
}
