TreeView::NodeDetails* TreeView::GetNodeDetailsByTreeItem(HTREEITEM tree_item) {
  DCHECK(tree_view_ && tree_item);
  TV_ITEM tv_item = {0};
  tv_item.hItem = tree_item;
  tv_item.mask = TVIF_PARAM;
  if (TreeView_GetItem(tree_view_, &tv_item))
    return GetNodeDetailsByID(static_cast<int>(tv_item.lParam));
  return NULL;
}

  TreeNodeModelTest()
      : added_count_(0),
         removed_count_(0),
         changed_count_(0) {}

void TreeView::RemoveObserverFromModel() {
  if (model_ && observer_added_) {
    model_->RemoveObserver(this);
    observer_added_ = false;
  }
}

void TreeView::SetModel(TreeModel* model) {
  if (model == model_)
    return;
  if (model_ && tree_view_)
    DeleteRootItems();

  RemoveObserverFromModel();

  model_ = model;
  if (tree_view_ && model_) {
    CreateRootItems();
    AddObserverToModel();
    HIMAGELIST last_image_list = image_list_;
    image_list_ = CreateImageList();
    TreeView_SetImageList(tree_view_, image_list_, TVSIL_NORMAL);
    if (last_image_list)
      ImageList_Destroy(last_image_list);
  }
}

HTREEITEM TreeView::GetTreeItemForNodeDuringMutation(TreeModelNode* node) {
  if (node_to_details_map_.find(node) == node_to_details_map_.end()) {
    return NULL;
  }
  if (!root_shown_ || node != model_->GetRoot()) {
    const NodeDetails* details = GetNodeDetails(node);
    if (!details->loaded_children)
      return NULL;
    return details->tree_item;
  }
  return TreeView_GetRoot(tree_view_);
}

void TreeView::OnDestroy() {
  Cleanup();
}

void TreeView::DeleteRootItems() {
  HTREEITEM root = TreeView_GetRoot(tree_view_);
  if (root) {
    if (root_shown_) {
      RecursivelyDelete(GetNodeDetailsByTreeItem(root));
    } else {
      do {
        RecursivelyDelete(GetNodeDetailsByTreeItem(root));
      } while ((root = TreeView_GetRoot(tree_view_)));
    }
  }
}

bool TreeView::IsExpanded(TreeModelNode* node) {
  TreeModelNode* parent = model_->GetParent(node);
  if (!parent)
    return true;
  if (!IsExpanded(parent))
    return false;
  NodeDetails* details = GetNodeDetails(node);
  return (TreeView_GetItemState(tree_view_, details->tree_item, TVIS_EXPANDED) &
          TVIS_EXPANDED) != 0;
}

TreeModelNode* TreeView::GetNodeForTreeItem(HTREEITEM tree_item) {
  NodeDetails* details = GetNodeDetailsByTreeItem(tree_item);
  return details ? details->node : NULL;
}

  virtual void TreeNodeChanged(TreeModel* model, TreeModelNode* node) {
     changed_count_++;
   }

void TreeView::OnContextMenu(const POINT& location) {
  if (!GetContextMenuController())
    return;

  if (location.x == -1 && location.y == -1) {
    NativeControl::OnContextMenu(location);
    return;
  }

  if (show_context_menu_only_when_node_selected_) {
    if (!GetSelectedNode())
      return;

    TVHITTESTINFO hit_info;
    gfx::Point local_loc(location);
    ConvertPointToView(NULL, this, &local_loc);
    hit_info.pt = local_loc.ToPOINT();
    HTREEITEM hit_item = TreeView_HitTest(tree_view_, &hit_info);
    if (!hit_item ||
        GetNodeDetails(GetSelectedNode())->tree_item != hit_item ||
        (hit_info.flags & (TVHT_ONITEM | TVHT_ONITEMRIGHT |
                          TVHT_ONITEMINDENT)) == 0) {
      return;
    }
  }
  ShowContextMenu(gfx::Point(location), true);
}

LRESULT TreeView::OnNotify(int w_param, LPNMHDR l_param) {
  switch (l_param->code) {
    case TVN_GETDISPINFO: {
      DCHECK(model_);
      NMTVDISPINFO* info = reinterpret_cast<NMTVDISPINFO*>(l_param);

      if (!id_to_details_map_.empty()) {
        const NodeDetails* details =
            GetNodeDetailsByID(static_cast<int>(info->item.lParam));
        if (info->item.mask & TVIF_CHILDREN)
          info->item.cChildren = model_->GetChildCount(details->node);
        if (info->item.mask & TVIF_TEXT) {
          std::wstring text = details->node->GetTitle();
          DCHECK(info->item.cchTextMax);

          base::i18n::AdjustStringForLocaleDirection(&text);

          wcsncpy_s(info->item.pszText, info->item.cchTextMax, text.c_str(),
                    _TRUNCATE);
        }
        info->item.mask |= TVIF_DI_SETITEM;
      } else {
        if (info->item.mask & TVIF_CHILDREN)
          info->item.cChildren = 0;

        if (info->item.mask & TVIF_TEXT)
          wcsncpy_s(info->item.pszText, info->item.cchTextMax, L"", _TRUNCATE);
      }

      return 0;
    }

    case TVN_ITEMEXPANDING: {
      DCHECK(model_);
      NMTREEVIEW* info = reinterpret_cast<NMTREEVIEW*>(l_param);
      NodeDetails* details =
          GetNodeDetailsByID(static_cast<int>(info->itemNew.lParam));
      if (!details->loaded_children) {
        details->loaded_children = true;
        for (int i = 0; i < model_->GetChildCount(details->node); ++i) {
          CreateItem(details->tree_item, TVI_LAST,
                       model_->GetChild(details->node, i));
          if (auto_expand_children_)
            Expand(model_->GetChild(details->node, i));
        }
      }
      return FALSE;
    }

    case TVN_SELCHANGED:
      if (controller_)
        controller_->OnTreeViewSelectionChanged(this);
      break;

    case TVN_BEGINLABELEDIT: {
      NMTVDISPINFO* info = reinterpret_cast<NMTVDISPINFO*>(l_param);
      NodeDetails* details =
          GetNodeDetailsByID(static_cast<int>(info->item.lParam));
      if (!controller_ || controller_->CanEdit(this, details->node)) {
        editing_node_ = details->node;
        return FALSE;
      }
      return TRUE;
    }

    case TVN_ENDLABELEDIT: {
      NMTVDISPINFO* info = reinterpret_cast<NMTVDISPINFO*>(l_param);
      if (info->item.pszText) {
        NodeDetails* details =
            GetNodeDetailsByID(static_cast<int>(info->item.lParam));
        model_->SetTitle(details->node, info->item.pszText);
        editing_node_ = NULL;
        return FALSE;
      }
      editing_node_ = NULL;
      return 0;
    }

    case TVN_KEYDOWN:
      if (controller_) {
        NMTVKEYDOWN* key_down_message =
            reinterpret_cast<NMTVKEYDOWN*>(l_param);
        controller_->OnTreeViewKeyDown(
            ui::KeyboardCodeForWindowsKeyCode(key_down_message->wVKey));
      }
      break;

    default:
      break;
  }
  return 0;
}

void TreeView::CancelEdit() {
  DCHECK(tree_view_);
  TreeView_EndEditLabelNow(tree_view_, TRUE);
}

LRESULT CALLBACK TreeView::TreeWndProc(HWND window,
                                       UINT message,
                                       WPARAM w_param,
                                       LPARAM l_param) {
  TreeViewWrapper* wrapper = reinterpret_cast<TreeViewWrapper*>(
      GetWindowLongPtr(window, GWLP_USERDATA));
  DCHECK(wrapper);
  TreeView* tree = wrapper->tree_view;

  switch (message) {
    case WM_ERASEBKGND:
      return 1;

    case WM_PAINT: {
      gfx::CanvasSkiaPaint canvas(window);
      if (canvas.isEmpty())
        return 0;

      HDC dc = skia::BeginPlatformPaint(&canvas);
      if (base::i18n::IsRTL()) {
        XFORM xform = {0};
        xform.eM11 = xform.eM22 = 1;
        SetWorldTransform(dc, &xform);

        SetGraphicsMode(dc, GM_COMPATIBLE);
        SetLayout(dc, LAYOUT_RTL);

        SetViewportOrgEx(dc, -canvas.paintStruct().rcPaint.left,
                         -canvas.paintStruct().rcPaint.top, NULL);
      }
      SendMessage(window, WM_PRINTCLIENT, reinterpret_cast<WPARAM>(dc), 0);
      if (base::i18n::IsRTL()) {
        SetViewportOrgEx(dc, 0, 0, NULL);
      }
      skia::EndPlatformPaint(&canvas);
      return 0;
    }

    case WM_RBUTTONDOWN:
      if (tree->select_on_right_mouse_down_) {
        TVHITTESTINFO hit_info;
        hit_info.pt = gfx::Point(l_param).ToPOINT();
        HTREEITEM hit_item = TreeView_HitTest(window, &hit_info);
        if (hit_item && (hit_info.flags & (TVHT_ONITEM | TVHT_ONITEMRIGHT |
                                           TVHT_ONITEMINDENT)) != 0)
          TreeView_SelectItem(tree->tree_view_, hit_item);
      }
      break;
  }
  WNDPROC handler = tree->original_handler_;
  DCHECK(handler);
  return CallWindowProc(handler, window, message, w_param, l_param);
}

void TreeView::Cleanup() {
  RemoveObserverFromModel();

  STLDeleteContainerPairSecondPointers(id_to_details_map_.begin(),
                                       id_to_details_map_.end());
  id_to_details_map_.clear();
  node_to_details_map_.clear();

  if (image_list_) {
    ImageList_Destroy(image_list_);
    image_list_ = NULL;
  }
}

void TreeView::CreateItem(HTREEITEM parent_item,
                          HTREEITEM after,
                          TreeModelNode* node) {
  DCHECK(node);
  TVINSERTSTRUCT insert_struct = {0};
  insert_struct.hParent = parent_item;
  insert_struct.hInsertAfter = after;
  insert_struct.itemex.mask = TVIF_PARAM | TVIF_CHILDREN | TVIF_TEXT |
                              TVIF_SELECTEDIMAGE | TVIF_IMAGE;
  insert_struct.itemex.pszText = LPSTR_TEXTCALLBACK;
  insert_struct.itemex.cChildren = I_CHILDRENCALLBACK;
  int icon_index = model_->GetIconIndex(node);
  if (icon_index == -1) {
    insert_struct.itemex.iImage = 0;
    insert_struct.itemex.iSelectedImage = 1;
  } else {
    insert_struct.itemex.iImage = icon_index + 2;
    insert_struct.itemex.iSelectedImage = icon_index + 2;
  }
  int node_id = next_id_++;
  insert_struct.itemex.lParam = node_id;

  NodeDetails* node_details = new NodeDetails(node_id, node);

  DCHECK(node_to_details_map_.count(node) == 0);
  DCHECK(id_to_details_map_.count(node_id) == 0);

  node_to_details_map_[node] = node_details;
  id_to_details_map_[node_id] = node_details;

  node_details->tree_item = TreeView_InsertItem(tree_view_, &insert_struct);
}

void TreeView::ExpandAll() {
  DCHECK(model_);
  ExpandAll(model_->GetRoot());
}

void TreeView::SetSelectedNode(TreeModelNode* node) {
  DCHECK(tree_view_);
  if (!node) {
    TreeView_SelectItem(tree_view_, NULL);
    return;
  }
  if (node != model_->GetRoot())
    Expand(model_->GetParent(node));
  if (!root_shown_ && node == model_->GetRoot()) {
    TreeView_SelectItem(tree_view_, NULL);
  } else {
    TreeView_SelectItem(tree_view_, GetNodeDetails(node)->tree_item);
  }
}

void TreeView::StartEditing(TreeModelNode* node) {
  DCHECK(node && tree_view_);
  CancelEdit();
  if (model_->GetParent(node))
    Expand(model_->GetParent(node));
  const NodeDetails* details = GetNodeDetails(node);
  SetFocus(tree_view_);
  SetSelectedNode(node);
  TreeView_EditLabel(tree_view_, details->tree_item);
}

gfx::Point TreeView::GetKeyboardContextMenuLocation() {
  int y = height() / 2;
  if (GetSelectedNode()) {
    RECT bounds;
    RECT client_rect;
    if (TreeView_GetItemRect(tree_view_,
                             GetNodeDetails(GetSelectedNode())->tree_item,
                             &bounds, TRUE) &&
        GetClientRect(tree_view_, &client_rect) &&
        bounds.bottom >= 0 && bounds.bottom < client_rect.bottom) {
      y = bounds.bottom;
    }
  }
  gfx::Point screen_loc(0, y);
  if (base::i18n::IsRTL())
    screen_loc.set_x(width());
  ConvertPointToScreen(this, &screen_loc);
  return screen_loc;
}

void TreeView::TreeNodesAdded(TreeModel* model,
                              TreeModelNode* parent,
                              int start,
                              int count) {
  DCHECK(parent && start >= 0 && count > 0);
  if (node_to_details_map_.find(parent) == node_to_details_map_.end() &&
      (root_shown_ || parent != model_->GetRoot())) {
    return;
  }
  HTREEITEM parent_tree_item = NULL;
  if (root_shown_ || parent != model_->GetRoot()) {
    const NodeDetails* details = GetNodeDetails(parent);
    if (!details->loaded_children) {
      if (count == model_->GetChildCount(parent)) {
        TV_ITEM tv_item = {0};
        tv_item.mask = TVIF_CHILDREN;
        tv_item.cChildren = count;
        tv_item.hItem = details->tree_item;
        TreeView_SetItem(tree_view_, &tv_item);
      }

      return;
    }
    parent_tree_item = details->tree_item;
  }

  for (int i = 0; i < count; ++i) {
    if (i == 0 && start == 0) {
      CreateItem(parent_tree_item, TVI_FIRST, model_->GetChild(parent, 0));
    } else {
      TreeModelNode* previous_sibling = model_->GetChild(parent, i + start - 1);
      CreateItem(parent_tree_item,
                 GetNodeDetails(previous_sibling)->tree_item,
                 model_->GetChild(parent, i + start));
    }
  }
}

void TreeView::Expand(TreeModelNode* node) {
  DCHECK(model_ && node);
  if (!root_shown_ && model_->GetRoot() == node) {
    return;
  }
  TreeModelNode* parent = model_->GetParent(node);
  if (parent) {
    Expand(parent);
  }
  TreeView_Expand(tree_view_, GetNodeDetails(node)->tree_item, TVE_EXPAND);
}

void TreeView::TreeNodeChanged(TreeModel* model, TreeModelNode* node) {
  if (node_to_details_map_.find(node) == node_to_details_map_.end()) {
    return;
  }
  const NodeDetails* details = GetNodeDetails(node);
  TV_ITEM tv_item = {0};
  tv_item.mask = TVIF_TEXT;
  tv_item.hItem = details->tree_item;
  tv_item.pszText = LPSTR_TEXTCALLBACK;
  TreeView_SetItem(tree_view_, &tv_item);
}

HTREEITEM TreeView::GetTreeItemForNode(TreeModelNode* node) {
  NodeDetails* details = GetNodeDetails(node);
  return details ? details->tree_item : NULL;
}

  void ClearCounts() {
    added_count_ = removed_count_ = changed_count_ = 0;
   }

void TreeView::CreateRootItems() {
  DCHECK(model_);
  DCHECK(tree_view_);
  TreeModelNode* root = model_->GetRoot();
  if (root_shown_) {
    CreateItem(NULL, TVI_LAST, root);
  } else {
    for (int i = 0; i < model_->GetChildCount(root); ++i)
      CreateItem(NULL, TVI_LAST, model_->GetChild(root, i));
  }
}

void TreeView::TreeNodesRemoved(TreeModel* model,
                                TreeModelNode* parent,
                                int start,
                                int count) {
  DCHECK(parent && start >= 0 && count > 0);

  HTREEITEM tree_item;
  if (!root_shown_ && parent == model->GetRoot()) {
    tree_item = TreeView_GetRoot(tree_view_);
  } else {
    HTREEITEM parent_tree_item = GetTreeItemForNodeDuringMutation(parent);
    if (!parent_tree_item)
      return;

    tree_item = TreeView_GetChild(tree_view_, parent_tree_item);
  }

  for (int i = 0; i < (start + count - 1); ++i) {
    tree_item = TreeView_GetNextSibling(tree_view_, tree_item);
  }

  for (int i = count - 1; i >= 0; --i) {
    HTREEITEM previous = (start + i) > 0 ?
        TreeView_GetPrevSibling(tree_view_, tree_item) : NULL;
    RecursivelyDelete(GetNodeDetailsByTreeItem(tree_item));
    tree_item = previous;
  }
}

void TreeView::AddObserverToModel() {
  if (model_ && !observer_added_) {
    model_->AddObserver(this);
    observer_added_ = true;
  }
}

void TreeView::GetAccessibleState(ui::AccessibleViewState* state) {
  state->role = ui::AccessibilityTypes::ROLE_OUTLINE;
  state->state = ui::AccessibilityTypes::STATE_READONLY;
}

void TreeView::ExpandAll(TreeModelNode* node) {
  DCHECK(node);
  if (node != model_->GetRoot() || root_shown_)
    TreeView_Expand(tree_view_, GetNodeDetails(node)->tree_item, TVE_EXPAND);
  for (int i = model_->GetChildCount(node) - 1; i >= 0; --i) {
    TreeModelNode* child = model_->GetChild(node, i);
    ExpandAll(child);
  }
}

TreeView::NodeDetails* TreeView::GetNodeDetails(TreeModelNode* node) {
  DCHECK(node &&
         node_to_details_map_.find(node) != node_to_details_map_.end());
  return node_to_details_map_[node];
}

virtual void TreeNodesRemoved(TreeModel* model, TreeModelNode* parent,
                                int start, int count) {
removed_count_++;
}

bool TreeView::OnKeyDown(ui::KeyboardCode virtual_key_code) {
  if (virtual_key_code == VK_F2) {
    if (!GetEditingNode()) {
      TreeModelNode* selected_node = GetSelectedNode();
      if (selected_node)
        StartEditing(selected_node);
    }
    return true;
  } else if (virtual_key_code == ui::VKEY_RETURN && !process_enter_) {
    Widget* widget = GetWidget();
    DCHECK(widget);
    Accelerator accelerator(Accelerator(virtual_key_code,
                                        base::win::IsShiftPressed(),
                                        base::win::IsCtrlPressed(),
                                        base::win::IsAltPressed()));
    GetFocusManager()->ProcessAccelerator(accelerator);
    return true;
  }
  return false;
}
