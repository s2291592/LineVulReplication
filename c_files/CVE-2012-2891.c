void PrintPreviewUI::OnPrintPreviewRequest(int request_id) {
  g_print_preview_request_id_map.Get().Set(preview_ui_addr_str_, request_id);
}

void ReportPrintSettingsStats(const DictionaryValue& settings) {
  bool landscape;
  if (settings.GetBoolean(printing::kSettingLandscape, &landscape))
    ReportPrintSettingHistogram(landscape ? LANDSCAPE : PORTRAIT);

  bool collate;
  if (settings.GetBoolean(printing::kSettingCollate, &collate) && collate)
    ReportPrintSettingHistogram(COLLATE);

  int duplex_mode;
  if (settings.GetInteger(printing::kSettingDuplexMode, &duplex_mode))
    ReportPrintSettingHistogram(duplex_mode ? DUPLEX : SIMPLEX);

  int color_mode;
  if (settings.GetInteger(printing::kSettingColor, &color_mode)) {
    ReportPrintSettingHistogram(
        printing::isColorModelSelected(color_mode) ? COLOR : BLACK_AND_WHITE);
  }
}

void PrintPreviewHandler::FileSelected(const FilePath& path,
                                       int index, void* params) {
  GetStickySettings()->StoreSavePath(path.DirName());

  PrintPreviewUI* print_preview_ui = static_cast<PrintPreviewUI*>(
      web_ui()->GetController());
  print_preview_ui->web_ui()->CallJavascriptFunction("fileSelectionCompleted");
  scoped_refptr<base::RefCountedBytes> data;
  print_preview_ui->GetPrintPreviewDataForIndex(
      printing::COMPLETE_PREVIEW_DOCUMENT_INDEX, &data);
  print_to_pdf_path_.reset(new FilePath(path));
  PostPrintToPdfTask(data);
}

void PrintingMessageFilter::OnUpdatePrintSettingsReply(
    scoped_refptr<printing::PrinterQuery> printer_query,
    IPC::Message* reply_msg) {
  PrintMsg_PrintPages_Params params;
  if (!printer_query.get() ||
      printer_query->last_status() != printing::PrintingContext::OK) {
    params.Reset();
  } else {
    RenderParamsFromPrintSettings(printer_query->settings(), &params.params);
    params.params.document_cookie = printer_query->cookie();
    params.pages =
        printing::PageRange::GetPages(printer_query->settings().ranges);
  }
  PrintHostMsg_UpdatePrintSettings::WriteReplyParams(reply_msg, params);
  Send(reply_msg);
  if (printer_query.get()) {
    if (printer_query->cookie() && printer_query->settings().dpi())
      print_job_manager_->QueuePrinterQuery(printer_query.get());
    else
      printer_query->StopWorker();
   }
 }

bool PrintWebViewHelper::PrintPages(WebFrame* frame, const WebNode& node) {
  const PrintMsg_PrintPages_Params& params = *print_pages_params_;
  const PrintMsg_Print_Params& print_params = params.params;
  PrepareFrameAndViewForPrint prep_frame_view(print_params, frame, node);
  UpdateFrameAndViewFromCssPageLayout(frame, node, &prep_frame_view,
                                      print_params, ignore_css_margins_);

  int page_count = prep_frame_view.GetExpectedPageCount();
  if (!page_count)
    return false;
  Send(new PrintHostMsg_DidGetPrintedPagesCount(routing_id(),
                                                print_params.document_cookie,
                                                page_count));

  const gfx::Size& canvas_size = prep_frame_view.GetPrintCanvasSize();
  PrintMsg_PrintPage_Params page_params;
  page_params.params = print_params;
  if (params.pages.empty()) {
    for (int i = 0; i < page_count; ++i) {
      page_params.page_number = i;
      PrintPageInternal(page_params, canvas_size, frame);
    }
  } else {
    for (size_t i = 0; i < params.pages.size(); ++i) {
      if (params.pages[i] >= page_count)
        break;
      page_params.page_number = params.pages[i];
      PrintPageInternal(page_params, canvas_size, frame);
    }
  }
  return true;
}

PrintMsg_Print_Params CalculatePrintParamsForCss(
    WebFrame* frame,
    int page_index,
    const PrintMsg_Print_Params& page_params,
    bool ignore_css_margins,
    bool fit_to_page,
    double* scale_factor) {
  PrintMsg_Print_Params css_params = GetCssPrintParams(frame, page_index,
                                                       page_params);

  PrintMsg_Print_Params params = page_params;
  EnsureOrientationMatches(css_params, &params);

  if (ignore_css_margins && fit_to_page)
    return params;

  PrintMsg_Print_Params result_params = css_params;
  if (ignore_css_margins) {
    result_params.margin_top = params.margin_top;
    result_params.margin_left = params.margin_left;

    DCHECK(!fit_to_page);
    int default_margin_right = params.page_size.width() -
        params.content_size.width() - params.margin_left;
    int default_margin_bottom = params.page_size.height() -
        params.content_size.height() - params.margin_top;
    result_params.content_size = gfx::Size(
        result_params.page_size.width() - result_params.margin_left -
            default_margin_right,
        result_params.page_size.height() - result_params.margin_top -
            default_margin_bottom);
  }

  if (fit_to_page) {
    double factor = FitPrintParamsToPage(params, &result_params);
    if (scale_factor)
      *scale_factor = factor;
  }
  return result_params;
}

void PrintPreviewHandler::ClearInitiatorTabDetails() {
  TabContents* initiator_tab = GetInitiatorTab();
  if (!initiator_tab)
    return;

  printing::PrintPreviewTabController* tab_controller =
      printing::PrintPreviewTabController::GetInstance();
  if (tab_controller)
    tab_controller->EraseInitiatorTabInfo(preview_tab_contents());
}

void PrintingMessageFilter::OnCheckForCancel(const std::string& preview_ui_addr,
int preview_request_id,
bool* cancel) {
  PrintPreviewUI::GetCurrentPrintPreviewStatus(preview_ui_addr,
preview_request_id,
cancel);
}

int GetPageCountFromSettingsDictionary(const DictionaryValue& settings) {
  int count = 0;
  const ListValue* page_range_array;
  if (settings.GetList(printing::kSettingPageRange, &page_range_array)) {
    for (size_t index = 0; index < page_range_array->GetSize(); ++index) {
      const DictionaryValue* dict;
      if (!page_range_array->GetDictionary(index, &dict))
        continue;

      printing::PageRange range;
      if (!dict->GetInteger(printing::kSettingPageRangeFrom, &range.from) ||
          !dict->GetInteger(printing::kSettingPageRangeTo, &range.to)) {
        continue;
      }
      count += (range.to - range.from) + 1;
    }
  }
  return count;
}

 void PrintPreviewUI::SetInitiatorTabURLAndTitle(
    const std::string& initiator_url,
    const string16& job_title) {
  initiator_url_ = initiator_url;
  initiator_tab_title_ = job_title;
}

void ComputeWebKitPrintParamsInDesiredDpi(
    const PrintMsg_Print_Params& print_params,
    WebPrintParams* webkit_print_params) {
  int dpi = GetDPI(&print_params);
  webkit_print_params->printerDPI = dpi;
  webkit_print_params->printScalingOption = print_params.print_scaling_option;

  webkit_print_params->printContentArea.width =
      ConvertUnit(print_params.content_size.width(), dpi,
                  print_params.desired_dpi);
  webkit_print_params->printContentArea.height =
      ConvertUnit(print_params.content_size.height(), dpi,
                  print_params.desired_dpi);

  webkit_print_params->printableArea.x =
      ConvertUnit(print_params.printable_area.x(), dpi,
                  print_params.desired_dpi);
  webkit_print_params->printableArea.y =
      ConvertUnit(print_params.printable_area.y(), dpi,
                  print_params.desired_dpi);
  webkit_print_params->printableArea.width =
      ConvertUnit(print_params.printable_area.width(), dpi,
                  print_params.desired_dpi);
  webkit_print_params->printableArea.height =
      ConvertUnit(print_params.printable_area.height(),
                  dpi, print_params.desired_dpi);

  webkit_print_params->paperSize.width =
      ConvertUnit(print_params.page_size.width(), dpi,
                  print_params.desired_dpi);
  webkit_print_params->paperSize.height =
      ConvertUnit(print_params.page_size.height(), dpi,
                  print_params.desired_dpi);
}

content::WebContents* PrintingMessageFilter::GetWebContentsForRenderView(
    int render_view_id) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  content::RenderViewHost* view = content::RenderViewHost::FromID(
      render_process_id_, render_view_id);
  return content::WebContents::FromRenderViewHost(view);
}

PrintWebViewHelper::PrintWebViewHelper(content::RenderView* render_view)
    : content::RenderViewObserver(render_view),
      content::RenderViewObserverTracker<PrintWebViewHelper>(render_view),
      print_web_view_(NULL),
      is_preview_enabled_(IsPrintPreviewEnabled()),
      is_print_ready_metafile_sent_(false),
      ignore_css_margins_(false),
      user_cancelled_scripted_print_count_(0),
      is_scripted_printing_blocked_(false),
      notify_browser_of_print_failure_(true),
      print_for_preview_(false) {
}

TabContents* PrintPreviewHandler::GetInitiatorTab() const {
  printing::PrintPreviewTabController* tab_controller =
      printing::PrintPreviewTabController::GetInstance();
  if (!tab_controller)
    return NULL;
  return tab_controller->GetInitiatorTab(preview_tab_contents());
}

void PrintPreviewUI::OnDidPreviewPage(int page_number,
int preview_request_id) {
DCHECK_GE(page_number, 0);
base::FundamentalValue number(page_number);
  StringValue ui_identifier(preview_ui_addr_str_);
base::FundamentalValue request_id(preview_request_id);
web_ui()->CallJavascriptFunction(
"onDidPreviewPage", number, ui_identifier, request_id);
}

printing::StickySettings* PrintPreviewHandler::GetStickySettings() {
  return sticky_settings.Pointer();
}

void PrintWebViewHelper::RequestPrintPreview(PrintPreviewRequestType type) {
  const bool is_modifiable = print_preview_context_.IsModifiable();
  old_print_pages_params_.reset();
  switch (type) {
    case PRINT_PREVIEW_USER_INITIATED_ENTIRE_FRAME: {
      Send(new PrintHostMsg_RequestPrintPreview(routing_id(), is_modifiable,
                                                false));
      break;
    }
    case PRINT_PREVIEW_USER_INITIATED_CONTEXT_NODE: {
      Send(new PrintHostMsg_RequestPrintPreview(routing_id(), is_modifiable,
                                                true));
      break;
    }
    case PRINT_PREVIEW_SCRIPTED: {
      IPC::SyncMessage* msg =
          new PrintHostMsg_ScriptedPrintPreview(routing_id(), is_modifiable);
      msg->EnableMessagePumping();
      Send(msg);
      break;
    }
    default: {
      NOTREACHED();
      return;
    }
  }
 }

  void VerifyPrintPreviewGenerated(bool generated_preview) {
    const IPC::Message* preview_msg =
        render_thread_->sink().GetUniqueMessageMatching(
            PrintHostMsg_MetafileReadyForPrinting::ID);
    bool did_get_preview_msg = (NULL != preview_msg);
    ASSERT_EQ(generated_preview, did_get_preview_msg);
    if (did_get_preview_msg) {
      PrintHostMsg_MetafileReadyForPrinting::Param preview_param;
      PrintHostMsg_MetafileReadyForPrinting::Read(preview_msg, &preview_param);
      EXPECT_NE(0, preview_param.a.document_cookie);
      EXPECT_NE(0, preview_param.a.expected_pages_count);
      EXPECT_NE(0U, preview_param.a.data_size);
    }
  }

void PrintPreviewHandler::GetNumberFormatAndMeasurementSystem(
    base::DictionaryValue* settings) {

  UErrorCode errorCode = U_ZERO_ERROR;
  const char* locale = g_browser_process->GetApplicationLocale().c_str();
  UMeasurementSystem system = ulocdata_getMeasurementSystem(locale, &errorCode);
  if (errorCode > U_ZERO_ERROR || system == UMS_LIMIT)
    system = UMS_SI;

  settings->SetString(kNumberFormat, base::FormatDouble(123456.78, 2));
  settings->SetInteger(kMeasurementSystem, system);
}

void PrintPreviewHandler::SetupPrinterList(const ListValue& printers) {
  web_ui()->CallJavascriptFunction("setPrinters", printers);
}

PrintPreviewDataService* PrintPreviewDataService::GetInstance() {
  return Singleton<PrintPreviewDataService>::get();
}

void PrepareFrameAndViewForPrint::UpdatePrintParams(
    const PrintMsg_Print_Params& print_params) {
  DCHECK(!finished_);
  WebPrintParams webkit_print_params;
  ComputeWebKitPrintParamsInDesiredDpi(print_params, &webkit_print_params);

  if (webkit_print_params.printContentArea ==
          web_print_params_.printContentArea &&
      webkit_print_params.printableArea == web_print_params_.printableArea &&
      webkit_print_params.paperSize == web_print_params_.paperSize &&
      webkit_print_params.printScalingOption ==
          web_print_params_.printScalingOption) {
    return;
  }

  frame_->printEnd();
  StartPrinting(webkit_print_params);
}

bool PrintWebViewHelper::InitPrintSettingsAndPrepareFrame(
    WebKit::WebFrame* frame, const WebKit::WebNode& node,
    scoped_ptr<PrepareFrameAndViewForPrint>* prepare) {
  DCHECK(frame);

  bool fit_to_paper_size = !(PrintingNodeOrPdfFrame(frame, node));
  if (!InitPrintSettings(fit_to_paper_size)) {
    notify_browser_of_print_failure_ = false;
    render_view()->RunModalAlertDialog(
        frame,
        l10n_util::GetStringUTF16(IDS_PRINT_PREVIEW_INVALID_PRINTER_SETTINGS));
    return false;
  }

  DCHECK(!prepare->get());
  prepare->reset(new PrepareFrameAndViewForPrint(print_pages_params_->params,
                                                 frame, node));
  UpdateFrameAndViewFromCssPageLayout(frame, node, prepare->get(),
                                      print_pages_params_->params,
                                      ignore_css_margins_);
  Send(new PrintHostMsg_DidGetDocumentCookie(
        routing_id(), print_pages_params_->params.document_cookie));
  return true;
}

PrintPreviewUI::~PrintPreviewUI() {
  print_preview_data_service()->RemoveEntry(preview_ui_addr_str_);
  g_print_preview_request_id_map.Get().Erase(preview_ui_addr_str_);
}

void CreatePrintSettingsDictionary(DictionaryValue* dict) {
dict->SetBoolean(printing::kSettingLandscape, false);
dict->SetBoolean(printing::kSettingCollate, false);
dict->SetInteger(printing::kSettingColor, printing::GRAY);
dict->SetBoolean(printing::kSettingPrintToPDF, true);
dict->SetInteger(printing::kSettingDuplexMode, printing::SIMPLEX);
dict->SetInteger(printing::kSettingCopies, 1);
dict->SetString(printing::kSettingDeviceName, "dummy");
  dict->SetString(printing::kPreviewUIAddr, "0xb33fbeef");
dict->SetInteger(printing::kPreviewRequestID, 12345);
dict->SetBoolean(printing::kIsFirstRequest, true);
dict->SetInteger(printing::kSettingMarginsType, printing::DEFAULT_MARGINS);
dict->SetBoolean(printing::kSettingPreviewModifiable, false);
dict->SetBoolean(printing::kSettingHeaderFooterEnabled, false);
dict->SetBoolean(printing::kSettingGenerateDraftData, true);
}

void PrintingMessageFilter::CreatePrintDialogForFile(int render_view_id,
                                                     const FilePath& path) {
  content::WebContents* wc = GetWebContentsForRenderView(render_view_id);
  print_dialog_cloud::CreatePrintDialogForFile(
      wc->GetBrowserContext(),
      wc->GetView()->GetTopLevelNativeWindow(),
      path,
      string16(),
      string16(),
      std::string("application/pdf"),
      false);
}

int PrintPreviewDataService::GetAvailableDraftPageCount(
    const std::string& preview_ui_addr_str) {
  if (data_store_map_.find(preview_ui_addr_str) != data_store_map_.end())
    return data_store_map_[preview_ui_addr_str]->GetAvailableDraftPageCount();
  return 0;
}

void ReportPrintDestinationHistogram(enum PrintDestinationBuckets event) {
  UMA_HISTOGRAM_ENUMERATION("PrintPreview.DestinationAction", event,
                            PRINT_DESTINATION_BUCKET_BOUNDARY);
}

void PrintPreviewHandler::OnPrintPreviewFailed() {
  if (reported_failed_preview_)
    return;
  reported_failed_preview_ = true;
  ReportUserActionHistogram(PREVIEW_FAILED);
}

bool PrintWebViewHelper::CopyAndPrint(WebKit::WebFrame* web_frame) {
  webkit_glue::WebPreferences prefs = render_view()->GetWebkitPreferences();
  prefs.javascript_enabled = false;
  prefs.java_enabled = false;

  print_web_view_ = WebView::create(this);
  prefs.Apply(print_web_view_);
  print_web_view_->initializeMainFrame(this);

  print_pages_params_->pages.clear();  // Print all pages of selection.

  std::string html = web_frame->selectionAsMarkup().utf8();
  std::string url_str = "data:text/html;charset=utf-8,";
  url_str.append(html);
  GURL url(url_str);

  print_web_view_->mainFrame()->loadRequest(WebURLRequest(url));

  return true;
}

PrintMsg_PrintPages_Params::PrintMsg_PrintPages_Params()
  : pages() {
}

void PrintPreviewHandler::HandleGetInitialSettings(const ListValue* /*args*/) {
  printing::StickySettings* sticky_settings = GetStickySettings();
  sticky_settings->RestoreFromPrefs(Profile::FromBrowserContext(
      preview_web_contents()->GetBrowserContext())->GetPrefs());
  if (sticky_settings->printer_name()) {
    std::string cloud_print_data;
    if (sticky_settings->printer_cloud_print_data())
      cloud_print_data = *sticky_settings->printer_cloud_print_data();
    SendInitialSettings(*sticky_settings->printer_name(), cloud_print_data);
  } else {
    scoped_refptr<PrintSystemTaskProxy> task =
        new PrintSystemTaskProxy(AsWeakPtr(),
                                 print_backend_.get(),
                                 has_logged_printers_count_);
    BrowserThread::PostTask(
        BrowserThread::FILE, FROM_HERE,
        base::Bind(&PrintSystemTaskProxy::GetDefaultPrinter, task.get()));
  }
  SendCloudPrintEnabled();
}

TabContents* PrintPreviewHandler::preview_tab_contents() const {
  return TabContents::FromWebContents(preview_web_contents());
}

void PrintPreviewUI::OnClosePrintPreviewTab() {
  if (tab_closed_)
    return;
  tab_closed_ = true;
  ConstrainedWebDialogDelegate* delegate = GetConstrainedDelegate();
  if (!delegate)
    return;
  delegate->GetWebDialogDelegate()->OnDialogClosed("");
  delegate->OnDialogCloseFromWebUI();
}

void ChromeMockRenderThread::OnCheckForCancel(
    const std::string& preview_ui_addr,
    int preview_request_id,
    bool* cancel) {
*cancel =
(print_preview_pages_remaining_ == print_preview_cancel_page_number_);
}

void PrintPreviewDataService::SetDataEntry(
    const std::string& preview_ui_addr_str,
int index,
const base::RefCountedBytes* data_bytes) {
  PreviewDataStoreMap::iterator it = data_store_map_.find(preview_ui_addr_str);
  if (it == data_store_map_.end())
    data_store_map_[preview_ui_addr_str] = new PrintPreviewDataStore();

  data_store_map_[preview_ui_addr_str]->SetPreviewDataForIndex(index,
                                                               data_bytes);
}

   ~PrintPreviewDataStore() {}

 void PrintPreviewUI::OnPrintPreviewTabClosed() {
  TabContents* preview_tab =
      TabContents::FromWebContents(web_ui()->GetWebContents());
  printing::BackgroundPrintingManager* background_printing_manager =
      g_browser_process->background_printing_manager();
  if (background_printing_manager->HasPrintPreviewTab(preview_tab))
    return;
  OnClosePrintPreviewTab();
}

void PrintPreviewHandler::HandleClosePreviewTab(const ListValue* /*args*/) {
  ReportStats();
  ReportUserActionHistogram(CANCEL);

  UMA_HISTOGRAM_COUNTS("PrintPreview.RegeneratePreviewRequest.BeforeCancel",
                       regenerate_preview_request_count_);
}

void PrintWebViewHelper::ComputePageLayoutInPointsForCss(
    WebFrame* frame,
    int page_index,
    const PrintMsg_Print_Params& page_params,
    bool ignore_css_margins,
    double* scale_factor,
    PageSizeMargins* page_layout_in_points) {
  PrintMsg_Print_Params params = CalculatePrintParamsForCss(
      frame, page_index, page_params, ignore_css_margins,
      page_params.print_scaling_option ==
          WebKit::WebPrintScalingOptionFitToPrintableArea,
      scale_factor);
  CalculatePageLayoutFromPrintParams(params, page_layout_in_points);
}

ChromeMockRenderThread::~ChromeMockRenderThread() {
}

  void VerifyPageCount(int count) {
#if defined(OS_CHROMEOS)
#else
    const IPC::Message* page_cnt_msg =
        render_thread_->sink().GetUniqueMessageMatching(
            PrintHostMsg_DidGetPrintedPagesCount::ID);
    ASSERT_TRUE(page_cnt_msg);
    PrintHostMsg_DidGetPrintedPagesCount::Param post_page_count_param;
    PrintHostMsg_DidGetPrintedPagesCount::Read(page_cnt_msg,
                                               &post_page_count_param);
    EXPECT_EQ(count, post_page_count_param.b);
#endif  // defined(OS_CHROMEOS)
  }

void PrintPreviewHandler::ReportStats() {
  UMA_HISTOGRAM_COUNTS("PrintPreview.ManagePrinters",
                       manage_printers_dialog_request_count_);
  UMA_HISTOGRAM_COUNTS("PrintPreview.ManageCloudPrinters",
                       manage_cloud_printers_dialog_request_count_);
}

  void VerifyDidPreviewPage(bool generate_draft_pages, int page_number) {
    bool msg_found = false;
    size_t msg_count = render_thread_->sink().message_count();
    for (size_t i = 0; i < msg_count; ++i) {
      const IPC::Message* msg = render_thread_->sink().GetMessageAt(i);
      if (msg->type() == PrintHostMsg_DidPreviewPage::ID) {
        PrintHostMsg_DidPreviewPage::Param page_param;
        PrintHostMsg_DidPreviewPage::Read(msg, &page_param);
        if (page_param.a.page_number == page_number) {
          msg_found = true;
          if (generate_draft_pages)
            EXPECT_NE(0U, page_param.a.data_size);
          else
            EXPECT_EQ(0U, page_param.a.data_size);
          break;
        }
      }
    }
    ASSERT_EQ(generate_draft_pages, msg_found);
  }

void CalculatePageLayoutFromPrintParams(
    const PrintMsg_Print_Params& params,
    PageSizeMargins* page_layout_in_points) {
  int dpi = GetDPI(&params);
  int content_width = params.content_size.width();
  int content_height = params.content_size.height();

  int margin_bottom = params.page_size.height() -
                      content_height - params.margin_top;
  int margin_right = params.page_size.width() -
                      content_width - params.margin_left;

  page_layout_in_points->content_width = ConvertUnit(
      content_width, dpi, printing::kPointsPerInch);
  page_layout_in_points->content_height = ConvertUnit(
      content_height, dpi, printing::kPointsPerInch);
  page_layout_in_points->margin_top = ConvertUnit(
      params.margin_top, dpi, printing::kPointsPerInch);
  page_layout_in_points->margin_right = ConvertUnit(
      margin_right, dpi, printing::kPointsPerInch);
  page_layout_in_points->margin_bottom = ConvertUnit(
      margin_bottom, dpi, printing::kPointsPerInch);
  page_layout_in_points->margin_left = ConvertUnit(
      params.margin_left, dpi, printing::kPointsPerInch);
}

void PrintWebViewHelper::UpdateFrameAndViewFromCssPageLayout(
    WebFrame* frame,
    const WebNode& node,
    PrepareFrameAndViewForPrint* prepare,
    const PrintMsg_Print_Params& params,
    bool ignore_css_margins) {
  if (PrintingNodeOrPdfFrame(frame, node))
    return;
  bool fit_to_page = ignore_css_margins &&
                     params.print_scaling_option ==
                          WebKit::WebPrintScalingOptionFitToPrintableArea;
  PrintMsg_Print_Params print_params = CalculatePrintParamsForCss(
      frame, 0, params, ignore_css_margins, fit_to_page, NULL);
  prepare->UpdatePrintParams(print_params);
}

void ChromeMockRenderThread::OnDidGetPrintedPagesCount(
int cookie, int number_pages) {
  if (printer_.get())
    printer_->SetPrintedPagesCount(cookie, number_pages);
}

void PrintPreviewUI::OnTabDestroyed() {
  handler_->OnTabDestroyed();
}

void ChromeMockRenderThread::set_print_preview_cancel_page_number(int page) {
   print_preview_cancel_page_number_ = page;
 }

void PrintPreviewDataService::GetDataEntry(
    const std::string& preview_ui_addr_str,
int index,
scoped_refptr<base::RefCountedBytes>* data_bytes) {
*data_bytes = NULL;
  PreviewDataStoreMap::iterator it = data_store_map_.find(preview_ui_addr_str);
if (it != data_store_map_.end())
it->second->GetPreviewDataForIndex(index, data_bytes);
}

void PrintToPdfCallback(Metafile* metafile, const FilePath& path) {
  metafile->SaveTo(path);
  BrowserThread::PostTask(
      BrowserThread::UI, FROM_HERE,
      base::Bind(&base::DeletePointer<Metafile>, metafile));
}

   PrintPreviewRequestIdMapWithLock() {}

  virtual ~PrintPreviewUIUnitTest() {}

void PrintWebViewHelper::Print(WebKit::WebFrame* frame,
                               const WebKit::WebNode& node) {
  if (print_web_view_)
    return;

  scoped_ptr<PrepareFrameAndViewForPrint> prepare;
  if (!InitPrintSettingsAndPrepareFrame(frame, node, &prepare)) {
    DidFinishPrinting(FAIL_PRINT_INIT);
    return;  // Failed to init print page settings.
  }

  int expected_page_count = 0;
  bool use_browser_overlays = true;

  expected_page_count = prepare->GetExpectedPageCount();
  if (expected_page_count)
    use_browser_overlays = prepare->ShouldUseBrowserOverlays();

  prepare.reset();

  if (!expected_page_count) {
    DidFinishPrinting(FAIL_PRINT);
    return;
  }

  if (!GetPrintSettingsFromUser(frame, node, expected_page_count,
                                use_browser_overlays)) {
    DidFinishPrinting(OK);  // Release resources and fail silently.
    return;
  }

  if (!RenderPagesForPrint(frame, node)) {
    LOG(ERROR) << "RenderPagesForPrint failed";
    DidFinishPrinting(FAIL_PRINT);
  }
  ResetScriptedPrintCount();
}

void PrintWebViewHelper::didStopLoading() {
  PrintPages(print_web_view_->mainFrame(), WebNode());
}

void PrintPreviewDataSource::Init() {
#if defined(OS_CHROMEOS)
  AddLocalizedString("title", IDS_PRINT_PREVIEW_GOOGLE_CLOUD_PRINT_TITLE);
#else
  AddLocalizedString("title", IDS_PRINT_PREVIEW_TITLE);
#endif
  AddLocalizedString("loading", IDS_PRINT_PREVIEW_LOADING);
  AddLocalizedString("noPlugin", IDS_PRINT_PREVIEW_NO_PLUGIN);
  AddLocalizedString("launchNativeDialog", IDS_PRINT_PREVIEW_NATIVE_DIALOG);
  AddLocalizedString("previewFailed", IDS_PRINT_PREVIEW_FAILED);
  AddLocalizedString("invalidPrinterSettings",
                     IDS_PRINT_PREVIEW_INVALID_PRINTER_SETTINGS);
  AddLocalizedString("printButton", IDS_PRINT_PREVIEW_PRINT_BUTTON);
  AddLocalizedString("saveButton", IDS_PRINT_PREVIEW_SAVE_BUTTON);
  AddLocalizedString("cancelButton", IDS_PRINT_PREVIEW_CANCEL_BUTTON);
  AddLocalizedString("printing", IDS_PRINT_PREVIEW_PRINTING);
  AddLocalizedString("printingToPDFInProgress",
                     IDS_PRINT_PREVIEW_PRINTING_TO_PDF_IN_PROGRESS);
#if defined(OS_MACOSX)
  AddLocalizedString("openingPDFInPreview",
                     IDS_PRINT_PREVIEW_OPENING_PDF_IN_PREVIEW);
#endif
  AddLocalizedString("destinationLabel", IDS_PRINT_PREVIEW_DESTINATION_LABEL);
  AddLocalizedString("copiesLabel", IDS_PRINT_PREVIEW_COPIES_LABEL);
  AddLocalizedString("examplePageRangeText",
                     IDS_PRINT_PREVIEW_EXAMPLE_PAGE_RANGE_TEXT);
  AddLocalizedString("layoutLabel", IDS_PRINT_PREVIEW_LAYOUT_LABEL);
  AddLocalizedString("optionAllPages", IDS_PRINT_PREVIEW_OPTION_ALL_PAGES);
  AddLocalizedString("optionBw", IDS_PRINT_PREVIEW_OPTION_BW);
  AddLocalizedString("optionCollate", IDS_PRINT_PREVIEW_OPTION_COLLATE);
  AddLocalizedString("optionColor", IDS_PRINT_PREVIEW_OPTION_COLOR);
  AddLocalizedString("optionLandscape", IDS_PRINT_PREVIEW_OPTION_LANDSCAPE);
  AddLocalizedString("optionPortrait", IDS_PRINT_PREVIEW_OPTION_PORTRAIT);
  AddLocalizedString("optionTwoSided", IDS_PRINT_PREVIEW_OPTION_TWO_SIDED);
  AddLocalizedString("pagesLabel", IDS_PRINT_PREVIEW_PAGES_LABEL);
  AddLocalizedString("pageRangeTextBox", IDS_PRINT_PREVIEW_PAGE_RANGE_TEXT);
  AddLocalizedString("pageRangeRadio", IDS_PRINT_PREVIEW_PAGE_RANGE_RADIO);
  AddLocalizedString("printToPDF", IDS_PRINT_PREVIEW_PRINT_TO_PDF);
  AddLocalizedString("printPreviewSummaryFormatShort",
                     IDS_PRINT_PREVIEW_SUMMARY_FORMAT_SHORT);
  AddLocalizedString("printPreviewSummaryFormatLong",
                     IDS_PRINT_PREVIEW_SUMMARY_FORMAT_LONG);
  AddLocalizedString("printPreviewSheetsLabelSingular",
                     IDS_PRINT_PREVIEW_SHEETS_LABEL_SINGULAR);
  AddLocalizedString("printPreviewSheetsLabelPlural",
                     IDS_PRINT_PREVIEW_SHEETS_LABEL_PLURAL);
  AddLocalizedString("printPreviewPageLabelSingular",
                     IDS_PRINT_PREVIEW_PAGE_LABEL_SINGULAR);
  AddLocalizedString("printPreviewPageLabelPlural",
                     IDS_PRINT_PREVIEW_PAGE_LABEL_PLURAL);
  const string16 shortcut_text(UTF8ToUTF16(kAdvancedPrintShortcut));
#if defined(OS_CHROMEOS)
  AddString("systemDialogOption", l10n_util::GetStringFUTF16(
      IDS_PRINT_PREVIEW_CLOUD_DIALOG_OPTION,
      l10n_util::GetStringUTF16(IDS_GOOGLE_CLOUD_PRINT),
      shortcut_text));
#else
  AddString("systemDialogOption", l10n_util::GetStringFUTF16(
      IDS_PRINT_PREVIEW_SYSTEM_DIALOG_OPTION,
      shortcut_text));
#endif
  AddString("cloudPrintDialogOption",
            l10n_util::GetStringFUTF16(
                IDS_PRINT_PREVIEW_CLOUD_DIALOG_OPTION_NO_SHORTCUT,
                l10n_util::GetStringUTF16(IDS_GOOGLE_CLOUD_PRINT)));
#if defined(OS_MACOSX)
  AddLocalizedString("openPdfInPreviewOption",
                     IDS_PRINT_PREVIEW_OPEN_PDF_IN_PREVIEW_APP);
#endif
  AddString("printWithCloudPrintWait", l10n_util::GetStringFUTF16(
      IDS_PRINT_PREVIEW_PRINT_WITH_CLOUD_PRINT_WAIT,
      l10n_util::GetStringUTF16(IDS_GOOGLE_CLOUD_PRINT)));
  AddLocalizedString("pageRangeInstruction",
                     IDS_PRINT_PREVIEW_PAGE_RANGE_INSTRUCTION);
  AddLocalizedString("copiesInstruction", IDS_PRINT_PREVIEW_COPIES_INSTRUCTION);
  AddLocalizedString("incrementTitle", IDS_PRINT_PREVIEW_INCREMENT_TITLE);
  AddLocalizedString("decrementTitle", IDS_PRINT_PREVIEW_DECREMENT_TITLE);
  AddLocalizedString("printPagesLabel", IDS_PRINT_PREVIEW_PRINT_PAGES_LABEL);
  AddLocalizedString("optionsLabel", IDS_PRINT_PREVIEW_OPTIONS_LABEL);
  AddLocalizedString("optionHeaderFooter",
                     IDS_PRINT_PREVIEW_OPTION_HEADER_FOOTER);
  AddLocalizedString("optionFitToPage",
                     IDS_PRINT_PREVIEW_OPTION_FIT_TO_PAGE);
  AddLocalizedString("marginsLabel", IDS_PRINT_PREVIEW_MARGINS_LABEL);
  AddLocalizedString("defaultMargins", IDS_PRINT_PREVIEW_DEFAULT_MARGINS);
  AddLocalizedString("noMargins", IDS_PRINT_PREVIEW_NO_MARGINS);
  AddLocalizedString("customMargins", IDS_PRINT_PREVIEW_CUSTOM_MARGINS);
  AddLocalizedString("minimumMargins", IDS_PRINT_PREVIEW_MINIMUM_MARGINS);
  AddLocalizedString("top", IDS_PRINT_PREVIEW_TOP_MARGIN_LABEL);
  AddLocalizedString("bottom", IDS_PRINT_PREVIEW_BOTTOM_MARGIN_LABEL);
  AddLocalizedString("left", IDS_PRINT_PREVIEW_LEFT_MARGIN_LABEL);
  AddLocalizedString("right", IDS_PRINT_PREVIEW_RIGHT_MARGIN_LABEL);
  AddLocalizedString("destinationSearchTitle",
                     IDS_PRINT_PREVIEW_DESTINATION_SEARCH_TITLE);
  AddLocalizedString("userInfo", IDS_PRINT_PREVIEW_USER_INFO);
  AddLocalizedString("cloudPrintPromotion",
                     IDS_PRINT_PREVIEW_CLOUD_PRINT_PROMOTION);
  AddLocalizedString("searchBoxPlaceholder",
                     IDS_PRINT_PREVIEW_SEARCH_BOX_PLACEHOLDER);
  AddLocalizedString("noDestinationsMessage",
                     IDS_PRINT_PREVIEW_NO_DESTINATIONS_MESSAGE);
  AddLocalizedString("showAllButtonText",
                     IDS_PRINT_PREVIEW_SHOW_ALL_BUTTON_TEXT);
  AddLocalizedString("destinationCount", IDS_PRINT_PREVIEW_DESTINATION_COUNT);
  AddLocalizedString("recentDestinationsTitle",
                     IDS_PRINT_PREVIEW_RECENT_DESTINATIONS_TITLE);
  AddLocalizedString("localDestinationsTitle",
                     IDS_PRINT_PREVIEW_LOCAL_DESTINATIONS_TITLE);
  AddLocalizedString("cloudDestinationsTitle",
                     IDS_PRINT_PREVIEW_CLOUD_DESTINATIONS_TITLE);
  AddLocalizedString("manage", IDS_PRINT_PREVIEW_MANAGE);
  AddLocalizedString("setupCloudPrinters",
                     IDS_PRINT_PREVIEW_SETUP_CLOUD_PRINTERS);
  AddLocalizedString("changeDestination",
                     IDS_PRINT_PREVIEW_CHANGE_DESTINATION);
  AddLocalizedString("offlineForYear", IDS_PRINT_PREVIEW_OFFLINE_FOR_YEAR);
  AddLocalizedString("offlineForMonth", IDS_PRINT_PREVIEW_OFFLINE_FOR_MONTH);
  AddLocalizedString("offlineForWeek", IDS_PRINT_PREVIEW_OFFLINE_FOR_WEEK);
  AddLocalizedString("offline", IDS_PRINT_PREVIEW_OFFLINE);
  AddLocalizedString("fedexTos", IDS_PRINT_PREVIEW_FEDEX_TOS);
  AddLocalizedString("tosCheckboxLabel", IDS_PRINT_PREVIEW_TOS_CHECKBOX_LABEL);

  set_json_path("strings.js");
  add_resource_path("print_preview.js", IDR_PRINT_PREVIEW_JS);
  add_resource_path("images/printer.png", IDR_PRINT_PREVIEW_IMAGES_PRINTER);
  add_resource_path("images/printer_shared.png",
                    IDR_PRINT_PREVIEW_IMAGES_PRINTER_SHARED);
  add_resource_path("images/third_party.png",
                    IDR_PRINT_PREVIEW_IMAGES_THIRD_PARTY);
  add_resource_path("images/google_doc.png",
                    IDR_PRINT_PREVIEW_IMAGES_GOOGLE_DOC);
  add_resource_path("images/pdf.png", IDR_PRINT_PREVIEW_IMAGES_PDF);
  add_resource_path("images/mobile.png", IDR_PRINT_PREVIEW_IMAGES_MOBILE);
  add_resource_path("images/mobile_shared.png",
                    IDR_PRINT_PREVIEW_IMAGES_MOBILE_SHARED);
  set_default_resource(IDR_PRINT_PREVIEW_HTML);
}

void PrintPreviewUI::OnDidGetDefaultPageLayout(
    const PageSizeMargins& page_layout, const gfx::Rect& printable_area,
    bool has_custom_page_size_style) {
  if (page_layout.margin_top < 0 || page_layout.margin_left < 0 ||
      page_layout.margin_bottom < 0 || page_layout.margin_right < 0 ||
      page_layout.content_width < 0 || page_layout.content_height < 0 ||
      printable_area.width() <= 0 || printable_area.height() <= 0) {
    NOTREACHED();
    return;
  }

  base::DictionaryValue layout;
  layout.SetDouble(printing::kSettingMarginTop, page_layout.margin_top);
  layout.SetDouble(printing::kSettingMarginLeft, page_layout.margin_left);
  layout.SetDouble(printing::kSettingMarginBottom, page_layout.margin_bottom);
  layout.SetDouble(printing::kSettingMarginRight, page_layout.margin_right);
  layout.SetDouble(printing::kSettingContentWidth, page_layout.content_width);
  layout.SetDouble(printing::kSettingContentHeight, page_layout.content_height);
  layout.SetInteger(printing::kSettingPrintableAreaX, printable_area.x());
  layout.SetInteger(printing::kSettingPrintableAreaY, printable_area.y());
  layout.SetInteger(printing::kSettingPrintableAreaWidth,
                    printable_area.width());
  layout.SetInteger(printing::kSettingPrintableAreaHeight,
                    printable_area.height());

  base::FundamentalValue has_page_size_style(has_custom_page_size_style);
  web_ui()->CallJavascriptFunction("onDidGetDefaultPageLayout", layout,
                                   has_page_size_style);
}

bool PrintWebViewHelper::CheckForCancel() {
bool cancel = false;
  Send(new PrintHostMsg_CheckForCancel(
      routing_id(),
      print_pages_params_->params.preview_ui_addr,
      print_pages_params_->params.preview_request_id,
      &cancel));
if (cancel)
notify_browser_of_print_failure_ = false;
return cancel;
}

void PrintPreviewHandler::HandlePrintWithCloudPrint(const ListValue* /*args*/) {
  ReportStats();

  PrintPreviewUI* print_preview_ui = static_cast<PrintPreviewUI*>(
      web_ui()->GetController());
  scoped_refptr<base::RefCountedBytes> data;
  print_preview_ui->GetPrintPreviewDataForIndex(
      printing::COMPLETE_PREVIEW_DOCUMENT_INDEX, &data);
  if (!data.get()) {
    NOTREACHED();
    return;
  }
  DCHECK_GT(data->size(), 0U);

  gfx::NativeWindow modal_parent =
      platform_util::GetTopLevel(preview_web_contents()->GetNativeView());
  print_dialog_cloud::CreatePrintDialogForBytes(
      preview_web_contents()->GetBrowserContext(),
      modal_parent,
      data,
      string16(print_preview_ui->initiator_tab_title()),
      string16(),
      std::string("application/pdf"));

  ActivateInitiatorTabAndClosePreviewTab();
}

void PrintPreviewHandler::HandleSignin(const ListValue* /*args*/) {
  gfx::NativeWindow modal_parent =
      platform_util::GetTopLevel(preview_web_contents()->GetNativeView());
  print_dialog_cloud::CreateCloudPrintSigninDialog(
      preview_web_contents()->GetBrowserContext(),
      modal_parent,
      base::Bind(&PrintPreviewHandler::OnSigninComplete, AsWeakPtr()));
}

void PrintPreviewUI::GetCurrentPrintPreviewStatus(
    const std::string& preview_ui_addr,
    int request_id,
    bool* cancel) {
int current_id = -1;
  if (!g_print_preview_request_id_map.Get().Get(preview_ui_addr, &current_id)) {
*cancel = true;
return;
}
*cancel = (request_id != current_id);
}

void PrintingMessageFilter::OnGetDefaultPrintSettings(IPC::Message* reply_msg) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));
  scoped_refptr<printing::PrinterQuery> printer_query;
  if (!profile_io_data_->printing_enabled()->GetValue()) {
    OnGetDefaultPrintSettingsReply(printer_query, reply_msg);
    return;
  }
  print_job_manager_->PopPrinterQuery(0, &printer_query);
  if (!printer_query.get()) {
    printer_query = new printing::PrinterQuery;
    printer_query->SetWorkerDestination(print_job_manager_->destination());
  }

  GetPrintSettingsForRenderViewParams params;
  params.ask_user_for_settings = printing::PrinterQuery::DEFAULTS;
  params.expected_page_count = 0;
  params.has_selection = false;
  params.margin_type = printing::DEFAULT_MARGINS;
  BrowserThread::PostTask(
      BrowserThread::UI, FROM_HERE,
      base::Bind(&PrintingMessageFilter::GetPrintSettingsForRenderView, this,
          reply_msg->routing_id(), params,
          base::Bind(&PrintingMessageFilter::OnGetDefaultPrintSettingsReply,
              this, printer_query, reply_msg),
          printer_query));
}

void GetPreviewDataForIndex(int index,
scoped_refptr<base::RefCountedBytes>* data) {
    if (index != printing::COMPLETE_PREVIEW_DOCUMENT_INDEX &&
        index < printing::FIRST_PAGE_INDEX) {
return;
    }

PreviewPageDataMap::iterator it = page_data_map_.find(index);
if (it != page_data_map_.end())
*data = it->second.get();
}

bool ChromeMockRenderThread::OnMessageReceived(const IPC::Message& msg) {
  if (content::MockRenderThread::OnMessageReceived(msg))
    return true;

  bool handled = true;
  bool msg_is_ok = true;
  IPC_BEGIN_MESSAGE_MAP_EX(ChromeMockRenderThread, msg, msg_is_ok)
    IPC_MESSAGE_HANDLER(ExtensionHostMsg_OpenChannelToExtension,
                        OnMsgOpenChannelToExtension)
    IPC_MESSAGE_HANDLER(PrintHostMsg_GetDefaultPrintSettings,
                        OnGetDefaultPrintSettings)
    IPC_MESSAGE_HANDLER(PrintHostMsg_ScriptedPrint, OnScriptedPrint)
    IPC_MESSAGE_HANDLER(PrintHostMsg_UpdatePrintSettings, OnUpdatePrintSettings)
    IPC_MESSAGE_HANDLER(PrintHostMsg_DidGetPrintedPagesCount,
                        OnDidGetPrintedPagesCount)
    IPC_MESSAGE_HANDLER(PrintHostMsg_DidPrintPage, OnDidPrintPage)
    IPC_MESSAGE_HANDLER(PrintHostMsg_DidGetPreviewPageCount,
                        OnDidGetPreviewPageCount)
    IPC_MESSAGE_HANDLER(PrintHostMsg_DidPreviewPage, OnDidPreviewPage)
    IPC_MESSAGE_HANDLER(PrintHostMsg_CheckForCancel, OnCheckForCancel)
#if defined(OS_WIN)
    IPC_MESSAGE_HANDLER(PrintHostMsg_DuplicateSection, OnDuplicateSection)
#endif
#if defined(OS_CHROMEOS)
    IPC_MESSAGE_HANDLER(PrintHostMsg_AllocateTempFileForPrinting,
                        OnAllocateTempFileForPrinting)
    IPC_MESSAGE_HANDLER(PrintHostMsg_TempFileForPrintingWritten,
                        OnTempFileForPrintingWritten)
#endif
    IPC_MESSAGE_UNHANDLED(handled = false)
  IPC_END_MESSAGE_MAP_EX()
  return handled;
 }

void PrintWebViewHelper::PrintPage(WebKit::WebFrame* frame) {
  DCHECK(frame);

  if (prerender::PrerenderHelper::IsPrerendering(render_view())) {
    Send(new ChromeViewHostMsg_CancelPrerenderForPrinting(routing_id()));
    return;
  }

  if (!IsScriptInitiatedPrintAllowed(frame))
    return;
  IncrementScriptedPrintCount();

  if (is_preview_enabled_) {
    print_preview_context_.InitWithFrame(frame);
    RequestPrintPreview(PRINT_PREVIEW_SCRIPTED);
  } else {
    Print(frame, WebNode());
  }
}

void PrintPreviewHandler::RegisterMessages() {
  web_ui()->RegisterMessageCallback("getPrinters",
      base::Bind(&PrintPreviewHandler::HandleGetPrinters,
                 base::Unretained(this)));
  web_ui()->RegisterMessageCallback("getPreview",
      base::Bind(&PrintPreviewHandler::HandleGetPreview,
                 base::Unretained(this)));
  web_ui()->RegisterMessageCallback("print",
      base::Bind(&PrintPreviewHandler::HandlePrint,
                 base::Unretained(this)));
  web_ui()->RegisterMessageCallback("getPrinterCapabilities",
      base::Bind(&PrintPreviewHandler::HandleGetPrinterCapabilities,
                 base::Unretained(this)));
  web_ui()->RegisterMessageCallback("showSystemDialog",
      base::Bind(&PrintPreviewHandler::HandleShowSystemDialog,
                 base::Unretained(this)));
  web_ui()->RegisterMessageCallback("signIn",
      base::Bind(&PrintPreviewHandler::HandleSignin,
                 base::Unretained(this)));
  web_ui()->RegisterMessageCallback("manageCloudPrinters",
      base::Bind(&PrintPreviewHandler::HandleManageCloudPrint,
                 base::Unretained(this)));
  web_ui()->RegisterMessageCallback("manageLocalPrinters",
      base::Bind(&PrintPreviewHandler::HandleManagePrinters,
                 base::Unretained(this)));
  web_ui()->RegisterMessageCallback("closePrintPreviewTab",
      base::Bind(&PrintPreviewHandler::HandleClosePreviewTab,
                 base::Unretained(this)));
  web_ui()->RegisterMessageCallback("hidePreview",
      base::Bind(&PrintPreviewHandler::HandleHidePreview,
                 base::Unretained(this)));
  web_ui()->RegisterMessageCallback("cancelPendingPrintRequest",
      base::Bind(&PrintPreviewHandler::HandleCancelPendingPrintRequest,
                 base::Unretained(this)));
  web_ui()->RegisterMessageCallback("saveLastPrinter",
      base::Bind(&PrintPreviewHandler::HandleSaveLastPrinter,
                 base::Unretained(this)));
  web_ui()->RegisterMessageCallback("getInitialSettings",
      base::Bind(&PrintPreviewHandler::HandleGetInitialSettings,
                 base::Unretained(this)));
  web_ui()->RegisterMessageCallback("reportDestinationEvent",
      base::Bind(&PrintPreviewHandler::HandleReportDestinationEvent,
                 base::Unretained(this)));
  web_ui()->RegisterMessageCallback("printWithCloudPrint",
      base::Bind(&PrintPreviewHandler::HandlePrintWithCloudPrint,
                 base::Unretained(this)));
}

WebContents* PrintPreviewHandler::preview_web_contents() const {
  return web_ui()->GetWebContents();
}

void ChromeMockRenderThread::OnDidPreviewPage(
const PrintHostMsg_DidPreviewPage_Params& params) {
  DCHECK(params.page_number >= printing::FIRST_PAGE_INDEX);
print_preview_pages_remaining_--;
}

 void PrintPreviewUI::OnShowSystemDialog() {
  web_ui()->CallJavascriptFunction("onSystemDialogLinkClicked");
}

void PrintPreviewHandler::PostPrintToPdfTask(base::RefCountedBytes* data) {
  if (!data) {
    NOTREACHED();
    return;
  }
  printing::PreviewMetafile* metafile = new printing::PreviewMetafile;
  metafile->InitFromData(static_cast<const void*>(data->front()), data->size());
#ifdef OS_CHROMEOS
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  gdata::util::PrepareWritableFileAndRun(
      Profile::FromBrowserContext(preview_web_contents()->GetBrowserContext()),
      *print_to_pdf_path_,
      base::Bind(&PrintToPdfCallbackWithCheck, metafile));
#else
  BrowserThread::PostTask(BrowserThread::FILE, FROM_HERE,
                          base::Bind(&PrintToPdfCallback, metafile,
                                     *print_to_pdf_path_));
#endif

  print_to_pdf_path_.reset();
  ActivateInitiatorTabAndClosePreviewTab();
}

bool PrintingFrameHasPageSizeStyle(WebFrame* frame, int total_page_count) {
  if (!frame)
    return false;
  bool frame_has_custom_page_size_style = false;
  for (int i = 0; i < total_page_count; ++i) {
    if (frame->hasCustomPageSizeStyle(i)) {
      frame_has_custom_page_size_style = true;
      break;
    }
  }
  return frame_has_custom_page_size_style;
}

 void PrintPreviewUI::OnPrintPreviewFailed() {
  handler_->OnPrintPreviewFailed();
  web_ui()->CallJavascriptFunction("printPreviewFailed");
}

void PrintPreviewUI::OnReusePreviewData(int preview_request_id) {
  base::StringValue ui_identifier(preview_ui_addr_str_);
base::FundamentalValue ui_preview_request_id(preview_request_id);
web_ui()->CallJavascriptFunction("reloadPreviewPages", ui_identifier,
ui_preview_request_id);
}

 size_t GetConstrainedWindowCount(TabContents* tab) {
   return tab->constrained_window_tab_helper()->constrained_window_count();
}

void PrintPreviewUI::OnCancelPendingPreviewRequest() {
  g_print_preview_request_id_map.Get().Set(preview_ui_addr_str_, -1);
}

bool PrintingNodeOrPdfFrame(const WebFrame* frame, const WebNode& node) {
  if (!node.isNull())
    return true;
  if (!frame->document().isPluginDocument())
    return false;
  WebPlugin* plugin = frame->document().to<WebPluginDocument>().plugin();
  return plugin && plugin->supportsPaginatedPrint();
}

void PrintPreviewUI::OnDidGetPreviewPageCount(
    const PrintHostMsg_DidGetPreviewPageCount_Params& params) {
  DCHECK_GT(params.page_count, 0);
  base::FundamentalValue count(params.page_count);
  base::FundamentalValue request_id(params.preview_request_id);
  web_ui()->CallJavascriptFunction("onDidGetPreviewPageCount",
                                   count,
                                   request_id);
}

void PrintPreviewHandler::FileSelectionCanceled(void* params) {
  PrintPreviewUI* print_preview_ui = static_cast<PrintPreviewUI*>(
      web_ui()->GetController());
  print_preview_ui->OnFileSelectionCancelled();
}

void Set(const std::string& addr, int value) {
base::AutoLock lock(lock_);
    map_[addr] = value;
}

void PrintPreviewHandler::HandlePrint(const ListValue* args) {
  ReportStats();

  UMA_HISTOGRAM_COUNTS("PrintPreview.RegeneratePreviewRequest.BeforePrint",
                       regenerate_preview_request_count_);

  TabContents* initiator_tab = GetInitiatorTab();
  if (initiator_tab) {
    RenderViewHost* rvh = initiator_tab->web_contents()->GetRenderViewHost();
    rvh->Send(new PrintMsg_ResetScriptedPrintCount(rvh->GetRoutingID()));
  }

  scoped_ptr<DictionaryValue> settings(GetSettingsDictionary(args));
  if (!settings.get())
    return;

  printing::StickySettings* sticky_settings = GetStickySettings();
  sticky_settings->Store(*settings);
  sticky_settings->SaveInPrefs(Profile::FromBrowserContext(
      preview_web_contents()->GetBrowserContext())->GetPrefs());
  settings->SetBoolean(printing::kSettingHeaderFooterEnabled, false);

  bool print_to_pdf = false;
  bool is_cloud_printer = false;
  bool is_cloud_dialog = false;

  bool open_pdf_in_preview = false;
#if defined(OS_MACOSX)
  open_pdf_in_preview = settings->HasKey(printing::kSettingOpenPDFInPreview);
#endif

  if (!open_pdf_in_preview) {
    settings->GetBoolean(printing::kSettingPrintToPDF, &print_to_pdf);
    settings->GetBoolean(printing::kSettingCloudPrintDialog, &is_cloud_dialog);
    is_cloud_printer = settings->HasKey(printing::kSettingCloudPrintId);
  }

  if (is_cloud_printer) {
    std::string print_ticket;
    bool res = args->GetString(1, &print_ticket);
    DCHECK(res);
    SendCloudPrintJob(*settings, print_ticket);
  } else if (print_to_pdf) {
    HandlePrintToPdf(*settings);
  } else if (is_cloud_dialog) {
    HandlePrintWithCloudPrint(NULL);
  } else {
    ReportPrintSettingsStats(*settings);
    ReportUserActionHistogram(PRINT_TO_PRINTER);
    UMA_HISTOGRAM_COUNTS("PrintPreview.PageCount.PrintToPrinter",
                         GetPageCountFromSettingsDictionary(*settings));

    PrintPreviewUI* print_preview_ui = static_cast<PrintPreviewUI*>(
        web_ui()->GetController());
    print_preview_ui->OnHidePreviewTab();

    ClearInitiatorTabDetails();

    settings->Remove(printing::kSettingPageRange, NULL);
    RenderViewHost* rvh = preview_web_contents()->GetRenderViewHost();
    rvh->Send(
        new PrintMsg_PrintForPrintPreview(rvh->GetRoutingID(), *settings));

    if (initiator_tab)
      initiator_tab->print_view_manager()->PrintPreviewDone();
  }
}

void PrintingMessageFilter::OnScriptedPrint(
    const PrintHostMsg_ScriptedPrint_Params& params,
    IPC::Message* reply_msg) {
  scoped_refptr<printing::PrinterQuery> printer_query;
  print_job_manager_->PopPrinterQuery(params.cookie, &printer_query);
  if (!printer_query.get()) {
    printer_query = new printing::PrinterQuery;
    printer_query->SetWorkerDestination(print_job_manager_->destination());
  }
  GetPrintSettingsForRenderViewParams settings_params;
  settings_params.ask_user_for_settings = printing::PrinterQuery::ASK_USER;
  settings_params.expected_page_count = params.expected_pages_count;
  settings_params.has_selection = params.has_selection;
  settings_params.margin_type = params.margin_type;

  BrowserThread::PostTask(
      BrowserThread::UI, FROM_HERE,
      base::Bind(&PrintingMessageFilter::GetPrintSettingsForRenderView, this,
                 reply_msg->routing_id(), settings_params,
                 base::Bind(&PrintingMessageFilter::OnScriptedPrintReply, this,
                            printer_query, reply_msg),
                 printer_query));
}

void PrintWebViewHelper::PrintHeaderAndFooter(
    WebKit::WebCanvas* canvas,
    int page_number,
    int total_pages,
    float webkit_scale_factor,
    const PageSizeMargins& page_layout,
    const DictionaryValue& header_footer_info) {
  skia::VectorPlatformDeviceSkia* device =
      static_cast<skia::VectorPlatformDeviceSkia*>(canvas->getTopDevice());
  device->setDrawingArea(SkPDFDevice::kMargin_DrawingArea);

#if defined(USE_RENDER_TEXT)
  scoped_ptr<gfx::RenderText> render_text(gfx::RenderText::CreateInstance());
  render_text->set_clip_to_display_rect(false);
  gfx::FontList font_list(
      gfx::Font(printing::kSettingHeaderFooterFontFamilyName,
                printing::kSettingHeaderFooterFontSize));
  gfx::RenderText* paint = render_text.get();
#else
  SkPaint paint;
  paint.setColor(SK_ColorBLACK);
  paint.setTextEncoding(SkPaint::kUTF16_TextEncoding);
  paint.setTextSize(SkDoubleToScalar(printing::kSettingHeaderFooterFontSize));
  paint.setTypeface(SkTypeface::CreateFromName(
      printing::kSettingHeaderFooterFontFamilyName, SkTypeface::kNormal));
#endif

  string16 date;
  string16 title;
  if (!header_footer_info.GetString(printing::kSettingHeaderFooterTitle,
                                    &title) ||
      !header_footer_info.GetString(printing::kSettingHeaderFooterDate,
                                    &date)) {
    NOTREACHED();
  }
  string16 header_text = date + title;

  SkRect header_vertical_bounds;
#if defined(USE_RENDER_TEXT)
  paint->SetFontList(font_list);
  paint->SetText(header_text);
  {
    gfx::Rect rect(gfx::Point(), paint->GetStringSize());
    header_vertical_bounds = gfx::RectToSkRect(rect);
    header_vertical_bounds.offset(0, -render_text->GetBaseline());
  }
#else
  paint.measureText(header_text.c_str(), header_text.length() * sizeof(char16),
                    &header_vertical_bounds, 0);
#endif

  double text_height = printing::kSettingHeaderFooterInterstice +
                       header_vertical_bounds.height();
  if (text_height <= page_layout.margin_top) {
    PrintHeaderFooterText(date, canvas, paint, webkit_scale_factor, page_layout,
                          printing::LEFT, printing::TOP,
                          header_vertical_bounds.top());
    PrintHeaderFooterText(title, canvas, paint, webkit_scale_factor,
                          page_layout, printing::CENTER, printing::TOP,
                          header_vertical_bounds.top());
  }

  string16 page_of_total_pages = base::IntToString16(page_number) +
                                 UTF8ToUTF16("/") +
                                 base::IntToString16(total_pages);
  string16 url;
  if (!header_footer_info.GetString(printing::kSettingHeaderFooterURL,
                                    &url)) {
    NOTREACHED();
  }
  string16 footer_text = page_of_total_pages + url;

  SkRect footer_vertical_bounds;
#if defined(USE_RENDER_TEXT)
  paint->SetFontList(font_list);
  paint->SetText(footer_text);
  {
    gfx::Rect rect(gfx::Point(), paint->GetStringSize());
    footer_vertical_bounds = gfx::RectToSkRect(rect);
    footer_vertical_bounds.offset(0, -paint->GetBaseline());
  }
#else
  paint.measureText(footer_text.c_str(), footer_text.length() * sizeof(char16),
                    &footer_vertical_bounds, 0);
#endif

  text_height = printing::kSettingHeaderFooterInterstice +
                footer_vertical_bounds.height();
  if (text_height <= page_layout.margin_bottom) {
    PrintHeaderFooterText(page_of_total_pages, canvas, paint,
                          webkit_scale_factor, page_layout, printing::RIGHT,
                          printing::BOTTOM, footer_vertical_bounds.bottom());
    PrintHeaderFooterText(url, canvas, paint, webkit_scale_factor, page_layout,
                          printing::LEFT, printing::BOTTOM,
                          footer_vertical_bounds.bottom());
  }

  device->setDrawingArea(SkPDFDevice::kContent_DrawingArea);
}

PrintMsg_Print_Params::~PrintMsg_Print_Params() {}

void PrintPreviewHandler::ActivateInitiatorTabAndClosePreviewTab() {
  TabContents* initiator_tab = GetInitiatorTab();
  if (initiator_tab) {
    WebContents* web_contents = initiator_tab->web_contents();
    web_contents->GetDelegate()->ActivateContents(web_contents);
  }
  PrintPreviewUI* print_preview_ui = static_cast<PrintPreviewUI*>(
      web_ui()->GetController());
  print_preview_ui->OnClosePrintPreviewTab();
}

void PrintPreviewHandler::HandleGetPreview(const ListValue* args) {
DCHECK_EQ(3U, args->GetSize());
scoped_ptr<DictionaryValue> settings(GetSettingsDictionary(args));
if (!settings.get())
return;
int request_id = -1;
if (!settings->GetInteger(printing::kPreviewRequestID, &request_id))
return;

PrintPreviewUI* print_preview_ui = static_cast<PrintPreviewUI*>(
web_ui()->GetController());
print_preview_ui->OnPrintPreviewRequest(request_id);
// Add an additional key in order to identify |print_preview_ui| later on
// when calling PrintPreviewUI::GetCurrentPrintPreviewStatus() on the IO
// thread.
  settings->SetString(printing::kPreviewUIAddr,
                      print_preview_ui->GetPrintPreviewUIAddress());

// Increment request count.
++regenerate_preview_request_count_;

TabContents* initiator_tab = GetInitiatorTab();
if (!initiator_tab) {
ReportUserActionHistogram(INITIATOR_TAB_CLOSED);
print_preview_ui->OnClosePrintPreviewTab();
return;
}

// Retrieve the page title and url and send it to the renderer process if
// headers and footers are to be displayed.
bool display_header_footer = false;
if (!settings->GetBoolean(printing::kSettingHeaderFooterEnabled,
&display_header_footer)) {
NOTREACHED();
}
if (display_header_footer) {
settings->SetString(printing::kSettingHeaderFooterTitle,
initiator_tab->web_contents()->GetTitle());
std::string url;
NavigationEntry* entry =
initiator_tab->web_contents()->GetController().GetActiveEntry();
if (entry)
url = entry->GetVirtualURL().spec();
settings->SetString(printing::kSettingHeaderFooterURL, url);
}

bool generate_draft_data = false;
bool success = settings->GetBoolean(printing::kSettingGenerateDraftData,
&generate_draft_data);
DCHECK(success);

if (!generate_draft_data) {
double draft_page_count_double = -1;
success = args->GetDouble(1, &draft_page_count_double);
DCHECK(success);
int draft_page_count = static_cast<int>(draft_page_count_double);

bool preview_modifiable = false;
success = args->GetBoolean(2, &preview_modifiable);
DCHECK(success);

if (draft_page_count != -1 && preview_modifiable &&
print_preview_ui->GetAvailableDraftPageCount() != draft_page_count) {
settings->SetBoolean(printing::kSettingGenerateDraftData, true);
}
}

VLOG(1) << "Print preview request start";
RenderViewHost* rvh = initiator_tab->web_contents()->GetRenderViewHost();
rvh->Send(new PrintMsg_PrintPreview(rvh->GetRoutingID(), *settings));
}

PrintMsg_Print_Params::PrintMsg_Print_Params()
: page_size(),
content_size(),
printable_area(),
margin_top(0),
margin_left(0),
dpi(0),
min_shrink(0),
max_shrink(0),
desired_dpi(0),
document_cookie(0),
selection_only(false),
supports_alpha_blend(false),
    preview_ui_addr(),
preview_request_id(0),
is_first_request(false),
print_scaling_option(WebKit::WebPrintScalingOptionSourceSize),
print_to_pdf(false),
display_header_footer(false),
date(),
title(),
url() {
}

  void OnPrintForPrintPreview(const DictionaryValue& dict) {
    PrintWebViewHelper::Get(view_)->OnPrintForPrintPreview(dict);
  }

void RenderParamsFromPrintSettings(const printing::PrintSettings& settings,
                                   PrintMsg_Print_Params* params) {
  params->page_size = settings.page_setup_device_units().physical_size();
  params->content_size.SetSize(
      settings.page_setup_device_units().content_area().width(),
      settings.page_setup_device_units().content_area().height());
  params->printable_area.SetRect(
      settings.page_setup_device_units().printable_area().x(),
      settings.page_setup_device_units().printable_area().y(),
      settings.page_setup_device_units().printable_area().width(),
      settings.page_setup_device_units().printable_area().height());
  params->margin_top = settings.page_setup_device_units().content_area().y();
  params->margin_left = settings.page_setup_device_units().content_area().x();
  params->dpi = settings.dpi();
  params->min_shrink = settings.min_shrink;
  params->max_shrink = settings.max_shrink;
  params->desired_dpi = settings.desired_dpi;
  params->document_cookie = 0;
  params->selection_only = settings.selection_only;
  params->supports_alpha_blend = settings.supports_alpha_blend();

  params->display_header_footer = settings.display_header_footer;
  if (!settings.display_header_footer)
    return;
  params->date = settings.date;
  params->title = settings.title;
  params->url = settings.url;
}

  void VerifyPrintPreviewCancelled(bool did_cancel) {
    bool print_preview_cancelled =
        (render_thread_->sink().GetUniqueMessageMatching(
            PrintHostMsg_PrintPreviewCancelled::ID) != NULL);
    EXPECT_EQ(did_cancel, print_preview_cancelled);
  }

PrepareFrameAndViewForPrint::PrepareFrameAndViewForPrint(
    const PrintMsg_Print_Params& print_params,
    WebFrame* frame,
    const WebNode& node)
        : frame_(frame),
          node_to_print_(node),
          web_view_(frame->view()),
          expected_pages_count_(0),
          use_browser_overlays_(true),
          finished_(false) {
  WebPrintParams webkit_print_params;
  ComputeWebKitPrintParamsInDesiredDpi(print_params, &webkit_print_params);

  if (WebFrame* web_frame = web_view_->mainFrame())
    prev_scroll_offset_ = web_frame->scrollOffset();
  prev_view_size_ = web_view_->size();

  StartPrinting(webkit_print_params);
}

 ChromeMockRenderThread::ChromeMockRenderThread()
     : printer_(new MockPrinter),
       print_dialog_user_response_(true),
      print_preview_cancel_page_number_(-1),
      print_preview_pages_remaining_(0) {
}

void PrintingMessageFilter::GetPrintSettingsForRenderView(
    int render_view_id,
    GetPrintSettingsForRenderViewParams params,
    const base::Closure& callback,
    scoped_refptr<printing::PrinterQuery> printer_query) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  content::WebContents* wc = GetWebContentsForRenderView(render_view_id);

  BrowserThread::PostTask(
      BrowserThread::IO, FROM_HERE,
      base::Bind(&printing::PrinterQuery::GetSettings, printer_query,
                 params.ask_user_for_settings, wc->GetView()->GetNativeView(),
                 params.expected_page_count, params.has_selection,
                 params.margin_type, callback));
}

PrintPreviewHandler::~PrintPreviewHandler() {
  if (select_file_dialog_.get())
    select_file_dialog_->ListenerDestroyed();
}

  PrintPreviewDataStore() {}

void PrintPreviewHandler::ShowSystemDialog() {
  HandleShowSystemDialog(NULL);
}

void PrintMsg_PrintPages_Params::Reset() {
  params.Reset();
  pages = std::vector<int>();
}

  void VerifyPagesPrinted(bool printed) {
#if defined(OS_CHROMEOS)
    bool did_print_msg = (render_thread_->sink().GetUniqueMessageMatching(
        PrintHostMsg_TempFileForPrintingWritten::ID) != NULL);
    ASSERT_EQ(printed, did_print_msg);
#else
    const IPC::Message* print_msg =
        render_thread_->sink().GetUniqueMessageMatching(
            PrintHostMsg_DidPrintPage::ID);
    bool did_print_msg = (NULL != print_msg);
    ASSERT_EQ(printed, did_print_msg);
    if (printed) {
      PrintHostMsg_DidPrintPage::Param post_did_print_page_param;
      PrintHostMsg_DidPrintPage::Read(print_msg, &post_did_print_page_param);
      EXPECT_EQ(0, post_did_print_page_param.a.page_number);
    }
#endif  // defined(OS_CHROMEOS)
  }

void SetPreviewDataForIndex(int index, const base::RefCountedBytes* data) {
    if (index != printing::COMPLETE_PREVIEW_DOCUMENT_INDEX &&
        index < printing::FIRST_PAGE_INDEX) {
return;
    }

page_data_map_[index] = const_cast<base::RefCountedBytes*>(data);
}

void PrintPreviewUI::SetPrintPreviewDataForIndex(
int index,
const base::RefCountedBytes* data) {
  print_preview_data_service()->SetDataEntry(preview_ui_addr_str_, index, data);
}

void PrintPreviewUI::OnPreviewDataIsAvailable(int expected_pages_count,
int preview_request_id) {
VLOG(1) << "Print preview request finished with "
<< expected_pages_count << " pages";

if (!initial_preview_start_time_.is_null()) {
UMA_HISTOGRAM_TIMES("PrintPreview.InitialDisplayTime",
base::TimeTicks::Now() - initial_preview_start_time_);
UMA_HISTOGRAM_COUNTS("PrintPreview.PageCount.Initial",
expected_pages_count);
initial_preview_start_time_ = base::TimeTicks();
}
  base::StringValue ui_identifier(preview_ui_addr_str_);
base::FundamentalValue ui_preview_request_id(preview_request_id);
web_ui()->CallJavascriptFunction("updatePrintPreview", ui_identifier,
ui_preview_request_id);
}

 void ChromeMockRenderThread::OnDidGetPreviewPageCount(
    const PrintHostMsg_DidGetPreviewPageCount_Params& params) {
  print_preview_pages_remaining_ = params.page_count;
}

void ReportPrintSettingHistogram(enum PrintSettingsBuckets setting) {
  UMA_HISTOGRAM_ENUMERATION("PrintPreview.PrintSettings", setting,
                            PRINT_SETTINGS_BUCKET_BOUNDARY);
}

void PrintPreviewHandler::HandleSaveLastPrinter(const ListValue* args) {
  std::string data_to_save;
  if (args->GetString(0, &data_to_save) && !data_to_save.empty())
    GetStickySettings()->StorePrinterName(data_to_save);

  if (args->GetString(1, &data_to_save) && !data_to_save.empty())
    GetStickySettings()->StoreCloudPrintData(data_to_save);
}

  PrintPreviewUIUnitTest() {}

void PrintPreviewHandler::SendPrinterCapabilities(
    const DictionaryValue& settings_info) {
  VLOG(1) << "Get printer capabilities finished";
  scoped_ptr<DictionaryValue> settings(settings_info.DeepCopy());
  if (GetStickySettings()->color_model() != printing::UNKNOWN_COLOR_MODEL) {
    settings->SetBoolean(
        printing::kSettingSetColorAsDefault,
        printing::isColorModelSelected(
            GetStickySettings()->color_model()));
  }
  web_ui()->CallJavascriptFunction("updateWithPrinterCapabilities",
                                   *settings);
}

PrintMsg_PrintPages_Params::~PrintMsg_PrintPages_Params() {}

bool PrintWebViewHelper::UpdatePrintSettings(
WebKit::WebFrame* frame, const WebKit::WebNode& node,
const DictionaryValue& passed_job_settings) {
DCHECK(is_preview_enabled_);
const DictionaryValue* job_settings = &passed_job_settings;
DictionaryValue modified_job_settings;
if (job_settings->empty()) {
if (!print_for_preview_)
print_preview_context_.set_error(PREVIEW_ERROR_BAD_SETTING);
return false;
}

bool source_is_html = true;
if (print_for_preview_) {
if (!job_settings->GetBoolean(printing::kSettingPreviewModifiable,
&source_is_html)) {
NOTREACHED();
}
} else {
source_is_html = !PrintingNodeOrPdfFrame(frame, node);
}

if (print_for_preview_ || !source_is_html) {
modified_job_settings.MergeDictionary(job_settings);
modified_job_settings.SetBoolean(printing::kSettingHeaderFooterEnabled,
false);
modified_job_settings.SetInteger(printing::kSettingMarginsType,
printing::NO_MARGINS);
job_settings = &modified_job_settings;
}

// Send the cookie so that UpdatePrintSettings can reuse PrinterQuery when
// possible.
int cookie = print_pages_params_.get() ?
print_pages_params_->params.document_cookie : 0;
PrintMsg_PrintPages_Params settings;
Send(new PrintHostMsg_UpdatePrintSettings(routing_id(),
cookie, *job_settings, &settings));
print_pages_params_.reset(new PrintMsg_PrintPages_Params(settings));

if (!PrintMsg_Print_Params_IsValid(settings.params)) {
if (!print_for_preview_) {
print_preview_context_.set_error(PREVIEW_ERROR_INVALID_PRINTER_SETTINGS);
} else {
// PrintForPrintPreview
WebKit::WebFrame* print_frame = NULL;
// This may not be the right frame, but the alert will be modal,
// therefore it works well enough.
GetPrintFrame(&print_frame);
if (print_frame) {
render_view()->RunModalAlertDialog(
print_frame,
l10n_util::GetStringUTF16(
IDS_PRINT_PREVIEW_INVALID_PRINTER_SETTINGS));
}
}
return false;
}

if (settings.params.dpi < kMinDpi || !settings.params.document_cookie) {
print_preview_context_.set_error(PREVIEW_ERROR_UPDATING_PRINT_SETTINGS);
return false;
}

if (!print_for_preview_) {
// Validate expected print preview settings.
    if (!job_settings->GetString(printing::kPreviewUIAddr,
                                 &(settings.params.preview_ui_addr)) ||
!job_settings->GetInteger(printing::kPreviewRequestID,
&(settings.params.preview_request_id)) ||
!job_settings->GetBoolean(printing::kIsFirstRequest,
&(settings.params.is_first_request))) {
NOTREACHED();
print_preview_context_.set_error(PREVIEW_ERROR_BAD_SETTING);
return false;
}

settings.params.print_to_pdf = IsPrintToPdfRequested(*job_settings);
UpdateFrameMarginsCssInfo(*job_settings);
settings.params.print_scaling_option = GetPrintScalingOption(
source_is_html, *job_settings, settings.params);

// Header/Footer: Set |header_footer_info_|.
if (settings.params.display_header_footer) {
header_footer_info_.reset(new DictionaryValue());
header_footer_info_->SetString(printing::kSettingHeaderFooterDate,
settings.params.date);
header_footer_info_->SetString(printing::kSettingHeaderFooterURL,
settings.params.url);
header_footer_info_->SetString(printing::kSettingHeaderFooterTitle,
settings.params.title);
}
}

print_pages_params_.reset(new PrintMsg_PrintPages_Params(settings));
Send(new PrintHostMsg_DidGetDocumentCookie(routing_id(),
settings.params.document_cookie));
return true;
}

bool Get(const std::string& addr, int* out_value) {
base::AutoLock lock(lock_);
    PrintPreviewRequestIdMap::const_iterator it = map_.find(addr);
if (it == map_.end())
return false;
*out_value = it->second;
return true;
}

int GetAvailableDraftPageCount() {
int page_data_map_size = page_data_map_.size();
    if (page_data_map_.find(printing::COMPLETE_PREVIEW_DOCUMENT_INDEX) !=
        page_data_map_.end()) {
page_data_map_size--;
    }
return page_data_map_size;
}

void PrintWebViewHelper::OnPrintNodeUnderContextMenu() {
  const WebNode& context_menu_node = render_view()->GetContextMenuNode();
  PrintNode(context_menu_node);
}

void PrintPreviewUI::SetSourceIsModifiable(TabContents* print_preview_tab,
                                           bool source_is_modifiable) {
  if (!print_preview_tab || !print_preview_tab->web_contents()->GetWebUI())
    return;
  PrintPreviewUI* print_preview_ui = static_cast<PrintPreviewUI*>(
      print_preview_tab->web_contents()->GetWebUI()->GetController());
  print_preview_ui->source_is_modifiable_ = source_is_modifiable;
 }

PrintPreviewDataService::~PrintPreviewDataService() {
 }

void PrintHeaderFooterText(
    const string16& text,
    WebKit::WebCanvas* canvas,
    HeaderFooterPaint paint,
    float webkit_scale_factor,
    const PageSizeMargins& page_layout,
    printing::HorizontalHeaderFooterPosition horizontal_position,
    printing::VerticalHeaderFooterPosition vertical_position,
    double offset_to_baseline) {
#if defined(USE_RENDER_TEXT)
  paint->SetText(text);
  paint->SetFontSize(printing::kSettingHeaderFooterFontSize);
  double text_width_in_points = paint->GetStringSize().width();
  SkPoint point = GetHeaderFooterPosition(webkit_scale_factor, page_layout,
                                          horizontal_position,
                                          vertical_position, offset_to_baseline,
                                          text_width_in_points);
  gfx::FontList font_list(
      gfx::Font(printing::kSettingHeaderFooterFontFamilyName,
                printing::kSettingHeaderFooterFontSize / webkit_scale_factor));
  paint->SetFontList(font_list);
  gfx::Size size(paint->GetStringSize());
  gfx::Rect rect(point.x(), point.y() - paint->GetBaseline(),
                 size.width(), size.height());
  paint->SetDisplayRect(rect);
  {
    SkMatrix m = canvas->getTotalMatrix();
    ui::ScaleFactor device_scale_factor = ui::GetScaleFactorFromScale(
        SkScalarAbs(m.getScaleX()));
    scoped_ptr<gfx::Canvas> gfx_canvas(gfx::Canvas::CreateCanvasWithoutScaling(
        canvas, device_scale_factor));
    paint->Draw(gfx_canvas.get());
  }
#else
  size_t text_byte_length = text.length() * sizeof(char16);
  double text_width_in_points = SkScalarToDouble(paint.measureText(
      text.c_str(), text_byte_length));
  SkPoint point = GetHeaderFooterPosition(webkit_scale_factor, page_layout,
                                          horizontal_position,
                                          vertical_position, offset_to_baseline,
                                          text_width_in_points);
  paint.setTextSize(SkDoubleToScalar(
      paint.getTextSize() / webkit_scale_factor));
  canvas->drawText(text.c_str(), text_byte_length, point.x(), point.y(),
                   paint);
#endif
}

void PrintingMessageFilter::OnScriptedPrintReply(
    scoped_refptr<printing::PrinterQuery> printer_query,
    IPC::Message* reply_msg) {
  PrintMsg_PrintPages_Params params;
  if (printer_query->last_status() != printing::PrintingContext::OK ||
      !printer_query->settings().dpi()) {
    params.Reset();
  } else {
    RenderParamsFromPrintSettings(printer_query->settings(), &params.params);
    params.params.document_cookie = printer_query->cookie();
    params.pages =
        printing::PageRange::GetPages(printer_query->settings().ranges);
  }
  PrintHostMsg_ScriptedPrint::WriteReplyParams(reply_msg, params);
  Send(reply_msg);
  if (params.params.dpi && params.params.document_cookie) {
    print_job_manager_->QueuePrinterQuery(printer_query.get());
  } else {
    printer_query->StopWorker();
  }
}

void ChromeMockRenderThread::OnUpdatePrintSettings(
int document_cookie,
const base::DictionaryValue& job_settings,
PrintMsg_PrintPages_Params* params) {
// Check and make sure the required settings are all there.
// We don't actually care about the values.
std::string dummy_string;
int margins_type = 0;
if (!job_settings.GetBoolean(printing::kSettingLandscape, NULL) ||
!job_settings.GetBoolean(printing::kSettingCollate, NULL) ||
!job_settings.GetInteger(printing::kSettingColor, NULL) ||
!job_settings.GetBoolean(printing::kSettingPrintToPDF, NULL) ||
!job_settings.GetBoolean(printing::kIsFirstRequest, NULL) ||
!job_settings.GetString(printing::kSettingDeviceName, &dummy_string) ||
!job_settings.GetInteger(printing::kSettingDuplexMode, NULL) ||
!job_settings.GetInteger(printing::kSettingCopies, NULL) ||
      !job_settings.GetString(printing::kPreviewUIAddr, &dummy_string) ||
!job_settings.GetInteger(printing::kPreviewRequestID, NULL) ||
!job_settings.GetInteger(printing::kSettingMarginsType, &margins_type)) {
return;
}

// Just return the default settings.
  if (printer_.get()) {
    const ListValue* page_range_array;
    printing::PageRanges new_ranges;
    if (job_settings.GetList(printing::kSettingPageRange, &page_range_array)) {
      for (size_t index = 0; index < page_range_array->GetSize(); ++index) {
        const base::DictionaryValue* dict;
        if (!page_range_array->GetDictionary(index, &dict))
          continue;
        printing::PageRange range;
        if (!dict->GetInteger(printing::kSettingPageRangeFrom, &range.from) ||
            !dict->GetInteger(printing::kSettingPageRangeTo, &range.to)) {
          continue;
        }
        // Page numbers are 1-based in the dictionary.
        // Page numbers are 0-based for the printing context.
        range.from--;
        range.to--;
        new_ranges.push_back(range);
}
}
    std::vector<int> pages(printing::PageRange::GetPages(new_ranges));
    printer_->UpdateSettings(document_cookie, params, pages, margins_type);
}
}

void ChromeMockRenderThread::OnScriptedPrint(
const PrintHostMsg_ScriptedPrint_Params& params,
PrintMsg_PrintPages_Params* settings) {
  if (print_dialog_user_response_ && printer_.get()) {
printer_->ScriptedPrint(params.cookie,
params.expected_pages_count,
params.has_selection,
settings);
}
}

void PrintPreviewDataSource::StartDataRequest(const std::string& path,
bool is_incognito,
int request_id) {
// Parent class handles most requests except for the print preview data.
if (!EndsWith(path, "/print.pdf", true)) {
ChromeWebUIDataSource::StartDataRequest(path, is_incognito, request_id);
return;
}

// Print Preview data.
scoped_refptr<base::RefCountedBytes> data;
std::vector<std::string> url_substr;
base::SplitString(path, '/', &url_substr);
int page_index = 0;
  if (url_substr.size() == 3 && base::StringToInt(url_substr[1], &page_index)) {
PrintPreviewDataService::GetInstance()->GetDataEntry(
        url_substr[0], page_index, &data);
}
if (data.get()) {
SendResponse(request_id, data);
return;
}
// Invalid request.
scoped_refptr<base::RefCountedBytes> empty_bytes(new base::RefCountedBytes);
SendResponse(request_id, empty_bytes);
}

void PrintPreviewHandler::HandleGetPrinterCapabilities(const ListValue* args) {
  std::string printer_name;
  bool ret = args->GetString(0, &printer_name);
  if (!ret || printer_name.empty())
    return;

  scoped_refptr<PrintSystemTaskProxy> task =
      new PrintSystemTaskProxy(AsWeakPtr(),
                               print_backend_.get(),
                               has_logged_printers_count_);

  BrowserThread::PostTask(
      BrowserThread::FILE, FROM_HERE,
      base::Bind(&PrintSystemTaskProxy::GetPrinterCapabilities, task.get(),
                 printer_name));
}

void PrintToPdfCallbackWithCheck(Metafile* metafile,
                                 gdata::DriveFileError error,
                                 const FilePath& path) {
  if (error != gdata::DRIVE_FILE_OK) {
    LOG(ERROR) << "Save to pdf failed to write: " << error;
  } else {
    metafile->SaveTo(path);
  }
  BrowserThread::PostTask(
      BrowserThread::UI, FROM_HERE,
      base::Bind(&base::DeletePointer<Metafile>, metafile));
}

  void VerifyPrintFailed(bool did_fail) {
    bool print_failed = (render_thread_->sink().GetUniqueMessageMatching(
        PrintHostMsg_PrintingFailed::ID) != NULL);
    EXPECT_EQ(did_fail, print_failed);
  }

int PrintPreviewUI::GetAvailableDraftPageCount() {
  return print_preview_data_service()->GetAvailableDraftPageCount(
      preview_ui_addr_str_);
}

void PrepareFrameAndViewForPrint::StartPrinting(
    const WebPrintParams& webkit_print_params) {
  web_print_params_ = webkit_print_params;

  gfx::Size print_layout_size(web_print_params_.printContentArea.width,
                              web_print_params_.printContentArea.height);
  print_layout_size.set_height(static_cast<int>(
      static_cast<double>(print_layout_size.height()) * 1.25));

  web_view_->resize(print_layout_size);

  expected_pages_count_ = frame_->printBegin(web_print_params_,
                                             node_to_print_,
                                             &use_browser_overlays_);
}

void PrintPreviewUI::GetPrintPreviewDataForIndex(
int index,
scoped_refptr<base::RefCountedBytes>* data) {
  print_preview_data_service()->GetDataEntry(preview_ui_addr_str_, index, data);
}

void PrintPreviewHandler::OnPrintDialogShown() {
  ActivateInitiatorTabAndClosePreviewTab();
}

void PrintPreviewHandler::SendCloudPrintJob(const DictionaryValue& settings,
                                            std::string print_ticket) {
  ReportUserActionHistogram(PRINT_WITH_CLOUD_PRINT);
  scoped_refptr<base::RefCountedBytes> data;
  PrintPreviewUI* print_preview_ui = static_cast<PrintPreviewUI*>(
      web_ui()->GetController());
  print_preview_ui->GetPrintPreviewDataForIndex(
      printing::COMPLETE_PREVIEW_DOCUMENT_INDEX, &data);
  if (data.get() && data->size() > 0U && data->front()) {
    string16 print_job_title_utf16 =
        preview_tab_contents()->print_view_manager()->RenderSourceName();
    std::string print_job_title = UTF16ToUTF8(print_job_title_utf16);
    std::string printer_id;
    settings.GetString(printing::kSettingCloudPrintId, &printer_id);
    std::string raw_data(reinterpret_cast<const char*>(data->front()),
                         data->size());
    std::string base64_data;
    if (!base::Base64Encode(raw_data, &base64_data)) {
      NOTREACHED() << "Base64 encoding PDF data.";
    }

    const char boundary[] = "----CloudPrintFormBoundaryjc9wuprokl8i";
    const char prolog[] = "--%s\r\n"
      "Content-Disposition: form-data; name=\"capabilities\"\r\n\r\n%s\r\n"
      "--%s\r\n"
      "Content-Disposition: form-data; name=\"contentType\"\r\n\r\ndataUrl\r\n"
      "--%s\r\n"
      "Content-Disposition: form-data; name=\"title\"\r\n\r\n%s\r\n"
      "--%s\r\n"
      "Content-Disposition: form-data; name=\"printerid\"\r\n\r\n%s\r\n"
      "--%s\r\n"
      "Content-Disposition: form-data; name=\"content\"\r\n\r\n"
      "data:application/pdf;base64,%s\r\n"
      "--%s\r\n";

    std::string final_data;
    base::SStringPrintf(&final_data,
                        prolog,
                        boundary,
                        print_ticket.c_str(),
                        boundary,
                        boundary,
                        print_job_title.c_str(),
                        boundary,
                        printer_id.c_str(),
                        boundary,
                        base64_data.c_str(),
                        boundary);

    StringValue data_value(final_data);

    web_ui()->CallJavascriptFunction("printToCloud", data_value);
  } else {
    NOTREACHED();
  }
}

void PrintPreviewHandler::OnTabDestroyed() {
  TabContents* initiator_tab = GetInitiatorTab();
  if (!initiator_tab)
    return;

  initiator_tab->print_view_manager()->set_observer(NULL);
}

void PrintWebViewHelper::UpdateFrameMarginsCssInfo(
    const DictionaryValue& settings) {
  int margins_type = 0;
  if (!settings.GetInteger(printing::kSettingMarginsType, &margins_type))
    margins_type = printing::DEFAULT_MARGINS;
  ignore_css_margins_ = margins_type != printing::DEFAULT_MARGINS;
}

void PrintWebViewHelper::OnPrintForPrintPreview(
    const DictionaryValue& job_settings) {
  DCHECK(is_preview_enabled_);
  if (print_web_view_)
    return;

  if (!render_view()->GetWebView())
    return;
  WebFrame* main_frame = render_view()->GetWebView()->mainFrame();
  if (!main_frame)
    return;

  WebDocument document = main_frame->document();
  WebElement pdf_element = document.getElementById("pdf-viewer");
  if (pdf_element.isNull()) {
    NOTREACHED();
    return;
  }

  AutoReset<bool> set_printing_flag(&print_for_preview_, true);

  WebFrame* pdf_frame = pdf_element.document().frame();
  if (!UpdatePrintSettings(pdf_frame, pdf_element, job_settings)) {
    LOG(ERROR) << "UpdatePrintSettings failed";
    DidFinishPrinting(FAIL_PRINT);
    return;
  }

  if (!RenderPagesForPrint(pdf_frame, pdf_element)) {
    LOG(ERROR) << "RenderPagesForPrint failed";
    DidFinishPrinting(FAIL_PRINT);
  }
}

  void OnPrintPreview(const DictionaryValue& dict) {
    PrintWebViewHelper* print_web_view_helper = PrintWebViewHelper::Get(view_);
    print_web_view_helper->OnInitiatePrintPreview();
    print_web_view_helper->OnPrintPreview(dict);
  }

bool PrintWebViewHelper::IsScriptInitiatedPrintAllowed(
    WebKit::WebFrame* frame) {
  if (is_scripted_printing_blocked_)
    return false;
  return !IsScriptInitiatedPrintTooFrequent(frame);
}

void PrintPreviewUI::OnReloadPrintersList() {
  web_ui()->CallJavascriptFunction("reloadPrintersList");
}

void PrintingMessageFilter::OnTempFileForPrintingWritten(int render_view_id,
                                                         int sequence_number) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::FILE));
  SequenceToPathMap* map = &g_printing_file_descriptor_map.Get().map;
  SequenceToPathMap::iterator it = map->find(sequence_number);
  if (it == map->end()) {
    NOTREACHED() << "Got a sequence that we didn't pass to the "
                    "renderer: " << sequence_number;
    return;
  }
  BrowserThread::PostTask(
      BrowserThread::UI, FROM_HERE,
      base::Bind(&PrintingMessageFilter::CreatePrintDialogForFile,
                 this, render_view_id, it->second));

  map->erase(it);
}

void PrintingMessageFilter::OnUpdatePrintSettings(
    int document_cookie, const DictionaryValue& job_settings,
    IPC::Message* reply_msg) {
  scoped_refptr<printing::PrinterQuery> printer_query;
  if (!profile_io_data_->printing_enabled()->GetValue()) {
    OnUpdatePrintSettingsReply(printer_query, reply_msg);
    return;
  }

  print_job_manager_->PopPrinterQuery(document_cookie, &printer_query);
  if (!printer_query.get()) {
    printer_query = new printing::PrinterQuery;
    printer_query->SetWorkerDestination(print_job_manager_->destination());
  }
  printer_query->SetSettings(
      job_settings,
      base::Bind(&PrintingMessageFilter::OnUpdatePrintSettingsReply, this,
                 printer_query, reply_msg));
}

bool PrintWebViewHelper::CreatePreviewDocument() {
  PrintMsg_Print_Params print_params = print_pages_params_->params;
  const std::vector<int>& pages = print_pages_params_->pages;
  if (!print_preview_context_.CreatePreviewDocument(&print_params, pages,
                                                    ignore_css_margins_)) {
    return false;
  }

  PageSizeMargins default_page_layout;
  ComputePageLayoutInPointsForCss(print_preview_context_.frame(), 0,
                                  print_params, ignore_css_margins_, NULL,
                                  &default_page_layout);

  if (!old_print_pages_params_.get() ||
      !PageLayoutIsEqual(*old_print_pages_params_, *print_pages_params_)) {
    bool has_page_size_style = PrintingFrameHasPageSizeStyle(
        print_preview_context_.frame(),
        print_preview_context_.total_page_count());
    int dpi = GetDPI(&print_params);
    gfx::Rect printable_area_in_points(
      ConvertUnit(print_pages_params_->params.printable_area.x(),
          dpi, printing::kPointsPerInch),
      ConvertUnit(print_pages_params_->params.printable_area.y(),
          dpi, printing::kPointsPerInch),
      ConvertUnit(print_pages_params_->params.printable_area.width(),
          dpi, printing::kPointsPerInch),
      ConvertUnit(print_pages_params_->params.printable_area.height(),
          dpi, printing::kPointsPerInch));

    Send(new PrintHostMsg_DidGetDefaultPageLayout(routing_id(),
                                                  default_page_layout,
                                                  printable_area_in_points,
                                                  has_page_size_style));
  }

  PrintHostMsg_DidGetPreviewPageCount_Params params;
  params.page_count = print_preview_context_.total_page_count();
  params.is_modifiable = print_preview_context_.IsModifiable();
  params.document_cookie = print_pages_params_->params.document_cookie;
  params.preview_request_id = print_pages_params_->params.preview_request_id;
  params.clear_preview_data = print_preview_context_.generate_draft_pages();
  Send(new PrintHostMsg_DidGetPreviewPageCount(routing_id(), params));
  if (CheckForCancel())
    return false;

  while (!print_preview_context_.IsFinalPageRendered()) {
    int page_number = print_preview_context_.GetNextPageNumber();
    DCHECK_GE(page_number, 0);
    if (!RenderPreviewPage(page_number))
      return false;

    if (CheckForCancel())
      return false;

    if (print_preview_context_.IsFinalPageRendered())
      print_preview_context_.AllPagesRendered();

    if (print_preview_context_.IsLastPageOfPrintReadyMetafile()) {
      DCHECK(print_preview_context_.IsModifiable() ||
             print_preview_context_.IsFinalPageRendered());
      if (!FinalizePrintReadyDocument())
        return false;
    }
  }
  print_preview_context_.Finished();
  return true;
}

PrintMsg_Print_Params GetCssPrintParams(
    WebFrame* frame,
    int page_index,
    const PrintMsg_Print_Params& page_params) {
  PrintMsg_Print_Params page_css_params = page_params;
  int dpi = GetDPI(&page_params);
  WebSize page_size_in_pixels(
      ConvertUnit(page_params.page_size.width(),
                  dpi, printing::kPixelsPerInch),
      ConvertUnit(page_params.page_size.height(),
                  dpi, printing::kPixelsPerInch));
  int margin_top_in_pixels = ConvertUnit(
      page_params.margin_top,
      dpi, printing::kPixelsPerInch);
  int margin_right_in_pixels = ConvertUnit(
      page_params.page_size.width() -
      page_params.content_size.width() - page_params.margin_left,
      dpi, printing::kPixelsPerInch);
  int margin_bottom_in_pixels = ConvertUnit(
      page_params.page_size.height() -
      page_params.content_size.height() - page_params.margin_top,
      dpi, printing::kPixelsPerInch);
  int margin_left_in_pixels = ConvertUnit(
      page_params.margin_left,
      dpi, printing::kPixelsPerInch);

  WebSize original_page_size_in_pixels = page_size_in_pixels;

  if (frame) {
    frame->pageSizeAndMarginsInPixels(page_index,
                                      page_size_in_pixels,
                                      margin_top_in_pixels,
                                      margin_right_in_pixels,
                                      margin_bottom_in_pixels,
                                      margin_left_in_pixels);
  }

  int new_content_width = page_size_in_pixels.width -
                          margin_left_in_pixels - margin_right_in_pixels;
  int new_content_height = page_size_in_pixels.height -
                           margin_top_in_pixels - margin_bottom_in_pixels;

  if (new_content_width < 1 || new_content_height < 1) {
    CHECK(frame != NULL);
    page_css_params = GetCssPrintParams(NULL, page_index, page_params);
    return page_css_params;
  }

  page_css_params.content_size = gfx::Size(
      static_cast<int>(ConvertUnit(new_content_width,
          printing::kPixelsPerInch, dpi)),
      static_cast<int>(ConvertUnit(new_content_height,
          printing::kPixelsPerInch, dpi)));

  if (original_page_size_in_pixels != page_size_in_pixels) {
    page_css_params.page_size = gfx::Size(
        static_cast<int>(ConvertUnit(page_size_in_pixels.width,
            printing::kPixelsPerInch, dpi)),
        static_cast<int>(ConvertUnit(page_size_in_pixels.height,
            printing::kPixelsPerInch, dpi)));
  } else {
    page_css_params.page_size = page_params.page_size;
  }

  page_css_params.margin_top =
      static_cast<int>(ConvertUnit(margin_top_in_pixels,
          printing::kPixelsPerInch, dpi));

  page_css_params.margin_left =
      static_cast<int>(ConvertUnit(margin_left_in_pixels,
          printing::kPixelsPerInch, dpi));
  return page_css_params;
}

void ChromeMockRenderThread::OnGetDefaultPrintSettings(
PrintMsg_Print_Params* params) {
  if (printer_.get())
    printer_->GetDefaultPrintSettings(params);
}

void PrintPreviewDataService::RemoveEntry(
    const std::string& preview_ui_addr_str) {
  PreviewDataStoreMap::iterator it = data_store_map_.find(preview_ui_addr_str);
  if (it != data_store_map_.end())
    data_store_map_.erase(it);
}

void Erase(const std::string& addr) {
base::AutoLock lock(lock_);
    map_.erase(addr);
}

int ChromeMockRenderThread::print_preview_pages_remaining() {
   return print_preview_pages_remaining_;
 }

void PrintPreviewUI::OnHidePreviewTab() {
  TabContents* preview_tab =
      TabContents::FromWebContents(web_ui()->GetWebContents());
  printing::BackgroundPrintingManager* background_printing_manager =
      g_browser_process->background_printing_manager();
  if (background_printing_manager->HasPrintPreviewTab(preview_tab))
    return;

  ConstrainedWebDialogDelegate* delegate = GetConstrainedDelegate();
  if (!delegate)
    return;
  delegate->ReleaseTabContentsOnDialogClose();
  background_printing_manager->OwnPrintPreviewTab(preview_tab);
  OnClosePrintPreviewTab();
}

bool PrintWebViewHelper::PrintPreviewContext::CreatePreviewDocument(
    PrintMsg_Print_Params* print_params,
    const std::vector<int>& pages,
    bool ignore_css_margins) {
  DCHECK_EQ(INITIALIZED, state_);
  state_ = RENDERING;

  metafile_.reset(new printing::PreviewMetafile);
  if (!metafile_->Init()) {
    set_error(PREVIEW_ERROR_METAFILE_INIT_FAILED);
    LOG(ERROR) << "PreviewMetafile Init failed";
    return false;
  }

  prep_frame_view_.reset(new PrepareFrameAndViewForPrint(*print_params, frame(),
                                                         node()));
  UpdateFrameAndViewFromCssPageLayout(frame_, node_, prep_frame_view_.get(),
                                      *print_params, ignore_css_margins);

  print_params_.reset(new PrintMsg_Print_Params(*print_params));

  total_page_count_ = prep_frame_view_->GetExpectedPageCount();
  if (total_page_count_ == 0) {
    LOG(ERROR) << "CreatePreviewDocument got 0 page count";
    set_error(PREVIEW_ERROR_ZERO_PAGES);
    return false;
  }

  int selected_page_count = pages.size();
  current_page_index_ = 0;
  print_ready_metafile_page_count_ = selected_page_count;
  pages_to_render_ = pages;

  if (selected_page_count == 0) {
    print_ready_metafile_page_count_ = total_page_count_;
    for (int i = 0; i < total_page_count_; ++i)
      pages_to_render_.push_back(i);
  } else if (generate_draft_pages_) {
    int pages_index = 0;
    for (int i = 0; i < total_page_count_; ++i) {
      if (pages_index < selected_page_count && i == pages[pages_index]) {
        pages_index++;
        continue;
      }
      pages_to_render_.push_back(i);
    }
  }

  document_render_time_ = base::TimeDelta();
  begin_time_ = base::TimeTicks::Now();

  return true;
}

void PrintPreviewHandler::HandleCancelPendingPrintRequest(
    const ListValue* /*args*/) {
  TabContents* initiator_tab = GetInitiatorTab();
  if (initiator_tab)
    ClearInitiatorTabDetails();
  gfx::NativeWindow parent = initiator_tab ?
      initiator_tab->web_contents()->GetView()->GetTopLevelNativeWindow() :
      NULL;
  chrome::ShowPrintErrorDialog(parent);
}

void PrintPreviewHandler::HandleManageCloudPrint(const ListValue* /*args*/) {
  ++manage_cloud_printers_dialog_request_count_;
  Profile* profile = Profile::FromBrowserContext(
      preview_web_contents()->GetBrowserContext());
  preview_web_contents()->OpenURL(
      OpenURLParams(
          CloudPrintURL(profile).GetCloudPrintServiceManageURL(),
          Referrer(),
          NEW_FOREGROUND_TAB,
          content::PAGE_TRANSITION_LINK,
          false));
}

PrintPreviewDataSource::PrintPreviewDataSource()
    : ChromeWebUIDataSource(chrome::kChromeUIPrintHost) {
  Init();
}
