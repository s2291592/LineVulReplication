status_t writeByteVectorInternalPtr(Parcel* parcel,
 const std::unique_ptr<std::vector<T>>& val)
{
 if (!val) {
 return parcel->writeInt32(-1);
 }

 return writeByteVectorInternal(parcel, *val);
}

size_t String8::length() const
{
 return SharedBuffer::sizeFromData(mString)-1;
}

status_t String8::append(const char* other, size_t otherLen)
{
 if (bytes() == 0) {
 return setTo(other, otherLen);
 } else if (otherLen == 0) {
 return NO_ERROR;
 }

 return real_append(other, otherLen);
}

MediaPlayerService::Client::Client(
 const sp<MediaPlayerService>& service, pid_t pid,
 int32_t connId, const sp<IMediaPlayerClient>& client,
 audio_session_t audioSessionId, uid_t uid)
{
    ALOGV("Client(%d) constructor", connId);
    mPid = pid;
    mConnId = connId;
    mService = service;
    mClient = client;
    mLoop = false;
    mStatus = NO_INIT;
    mAudioSessionId = audioSessionId;
    mUID = uid;
    mRetransmitEndpointValid = false;
    mAudioAttributes = NULL;

#if CALLBACK_ANTAGONIZER
    ALOGD("create Antagonizer");
    mAntagonizer = new Antagonizer(notify, this);
#endif
}

status_t Parcel::writeString16(const std::unique_ptr<String16>& str)
{
 if (!str) {
 return writeInt32(-1);
 }

 return writeString16(*str);
}

void String8::setPathName(const char* name, size_t len)
{
 char* buf = lockBuffer(len);

    memcpy(buf, name, len);

 if (len > 0 && buf[len-1] == OS_PATH_SEPARATOR)
        len--;

    buf[len] = '\0';

    unlockBuffer(len);
}

status_t String8::appendFormat(const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);

 status_t result = appendFormatV(fmt, args);

    va_end(args);
 return result;
}

status_t Parcel::writeRawNullableParcelable(const Parcelable* parcelable) {
 if (!parcelable) {
 return writeInt32(0);
 }

 return writeParcelable(*parcelable);
}

ssize_t String8::find(const char* other, size_t start) const
{
 size_t len = size();
 if (start >= len) {
 return -1;
 }
 const char* s = mString+start;
 const char* p = strstr(s, other);
 return p ? p-mString : -1;
}

size_t utf8_to_utf32_length(const char *src, size_t src_len)
{
 if (src == NULL || src_len == 0) {
 return 0;
 }
 size_t ret = 0;
 const char* cur;
 const char* end;
 size_t num_to_skip;
 for (cur = src, end = src + src_len, num_to_skip = 1;
         cur < end;
         cur += num_to_skip, ret++) {
 const char first_char = *cur;
        num_to_skip = 1;
 if ((first_char & 0x80) == 0) { // ASCII
 continue;
 }
 int32_t mask;

 for (mask = 0x40; (first_char & mask); num_to_skip++, mask >>= 1) {
 }
 }
 return ret;
}

void terminate_string8()
{
 SharedBuffer::bufferFromData(gEmptyString)->release();
    gEmptyStringBuf = NULL;
    gEmptyString = NULL;
}

String8& String8::appendPath(const char* name)
{
 if (name[0] != OS_PATH_SEPARATOR) {
 if (*name == '\0') {
 return *this;
 }

 size_t len = length();
 if (len == 0) {
            setPathName(name);
 return *this;
 }

 int newlen = strlen(name);

 char* buf = lockBuffer(len+1+newlen);

 if (buf[len-1] != OS_PATH_SEPARATOR)
            buf[len++] = OS_PATH_SEPARATOR;

        memcpy(buf+len, name, newlen+1);
        len += newlen;

        unlockBuffer(len);

 return *this;
 } else {
        setPathName(name);
 return *this;
 }
}

status_t Parcel::readInt64Vector(std::vector<int64_t>* val) const {
 return readTypedVector(val, &Parcel::readInt64);
}

String8 String8::getBasePath(void) const
{
 char* ext;
 const char* const str = mString;

    ext = find_extension();
 if (ext == NULL)
 return String8(*this);
 else
 return String8(str, ext - str);
}

void String8::getUtf32(char32_t* dst) const
{
    utf8_to_utf32(mString, length(), dst);
}

std::vector<std::string> splitAndLowercase(const StringPiece& str, char sep) {
 return splitAndTransform(str, sep, ::tolower);
}

status_t Parcel::readDoubleVector(std::vector<double>* val) const {
 return readTypedVector(val, &Parcel::readDouble);
}

void utf8_to_utf16(const uint8_t* u8str, size_t u8len, char16_t* u16str) {
 char16_t* end = utf8_to_utf16_no_null_terminator(u8str, u8len, u16str);
 *end = 0;
}

status_t Parcel::writeInt64Vector(const std::vector<int64_t>& val)
{
 return writeTypedVector(val, &Parcel::writeInt64);
}

String8::String8(const char32_t* o)
 : mString(allocFromUTF32(o, strlen32(o)))
{
}

ssize_t utf16_to_utf8_length(const char16_t *src, size_t src_len)
{
if (src == NULL || src_len == 0) {
return -1;
}

size_t ret = 0;

const char16_t* const end = src + src_len;
while (src < end) {
if ((*src & 0xFC00) == 0xD800 && (src + 1) < end
                && (*++src & 0xFC00) == 0xDC00) {
// surrogate pairs are always 4 bytes.
ret += 4;
            src++;
} else {
ret += utf32_codepoint_utf8_length((char32_t) *src++);
}
}
return ret;
}

status_t String8::setTo(const char* other)
{
 const char *newString = allocFromUTF8(other, strlen(other));
 SharedBuffer::bufferFromData(mString)->release();
    mString = newString;
 if (mString) return NO_ERROR;

    mString = getEmptyString();
 return NO_MEMORY;
}

status_t Parcel::readDoubleVector(std::unique_ptr<std::vector<double>>* val) const {
 return readNullableTypedVector(val, &Parcel::readDouble);
}

StringPiece trimWhitespace(const StringPiece& str) {
 if (str.size() == 0 || str.data() == nullptr) {
 return str;
 }

 const char* start = str.data();
 const char* end = str.data() + str.length();

 while (start != end && isspace(*start)) {
        start++;
 }

 while (end != start && isspace(*(end - 1))) {
        end--;
 }

 return StringPiece(start, end - start);
}

status_t writeByteVectorInternal(Parcel* parcel, const std::vector<T>& val)
{
 status_t status;
 if (val.size() > std::numeric_limits<int32_t>::max()) {
        status = BAD_VALUE;
 return status;
 }

    status = parcel->writeInt32(val.size());
 if (status != OK) {
 return status;
 }

 void* data = parcel->writeInplace(val.size());
 if (!data) {
        status = BAD_VALUE;
 return status;
 }

    memcpy(data, val.data(), val.size());
 return status;
}

 virtual void SetUp() {
 }

void utf8_to_utf32(const char* src, size_t src_len, char32_t* dst)
{
 if (src == NULL || src_len == 0 || dst == NULL) {
 return;
 }

 const char* cur = src;
 const char* const end = src + src_len;
 char32_t* cur_utf32 = dst;
 while (cur < end) {
 size_t num_read;
 *cur_utf32++ = static_cast<char32_t>(utf32_at_internal(cur, &num_read));
        cur += num_read;
 }
 *cur_utf32 = 0;
}

status_t Parcel::readStrongBinderVector(std::unique_ptr<std::vector<sp<IBinder>>>* val) const {
 return readNullableTypedVector(val, &Parcel::readStrongBinder);
}

static inline size_t utf32_codepoint_utf8_length(char32_t srcChar)
{
 if (srcChar < 0x00000080) {
 return 1;
 } else if (srcChar < 0x00000800) {
 return 2;
 } else if (srcChar < 0x00010000) {
 if ((srcChar < kUnicodeSurrogateStart) || (srcChar > kUnicodeSurrogateEnd)) {
 return 3;
 } else {
 return 0;
 }
 }
 else if (srcChar <= kUnicodeMaxCodepoint) {
 return 4;
 } else {
 return 0;
 }
}

int32_t utf32_from_utf8_at(const char *src, size_t src_len, size_t index, size_t *next_index)
{
 if (index >= src_len) {
 return -1;
 }
 size_t dummy_index;
 if (next_index == NULL) {
        next_index = &dummy_index;
 }
 size_t num_read;
 int32_t ret = utf32_at_internal(src + index, &num_read);
 if (ret >= 0) {
 *next_index = index + num_read;
 }

 return ret;
}

status_t Parcel::writeUniqueFileDescriptorVector(const std::unique_ptr<std::vector<ScopedFd>>& val) {
 return writeNullableTypedVector(val, &Parcel::writeUniqueFileDescriptor);
}

String8 String8::formatV(const char* fmt, va_list args)
{
 String8 result;
    result.appendFormatV(fmt, args);
 return result;
}

status_t Parcel::writeInt64Vector(const std::unique_ptr<std::vector<int64_t>>& val)
{
 return writeNullableTypedVector(val, &Parcel::writeInt64);
}

status_t Parcel::writeString16Vector(const std::vector<String16>& val)
{
 return writeTypedVector(val, &Parcel::writeString16);
}

int Parcel::readFileDescriptor() const
{
 const flat_binder_object* flat = readObject(true);

 if (flat && flat->type == BINDER_TYPE_FD) {
 return flat->handle;
 }

 return BAD_TYPE;
}

char* String8::lockBuffer(size_t size)
{
 SharedBuffer* buf = SharedBuffer::bufferFromData(mString)
 ->editResize(size+1);
 if (buf) {
 char* str = (char*)buf->data();
        mString = str;
 return str;
 }
 return NULL;
}

status_t Parcel::readInt32Vector(std::unique_ptr<std::vector<int32_t>>* val) const {
 return readNullableTypedVector(val, &Parcel::readInt32);
}

status_t Parcel::readUniqueFileDescriptorVector(std::vector<ScopedFd>* val) const {
 return readTypedVector(val, &Parcel::readUniqueFileDescriptor);
}

void String8::toLower(size_t start, size_t length)
{
 const size_t len = size();
 if (start >= len) {
 return;
 }
 if (start+length > len) {
        length = len-start;
 }
 char* buf = lockBuffer(len);
    buf += start;
 while (length > 0) {
 *buf = tolower(*buf);
        buf++;
        length--;
 }
    unlockBuffer(len);
}

String8 String8::format(const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);

 String8 result(formatV(fmt, args));

    va_end(args);
 return result;
}

char* String8::find_extension(void) const
{
 const char* lastSlash;
 const char* lastDot;
 const char* const str = mString;

    lastSlash = strrchr(str, OS_PATH_SEPARATOR);
 if (lastSlash == NULL)
        lastSlash = str;
 else
        lastSlash++;

    lastDot = strrchr(lastSlash, '.');
 if (lastDot == NULL)
 return NULL;

 return const_cast<char*>(lastDot);
}

status_t String8::unlockBuffer(size_t size)
{
 if (size != this->size()) {
 SharedBuffer* buf = SharedBuffer::bufferFromData(mString)
 ->editResize(size+1);
 if (! buf) {
 return NO_MEMORY;
 }

 char* str = (char*)buf->data();
        str[size] = 0;
        mString = str;
 }

 return NO_ERROR;
}

String8 String8::getPathExtension(void) const
{
 char* ext;

    ext = find_extension();
 if (ext != NULL)
 return String8(ext);
 else
 return String8("");
}

status_t Parcel::writeNoException()
{
    binder::Status status;
 return status.writeToParcel(this);
}

status_t MediaPlayerService::Client::setNextPlayer(const sp<IMediaPlayer>& player) {
    ALOGV("setNextPlayer");
 Mutex::Autolock l(mLock);
    sp<Client> c = static_cast<Client*>(player.get());
    mNextClient = c;

 if (c != NULL) {
 if (mAudioOutput != NULL) {
            mAudioOutput->setNextOutput(c->mAudioOutput);
 } else if ((mPlayer != NULL) && !mPlayer->hardwareOutput()) {
            ALOGE("no current audio output");
 }

 if ((mPlayer != NULL) && (mNextClient->getPlayer() != NULL)) {
            mPlayer->setNextPlayer(mNextClient->getPlayer());
 }
 }

 return OK;
}

bool String8::removeAll(const char* other) {
 ssize_t index = find(other);
 if (index < 0) return false;

 char* buf = lockBuffer(size());
 if (!buf) return false; // out of memory

 size_t skip = strlen(other);
 size_t len = size();
 size_t tail = index;
 while (size_t(index) < len) {
 ssize_t next = find(other, index + skip);
 if (next < 0) {
            next = len;
 }

        memmove(buf + tail, buf + index + skip, next - index - skip);
        tail += next - index - skip;
        index = next;
 }
    unlockBuffer(tail);
 return true;
}

void String8::toUpper(size_t start, size_t length)
{
 const size_t len = size();
 if (start >= len) {
 return;
 }
 if (start+length > len) {
        length = len-start;
 }
 char* buf = lockBuffer(len);
    buf += start;
 while (length > 0) {
 *buf = toupper(*buf);
        buf++;
        length--;
 }
    unlockBuffer(len);
}

status_t Parcel::writeDoubleVector(const std::unique_ptr<std::vector<double>>& val)
{
 return writeNullableTypedVector(val, &Parcel::writeDouble);
}

status_t Parcel::writeDoubleVector(const std::vector<double>& val)
{
 return writeTypedVector(val, &Parcel::writeDouble);
}

status_t String8::append(const char* other)
{
 return append(other, strlen(other));
}

status_t Parcel::writeStrongBinderVector(const std::unique_ptr<std::vector<sp<IBinder>>>& val)
{
 return writeNullableTypedVector(val, &Parcel::writeStrongBinder);
}

static inline int32_t utf32_at_internal(const char* cur, size_t *num_read)
{
 const char first_char = *cur;
 if ((first_char & 0x80) == 0) { // ASCII
 *num_read = 1;
 return *cur;
 }
    cur++;
 char32_t mask, to_ignore_mask;
 size_t num_to_read = 0;
 char32_t utf32 = first_char;
 for (num_to_read = 1, mask = 0x40, to_ignore_mask = 0xFFFFFF80;
 (first_char & mask);
         num_to_read++, to_ignore_mask |= mask, mask >>= 1) {
        utf32 = (utf32 << 6) + (*cur++ & 0x3F);
 }
    to_ignore_mask |= mask;
    utf32 &= ~(to_ignore_mask << (6 * (num_to_read - 1)));

 *num_read = num_to_read;
 return static_cast<int32_t>(utf32);
}

status_t Parcel::write(const FlattenableHelperInterface& val)
{
 status_t err;

 const size_t len = val.getFlattenedSize();
 const size_t fd_count = val.getFdCount();

 if ((len > INT32_MAX) || (fd_count >= gMaxFds)) {
 return BAD_VALUE;
 }

    err = this->writeInt32(len);
 if (err) return err;

    err = this->writeInt32(fd_count);
 if (err) return err;

 void* const buf = this->writeInplace(pad_size(len));
 if (buf == NULL)
 return BAD_VALUE;

 int* fds = NULL;
 if (fd_count) {
        fds = new (std::nothrow) int[fd_count];
 if (fds == nullptr) {
            ALOGE("write: failed to allocate requested %zu fds", fd_count);
 return BAD_VALUE;
 }
 }

    err = val.flatten(buf, len, fds, fd_count);
 for (size_t i=0 ; i<fd_count && err==NO_ERROR ; i++) {
        err = this->writeDupFileDescriptor( fds[i] );
 }

 if (fd_count) {
 delete [] fds;
 }

 return err;
}

void Parcel::freeDataNoInit()
{
 if (mOwner) {
        LOG_ALLOC("Parcel %p: freeing other owner data", this);
        mOwner(this, mData, mDataSize, mObjects, mObjectsSize, mOwnerCookie);
 } else {
        LOG_ALLOC("Parcel %p: freeing allocated data", this);
        releaseObjects();
 if (mData) {
            LOG_ALLOC("Parcel %p: freeing with %zu capacity", this, mDataCapacity);
            pthread_mutex_lock(&gParcelGlobalAllocSizeLock);
 if (mDataCapacity <= gParcelGlobalAllocSize) {
              gParcelGlobalAllocSize = gParcelGlobalAllocSize - mDataCapacity;
 } else {
              gParcelGlobalAllocSize = 0;
 }
 if (gParcelGlobalAllocCount > 0) {
              gParcelGlobalAllocCount--;
 }
            pthread_mutex_unlock(&gParcelGlobalAllocSizeLock);
            free(mData);
 }
 if (mObjects) free(mObjects);
 }
}

std::string utf16ToUtf8(const StringPiece16& utf16) {
ssize_t utf8Length = utf16_to_utf8_length(utf16.data(), utf16.length());
if (utf8Length <= 0) {
return {};

}

std::string utf8;
utf8.resize(utf8Length);
    utf16_to_utf8(utf16.data(), utf16.length(), &*utf8.begin());
return utf8;
}

status_t Parcel::writeFloatVector(const std::vector<float>& val)
{
 return writeTypedVector(val, &Parcel::writeFloat);
}

static char* allocFromUTF8(const char* in, size_t len)
{
 if (len > 0) {
 if (len == SIZE_MAX) {
 return NULL;
 }
 SharedBuffer* buf = SharedBuffer::alloc(len+1);
        ALOG_ASSERT(buf, "Unable to allocate shared buffer");
 if (buf) {
 char* str = (char*)buf->data();
            memcpy(str, in, len);
            str[len] = 0;
 return str;
 }
 return NULL;
 }

 return getEmptyString();
}

static Maybe<char16_t> parseUnicodeCodepoint(const char16_t** start, const char16_t* end) {
 char16_t code = 0;
 for (size_t i = 0; i < 4 && *start != end; i++, (*start)++) {
 char16_t c = **start;
 int a;
 if (c >= '0' && c <= '9') {
            a = c - '0';
 } else if (c >= 'a' && c <= 'f') {
            a = c - 'a' + 10;
 } else if (c >= 'A' && c <= 'F') {
            a = c - 'A' + 10;
 } else {
 return make_nothing<char16_t>();
 }
        code = (code << 4) | a;
 }
 return make_value(code);
}

status_t Parcel::readParcelable(Parcelable* parcelable) const {
 int32_t have_parcelable = 0;
 status_t status = readInt32(&have_parcelable);
 if (status != OK) {
 return status;
 }
 if (!have_parcelable) {
 return UNEXPECTED_NULL;
 }
 return parcelable->readFromParcel(this);
}

status_t Parcel::readUtf8VectorFromUtf16Vector(
        std::unique_ptr<std::vector<std::unique_ptr<std::string>>>* val) const {
 return readNullableTypedVector(val, &Parcel::readUtf8FromUtf16);
}

status_t Parcel::writeUtf8AsUtf16(const std::string& str) {
 const uint8_t* strData = (uint8_t*)str.data();
 const size_t strLen= str.length();
 const ssize_t utf16Len = utf8_to_utf16_length(strData, strLen);
 if (utf16Len < 0 || utf16Len> std::numeric_limits<int32_t>::max()) {
 return BAD_VALUE;
 }

 status_t err = writeInt32(utf16Len);
 if (err) {
 return err;
 }

 void* dst = writeInplace((utf16Len + 1) * sizeof(char16_t));
 if (!dst) {
 return NO_MEMORY;
 }

    utf8_to_utf16(strData, strLen, (char16_t*)dst);

 return NO_ERROR;
}

status_t Parcel::writeUniqueFileDescriptor(const ScopedFd& fd) {
 return writeDupFileDescriptor(fd.get());
}

status_t Parcel::readByte(int8_t *pArg) const
{
 int32_t tmp;
 status_t ret = readInt32(&tmp);
 *pArg = int8_t(tmp);
 return ret;
}

static inline size_t utf8_codepoint_len(uint8_t ch)
{
 return ((0xe5000000 >> ((ch >> 3) & 0x1e)) & 3) + 1;
}

bool isJavaClassName(const StringPiece16& str) {
 size_t pieces = 0;
 for (const StringPiece16& piece : tokenize(str, u'.')) {
        pieces++;
 if (piece.empty()) {
 return false;
 }

 if (piece.data()[0] == u'$' || piece.data()[piece.size() - 1] == u'$') {
 return false;
 }

 if (findNonAlphaNumericAndNotInSet(piece, u"$_") != piece.end()) {
 return false;
 }
 }
 return pieces >= 2;
}

void String8::clear() {
 SharedBuffer::bufferFromData(mString)->release();
    mString = getEmptyString();
}

status_t Parcel::writeChar(char16_t val)
{
 return writeInt32(int32_t(val));
}

status_t Parcel::readStrongBinderVector(std::vector<sp<IBinder>>* val) const {
 return readTypedVector(val, &Parcel::readStrongBinder);
}

status_t Parcel::read(FlattenableHelperInterface& val) const
{
 const size_t len = this->readInt32();
 const size_t fd_count = this->readInt32();

 if ((len > INT32_MAX) || (fd_count >= gMaxFds)) {
 return BAD_VALUE;
 }

 void const* const buf = this->readInplace(pad_size(len));
 if (buf == NULL)
 return BAD_VALUE;

 int* fds = NULL;
 if (fd_count) {
        fds = new (std::nothrow) int[fd_count];
 if (fds == nullptr) {
            ALOGE("read: failed to allocate requested %zu fds", fd_count);
 return BAD_VALUE;
 }
 }

 status_t err = NO_ERROR;
 for (size_t i=0 ; i<fd_count && err==NO_ERROR ; i++) {
        fds[i] = dup(this->readFileDescriptor());
 if (fds[i] < 0) {
            err = BAD_VALUE;
            ALOGE("dup() failed in Parcel::read, i is %zu, fds[i] is %d, fd_count is %zu, error: %s",
                i, fds[i], fd_count, strerror(errno));
 }
 }

 if (err == NO_ERROR) {
        err = val.unflatten(buf, len, fds, fd_count);
 }

 if (fd_count) {
 delete [] fds;
 }

 return err;
}

StringPiece16::const_iterator findNonAlphaNumericAndNotInSet(const StringPiece16& str,
 const StringPiece16& allowedChars) {
 const auto endIter = str.end();
 for (auto iter = str.begin(); iter != endIter; ++iter) {
 char16_t c = *iter;
 if ((c >= u'a' && c <= u'z') ||
 (c >= u'A' && c <= u'Z') ||
 (c >= u'0' && c <= u'9')) {
 continue;
 }

 bool match = false;
 for (char16_t i : allowedChars) {
 if (c == i) {
                match = true;
 break;
 }
 }

 if (!match) {
 return iter;
 }
 }
 return endIter;
}

static size_t consumeDigits(const char16_t* start, const char16_t* end) {
 const char16_t* c = start;
 for (; c != end && *c >= u'0' && *c <= u'9'; c++) {}
 return static_cast<size_t>(c - start);
}

status_t String8::appendFormatV(const char* fmt, va_list args)
{
 int n, result = NO_ERROR;
    va_list tmp_args;

 /* args is undefined after vsnprintf.
     * So we need a copy here to avoid the
     * second vsnprintf access undefined args.
     */
    va_copy(tmp_args, args);
    n = vsnprintf(NULL, 0, fmt, tmp_args);
    va_end(tmp_args);

 if (n != 0) {
 size_t oldLength = length();
 char* buf = lockBuffer(oldLength + n);
 if (buf) {
            vsnprintf(buf + oldLength, n + 1, fmt, args);
 } else {
            result = NO_MEMORY;
 }
 }
 return result;
}

void unmarshallAudioAttributes(const Parcel& parcel, audio_attributes_t *attributes)
{
attributes->usage = (audio_usage_t) parcel.readInt32();
attributes->content_type = (audio_content_type_t) parcel.readInt32();
attributes->source = (audio_source_t) parcel.readInt32();
attributes->flags = (audio_flags_mask_t) parcel.readInt32();
const bool hasFlattenedTag = (parcel.readInt32() == kAudioAttributesMarshallTagFlattenTags);
if (hasFlattenedTag) {
// the tags are UTF16, convert to UTF8
String16 tags = parcel.readString16();
ssize_t realTagSize = utf16_to_utf8_length(tags.string(), tags.size());
if (realTagSize <= 0) {
strcpy(attributes->tags, "");
} else {
// copy the flattened string into the attributes as the destination for the conversion:

// copying array size -1, array for tags was calloc'd, no need to NULL-terminate it
size_t tagSize = realTagSize > AUDIO_ATTRIBUTES_TAGS_MAX_SIZE - 1 ?
AUDIO_ATTRIBUTES_TAGS_MAX_SIZE - 1 : realTagSize;
            utf16_to_utf8(tags.string(), tagSize, attributes->tags);
}
} else {
ALOGE("unmarshallAudioAttributes() received unflattened tags, ignoring tag values");
strcpy(attributes->tags, "");
}
}

status_t Parcel::writeFloatVector(const std::unique_ptr<std::vector<float>>& val)
{
 return writeNullableTypedVector(val, &Parcel::writeFloat);
}

status_t String8::setTo(const char32_t* other, size_t len)
{
 const char *newString = allocFromUTF32(other, len);
 SharedBuffer::bufferFromData(mString)->release();
    mString = newString;
 if (mString) return NO_ERROR;

    mString = getEmptyString();
 return NO_MEMORY;
}

void initialize_string8()
{
    gDarwinIsReallyAnnoying = gDarwinCantLoadAllObjects;

 SharedBuffer* buf = SharedBuffer::alloc(1);
 char* str = (char*)buf->data();
 *str = 0;
    gEmptyStringBuf = buf;
    gEmptyString = str;
}

int8_t Parcel::readByte() const
{
 return int8_t(readInt32());
}

status_t String8::setTo(const char* other, size_t len)
{
 const char *newString = allocFromUTF8(other, len);
 SharedBuffer::bufferFromData(mString)->release();
    mString = newString;
 if (mString) return NO_ERROR;

    mString = getEmptyString();
 return NO_MEMORY;
}

status_t Parcel::writeCharVector(const std::unique_ptr<std::vector<char16_t>>& val)
{
 return writeNullableTypedVector(val, &Parcel::writeChar);
}

void utf16_to_utf8(const char16_t* src, size_t src_len, char* dst)
 {
     if (src == NULL || src_len == 0 || dst == NULL) {
         return;
 }

 const char16_t* cur_utf16 = src;
 const char16_t* const end_utf16 = src + src_len;
 char *cur = dst;
 while (cur_utf16 < end_utf16) {
 char32_t utf32;
 if((*cur_utf16 & 0xFC00) == 0xD800 && (cur_utf16 + 1) < end_utf16
 && (*(cur_utf16 + 1) & 0xFC00) == 0xDC00) {
            utf32 = (*cur_utf16++ - 0xD800) << 10;
            utf32 |= *cur_utf16++ - 0xDC00;
            utf32 += 0x10000;
 } else {

             utf32 = (char32_t) *cur_utf16++;
         }
         const size_t len = utf32_codepoint_utf8_length(utf32);
         utf32_codepoint_to_utf8((uint8_t*)cur, utf32, len);
         cur += len;
     }
     *cur = '\0';
 }

static char* allocFromUTF16(const char16_t* in, size_t len)

{
if (len == 0) return getEmptyString();

    const ssize_t bytes = utf16_to_utf8_length(in, len);
    if (bytes < 0) {
return getEmptyString();
}

    SharedBuffer* buf = SharedBuffer::alloc(bytes+1);
ALOG_ASSERT(buf, "Unable to allocate shared buffer");
if (!buf) {
return getEmptyString();
}

    char* str = (char*)buf->data();
    utf16_to_utf8(in, len, str);
    return str;
}

status_t Parcel::writeString16Vector(
 const std::unique_ptr<std::vector<std::unique_ptr<String16>>>& val)
{
 return writeNullableTypedVector(val, &Parcel::writeString16);
}

std::unique_ptr<uint8_t[]> copy(const BigBuffer& buffer) {
    std::unique_ptr<uint8_t[]> data = std::unique_ptr<uint8_t[]>(new uint8_t[buffer.size()]);
 uint8_t* p = data.get();
 for (const auto& block : buffer) {
        memcpy(p, block.buffer.get(), block.size);
        p += block.size;
 }
 return data;
}

status_t Parcel::writeBoolVector(const std::unique_ptr<std::vector<bool>>& val)
{
 return writeNullableTypedVector(val, &Parcel::writeBool);
}

size_t strlen16(const char16_t *s)
{
 const char16_t *ss = s;
 while ( *ss )
    ss++;
 return ss-s;
}

bool verifyJavaStringFormat(const StringPiece16& str) {
 const char16_t* c = str.begin();
 const char16_t* const end = str.end();

 size_t argCount = 0;
 bool nonpositional = false;
 while (c != end) {
 if (*c == u'%' && c + 1 < end) {
            c++;

 if (*c == u'%') {
                c++;
 continue;
 }

            argCount++;

 size_t numDigits = consumeDigits(c, end);
 if (numDigits > 0) {
                c += numDigits;
 if (c != end && *c != u'$') {
                    nonpositional = true;
 }
 } else if (*c == u'<') {
                nonpositional = true;

                c++;

 if (c != end && *c == u'$') {
                    c++;
 }
 } else {
                nonpositional = true;
 }

 while (c != end && (*c == u'-' ||
 *c == u'#' ||
 *c == u'+' ||
 *c == u' ' ||
 *c == u',' ||
 *c == u'(' ||
 (*c >= u'0' && *c <= '9'))) {
                c++;
 }

 /*
             * This is a shortcut to detect strings that are going to Time.format()
             * instead of String.format()
             *
             * Comparison of String.format() and Time.format() args:
             *
             * String: ABC E GH  ST X abcdefgh  nost x
             *   Time:    DEFGHKMS W Za  d   hkm  s w yz
             *
             * Therefore we know it's definitely Time if we have:
             *     DFKMWZkmwyz
             */
 if (c != end) {
 switch (*c) {
 case 'D':
 case 'F':
 case 'K':
 case 'M':
 case 'W':
 case 'Z':
 case 'k':
 case 'm':
 case 'w':
 case 'y':
 case 'z':
 return true;
 }
 }
 }

 if (c != end) {
            c++;
 }
 }

 if (argCount > 1 && nonpositional) {
 return false;
 }
 return true;
}

status_t Parcel::readBool(bool *pArg) const
{
 int32_t tmp;
 status_t ret = readInt32(&tmp);
 *pArg = (tmp != 0);
 return ret;
}

static char* allocFromUTF32(const char32_t* in, size_t len)
{
if (len == 0) {

return getEmptyString();
}

    const ssize_t bytes = utf32_to_utf8_length(in, len);
    if (bytes < 0) {
return getEmptyString();
}

    SharedBuffer* buf = SharedBuffer::alloc(bytes+1);
ALOG_ASSERT(buf, "Unable to allocate shared buffer");
if (!buf) {
return getEmptyString();
}

    char* str = (char*) buf->data();
    utf32_to_utf8(in, len, str);

    return str;
}

status_t Parcel::readUniqueFileDescriptor(ScopedFd* val) const
{
 int got = readFileDescriptor();

 if (got == BAD_TYPE) {
 return BAD_TYPE;
 }

    val->reset(dup(got));

 if (val->get() < 0) {
 return BAD_VALUE;
 }

 return OK;
}

size_t String8::getUtf32Length() const
{
 return utf8_to_utf32_length(mString, length());
}

status_t String8::setTo(const char16_t* other, size_t len)
{
 const char *newString = allocFromUTF16(other, len);
 SharedBuffer::bufferFromData(mString)->release();
    mString = newString;
 if (mString) return NO_ERROR;

    mString = getEmptyString();
 return NO_MEMORY;
}

status_t Parcel::readString16Vector(std::vector<String16>* val) const {
 return readTypedVector(val, &Parcel::readString16);
}

static inline void utf32_codepoint_to_utf8(uint8_t* dstP, char32_t srcChar, size_t bytes)
{
    dstP += bytes;
 switch (bytes)
 { /* note: everything falls through. */
 case 4: *--dstP = (uint8_t)((srcChar | kByteMark) & kByteMask); srcChar >>= 6;
 case 3: *--dstP = (uint8_t)((srcChar | kByteMark) & kByteMask); srcChar >>= 6;
 case 2: *--dstP = (uint8_t)((srcChar | kByteMark) & kByteMask); srcChar >>= 6;
 case 1: *--dstP = (uint8_t)(srcChar | kFirstByteMark[bytes]);
 }
}

void Parcel::initState()
{
    LOG_ALLOC("Parcel %p: initState", this);
    mError = NO_ERROR;
    mData = 0;
    mDataSize = 0;
    mDataCapacity = 0;
    mDataPos = 0;
    ALOGV("initState Setting data size of %p to %zu", this, mDataSize);
    ALOGV("initState Setting data pos of %p to %zu", this, mDataPos);
    mObjects = NULL;
    mObjectsSize = 0;
    mObjectsCapacity = 0;
    mNextObjectHint = 0;
    mHasFds = false;
    mFdsKnown = true;
    mAllowFds = true;
    mOwner = NULL;
    mOpenAshmemSize = 0;

 if (gMaxFds == 0) {
 struct rlimit result;
 if (!getrlimit(RLIMIT_NOFILE, &result)) {
            gMaxFds = (size_t)result.rlim_cur;
 } else {
            ALOGW("Unable to getrlimit: %s", strerror(errno));
            gMaxFds = 1024;
 }
 }
}

status_t Parcel::readString16(std::unique_ptr<String16>* pArg) const
{
 const int32_t start = dataPosition();
 int32_t size;
 status_t status = readInt32(&size);
    pArg->reset();

 if (status != OK || size < 0) {
 return status;
 }

    setDataPosition(start);
    pArg->reset(new (std::nothrow) String16());

    status = readString16(pArg->get());

 if (status != OK) {
        pArg->reset();
 }

 return status;
}

status_t Parcel::writeInt32Vector(const std::unique_ptr<std::vector<int32_t>>& val)
{
 return writeNullableTypedVector(val, &Parcel::writeInt32);
}

int32_t Parcel::readExceptionCode() const
{
    binder::Status status;
    status.readFromParcel(*this);
 return status.exceptionCode();
}

static std::vector<std::string> splitAndTransform(const StringPiece& str, char sep,
 const std::function<char(char)>& f) {
    std::vector<std::string> parts;
 const StringPiece::const_iterator end = std::end(str);
 StringPiece::const_iterator start = std::begin(str);
 StringPiece::const_iterator current;
 do {
        current = std::find(start, end, sep);
        parts.emplace_back(str.substr(start, current).toString());
 if (f) {
            std::string& part = parts.back();
            std::transform(part.begin(), part.end(), part.begin(), f);
 }
        start = current + 1;
 } while (current != end);
 return parts;
}

char16_t* strstr16(const char16_t* src, const char16_t* target)
{
 const char16_t needle = *target++;
 const size_t target_len = strlen16(target);
 if (needle != '\0') {
 do {
 do {
 if (*src == '\0') {
 return nullptr;
 }
 } while (*src++ != needle);
 } while (strncmp16(src, target, target_len) != 0);
      src--;
 }

 return (char16_t*)src;
}

void MediaPlayerService::removeClient(wp<Client> client)
{
 Mutex::Autolock lock(mLock);
    mClients.remove(client);
}

status_t Parcel::readCharVector(std::vector<char16_t>* val) const {
 return readTypedVector(val, &Parcel::readChar);
}

status_t Parcel::readUtf8VectorFromUtf16Vector(std::vector<std::string>* val) const {
 return readTypedVector(val, &Parcel::readUtf8FromUtf16);
}

status_t Parcel::writeByteVector(const std::vector<int8_t>& val) {
 return writeByteVectorInternal(this, val);
}

String8::String8()
 : mString(getEmptyString())
{
}

std::u16string utf8ToUtf16(const StringPiece& utf8) {
 ssize_t utf16Length = utf8_to_utf16_length(reinterpret_cast<const uint8_t*>(utf8.data()),
            utf8.length());
 if (utf16Length <= 0) {
 return {};
 }

    std::u16string utf16;
    utf16.resize(utf16Length);
    utf8_to_utf16(reinterpret_cast<const uint8_t*>(utf8.data()), utf8.length(), &*utf16.begin());
 return utf16;
}

status_t Parcel::readUniqueFileDescriptorVector(std::unique_ptr<std::vector<ScopedFd>>* val) const {
 return readNullableTypedVector(val, &Parcel::readUniqueFileDescriptor);
}

status_t Parcel::readByteVector(std::unique_ptr<std::vector<int8_t>>* val) const {
 return readByteVectorInternalPtr(this, val);
}

status_t Parcel::writeUniqueFileDescriptorVector(const std::vector<ScopedFd>& val) {
 return writeTypedVector(val, &Parcel::writeUniqueFileDescriptor);
}

status_t Parcel::readCharVector(std::unique_ptr<std::vector<char16_t>>* val) const {
 return readNullableTypedVector(val, &Parcel::readChar);
}

static inline char* getEmptyString()
{
    gEmptyStringBuf->acquire();
 return gEmptyString;
}

int strzcmp16(const char16_t *s1, size_t n1, const char16_t *s2, size_t n2)
{
 const char16_t* e1 = s1+n1;
 const char16_t* e2 = s2+n2;

 while (s1 < e1 && s2 < e2) {
 const int d = (int)*s1++ - (int)*s2++;
 if (d) {
 return d;
 }
 }

 return n1 < n2
 ? (0 - (int)*s2)
 : (n1 > n2
 ? ((int)*s1 - 0)
 : 0);
}

status_t Parcel::writeByte(int8_t val)
{
 return writeInt32(int32_t(val));
}

status_t Parcel::writeCharVector(const std::vector<char16_t>& val)
{
 return writeTypedVector(val, &Parcel::writeChar);
}

status_t Parcel::readUtf8FromUtf16(std::unique_ptr<std::string>* str) const {
 const int32_t start = dataPosition();
 int32_t size;
 status_t status = readInt32(&size);
    str->reset();

 if (status != OK || size < 0) {
 return status;
 }

    setDataPosition(start);
    str->reset(new (std::nothrow) std::string());
 return readUtf8FromUtf16(str->get());
}

status_t Parcel::readUtf8FromUtf16(std::string* str) const {
size_t utf16Size = 0;
const char16_t* src = readString16Inplace(&utf16Size);
if (!src) {
return UNEXPECTED_NULL;
}

// Save ourselves the trouble, we're done.
if (utf16Size == 0u) {
str->clear();

return NO_ERROR;
}

    ssize_t utf8Size = utf16_to_utf8_length(src, utf16Size);
    if (utf8Size < 0) {
return BAD_VALUE;
}
// Note that while it is probably safe to assume string::resize keeps a
    // spare byte around for the trailing null, we're going to be explicit.
    str->resize(utf8Size + 1);
    utf16_to_utf8(src, utf16Size, &((*str)[0]));
str->resize(utf8Size);
return NO_ERROR;
}

size_t strlen32(const char32_t *s)
{
 const char32_t *ss = s;
 while ( *ss )
    ss++;
 return ss-s;
}

status_t Parcel::writeInt32Vector(const std::vector<int32_t>& val)
{
 return writeTypedVector(val, &Parcel::writeInt32);
}

String8::String8(const char* o, size_t len)
 : mString(allocFromUTF8(o, len))
{
 if (mString == NULL) {
        mString = getEmptyString();
 }
}

status_t Parcel::writeBool(bool val)
{
 return writeInt32(int32_t(val));
}

status_t Parcel::writeUtf8AsUtf16(const std::unique_ptr<std::string>& str) {
 if (!str) {
 return writeInt32(-1);
 }
 return writeUtf8AsUtf16(*str);
}

status_t Parcel::readInt32Vector(std::vector<int32_t>* val) const {
 return readTypedVector(val, &Parcel::readInt32);
}

static dev_t ashmem_rdev()
{
 static dev_t __ashmem_rdev;
 static pthread_mutex_t __ashmem_rdev_lock = PTHREAD_MUTEX_INITIALIZER;

    pthread_mutex_lock(&__ashmem_rdev_lock);

 dev_t rdev = __ashmem_rdev;
 if (!rdev) {
 int fd = TEMP_FAILURE_RETRY(open("/dev/ashmem", O_RDONLY));
 if (fd >= 0) {
 struct stat st;

 int ret = TEMP_FAILURE_RETRY(fstat(fd, &st));
            close(fd);
 if ((ret >= 0) && S_ISCHR(st.st_mode)) {
                rdev = __ashmem_rdev = st.st_rdev;
 }
 }
 }

    pthread_mutex_unlock(&__ashmem_rdev_lock);

 return rdev;
}

String8::String8(const String16& o)
 : mString(allocFromUTF16(o.string(), o.size()))
{
}

static void release_object(const sp<ProcessState>& proc,
 const flat_binder_object& obj, const void* who, size_t* outAshmemSize)
{
 switch (obj.type) {
 case BINDER_TYPE_BINDER:
 if (obj.binder) {
                LOG_REFS("Parcel %p releasing reference on local %p", who, obj.cookie);
 reinterpret_cast<IBinder*>(obj.cookie)->decStrong(who);
 }
 return;
 case BINDER_TYPE_WEAK_BINDER:
 if (obj.binder)
 reinterpret_cast<RefBase::weakref_type*>(obj.binder)->decWeak(who);
 return;
 case BINDER_TYPE_HANDLE: {
 const sp<IBinder> b = proc->getStrongProxyForHandle(obj.handle);
 if (b != NULL) {
                LOG_REFS("Parcel %p releasing reference on remote %p", who, b.get());
                b->decStrong(who);
 }
 return;
 }
 case BINDER_TYPE_WEAK_HANDLE: {
 const wp<IBinder> b = proc->getWeakProxyForHandle(obj.handle);
 if (b != NULL) b.get_refs()->decWeak(who);
 return;
 }
 case BINDER_TYPE_FD: {
 if (obj.cookie != 0) { // owned
 if (outAshmemSize != NULL) {
 struct stat st;
 int ret = fstat(obj.handle, &st);
 if (!ret && S_ISCHR(st.st_mode) && (st.st_rdev == ashmem_rdev())) {
 int size = ashmem_get_size_region(obj.handle);
 if (size > 0) {
 *outAshmemSize -= size;
 }
 }
 }

                close(obj.handle);
 }
 return;
 }
 }

    ALOGE("Invalid object type 0x%08x", obj.type);
}

static inline void utf8_shift_and_mask(uint32_t* codePoint, const uint8_t byte)
{
 *codePoint <<= 6;
 *codePoint |= 0x3F & byte;
}

status_t Parcel::readInt64Vector(std::unique_ptr<std::vector<int64_t>>* val) const {
 return readNullableTypedVector(val, &Parcel::readInt64);
}

status_t Parcel::writeUtf8VectorAsUtf16Vector(
 const std::unique_ptr<std::vector<std::unique_ptr<std::string>>>& val) {
 return writeNullableTypedVector(val, &Parcel::writeUtf8AsUtf16);
}

status_t Parcel::readFloatVector(std::vector<float>* val) const {
 return readTypedVector(val, &Parcel::readFloat);
}

void String8::setTo(const String8& other)
{
 SharedBuffer::bufferFromData(other.mString)->acquire();
 SharedBuffer::bufferFromData(mString)->release();
    mString = other.mString;
}

void String8::toUpper()
{
    toUpper(0, size());
}

String8 String8::getPathDir(void) const
{
 const char* cp;
 const char*const str = mString;

    cp = strrchr(str, OS_PATH_SEPARATOR);
 if (cp == NULL)
 return String8("");
 else
 return String8(str, cp - str);
}

ssize_t utf32_to_utf8_length(const char32_t *src, size_t src_len)
{
 if (src == NULL || src_len == 0) {
 return -1;
 }

 size_t ret = 0;
 const char32_t *end = src + src_len;
 while (src < end) {
        ret += utf32_codepoint_utf8_length(*src++);
 }

     return ret;
 }

int32_t String8::getUtf32At(size_t index, size_t *next_index) const
{
 return utf32_from_utf8_at(mString, length(), index, next_index);
}

void String8::toLower()
{
    toLower(0, size());
}

char16_t *strcpy16(char16_t *dst, const char16_t *src)
{
 char16_t *q = dst;
 const char16_t *p = src;
 char16_t ch;

 do {
 *q++ = ch = *p++;
 } while ( ch );

 return dst;
}

String8::String8(const char16_t* o)
 : mString(allocFromUTF16(o, strlen16(o)))
{
}

size_t strnlen16(const char16_t *s, size_t maxlen)
{
 const char16_t *ss = s;

 /* Important: the maxlen test must precede the reference through ss;
     since the byte beyond the maximum may segfault */
 while ((maxlen > 0) && *ss) {
    ss++;
    maxlen--;
 }
 return ss-s;
}

status_t Parcel::restartWrite(size_t desired)
{
 if (desired > INT32_MAX) {
 return BAD_VALUE;
 }

 if (mOwner) {
        freeData();
 return continueWrite(desired);
 }

 uint8_t* data = (uint8_t*)realloc(mData, desired);
 if (!data && desired > mDataCapacity) {
        mError = NO_MEMORY;
 return NO_MEMORY;
 }

    releaseObjects();

 if (data) {
        LOG_ALLOC("Parcel %p: restart from %zu to %zu capacity", this, mDataCapacity, desired);
        pthread_mutex_lock(&gParcelGlobalAllocSizeLock);
        gParcelGlobalAllocSize += desired;
        gParcelGlobalAllocSize -= mDataCapacity;
 if (!mData) {
            gParcelGlobalAllocCount++;
 }
        pthread_mutex_unlock(&gParcelGlobalAllocSizeLock);
        mData = data;
        mDataCapacity = desired;
 }

    mDataSize = mDataPos = 0;
    ALOGV("restartWrite Setting data size of %p to %zu", this, mDataSize);
    ALOGV("restartWrite Setting data pos of %p to %zu", this, mDataPos);

    free(mObjects);
    mObjects = NULL;
    mObjectsSize = mObjectsCapacity = 0;
    mNextObjectHint = 0;
    mHasFds = false;
    mFdsKnown = true;
    mAllowFds = true;

 return NO_ERROR;
}

static inline uint32_t utf8_to_utf32_codepoint(const uint8_t *src, size_t length)
{
 uint32_t unicode;

 switch (length)
 {
 case 1:
 return src[0];
 case 2:
            unicode = src[0] & 0x1f;
            utf8_shift_and_mask(&unicode, src[1]);
 return unicode;
 case 3:
            unicode = src[0] & 0x0f;
            utf8_shift_and_mask(&unicode, src[1]);
            utf8_shift_and_mask(&unicode, src[2]);
 return unicode;
 case 4:
            unicode = src[0] & 0x07;
            utf8_shift_and_mask(&unicode, src[1]);
            utf8_shift_and_mask(&unicode, src[2]);
            utf8_shift_and_mask(&unicode, src[3]);
 return unicode;
 default:
 return 0xffff;
 }

}

int strncmp16(const char16_t *s1, const char16_t *s2, size_t n)
{
 char16_t ch;
 int d = 0;

 if (n == 0) {
 return 0;
 }

 do {
    d = (int)(ch = *s1++) - (int)*s2++;
 if ( d || !ch ) {
 break;
 }
 } while (--n);

 return d;
}

status_t String8::append(const String8& other)
{
 const size_t otherLen = other.bytes();
 if (bytes() == 0) {
        setTo(other);
 return NO_ERROR;
 } else if (otherLen == 0) {
 return NO_ERROR;
 }

 return real_append(other.string(), otherLen);
}

void utf32_to_utf8(const char32_t* src, size_t src_len, char* dst)
 {
     if (src == NULL || src_len == 0 || dst == NULL) {
         return;
 }

 const char32_t *cur_utf32 = src;
 const char32_t *end_utf32 = src + src_len;

     char *cur = dst;
     while (cur_utf32 < end_utf32) {
         size_t len = utf32_codepoint_utf8_length(*cur_utf32);
         utf32_codepoint_to_utf8((uint8_t *)cur, *cur_utf32++, len);
         cur += len;
     }
     *cur = '\0';
 }

ssize_t utf8_length(const char *src)
{
 const char *cur = src;
 size_t ret = 0;
 while (*cur != '\0') {
 const char first_char = *cur++;
 if ((first_char & 0x80) == 0) { // ASCII
            ret += 1;
 continue;
 }
 if ((first_char & 0x40) == 0) {
 return -1;
 }

 int32_t mask, to_ignore_mask;
 size_t num_to_read = 0;
 char32_t utf32 = 0;
 for (num_to_read = 1, mask = 0x40, to_ignore_mask = 0x80;
             num_to_read < 5 && (first_char & mask);
             num_to_read++, to_ignore_mask |= mask, mask >>= 1) {
 if ((*cur & 0xC0) != 0x80) { // must be 10xxxxxx
 return -1;
 }
            utf32 = (utf32 << 6) + (*cur++ & 0x3F);
 }
 if (num_to_read == 5) {
 return -1;
 }
        to_ignore_mask |= mask;
        utf32 |= ((~to_ignore_mask) & first_char) << (6 * (num_to_read - 1));
 if (utf32 > kUnicodeMaxCodepoint) {
 return -1;
 }

        ret += num_to_read;
 }
 return ret;
}

status_t Parcel::readFloatVector(std::unique_ptr<std::vector<float>>* val) const {
 return readNullableTypedVector(val, &Parcel::readFloat);
}

int strzcmp16_h_n(const char16_t *s1H, size_t n1, const char16_t *s2N, size_t n2)
{
 const char16_t* e1 = s1H+n1;
 const char16_t* e2 = s2N+n2;

 while (s1H < e1 && s2N < e2) {
 const char16_t c2 = ntohs(*s2N);
 const int d = (int)*s1H++ - (int)c2;
        s2N++;
 if (d) {
 return d;
 }
 }

 return n1 < n2
 ? (0 - (int)ntohs(*s2N))
 : (n1 > n2
 ? ((int)*s1H - 0)

            : 0);
 }

status_t Parcel::readBoolVector(std::vector<bool>* val) const {
 int32_t size;
 status_t status = readInt32(&size);

 if (status != OK) {
 return status;
 }

 if (size < 0) {
 return UNEXPECTED_NULL;
 }

    val->resize(size);

 /* C++ bool handling means a vector of bools isn't necessarily addressable
     * (we might use individual bits)
     */
 bool data;
 for (int32_t i = 0; i < size; ++i) {
        status = readBool(&data);
 (*val)[i] = data;

 if (status != OK) {
 return status;
 }
 }

 return OK;
}

std::vector<std::string> split(const StringPiece& str, char sep) {
 return splitAndTransform(str, sep, nullptr);
}

 virtual void TearDown() {
 }

status_t Parcel::readByteVector(std::unique_ptr<std::vector<uint8_t>>* val) const {
 return readByteVectorInternalPtr(this, val);
}
