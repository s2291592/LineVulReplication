static bool SniffForMagicNumbers(const char* content,
                                 size_t size,
                                 bool* have_enough_content,
                                 std::string* result) {
  *have_enough_content &= TruncateSize(kBytesRequiredForMagic, &size);

  return CheckForMagicNumbers(content, size, kMagicNumbers,
                              arraysize(kMagicNumbers), result);
}

static bool MagicMaskCmp(const char* magic_entry,
                         const char* content,
                         size_t len,
                         const char* mask) {
  while (len) {
    if ((*magic_entry != '.') && (*magic_entry != (*mask & *content)))
      return false;
    ++magic_entry;
    ++content;
    ++mask;
    --len;
  }
  return true;
}

  std::vector<GURL> GetRedirects(const GURL& url) {
    history::HistoryService* history_service =
        HistoryServiceFactory::GetForProfile(
            browser()->profile(), ServiceAccessType::EXPLICIT_ACCESS);

    std::vector<GURL> rv;
    history_service->QueryRedirectsFrom(
        url,
        base::Bind(&RedirectTest::OnRedirectQueryComplete,
                   base::Unretained(this),
                   &rv),
        &tracker_);
    content::RunMessageLoop();
    return rv;
  }

bool LooksLikeBinary(const char* content, size_t size) {
  const uint32_t kBinaryBits =
      ~(1u << '\t' | 1u << '\n' | 1u << '\r' | 1u << '\f' | 1u << '\x1b');
  for (size_t i = 0; i < size; ++i) {
    uint8_t byte = static_cast<uint8_t>(content[i]);
    if (byte < 0x20 && (kBinaryBits & (1u << byte)))
      return true;
  }
  return false;
}

static std::string SniffMimeType(const std::string& content,
                                 const std::string& url,
                                 const std::string& mime_type_hint) {
  std::string mime_type;
  SniffMimeType(content.data(), content.size(), GURL(url),
                     mime_type_hint, &mime_type);
  return mime_type;
}

static bool SniffCRX(const char* content,
                     size_t size,
                     const GURL& url,
                     const std::string& type_hint,
                     bool* have_enough_content,
                     std::string* result) {
  static const struct MagicNumber kCRXMagicNumbers[] = {
    MAGIC_NUMBER("application/x-chrome-extension", "Cr24\x02\x00\x00\x00")
  };

  if (!base::EndsWith(url.path_piece(), ".crx", base::CompareCase::SENSITIVE))
    return false;

  *have_enough_content &= TruncateSize(kBytesRequiredForMagic, &size);
  return CheckForMagicNumbers(content, size, kCRXMagicNumbers,
                              arraysize(kCRXMagicNumbers), result);
}

void OnMimeTypesCollected(
    std::vector<std::string>* output,
    std::unique_ptr<std::vector<std::string>> mime_types) {
  *output = *mime_types;
}

  ResourceLoaderBrowserTest() {}

bool ShouldSniffMimeType(const GURL& url, const std::string& mime_type) {
  bool sniffable_scheme = url.is_empty() ||
                          url.SchemeIsHTTPOrHTTPS() ||
                          url.SchemeIs("ftp") ||
#if defined(OS_ANDROID)
                          url.SchemeIs("content") ||
#endif
                          url.SchemeIsFile() ||
                          url.SchemeIsFileSystem();
  if (!sniffable_scheme)
    return false;

  static const char* const kSniffableTypes[] = {
    "text/plain",
    "application/octet-stream",
    "text/xml",
    "application/xml",
    "application/msword",
    "application/vnd.ms-excel",
    "application/vnd.ms-powerpoint",
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    "application/vnd.openxmlformats-officedocument.presentationml.presentation",
    "application/vnd.ms-excel.sheet.macroenabled.12",
    "application/vnd.ms-word.document.macroenabled.12",
    "application/vnd.ms-powerpoint.presentation.macroenabled.12",
    "application/mspowerpoint",
    "application/msexcel",
    "application/vnd.ms-word",
    "application/vnd.ms-word.document.12",
    "application/vnd.msword",
  };
  for (size_t i = 0; i < arraysize(kSniffableTypes); ++i) {
    if (mime_type == kSniffableTypes[i])
      return true;
  }
  if (IsUnknownMimeType(mime_type)) {
    return true;
  }
  return false;
}

  FileHandlersMimeUtilTest()
      : ExtensionsTest(std::make_unique<content::TestBrowserThreadBundle>()) {}

static bool IsUnknownMimeType(const std::string& mime_type) {
  static const char* const kUnknownMimeTypes[] = {
    "",
    "unknown/unknown",
    "application/unknown",
    "*/*",
  };
  for (size_t i = 0; i < arraysize(kUnknownMimeTypes); ++i) {
    if (mime_type == kUnknownMimeTypes[i])
      return true;
  }
  if (mime_type.find('/') == std::string::npos) {
    return true;
  }
  return false;
}

static bool MatchMagicNumber(const char* content,
                             size_t size,
                             const MagicNumber& magic_entry,
                             std::string* result) {
  const size_t len = magic_entry.magic_len;

  DCHECK_LE(len, kBytesRequiredForMagic);

  const char* end = static_cast<const char*>(memchr(content, '\0', size));
  const size_t content_strlen =
      (end != NULL) ? static_cast<size_t>(end - content) : size;

  bool match = false;
  if (magic_entry.is_string) {
    if (content_strlen >= len) {
      DCHECK_EQ(strlen(magic_entry.magic), len);
      match = base::EqualsCaseInsensitiveASCII(magic_entry.magic,
                                               base::StringPiece(content, len));
    }
  } else {
    if (size >= len) {
      if (!magic_entry.mask) {
        match = MagicCmp(magic_entry.magic, content, len);
      } else {
        match = MagicMaskCmp(magic_entry.magic, content, len, magic_entry.mask);
      }
    }
  }

  if (match) {
    result->assign(magic_entry.mime_type);
    return true;
  }
  return false;
}

storage::FileSystemURL CreateNativeLocalFileSystemURL(
    storage::FileSystemContext* context,
    const base::FilePath local_path) {
  return context->CreateCrackedFileSystemURL(
      GURL(kOrigin), storage::kFileSystemTypeNativeLocal, local_path);
}

static bool SniffForOfficeDocs(const char* content,
                               size_t size,
                               const GURL& url,
                               bool* have_enough_content,
                               std::string* result) {
  *have_enough_content &= TruncateSize(kBytesRequiredForOfficeMagic, &size);

  std::string office_version;
  if (!CheckForMagicNumbers(content, size, kOfficeMagicNumbers,
                            arraysize(kOfficeMagicNumbers), &office_version))
    return false;

  OfficeDocType type = DOC_TYPE_NONE;
  base::StringPiece url_path = url.path_piece();
  for (size_t i = 0; i < arraysize(kOfficeExtensionTypes); ++i) {
    if (url_path.length() < kOfficeExtensionTypes[i].extension_len)
      continue;

    base::StringPiece extension = url_path.substr(
        url_path.length() - kOfficeExtensionTypes[i].extension_len);
    if (base::EqualsCaseInsensitiveASCII(
            extension,
            base::StringPiece(kOfficeExtensionTypes[i].extension,
                              kOfficeExtensionTypes[i].extension_len))) {
      type = kOfficeExtensionTypes[i].doc_type;
      break;
    }
  }

  if (type == DOC_TYPE_NONE)
    return false;

  if (office_version == "CFB") {
    switch (type) {
      case DOC_TYPE_WORD:
        *result = "application/msword";
        return true;
      case DOC_TYPE_EXCEL:
        *result = "application/vnd.ms-excel";
        return true;
      case DOC_TYPE_POWERPOINT:
        *result = "application/vnd.ms-powerpoint";
        return true;
      case DOC_TYPE_NONE:
        NOTREACHED();
        return false;
    }
  } else if (office_version == "OOXML") {
    switch (type) {
      case DOC_TYPE_WORD:
        *result = "application/vnd.openxmlformats-officedocument."
                  "wordprocessingml.document";
        return true;
      case DOC_TYPE_EXCEL:
        *result = "application/vnd.openxmlformats-officedocument."
                  "spreadsheetml.sheet";
        return true;
      case DOC_TYPE_POWERPOINT:
        *result = "application/vnd.openxmlformats-officedocument."
                  "presentationml.presentation";
        return true;
      case DOC_TYPE_NONE:
        NOTREACHED();
        return false;
    }
  }

  NOTREACHED();
  return false;
}

bool SniffMimeTypeFromLocalData(const char* content,
                                size_t size,
                                std::string* result) {
  if (CheckForMagicNumbers(content, size, kExtraMagicNumbers,
                           arraysize(kExtraMagicNumbers), result))
    return true;
  return CheckForMagicNumbers(content, size, kMagicNumbers,
                              arraysize(kMagicNumbers), result);
}

bool SniffMimeType(const char* content,
size_t content_size,
const GURL& url,
const std::string& type_hint,
std::string* result) {
DCHECK_LT(content_size, 1000000U);  // sanity check
DCHECK(content);
DCHECK(result);

// By default, we assume we have enough content.
// Each sniff routine may unset this if it wasn't provided enough content.
bool have_enough_content = true;

// By default, we'll return the type hint.
// Each sniff routine may modify this if it has a better guess..
result->assign(type_hint);

// If the file has a Microsoft Office MIME type, we should only check that it
// is a valid Office file.  Because this is the only reason we sniff files
// with a Microsoft Office MIME type, we can return early.
if (IsOfficeType(type_hint))
return SniffForInvalidOfficeDocs(content, content_size, url, result);

// Cache information about the type_hint
const bool hint_is_unknown_mime_type = IsUnknownMimeType(type_hint);

  // We're only willing to sniff HTML if:
  // 1. The content was not served by a file:// URI (https://crbug.com/777737).
  // 2. The server has not supplied a mime type, or the type it did supply
  //    indicates that it doesn't know what the type should be.
  if (hint_is_unknown_mime_type && !url.SchemeIsFile() &&
      SniffForHTML(content, content_size, &have_enough_content, result)) {
    // We succeeded in sniffing HTML. No more content needed.
    return true;
}

// We're only willing to sniff for binary in 3 cases:
// 1. The server has not supplied a mime type.
// 2. The type it did supply indicates that it doesn't know what the type
//    should be.
// 3. The type is "text/plain" which is the default on some web servers and
//    could be indicative of a mis-configuration that we shield the user from.
const bool hint_is_text_plain = (type_hint == "text/plain");
if (hint_is_unknown_mime_type || hint_is_text_plain) {
if (!SniffBinary(content, content_size, &have_enough_content, result)) {
// If the server said the content was text/plain and it doesn't appear
// to be binary, then we trust it.
if (hint_is_text_plain) {
return have_enough_content;
}
}
}

// If we have plain XML, sniff XML subtypes.
if (type_hint == "text/xml" || type_hint == "application/xml") {
// We're not interested in sniffing these types for images and the like.
// Instead, we're looking explicitly for a feed.  If we don't find one
// we're done and return early.
if (SniffXML(content, content_size, &have_enough_content, result))
return true;
return have_enough_content;
}

// CRX files (Chrome extensions) have a special sniffing algorithm. It is
// tighter than the others because we don't have to match legacy behavior.
if (SniffCRX(content, content_size, url, type_hint,
&have_enough_content, result))
return true;

// Check the file extension and magic numbers to see if this is an Office
// document.  This needs to be checked before the general magic numbers
// because zip files and Office documents (OOXML) have the same magic number.
if (SniffForOfficeDocs(content, content_size, url,
&have_enough_content, result))
return true;  // We've matched a magic number.  No more content needed.

// We're not interested in sniffing for magic numbers when the type_hint
// is application/octet-stream.  Time to bail out.
if (type_hint == "application/octet-stream")
return have_enough_content;

// Now we look in our large table of magic numbers to see if we can find
// anything that matches the content.
if (SniffForMagicNumbers(content, content_size,
&have_enough_content, result))
return true;  // We've matched a magic number.  No more content needed.

return have_enough_content;
}

static bool CheckForMagicNumbers(const char* content, size_t size,
                                 const MagicNumber* magic, size_t magic_len,
                                 std::string* result) {
  for (size_t i = 0; i < magic_len; ++i) {
    if (MatchMagicNumber(content, size, magic[i], result))
      return true;
  }
  return false;
}

  void JSExpectAsync(const std::string& function) {
    bool result;
    EXPECT_TRUE(content::ExecuteScriptAndExtractBool(
        browser()->tab_strip_model()->GetActiveWebContents(),
        "(" + function + ")(function() {"
        "  window.domAutomationController.send(true);"
        "});",
        &result));
    EXPECT_TRUE(result);
  }

GURL CreateResource(const std::string& content, const std::string& file_ext) {
base::FilePath path;
EXPECT_TRUE(base::CreateTemporaryFile(&path));
EXPECT_EQ(static_cast<int>(content.size()),
base::WriteFile(path, content.c_str(), content.size()));
  base::FilePath path_with_extension;
  path_with_extension = path.AddExtension(FILE_PATH_LITERAL(file_ext));
  EXPECT_TRUE(base::Move(path, path_with_extension));
  return net::FilePathToFileURL(path_with_extension);
}

static bool MagicCmp(const char* magic_entry, const char* content, size_t len) {
  while (len) {
    if ((*magic_entry != '.') && (*magic_entry != *content))
      return false;
    ++magic_entry;
    ++content;
    --len;
  }
  return true;
}

static bool TruncateSize(const size_t max_size, size_t* size) {
  DCHECK_LE(static_cast<int>(max_size), kMaxBytesToSniff);

  if (*size >= max_size) {
    *size = max_size;
    return true;
  }
  return false;
}

static void TestArray(SnifferTest* tests, size_t count) {
  std::string mime_type;

  for (size_t i = 0; i < count; ++i) {
    SniffMimeType(tests[i].content,
                       tests[i].content_len,
                       GURL(tests[i].url),
                       tests[i].type_hint,
                       &mime_type);
    EXPECT_EQ(tests[i].mime_type, mime_type);
  }
}

static bool SniffXML(const char* content,
                     size_t size,
                     bool* have_enough_content,
                     std::string* result) {
  *have_enough_content &= TruncateSize(300, &size);
  const char* pos = content;
  const char* const end = content + size;

  const int kMaxTagIterations = 5;
  for (int i = 0; i < kMaxTagIterations && pos < end; ++i) {
    pos = reinterpret_cast<const char*>(memchr(pos, '<', end - pos));
    if (!pos)
      return false;

    static const char kXmlPrefix[] = "<?xml";
    static const size_t kXmlPrefixLength = arraysize(kXmlPrefix) - 1;
    static const char kDocTypePrefix[] = "<!DOCTYPE";
    static const size_t kDocTypePrefixLength = arraysize(kDocTypePrefix) - 1;

    if ((pos + kXmlPrefixLength <= end) &&
        base::EqualsCaseInsensitiveASCII(
            base::StringPiece(pos, kXmlPrefixLength),
            base::StringPiece(kXmlPrefix, kXmlPrefixLength))) {
      ++pos;
      continue;
    } else if ((pos + kDocTypePrefixLength <= end) &&
               base::EqualsCaseInsensitiveASCII(
                   base::StringPiece(pos, kDocTypePrefixLength),
                   base::StringPiece(kDocTypePrefix, kDocTypePrefixLength))) {
      ++pos;
      continue;
    }

    if (CheckForMagicNumbers(pos, end - pos, kMagicXML, arraysize(kMagicXML),
                             result))
      return true;


    return true;
  }

  return pos < end;
}

  void JSExpect(const std::string& expression) {
    bool result;
    EXPECT_TRUE(content::ExecuteScriptAndExtractBool(
        browser()->tab_strip_model()->GetActiveWebContents(),
        "window.domAutomationController.send(!!(" + expression + "));",
        &result));
    EXPECT_TRUE(result) << expression;
  }
