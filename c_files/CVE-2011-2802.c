bool SendAutomationJSONRequest(AutomationMessageSender* sender,
                               const std::string& request,
                               int timeout_ms,
                               std::string* reply,
                               bool* success) {
  return sender->Send(new AutomationMsg_SendJSONRequest(
       -1, request, reply, success), timeout_ms);
 }

bool KeyMap::Press(const scoped_refptr<WindowProxy>& window,
const ui::KeyboardCode key_code,
const wchar_t& key) {
if (key_code == ui::VKEY_SHIFT) {
shift_ = !shift_;
} else if (key_code == ui::VKEY_CONTROL) {
control_ = !control_;
} else if (key_code == ui::VKEY_MENU) {  // ALT
alt_ = !alt_;
} else if (key_code == ui::VKEY_COMMAND) {
command_ = !command_;
}

int modifiers = 0;
if (shift_ || shifted_keys_.find(key) != shifted_keys_.end()) {
modifiers = modifiers | ui::EF_SHIFT_DOWN;
}
if (control_) {
modifiers = modifiers | ui::EF_CONTROL_DOWN;
}
if (alt_) {
modifiers = modifiers | ui::EF_ALT_DOWN;
}
if (command_) {
    VLOG(1) << "Pressing command key on linux!!";
modifiers = modifiers | ui::EF_COMMAND_DOWN;
}

// TODO(jmikhail): need to be able to capture modifier key up.
window->SimulateOSKeyPress(key_code, modifiers);

return true;
}

bool SendGetTabURLJSONRequest(
    AutomationMessageSender* sender,
    int browser_index,
    int tab_index,
    std::string* url,
    std::string* error_msg) {
  DictionaryValue dict;
  dict.SetString("command", "GetTabURL");
  dict.SetInteger("windex", browser_index);
  dict.SetInteger("tab_index", tab_index);
  DictionaryValue reply_dict;
  if (!SendAutomationJSONRequest(sender, dict, &reply_dict, error_msg))
    return false;
  return reply_dict.GetString("url", url);
}

Session* SessionManager::GetSession(const std::string& id) const {
std::map<std::string, Session*>::const_iterator it;
base::AutoLock lock(map_lock_);
it = map_.find(id);
  if (it == map_.end()) {
    VLOG(1) << "No such session with ID " << id;
return NULL;
  }
return it->second;
}

bool SendGetTabTitleJSONRequest(
    AutomationMessageSender* sender,
    int browser_index,
    int tab_index,
    std::string* tab_title,
    std::string* error_msg) {
  DictionaryValue dict;
  dict.SetString("command", "GetTabTitle");
  dict.SetInteger("windex", browser_index);
  dict.SetInteger("tab_index", tab_index);
  DictionaryValue reply_dict;
  if (!SendAutomationJSONRequest(sender, dict, &reply_dict, error_msg))
    return false;
  return reply_dict.GetString("title", tab_title);
}

void Automation::MouseDoubleClick(int tab_id,
                                  const gfx::Point& p,
                                  Error** error) {
  *error = CheckAdvancedInteractionsSupported();
  if (*error)
    return;

  int windex = 0, tab_index = 0;
  *error = GetIndicesForTab(tab_id, &windex, &tab_index);
  if (*error)
    return;

  std::string error_msg;
  if (!SendMouseDoubleClickJSONRequest(
          automation(), windex, tab_index, p.x(), p.y(), &error_msg)) {
    *error = new Error(kUnknownError, error_msg);
  }
}

void InitChromeDriverLogging(const CommandLine& command_line) {
  bool success = InitLogging(
      FILE_PATH_LITERAL("chromedriver.log"),
      logging::LOG_TO_BOTH_FILE_AND_SYSTEM_DEBUG_LOG,
      logging::LOCK_LOG_FILE,
      logging::DELETE_OLD_LOG_FILE,
      logging::DISABLE_DCHECK_FOR_NON_OFFICIAL_RELEASE_BUILDS);
  if (!success) {
    PLOG(ERROR) << "Unable to initialize logging";
  }
  logging::SetLogItems(false,  // enable_process_id
                       false,  // enable_thread_id
                       true,   // enable_timestamp
                       false); // enable_tickcount
  if (command_line.HasSwitch(switches::kLoggingLevel)) {
    std::string log_level = command_line.GetSwitchValueASCII(
        switches::kLoggingLevel);
    int level = 0;
    if (base::StringToInt(log_level, &level)) {
      logging::SetMinLogLevel(level);
    } else {
      LOG(WARNING) << "Bad log level: " << log_level;
    }
  }
}

void Automation::SendWebKeyEvent(int tab_id,
                                 const WebKeyEvent& key_event,
                                 Error** error) {
  int windex = 0, tab_index = 0;
  *error = GetIndicesForTab(tab_id, &windex, &tab_index);
  if (*error)
    return;

  std::string error_msg;
  if (!SendWebKeyEventJSONRequest(
          automation(), windex, tab_index, key_event, &error_msg)) {
    *error = new Error(kUnknownError, error_msg);
  }
}

void KeyMap::ClearModifiers() {
  shift_ = false;
  alt_ = false;
  control_ = false;
  command_ = false;
}

 bool SendGetIndicesFromTabIdJSONRequest(
     AutomationMessageSender* sender,
     int tab_id,
    int* browser_index,
    int* tab_index,
    std::string* error_msg) {
  DictionaryValue request_dict;
  request_dict.SetString("command", "GetIndicesFromTab");
  request_dict.SetInteger("tab_id", tab_id);
  DictionaryValue reply_dict;
  if (!SendAutomationJSONRequest(sender, request_dict, &reply_dict, error_msg))
    return false;
  if (!reply_dict.GetInteger("windex", browser_index))
    return false;
  if (!reply_dict.GetInteger("tab_index", tab_index))
    return false;
  return true;
}

Automation::Automation() {}

bool SendIsTabIdValidJSONRequest(
    AutomationMessageSender* sender,
    int tab_id,
    bool* is_valid,
    std::string* error_msg) {
  DictionaryValue dict;
  dict.SetString("command", "IsTabIdValid");
  dict.SetInteger("id", tab_id);
  DictionaryValue reply_dict;
  if (!SendAutomationJSONRequest(sender, dict, &reply_dict, error_msg))
    return false;
  return reply_dict.GetBoolean("is_valid", is_valid);
}

bool SendCaptureEntirePageJSONRequest(
    AutomationMessageSender* sender,
    int browser_index,
    int tab_index,
    const FilePath& path,
    std::string* error_msg) {
  DictionaryValue dict;
  dict.SetString("command", "CaptureEntirePage");
  dict.SetInteger("windex", browser_index);
  dict.SetInteger("tab_index", tab_index);
  dict.SetString("path", path.value());
  DictionaryValue reply_dict;

  return SendAutomationJSONRequest(sender, dict, &reply_dict, error_msg);
}

bool SendGetChromeDriverAutomationVersion(
    AutomationMessageSender* sender,
    int* version,
    std::string* error_msg) {
  DictionaryValue dict;
  dict.SetString("command", "GetChromeDriverAutomationVersion");
  DictionaryValue reply_dict;
  if (!SendAutomationJSONRequest(sender, dict, &reply_dict, error_msg))
    return false;
  return reply_dict.GetInteger("version", version);
}

bool SendDeleteCookieJSONRequest(
    AutomationMessageSender* sender,
    const std::string& url,
    const std::string& cookie_name,
    std::string* error_msg) {
  DictionaryValue dict;
  dict.SetString("command", "DeleteCookie");
  dict.SetString("url", url);
  dict.SetString("name", cookie_name);
  DictionaryValue reply_dict;
  return SendAutomationJSONRequest(sender, dict, &reply_dict, error_msg);
}

void SessionManager::set_url_base(const std::string& url_base) {
  url_base_ = url_base;
}

 void Dispatcher::SetNotImplemented(const std::string& pattern) {
  mg_set_uri_callback(context_, (root_ + pattern).c_str(),
                      &SendNotImplementedError, NULL);
}

bool SendWaitForAllTabsToStopLoadingJSONRequest(
    AutomationMessageSender* sender,
    std::string* error_msg) {
  DictionaryValue dict;
  dict.SetString("command", "WaitForAllTabsToStopLoading");
  DictionaryValue reply_dict;
  return SendAutomationJSONRequest(sender, dict, &reply_dict, error_msg);
}

Error* Automation::GetIndicesForTab(
    int tab_id, int* browser_index, int* tab_index) {
  std::string error_msg;
  if (!SendGetIndicesFromTabIdJSONRequest(
          automation(), tab_id, browser_index, tab_index, &error_msg)) {
    return new Error(kUnknownError, error_msg);
  }
  return NULL;
}

bool GetDefaultChromeExe(FilePath* browser_exe) {
  std::vector<FilePath> locations;
  FilePath module_dir;
  if (PathService::Get(base::DIR_MODULE, &module_dir))
    locations.push_back(module_dir);

#if defined(OS_WIN)
  const wchar_t kSubKey[] =
      L"Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\chrome.exe";
  base::win::RegKey key(HKEY_CURRENT_USER, kSubKey, KEY_READ);
  std::wstring path;
  if (key.ReadValue(L"path", &path) == ERROR_SUCCESS)
    locations.push_back(FilePath(path));
  base::win::RegKey sys_key(HKEY_LOCAL_MACHINE, kSubKey, KEY_READ);
  if (sys_key.ReadValue(L"path", &path) == ERROR_SUCCESS)
    locations.push_back(FilePath(path));

  FilePath app_from_google(L"Google\\Chrome\\Application");
  scoped_ptr<base::Environment> env(base::Environment::Create());
  std::string home_dir;
  if (env->GetVar("userprofile", &home_dir)) {
    FilePath default_location(UTF8ToWide(home_dir));
    if (base::win::GetVersion() < base::win::VERSION_VISTA) {
      default_location = default_location.Append(
          L"Local Settings\\Application Data");
    } else {
      default_location = default_location.Append(L"AppData\\Local");
    }
    locations.push_back(default_location.Append(app_from_google));
  }

  std::string program_dir;
  if (env->GetVar("ProgramFiles", &program_dir)) {
    locations.push_back(FilePath(UTF8ToWide(program_dir))
        .Append(app_from_google));
  }
  if (env->GetVar("ProgramFiles(x86)", &program_dir)) {
    locations.push_back(FilePath(UTF8ToWide(program_dir))
        .Append(app_from_google));
  }
#elif defined(OS_MACOSX)
  locations.push_back(FilePath("/Applications"));
#elif defined(OS_LINUX)
  FilePath chrome_sym_link("/usr/bin/google-chrome");
  if (file_util::PathExists(chrome_sym_link)) {
    FilePath chrome;
    if (file_util::ReadSymbolicLink(chrome_sym_link, &chrome)) {
      locations.push_back(chrome.DirName());
    }
  }
#endif

  FilePath current_dir;
  if (file_util::GetCurrentDirectory(&current_dir))
    locations.push_back(current_dir);

  for (size_t i = 0; i < locations.size(); ++i) {
    FilePath path = locations[i].Append(chrome::kBrowserProcessExecutablePath);
    if (file_util::PathExists(path)) {
      *browser_exe = path;
      return true;
    }
  }
  return false;
}

Error* Automation::CheckAdvancedInteractionsSupported() {
  const char* message =
      "Advanced user interactions are not supported for this version of Chrome";
  return CheckVersion(750, 0, message);
}

bool SendExecuteJavascriptJSONRequest(
    AutomationMessageSender* sender,
    int browser_index,
    int tab_index,
    const std::string& frame_xpath,
    const std::string& javascript,
    Value** result,
    std::string* error_msg) {
  DictionaryValue dict;
  dict.SetString("command", "ExecuteJavascript");
  dict.SetInteger("windex", browser_index);
  dict.SetInteger("tab_index", tab_index);
  dict.SetString("frame_xpath", frame_xpath);
  dict.SetString("javascript", javascript);
  DictionaryValue reply_dict;
  if (!SendAutomationJSONRequest(sender, dict, &reply_dict, error_msg))
    return false;

  std::string json;
  if (!reply_dict.GetString("result", &json)) {
    LOG(ERROR) << "Executed javascript but received no 'result'";
    return false;
  }
  json.insert(0, "[");
  json.append("]");

  JSONStringValueSerializer deserializer(json);
  Value* value = deserializer.Deserialize(NULL, NULL);
  if (!value || !value->IsType(Value::TYPE_LIST)) {
    LOG(ERROR) << "Unable to deserialize returned JSON";
    return false;
  }
  scoped_ptr<ListValue> list(static_cast<ListValue*>(value));
  return list->Remove(0, result);
}

void Automation::NavigateToURL(int tab_id,
                               const std::string& url,
                               Error** error) {
  int windex = 0, tab_index = 0;
  *error = GetIndicesForTab(tab_id, &windex, &tab_index);
  if (*error)
    return;

  AutomationMsg_NavigationResponseValues navigate_response;
  std::string error_msg;
  if (!SendNavigateToURLJSONRequest(automation(), windex, tab_index,
                                    GURL(url), 1, &navigate_response,
                                    &error_msg)) {
    *error = new Error(kUnknownError, error_msg);
    return;
  }
  if (navigate_response == AUTOMATION_MSG_NAVIGATION_ERROR)
    *error = new Error(kUnknownError, "Navigation error occurred");
}

SessionManager::SessionManager() : port_(""), url_base_("") {}

bool SessionManager::Remove(const std::string& id) {
std::map<std::string, Session*>::iterator it;
Session* session;
base::AutoLock lock(map_lock_);
it = map_.find(id);
  if (it == map_.end()) {
    VLOG(1) << "No such session with ID " << id;
return false;
  }
session = it->second;
map_.erase(it);
return true;
}

KeyMap::~KeyMap() {}

int main(int argc, char *argv[]) {
struct mg_context *ctx;
base::AtExitManager exit;
base::WaitableEvent shutdown_event(false, false);
CommandLine::Init(argc, argv);
CommandLine* cmd_line = CommandLine::ForCurrentProcess();

#if defined(OS_POSIX)
signal(SIGPIPE, SIG_IGN);
#endif
srand((unsigned int)time(NULL));

// Register Chrome's path provider so that the AutomationProxy will find our
// built Chrome.
chrome::RegisterPathProvider();
TestTimeouts::Initialize();
  InitChromeDriverLogging(*cmd_line);

// Parse command line flags.
std::string port = "9515";
std::string root;
std::string url_base;
if (cmd_line->HasSwitch("port"))
port = cmd_line->GetSwitchValueASCII("port");
// The 'root' flag allows the user to specify a location to serve files from.
// If it is not given, a callback will be registered to forbid all file
// requests.
if (cmd_line->HasSwitch("root"))
root = cmd_line->GetSwitchValueASCII("root");
if (cmd_line->HasSwitch("url-base"))
url_base = cmd_line->GetSwitchValueASCII("url-base");

webdriver::SessionManager* manager = webdriver::SessionManager::GetInstance();
manager->set_port(port);
manager->set_url_base(url_base);

// Initialize SHTTPD context.
// Listen on port 9515 or port specified on command line.
// TODO(jmikhail) Maybe add port 9516 as a secure connection.
ctx = mg_start();
if (!SetMongooseOptions(ctx, port, root)) {
mg_stop(ctx);
#if defined(OS_WIN)
return WSAEADDRINUSE;
#else
return EADDRINUSE;
#endif
}

webdriver::Dispatcher dispatcher(ctx, url_base);
webdriver::InitCallbacks(ctx, &dispatcher, &shutdown_event, root.empty());

// The tests depend on parsing the first line ChromeDriver outputs,
// so all other logging should happen after this.
std::cout << "Started ChromeDriver" << std::endl
<< "port=" << port << std::endl;

if (root.length()) {
VLOG(1) << "Serving files from the current working directory";
}

// Run until we receive command to shutdown.
shutdown_event.Wait();

// We should not reach here since the service should never quit.
// TODO(jmikhail): register a listener for SIGTERM and break the
// message loop gracefully.
mg_stop(ctx);
return (EXIT_SUCCESS);
}

void InitCallbacks(struct mg_context* ctx, Dispatcher* dispatcher,
base::WaitableEvent* shutdown_event,
bool forbid_other_requests) {
dispatcher->AddShutdown("/shutdown", shutdown_event);
  dispatcher->AddStatus("/healthz");

dispatcher->Add<CreateSession>("/session");

// WebElement commands
dispatcher->Add<FindOneElementCommand>(  "/session/*/element");
dispatcher->Add<FindManyElementsCommand>("/session/*/elements");
dispatcher->Add<ActiveElementCommand>(   "/session/*/element/active");
dispatcher->Add<FindOneElementCommand>(  "/session/*/element/*/element");
dispatcher->Add<FindManyElementsCommand>("/session/*/elements/*/elements");
dispatcher->Add<ElementAttributeCommand>("/session/*/element/*/attribute/*");
dispatcher->Add<ElementCssCommand>(      "/session/*/element/*/css/*");
dispatcher->Add<ElementClearCommand>(    "/session/*/element/*/clear");
dispatcher->Add<ElementDisplayedCommand>("/session/*/element/*/displayed");
dispatcher->Add<ElementEnabledCommand>(  "/session/*/element/*/enabled");
dispatcher->Add<ElementEqualsCommand>(   "/session/*/element/*/equals/*");
dispatcher->Add<ElementLocationCommand>( "/session/*/element/*/location");
dispatcher->Add<ElementLocationInViewCommand>(
"/session/*/element/*/location_in_view");
dispatcher->Add<ElementNameCommand>(    "/session/*/element/*/name");
dispatcher->Add<ElementSelectedCommand>("/session/*/element/*/selected");
dispatcher->Add<ElementSizeCommand>(    "/session/*/element/*/size");
dispatcher->Add<ElementSubmitCommand>(  "/session/*/element/*/submit");
dispatcher->Add<ElementTextCommand>(    "/session/*/element/*/text");
dispatcher->Add<ElementToggleCommand>(  "/session/*/element/*/toggle");
dispatcher->Add<ElementValueCommand>(   "/session/*/element/*/value");

dispatcher->Add<ScreenshotCommand>("/session/*/screenshot");

// Mouse Commands
dispatcher->Add<MoveAndClickCommand>("/session/*/element/*/click");
dispatcher->Add<DragCommand>(        "/session/*/element/*/drag");
dispatcher->Add<HoverCommand>(       "/session/*/element/*/hover");

dispatcher->Add<MoveToCommand>(     "/session/*/moveto");
dispatcher->Add<ClickCommand>(      "/session/*/click");
dispatcher->Add<ButtonDownCommand>( "/session/*/buttondown");
dispatcher->Add<ButtonUpCommand>(   "/session/*/buttonup");
dispatcher->Add<DoubleClickCommand>("/session/*/doubleclick");

// All session based commands should be listed after the element based
// commands to avoid potential mapping conflicts from an overzealous
// wildcard match. For example, /session/*/title maps to the handler to
// fetch the page title. If mapped first, this would overwrite the handler
// for /session/*/element/*/attribute/title, which should fetch the title
// attribute of the element.
dispatcher->Add<AcceptAlertCommand>(  "/session/*/accept_alert");
dispatcher->Add<AlertTextCommand>(    "/session/*/alert_text");
dispatcher->Add<BackCommand>(         "/session/*/back");
dispatcher->Add<DismissAlertCommand>( "/session/*/dismiss_alert");
dispatcher->Add<ExecuteCommand>(      "/session/*/execute");
dispatcher->Add<ExecuteAsyncScriptCommand>(
"/session/*/execute_async");
dispatcher->Add<ForwardCommand>(      "/session/*/forward");
dispatcher->Add<SwitchFrameCommand>(  "/session/*/frame");
dispatcher->Add<RefreshCommand>(      "/session/*/refresh");
dispatcher->Add<SourceCommand>(       "/session/*/source");
dispatcher->Add<TitleCommand>(        "/session/*/title");
dispatcher->Add<URLCommand>(          "/session/*/url");
dispatcher->Add<WindowCommand>(       "/session/*/window");
dispatcher->Add<WindowHandleCommand>( "/session/*/window_handle");
dispatcher->Add<WindowHandlesCommand>("/session/*/window_handles");
dispatcher->Add<SetAsyncScriptTimeoutCommand>(
"/session/*/timeouts/async_script");
dispatcher->Add<ImplicitWaitCommand>( "/session/*/timeouts/implicit_wait");

// Cookie functions.
dispatcher->Add<CookieCommand>(     "/session/*/cookie");
dispatcher->Add<NamedCookieCommand>("/session/*/cookie/*");

// Since the /session/* is a wild card that would match the above URIs, this
// line MUST be after all other webdriver command callbacks.
dispatcher->Add<SessionWithID>("/session/*");

if (forbid_other_requests)
dispatcher->ForbidAllOtherRequests();
}

Dispatcher::~Dispatcher() {}

bool SendGetCookiesJSONRequestDeprecated(
    AutomationMessageSender* sender,
    int browser_index,
    const std::string& url,
    std::string* cookies) {
  DictionaryValue dict;
  dict.SetString("command", "GetCookies");
  dict.SetInteger("windex", browser_index);
  dict.SetString("url", url);
  DictionaryValue reply_dict;
  std::string error_msg;
  if (!SendAutomationJSONRequest(sender, dict, &reply_dict, &error_msg))
    return false;
  return reply_dict.GetString("cookies", cookies);
}

void CheckValueType(const Value::ValueType expected,
                    const Value* const actual) {
  DCHECK(actual != NULL) << "Expected value to be non-NULL";
  DCHECK(expected == actual->GetType())
      << "Expected " << print_valuetype(expected)
      << ", but was " << print_valuetype(actual->GetType());
}

void Automation::GoBack(int tab_id, Error** error) {
  int windex = 0, tab_index = 0;
  *error = GetIndicesForTab(tab_id, &windex, &tab_index);
  if (*error)
    return;

  std::string error_msg;
  if (!SendGoBackJSONRequest(automation(), windex, tab_index, &error_msg))
    *error = new Error(kUnknownError, error_msg);
}

void Automation::SendNativeKeyEvent(int tab_id,
                                    ui::KeyboardCode key_code,
                                    int modifiers,
                                    Error** error) {
  int windex = 0, tab_index = 0;
  *error = GetIndicesForTab(tab_id, &windex, &tab_index);
  if (*error)
    return;

  std::string error_msg;
  if (!SendNativeKeyEventJSONRequest(
         automation(), windex, tab_index, key_code, modifiers, &error_msg)) {
    *error = new Error(kUnknownError, error_msg);
  }
}

std::string SessionManager::GetAddress() {
  std::string hostname = net::GetHostName();
#if defined(OS_WIN)
  if (hostname.length()) {
    struct hostent* host_entry = gethostbyname(hostname.c_str());
    if (host_entry)
      hostname = host_entry->h_name;
  }
#endif
  if (hostname.empty()) {
    hostname = "localhost";
  }
  return hostname + ":" + port_ + url_base_;
}

SessionManager::~SessionManager() {}

void SendNotImplementedError(struct mg_connection* connection,
const struct mg_request_info* request_info,
void* user_data) {
// Send a well-formed WebDriver JSON error response to ensure clients
// handle it correctly.
std::string body = base::StringPrintf(
"{\"status\":%d,\"value\":{\"message\":"
"\"Command has not been implemented yet: %s %s\"}}",
kUnknownCommand, request_info->request_method, request_info->uri);

std::string header = base::StringPrintf(
"HTTP/1.1 501 Not Implemented\r\n"
"Content-Type:application/json\r\n"
"Content-Length:%" PRIuS "\r\n"
"\r\n", body.length());

  LOG(ERROR) << header << body;
mg_write(connection, header.data(), header.length());
mg_write(connection, body.data(), body.length());
}

bool WebDriverCommand::Init(Response* const response) {
// There should be at least 3 path segments to match "/session/$id".
std::string session_id = GetPathVariable(2);
if (session_id.length() == 0) {
response->SetError(
new Error(kBadRequest, "No session ID specified"));
return false;
}

  VLOG(1) << "Fetching session: " << session_id;
session_ = SessionManager::GetInstance()->GetSession(session_id);
if (session_ == NULL) {
response->SetError(
new Error(kSessionNotFound, "Session not found: " + session_id));
return false;
}

  // TODO(kkania): Do not use the standard automation timeout for this,
  // and throw an error if it does not succeed.
  scoped_ptr<Error> error(session_->WaitForAllTabsToStopLoading());
  if (error.get()) {
    LOG(WARNING) << error->ToString();
}
  error.reset(session_->SwitchToTopFrameIfCurrentFrameInvalid());
  if (error.get()) {
    LOG(WARNING) << error->ToString();
}

response->SetField("sessionId", Value::CreateStringValue(session_id));
return true;
}

void SendForbidden(struct mg_connection* connection,
                   const struct mg_request_info* request_info,
                   void* user_data) {
  mg_printf(connection, "HTTP/1.1 403 Forbidden\r\n\r\n");
}

void PrepareHttpResponse(const Response& command_response,
                         HttpResponse* const http_response) {
  ErrorCode status = command_response.GetStatus();
  switch (status) {
    case kSuccess:
      http_response->set_status(HttpResponse::kOk);
      break;

    case kSeeOther: {
      const Value* const value = command_response.GetValue();
      std::string location;
      if (!value->GetAsString(&location)) {
        http_response->set_status(HttpResponse::kInternalServerError);
        http_response->SetBody("Unable to set 'Location' header: response "
                               "value is not a string: " +
                               command_response.ToJSON());
        return;
      }
      http_response->AddHeader("Location", location);
      http_response->set_status(HttpResponse::kSeeOther);
      break;
    }

    case kBadRequest:
    case kSessionNotFound:
      http_response->set_status(status);
      break;

    case kMethodNotAllowed: {
      const Value* const value = command_response.GetValue();
      if (!value->IsType(Value::TYPE_LIST)) {
        http_response->set_status(HttpResponse::kInternalServerError);
        http_response->SetBody(
            "Unable to set 'Allow' header: response value was "
            "not a list of strings: " + command_response.ToJSON());
        return;
      }

      const ListValue* const list_value =
          static_cast<const ListValue* const>(value);
      std::vector<std::string> allowed_methods;
      for (size_t i = 0; i < list_value->GetSize(); ++i) {
        std::string method;
        if (list_value->GetString(i, &method)) {
          allowed_methods.push_back(method);
        } else {
          http_response->set_status(HttpResponse::kInternalServerError);
          http_response->SetBody(
              "Unable to set 'Allow' header: response value was "
              "not a list of strings: " + command_response.ToJSON());
          return;
        }
      }
      http_response->AddHeader("Allow", JoinString(allowed_methods, ','));
      http_response->set_status(HttpResponse::kMethodNotAllowed);
      break;
    }

    case kInternalServerError:
    default:
      http_response->set_status(HttpResponse::kInternalServerError);
      break;
  }

  http_response->SetMimeType("application/json; charset=utf-8");
  http_response->SetBody(command_response.ToJSON());
}

bool SendMouseDoubleClickJSONRequest(
    AutomationMessageSender* sender,
    int browser_index,
    int tab_index,
    int x,
    int y,
    std::string* error_msg)  {
  DictionaryValue dict;
  dict.SetString("command", "WebkitMouseDoubleClick");
  dict.SetInteger("windex", browser_index);
  dict.SetInteger("tab_index", tab_index);
  dict.SetInteger("x", x);
  dict.SetInteger("y", y);
  DictionaryValue reply_dict;
  return SendAutomationJSONRequest(sender, dict, &reply_dict, error_msg);
}

std::string SessionManager::url_base() const {
  return url_base_;
}

void Automation::GetCookiesDeprecated(int tab_id,
                                      const GURL& gurl,
                                      std::string* cookies,
                                      bool* success) {
  int windex = 0, tab_index = 0;
  scoped_ptr<Error> error(GetIndicesForTab(tab_id, &windex, &tab_index));
  if (error.get()) {
    *success = false;
    return;
  }

  *success = SendGetCookiesJSONRequestDeprecated(
      automation(), windex, gurl.possibly_invalid_spec(), cookies);
}

bool SendMouseButtonDownJSONRequest(
    AutomationMessageSender* sender,
    int browser_index,
    int tab_index,
    int x,
    int y,
    std::string* error_msg) {
  DictionaryValue dict;
  dict.SetString("command", "WebkitMouseButtonDown");
  dict.SetInteger("windex", browser_index);
  dict.SetInteger("tab_index", tab_index);
  dict.SetInteger("x", x);
  dict.SetInteger("y", y);
  DictionaryValue reply_dict;
  return SendAutomationJSONRequest(sender, dict, &reply_dict, error_msg);
}

void Automation::SetCookie(const std::string& url,
                           DictionaryValue* cookie_dict,
                           Error** error) {
  std::string error_msg;
  if (!SendSetCookieJSONRequest(automation(), url, cookie_dict, &error_msg))
    *error = new Error(kUnknownError, error_msg);
}

bool ParseJSONDictionary(const std::string& json, DictionaryValue** dict,
                         std::string* error) {
  int error_code = 0;
  Value* params =
    base::JSONReader::ReadAndReturnError(json, true, &error_code, error);
  if (error_code != 0) {
    VLOG(1) << "Could not parse JSON object, " << *error;
    if (params)
      delete params;
    return false;
  }
  if (!params || params->GetType() != Value::TYPE_DICTIONARY) {
    *error = "Data passed in URL must be of type dictionary.";
    VLOG(1) << "Invalid type to parse";
    if (params)
      delete params;
    return false;
  }
  *dict = static_cast<DictionaryValue*>(params);
  return true;
}

bool CreateSession::DoesPost() { return true; }

ui::KeyboardCode KeyMap::Get(const wchar_t& key) const {
  std::map<wchar_t, ui::KeyboardCode>::const_iterator it;
  it = keys_.find(key);
  if (it == keys_.end()) {
    it = shifted_keys_.find(key);
    if (it == shifted_keys_.end()) {
      return ui::VKEY_UNKNOWN;
    }
  }
  return it->second;
}

Automation::~Automation() {}

bool SendNavigateToURLJSONRequest(
    AutomationMessageSender* sender,
    int browser_index,
    int tab_index,
    const GURL& url,
    int navigation_count,
    AutomationMsg_NavigationResponseValues* nav_response,
    std::string* error_msg) {
  DictionaryValue dict;
  dict.SetString("command", "NavigateToURL");
  dict.SetInteger("windex", browser_index);
  dict.SetInteger("tab_index", tab_index);
  dict.SetString("url", url.possibly_invalid_spec());
  dict.SetInteger("navigation_count", navigation_count);
  DictionaryValue reply_dict;
  if (!SendAutomationJSONRequest(sender, dict, &reply_dict, error_msg))
    return false;
  int response = 0;
  if (!reply_dict.GetInteger("result", &response))
    return false;
  *nav_response = static_cast<AutomationMsg_NavigationResponseValues>(response);
  return true;
}

void CreateSession::ExecutePost(Response* const response) {
DictionaryValue *capabilities = NULL;
if (!GetDictionaryParameter("desiredCapabilities", &capabilities)) {
response->SetError(new Error(
kBadRequest, "Missing or invalid 'desiredCapabilities'"));
return;
}

CommandLine command_line_options(CommandLine::NO_PROGRAM);
ListValue* switches = NULL;
const char* kCustomSwitchesKey = "chrome.switches";
if (capabilities->GetListWithoutPathExpansion(kCustomSwitchesKey,
&switches)) {
for (size_t i = 0; i < switches->GetSize(); ++i) {
std::string switch_string;
if (!switches->GetString(i, &switch_string)) {
response->SetError(new Error(
kBadRequest, "Custom switch is not a string"));
return;
}
size_t separator_index = switch_string.find("=");
if (separator_index != std::string::npos) {
CommandLine::StringType switch_string_native;
if (!switches->GetString(i, &switch_string_native)) {
response->SetError(new Error(
kBadRequest, "Custom switch is not a string"));
return;
}
command_line_options.AppendSwitchNative(
switch_string.substr(0, separator_index),
switch_string_native.substr(separator_index + 1));
} else {
command_line_options.AppendSwitch(switch_string);
}
}
} else if (capabilities->HasKey(kCustomSwitchesKey)) {
response->SetError(new Error(
kBadRequest, "Custom switches must be a list"));
return;
}

FilePath browser_exe;
FilePath::StringType path;
if (capabilities->GetStringWithoutPathExpansion("chrome.binary", &path))
browser_exe = FilePath(path);

// Session manages its own liftime, so do not call delete.
Session* session = new Session();
Error* error = session->Init(browser_exe, command_line_options);
if (error) {
response->SetError(error);
return;
}

bool native_events_required = false;
Value* native_events_value = NULL;
if (capabilities->GetWithoutPathExpansion(
"chrome.nativeEvents", &native_events_value)) {
if (native_events_value->GetAsBoolean(&native_events_required)) {
session->set_use_native_events(native_events_required);
}
}
bool screenshot_on_error = false;
if (capabilities->GetBoolean(
"takeScreenshotOnError", &screenshot_on_error)) {
session->set_screenshot_on_error(screenshot_on_error);
}

  VLOG(1) << "Created session " << session->id();
std::ostringstream stream;
SessionManager* session_manager = SessionManager::GetInstance();
stream << "http://" << session_manager->GetAddress() << "/session/"
<< session->id();
response->SetStatus(kSeeOther);
response->SetValue(Value::CreateStringValue(stream.str()));
}

void Automation::Init(const CommandLine& options,
                      Error** error) {
  FilePath browser_exe;
  if (!GetDefaultChromeExe(&browser_exe)) {
    *error = new Error(kUnknownError, "Could not find default Chrome binary");
    return;
  }

  InitWithBrowserPath(browser_exe, options, error);
}

void Shutdown(struct mg_connection* connection,
              const struct mg_request_info* request_info,
              void* user_data) {
  base::WaitableEvent* shutdown_event =
      reinterpret_cast<base::WaitableEvent*>(user_data);
  mg_printf(connection, "HTTP/1.1 200 OK\r\n\r\n");
   shutdown_event->Signal();
 }

bool SendCloseTabJSONRequest(
    AutomationMessageSender* sender,
    int browser_index,
    int tab_index,
    std::string* error_msg) {
  DictionaryValue dict;
  dict.SetString("command", "CloseTab");
  dict.SetInteger("windex", browser_index);
  dict.SetInteger("tab_index", tab_index);
  DictionaryValue reply_dict;
  return SendAutomationJSONRequest(sender, dict, &reply_dict, error_msg);
}

std::string print_valuetype(Value::ValueType e) {
  switch (e) {
    case Value::TYPE_NULL:
      return "NULL ";
    case Value::TYPE_BOOLEAN:
      return "BOOL";
    case Value::TYPE_INTEGER:
      return "INT";
    case Value::TYPE_DOUBLE:
      return "DOUBLE";
    case Value::TYPE_STRING:
      return "STRING";
    case Value::TYPE_BINARY:
      return "BIN";
    case Value::TYPE_DICTIONARY:
      return "DICT";
    case Value::TYPE_LIST:
      return "LIST";
    default:
      return "ERROR";
  }
}

Error* Automation::CheckVersion(int client_build_no,
                                int client_patch_no,
                                const std::string& error_msg) {
  bool version_is_ok = false;
  Error* error = CompareVersion(
      client_build_no, client_patch_no, &version_is_ok);
  if (error)
    return error;
  if (!version_is_ok)
    return new Error(kUnknownError, error_msg);
  return NULL;
}

void DispatchHelper(Command* command_ptr,
                    const std::string& method,
                    Response* response) {
  CHECK(method == "GET" || method == "POST" || method == "DELETE");
  scoped_ptr<Command> command(command_ptr);

  if ((method == "GET" && !command->DoesGet()) ||
      (method == "POST" && !command->DoesPost()) ||
      (method == "DELETE" && !command->DoesDelete())) {
    ListValue* methods = new ListValue;
    if (command->DoesPost())
      methods->Append(Value::CreateStringValue("POST"));
    if (command->DoesGet()) {
      methods->Append(Value::CreateStringValue("GET"));
      methods->Append(Value::CreateStringValue("HEAD"));
    }
    if (command->DoesDelete())
      methods->Append(Value::CreateStringValue("DELETE"));
    response->SetStatus(kMethodNotAllowed);
    response->SetValue(methods);
    return;
  }

  DispatchCommand(command.get(), method, response);
}

bool SendSetCookieJSONRequestDeprecated(
    AutomationMessageSender* sender,
    int browser_index,
    const std::string& url,
    const std::string& cookie) {
  DictionaryValue dict;
  dict.SetString("command", "SetCookie");
  dict.SetInteger("windex", browser_index);
  dict.SetString("url", url);
  dict.SetString("cookie", cookie);
  DictionaryValue reply_dict;
  std::string error_msg;
  return SendAutomationJSONRequest(sender, dict, &reply_dict, &error_msg);
}

WebDriverCommand::WebDriverCommand(
    const std::vector<std::string>& path_segments,
    const DictionaryValue* const parameters)
    : Command(path_segments, parameters), session_(NULL) {
}

void Automation::GetBrowserVersion(std::string* version) {
  *version = automation()->server_version();
}

bool SendDeleteCookieJSONRequestDeprecated(
    AutomationMessageSender* sender,
    int browser_index,
    const std::string& url,
    const std::string& cookie_name) {
  DictionaryValue dict;
  dict.SetString("command", "DeleteCookie");
  dict.SetInteger("windex", browser_index);
  dict.SetString("url", url);
  dict.SetString("name", cookie_name);
  DictionaryValue reply_dict;
  std::string error_msg;
  return SendAutomationJSONRequest(sender, dict, &reply_dict, &error_msg);
}

 bool SetMongooseOptions(struct mg_context* ctx,
                        const std::string& port,
                        const std::string& root) {
  if (!mg_set_option(ctx, "ports", port.c_str())) {
    std::cout << "ChromeDriver cannot bind to port ("
              << port.c_str() << ")" << std::endl;
    return false;
  }
  if (root.length())
    mg_set_option(ctx, "root", root.c_str());
  mg_set_option(ctx, "idle_time", "1");
  return true;
}

CreateSession::~CreateSession() {}

AutomationProxy* Automation::automation() const {
  return launcher_->automation();
}

 std::string GenerateRandomID() {
   uint64 msb = base::RandUint64();
   uint64 lsb = base::RandUint64();
  return base::StringPrintf("%016" PRIx64 "%016" PRIx64, msb, lsb);
}

bool SendGetTabIdsJSONRequest(
    AutomationMessageSender* sender,
    std::vector<int>* tab_ids,
    std::string* error_msg) {
  DictionaryValue dict;
  dict.SetString("command", "GetTabIds");
  DictionaryValue reply_dict;
  if (!SendAutomationJSONRequest(sender, dict, &reply_dict, error_msg))
    return false;
  ListValue* id_list;
  if (!reply_dict.GetList("ids", &id_list)) {
    LOG(ERROR) << "Returned 'ids' key is missing or invalid";
    return false;
  }
  std::vector<int> temp_ids;
  for (size_t i = 0; i < id_list->GetSize(); ++i) {
    int id;
    if (!id_list->GetInteger(i, &id)) {
      LOG(ERROR) << "Returned 'ids' key contains non-integer values";
      return false;
    }
    temp_ids.push_back(id);
  }
  *tab_ids = temp_ids;
  return true;
}

bool SendGetIndicesFromTabHandleJSONRequest(
    AutomationMessageSender* sender,
    int tab_handle,
    int* browser_index,
    int* tab_index,
    std::string* error_msg) {
  DictionaryValue request_dict;
  request_dict.SetString("command", "GetIndicesFromTab");
  request_dict.SetInteger("tab_handle", tab_handle);
  DictionaryValue reply_dict;
  if (!SendAutomationJSONRequest(sender, request_dict, &reply_dict, error_msg))
    return false;
  if (!reply_dict.GetInteger("windex", browser_index))
    return false;
  if (!reply_dict.GetInteger("tab_index", tab_index))
    return false;
  return true;
}

bool SendSetCookieJSONRequest(
    AutomationMessageSender* sender,
    const std::string& url,
    DictionaryValue* cookie_dict,
    std::string* error_msg) {
  DictionaryValue dict;
  dict.SetString("command", "SetCookie");
  dict.SetString("url", url);
  dict.Set("cookie", cookie_dict->DeepCopy());
  DictionaryValue reply_dict;
  return SendAutomationJSONRequest(sender, dict, &reply_dict, error_msg);
}

bool SendReloadJSONRequest(
    AutomationMessageSender* sender,
    int browser_index,
    int tab_index,
    std::string* error_msg) {
  DictionaryValue dict;
  dict.SetString("command", "Reload");
  dict.SetInteger("windex", browser_index);
  dict.SetInteger("tab_index", tab_index);
  DictionaryValue reply_dict;
  return SendAutomationJSONRequest(sender, dict, &reply_dict, error_msg);
}

 void SendNoContentResponse(struct mg_connection* connection,
                            const struct mg_request_info* request_info,
                            void* user_data) {
  std::string response = "HTTP/1.1 204 No Content\r\n"
                         "Content-Length:0\r\n"
                         "\r\n";
  mg_write(connection, response.data(), response.length());
}

bool SendAcceptOrDismissAppModalDialogJSONRequest(
    AutomationMessageSender* sender,
    bool accept,
    std::string* error_msg) {
  DictionaryValue dict;
  dict.SetString("command", "AcceptOrDismissAppModalDialog");
  dict.SetBoolean("accept", accept);
  DictionaryValue reply_dict;
  return SendAutomationJSONRequest(sender, dict, &reply_dict, error_msg);
}

void Automation::DeleteCookieDeprecated(int tab_id,
                                        const GURL& gurl,
                                        const std::string& cookie_name,
                                        bool* success) {
  int windex = 0, tab_index = 0;
  scoped_ptr<Error> error(GetIndicesForTab(tab_id, &windex, &tab_index));
  if (error.get()) {
    *success = false;
    return;
  }

  *success = SendDeleteCookieJSONRequestDeprecated(
      automation(),
      windex,
      gurl.possibly_invalid_spec(),
      cookie_name);
}

WebKeyEvent::WebKeyEvent(automation::KeyEventTypes type,
                         ui::KeyboardCode key_code,
                         const std::string& unmodified_text,
                         const std::string& modified_text,
                         int modifiers)
    : type(type),
      key_code(key_code),
      unmodified_text(unmodified_text),
      modified_text(modified_text),
      modifiers(modifiers) {}

bool SendMouseMoveJSONRequest(
    AutomationMessageSender* sender,
    int browser_index,
    int tab_index,
    int x,
    int y,
    std::string* error_msg) {
  DictionaryValue dict;
  dict.SetString("command", "WebkitMouseMove");
  dict.SetInteger("windex", browser_index);
  dict.SetInteger("tab_index", tab_index);
  dict.SetInteger("x", x);
  dict.SetInteger("y", y);
  DictionaryValue reply_dict;
  return SendAutomationJSONRequest(sender, dict, &reply_dict, error_msg);
}

void Automation::InitWithBrowserPath(const FilePath& browser_exe,
const CommandLine& options,
Error** error) {
if (!file_util::PathExists(browser_exe)) {
std::string message = base::StringPrintf(
"Could not find Chrome binary at: %" PRFilePath,
browser_exe.value().c_str());
*error = new Error(kUnknownError, message);
return;
}

CommandLine command(browser_exe);
command.AppendSwitch(switches::kDisableHangMonitor);
command.AppendSwitch(switches::kDisablePromptOnRepost);
command.AppendSwitch(switches::kDomAutomationController);
command.AppendSwitch(switches::kFullMemoryCrashReport);
command.AppendSwitchASCII(switches::kHomePage, chrome::kAboutBlankURL);
command.AppendSwitch(switches::kNoDefaultBrowserCheck);
command.AppendSwitch(switches::kNoFirstRun);
command.AppendSwitchASCII(switches::kTestType, "webdriver");

command.AppendArguments(options, false);

launcher_.reset(new AnonymousProxyLauncher(false));
ProxyLauncher::LaunchState launch_props = {
false,  // clear_profile
FilePath(),  // template_user_data
ProxyLauncher::DEFAULT_THEME,
command,
true,  // include_testing_id
true   // show_window
};

std::string chrome_details = base::StringPrintf(
"Using Chrome binary at: %" PRFilePath,
browser_exe.value().c_str());
  VLOG(1) << chrome_details;

if (!launcher_->LaunchBrowserAndServer(launch_props, true)) {
*error = new Error(
kUnknownError,
"Unable to either launch or connect to Chrome. Please check that "
"ChromeDriver is up-to-date. " + chrome_details);
return;
}

launcher_->automation()->set_action_timeout_ms(base::kNoTimeout);
  VLOG(1) << "Chrome launched successfully. Version: "
          << automation()->server_version();

bool has_automation_version = false;
*error = CompareVersion(730, 0, &has_automation_version);
if (*error)
return;

chrome_details += ", version (" + automation()->server_version() + ")";
if (has_automation_version) {
int version = 0;
std::string error_msg;
if (!SendGetChromeDriverAutomationVersion(
automation(), &version, &error_msg)) {
*error = new Error(kUnknownError, error_msg + " " + chrome_details);
return;
}
if (version > automation::kChromeDriverAutomationVersion) {
*error = new Error(
kUnknownError,
"ChromeDriver is not compatible with this version of Chrome. " +
chrome_details);
return;
}
}
}

Dispatcher::Dispatcher(struct mg_context* context, const std::string& root)
    : context_(context), root_(root) {
  mg_set_uri_callback(context_, "/favicon.ico", &SendNoContentResponse, NULL);
}

void Automation::GetCookies(const std::string& url,
                            ListValue** cookies,
                            Error** error) {
  std::string error_msg;
  if (!SendGetCookiesJSONRequest(automation(), url, cookies, &error_msg))
    *error = new Error(kUnknownError, error_msg);
}

void Automation::MouseDrag(int tab_id,
                           const gfx::Point& start,
                           const gfx::Point& end,
                           Error** error) {
  int windex = 0, tab_index = 0;
  *error = GetIndicesForTab(tab_id, &windex, &tab_index);
  if (*error)
    return;

  std::string error_msg;
  if (!SendMouseDragJSONRequest(automation(), windex, tab_index, start.x(),
                                start.y(), end.x(), end.y(), &error_msg)) {
    *error = new Error(kUnknownError, error_msg);
  }
}

void Automation::WaitForAllTabsToStopLoading(Error** error) {
  std::string error_msg;
  if (!SendWaitForAllTabsToStopLoadingJSONRequest(automation(), &error_msg))
    *error = new Error(kUnknownError, error_msg);
}

bool SendWebKeyEventJSONRequest(
    AutomationMessageSender* sender,
    int browser_index,
    int tab_index,
    const WebKeyEvent& key_event,
    std::string* error_msg) {
  DictionaryValue dict;
  dict.SetString("command", "SendWebkitKeyEvent");
  dict.SetInteger("windex", browser_index);
  dict.SetInteger("tab_index", tab_index);
  dict.SetInteger("type", key_event.type);
  dict.SetInteger("nativeKeyCode", key_event.key_code);
  dict.SetInteger("windowsKeyCode", key_event.key_code);
  dict.SetString("unmodifiedText", key_event.unmodified_text);
  dict.SetString("text", key_event.modified_text);
  dict.SetInteger("modifiers", key_event.modifiers);
  dict.SetBoolean("isSystemKey", false);
  DictionaryValue reply_dict;
  return SendAutomationJSONRequest(sender, dict, &reply_dict, error_msg);
}

void Dispatcher::AddShutdown(const std::string& pattern,
                             base::WaitableEvent* shutdown_event) {
  mg_set_uri_callback(context_, (root_ + pattern).c_str(), &Shutdown,
                       shutdown_event);
 }

void Automation::GetAppModalDialogMessage(std::string* message, Error** error) {
  *error = CheckAlertsSupported();
  if (*error)
    return;

  std::string error_msg;
  if (!SendGetAppModalDialogMessageJSONRequest(
          automation(), message, &error_msg)) {
    *error = new Error(kUnknownError, error_msg);
  }
}

bool SendMouseButtonUpJSONRequest(
    AutomationMessageSender* sender,
    int browser_index,
    int tab_index,
    int x,
    int y,
    std::string* error_msg)  {
  DictionaryValue dict;
  dict.SetString("command", "WebkitMouseButtonUp");
  dict.SetInteger("windex", browser_index);
  dict.SetInteger("tab_index", tab_index);
  dict.SetInteger("x", x);
  dict.SetInteger("y", y);
  DictionaryValue reply_dict;
  return SendAutomationJSONRequest(sender, dict, &reply_dict, error_msg);
}

void Dispatcher::ForbidAllOtherRequests() {
  mg_set_uri_callback(context_, "*", &SendForbidden, NULL);
}

void Automation::CaptureEntirePageAsPNG(int tab_id,
                                        const FilePath& path,
                                        Error** error) {
  int windex = 0, tab_index = 0;
  *error = GetIndicesForTab(tab_id, &windex, &tab_index);
  if (*error)
    return;

  std::string error_msg;
  if (!SendCaptureEntirePageJSONRequest(
          automation(), windex, tab_index, path, &error_msg)) {
    *error = new Error(kUnknownError, error_msg);
  }
}

CreateSession::CreateSession(const std::vector<std::string>& path_segments,
                             const DictionaryValue* const parameters)
    : Command(path_segments, parameters) {}

SessionManager* SessionManager::GetInstance() {
  return Singleton<SessionManager>::get();
}

Error* Automation::CheckAlertsSupported() {
  return CheckVersion(
      768, 0, "Alerts are not supported for this version of Chrome");
}

void Automation::CloseTab(int tab_id, Error** error) {
  int windex = 0, tab_index = 0;
  *error = GetIndicesForTab(tab_id, &windex, &tab_index);
  if (*error)
    return;

  std::string error_msg;
  if (!SendCloseTabJSONRequest(automation(), windex, tab_index, &error_msg))
    *error = new Error(kUnknownError, error_msg);
}

void Dispatcher::AddStatus(const std::string& pattern) {
  mg_set_uri_callback(context_, (root_ + pattern).c_str(), &SendStatus, NULL);
}

bool SendMouseClickJSONRequest(
    AutomationMessageSender* sender,
    int browser_index,
    int tab_index,
    automation::MouseButton button,
    int x,
    int y,
    std::string* error_msg) {
  DictionaryValue dict;
  dict.SetString("command", "WebkitMouseClick");
  dict.SetInteger("windex", browser_index);
  dict.SetInteger("tab_index", tab_index);
  dict.SetInteger("button", button);
  dict.SetInteger("x", x);
  dict.SetInteger("y", y);
  DictionaryValue reply_dict;
  return SendAutomationJSONRequest(sender, dict, &reply_dict, error_msg);
}

void Automation::MouseButtonDown(int tab_id,
                                 const gfx::Point& p,
                                 Error** error) {
  *error = CheckAdvancedInteractionsSupported();
  if (*error)
    return;

  int windex = 0, tab_index = 0;
  *error = GetIndicesForTab(tab_id, &windex, &tab_index);
  if (*error)
    return;

  std::string error_msg;
  if (!SendMouseButtonDownJSONRequest(
          automation(), windex, tab_index, p.x(), p.y(), &error_msg)) {
    *error = new Error(kUnknownError, error_msg);
  }
}

void Automation::SetCookieDeprecated(int tab_id,
                                     const GURL& gurl,
                                     const std::string& cookie,
                                     bool* success) {
  int windex = 0, tab_index = 0;
  scoped_ptr<Error> error(GetIndicesForTab(tab_id, &windex, &tab_index));
  if (error.get()) {
    *success = false;
    return;
  }

  *success = SendSetCookieJSONRequestDeprecated(
      automation(),
      windex,
      gurl.possibly_invalid_spec(),
      cookie);
}

bool SendGoForwardJSONRequest(
    AutomationMessageSender* sender,
    int browser_index,
    int tab_index,
    std::string* error_msg) {
  DictionaryValue dict;
  dict.SetString("command", "GoForward");
  dict.SetInteger("windex", browser_index);
  dict.SetInteger("tab_index", tab_index);
  DictionaryValue reply_dict;
  return SendAutomationJSONRequest(sender, dict, &reply_dict, error_msg);
}

void Automation::AcceptPromptAppModalDialog(const std::string& prompt_text,
                                            Error** error) {
  *error = CheckAlertsSupported();
  if (*error)
    return;

  std::string error_msg;
  if (!SendAcceptPromptAppModalDialogJSONRequest(
          automation(), prompt_text, &error_msg)) {
    *error = new Error(kUnknownError, error_msg);
  }
}

void Automation::ExecuteScript(int tab_id,
                               const FramePath& frame_path,
                               const std::string& script,
                               std::string* result,
                               Error** error) {
  int windex = 0, tab_index = 0;
  *error = GetIndicesForTab(tab_id, &windex, &tab_index);
  if (*error)
    return;

  Value* unscoped_value;
  std::string error_msg;
  if (!SendExecuteJavascriptJSONRequest(automation(), windex, tab_index,
                                        frame_path.value(), script,
                                        &unscoped_value, &error_msg)) {
    *error = new Error(kUnknownError, error_msg);
    return;
  }
  scoped_ptr<Value> value(unscoped_value);
  if (!value->GetAsString(result))
    *error = new Error(kUnknownError, "Execute script did not return string");
}

void Automation::GetChromeDriverAutomationVersion(int* version, Error** error) {
  std::string error_msg;
  if (!SendGetChromeDriverAutomationVersion(automation(), version, &error_msg))
    *error = new Error(kUnknownError, error_msg);
}
