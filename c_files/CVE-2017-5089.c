bool CheckClientDownloadRequest::IsCancelled() {
  return item_->GetState() == download::DownloadItem::CANCELLED;
}

void BinaryUploadService::Request::FinishRequest(
    Result result,
    DeepScanningClientResponse response) {
  std::move(callback_).Run(result, response);
}

void BinaryUploadService::RecordRequestMetrics(
    Request* request,
    Result result,
    const DeepScanningClientResponse& response) {
  base::UmaHistogramEnumeration("SafeBrowsingBinaryUploadRequest.Result",
                                result);
  base::UmaHistogramCustomTimes("SafeBrowsingBinaryUploadRequest.Duration",
                                base::TimeTicks::Now() - start_times_[request],
                                base::TimeDelta::FromMilliseconds(1),
                                base::TimeDelta::FromMinutes(6), 50);

  if (response.has_malware_scan_verdict()) {
    base::UmaHistogramBoolean("SafeBrowsingBinaryUploadRequest.MalwareResult",
                              response.malware_scan_verdict().verdict() !=
                                  MalwareDeepScanningVerdict::CLEAN);
  }

  if (response.has_dlp_scan_verdict()) {
    base::UmaHistogramBoolean("SafeBrowsingBinaryUploadRequest.DlpResult",
                              response.dlp_scan_verdict().status() ==
                                  DlpDeepScanningVerdict::SUCCESS);
  }
}

std::string GetDMToken() {
  std::string dm_token = *GetTestingDMToken();

#if !defined(OS_CHROMEOS)
// This is not compiled on chromeos because
// ChromeBrowserCloudManagementController does not exist.  Also,
// policy::BrowserDMTokenStorage::Get()->RetrieveDMToken() does not return a
// valid token either.  Once these are fixed the #if !defined can be removed.

  if (dm_token.empty() &&
policy::ChromeBrowserCloudManagementController::IsEnabled()) {
    dm_token = policy::BrowserDMTokenStorage::Get()->RetrieveDMToken();
}
#endif

return dm_token;
}

BinaryUploadService::BinaryUploadService(
    scoped_refptr<network::SharedURLLoaderFactory> url_loader_factory,
    std::unique_ptr<BinaryFCMService> binary_fcm_service)
    : url_loader_factory_(url_loader_factory),
      binary_fcm_service_(std::move(binary_fcm_service)),
      weakptr_factory_(this) {}

CheckClientDownloadRequest::CheckClientDownloadRequest(
    download::DownloadItem* item,
    CheckDownloadRepeatingCallback callback,
    DownloadProtectionService* service,
    scoped_refptr<SafeBrowsingDatabaseManager> database_manager,
    scoped_refptr<BinaryFeatureExtractor> binary_feature_extractor)
    : CheckClientDownloadRequestBase(
          item->GetURL(),
          item->GetTargetFilePath(),
          item->GetFullPath(),
          {item->GetTabUrl(), item->GetTabReferrerUrl()},

bool CheckClientDownloadRequest::ShouldUploadForDlpScan() {
if (!base::FeatureList::IsEnabled(kDeepScanningOfDownloads))
return false;

int check_content_compliance = g_browser_process->local_state()->GetInteger(
prefs::kCheckContentCompliance);
if (check_content_compliance !=
CheckContentComplianceValues::CHECK_DOWNLOADS &&
check_content_compliance !=
CheckContentComplianceValues::CHECK_UPLOADS_AND_DOWNLOADS)
return false;

  // If there's no DM token, the upload will fail, so we can skip uploading now.
  if (policy::BrowserDMTokenStorage::Get()->RetrieveDMToken().empty())
return false;

const base::ListValue* domains = g_browser_process->local_state()->GetList(
prefs::kURLsToCheckComplianceOfDownloadedContent);
url_matcher::URLMatcher matcher;
policy::url_util::AddAllowFilters(&matcher, domains);
return !matcher.MatchURL(item_->GetURL()).empty();
}

void CheckClientDownloadRequest::NotifySendRequest(
    const ClientDownloadRequest* request) {
  DCHECK_CURRENTLY_ON(BrowserThread::UI);
  service()->client_download_request_callbacks_.Notify(item_, request);
}

void BinaryUploadService::UploadForDeepScanning(
    std::unique_ptr<BinaryUploadService::Request> request) {
  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);

  Request* raw_request = request.get();
  active_requests_[raw_request] = std::move(request);
  start_times_[raw_request] = base::TimeTicks::Now();

  if (!binary_fcm_service_) {
    base::PostTask(FROM_HERE, {content::BrowserThread::UI},
                   base::BindOnce(&BinaryUploadService::FinishRequest,
                                  weakptr_factory_.GetWeakPtr(), raw_request,
                                  Result::FAILED_TO_GET_TOKEN,
                                  DeepScanningClientResponse()));
    return;
  }

  std::string token = base::RandBytesAsString(128);
  token = base::HexEncode(token.data(), token.size());
  active_tokens_[raw_request] = token;
  binary_fcm_service_->SetCallbackForToken(
      token, base::BindRepeating(&BinaryUploadService::OnGetResponse,
                                 weakptr_factory_.GetWeakPtr(), raw_request));
  raw_request->set_request_token(std::move(token));

  binary_fcm_service_->GetInstanceID(
      base::BindOnce(&BinaryUploadService::OnGetInstanceID,
                     weakptr_factory_.GetWeakPtr(), raw_request));
  active_timers_[raw_request] = std::make_unique<base::OneShotTimer>();
  active_timers_[raw_request]->Start(
      FROM_HERE, base::TimeDelta::FromSeconds(kScanningTimeoutSeconds),
      base::BindOnce(&BinaryUploadService::OnTimeout,
                     weakptr_factory_.GetWeakPtr(), raw_request));
}

content::BrowserContext* CheckClientDownloadRequest::GetBrowserContext() {
  return content::DownloadItemUtils::GetBrowserContext(item_);
}

void BinaryUploadService::RunAuthorizationCallbacks() {
  DCHECK(can_upload_data_.has_value());
  for (auto& callback : authorization_callbacks_) {
    std::move(callback).Run(can_upload_data_.value());
  }
  authorization_callbacks_.clear();
}

void BinaryUploadService::MaybeUploadForDeepScanning(
    std::unique_ptr<BinaryUploadService::Request> request) {
  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
  can_upload_data_ = true;
  if (!can_upload_data_.has_value()) {
    IsAuthorized(
        base::BindOnce(&BinaryUploadService::MaybeUploadForDeepScanningCallback,
                       weakptr_factory_.GetWeakPtr(), std::move(request)));
    return;
  }

  MaybeUploadForDeepScanningCallback(std::move(request),
                                     can_upload_data_.value());
}

  explicit ValidateDataUploadRequest(BinaryUploadService::Callback callback)
      : BinaryUploadService::Request(std::move(callback)) {}

void BinaryUploadService::Request::set_request_dlp_scan(
    DlpDeepScanningClientRequest dlp_request) {
  *deep_scanning_request_.mutable_dlp_scan_request() = std::move(dlp_request);
}

void BinaryUploadService::MaybeUploadForDeepScanningCallback(
    std::unique_ptr<BinaryUploadService::Request> request,
    bool authorized) {
  if (!authorized)
    return;
  UploadForDeepScanning(std::move(request));
}

CheckClientDownloadRequest::~CheckClientDownloadRequest() {
  DCHECK_CURRENTLY_ON(BrowserThread::UI);
  item_->RemoveObserver(this);
}

void BinaryUploadService::Request::set_request_malware_scan(
    MalwareDeepScanningClientRequest malware_request) {
  *deep_scanning_request_.mutable_malware_scan_request() =
      std::move(malware_request);
}

std::string* GetTestingDMToken() {
  static std::string dm_token;
return &dm_token;
}

void DeepScanningClientResponseToDownloadCheckResult(
    const DeepScanningClientResponse& response,
    DownloadCheckResult* download_result,
    DownloadCheckResultReason* download_reason) {
  if (response.has_malware_scan_verdict() &&
      response.malware_scan_verdict().verdict() ==
          MalwareDeepScanningVerdict::MALWARE) {
    *download_result = DownloadCheckResult::DANGEROUS;
    *download_reason = DownloadCheckResultReason::REASON_DOWNLOAD_DANGEROUS;
    return;
  }

  if (response.has_malware_scan_verdict() &&
      response.malware_scan_verdict().verdict() ==
          MalwareDeepScanningVerdict::UWS) {
    *download_result = DownloadCheckResult::POTENTIALLY_UNWANTED;
    *download_reason =
        DownloadCheckResultReason::REASON_DOWNLOAD_POTENTIALLY_UNWANTED;
    return;
  }

  if (response.has_dlp_scan_verdict()) {
    bool should_dlp_block = std::any_of(
        response.dlp_scan_verdict().triggered_rules().begin(),
        response.dlp_scan_verdict().triggered_rules().end(),
        [](const DlpDeepScanningVerdict::TriggeredRule& rule) {
          return rule.action() == DlpDeepScanningVerdict::TriggeredRule::BLOCK;
        });
    if (should_dlp_block) {
      *download_result = DownloadCheckResult::SENSITIVE_CONTENT_BLOCK;
      *download_reason =
          DownloadCheckResultReason::REASON_SENSITIVE_CONTENT_BLOCK;
      return;
    }

    bool should_dlp_warn = std::any_of(
        response.dlp_scan_verdict().triggered_rules().begin(),
        response.dlp_scan_verdict().triggered_rules().end(),
        [](const DlpDeepScanningVerdict::TriggeredRule& rule) {
          return rule.action() == DlpDeepScanningVerdict::TriggeredRule::WARN;
        });
    if (should_dlp_warn) {
      *download_result = DownloadCheckResult::SENSITIVE_CONTENT_WARNING;
      *download_reason =
          DownloadCheckResultReason::REASON_SENSITIVE_CONTENT_WARNING;
      return;
    }
  }

  *download_result = DownloadCheckResult::DEEP_SCANNED_SAFE;
  *download_reason = DownloadCheckResultReason::REASON_DEEP_SCANNED_SAFE;
}

void MaybeReportDeepScanningVerdict(Profile* profile,
                                    const GURL& url,
                                    const std::string& file_name,
                                    const std::string& download_digest_sha256,
                                    const std::string& mime_type,
                                    const std::string& trigger,
                                    const int64_t content_size,
                                    BinaryUploadService::Result result,
                                    DeepScanningClientResponse response) {
  if (result == BinaryUploadService::Result::FILE_TOO_LARGE) {
    extensions::SafeBrowsingPrivateEventRouterFactory::GetForProfile(profile)
        ->OnLargeUnscannedFileEvent(url, file_name, download_digest_sha256,
                                    mime_type, trigger, content_size);
  }

  if (result != BinaryUploadService::Result::SUCCESS)
    return;

  if (response.malware_scan_verdict().verdict() ==
          MalwareDeepScanningVerdict::UWS ||
      response.malware_scan_verdict().verdict() ==
          MalwareDeepScanningVerdict::MALWARE) {
    extensions::SafeBrowsingPrivateEventRouterFactory::GetForProfile(profile)
        ->OnDangerousDeepScanningResult(
            url, file_name, download_digest_sha256,
            MalwareVerdictToThreatType(
                response.malware_scan_verdict().verdict()),
            mime_type, trigger, content_size);
  }

  if (response.dlp_scan_verdict().status() == DlpDeepScanningVerdict::SUCCESS) {
    if (!response.dlp_scan_verdict().triggered_rules().empty()) {
      extensions::SafeBrowsingPrivateEventRouterFactory::GetForProfile(profile)
          ->OnSensitiveDataEvent(response.dlp_scan_verdict(), url, file_name,
                                 download_digest_sha256, mime_type, trigger,
                                 content_size);
    }
  }
}

bool CheckClientDownloadRequest::ShouldUploadForMalwareScan(
DownloadCheckResultReason reason) {
if (!base::FeatureList::IsEnabled(kDeepScanningOfDownloads))
return false;

// If we know the file is malicious, we don't need to upload it.
if (reason != DownloadCheckResultReason::REASON_DOWNLOAD_SAFE &&
reason != DownloadCheckResultReason::REASON_DOWNLOAD_UNCOMMON &&
reason != DownloadCheckResultReason::REASON_VERDICT_UNKNOWN)
return false;

content::BrowserContext* browser_context =
content::DownloadItemUtils::GetBrowserContext(item_);
if (!browser_context)
return false;

Profile* profile = Profile::FromBrowserContext(browser_context);
if (!profile)
return false;

int send_files_for_malware_check = profile->GetPrefs()->GetInteger(
prefs::kSafeBrowsingSendFilesForMalwareCheck);
if (send_files_for_malware_check !=
SendFilesForMalwareCheckValues::SEND_DOWNLOADS &&
send_files_for_malware_check !=
SendFilesForMalwareCheckValues::SEND_UPLOADS_AND_DOWNLOADS)
return false;

  // If there's no DM token, the upload will fail, so we can skip uploading now.
  return !policy::BrowserDMTokenStorage::Get()->RetrieveDMToken().empty();
}

void BinaryUploadService::FinishRequest(Request* request,
                                        Result result,
                                        DeepScanningClientResponse response) {
  RecordRequestMetrics(request, result, response);

  request->FinishRequest(result, response);
  active_requests_.erase(request);
  active_timers_.erase(request);
  active_uploads_.erase(request);
  received_malware_verdicts_.erase(request);
  received_dlp_verdicts_.erase(request);

  auto token_it = active_tokens_.find(request);
  if (token_it != active_tokens_.end()) {
    binary_fcm_service_->ClearCallbackForToken(token_it->second);
    active_tokens_.erase(token_it);
  }
}

BinaryUploadService::~BinaryUploadService() {}

BinaryUploadService::Request::~Request() {}

void BinaryUploadService::Request::set_dm_token(const std::string& token) {
  deep_scanning_request_.set_dm_token(token);
}

std::string MalwareVerdictToThreatType(
    MalwareDeepScanningVerdict::Verdict verdict) {
  switch (verdict) {
    case MalwareDeepScanningVerdict::CLEAN:
      return "SAFE";
    case MalwareDeepScanningVerdict::UWS:
      return "POTENTIALLY_UNWANTED";
    case MalwareDeepScanningVerdict::MALWARE:
      return "DANGEROUS";
    case MalwareDeepScanningVerdict::VERDICT_UNSPECIFIED:
    default:
      return "UNKNOWN";
  }
}

void CheckClientDownloadRequest::NotifyRequestFinished(
    DownloadCheckResult result,
    DownloadCheckResultReason reason) {
  DCHECK_CURRENTLY_ON(BrowserThread::UI);
  weakptr_factory_.InvalidateWeakPtrs();

  DVLOG(2) << "SafeBrowsing download verdict for: " << item_->DebugString(true)
           << " verdict:" << reason << " result:" << static_cast<int>(result);

  item_->RemoveObserver(this);
}

bool BinaryUploadService::ShouldBlockFileSize(size_t file_size) {
  int block_large_file_transfer = g_browser_process->local_state()->GetInteger(
      prefs::kBlockLargeFileTransfer);
  if (block_large_file_transfer !=
          BlockLargeFileTransferValues::BLOCK_LARGE_DOWNLOADS &&
      block_large_file_transfer !=
          BlockLargeFileTransferValues::BLOCK_LARGE_UPLOADS_AND_DOWNLOADS)
    return false;

  return (file_size > kMaxUploadSizeBytes);
}

CheckClientDownloadRequest::GetWeakPtr() {
  return weakptr_factory_.GetWeakPtr();
}

BinaryUploadService::BinaryUploadService(
    scoped_refptr<network::SharedURLLoaderFactory> url_loader_factory,
    Profile* profile)
    : url_loader_factory_(url_loader_factory),
      binary_fcm_service_(BinaryFCMService::Create(profile)),
      weakptr_factory_(this) {}

void BinaryUploadService::OnGetInstanceID(Request* request,
                                          const std::string& instance_id) {
  if (!IsActive(request))
    return;

  if (instance_id == BinaryFCMService::kInvalidId) {
    FinishRequest(request, Result::FAILED_TO_GET_TOKEN,
                  DeepScanningClientResponse());
    return;
  }

  request->set_fcm_token(instance_id);
  request->GetRequestData(base::BindOnce(&BinaryUploadService::OnGetRequestData,
                                         weakptr_factory_.GetWeakPtr(),
                                         request));
}

void BinaryUploadService::ValidateDataUploadRequestCallback(
    BinaryUploadService::Result result,
    DeepScanningClientResponse response) {
  pending_validate_data_upload_request_ = false;
  can_upload_data_ = result == BinaryUploadService::Result::SUCCESS;
  RunAuthorizationCallbacks();
}

GURL BinaryUploadService::GetUploadUrl() {
  return GURL(kSbBinaryUploadUrl);
}

void BinaryUploadService::Request::set_request_token(const std::string& token) {
  deep_scanning_request_.set_request_token(token);
}

void CheckClientDownloadRequest::UploadBinary(
DownloadCheckResult result,
DownloadCheckResultReason reason) {
saved_result_ = result;
saved_reason_ = reason;

bool upload_for_dlp = ShouldUploadForDlpScan();
bool upload_for_malware = ShouldUploadForMalwareScan(reason);
auto request = std::make_unique<DownloadItemRequest>(
item_, /*read_immediately=*/true,
base::BindOnce(&CheckClientDownloadRequest::OnDeepScanningComplete,
weakptr_factory_.GetWeakPtr()));

Profile* profile = Profile::FromBrowserContext(GetBrowserContext());

if (upload_for_dlp) {
DlpDeepScanningClientRequest dlp_request;
dlp_request.set_content_source(DlpDeepScanningClientRequest::FILE_DOWNLOAD);
request->set_request_dlp_scan(std::move(dlp_request));
}

if (upload_for_malware) {
MalwareDeepScanningClientRequest malware_request;
malware_request.set_population(
MalwareDeepScanningClientRequest::POPULATION_ENTERPRISE);
malware_request.set_download_token(
DownloadProtectionService::GetDownloadPingToken(item_));
request->set_request_malware_scan(std::move(malware_request));
}

  request->set_dm_token(
      policy::BrowserDMTokenStorage::Get()->RetrieveDMToken());

service()->UploadForDeepScanning(profile, std::move(request));
}

void BinaryUploadService::OnGetRequestData(Request* request,
                                           Result result,
                                           const Request::Data& data) {
  if (!IsActive(request))
    return;

  if (result != Result::SUCCESS) {
    FinishRequest(request, result, DeepScanningClientResponse());
    return;
  }

  net::NetworkTrafficAnnotationTag traffic_annotation =
      net::DefineNetworkTrafficAnnotation("safe_browsing_binary_upload", R"(
        semantics {
          sender: "Safe Browsing Download Protection"
          description:
            "For users with the enterprise policy "
            "SendFilesForMalwareCheck set, when a file is "
            "downloaded, Chrome will upload that file to Safe Browsing for "
            "detailed scanning."
          trigger:
            "The browser will upload the file to Google when "
            "the user downloads a file, and the enterprise policy "
            "SendFilesForMalwareCheck is set."
          data:
            "The downloaded file."
          destination: GOOGLE_OWNED_SERVICE
        }
        policy {
          cookies_allowed: YES
          cookies_store: "Safe Browsing Cookie Store"
          setting: "This is disabled by default an can only be enabled by "
            "policy."
          chrome_policy {
            SendFilesForMalwareCheck {
              SendFilesForMalwareCheck: 0
            }
          }
          chrome_policy {
            SendFilesForMalwareCheck {
              SendFilesForMalwareCheck: 1
            }
          }
        }
        comments: "Setting SendFilesForMalwareCheck to 0 (Do not scan "
          "downloads) or 1 (Forbid the scanning of downloads) will disable "
          "this feature"
        )");

  std::string metadata;
  request->deep_scanning_request().SerializeToString(&metadata);
  base::Base64Encode(metadata, &metadata);

  auto upload_request = MultipartUploadRequest::Create(
      url_loader_factory_, GURL(kSbBinaryUploadUrl), metadata, data.contents,
      traffic_annotation,
      base::BindOnce(&BinaryUploadService::OnUploadComplete,
                     weakptr_factory_.GetWeakPtr(), request));
  upload_request->Start();
  active_uploads_[request] = std::move(upload_request);
}

bool CheckClientDownloadRequest::MaybeReturnAsynchronousVerdict(
    DownloadCheckResultReason reason) {
  if (ShouldUploadBinary(reason)) {
    callback_.Run(DownloadCheckResult::ASYNC_SCANNING);
    return true;
  }

  return false;
}

BinaryUploadService::Request::Request(Callback callback)
    : callback_(std::move(callback)) {}

void BinaryUploadService::OnTimeout(Request* request) {
  if (IsActive(request))
    FinishRequest(request, Result::TIMEOUT, DeepScanningClientResponse());
}

void BinaryUploadService::MaybeFinishRequest(Request* request) {
  bool requested_dlp_scan_response =
      request->deep_scanning_request().has_dlp_scan_request();
  auto received_dlp_response = received_dlp_verdicts_.find(request);
  if (requested_dlp_scan_response &&
      received_dlp_response == received_dlp_verdicts_.end()) {
    return;
  }

  bool requested_malware_scan_response =
      request->deep_scanning_request().has_malware_scan_request();
  auto received_malware_response = received_malware_verdicts_.find(request);
  if (requested_malware_scan_response &&
      received_malware_response == received_malware_verdicts_.end()) {
    return;
  }

  DeepScanningClientResponse response;
  if (requested_dlp_scan_response) {
    response.set_allocated_dlp_scan_verdict(
        received_dlp_response->second.release());
  }

  if (requested_malware_scan_response) {
    response.set_allocated_malware_scan_verdict(
        received_malware_response->second.release());
  }

  FinishRequest(request, Result::SUCCESS, std::move(response));
}

inline void ValidateDataUploadRequest::GetRequestData(DataCallback callback) {
  std::move(callback).Run(BinaryUploadService::Result::SUCCESS,
                          BinaryUploadService::Request::Data());
}

void CheckClientDownloadRequest::MaybeStorePingsForDownload(
    DownloadCheckResult result,
    bool upload_requested,
    const std::string& request_data,
    const std::string& response_body) {
  DownloadFeedbackService::MaybeStorePingsForDownload(
      result, upload_requested, item_, request_data, response_body);
}
