sp<MetaData> AMRExtractor::getMetaData() {
    sp<MetaData> meta = new MetaData;

 if (mInitCheck != OK) {
 return meta;
 }

    meta->setCString(kKeyMIMEType, mIsWide ? "audio/amr-wb" : "audio/amr");

 return meta;
}

status_t NuMediaExtractor::unselectTrack(size_t index) {
 Mutex::Autolock autoLock(mLock);

 if (mImpl == NULL) {
 return -EINVAL;
 }

 if (index >= mImpl->countTracks()) {
 return -ERANGE;
 }

 size_t i;
 for (i = 0; i < mSelectedTracks.size(); ++i) {
 TrackInfo *info = &mSelectedTracks.editItemAt(i);

 if (info->mTrackIndex == index) {
 break;
 }
 }

 if (i == mSelectedTracks.size()) {
 return OK;
 }

 TrackInfo *info = &mSelectedTracks.editItemAt(i);

 if (info->mSample != NULL) {
        info->mSample->release();
        info->mSample = NULL;

        info->mSampleTimeUs = -1ll;
 }

    CHECK_EQ((status_t)OK, info->mSource->stop());

    mSelectedTracks.removeAt(i);

 return OK;
}

AMRSource::~AMRSource() {
 if (mStarted) {
        stop();
 }
}

NuMediaExtractor::~NuMediaExtractor() {
    releaseTrackSamples();

 for (size_t i = 0; i < mSelectedTracks.size(); ++i) {
 TrackInfo *info = &mSelectedTracks.editItemAt(i);

        CHECK_EQ((status_t)OK, info->mSource->stop());
 }

    mSelectedTracks.clear();
 if (mDataSource != NULL) {
        mDataSource->close();
 }
}

static status_t getFrameSizeByOffset(const sp<DataSource> &source,
 off64_t offset, bool isWide, size_t *frameSize) {
 uint8_t header;
 ssize_t count = source->readAt(offset, &header, 1);
 if (count == 0) {
 return ERROR_END_OF_STREAM;
 } else if (count < 0) {
 return ERROR_IO;
 }

 unsigned FT = (header >> 3) & 0x0f;

 *frameSize = getFrameSize(isWide, FT);
 if (*frameSize == 0) {
 return ERROR_MALFORMED;
 }
 return OK;
}

void NuMediaExtractor::releaseTrackSamples() {
 for (size_t i = 0; i < mSelectedTracks.size(); ++i) {
 TrackInfo *info = &mSelectedTracks.editItemAt(i);

 if (info->mSample != NULL) {
            info->mSample->release();
            info->mSample = NULL;

            info->mSampleTimeUs = -1ll;
 }
 }
}

size_t AMRExtractor::countTracks() {
 return mInitCheck == OK ? 1 : 0;
}

sp<MetaData> AMRSource::getFormat() {
 return mMeta;
}

status_t NuMediaExtractor::getSampleMeta(sp<MetaData> *sampleMeta) {
 Mutex::Autolock autoLock(mLock);

 *sampleMeta = NULL;

 ssize_t minIndex = fetchTrackSamples();

 if (minIndex < 0) {
 return ERROR_END_OF_STREAM;
 }

 TrackInfo *info = &mSelectedTracks.editItemAt(minIndex);
 *sampleMeta = info->mSample->meta_data();

 return OK;
}

ssize_t NuMediaExtractor::fetchTrackSamples(
 int64_t seekTimeUs, MediaSource::ReadOptions::SeekMode mode) {
 TrackInfo *minInfo = NULL;
 ssize_t minIndex = -1;

 for (size_t i = 0; i < mSelectedTracks.size(); ++i) {
 TrackInfo *info = &mSelectedTracks.editItemAt(i);

 if (seekTimeUs >= 0ll) {
            info->mFinalResult = OK;

 if (info->mSample != NULL) {
                info->mSample->release();
                info->mSample = NULL;
                info->mSampleTimeUs = -1ll;
 }
 } else if (info->mFinalResult != OK) {
 continue;
 }

 if (info->mSample == NULL) {
 MediaSource::ReadOptions options;
 if (seekTimeUs >= 0ll) {
                options.setSeekTo(seekTimeUs, mode);
 }
 status_t err = info->mSource->read(&info->mSample, &options);

 if (err != OK) {
                CHECK(info->mSample == NULL);

                info->mFinalResult = err;

 if (info->mFinalResult != ERROR_END_OF_STREAM) {
                    ALOGW("read on track %zu failed with error %d",
                          info->mTrackIndex, err);
 }

                info->mSampleTimeUs = -1ll;
 continue;
 } else {
                CHECK(info->mSample != NULL);
                CHECK(info->mSample->meta_data()->findInt64(
                            kKeyTime, &info->mSampleTimeUs));
 }
 }

 if (minInfo == NULL  || info->mSampleTimeUs < minInfo->mSampleTimeUs) {
            minInfo = info;
            minIndex = i;
 }
 }

 return minIndex;
}

AMRExtractor::~AMRExtractor() {
}

NuMediaExtractor::NuMediaExtractor()
 : mIsWidevineExtractor(false),
      mTotalBitrate(-1ll),
      mDurationUs(-1ll) {
}

status_t NuMediaExtractor::getTrackFormat(
 size_t index, sp<AMessage> *format, uint32_t flags) const {
 Mutex::Autolock autoLock(mLock);

 *format = NULL;

 if (mImpl == NULL) {
 return -EINVAL;
 }

 if (index >= mImpl->countTracks()) {
 return -ERANGE;
 }

    sp<MetaData> meta = mImpl->getTrackMetaData(index, flags);
 int32_t trackID;
 if (meta != NULL && !meta->findInt32(kKeyTrackID, &trackID)) {
        meta->setInt32(kKeyTrackID, (int32_t)index + 1);
 }
 return convertMetaDataToMessage(meta, format);
}

status_t AMRSource::stop() {
    CHECK(mStarted);

 delete mGroup;
    mGroup = NULL;

    mStarted = false;
 return OK;
}

status_t AMRSource::read(
MediaBuffer **out, const ReadOptions *options) {
*out = NULL;


int64_t seekTimeUs;
ReadOptions::SeekMode mode;
    if (options && options->getSeekTo(&seekTimeUs, &mode)) {
size_t size;
int64_t seekFrame = seekTimeUs / 20000ll;  // 20ms per frame.
mCurrentTimeUs = seekFrame * 20000ll;

size_t index = seekFrame < 0 ? 0 : seekFrame / 50;
if (index >= mOffsetTableLength) {
index = mOffsetTableLength - 1;
}

mOffset = mOffsetTable[index] + (mIsWide ? 9 : 6);

for (size_t i = 0; i< seekFrame - index * 50; i++) {
status_t err;
if ((err = getFrameSizeByOffset(mDataSource, mOffset,
mIsWide, &size)) != OK) {
return err;
}
mOffset += size;
}
}

uint8_t header;
ssize_t n = mDataSource->readAt(mOffset, &header, 1);

if (n < 1) {
return ERROR_END_OF_STREAM;
}

if (header & 0x83) {
// Padding bits must be 0.

ALOGE("padding bits must be 0, header is 0x%02x", header);

return ERROR_MALFORMED;
}

unsigned FT = (header >> 3) & 0x0f;

size_t frameSize = getFrameSize(mIsWide, FT);
if (frameSize == 0) {
return ERROR_MALFORMED;
}

MediaBuffer *buffer;
status_t err = mGroup->acquire_buffer(&buffer);
if (err != OK) {
return err;
}

n = mDataSource->readAt(mOffset, buffer->data(), frameSize);

if (n != (ssize_t)frameSize) {
buffer->release();
buffer = NULL;

if (n < 0) {
return ERROR_IO;
} else {
// only partial frame is available, treat it as EOS.
mOffset += n;
return ERROR_END_OF_STREAM;
}
}

buffer->set_range(0, frameSize);
buffer->meta_data()->setInt64(kKeyTime, mCurrentTimeUs);
buffer->meta_data()->setInt32(kKeyIsSyncFrame, 1);

mOffset += frameSize;
mCurrentTimeUs += 20000; // Each frame is 20ms

*out = buffer;

return OK;
}

status_t NuMediaExtractor::getSampleTrackIndex(size_t *trackIndex) {
 Mutex::Autolock autoLock(mLock);

 ssize_t minIndex = fetchTrackSamples();

 if (minIndex < 0) {
 return ERROR_END_OF_STREAM;
 }

 TrackInfo *info = &mSelectedTracks.editItemAt(minIndex);
 *trackIndex = info->mTrackIndex;

 return OK;
}

status_t AMRSource::start(MetaData * /* params */) {
    CHECK(!mStarted);

    mOffset = mIsWide ? 9 : 6;
    mCurrentTimeUs = 0;
    mGroup = new MediaBufferGroup;
    mGroup->add_buffer(new MediaBuffer(128));
    mStarted = true;

 return OK;
}

status_t NuMediaExtractor::selectTrack(size_t index) {
 Mutex::Autolock autoLock(mLock);

 if (mImpl == NULL) {
 return -EINVAL;
 }

 if (index >= mImpl->countTracks()) {
 return -ERANGE;
 }

 for (size_t i = 0; i < mSelectedTracks.size(); ++i) {
 TrackInfo *info = &mSelectedTracks.editItemAt(i);

 if (info->mTrackIndex == index) {
 return OK;
 }
 }

    sp<IMediaSource> source = mImpl->getTrack(index);

 status_t ret = source->start();
 if (ret != OK) {
 return ret;
 }

    mSelectedTracks.push();
 TrackInfo *info = &mSelectedTracks.editItemAt(mSelectedTracks.size() - 1);

    info->mSource = source;
    info->mTrackIndex = index;
    info->mFinalResult = OK;
    info->mSample = NULL;
    info->mSampleTimeUs = -1ll;
    info->mTrackFlags = 0;

 const char *mime;
    CHECK(source->getFormat()->findCString(kKeyMIMEType, &mime));

 if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_VORBIS)) {
        info->mTrackFlags |= kIsVorbis;
 }

 return OK;
}

status_t NuMediaExtractor::getSampleTime(int64_t *sampleTimeUs) {
 Mutex::Autolock autoLock(mLock);

 ssize_t minIndex = fetchTrackSamples();

 if (minIndex < 0) {
 return ERROR_END_OF_STREAM;
 }

 TrackInfo *info = &mSelectedTracks.editItemAt(minIndex);
 *sampleTimeUs = info->mSampleTimeUs;

 return OK;
}

status_t NuMediaExtractor::setDataSource(const sp<DataSource> &source) {
 Mutex::Autolock autoLock(mLock);

 if (mImpl != NULL) {
 return -EINVAL;
 }

 status_t err = source->initCheck();
 if (err != OK) {
 return err;
 }

    mImpl = MediaExtractor::Create(source);

 if (mImpl == NULL) {
 return ERROR_UNSUPPORTED;
 }

    err = updateDurationAndBitrate();
 if (err == OK) {
        mDataSource = source;
 }

 return err;
}

sp<IMediaSource> AMRExtractor::getTrack(size_t index) {
 if (mInitCheck != OK || index != 0) {
 return NULL;
 }

 return new AMRSource(mDataSource, mMeta, mIsWide,
            mOffsetTable, mOffsetTableLength);
}

static size_t getFrameSize(bool isWide, unsigned FT) {
 static const size_t kFrameSizeNB[16] = {
 95, 103, 118, 134, 148, 159, 204, 244,
 39, 43, 38, 37, // SID
 0, 0, 0, // future use
 0 // no data
 };
 static const size_t kFrameSizeWB[16] = {
 132, 177, 253, 285, 317, 365, 397, 461, 477,
 40, // SID
 0, 0, 0, 0, // future use
 0, // speech lost
 0 // no data
 };

 if (FT > 15 || (isWide && FT > 9 && FT < 14) || (!isWide && FT > 11 && FT < 15)) {
        ALOGE("illegal AMR frame type %d", FT);
 return 0;
 }

 size_t frameSize = isWide ? kFrameSizeWB[FT] : kFrameSizeNB[FT];

    frameSize = (frameSize + 7) / 8 + 1;

 return frameSize;
}

status_t NuMediaExtractor::appendVorbisNumPageSamples(TrackInfo *info, const sp<ABuffer> &buffer) {
 int32_t numPageSamples;
 if (!info->mSample->meta_data()->findInt32(
            kKeyValidSamples, &numPageSamples)) {
        numPageSamples = -1;
 }

    memcpy((uint8_t *)buffer->data() + info->mSample->range_length(),
 &numPageSamples,
 sizeof(numPageSamples));

 uint32_t type;
 const void *data;
 size_t size, size2;
 if (info->mSample->meta_data()->findData(kKeyEncryptedSizes, &type, &data, &size)) {
 if (SIZE_MAX - size < sizeof(int32_t)) {
 return -ENOMEM;
 }

 size_t newSize = size + sizeof(int32_t);
        sp<ABuffer> abuf = new ABuffer(newSize);
 uint8_t *adata = static_cast<uint8_t *>(abuf->data());
 if (adata == NULL) {
 return -ENOMEM;
 }

 int32_t zero = 0;
        memcpy(adata, data, size);
        memcpy(adata + size, &zero, sizeof(zero));
        info->mSample->meta_data()->setData(kKeyEncryptedSizes, type, adata, newSize);

 if (info->mSample->meta_data()->findData(kKeyPlainSizes, &type, &data, &size2)) {
 if (size2 != size) {
 return ERROR_MALFORMED;
 }
            memcpy(adata, data, size);
 } else {
            memset(adata, 0, size);
 }
 int32_t int32Size = sizeof(numPageSamples);
        memcpy(adata + size, &int32Size, sizeof(int32Size));
        info->mSample->meta_data()->setData(kKeyPlainSizes, type, adata, newSize);
 }

 return OK;
}

bool NuMediaExtractor::getCachedDuration(
 int64_t *durationUs, bool *eos) const {
 Mutex::Autolock autoLock(mLock);

 int64_t bitrate;
 if (mIsWidevineExtractor) {
        sp<WVMExtractor> wvmExtractor =
 static_cast<WVMExtractor *>(mImpl.get());

 status_t finalStatus;
 *durationUs = wvmExtractor->getCachedDurationUs(&finalStatus);
 *eos = (finalStatus != OK);
 return true;
 } else if ((mDataSource->flags() & DataSource::kIsCachingDataSource)
 && getTotalBitrate(&bitrate)) {
        sp<NuCachedSource2> cachedSource =
 static_cast<NuCachedSource2 *>(mDataSource.get());

 status_t finalStatus;
 size_t cachedDataRemaining =
            cachedSource->approxDataRemaining(&finalStatus);

 *durationUs = cachedDataRemaining * 8000000ll / bitrate;
 *eos = (finalStatus != OK);
 return true;
 }

 return false;
}

sp<MetaData> AMRExtractor::getTrackMetaData(size_t index, uint32_t /* flags */) {
 if (mInitCheck != OK || index != 0) {
 return NULL;
 }

 return mMeta;
}

bool NuMediaExtractor::getTotalBitrate(int64_t *bitrate) const {
if (mTotalBitrate >= 0) {
*bitrate = mTotalBitrate;
return true;

}

off64_t size;
    if (mDurationUs >= 0 && mDataSource->getSize(&size) == OK) {
*bitrate = size * 8000000ll / mDurationUs;  // in bits/sec
return true;
}

return false;
}

status_t NuMediaExtractor::getFileFormat(sp<AMessage> *format) const {
 Mutex::Autolock autoLock(mLock);

 *format = NULL;

 if (mImpl == NULL) {
 return -EINVAL;
 }

    sp<MetaData> meta = mImpl->getMetaData();

 const char *mime;
    CHECK(meta->findCString(kKeyMIMEType, &mime));
 *format = new AMessage();
 (*format)->setString("mime", mime);

 uint32_t type;
 const void *pssh;
 size_t psshsize;
 if (meta->findData(kKeyPssh, &type, &pssh, &psshsize)) {
        sp<ABuffer> buf = new ABuffer(psshsize);
        memcpy(buf->data(), pssh, psshsize);
 (*format)->setBuffer("pssh", buf);
 }

 return OK;
}

size_t NuMediaExtractor::countTracks() const {
 Mutex::Autolock autoLock(mLock);

 return mImpl == NULL ? 0 : mImpl->countTracks();
}
