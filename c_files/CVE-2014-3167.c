const LayoutSVGRoot* SVGLayoutSupport::findTreeRootObject(const LayoutObject* start)
{
    while (start && !start->isSVGRoot())
        start = start->parent();

    ASSERT(start);
    ASSERT(start->isSVGRoot());
    return toLayoutSVGRoot(start);
}

AffineTransform SVGLayoutSupport::deprecatedCalculateTransformToLayer(const LayoutObject* layoutObject)
{
    AffineTransform transform;
    while (layoutObject) {
        transform = layoutObject->localToSVGParentTransform() * transform;
        if (layoutObject->isSVGRoot())
            break;
        layoutObject = layoutObject->parent();
    }

    PaintLayer* layer = layoutObject ? layoutObject->enclosingLayer() : 0;
    while (layer && layer->isAllowedToQueryCompositingState()) {
        if (layer->compositingState() != NotComposited)
            break;

        if (TransformationMatrix* layerTransform = layer->transform())
            transform = layerTransform->toAffineTransform() * transform;

        layer = layer->parent();
    }

    return transform;
}

AffineTransform& AffineTransform::preMultiply(const AffineTransform& other)
{
    if (other.isIdentityOrTranslation()) {
        if (other.m_transform[4] || other.m_transform[5]) {
            m_transform[4] += other.m_transform[4];
            m_transform[5] += other.m_transform[5];
        }
        return *this;
    }

    AffineTransform trans;
    doMultiply(other, *this, &trans);
    setMatrix(trans.m_transform);

    return *this;
}

IntSize AffineTransform::mapSize(const IntSize& size) const
{
    double width2 = size.width() * xScale();
    double height2 = size.height() * yScale();

    return IntSize(lround(width2), lround(height2));
}

FloatPoint LayoutSVGResourceMarker::referencePoint() const
{
    SVGMarkerElement* marker = toSVGMarkerElement(element());
    ASSERT(marker);

    SVGLengthContext lengthContext(marker);
    return FloatPoint(marker->refX()->currentValue()->value(lengthContext), marker->refY()->currentValue()->value(lengthContext));
}

AffineTransform AffineTransform::inverse() const
{
    double determinant = det();
    if (determinant == 0.0)
        return AffineTransform();

    AffineTransform result;
    if (isIdentityOrTranslation()) {
        result.m_transform[4] = -m_transform[4];
        result.m_transform[5] = -m_transform[5];
        return result;
    }

    result.m_transform[0] = m_transform[3] / determinant;
    result.m_transform[1] = -m_transform[1] / determinant;
    result.m_transform[2] = -m_transform[2] / determinant;
    result.m_transform[3] = m_transform[0] / determinant;
    result.m_transform[4] = (m_transform[2] * m_transform[5]
                           - m_transform[3] * m_transform[4]) / determinant;
    result.m_transform[5] = (m_transform[1] * m_transform[4]
                           - m_transform[0] * m_transform[5]) / determinant;

    return result;
}

void LayoutSVGViewportContainer::calcViewport()
{
    SVGElement* element = this->element();
    ASSERT(element);
    if (!isSVGSVGElement(*element))
        return;
    SVGSVGElement* svg = toSVGSVGElement(element);
    FloatRect oldViewport = m_viewport;

    SVGLengthContext lengthContext(element);
    m_viewport = FloatRect(svg->x()->currentValue()->value(lengthContext), svg->y()->currentValue()->value(lengthContext), svg->width()->currentValue()->value(lengthContext), svg->height()->currentValue()->value(lengthContext));

    if (oldViewport != m_viewport) {
        setNeedsBoundariesUpdate();
        setNeedsTransformUpdate();
     }
 }

AffineTransform& AffineTransform::translate(double tx, double ty)
{
    if (isIdentityOrTranslation()) {
        m_transform[4] += tx;
        m_transform[5] += ty;
        return *this;
    }

    m_transform[4] += tx * m_transform[0] + ty * m_transform[2];
    m_transform[5] += tx * m_transform[1] + ty * m_transform[3];
    return *this;
}

LayoutObject* SVGLayoutSupport::findClosestLayoutSVGText(LayoutObject* layoutObject, const FloatPoint& point)
{
    return searchTreeForFindClosestLayoutSVGText(layoutObject, point).candidateLayoutObject;
}

void LayoutSVGContainer::styleDidChange(StyleDifference diff, const ComputedStyle* oldStyle)
{
    LayoutSVGModelObject::styleDidChange(diff, oldStyle);

    bool hadIsolation = oldStyle && !isSVGHiddenContainer() && SVGLayoutSupport::willIsolateBlendingDescendantsForStyle(*oldStyle);
    bool isolationChanged = hadIsolation == !SVGLayoutSupport::willIsolateBlendingDescendantsForObject(this);

    if (!parent() || !isolationChanged)
        return;

    if (hasNonIsolatedBlendingDescendants())
        parent()->descendantIsolationRequirementsChanged(SVGLayoutSupport::willIsolateBlendingDescendantsForObject(this) ? DescendantIsolationNeedsUpdate : DescendantIsolationRequired);
}

SubtreeContentTransformScope::SubtreeContentTransformScope(const AffineTransform& subtreeContentTransformation)
    : m_savedContentTransformation(s_currentContentTransformation)
{
    AffineTransform contentTransformation = subtreeContentTransformation * AffineTransform(s_currentContentTransformation);
    contentTransformation.copyTransformTo(s_currentContentTransformation);
}

LayoutRect SVGLayoutSupport::clippedOverflowRectForPaintInvalidation(const LayoutObject& object, const LayoutBoxModelObject& paintInvalidationContainer)
{
    LayoutRect rect;
    mapToVisualRectInAncestorSpace(object, &paintInvalidationContainer, localOverflowRectForPaintInvalidation(object), rect);
    return rect;
}

void LayoutSVGContainer::addOutlineRects(Vector<LayoutRect>& rects, const LayoutPoint&, IncludeBlockVisualOverflowOrNot) const
{
    rects.append(LayoutRect(paintInvalidationRectInLocalSVGCoordinates()));
}

FloatRect LayoutSVGResourceMarker::markerBoundaries(const AffineTransform& markerTransformation) const
{
    FloatRect coordinates = LayoutSVGContainer::paintInvalidationRectInLocalSVGCoordinates();

    coordinates = localToSVGParentTransform().mapRect(coordinates);

    return markerTransformation.mapRect(coordinates);
}

 static inline bool compareCandidateDistance(const SearchCandidate& r1, const SearchCandidate& r2)
{
    return r1.candidateDistance < r2.candidateDistance;
}

bool SVGLayoutSupport::layoutSizeOfNearestViewportChanged(const LayoutObject* start)
{
    for (; start; start = start->parent()) {
        if (start->isSVGRoot())
            return toLayoutSVGRoot(start)->isLayoutSizeChanged();
        if (start->isSVGViewportContainer())
            return toLayoutSVGViewportContainer(start)->isLayoutSizeChanged();
    }
    ASSERT_NOT_REACHED();
    return false;
}

bool SVGLayoutSupport::mapToVisualRectInAncestorSpace(const LayoutObject& object, const LayoutBoxModelObject* ancestor, const FloatRect& localPaintInvalidationRect, LayoutRect& resultRect, VisualRectFlags visualRectFlags)
{
    AffineTransform rootBorderBoxTransform;
    const LayoutSVGRoot& svgRoot = computeTransformToSVGRoot(object, rootBorderBoxTransform);
    resultRect = transformPaintInvalidationRect(object, rootBorderBoxTransform, localPaintInvalidationRect);

    if (svgRoot.shouldApplyViewportClip()) {
        LayoutRect clipRect(svgRoot.pixelSnappedBorderBoxRect());
        if (visualRectFlags & EdgeInclusive) {
            if (!resultRect.inclusiveIntersect(clipRect))
                return false;
        } else {
            resultRect.intersect(clipRect);
        }
    }
    return svgRoot.mapToVisualRectInAncestorSpace(ancestor, resultRect, visualRectFlags);
}

    SearchCandidate(LayoutObject* layoutObject, float distance)
        : candidateLayoutObject(layoutObject)
        , candidateDistance(distance)
    {
    }

void SVGLayoutSupport::intersectPaintInvalidationRectWithResources(const LayoutObject* layoutObject, FloatRect& paintInvalidationRect)
{
    ASSERT(layoutObject);

    SVGResources* resources = SVGResourcesCache::cachedResourcesForLayoutObject(layoutObject);
    if (!resources)
        return;

    if (LayoutSVGResourceFilter* filter = resources->filter())
        paintInvalidationRect = filter->resourceBoundingBox(layoutObject);

    if (LayoutSVGResourceClipper* clipper = resources->clipper())
        paintInvalidationRect.intersect(clipper->resourceBoundingBox(layoutObject));

    if (LayoutSVGResourceMasker* masker = resources->masker())
        paintInvalidationRect.intersect(masker->resourceBoundingBox(layoutObject));
}

static inline float distanceToChildLayoutObject(LayoutObject* child, const FloatPoint& point)
{
    const AffineTransform& localToParentTransform = child->localToSVGParentTransform();
    if (!localToParentTransform.isInvertible())
        return std::numeric_limits<float>::max();
    FloatPoint childLocalPoint = localToParentTransform.inverse().mapPoint(point);
    return child->objectBoundingBox().squaredDistanceTo(childLocalPoint);
}

const LayoutObject* SVGLayoutSupport::pushMappingToContainer(const LayoutObject* object, const LayoutBoxModelObject* ancestorToStopAt, LayoutGeometryMap& geometryMap)
{
    ASSERT_UNUSED(ancestorToStopAt, ancestorToStopAt != object);

    LayoutObject* parent = object->parent();

    if (parent->isSVGRoot()) {
        TransformationMatrix matrix(object->localToSVGParentTransform());
        matrix.multiply(toLayoutSVGRoot(parent)->localToBorderBoxTransform());
        geometryMap.push(object, matrix);
    } else {
        geometryMap.push(object, object->localToSVGParentTransform());
    }

    return parent;
}

void LayoutSVGContainer::paint(const PaintInfo& paintInfo, const LayoutPoint&) const
{
    SVGContainerPainter(*this).paint(paintInfo);
}

AffineTransform& AffineTransform::multiply(const AffineTransform& other)
{
    if (other.isIdentityOrTranslation()) {
        if (other.m_transform[4] || other.m_transform[5])
            translate(other.m_transform[4], other.m_transform[5]);
        return *this;
    }

    AffineTransform trans;
    doMultiply(*this, other, &trans);
    setMatrix(trans.m_transform);

    return *this;
}

static SearchCandidate searchTreeForFindClosestLayoutSVGText(LayoutObject* layoutObject, const FloatPoint& point)
{
    SearchCandidate closestText;
    Vector<SearchCandidate> candidates;

    for (LayoutObject* child = layoutObject->slowLastChild(); child; child = child->previousSibling()) {
        if (child->isSVGText()) {
            float distance = distanceToChildLayoutObject(child, point);
            if (distance >= closestText.candidateDistance)
                continue;
            candidates.clear();
            closestText.candidateLayoutObject = child;
            closestText.candidateDistance = distance;
            continue;
        }

        if (child->isSVGContainer() && !layoutObject->isSVGHiddenContainer()) {
            float distance = distanceToChildLayoutObject(child, point);
            if (distance > closestText.candidateDistance)
                continue;
            candidates.append(SearchCandidate(child, distance));
        }
    }

    if (closestText.candidateLayoutObject && candidates.isEmpty())
        return closestText;

    std::stable_sort(candidates.begin(), candidates.end(), compareCandidateDistance);

    for (const SearchCandidate& searchCandidate : candidates) {
        if (closestText.candidateDistance < searchCandidate.candidateDistance)
            break;
        LayoutObject* candidateLayoutObject = searchCandidate.candidateLayoutObject;
        FloatPoint candidateLocalPoint = candidateLayoutObject->localToSVGParentTransform().inverse().mapPoint(point);

        SearchCandidate candidateText = searchTreeForFindClosestLayoutSVGText(candidateLayoutObject, candidateLocalPoint);

        if (candidateText.candidateDistance < closestText.candidateDistance)
            closestText = candidateText;
    }

    return closestText;
}

void LayoutSVGResourceMarker::calcViewport()
{
    if (!selfNeedsLayout())
        return;

    SVGMarkerElement* marker = toSVGMarkerElement(element());
    ASSERT(marker);

    SVGLengthContext lengthContext(marker);
    float w = marker->markerWidth()->currentValue()->value(lengthContext);
    float h = marker->markerHeight()->currentValue()->value(lengthContext);
     m_viewport = FloatRect(0, 0, w, h);
 }

AffineTransform& AffineTransform::rotate(double a)
{
    return rotateRadians(deg2rad(a));
}

bool LayoutSVGResourceMarker::calculateLocalTransform()
{
// TODO(fs): Temporarily, needing a layout implies that the local transform
// has changed. This should be updated to be more precise and factor in the
// actual (relevant) changes to the computed user-space transform.
    return selfNeedsLayout();
}

bool SVGLayoutSupport::isOverflowHidden(const LayoutObject* object)
{
    ASSERT(!object->isDocumentElement());

    return object->style()->overflowX() == OverflowHidden || object->style()->overflowX() == OverflowScroll;
}

void AffineTransform::map(double x, double y, double& x2, double& y2) const
{
    x2 = (m_transform[0] * x + m_transform[2] * y + m_transform[4]);
    y2 = (m_transform[1] * x + m_transform[3] * y + m_transform[5]);
}

AffineTransform& AffineTransform::rotateFromVector(double x, double y)
{
    return rotateRadians(atan2(y, x));
}

AffineTransform& AffineTransform::rotateRadians(double a)
{
    double cosAngle = cos(a);
    double sinAngle = sin(a);
    AffineTransform rot(cosAngle, sinAngle, -sinAngle, cosAngle, 0, 0);

    multiply(rot);
    return *this;
}

 double AffineTransform::det() const
{
    return m_transform[0] * m_transform[3] - m_transform[1] * m_transform[2];
}

bool SVGLayoutSupport::isLayoutableTextNode(const LayoutObject* object)
{
    ASSERT(object->isText());
    return object->isSVGInlineText() && !toLayoutSVGInlineText(object)->hasEmptyText();
}

LayoutSVGContainer::LayoutSVGContainer(SVGElement* node)
    : LayoutSVGModelObject(node)
    , m_objectBoundingBoxValid(false)
    , m_needsBoundariesUpdate(true)
    , m_didScreenScaleFactorChange(false)
    , m_hasNonIsolatedBlendingDescendants(false)
    , m_hasNonIsolatedBlendingDescendantsDirty(false)
{
}

void SVGLayoutSupport::layoutResourcesIfNeeded(const LayoutObject* object)
{
    ASSERT(object);

    SVGResources* resources = SVGResourcesCache::cachedResourcesForLayoutObject(object);
    if (resources)
        resources->layoutIfNeeded();
}

bool SVGLayoutSupport::hasFilterResource(const LayoutObject& object)
{
    SVGResources* resources = SVGResourcesCache::cachedResourcesForLayoutObject(&object);
    return resources && resources->filter();
}

void AffineTransform::makeIdentity()
{
    setMatrix(1, 0, 0, 1, 0, 0);
}

void SVGLayoutSupport::applyStrokeStyleToStrokeData(StrokeData& strokeData, const ComputedStyle& style, const LayoutObject& object, float dashScaleFactor)
{
    ASSERT(object.node());
    ASSERT(object.node()->isSVGElement());

    const SVGComputedStyle& svgStyle = style.svgStyle();

    SVGLengthContext lengthContext(toSVGElement(object.node()));
    strokeData.setThickness(lengthContext.valueForLength(svgStyle.strokeWidth()));
    strokeData.setLineCap(svgStyle.capStyle());
    strokeData.setLineJoin(svgStyle.joinStyle());
    strokeData.setMiterLimit(svgStyle.strokeMiterLimit());

    DashArray dashArray = resolveSVGDashArray(*svgStyle.strokeDashArray(), style, lengthContext);
    float dashOffset = lengthContext.valueForLength(svgStyle.strokeDashOffset(), style);
    if (dashScaleFactor != 1) {
        ASSERT(dashScaleFactor >= 0);
        dashOffset *= dashScaleFactor;
        for (auto& dashItem : dashArray)
            dashItem *= dashScaleFactor;
    }
    strokeData.setLineDash(dashArray, dashOffset);
}

void LayoutSVGContainer::updateCachedBoundaries()
{
    SVGLayoutSupport::computeContainerBoundingBoxes(this, m_objectBoundingBox, m_objectBoundingBoxValid, m_strokeBoundingBox, m_paintInvalidationBoundingBox);
    SVGLayoutSupport::intersectPaintInvalidationRectWithResources(this, m_paintInvalidationBoundingBox);
}

bool SVGLayoutSupport::isIsolationRequired(const LayoutObject* object)
{
    return willIsolateBlendingDescendantsForObject(object) && object->hasNonIsolatedBlendingDescendants();
}

bool SVGLayoutSupport::willIsolateBlendingDescendantsForObject(const LayoutObject* object)
{
    if (object->isSVGHiddenContainer())
        return false;
    if (!object->isSVGRoot() && !object->isSVGContainer())
        return false;
    return willIsolateBlendingDescendantsForStyle(object->styleRef());
}

double AffineTransform::yScale() const
{
    return sqrt(m_transform[2] * m_transform[2] + m_transform[3] * m_transform[3]);
}

void LayoutSVGViewportContainer::determineIfLayoutSizeChanged()
{
    ASSERT(element());
    if (!isSVGSVGElement(*element()))
        return;

    m_isLayoutSizeChanged = toSVGSVGElement(element())->hasRelativeLengths() && selfNeedsLayout();
}

bool LayoutSVGResourceMarker::shouldPaint() const
{
    SVGMarkerElement* marker = toSVGMarkerElement(element());
    ASSERT(marker);
    return !marker->viewBox()->isSpecified()
        || !marker->viewBox()->currentValue()->isValid()
        || !marker->viewBox()->currentValue()->value().isEmpty();
}

bool LayoutSVGContainer::selfWillPaint() const
{
    return SVGLayoutSupport::hasFilterResource(*this);
}

AffineTransform::AffineTransform(double a, double b, double c, double d, double e, double f)
{
    setMatrix(a, b, c, d, e, f);
}

void SVGLayoutSupport::mapLocalToAncestor(const LayoutObject* object, const LayoutBoxModelObject* ancestor, TransformState& transformState)
{
    transformState.applyTransform(object->localToSVGParentTransform());

    LayoutObject* parent = object->parent();

    if (parent->isSVGRoot())
        transformState.applyTransform(toLayoutSVGRoot(parent)->localToBorderBoxTransform());

    MapCoordinatesFlags mode = UseTransforms;
    parent->mapLocalToAncestor(ancestor, transformState, mode);
}

AffineTransform& AffineTransform::skewY(double angle)
{
    return shear(0, tan(deg2rad(angle)));
}

bool LayoutSVGContainer::hasNonIsolatedBlendingDescendants() const
{
    if (m_hasNonIsolatedBlendingDescendantsDirty) {
        m_hasNonIsolatedBlendingDescendants = SVGLayoutSupport::computeHasNonIsolatedBlendingDescendants(this);
        m_hasNonIsolatedBlendingDescendantsDirty = false;
    }
    return m_hasNonIsolatedBlendingDescendants;
}

void AffineTransform::setMatrix(double a, double b, double c, double d, double e, double f)
{
    m_transform[0] = a;
    m_transform[1] = b;
    m_transform[2] = c;
    m_transform[3] = d;
    m_transform[4] = e;
    m_transform[5] = f;
}

float LayoutSVGResourceMarker::angle() const
{
    return toSVGMarkerElement(element())->orientAngle()->currentValue()->value();
}

LayoutSVGResourceMarker::~LayoutSVGResourceMarker()
{
}

bool SVGLayoutSupport::willIsolateBlendingDescendantsForStyle(const ComputedStyle& style)
{
    const SVGComputedStyle& svgStyle = style.svgStyle();

    return style.hasIsolation() || style.opacity() < 1 || style.hasBlendMode()
        || style.hasFilter() || svgStyle.hasMasker() || svgStyle.hasClipper();
}

AffineTransform& AffineTransform::flipX()
{
    return scale(-1, 1);
}

void LayoutSVGResourceMarker::removeAllClientsFromCache(bool markForInvalidation)
{
    markAllClientsForInvalidation(markForInvalidation ? LayoutAndBoundariesInvalidation : ParentOnlyInvalidation);
}

AffineTransform& AffineTransform::skewX(double angle)
{
    return shear(tan(deg2rad(angle)), 0);
}

inline void doMultiply(const AffineTransform& t1, const AffineTransform& t2, AffineTransform* res)
{
    res->setA(t1.a() * t2.a() + t1.c() * t2.b());
    res->setB(t1.b() * t2.a() + t1.d() * t2.b());
    res->setC(t1.a() * t2.c() + t1.c() * t2.d());
    res->setD(t1.b() * t2.c() + t1.d() * t2.d());
    res->setE(t1.a() * t2.e() + t1.c() * t2.f() + t1.e());
    res->setF(t1.b() * t2.e() + t1.d() * t2.f() + t1.f());
}

void LayoutSVGViewportContainer::paint(const PaintInfo& paintInfo, const LayoutPoint& paintOffset) const
{
    SVGContainerPainter(*this).paint(paintInfo);
}

    SearchCandidate()
        : candidateLayoutObject(nullptr)
        , candidateDistance(std::numeric_limits<float>::max())
    {
    }

double AffineTransform::xScale() const
{
    return sqrt(m_transform[0] * m_transform[0] + m_transform[1] * m_transform[1]);
}

bool AffineTransform::isIdentity() const
{
    return (m_transform[0] == 1 && m_transform[1] == 0
         && m_transform[2] == 0 && m_transform[3] == 1
          && m_transform[4] == 0 && m_transform[5] == 0);
 }

AffineTransform& AffineTransform::scale(double sx, double sy)
{
    m_transform[0] *= sx;
    m_transform[1] *= sx;
    m_transform[2] *= sy;
    m_transform[3] *= sy;
    return *this;
}

void LayoutSVGResourceMarker::layout()
{
    ASSERT(needsLayout());
    if (m_isInLayout)
        return;

    TemporaryChange<bool> inLayoutChange(m_isInLayout, true);

    LayoutSVGContainer::layout();

    clearInvalidationMask();
}

void LayoutSVGContainer::descendantIsolationRequirementsChanged(DescendantIsolationState state)
{
    switch (state) {
    case DescendantIsolationRequired:
        m_hasNonIsolatedBlendingDescendants = true;
        m_hasNonIsolatedBlendingDescendantsDirty = false;
        break;
    case DescendantIsolationNeedsUpdate:
        if (m_hasNonIsolatedBlendingDescendantsDirty)
            return;
        m_hasNonIsolatedBlendingDescendantsDirty = true;
        break;
    }
    if (SVGLayoutSupport::willIsolateBlendingDescendantsForObject(this))
        return;
    if (parent())
        parent()->descendantIsolationRequirementsChanged(state);
}

void LayoutSVGContainer::removeChild(LayoutObject* child)
{
    SVGResourcesCache::clientWillBeRemovedFromTree(child);
    LayoutSVGModelObject::removeChild(child);

    bool hadNonIsolatedDescendants = (child->isBlendingAllowed() && child->style()->hasBlendMode()) || child->hasNonIsolatedBlendingDescendants();
    if (hadNonIsolatedDescendants)
        descendantIsolationRequirementsChanged(DescendantIsolationNeedsUpdate);
}

AffineTransform& AffineTransform::skew(double angleX, double angleY)
{
    return shear(tan(deg2rad(angleX)), tan(deg2rad(angleY)));
}

const AffineTransform& LayoutSVGResourceMarker::localToSVGParentTransform() const
{
    m_localToParentTransform = AffineTransform::translation(m_viewport.x(), m_viewport.y()) * viewportTransform();
    return m_localToParentTransform;
}

void SVGLayoutSupport::layoutChildren(
    LayoutObject* firstChild, bool forceLayout, bool screenScalingFactorChanged, bool layoutSizeChanged)
{
    for (LayoutObject* child = firstChild; child; child = child->nextSibling()) {
        bool forceChildLayout = forceLayout;

        if (screenScalingFactorChanged) {
            if (child->isSVGText())
                toLayoutSVGText(child)->setNeedsTextMetricsUpdate();
            forceChildLayout = true;
        }

        if (layoutSizeChanged) {
            if (SVGElement* element = child->node()->isSVGElement() ? toSVGElement(child->node()) : 0) {
                if (element->hasRelativeLengths()) {
                    if (child->isSVGShape()) {
                        toLayoutSVGShape(child)->setNeedsShapeUpdate();
                    } else if (child->isSVGText()) {
                        toLayoutSVGText(child)->setNeedsTextMetricsUpdate();
                        toLayoutSVGText(child)->setNeedsPositioningValuesUpdate();
                    }

                    forceChildLayout = true;
                }
            }
        }

        if (child->isSVGResourceContainer()) {
            layoutResourcesIfNeeded(child);
            child->layoutIfNeeded();
        } else {
            SubtreeLayoutScope layoutScope(*child);
            if (forceChildLayout)
                layoutScope.setNeedsLayout(child, LayoutInvalidationReason::SvgChanged);

            layoutResourcesIfNeeded(child);
            child->layoutIfNeeded();
        }
    }
}

SVGMarkerUnitsType LayoutSVGResourceMarker::markerUnits() const
{
    return toSVGMarkerElement(element())->markerUnits()->currentValue()->enumValue();
}

IntRect AffineTransform::mapRect(const IntRect &rect) const
{
    return enclosingIntRect(mapRect(FloatRect(rect)));
}

SubtreeContentTransformScope::~SubtreeContentTransformScope()
{
    m_savedContentTransformation.copyTransformTo(s_currentContentTransformation);
}

DashArray SVGLayoutSupport::resolveSVGDashArray(const SVGDashArray& svgDashArray, const ComputedStyle& style, const SVGLengthContext& lengthContext)
{
    DashArray dashArray;
    for (const Length& dashLength : svgDashArray.vector())
        dashArray.append(lengthContext.valueForLength(dashLength, style));
    return dashArray;
}

TransformationMatrix AffineTransform::toTransformationMatrix() const
{
    return TransformationMatrix(m_transform[0], m_transform[1], m_transform[2],
                                m_transform[3], m_transform[4], m_transform[5]);
}

bool LayoutSVGContainer::nodeAtFloatPoint(HitTestResult& result, const FloatPoint& pointInParent, HitTestAction hitTestAction)
{
    if (!pointIsInsideViewportClip(pointInParent))
        return false;

    FloatPoint localPoint;
    if (!SVGLayoutSupport::transformToUserSpaceAndCheckClipping(this, localToSVGParentTransform(), pointInParent, localPoint))
        return false;

    for (LayoutObject* child = lastChild(); child; child = child->previousSibling()) {
        if (child->nodeAtFloatPoint(result, localPoint, hitTestAction)) {
            const LayoutPoint& localLayoutPoint = roundedLayoutPoint(localPoint);
            updateHitTestResult(result, localLayoutPoint);
            if (result.addNodeToListBasedTestResult(child->node(), localLayoutPoint) == StopHitTesting)
                return true;
        }
    }

    if (style()->pointerEvents() == PE_BOUNDINGBOX) {
        ASSERT(isObjectBoundingBoxValid());
        if (objectBoundingBox().contains(localPoint)) {
            const LayoutPoint& localLayoutPoint = roundedLayoutPoint(localPoint);
            updateHitTestResult(result, localLayoutPoint);
            if (result.addNodeToListBasedTestResult(element(), localLayoutPoint) == StopHitTesting)
                return true;
        }
    }
    return false;
}

FloatRect AffineTransform::mapRect(const FloatRect& rect) const
{
    if (isIdentityOrTranslation()) {
        if (!m_transform[4] && !m_transform[5])
            return rect;

        FloatRect mappedRect(rect);
        mappedRect.move(narrowPrecisionToFloat(m_transform[4]), narrowPrecisionToFloat(m_transform[5]));
        return mappedRect;
    }

    FloatQuad result;
    result.setP1(mapPoint(rect.location()));
    result.setP2(mapPoint(FloatPoint(rect.maxX(), rect.y())));
    result.setP3(mapPoint(FloatPoint(rect.maxX(), rect.maxY())));
    result.setP4(mapPoint(FloatPoint(rect.x(), rect.maxY())));
    return result.boundingBox();
}

AffineTransform& AffineTransform::scale(double s)
{
    return scale(s, s);
}

AffineTransform LayoutSVGResourceMarker::markerTransformation(const FloatPoint& origin, float autoAngle, float strokeWidth) const
{
    float markerScale = markerUnits() == SVGMarkerUnitsStrokeWidth ? strokeWidth : 1;

    AffineTransform transform;
    transform.translate(origin.x(), origin.y());
    transform.rotate(orientType() == SVGMarkerOrientAngle ? angle() : autoAngle);
    transform.scale(markerScale);

    FloatPoint mappedReferencePoint = viewportTransform().mapPoint(referencePoint());
    transform.translate(-mappedReferencePoint.x(), -mappedReferencePoint.y());
    return transform;
}

bool SVGLayoutSupport::transformToUserSpaceAndCheckClipping(const LayoutObject* object, const AffineTransform& localTransform, const FloatPoint& pointInParent, FloatPoint& localPoint)
{
    if (!localTransform.isInvertible())
        return false;
    localPoint = localTransform.inverse().mapPoint(pointInParent);
    return pointInClippingArea(object, localPoint);
}

FloatRect SVGLayoutSupport::localOverflowRectForPaintInvalidation(const LayoutObject& object)
{
    ASSERT(!object.isSVGRoot());

    if (object.styleRef().visibility() != VISIBLE && !object.enclosingLayer()->hasVisibleContent())
        return FloatRect();

    FloatRect paintInvalidationRect = object.paintInvalidationRectInLocalSVGCoordinates();
    if (int outlineOutset = object.styleRef().outlineOutsetExtent())
        paintInvalidationRect.inflate(outlineOutset);
    return paintInvalidationRect;
}

static bool hasValidPredecessor(const Node* node)
{
    ASSERT(node);
    for (node = node->previousSibling(); node; node = node->previousSibling()) {
        if (node->isSVGElement() && toSVGElement(node)->isValid())
            return true;
    }
    return false;
}

bool AffineTransform::isInvertible() const
{
    return det() != 0.0;
}

FloatQuad AffineTransform::mapQuad(const FloatQuad& q) const
{
    if (isIdentityOrTranslation()) {
        FloatQuad mappedQuad(q);
        mappedQuad.move(narrowPrecisionToFloat(m_transform[4]), narrowPrecisionToFloat(m_transform[5]));
        return mappedQuad;
    }

    FloatQuad result;
    result.setP1(mapPoint(q.p1()));
    result.setP2(mapPoint(q.p2()));
    result.setP3(mapPoint(q.p3()));
    result.setP4(mapPoint(q.p4()));
    return result;
}

void LayoutSVGContainer::layout()
{
ASSERT(needsLayout());
LayoutAnalyzer::Scope analyzer(*this);

// Allow LayoutSVGViewportContainer to update its viewport.
calcViewport();

// Allow LayoutSVGTransformableContainer to update its transform.
    bool updatedTransform = calculateLocalTransform();
    m_didScreenScaleFactorChange = updatedTransform || SVGLayoutSupport::screenScaleFactorChanged(parent());

// LayoutSVGViewportContainer needs to set the 'layout size changed' flag.
determineIfLayoutSizeChanged();

// When hasRelativeLengths() is false, no descendants have relative lengths
// (hence no one is interested in viewport size changes).
bool layoutSizeChanged = element()->hasRelativeLengths()
&& SVGLayoutSupport::layoutSizeOfNearestViewportChanged(this);

SVGLayoutSupport::layoutChildren(firstChild(), false, m_didScreenScaleFactorChange, layoutSizeChanged);

// Invalidate all resources of this client if our layout changed.
if (everHadLayout() && needsLayout())
SVGResourcesCache::clientLayoutChanged(this);

    if (m_needsBoundariesUpdate || updatedTransform) {
updateCachedBoundaries();
m_needsBoundariesUpdate = false;

// If our bounds changed, notify the parents.
LayoutSVGModelObject::setNeedsBoundariesUpdate();
}

ASSERT(!m_needsBoundariesUpdate);
clearNeedsLayout();
}

void LayoutSVGResourceMarker::removeClientFromCache(LayoutObject* client, bool markForInvalidation)
{
    ASSERT(client);
    markClientForInvalidation(client, markForInvalidation ? BoundariesInvalidation : ParentOnlyInvalidation);
}

AffineTransform LayoutSVGResourceMarker::viewportTransform() const
{
    SVGMarkerElement* marker = toSVGMarkerElement(element());
    ASSERT(marker);

    return marker->viewBoxToViewTransform(m_viewport.width(), m_viewport.height());
}

void SVGLayoutSupport::computeContainerBoundingBoxes(const LayoutObject* container, FloatRect& objectBoundingBox, bool& objectBoundingBoxValid, FloatRect& strokeBoundingBox, FloatRect& paintInvalidationBoundingBox)
{
    objectBoundingBox = FloatRect();
    objectBoundingBoxValid = false;
    strokeBoundingBox = FloatRect();

    for (LayoutObject* current = container->slowFirstChild(); current; current = current->nextSibling()) {
        if (current->isSVGHiddenContainer())
            continue;

        if (current->isSVGShape() && toLayoutSVGShape(current)->isShapeEmpty())
            continue;

        if (current->isSVGText() && !toLayoutSVGText(current)->isObjectBoundingBoxValid())
            continue;

        const AffineTransform& transform = current->localToSVGParentTransform();
        updateObjectBoundingBox(objectBoundingBox, objectBoundingBoxValid, current,
            transform.mapRect(current->objectBoundingBox()));
        strokeBoundingBox.unite(transform.mapRect(current->paintInvalidationRectInLocalSVGCoordinates()));
    }

    paintInvalidationBoundingBox = strokeBoundingBox;
}

static const LayoutSVGRoot& computeTransformToSVGRoot(const LayoutObject& object, AffineTransform& rootBorderBoxTransform)
{
    ASSERT(object.isSVG() && !object.isSVGRoot());

    const LayoutObject* parent;
    for (parent = &object; !parent->isSVGRoot(); parent = parent->parent())
        rootBorderBoxTransform.preMultiply(parent->localToSVGParentTransform());

    const LayoutSVGRoot& svgRoot = toLayoutSVGRoot(*parent);
    rootBorderBoxTransform.preMultiply(svgRoot.localToBorderBoxTransform());
    return svgRoot;
}

AffineTransform& AffineTransform::flipY()
{
    return scale(1, -1);
}

float SVGLayoutSupport::calculateScreenFontSizeScalingFactor(const LayoutObject* layoutObject)
{
ASSERT(layoutObject);

// FIXME: trying to compute a device space transform at record time is wrong. All clients
// should be updated to avoid relying on this information, and the method should be removed.
AffineTransform ctm = deprecatedCalculateTransformToLayer(layoutObject) * SubtreeContentTransformScope::currentContentTransformation();
ctm.scale(layoutObject->document().frameHost()->deviceScaleFactorDeprecated());

    return narrowPrecisionToFloat(sqrt((pow(ctm.xScale(), 2) + pow(ctm.yScale(), 2)) / 2));
}

AffineTransform::AffineTransform()
{
    const Transform identity = IDENTITY_TRANSFORM;
    setMatrix(identity);
}

void LayoutSVGContainer::addChild(LayoutObject* child, LayoutObject* beforeChild)
{
    LayoutSVGModelObject::addChild(child, beforeChild);
    SVGResourcesCache::clientWasAddedToTree(child, child->styleRef());

    bool shouldIsolateDescendants = (child->isBlendingAllowed() && child->style()->hasBlendMode()) || child->hasNonIsolatedBlendingDescendants();
    if (shouldIsolateDescendants)
        descendantIsolationRequirementsChanged(DescendantIsolationRequired);
}
