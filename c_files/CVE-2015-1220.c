bool GIFLZWContext::doLZW(const unsigned char* block, size_t bytesInBlock)
{
    const size_t width = m_frameContext->width();

    if (rowIter == rowBuffer.end())
        return true;

    for (const unsigned char* ch = block; bytesInBlock-- > 0; ch++) {
        datum += ((int) *ch) << bits;
        bits += 8;

        while (bits >= codesize) {
            int code = datum & codemask;
            datum >>= codesize;
            bits -= codesize;

            if (code == clearCode) {
                codesize = m_frameContext->dataSize() + 1;
                codemask = (1 << codesize) - 1;
                avail = clearCode + 2;
                oldcode = -1;
                continue;
            }

            if (code == (clearCode + 1)) {
                if (!rowsRemaining)
                    return true;
                return false;
            }

            const int tempCode = code;
            unsigned short codeLength = 0;
            if (code < avail) {
                codeLength = suffixLength[code];
                rowIter += codeLength;
            } else if (code == avail && oldcode != -1) {
                codeLength = suffixLength[oldcode] + 1;
                rowIter += codeLength;
                *--rowIter = firstchar;
                code = oldcode;
            } else {
                return false;
            }

            while (code >= clearCode) {
                *--rowIter = suffix[code];
                code = prefix[code];
            }

            *--rowIter = firstchar = suffix[code];

            if (avail < MAX_DICTIONARY_ENTRIES && oldcode != -1) {
                prefix[avail] = oldcode;
                suffix[avail] = firstchar;
                suffixLength[avail] = suffixLength[oldcode] + 1;
                ++avail;

                if (!(avail & codemask) && avail < MAX_DICTIONARY_ENTRIES) {
                    ++codesize;
                    codemask += avail;
                }
            }
            oldcode = tempCode;
            rowIter += codeLength;

            GIFRow::iterator rowBegin = rowBuffer.begin();
            for (; rowBegin + width <= rowIter; rowBegin += width) {
                if (!outputRow(rowBegin))
                    return false;
                rowsRemaining--;
                if (!rowsRemaining)
                    return true;
            }

            if (rowBegin != rowBuffer.begin()) {
                const size_t bytesToCopy = rowIter - rowBegin;
                memcpy(rowBuffer.begin(), rowBegin, bytesToCopy);
                rowIter = rowBuffer.begin() + bytesToCopy;
            }
        }
    }
    return true;
}

unsigned hashSkBitmap(const SkBitmap& bitmap)
{
    return StringHasher::hashMemory(bitmap.getPixels(), bitmap.getSize());
}

bool GIFImageReader::decode(size_t frameIndex)
{
    m_globalColorMap.buildTable(data(0), m_data->size());

    bool frameDecoded = false;
    GIFFrameContext* currentFrame = m_frames[frameIndex].get();

    return currentFrame->decode(data(0), m_data->size(), m_client, &frameDecoded)
        && (!frameDecoded || m_client->frameComplete(frameIndex));
}

void GIFImageReader::setRemainingBytes(size_t remainingBytes)
{
    ASSERT(remainingBytes <= m_data->size());
    m_bytesRead = m_data->size() - remainingBytes;
}

bool GIFImageReader::parseData(size_t dataPosition, size_t len, GIFImageDecoder::GIFParseQuery query)
{
if (!len) {
// No new data has come in since the last call, just ignore this call.
return true;
}

if (len < m_bytesToConsume)
return true;

// This loop reads as many components from |m_data| as possible.
// At the beginning of each iteration, dataPosition will be advanced by m_bytesToConsume to
// point to the next component. len will be decremented accordingly.
while (len >= m_bytesToConsume) {
const size_t currentComponentPosition = dataPosition;
const unsigned char* currentComponent = data(dataPosition);

// Mark the current component as consumed. Note that currentComponent will remain pointed at this
// component until the next loop iteration.
dataPosition += m_bytesToConsume;
len -= m_bytesToConsume;

switch (m_state) {
case GIFLZW:
ASSERT(!m_frames.isEmpty());
// m_bytesToConsume is the current component size because it hasn't been updated.
m_frames.last()->addLzwBlock(currentComponentPosition, m_bytesToConsume);
GETN(1, GIFSubBlock);
break;

case GIFLZWStart: {
ASSERT(!m_frames.isEmpty());
m_frames.last()->setDataSize(*currentComponent);
GETN(1, GIFSubBlock);
break;
}

case GIFType: {
// All GIF files begin with "GIF87a" or "GIF89a".
if (!strncmp((char*)currentComponent, "GIF89a", 6))
m_version = 89;
else if (!strncmp((char*)currentComponent, "GIF87a", 6))
m_version = 87;
else
return false;
GETN(7, GIFGlobalHeader);
break;
}

case GIFGlobalHeader: {
            // This is the height and width of the "screen" or frame into which images are rendered. The
            // individual images can be smaller than the screen size and located with an origin anywhere
            // within the screen.
m_screenWidth = GETINT16(currentComponent);
m_screenHeight = GETINT16(currentComponent + 2);

            // CALLBACK: Inform the decoderplugin of our size.
            // Note: A subsequent frame might have dimensions larger than the "screen" dimensions.
            if (m_client && !m_client->setSize(m_screenWidth, m_screenHeight))
                return false;
const size_t globalColorMapColors = 2 << (currentComponent[4] & 0x07);

if ((currentComponent[4] & 0x80) && globalColorMapColors > 0) { /* global map */
m_globalColorMap.setTablePositionAndSize(dataPosition, globalColorMapColors);
GETN(BYTES_PER_COLORMAP_ENTRY * globalColorMapColors, GIFGlobalColormap);
break;
}

GETN(1, GIFImageStart);
break;
}

case GIFGlobalColormap: {
m_globalColorMap.setDefined();
GETN(1, GIFImageStart);
break;
}

case GIFImageStart: {
if (*currentComponent == '!') { // extension.
GETN(2, GIFExtension);
break;
}

if (*currentComponent == ',') { // image separator.
GETN(9, GIFImageHeader);
break;
}

// If we get anything other than ',' (image separator), '!'
// (extension), or ';' (trailer), there is extraneous data
// between blocks. The GIF87a spec tells us to keep reading
// until we find an image separator, but GIF89a says such
// a file is corrupt. We follow Mozilla's implementation and
// proceed as if the file were correctly terminated, so the
// GIF will display.
GETN(0, GIFDone);
break;
}

case GIFExtension: {
size_t bytesInBlock = currentComponent[1];
GIFState exceptionState = GIFSkipBlock;

switch (*currentComponent) {
case 0xf9:
exceptionState = GIFControlExtension;
// The GIF spec mandates that the GIFControlExtension header block length is 4 bytes,
// and the parser for this block reads 4 bytes, so we must enforce that the buffer
// contains at least this many bytes. If the GIF specifies a different length, we
// allow that, so long as it's larger; the additional data will simply be ignored.
bytesInBlock = std::max(bytesInBlock, static_cast<size_t>(4));
break;

// The GIF spec also specifies the lengths of the following two extensions' headers
// (as 12 and 11 bytes, respectively). Because we ignore the plain text extension entirely
// and sanity-check the actual length of the application extension header before reading it,
// we allow GIFs to deviate from these values in either direction. This is important for
// real-world compatibility, as GIFs in the wild exist with application extension headers
// that are both shorter and longer than 11 bytes.
case 0x01:
// ignoring plain text extension
break;

case 0xff:
exceptionState = GIFApplicationExtension;
break;

case 0xfe:
exceptionState = GIFConsumeComment;
break;
}

if (bytesInBlock)
GETN(bytesInBlock, exceptionState);
else
GETN(1, GIFImageStart);
break;
}

case GIFConsumeBlock: {
if (!*currentComponent)
GETN(1, GIFImageStart);
else
GETN(*currentComponent, GIFSkipBlock);
break;
}

case GIFSkipBlock: {
GETN(1, GIFConsumeBlock);
break;
}

case GIFControlExtension: {
addFrameIfNecessary();
GIFFrameContext* currentFrame = m_frames.last().get();
if (*currentComponent & 0x1)
currentFrame->setTransparentPixel(currentComponent[3]);

// We ignore the "user input" bit.

// NOTE: This relies on the values in the FrameDisposalMethod enum
// matching those in the GIF spec!
int disposalMethod = ((*currentComponent) >> 2) & 0x7;
if (disposalMethod < 4) {
currentFrame->setDisposalMethod(static_cast<blink::ImageFrame::DisposalMethod>(disposalMethod));
} else if (disposalMethod == 4) {
// Some specs say that disposal method 3 is "overwrite previous", others that setting
// the third bit of the field (i.e. method 4) is. We map both to the same value.
currentFrame->setDisposalMethod(blink::ImageFrame::DisposeOverwritePrevious);
}
currentFrame->setDelayTime(GETINT16(currentComponent + 1) * 10);
GETN(1, GIFConsumeBlock);
break;
}

case GIFCommentExtension: {
if (*currentComponent)
GETN(*currentComponent, GIFConsumeComment);
else
GETN(1, GIFImageStart);
break;
}

case GIFConsumeComment: {
GETN(1, GIFCommentExtension);
break;
}

case GIFApplicationExtension: {
// Check for netscape application extension.
if (m_bytesToConsume == 11
&& (!strncmp((char*)currentComponent, "NETSCAPE2.0", 11) || !strncmp((char*)currentComponent, "ANIMEXTS1.0", 11)))
GETN(1, GIFNetscapeExtensionBlock);
else
GETN(1, GIFConsumeBlock);
break;
}

// Netscape-specific GIF extension: animation looping.
case GIFNetscapeExtensionBlock: {
// GIFConsumeNetscapeExtension always reads 3 bytes from the stream; we should at least wait for this amount.
if (*currentComponent)
GETN(std::max(3, static_cast<int>(*currentComponent)), GIFConsumeNetscapeExtension);
else
GETN(1, GIFImageStart);
break;
}

// Parse netscape-specific application extensions
case GIFConsumeNetscapeExtension: {
int netscapeExtension = currentComponent[0] & 7;

// Loop entire animation specified # of times. Only read the loop count during the first iteration.
if (netscapeExtension == 1) {
m_loopCount = GETINT16(currentComponent + 1);

// Zero loop count is infinite animation loop request.
if (!m_loopCount)
m_loopCount = blink::cAnimationLoopInfinite;

GETN(1, GIFNetscapeExtensionBlock);
} else if (netscapeExtension == 2) {
// Wait for specified # of bytes to enter buffer.

// Don't do this, this extension doesn't exist (isn't used at all)
// and doesn't do anything, as our streaming/buffering takes care of it all...
// See: http://semmix.pl/color/exgraf/eeg24.htm
GETN(1, GIFNetscapeExtensionBlock);
} else {
// 0,3-7 are yet to be defined netscape extension codes
return false;
}
break;
}

case GIFImageHeader: {
unsigned height, width, xOffset, yOffset;

/* Get image offsets, with respect to the screen origin */
xOffset = GETINT16(currentComponent);
yOffset = GETINT16(currentComponent + 2);

/* Get image width and height. */
width  = GETINT16(currentComponent + 4);
height = GETINT16(currentComponent + 6);

            /* Work around broken GIF files where the logical screen
             * size has weird width or height.  We assume that GIF87a
             * files don't contain animations.
             *
            if (currentFrameIsFirstFrame()
                && ((m_screenHeight < height) || (m_screenWidth < width) || (m_version == 87))) {
                m_screenHeight = height;
                m_screenWidth = width;
                xOffset = 0;
                yOffset = 0;
                // CALLBACK: Inform the decoderplugin of our size.
                if (m_client && !m_client->setSize(m_screenWidth, m_screenHeight))
                    return false;
}

            // Work around more broken GIF files that have zero image width or height
            if (!height || !width) {
                height = m_screenHeight;
                width = m_screenWidth;
                if (!height || !width)
                    return false;
            }

if (query == GIFImageDecoder::GIFSizeQuery) {
// The decoder needs to stop. Hand back the number of bytes we consumed from
// buffer minus 9 (the amount we consumed to read the header).
setRemainingBytes(len + 9);
GETN(9, GIFImageHeader);
return true;
}

addFrameIfNecessary();
GIFFrameContext* currentFrame = m_frames.last().get();

currentFrame->setHeaderDefined();
currentFrame->setRect(xOffset, yOffset, width, height);
            m_screenWidth = std::max(m_screenWidth, width);
            m_screenHeight = std::max(m_screenHeight, height);
currentFrame->setInterlaced(currentComponent[8] & 0x40);

// Overlaying interlaced, transparent GIFs over
// existing image data using the Haeberli display hack
// requires saving the underlying image in order to
// avoid jaggies at the transparency edges. We are
// unprepared to deal with that, so don't display such
// images progressively. Which means only the first
// frame can be progressively displayed.
// FIXME: It is possible that a non-transparent frame
// can be interlaced and progressively displayed.
currentFrame->setProgressiveDisplay(currentFrameIsFirstFrame());

const bool isLocalColormapDefined = currentComponent[8] & 0x80;
if (isLocalColormapDefined) {
// The three low-order bits of currentComponent[8] specify the bits per pixel.
const size_t numColors = 2 << (currentComponent[8] & 0x7);
currentFrame->localColorMap().setTablePositionAndSize(dataPosition, numColors);
GETN(BYTES_PER_COLORMAP_ENTRY * numColors, GIFImageColormap);
break;
}

GETN(1, GIFLZWStart);
break;
}

case GIFImageColormap: {
ASSERT(!m_frames.isEmpty());
m_frames.last()->localColorMap().setDefined();
GETN(1, GIFLZWStart);
break;
}

case GIFSubBlock: {
const size_t bytesInBlock = *currentComponent;
if (bytesInBlock)
GETN(bytesInBlock, GIFLZW);
else {
// Finished parsing one frame; Process next frame.
ASSERT(!m_frames.isEmpty());
// Note that some broken GIF files do not have enough LZW blocks to fully
// decode all rows but we treat it as frame complete.
m_frames.last()->setComplete();
GETN(1, GIFImageStart);
}
break;
}

case GIFDone: {
m_parseCompleted = true;
return true;
}

default:
// We shouldn't ever get here.
return false;
break;
}
}

setRemainingBytes(len);
return true;
}

bool GIFLZWContext::prepareToDecode()
{
    ASSERT(m_frameContext->isDataSizeDefined() && m_frameContext->isHeaderDefined());

    if (m_frameContext->dataSize() >= MAX_DICTIONARY_ENTRY_BITS)
        return false;
    clearCode = 1 << m_frameContext->dataSize();
    avail = clearCode + 2;
    oldcode = -1;
    codesize = m_frameContext->dataSize() + 1;
    codemask = (1 << codesize) - 1;
    datum = bits = 0;
    ipass = m_frameContext->interlaced() ? 1 : 0;
    irow = 0;

    const size_t maxBytes = MAX_DICTIONARY_ENTRIES - 1;

    rowBuffer.resize(m_frameContext->width() - 1 + maxBytes);
    rowIter = rowBuffer.begin();
    rowsRemaining = m_frameContext->height();

    for (int i = 0; i < clearCode; ++i) {
        suffix[i] = i;
        suffixLength[i] = 1;
    }
    return true;
}

void GIFColorMap::buildTable(const unsigned char* data, size_t length)
{
    if (!m_isDefined || !m_table.isEmpty())
        return;

    RELEASE_ASSERT(m_position + m_colors * BYTES_PER_COLORMAP_ENTRY <= length);
    const unsigned char* srcColormap = data + m_position;
    m_table.resize(m_colors);
    for (Table::iterator iter = m_table.begin(); iter != m_table.end(); ++iter) {
        *iter = SkPackARGB32NoCheck(255, srcColormap[0], srcColormap[1], srcColormap[2]);
        srcColormap += BYTES_PER_COLORMAP_ENTRY;
    }
}

PassOwnPtr<GIFImageDecoder> createDecoder()
{
    return adoptPtr(new GIFImageDecoder(ImageSource::AlphaNotPremultiplied, ImageSource::GammaAndColorProfileApplied, ImageDecoder::noDecodedImageByteLimit));
}

void testRandomDecodeAfterClearFrameBufferCache(const char* gifFile)
{
SCOPED_TRACE(gifFile);

    RefPtr<SharedBuffer> data = readFile(gifFile);
ASSERT_TRUE(data.get());
Vector<unsigned> baselineHashes;
createDecodingBaseline(data.get(), &baselineHashes);
size_t frameCount = baselineHashes.size();

OwnPtr<GIFImageDecoder> decoder = createDecoder();
decoder->setData(data.get(), true);
for (size_t clearExceptFrame = 0; clearExceptFrame < frameCount; ++clearExceptFrame) {
decoder->clearCacheExceptFrame(clearExceptFrame);
const size_t skippingStep = 5;
for (size_t i = 0; i < skippingStep; ++i) {
for (size_t j = 0; j < frameCount; j += skippingStep) {
SCOPED_TRACE(testing::Message() << "Random i:" << i << " j:" << j);
ImageFrame* frame = decoder->frameBufferAtIndex(j);
EXPECT_EQ(baselineHashes[j], hashSkBitmap(frame->getSkBitmap()));
}
}
}
}

void testRandomFrameDecode(const char* gifFile)
{
SCOPED_TRACE(gifFile);

    RefPtr<SharedBuffer> fullData = readFile(gifFile);
ASSERT_TRUE(fullData.get());
Vector<unsigned> baselineHashes;
createDecodingBaseline(fullData.get(), &baselineHashes);
size_t frameCount = baselineHashes.size();

// Random decoding should get the same results as sequential decoding.
OwnPtr<GIFImageDecoder> decoder = createDecoder();
decoder->setData(fullData.get(), true);
const size_t skippingStep = 5;
for (size_t i = 0; i < skippingStep; ++i) {
for (size_t j = i; j < frameCount; j += skippingStep) {
SCOPED_TRACE(testing::Message() << "Random i:" << i << " j:" << j);
ImageFrame* frame = decoder->frameBufferAtIndex(j);
EXPECT_EQ(baselineHashes[j], hashSkBitmap(frame->getSkBitmap()));
}
}

// Decoding in reverse order.
decoder = createDecoder();
decoder->setData(fullData.get(), true);
for (size_t i = frameCount; i; --i) {
SCOPED_TRACE(testing::Message() << "Reverse i:" << i);
ImageFrame* frame = decoder->frameBufferAtIndex(i - 1);
EXPECT_EQ(baselineHashes[i - 1], hashSkBitmap(frame->getSkBitmap()));
}
}

void createDecodingBaseline(SharedBuffer* data, Vector<unsigned>* baselineHashes)
{
    OwnPtr<GIFImageDecoder> decoder = createDecoder();
    decoder->setData(data, true);
    size_t frameCount = decoder->frameCount();
    for (size_t i = 0; i < frameCount; ++i) {
        ImageFrame* frame = decoder->frameBufferAtIndex(i);
        baselineHashes->append(hashSkBitmap(frame->getSkBitmap()));
     }
 }

PassRefPtr<SharedBuffer> readFile(const char* fileName)
 {
     String filePath = Platform::current()->unitTestSupport()->webKitRootDir();
     filePath.append(fileName);
 
     return Platform::current()->unitTestSupport()->readFromFile(filePath);
}

void GIFImageReader::addFrameIfNecessary()
{
    if (m_frames.isEmpty() || m_frames.last()->isComplete())
        m_frames.append(adoptPtr(new GIFFrameContext(m_frames.size())));
}

bool GIFLZWContext::outputRow(GIFRow::const_iterator rowBegin)
{
    int drowStart = irow;
    int drowEnd = irow;

    if (m_frameContext->progressiveDisplay() && m_frameContext->interlaced() && ipass < 4) {
        unsigned rowDup = 0;
        unsigned rowShift = 0;

        switch (ipass) {
        case 1:
            rowDup = 7;
            rowShift = 3;
            break;
        case 2:
            rowDup = 3;
            rowShift = 1;
            break;
        case 3:
            rowDup = 1;
            rowShift = 0;
            break;
        default:
            break;
        }

        drowStart -= rowShift;
        drowEnd = drowStart + rowDup;

        if (((m_frameContext->height() - 1) - drowEnd) <= rowShift)
            drowEnd = m_frameContext->height() - 1;

        if (drowStart < 0)
            drowStart = 0;

        if ((unsigned)drowEnd >= m_frameContext->height())
            drowEnd = m_frameContext->height() - 1;
    }

    if ((unsigned)drowStart >= m_frameContext->height())
        return true;

    if (!m_client->haveDecodedRow(m_frameContext->frameId(), rowBegin, m_frameContext->width(),
        drowStart, drowEnd - drowStart + 1, m_frameContext->progressiveDisplay() && m_frameContext->interlaced() && ipass > 1))
        return false;

    if (!m_frameContext->interlaced())
        irow++;
    else {
        do {
            switch (ipass) {
            case 1:
                irow += 8;
                if (irow >= m_frameContext->height()) {
                    ipass++;
                    irow = 4;
                }
                break;

            case 2:
                irow += 8;
                if (irow >= m_frameContext->height()) {
                    ipass++;
                    irow = 2;
                }
                break;

            case 3:
                irow += 4;
                if (irow >= m_frameContext->height()) {
                    ipass++;
                    irow = 1;
                }
                break;

            case 4:
                irow += 2;
                if (irow >= m_frameContext->height()) {
                    ipass++;
                    irow = 0;
                }
                break;

            default:
                break;
            }
        } while (irow > (m_frameContext->height() - 1));
    }
    return true;
}
