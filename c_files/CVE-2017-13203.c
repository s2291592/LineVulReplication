WORD32 ih264d_parse_recovery_point(dec_bit_stream_t *ps_bitstrm,
 dec_struct_t *ps_dec,
                                   UWORD32 ui4_payload_size)
{
    sei *ps_sei = ps_dec->ps_sei;
 dec_err_status_t *ps_err = ps_dec->ps_dec_err_status;
    UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;
    UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
    UNUSED(ui4_payload_size);
    ps_sei->u2_recovery_frame_cnt = ih264d_uev(pu4_bitstrm_ofst,
                                               pu4_bitstrm_buf);
    ps_err->u4_frm_sei_sync = ps_err->u4_cur_frm
 + ps_sei->u2_recovery_frame_cnt;
    ps_sei->u1_exact_match_flag = ih264d_get_bit_h264(ps_bitstrm);
    ps_sei->u1_broken_link_flag = ih264d_get_bit_h264(ps_bitstrm);
    ps_sei->u1_changing_slice_grp_idc = ih264d_get_bits_h264(ps_bitstrm, 2);

 return (0);
}

WORD32 ih264d_allocate_static_bufs(iv_obj_t **dec_hdl, void *pv_api_ip, void *pv_api_op)
{
 ih264d_create_ip_t *ps_create_ip;
 ih264d_create_op_t *ps_create_op;
 void *pv_buf;
    UWORD8 *pu1_buf;
 dec_struct_t *ps_dec;
 void *(*pf_aligned_alloc)(void *pv_mem_ctxt, WORD32 alignment, WORD32 size);
 void (*pf_aligned_free)(void *pv_mem_ctxt, void *pv_buf);
 void *pv_mem_ctxt;
    WORD32 size;

    ps_create_ip = (ih264d_create_ip_t *)pv_api_ip;
    ps_create_op = (ih264d_create_op_t *)pv_api_op;

    ps_create_op->s_ivd_create_op_t.u4_error_code = 0;

    pf_aligned_alloc = ps_create_ip->s_ivd_create_ip_t.pf_aligned_alloc;
    pf_aligned_free = ps_create_ip->s_ivd_create_ip_t.pf_aligned_free;
    pv_mem_ctxt  = ps_create_ip->s_ivd_create_ip_t.pv_mem_ctxt;

 /* Initialize return handle to NULL */
    ps_create_op->s_ivd_create_op_t.pv_handle = NULL;
    pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, sizeof(iv_obj_t));
    RETURN_IF((NULL == pv_buf), IV_FAIL);
 *dec_hdl = (iv_obj_t *)pv_buf;
    ps_create_op->s_ivd_create_op_t.pv_handle = *dec_hdl;

 (*dec_hdl)->pv_codec_handle = NULL;
    pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, sizeof(dec_struct_t));
    RETURN_IF((NULL == pv_buf), IV_FAIL);
 (*dec_hdl)->pv_codec_handle = (dec_struct_t *)pv_buf;
    ps_dec = (dec_struct_t *)pv_buf;

    memset(ps_dec, 0, sizeof(dec_struct_t));

#ifndef LOGO_EN
    ps_dec->u4_share_disp_buf = ps_create_ip->s_ivd_create_ip_t.u4_share_disp_buf;
#else
    ps_dec->u4_share_disp_buf = 0;
#endif

    ps_dec->u1_chroma_format =
 (UWORD8)(ps_create_ip->s_ivd_create_ip_t.e_output_format);

 if((ps_dec->u1_chroma_format != IV_YUV_420P)
 && (ps_dec->u1_chroma_format
 != IV_YUV_420SP_UV)
 && (ps_dec->u1_chroma_format
 != IV_YUV_420SP_VU))
 {
        ps_dec->u4_share_disp_buf = 0;
 }

    ps_dec->pf_aligned_alloc = pf_aligned_alloc;
    ps_dec->pf_aligned_free = pf_aligned_free;
    ps_dec->pv_mem_ctxt = pv_mem_ctxt;


    size = ((sizeof(dec_seq_params_t)) * MAX_NUM_SEQ_PARAMS);
    pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, size);
    RETURN_IF((NULL == pv_buf), IV_FAIL);
    ps_dec->ps_sps = pv_buf;

    size = (sizeof(dec_pic_params_t)) * MAX_NUM_PIC_PARAMS;
    pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, size);
    RETURN_IF((NULL == pv_buf), IV_FAIL);
    ps_dec->ps_pps = pv_buf;

    size = ithread_get_handle_size();
    pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, size);
    RETURN_IF((NULL == pv_buf), IV_FAIL);
    ps_dec->pv_dec_thread_handle = pv_buf;

    size = ithread_get_handle_size();
    pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, size);
    RETURN_IF((NULL == pv_buf), IV_FAIL);
    ps_dec->pv_bs_deblk_thread_handle = pv_buf;

    size = sizeof(dpb_manager_t);
    pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, size);
    RETURN_IF((NULL == pv_buf), IV_FAIL);
    ps_dec->ps_dpb_mgr = pv_buf;

    size = sizeof(pred_info_t) * 2 * 32;
    pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, size);
    RETURN_IF((NULL == pv_buf), IV_FAIL);
    ps_dec->ps_pred = pv_buf;

    size = sizeof(disp_mgr_t);
    pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, size);
    RETURN_IF((NULL == pv_buf), IV_FAIL);
    ps_dec->pv_disp_buf_mgr = pv_buf;

    size = sizeof(buf_mgr_t) + ithread_get_mutex_lock_size();
    pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, size);
    RETURN_IF((NULL == pv_buf), IV_FAIL);
    ps_dec->pv_pic_buf_mgr = pv_buf;

    size = sizeof(struct pic_buffer_t) * (H264_MAX_REF_PICS * 2);
    pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, size);
    RETURN_IF((NULL == pv_buf), IV_FAIL);
    ps_dec->ps_pic_buf_base = pv_buf;

    size = sizeof(dec_err_status_t);
    pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, size);
    RETURN_IF((NULL == pv_buf), IV_FAIL);
    ps_dec->ps_dec_err_status = (dec_err_status_t *)pv_buf;

    size = sizeof(sei);
    pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, size);
    RETURN_IF((NULL == pv_buf), IV_FAIL);
    ps_dec->ps_sei = (sei *)pv_buf;

    size = sizeof(dpb_commands_t);
    pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, size);
    RETURN_IF((NULL == pv_buf), IV_FAIL);
    ps_dec->ps_dpb_cmds = (dpb_commands_t *)pv_buf;

    size = sizeof(dec_bit_stream_t);
    pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, size);
    RETURN_IF((NULL == pv_buf), IV_FAIL);
    ps_dec->ps_bitstrm = (dec_bit_stream_t *)pv_buf;

    size = sizeof(dec_slice_params_t);
    pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, size);
    RETURN_IF((NULL == pv_buf), IV_FAIL);
    ps_dec->ps_cur_slice = (dec_slice_params_t *)pv_buf;

    size = MAX(sizeof(dec_seq_params_t), sizeof(dec_pic_params_t));
    pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, size);
    RETURN_IF((NULL == pv_buf), IV_FAIL);
    ps_dec->pv_scratch_sps_pps = pv_buf;


    ps_dec->u4_static_bits_buf_size = 256000;
    pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, ps_dec->u4_static_bits_buf_size);
    RETURN_IF((NULL == pv_buf), IV_FAIL);
    ps_dec->pu1_bits_buf_static = pv_buf;


    size = ((TOTAL_LIST_ENTRIES + PAD_MAP_IDX_POC)
 * sizeof(void *));
    pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, size);
    RETURN_IF((NULL == pv_buf), IV_FAIL);
    ps_dec->ppv_map_ref_idx_to_poc_base = pv_buf;
    memset(ps_dec->ppv_map_ref_idx_to_poc_base, 0, size);

    ps_dec->ppv_map_ref_idx_to_poc = ps_dec->ppv_map_ref_idx_to_poc_base + OFFSET_MAP_IDX_POC;


    size = (sizeof(bin_ctxt_model_t) * NUM_CABAC_CTXTS);
    pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, size);
    RETURN_IF((NULL == pv_buf), IV_FAIL);
    ps_dec->p_cabac_ctxt_table_t = pv_buf;



    size = sizeof(ctxt_inc_mb_info_t);
    pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, size);
    RETURN_IF((NULL == pv_buf), IV_FAIL);
    ps_dec->ps_left_mb_ctxt_info = pv_buf;



    size = MAX_REF_BUF_SIZE * 2;
    pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, size);
    RETURN_IF((NULL == pv_buf), IV_FAIL);
    ps_dec->pu1_ref_buff_base = pv_buf;
    ps_dec->pu1_ref_buff = ps_dec->pu1_ref_buff_base + MAX_REF_BUF_SIZE;


    size = ((sizeof(WORD16)) * PRED_BUFFER_WIDTH
 * PRED_BUFFER_HEIGHT * 2);
    pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, size);
    RETURN_IF((NULL == pv_buf), IV_FAIL);
    ps_dec->pi2_pred1 = pv_buf;


    size = sizeof(UWORD8) * (MB_LUM_SIZE);
    pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, size);
    RETURN_IF((NULL == pv_buf), IV_FAIL);
    ps_dec->pu1_temp_mc_buffer = pv_buf;




    size = 8 * MAX_REF_BUFS * sizeof(struct pic_buffer_t);
    pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, size);
    RETURN_IF((NULL == pv_buf), IV_FAIL);

    ps_dec->pu1_init_dpb_base = pv_buf;
    pu1_buf = pv_buf;
    ps_dec->ps_dpb_mgr->ps_init_dpb[0][0] = (struct pic_buffer_t *)pu1_buf;

    pu1_buf += size / 2;
    ps_dec->ps_dpb_mgr->ps_init_dpb[1][0] = (struct pic_buffer_t *)pu1_buf;

    size = (sizeof(UWORD32) * 2 * 3
 * ((MAX_FRAMES << 1) * (MAX_FRAMES << 1)) * 2);
    pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, size);
    RETURN_IF((NULL == pv_buf), IV_FAIL);
    ps_dec->pu4_mbaff_wt_mat = pv_buf;

    size = sizeof(UWORD32) * 2 * 3
 * ((MAX_FRAMES << 1) * (MAX_FRAMES << 1));
    pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, size);
    RETURN_IF((NULL == pv_buf), IV_FAIL);
    ps_dec->pu4_wts_ofsts_mat = pv_buf;


    size = (sizeof(neighbouradd_t) << 2);
    pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, size);
    RETURN_IF((NULL == pv_buf), IV_FAIL);
    ps_dec->ps_left_mvpred_addr = pv_buf;


    size = sizeof(buf_mgr_t) + ithread_get_mutex_lock_size();
    pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, size);
    RETURN_IF((NULL == pv_buf), IV_FAIL);
    ps_dec->pv_mv_buf_mgr = pv_buf;


    size = sizeof(col_mv_buf_t) * (H264_MAX_REF_PICS * 2);
    pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, size);
    RETURN_IF((NULL == pv_buf), IV_FAIL);
    ps_dec->ps_col_mv_base = pv_buf;
    memset(ps_dec->ps_col_mv_base, 0, size);

 {
        UWORD8 i;
 struct pic_buffer_t *ps_init_dpb;
        ps_init_dpb = ps_dec->ps_dpb_mgr->ps_init_dpb[0][0];
 for(i = 0; i < 2 * MAX_REF_BUFS; i++)
 {
            ps_init_dpb->pu1_buf1 = NULL;
            ps_init_dpb->u1_long_term_frm_idx = MAX_REF_BUFS + 1;
            ps_dec->ps_dpb_mgr->ps_init_dpb[0][i] = ps_init_dpb;
            ps_dec->ps_dpb_mgr->ps_mod_dpb[0][i] = ps_init_dpb;
            ps_init_dpb++;
 }

        ps_init_dpb = ps_dec->ps_dpb_mgr->ps_init_dpb[1][0];
 for(i = 0; i < 2 * MAX_REF_BUFS; i++)
 {
            ps_init_dpb->pu1_buf1 = NULL;
            ps_init_dpb->u1_long_term_frm_idx = MAX_REF_BUFS + 1;
            ps_dec->ps_dpb_mgr->ps_init_dpb[1][i] = ps_init_dpb;
            ps_dec->ps_dpb_mgr->ps_mod_dpb[1][i] = ps_init_dpb;
            ps_init_dpb++;
 }
 }
    ih264d_init_decoder(ps_dec);

 return IV_SUCCESS;
}

WORD32 ih264d_set_params(iv_obj_t *dec_hdl, void *pv_api_ip, void *pv_api_op)
{

 dec_struct_t * ps_dec;
    WORD32 ret = IV_SUCCESS;

 ivd_ctl_set_config_ip_t *ps_ctl_ip =
 (ivd_ctl_set_config_ip_t *)pv_api_ip;
 ivd_ctl_set_config_op_t *ps_ctl_op =
 (ivd_ctl_set_config_op_t *)pv_api_op;

    ps_dec = (dec_struct_t *)(dec_hdl->pv_codec_handle);

    ps_dec->u4_skip_frm_mask = 0;

    ps_ctl_op->u4_error_code = 0;

    ps_dec->i4_app_skip_mode = ps_ctl_ip->e_frm_skip_mode;

 /*Is it really supported test it when you so the corner testing using test app*/

 if(ps_ctl_ip->e_frm_skip_mode != IVD_SKIP_NONE)
 {

 if(ps_ctl_ip->e_frm_skip_mode == IVD_SKIP_P)
            ps_dec->u4_skip_frm_mask |= 1 << P_SLC_BIT;
 else if(ps_ctl_ip->e_frm_skip_mode == IVD_SKIP_B)
            ps_dec->u4_skip_frm_mask |= 1 << B_SLC_BIT;
 else if(ps_ctl_ip->e_frm_skip_mode == IVD_SKIP_PB)
 {
            ps_dec->u4_skip_frm_mask |= 1 << B_SLC_BIT;
            ps_dec->u4_skip_frm_mask |= 1 << P_SLC_BIT;
 }
 else if(ps_ctl_ip->e_frm_skip_mode == IVD_SKIP_I)
            ps_dec->u4_skip_frm_mask |= 1 << I_SLC_BIT;
 else
 {
            ps_ctl_op->u4_error_code = (1 << IVD_UNSUPPORTEDPARAM);
            ret = IV_FAIL;
 }
 }

 if(ps_ctl_ip->u4_disp_wd >= ps_dec->u2_pic_wd)
 {
        ps_dec->u4_app_disp_width = ps_ctl_ip->u4_disp_wd;
 }
 else if(0 == ps_dec->i4_header_decoded)
 {
        ps_dec->u4_app_disp_width = ps_ctl_ip->u4_disp_wd;
 }
 else if(ps_ctl_ip->u4_disp_wd == 0)
 {
        ps_dec->u4_app_disp_width = 0;
 }
 else
 {
 /*
         * Set the display width to zero. This will ensure that the wrong value we had stored (0xFFFFFFFF)
         * does not propogate.
         */
        ps_dec->u4_app_disp_width = 0;
        ps_ctl_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);
        ps_ctl_op->u4_error_code |= ERROR_DISP_WIDTH_INVALID;
        ret = IV_FAIL;
 }

 if(ps_ctl_ip->e_vid_dec_mode == IVD_DECODE_FRAME)
        ps_dec->i4_decode_header = 0;
 else if(ps_ctl_ip->e_vid_dec_mode == IVD_DECODE_HEADER)
        ps_dec->i4_decode_header = 1;
 else
 {
        ps_ctl_op->u4_error_code = (1 << IVD_UNSUPPORTEDPARAM);
        ps_dec->i4_decode_header = 1;
        ret = IV_FAIL;
 }
    ps_dec->e_frm_out_mode = IVD_DISPLAY_FRAME_OUT;

 if((ps_ctl_ip->e_frm_out_mode != IVD_DECODE_FRAME_OUT) &&
 (ps_ctl_ip->e_frm_out_mode != IVD_DISPLAY_FRAME_OUT))
 {
        ps_ctl_op->u4_error_code = (1 << IVD_UNSUPPORTEDPARAM);
        ret = IV_FAIL;
 }
    ps_dec->e_frm_out_mode = ps_ctl_ip->e_frm_out_mode;
 return ret;

}

static IV_API_CALL_STATUS_T api_check_struct_sanity(iv_obj_t *ps_handle,
 void *pv_api_ip,
 void *pv_api_op)
{
    IVD_API_COMMAND_TYPE_T e_cmd;
    UWORD32 *pu4_api_ip;
    UWORD32 *pu4_api_op;
    UWORD32 i, j;

 if(NULL == pv_api_op)
 return (IV_FAIL);

 if(NULL == pv_api_ip)
 return (IV_FAIL);

    pu4_api_ip = (UWORD32 *)pv_api_ip;
    pu4_api_op = (UWORD32 *)pv_api_op;
    e_cmd = *(pu4_api_ip + 1);

 /* error checks on handle */
 switch((WORD32)e_cmd)
 {
 case IVD_CMD_CREATE:
 break;

 case IVD_CMD_REL_DISPLAY_FRAME:
 case IVD_CMD_SET_DISPLAY_FRAME:
 case IVD_CMD_GET_DISPLAY_FRAME:
 case IVD_CMD_VIDEO_DECODE:
 case IVD_CMD_DELETE:
 case IVD_CMD_VIDEO_CTL:
 if(ps_handle == NULL)
 {
 *(pu4_api_op + 1) |= 1 << IVD_UNSUPPORTEDPARAM;
 *(pu4_api_op + 1) |= IVD_HANDLE_NULL;
 return IV_FAIL;
 }

 if(ps_handle->u4_size != sizeof(iv_obj_t))
 {
 *(pu4_api_op + 1) |= 1 << IVD_UNSUPPORTEDPARAM;
 *(pu4_api_op + 1) |= IVD_HANDLE_STRUCT_SIZE_INCORRECT;
 return IV_FAIL;
 }

 if(ps_handle->pv_fxns != ih264d_api_function)
 {
 *(pu4_api_op + 1) |= 1 << IVD_UNSUPPORTEDPARAM;
 *(pu4_api_op + 1) |= IVD_INVALID_HANDLE_NULL;
 return IV_FAIL;
 }

 if(ps_handle->pv_codec_handle == NULL)
 {
 *(pu4_api_op + 1) |= 1 << IVD_UNSUPPORTEDPARAM;
 *(pu4_api_op + 1) |= IVD_INVALID_HANDLE_NULL;
 return IV_FAIL;
 }
 break;
 default:
 *(pu4_api_op + 1) |= 1 << IVD_UNSUPPORTEDPARAM;
 *(pu4_api_op + 1) |= IVD_INVALID_API_CMD;
 return IV_FAIL;
 }

 switch((WORD32)e_cmd)
 {
 case IVD_CMD_CREATE:
 {
 ih264d_create_ip_t *ps_ip = (ih264d_create_ip_t *)pv_api_ip;
 ih264d_create_op_t *ps_op = (ih264d_create_op_t *)pv_api_op;


            ps_op->s_ivd_create_op_t.u4_error_code = 0;

 if((ps_ip->s_ivd_create_ip_t.u4_size > sizeof(ih264d_create_ip_t))
 || (ps_ip->s_ivd_create_ip_t.u4_size
 < sizeof(ivd_create_ip_t)))
 {
                ps_op->s_ivd_create_op_t.u4_error_code |= 1
 << IVD_UNSUPPORTEDPARAM;
                ps_op->s_ivd_create_op_t.u4_error_code |=
                                IVD_IP_API_STRUCT_SIZE_INCORRECT;
                H264_DEC_DEBUG_PRINT("\n");
 return (IV_FAIL);
 }

 if((ps_op->s_ivd_create_op_t.u4_size != sizeof(ih264d_create_op_t))
 && (ps_op->s_ivd_create_op_t.u4_size
 != sizeof(ivd_create_op_t)))
 {
                ps_op->s_ivd_create_op_t.u4_error_code |= 1
 << IVD_UNSUPPORTEDPARAM;
                ps_op->s_ivd_create_op_t.u4_error_code |=
                                IVD_OP_API_STRUCT_SIZE_INCORRECT;
                H264_DEC_DEBUG_PRINT("\n");
 return (IV_FAIL);
 }


 if((ps_ip->s_ivd_create_ip_t.e_output_format != IV_YUV_420P)
 && (ps_ip->s_ivd_create_ip_t.e_output_format
 != IV_YUV_422ILE)
 && (ps_ip->s_ivd_create_ip_t.e_output_format
 != IV_RGB_565)
 && (ps_ip->s_ivd_create_ip_t.e_output_format
 != IV_YUV_420SP_UV)
 && (ps_ip->s_ivd_create_ip_t.e_output_format
 != IV_YUV_420SP_VU))
 {
                ps_op->s_ivd_create_op_t.u4_error_code |= 1
 << IVD_UNSUPPORTEDPARAM;
                ps_op->s_ivd_create_op_t.u4_error_code |=
                                IVD_INIT_DEC_COL_FMT_NOT_SUPPORTED;
                H264_DEC_DEBUG_PRINT("\n");
 return (IV_FAIL);
 }

 }
 break;

 case IVD_CMD_GET_DISPLAY_FRAME:
 {
 ih264d_get_display_frame_ip_t *ps_ip =
 (ih264d_get_display_frame_ip_t *)pv_api_ip;
 ih264d_get_display_frame_op_t *ps_op =
 (ih264d_get_display_frame_op_t *)pv_api_op;

            ps_op->s_ivd_get_display_frame_op_t.u4_error_code = 0;

 if((ps_ip->s_ivd_get_display_frame_ip_t.u4_size
 != sizeof(ih264d_get_display_frame_ip_t))
 && (ps_ip->s_ivd_get_display_frame_ip_t.u4_size
 != sizeof(ivd_get_display_frame_ip_t)))
 {
                ps_op->s_ivd_get_display_frame_op_t.u4_error_code |= 1
 << IVD_UNSUPPORTEDPARAM;
                ps_op->s_ivd_get_display_frame_op_t.u4_error_code |=
                                IVD_IP_API_STRUCT_SIZE_INCORRECT;
 return (IV_FAIL);
 }

 if((ps_op->s_ivd_get_display_frame_op_t.u4_size
 != sizeof(ih264d_get_display_frame_op_t))
 && (ps_op->s_ivd_get_display_frame_op_t.u4_size
 != sizeof(ivd_get_display_frame_op_t)))
 {
                ps_op->s_ivd_get_display_frame_op_t.u4_error_code |= 1
 << IVD_UNSUPPORTEDPARAM;
                ps_op->s_ivd_get_display_frame_op_t.u4_error_code |=
                                IVD_OP_API_STRUCT_SIZE_INCORRECT;
 return (IV_FAIL);
 }
 }
 break;

 case IVD_CMD_REL_DISPLAY_FRAME:
 {
 ih264d_rel_display_frame_ip_t *ps_ip =
 (ih264d_rel_display_frame_ip_t *)pv_api_ip;
 ih264d_rel_display_frame_op_t *ps_op =
 (ih264d_rel_display_frame_op_t *)pv_api_op;

            ps_op->s_ivd_rel_display_frame_op_t.u4_error_code = 0;

 if((ps_ip->s_ivd_rel_display_frame_ip_t.u4_size
 != sizeof(ih264d_rel_display_frame_ip_t))
 && (ps_ip->s_ivd_rel_display_frame_ip_t.u4_size
 != sizeof(ivd_rel_display_frame_ip_t)))
 {
                ps_op->s_ivd_rel_display_frame_op_t.u4_error_code |= 1
 << IVD_UNSUPPORTEDPARAM;
                ps_op->s_ivd_rel_display_frame_op_t.u4_error_code |=
                                IVD_IP_API_STRUCT_SIZE_INCORRECT;
 return (IV_FAIL);
 }

 if((ps_op->s_ivd_rel_display_frame_op_t.u4_size
 != sizeof(ih264d_rel_display_frame_op_t))
 && (ps_op->s_ivd_rel_display_frame_op_t.u4_size
 != sizeof(ivd_rel_display_frame_op_t)))
 {
                ps_op->s_ivd_rel_display_frame_op_t.u4_error_code |= 1
 << IVD_UNSUPPORTEDPARAM;
                ps_op->s_ivd_rel_display_frame_op_t.u4_error_code |=
                                IVD_OP_API_STRUCT_SIZE_INCORRECT;
 return (IV_FAIL);
 }

 }
 break;

 case IVD_CMD_SET_DISPLAY_FRAME:
 {
 ih264d_set_display_frame_ip_t *ps_ip =
 (ih264d_set_display_frame_ip_t *)pv_api_ip;
 ih264d_set_display_frame_op_t *ps_op =
 (ih264d_set_display_frame_op_t *)pv_api_op;
            UWORD32 j;

            ps_op->s_ivd_set_display_frame_op_t.u4_error_code = 0;

 if((ps_ip->s_ivd_set_display_frame_ip_t.u4_size
 != sizeof(ih264d_set_display_frame_ip_t))
 && (ps_ip->s_ivd_set_display_frame_ip_t.u4_size
 != sizeof(ivd_set_display_frame_ip_t)))
 {
                ps_op->s_ivd_set_display_frame_op_t.u4_error_code |= 1
 << IVD_UNSUPPORTEDPARAM;
                ps_op->s_ivd_set_display_frame_op_t.u4_error_code |=
                                IVD_IP_API_STRUCT_SIZE_INCORRECT;
 return (IV_FAIL);
 }

 if((ps_op->s_ivd_set_display_frame_op_t.u4_size
 != sizeof(ih264d_set_display_frame_op_t))
 && (ps_op->s_ivd_set_display_frame_op_t.u4_size
 != sizeof(ivd_set_display_frame_op_t)))
 {
                ps_op->s_ivd_set_display_frame_op_t.u4_error_code |= 1
 << IVD_UNSUPPORTEDPARAM;
                ps_op->s_ivd_set_display_frame_op_t.u4_error_code |=
                                IVD_OP_API_STRUCT_SIZE_INCORRECT;
 return (IV_FAIL);
 }

 if(ps_ip->s_ivd_set_display_frame_ip_t.num_disp_bufs == 0)
 {
                ps_op->s_ivd_set_display_frame_op_t.u4_error_code |= 1
 << IVD_UNSUPPORTEDPARAM;
                ps_op->s_ivd_set_display_frame_op_t.u4_error_code |=
                                IVD_DISP_FRM_ZERO_OP_BUFS;
 return IV_FAIL;
 }

 for(j = 0; j < ps_ip->s_ivd_set_display_frame_ip_t.num_disp_bufs;
                            j++)
 {
 if(ps_ip->s_ivd_set_display_frame_ip_t.s_disp_buffer[j].u4_num_bufs
 == 0)
 {
                    ps_op->s_ivd_set_display_frame_op_t.u4_error_code |= 1
 << IVD_UNSUPPORTEDPARAM;
                    ps_op->s_ivd_set_display_frame_op_t.u4_error_code |=
                                    IVD_DISP_FRM_ZERO_OP_BUFS;
 return IV_FAIL;
 }

 for(i = 0;
                                i
 < ps_ip->s_ivd_set_display_frame_ip_t.s_disp_buffer[j].u4_num_bufs;
                                i++)
 {
 if(ps_ip->s_ivd_set_display_frame_ip_t.s_disp_buffer[j].pu1_bufs[i]
 == NULL)
 {
                        ps_op->s_ivd_set_display_frame_op_t.u4_error_code |= 1
 << IVD_UNSUPPORTEDPARAM;
                        ps_op->s_ivd_set_display_frame_op_t.u4_error_code |=
                                        IVD_DISP_FRM_OP_BUF_NULL;
 return IV_FAIL;
 }

 if(ps_ip->s_ivd_set_display_frame_ip_t.s_disp_buffer[j].u4_min_out_buf_size[i]
 == 0)
 {
                        ps_op->s_ivd_set_display_frame_op_t.u4_error_code |= 1
 << IVD_UNSUPPORTEDPARAM;
                        ps_op->s_ivd_set_display_frame_op_t.u4_error_code |=
                                        IVD_DISP_FRM_ZERO_OP_BUF_SIZE;
 return IV_FAIL;
 }
 }
 }
 }
 break;

 case IVD_CMD_VIDEO_DECODE:
 {
 ih264d_video_decode_ip_t *ps_ip =
 (ih264d_video_decode_ip_t *)pv_api_ip;
 ih264d_video_decode_op_t *ps_op =
 (ih264d_video_decode_op_t *)pv_api_op;

            H264_DEC_DEBUG_PRINT("The input bytes is: %d",
                                 ps_ip->s_ivd_video_decode_ip_t.u4_num_Bytes);
            ps_op->s_ivd_video_decode_op_t.u4_error_code = 0;

 if(ps_ip->s_ivd_video_decode_ip_t.u4_size
 != sizeof(ih264d_video_decode_ip_t)&&
                            ps_ip->s_ivd_video_decode_ip_t.u4_size != offsetof(ivd_video_decode_ip_t, s_out_buffer))
 {
                ps_op->s_ivd_video_decode_op_t.u4_error_code |= 1
 << IVD_UNSUPPORTEDPARAM;
                ps_op->s_ivd_video_decode_op_t.u4_error_code |=
                                IVD_IP_API_STRUCT_SIZE_INCORRECT;
 return (IV_FAIL);
 }

 if(ps_op->s_ivd_video_decode_op_t.u4_size
 != sizeof(ih264d_video_decode_op_t)&&
                            ps_op->s_ivd_video_decode_op_t.u4_size != offsetof(ivd_video_decode_op_t, u4_output_present))
 {
                ps_op->s_ivd_video_decode_op_t.u4_error_code |= 1
 << IVD_UNSUPPORTEDPARAM;
                ps_op->s_ivd_video_decode_op_t.u4_error_code |=
                                IVD_OP_API_STRUCT_SIZE_INCORRECT;
 return (IV_FAIL);
 }

 }
 break;

 case IVD_CMD_DELETE:
 {
 ih264d_delete_ip_t *ps_ip =
 (ih264d_delete_ip_t *)pv_api_ip;
 ih264d_delete_op_t *ps_op =
 (ih264d_delete_op_t *)pv_api_op;

            ps_op->s_ivd_delete_op_t.u4_error_code = 0;

 if(ps_ip->s_ivd_delete_ip_t.u4_size
 != sizeof(ih264d_delete_ip_t))
 {
                ps_op->s_ivd_delete_op_t.u4_error_code |= 1
 << IVD_UNSUPPORTEDPARAM;
                ps_op->s_ivd_delete_op_t.u4_error_code |=
                                IVD_IP_API_STRUCT_SIZE_INCORRECT;
 return (IV_FAIL);
 }

 if(ps_op->s_ivd_delete_op_t.u4_size
 != sizeof(ih264d_delete_op_t))
 {
                ps_op->s_ivd_delete_op_t.u4_error_code |= 1
 << IVD_UNSUPPORTEDPARAM;
                ps_op->s_ivd_delete_op_t.u4_error_code |=
                                IVD_OP_API_STRUCT_SIZE_INCORRECT;
 return (IV_FAIL);
 }

 }
 break;

 case IVD_CMD_VIDEO_CTL:
 {
            UWORD32 *pu4_ptr_cmd;
            UWORD32 sub_command;

            pu4_ptr_cmd = (UWORD32 *)pv_api_ip;
            pu4_ptr_cmd += 2;
            sub_command = *pu4_ptr_cmd;

 switch(sub_command)
 {
 case IVD_CMD_CTL_SETPARAMS:
 {
 ih264d_ctl_set_config_ip_t *ps_ip;
 ih264d_ctl_set_config_op_t *ps_op;
                    ps_ip = (ih264d_ctl_set_config_ip_t *)pv_api_ip;
                    ps_op = (ih264d_ctl_set_config_op_t *)pv_api_op;

 if(ps_ip->s_ivd_ctl_set_config_ip_t.u4_size
 != sizeof(ih264d_ctl_set_config_ip_t))
 {
                        ps_op->s_ivd_ctl_set_config_op_t.u4_error_code |= 1
 << IVD_UNSUPPORTEDPARAM;
                        ps_op->s_ivd_ctl_set_config_op_t.u4_error_code |=
                                        IVD_IP_API_STRUCT_SIZE_INCORRECT;
 return IV_FAIL;
 }
 }
 case IVD_CMD_CTL_SETDEFAULT:
 {
 ih264d_ctl_set_config_op_t *ps_op;
                    ps_op = (ih264d_ctl_set_config_op_t *)pv_api_op;
 if(ps_op->s_ivd_ctl_set_config_op_t.u4_size
 != sizeof(ih264d_ctl_set_config_op_t))
 {
                        ps_op->s_ivd_ctl_set_config_op_t.u4_error_code |= 1
 << IVD_UNSUPPORTEDPARAM;
                        ps_op->s_ivd_ctl_set_config_op_t.u4_error_code |=
                                        IVD_OP_API_STRUCT_SIZE_INCORRECT;
 return IV_FAIL;
 }
 }
 break;

 case IVD_CMD_CTL_GETPARAMS:
 {
 ih264d_ctl_getstatus_ip_t *ps_ip;
 ih264d_ctl_getstatus_op_t *ps_op;

                    ps_ip = (ih264d_ctl_getstatus_ip_t *)pv_api_ip;
                    ps_op = (ih264d_ctl_getstatus_op_t *)pv_api_op;
 if(ps_ip->s_ivd_ctl_getstatus_ip_t.u4_size
 != sizeof(ih264d_ctl_getstatus_ip_t))
 {
                        ps_op->s_ivd_ctl_getstatus_op_t.u4_error_code |= 1
 << IVD_UNSUPPORTEDPARAM;
                        ps_op->s_ivd_ctl_getstatus_op_t.u4_error_code |=
                                        IVD_IP_API_STRUCT_SIZE_INCORRECT;
 return IV_FAIL;
 }
 if(ps_op->s_ivd_ctl_getstatus_op_t.u4_size
 != sizeof(ih264d_ctl_getstatus_op_t))
 {
                        ps_op->s_ivd_ctl_getstatus_op_t.u4_error_code |= 1
 << IVD_UNSUPPORTEDPARAM;
                        ps_op->s_ivd_ctl_getstatus_op_t.u4_error_code |=
                                        IVD_OP_API_STRUCT_SIZE_INCORRECT;
 return IV_FAIL;
 }
 }
 break;

 case IVD_CMD_CTL_GETBUFINFO:
 {
 ih264d_ctl_getbufinfo_ip_t *ps_ip;
 ih264d_ctl_getbufinfo_op_t *ps_op;
                    ps_ip = (ih264d_ctl_getbufinfo_ip_t *)pv_api_ip;
                    ps_op = (ih264d_ctl_getbufinfo_op_t *)pv_api_op;

 if(ps_ip->s_ivd_ctl_getbufinfo_ip_t.u4_size
 != sizeof(ih264d_ctl_getbufinfo_ip_t))
 {
                        ps_op->s_ivd_ctl_getbufinfo_op_t.u4_error_code |= 1
 << IVD_UNSUPPORTEDPARAM;
                        ps_op->s_ivd_ctl_getbufinfo_op_t.u4_error_code |=
                                        IVD_IP_API_STRUCT_SIZE_INCORRECT;
 return IV_FAIL;
 }
 if(ps_op->s_ivd_ctl_getbufinfo_op_t.u4_size
 != sizeof(ih264d_ctl_getbufinfo_op_t))
 {
                        ps_op->s_ivd_ctl_getbufinfo_op_t.u4_error_code |= 1
 << IVD_UNSUPPORTEDPARAM;
                        ps_op->s_ivd_ctl_getbufinfo_op_t.u4_error_code |=
                                        IVD_OP_API_STRUCT_SIZE_INCORRECT;
 return IV_FAIL;
 }
 }
 break;

 case IVD_CMD_CTL_GETVERSION:
 {
 ih264d_ctl_getversioninfo_ip_t *ps_ip;
 ih264d_ctl_getversioninfo_op_t *ps_op;
                    ps_ip = (ih264d_ctl_getversioninfo_ip_t *)pv_api_ip;
                    ps_op = (ih264d_ctl_getversioninfo_op_t *)pv_api_op;
 if(ps_ip->s_ivd_ctl_getversioninfo_ip_t.u4_size
 != sizeof(ih264d_ctl_getversioninfo_ip_t))
 {
                        ps_op->s_ivd_ctl_getversioninfo_op_t.u4_error_code |= 1
 << IVD_UNSUPPORTEDPARAM;
                        ps_op->s_ivd_ctl_getversioninfo_op_t.u4_error_code |=
                                        IVD_IP_API_STRUCT_SIZE_INCORRECT;
 return IV_FAIL;
 }
 if(ps_op->s_ivd_ctl_getversioninfo_op_t.u4_size
 != sizeof(ih264d_ctl_getversioninfo_op_t))
 {
                        ps_op->s_ivd_ctl_getversioninfo_op_t.u4_error_code |= 1
 << IVD_UNSUPPORTEDPARAM;
                        ps_op->s_ivd_ctl_getversioninfo_op_t.u4_error_code |=
                                        IVD_OP_API_STRUCT_SIZE_INCORRECT;
 return IV_FAIL;
 }
 }
 break;

 case IVD_CMD_CTL_FLUSH:
 {
 ih264d_ctl_flush_ip_t *ps_ip;
 ih264d_ctl_flush_op_t *ps_op;
                    ps_ip = (ih264d_ctl_flush_ip_t *)pv_api_ip;
                    ps_op = (ih264d_ctl_flush_op_t *)pv_api_op;
 if(ps_ip->s_ivd_ctl_flush_ip_t.u4_size
 != sizeof(ih264d_ctl_flush_ip_t))
 {
                        ps_op->s_ivd_ctl_flush_op_t.u4_error_code |= 1
 << IVD_UNSUPPORTEDPARAM;
                        ps_op->s_ivd_ctl_flush_op_t.u4_error_code |=
                                        IVD_IP_API_STRUCT_SIZE_INCORRECT;
 return IV_FAIL;
 }
 if(ps_op->s_ivd_ctl_flush_op_t.u4_size
 != sizeof(ih264d_ctl_flush_op_t))
 {
                        ps_op->s_ivd_ctl_flush_op_t.u4_error_code |= 1
 << IVD_UNSUPPORTEDPARAM;
                        ps_op->s_ivd_ctl_flush_op_t.u4_error_code |=
                                        IVD_OP_API_STRUCT_SIZE_INCORRECT;
 return IV_FAIL;
 }
 }
 break;

 case IVD_CMD_CTL_RESET:
 {
 ih264d_ctl_reset_ip_t *ps_ip;
 ih264d_ctl_reset_op_t *ps_op;
                    ps_ip = (ih264d_ctl_reset_ip_t *)pv_api_ip;
                    ps_op = (ih264d_ctl_reset_op_t *)pv_api_op;
 if(ps_ip->s_ivd_ctl_reset_ip_t.u4_size
 != sizeof(ih264d_ctl_reset_ip_t))
 {
                        ps_op->s_ivd_ctl_reset_op_t.u4_error_code |= 1
 << IVD_UNSUPPORTEDPARAM;
                        ps_op->s_ivd_ctl_reset_op_t.u4_error_code |=
                                        IVD_IP_API_STRUCT_SIZE_INCORRECT;
 return IV_FAIL;
 }
 if(ps_op->s_ivd_ctl_reset_op_t.u4_size
 != sizeof(ih264d_ctl_reset_op_t))
 {
                        ps_op->s_ivd_ctl_reset_op_t.u4_error_code |= 1
 << IVD_UNSUPPORTEDPARAM;
                        ps_op->s_ivd_ctl_reset_op_t.u4_error_code |=
                                        IVD_OP_API_STRUCT_SIZE_INCORRECT;
 return IV_FAIL;
 }
 }
 break;

 case IH264D_CMD_CTL_DEGRADE:
 {
 ih264d_ctl_degrade_ip_t *ps_ip;
 ih264d_ctl_degrade_op_t *ps_op;

                    ps_ip = (ih264d_ctl_degrade_ip_t *)pv_api_ip;
                    ps_op = (ih264d_ctl_degrade_op_t *)pv_api_op;

 if(ps_ip->u4_size != sizeof(ih264d_ctl_degrade_ip_t))
 {
                        ps_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                        ps_op->u4_error_code |=
                                        IVD_IP_API_STRUCT_SIZE_INCORRECT;
 return IV_FAIL;
 }

 if(ps_op->u4_size != sizeof(ih264d_ctl_degrade_op_t))
 {
                        ps_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                        ps_op->u4_error_code |=
                                        IVD_OP_API_STRUCT_SIZE_INCORRECT;
 return IV_FAIL;
 }

 if((ps_ip->i4_degrade_pics < 0)
 || (ps_ip->i4_degrade_pics > 4)
 || (ps_ip->i4_nondegrade_interval < 0)
 || (ps_ip->i4_degrade_type < 0)
 || (ps_ip->i4_degrade_type > 15))
 {
                        ps_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
 return IV_FAIL;
 }

 break;
 }

 case IH264D_CMD_CTL_GET_BUFFER_DIMENSIONS:
 {
 ih264d_ctl_get_frame_dimensions_ip_t *ps_ip;
 ih264d_ctl_get_frame_dimensions_op_t *ps_op;

                    ps_ip = (ih264d_ctl_get_frame_dimensions_ip_t *)pv_api_ip;
                    ps_op = (ih264d_ctl_get_frame_dimensions_op_t *)pv_api_op;

 if(ps_ip->u4_size
 != sizeof(ih264d_ctl_get_frame_dimensions_ip_t))
 {
                        ps_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                        ps_op->u4_error_code |=
                                        IVD_IP_API_STRUCT_SIZE_INCORRECT;
 return IV_FAIL;
 }

 if(ps_op->u4_size
 != sizeof(ih264d_ctl_get_frame_dimensions_op_t))
 {
                        ps_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                        ps_op->u4_error_code |=
                                        IVD_OP_API_STRUCT_SIZE_INCORRECT;
 return IV_FAIL;
 }

 break;
 }
 case IH264D_CMD_CTL_GET_VUI_PARAMS:
 {
 ih264d_ctl_get_vui_params_ip_t *ps_ip;
 ih264d_ctl_get_vui_params_op_t *ps_op;

                    ps_ip =
 (ih264d_ctl_get_vui_params_ip_t *)pv_api_ip;
                    ps_op =
 (ih264d_ctl_get_vui_params_op_t *)pv_api_op;

 if(ps_ip->u4_size
 != sizeof(ih264d_ctl_get_vui_params_ip_t))
 {
                        ps_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                        ps_op->u4_error_code |=
                                        IVD_IP_API_STRUCT_SIZE_INCORRECT;
 return IV_FAIL;
 }

 if(ps_op->u4_size
 != sizeof(ih264d_ctl_get_vui_params_op_t))
 {
                        ps_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                        ps_op->u4_error_code |=
                                        IVD_OP_API_STRUCT_SIZE_INCORRECT;
 return IV_FAIL;
 }

 break;
 }
 case IH264D_CMD_CTL_SET_NUM_CORES:
 {
 ih264d_ctl_set_num_cores_ip_t *ps_ip;
 ih264d_ctl_set_num_cores_op_t *ps_op;

                    ps_ip = (ih264d_ctl_set_num_cores_ip_t *)pv_api_ip;
                    ps_op = (ih264d_ctl_set_num_cores_op_t *)pv_api_op;

 if(ps_ip->u4_size != sizeof(ih264d_ctl_set_num_cores_ip_t))
 {
                        ps_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                        ps_op->u4_error_code |=
                                        IVD_IP_API_STRUCT_SIZE_INCORRECT;
 return IV_FAIL;
 }

 if(ps_op->u4_size != sizeof(ih264d_ctl_set_num_cores_op_t))
 {
                        ps_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                        ps_op->u4_error_code |=
                                        IVD_OP_API_STRUCT_SIZE_INCORRECT;
 return IV_FAIL;
 }

 if((ps_ip->u4_num_cores != 1) && (ps_ip->u4_num_cores != 2)
 && (ps_ip->u4_num_cores != 3)
 && (ps_ip->u4_num_cores != 4))
 {
                        ps_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
 return IV_FAIL;
 }
 break;
 }
 case IH264D_CMD_CTL_SET_PROCESSOR:
 {
 ih264d_ctl_set_processor_ip_t *ps_ip;
 ih264d_ctl_set_processor_op_t *ps_op;

                    ps_ip = (ih264d_ctl_set_processor_ip_t *)pv_api_ip;
                    ps_op = (ih264d_ctl_set_processor_op_t *)pv_api_op;

 if(ps_ip->u4_size != sizeof(ih264d_ctl_set_processor_ip_t))
 {
                        ps_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                        ps_op->u4_error_code |=
                                        IVD_IP_API_STRUCT_SIZE_INCORRECT;
 return IV_FAIL;
 }

 if(ps_op->u4_size != sizeof(ih264d_ctl_set_processor_op_t))
 {
                        ps_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                        ps_op->u4_error_code |=
                                        IVD_OP_API_STRUCT_SIZE_INCORRECT;
 return IV_FAIL;
 }

 break;
 }
 default:
 *(pu4_api_op + 1) |= 1 << IVD_UNSUPPORTEDPARAM;
 *(pu4_api_op + 1) |= IVD_UNSUPPORTED_API_CMD;
 return IV_FAIL;
 break;
 }
 }
 break;
 }

 return IV_SUCCESS;
}

WORD32 ih264d_parse_pic_timing(dec_bit_stream_t *ps_bitstrm,
 dec_struct_t *ps_dec,
                               UWORD32 ui4_payload_size)
{
    sei *ps_sei;
 vui_t *ps_vu4;
    UWORD8 u1_cpb_dpb_present;
    UWORD8 u1_pic_struct_present_flag;
    UWORD32 u4_start_offset, u4_bits_consumed;
    UWORD8 u1_cpb_removal_delay_length, u1_dpb_output_delay_length;

    ps_sei = (sei *)ps_dec->ps_sei;
    ps_vu4 = &ps_dec->ps_cur_sps->s_vui;

    u1_cpb_dpb_present = ps_vu4->u1_vcl_hrd_params_present
 + ps_vu4->u1_nal_hrd_params_present;

 if(ps_vu4->u1_vcl_hrd_params_present)
 {
        u1_cpb_removal_delay_length =
                        ps_vu4->s_vcl_hrd.u1_cpb_removal_delay_length;
        u1_dpb_output_delay_length =
                        ps_vu4->s_vcl_hrd.u1_dpb_output_delay_length;
 }
 else if(ps_vu4->u1_nal_hrd_params_present)
 {
        u1_cpb_removal_delay_length =
                        ps_vu4->s_nal_hrd.u1_cpb_removal_delay_length;
        u1_dpb_output_delay_length =
                        ps_vu4->s_nal_hrd.u1_dpb_output_delay_length;
 }
 else
 {
        u1_cpb_removal_delay_length = 24;
        u1_dpb_output_delay_length = 24;

 }

    u4_start_offset = ps_bitstrm->u4_ofst;
 if(u1_cpb_dpb_present)
 {
        ih264d_get_bits_h264(ps_bitstrm, u1_cpb_removal_delay_length);
        ih264d_get_bits_h264(ps_bitstrm, u1_dpb_output_delay_length);
 }

    u1_pic_struct_present_flag = ps_vu4->u1_pic_struct_present_flag;
 if(u1_pic_struct_present_flag)
 {
        ps_sei->u1_pic_struct = ih264d_get_bits_h264(ps_bitstrm, 4);
        ps_dec->u1_pic_struct_copy = ps_sei->u1_pic_struct;
        ps_sei->u1_is_valid = 1;
 }
    u4_bits_consumed = ps_bitstrm->u4_ofst - u4_start_offset;
    ih264d_flush_bits_h264(ps_bitstrm,
 (ui4_payload_size << 3) - u4_bits_consumed);

 return (0);
}

WORD32 ih264d_parse_sei_payload(dec_bit_stream_t *ps_bitstrm,
                                UWORD32 ui4_payload_type,
                                UWORD32 ui4_payload_size,
 dec_struct_t *ps_dec)
{
    sei *ps_sei;
    WORD32 i4_status = 0;
    ps_sei = (sei *)ps_dec->ps_sei;
 switch(ui4_payload_type)
 {
 case SEI_BUF_PERIOD:

            i4_status = ih264d_parse_buffering_period(&ps_sei->s_buf_period,
                                                      ps_bitstrm, ps_dec);
 /*if(i4_status != OK)
                return i4_status;*/
 break;
 case SEI_PIC_TIMING:
 if(NULL == ps_dec->ps_cur_sps)
                ih264d_flush_bits_h264(ps_bitstrm, (ui4_payload_size << 3));
 else
                ih264d_parse_pic_timing(ps_bitstrm, ps_dec,
                                        ui4_payload_size);
 break;
 case SEI_RECOVERY_PT:
            ih264d_parse_recovery_point(ps_bitstrm, ps_dec,
                                        ui4_payload_size);
 break;
 default:
            ih264d_flush_bits_h264(ps_bitstrm, (ui4_payload_size << 3));
 break;
 }
 return (i4_status);
}

WORD32 ih264d_get_vui_params(iv_obj_t *dec_hdl,
 void *pv_api_ip,
 void *pv_api_op)
{
 ih264d_ctl_get_vui_params_ip_t *ps_ip;
 ih264d_ctl_get_vui_params_op_t *ps_op;
 dec_struct_t *ps_dec = dec_hdl->pv_codec_handle;
 dec_seq_params_t *ps_sps;
 vui_t *ps_vui;
    WORD32 i;
    UWORD32 u4_size;

    ps_ip = (ih264d_ctl_get_vui_params_ip_t *)pv_api_ip;
    ps_op = (ih264d_ctl_get_vui_params_op_t *)pv_api_op;
    UNUSED(ps_ip);

    u4_size = ps_op->u4_size;
    memset(ps_op, 0, sizeof(ih264d_ctl_get_vui_params_op_t));
    ps_op->u4_size = u4_size;

 if(NULL == ps_dec->ps_cur_sps)
 {
        ps_op->u4_error_code = ERROR_VUI_PARAMS_NOT_FOUND;
 return IV_FAIL;
 }

    ps_sps = ps_dec->ps_cur_sps;
 if((0 == ps_sps->u1_is_valid)
 || (0 == ps_sps->u1_vui_parameters_present_flag))
 {
        ps_op->u4_error_code = ERROR_VUI_PARAMS_NOT_FOUND;
 return IV_FAIL;
 }

    ps_vui = &ps_sps->s_vui;

    ps_op->u1_aspect_ratio_idc              = ps_vui->u1_aspect_ratio_idc;
    ps_op->u2_sar_width                     = ps_vui->u2_sar_width;
    ps_op->u2_sar_height                    = ps_vui->u2_sar_height;
    ps_op->u1_overscan_appropriate_flag     = ps_vui->u1_overscan_appropriate_flag;
    ps_op->u1_video_format                  = ps_vui->u1_video_format;
    ps_op->u1_video_full_range_flag         = ps_vui->u1_video_full_range_flag;
    ps_op->u1_colour_primaries              = ps_vui->u1_colour_primaries;
    ps_op->u1_tfr_chars                     = ps_vui->u1_tfr_chars;
    ps_op->u1_matrix_coeffs                 = ps_vui->u1_matrix_coeffs;
    ps_op->u1_cr_top_field                  = ps_vui->u1_cr_top_field;
    ps_op->u1_cr_bottom_field               = ps_vui->u1_cr_bottom_field;
    ps_op->u4_num_units_in_tick             = ps_vui->u4_num_units_in_tick;
    ps_op->u4_time_scale                    = ps_vui->u4_time_scale;
    ps_op->u1_fixed_frame_rate_flag         = ps_vui->u1_fixed_frame_rate_flag;
    ps_op->u1_nal_hrd_params_present        = ps_vui->u1_nal_hrd_params_present;
    ps_op->u1_vcl_hrd_params_present        = ps_vui->u1_vcl_hrd_params_present;
    ps_op->u1_low_delay_hrd_flag            = ps_vui->u1_low_delay_hrd_flag;
    ps_op->u1_pic_struct_present_flag       = ps_vui->u1_pic_struct_present_flag;
    ps_op->u1_bitstream_restriction_flag    = ps_vui->u1_bitstream_restriction_flag;
    ps_op->u1_mv_over_pic_boundaries_flag   = ps_vui->u1_mv_over_pic_boundaries_flag;
    ps_op->u4_max_bytes_per_pic_denom       = ps_vui->u4_max_bytes_per_pic_denom;
    ps_op->u4_max_bits_per_mb_denom         = ps_vui->u4_max_bits_per_mb_denom;
    ps_op->u4_log2_max_mv_length_horz       = ps_vui->u4_log2_max_mv_length_horz;
    ps_op->u4_log2_max_mv_length_vert       = ps_vui->u4_log2_max_mv_length_vert;
    ps_op->u4_num_reorder_frames            = ps_vui->u4_num_reorder_frames;
    ps_op->u4_max_dec_frame_buffering       = ps_vui->u4_max_dec_frame_buffering;

 return IV_SUCCESS;
}

void ih264d_init_decoder(void * ps_dec_params)
{
 dec_struct_t * ps_dec = (dec_struct_t *)ps_dec_params;
 dec_slice_params_t *ps_cur_slice;
 pocstruct_t *ps_prev_poc, *ps_cur_poc;
    WORD32 size;

    size = sizeof(pred_info_t) * 2 * 32;
    memset(ps_dec->ps_pred, 0 , size);

    size = sizeof(disp_mgr_t);
    memset(ps_dec->pv_disp_buf_mgr, 0 , size);

    size = sizeof(buf_mgr_t) + ithread_get_mutex_lock_size();
    memset(ps_dec->pv_pic_buf_mgr, 0, size);

    size = sizeof(dec_err_status_t);
    memset(ps_dec->ps_dec_err_status, 0, size);

    size = sizeof(sei);
    memset(ps_dec->ps_sei, 0, size);

    size = sizeof(dpb_commands_t);
    memset(ps_dec->ps_dpb_cmds, 0, size);

    size = sizeof(dec_bit_stream_t);
    memset(ps_dec->ps_bitstrm, 0, size);

    size = sizeof(dec_slice_params_t);
    memset(ps_dec->ps_cur_slice, 0, size);

    size = MAX(sizeof(dec_seq_params_t), sizeof(dec_pic_params_t));
    memset(ps_dec->pv_scratch_sps_pps, 0, size);

    size = sizeof(ctxt_inc_mb_info_t);
    memset(ps_dec->ps_left_mb_ctxt_info, 0, size);

    size = (sizeof(neighbouradd_t) << 2);
    memset(ps_dec->ps_left_mvpred_addr, 0 ,size);

    size = sizeof(buf_mgr_t) + ithread_get_mutex_lock_size();
    memset(ps_dec->pv_mv_buf_mgr, 0, size);

 /* Free any dynamic buffers that are allocated */
    ih264d_free_dynamic_bufs(ps_dec);

    ps_cur_slice = ps_dec->ps_cur_slice;
    ps_dec->init_done = 0;

    ps_dec->u4_num_cores = 1;

    ps_dec->u2_pic_ht = ps_dec->u2_pic_wd = 0;

    ps_dec->u1_separate_parse = DEFAULT_SEPARATE_PARSE;
    ps_dec->u4_app_disable_deblk_frm = 0;
    ps_dec->i4_degrade_type = 0;
    ps_dec->i4_degrade_pics = 0;

    ps_dec->i4_app_skip_mode = IVD_SKIP_NONE;
    ps_dec->i4_dec_skip_mode = IVD_SKIP_NONE;

    memset(ps_dec->ps_pps, 0,
 ((sizeof(dec_pic_params_t)) * MAX_NUM_PIC_PARAMS));
    memset(ps_dec->ps_sps, 0,
 ((sizeof(dec_seq_params_t)) * MAX_NUM_SEQ_PARAMS));

 /* Initialization of function pointers ih264d_deblock_picture function*/

    ps_dec->p_DeblockPicture[0] = ih264d_deblock_picture_non_mbaff;
    ps_dec->p_DeblockPicture[1] = ih264d_deblock_picture_mbaff;

    ps_dec->s_cab_dec_env.pv_codec_handle = ps_dec;

    ps_dec->u4_num_fld_in_frm = 0;

    ps_dec->ps_dpb_mgr->pv_codec_handle = ps_dec;

 /* Initialize the sei validity u4_flag with zero indiacting sei is not valid*/
    ps_dec->ps_sei->u1_is_valid = 0;

 /* decParams Initializations */
    ps_dec->ps_cur_pps = NULL;
    ps_dec->ps_cur_sps = NULL;
    ps_dec->u1_init_dec_flag = 0;
    ps_dec->u1_first_slice_in_stream = 1;
    ps_dec->u1_last_pic_not_decoded = 0;
    ps_dec->u4_app_disp_width = 0;
    ps_dec->i4_header_decoded = 0;
    ps_dec->u4_total_frames_decoded = 0;

    ps_dec->i4_error_code = 0;
    ps_dec->i4_content_type = -1;
    ps_dec->ps_cur_slice->u1_mbaff_frame_flag = 0;

    ps_dec->ps_dec_err_status->u1_err_flag = ACCEPT_ALL_PICS; //REJECT_PB_PICS;
    ps_dec->ps_dec_err_status->u1_cur_pic_type = PIC_TYPE_UNKNOWN;
    ps_dec->ps_dec_err_status->u4_frm_sei_sync = SYNC_FRM_DEFAULT;
    ps_dec->ps_dec_err_status->u4_cur_frm = INIT_FRAME;
    ps_dec->ps_dec_err_status->u1_pic_aud_i = PIC_TYPE_UNKNOWN;

    ps_dec->u1_pr_sl_type = 0xFF;
    ps_dec->u2_mbx = 0xffff;
    ps_dec->u2_mby = 0;
    ps_dec->u2_total_mbs_coded = 0;

 /* POC initializations */
    ps_prev_poc = &ps_dec->s_prev_pic_poc;
    ps_cur_poc = &ps_dec->s_cur_pic_poc;
    ps_prev_poc->i4_pic_order_cnt_lsb = ps_cur_poc->i4_pic_order_cnt_lsb = 0;
    ps_prev_poc->i4_pic_order_cnt_msb = ps_cur_poc->i4_pic_order_cnt_msb = 0;
    ps_prev_poc->i4_delta_pic_order_cnt_bottom =
                    ps_cur_poc->i4_delta_pic_order_cnt_bottom = 0;
    ps_prev_poc->i4_delta_pic_order_cnt[0] =
                    ps_cur_poc->i4_delta_pic_order_cnt[0] = 0;
    ps_prev_poc->i4_delta_pic_order_cnt[1] =
                    ps_cur_poc->i4_delta_pic_order_cnt[1] = 0;
    ps_prev_poc->u1_mmco_equalto5 = ps_cur_poc->u1_mmco_equalto5 = 0;
    ps_prev_poc->i4_top_field_order_count = ps_cur_poc->i4_top_field_order_count =
 0;
    ps_prev_poc->i4_bottom_field_order_count =
                    ps_cur_poc->i4_bottom_field_order_count = 0;
    ps_prev_poc->u1_bot_field = ps_cur_poc->u1_bot_field = 0;
    ps_prev_poc->u1_mmco_equalto5 = ps_cur_poc->u1_mmco_equalto5 = 0;
    ps_prev_poc->i4_prev_frame_num_ofst = ps_cur_poc->i4_prev_frame_num_ofst = 0;
    ps_cur_slice->u1_mmco_equalto5 = 0;
    ps_cur_slice->u2_frame_num = 0;

    ps_dec->i4_max_poc = 0;
    ps_dec->i4_prev_max_display_seq = 0;
    ps_dec->u1_recon_mb_grp = 4;

 /* Field PIC initializations */
    ps_dec->u1_second_field = 0;
    ps_dec->s_prev_seq_params.u1_eoseq_pending = 0;

 /* Set the cropping parameters as zero */
    ps_dec->u2_crop_offset_y = 0;
    ps_dec->u2_crop_offset_uv = 0;

 /* The Initial Frame Rate Info is not Present */
    ps_dec->i4_vui_frame_rate = -1;
    ps_dec->i4_pic_type = -1;
    ps_dec->i4_frametype = -1;
    ps_dec->i4_content_type = -1;

    ps_dec->u1_res_changed = 0;


    ps_dec->u1_frame_decoded_flag = 0;

 /* Set the default frame seek mask mode */
    ps_dec->u4_skip_frm_mask = SKIP_NONE;

 /********************************************************/
 /* Initialize CAVLC residual decoding function pointers */
 /********************************************************/
    ps_dec->pf_cavlc_4x4res_block[0] = ih264d_cavlc_4x4res_block_totalcoeff_1;
    ps_dec->pf_cavlc_4x4res_block[1] =
                    ih264d_cavlc_4x4res_block_totalcoeff_2to10;
    ps_dec->pf_cavlc_4x4res_block[2] =
                    ih264d_cavlc_4x4res_block_totalcoeff_11to16;

    ps_dec->pf_cavlc_parse4x4coeff[0] = ih264d_cavlc_parse4x4coeff_n0to7;
    ps_dec->pf_cavlc_parse4x4coeff[1] = ih264d_cavlc_parse4x4coeff_n8;

    ps_dec->pf_cavlc_parse_8x8block[0] =
                    ih264d_cavlc_parse_8x8block_none_available;
    ps_dec->pf_cavlc_parse_8x8block[1] =
                    ih264d_cavlc_parse_8x8block_left_available;
    ps_dec->pf_cavlc_parse_8x8block[2] =
                    ih264d_cavlc_parse_8x8block_top_available;
    ps_dec->pf_cavlc_parse_8x8block[3] =
                    ih264d_cavlc_parse_8x8block_both_available;

 /***************************************************************************/
 /* Initialize Bs calculation function pointers for P and B, 16x16/non16x16 */
 /***************************************************************************/
    ps_dec->pf_fill_bs1[0][0] = ih264d_fill_bs1_16x16mb_pslice;
    ps_dec->pf_fill_bs1[0][1] = ih264d_fill_bs1_non16x16mb_pslice;

    ps_dec->pf_fill_bs1[1][0] = ih264d_fill_bs1_16x16mb_bslice;
    ps_dec->pf_fill_bs1[1][1] = ih264d_fill_bs1_non16x16mb_bslice;

    ps_dec->pf_fill_bs_xtra_left_edge[0] =
                    ih264d_fill_bs_xtra_left_edge_cur_frm;
    ps_dec->pf_fill_bs_xtra_left_edge[1] =
                    ih264d_fill_bs_xtra_left_edge_cur_fld;

 /* Initialize Reference Pic Buffers */
    ih264d_init_ref_bufs(ps_dec->ps_dpb_mgr);

    ps_dec->u2_prv_frame_num = 0;
    ps_dec->u1_top_bottom_decoded = 0;
    ps_dec->u1_dangling_field = 0;

    ps_dec->s_cab_dec_env.cabac_table = gau4_ih264d_cabac_table;

    ps_dec->pu1_left_mv_ctxt_inc = ps_dec->u1_left_mv_ctxt_inc_arr[0];
    ps_dec->pi1_left_ref_idx_ctxt_inc =
 &ps_dec->i1_left_ref_idx_ctx_inc_arr[0][0];
    ps_dec->pu1_left_yuv_dc_csbp = &ps_dec->u1_yuv_dc_csbp_topmb;

 /* ! */
 /* Initializing flush frame u4_flag */
    ps_dec->u1_flushfrm = 0;

 {
        ps_dec->s_cab_dec_env.pv_codec_handle = (void*)ps_dec;
        ps_dec->ps_bitstrm->pv_codec_handle = (void*)ps_dec;
        ps_dec->ps_cur_slice->pv_codec_handle = (void*)ps_dec;
        ps_dec->ps_dpb_mgr->pv_codec_handle = (void*)ps_dec;
 }

    memset(ps_dec->disp_bufs, 0, (MAX_DISP_BUFS_NEW) * sizeof(disp_buf_t));
    memset(ps_dec->u4_disp_buf_mapping, 0,
 (MAX_DISP_BUFS_NEW) * sizeof(UWORD32));
    memset(ps_dec->u4_disp_buf_to_be_freed, 0,
 (MAX_DISP_BUFS_NEW) * sizeof(UWORD32));
    memset(ps_dec->ps_cur_slice, 0, sizeof(dec_slice_params_t));

    ih264d_init_arch(ps_dec);
    ih264d_init_function_ptr(ps_dec);
    ps_dec->e_frm_out_mode = IVD_DISPLAY_FRAME_OUT;
    ps_dec->init_done = 1;

}

WORD32 ih264d_get_buf_info(iv_obj_t *dec_hdl, void *pv_api_ip, void *pv_api_op)
{

 dec_struct_t * ps_dec;
    UWORD8 i = 0; // Default for 420P format
    UWORD16 pic_wd, pic_ht;
 ivd_ctl_getbufinfo_op_t *ps_ctl_op =
 (ivd_ctl_getbufinfo_op_t*)pv_api_op;
    UWORD32 au4_min_out_buf_size[IVD_VIDDEC_MAX_IO_BUFFERS];
    UNUSED(pv_api_ip);

    ps_ctl_op->u4_error_code = 0;

    ps_dec = (dec_struct_t *)(dec_hdl->pv_codec_handle);

    ps_ctl_op->u4_min_num_in_bufs = MIN_IN_BUFS;


    ps_ctl_op->u4_num_disp_bufs = 1;


    pic_wd = 0;
    pic_ht = 0;

 if(ps_dec->i4_header_decoded == 3)
 {

 if(0 == ps_dec->u4_share_disp_buf)
 {
            pic_wd = ps_dec->u2_disp_width;
            pic_ht = ps_dec->u2_disp_height;

 }
 else
 {
            pic_wd = ps_dec->u2_frm_wd_y;
            pic_ht = ps_dec->u2_frm_ht_y;
 }

 }

 for(i = 0; i < ps_ctl_op->u4_min_num_in_bufs; i++)
 {
        ps_ctl_op->u4_min_in_buf_size[i] = MAX(256000, pic_wd * pic_ht * 3 / 2);
 }
 if((WORD32)ps_dec->u4_app_disp_width > pic_wd)
        pic_wd = ps_dec->u4_app_disp_width;

 if(0 == ps_dec->u4_share_disp_buf)
        ps_ctl_op->u4_num_disp_bufs = 1;
 else
 {
 if((NULL != ps_dec->ps_cur_sps) && (1 == (ps_dec->ps_cur_sps->u1_is_valid)))
 {
 if((ps_dec->ps_cur_sps->u1_vui_parameters_present_flag == 1) &&
 (1 == ps_dec->ps_cur_sps->s_vui.u1_bitstream_restriction_flag))
 {
                ps_ctl_op->u4_num_disp_bufs =
                                ps_dec->ps_cur_sps->s_vui.u4_num_reorder_frames + 1;
 }
 else
 {
 /*if VUI is not present assume maximum possible refrence frames for the level,
                 * as max reorder frames*/
                ps_ctl_op->u4_num_disp_bufs = ih264d_get_dpb_size(ps_dec->ps_cur_sps);
 }

            ps_ctl_op->u4_num_disp_bufs +=
                            ps_dec->ps_cur_sps->u1_num_ref_frames + 1;

 }
 else
 {
            ps_ctl_op->u4_num_disp_bufs = 32;

 }

        ps_ctl_op->u4_num_disp_bufs = MAX(
                        ps_ctl_op->u4_num_disp_bufs, 6);
        ps_ctl_op->u4_num_disp_bufs = MIN(
                        ps_ctl_op->u4_num_disp_bufs, 32);
 }

    ps_ctl_op->u4_min_num_out_bufs = ih264d_get_outbuf_size(
                    pic_wd, pic_ht, ps_dec->u1_chroma_format,
 &au4_min_out_buf_size[0]);

 for(i = 0; i < ps_ctl_op->u4_min_num_out_bufs; i++)
 {
        ps_ctl_op->u4_min_out_buf_size[i] = au4_min_out_buf_size[i];
 }

    ps_dec->u4_num_disp_bufs_requested = ps_ctl_op->u4_num_disp_bufs;

 return IV_SUCCESS;
}

WORD32 check_app_out_buf_size(dec_struct_t *ps_dec)
{
    UWORD32 au4_min_out_buf_size[IVD_VIDDEC_MAX_IO_BUFFERS];
    UWORD32 u4_min_num_out_bufs, i;
    UWORD32 pic_wd, pic_ht;

 if(0 == ps_dec->u4_share_disp_buf)
 {
        pic_wd = ps_dec->u2_disp_width;
        pic_ht = ps_dec->u2_disp_height;

 }
 else
 {
 /* In case of shared mode, do not check validity of ps_dec->ps_out_buffer */
 return (IV_SUCCESS);
 }

 if(ps_dec->u4_app_disp_width > pic_wd)
        pic_wd = ps_dec->u4_app_disp_width;

    u4_min_num_out_bufs = ih264d_get_outbuf_size(pic_wd, pic_ht,
                                                 ps_dec->u1_chroma_format,
 &au4_min_out_buf_size[0]);

 if(ps_dec->ps_out_buffer->u4_num_bufs < u4_min_num_out_bufs)
 return IV_FAIL;

 for(i = 0; i < u4_min_num_out_bufs; i++)
 {
 if(ps_dec->ps_out_buffer->u4_min_out_buf_size[i]
 < au4_min_out_buf_size[i])
 return (IV_FAIL);
 }

 return (IV_SUCCESS);
}

WORD32 ih264d_set_flush_mode(iv_obj_t *dec_hdl, void *pv_api_ip, void *pv_api_op)
{
 dec_struct_t * ps_dec;
 ivd_ctl_flush_op_t *ps_ctl_op = (ivd_ctl_flush_op_t*)pv_api_op;
    ps_ctl_op->u4_error_code = 0;

    ps_dec = (dec_struct_t *)(dec_hdl->pv_codec_handle);
    UNUSED(pv_api_ip);
 /* ! */
 /* Signal flush frame control call */
    ps_dec->u1_flushfrm = 1;

 if(ps_dec->u1_init_dec_flag == 1)
 {
        ih264d_release_pics_in_dpb((void *)ps_dec, ps_dec->u1_pic_bufs);
        ih264d_release_display_bufs(ps_dec);
 }

    ps_ctl_op->u4_error_code = 0;

 /* Ignore dangling fields during flush */
    ps_dec->u1_top_bottom_decoded = 0;

 return IV_SUCCESS;
}

WORD32 ih264d_parse_buffering_period(buf_period_t *ps_buf_prd,
 dec_bit_stream_t *ps_bitstrm,
 dec_struct_t *ps_dec)
{
    UWORD8 u1_seq_parameter_set_id;
 dec_seq_params_t *ps_seq;
    UWORD8 u1_nal_hrd_present, u1_vcl_hrd_present;
    UWORD32 i;
    UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;
    UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
    UNUSED(ps_buf_prd);
    u1_seq_parameter_set_id = ih264d_uev(pu4_bitstrm_ofst,
                                         pu4_bitstrm_buf);
 if(u1_seq_parameter_set_id >= MAX_NUM_SEQ_PARAMS)
 return ERROR_INVALID_SEQ_PARAM;
    ps_seq = &ps_dec->ps_sps[u1_seq_parameter_set_id];
 if(TRUE != ps_seq->u1_is_valid)
 return (-1);

    ps_dec->ps_sei->u1_seq_param_set_id = u1_seq_parameter_set_id;
    ps_dec->ps_cur_sps = ps_seq;
 if(FALSE == ps_seq->u1_is_valid)
 return ERROR_INVALID_SEQ_PARAM;
 if(1 == ps_seq->u1_vui_parameters_present_flag)
 {
        u1_nal_hrd_present = ps_seq->s_vui.u1_nal_hrd_params_present;
 if(u1_nal_hrd_present)
 {
 for(i = 0; i < ps_seq->s_vui.s_nal_hrd.u4_cpb_cnt; i++)
 {
                ih264d_get_bits_h264(
                                ps_bitstrm,
                                ps_seq->s_vui.s_nal_hrd.u1_initial_cpb_removal_delay);
                ih264d_get_bits_h264(
                                ps_bitstrm,
                                ps_seq->s_vui.s_nal_hrd.u1_initial_cpb_removal_delay);
 }
 }

        u1_vcl_hrd_present = ps_seq->s_vui.u1_vcl_hrd_params_present;
 if(u1_vcl_hrd_present)
 {
 for(i = 0; i < ps_seq->s_vui.s_vcl_hrd.u4_cpb_cnt; i++)
 {
                ih264d_get_bits_h264(
                                ps_bitstrm,
                                ps_seq->s_vui.s_vcl_hrd.u1_initial_cpb_removal_delay);
                ih264d_get_bits_h264(
                                ps_bitstrm,
                                ps_seq->s_vui.s_vcl_hrd.u1_initial_cpb_removal_delay);
 }
 }
 }
 return OK;
}
