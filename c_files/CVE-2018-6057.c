  const Microsoft::WRL::ComPtr<ISensorManager>& sensor_manager() const {
    return sensor_manager_;
  }

void PlatformSensorFusion::Create(
    mojo::ScopedSharedBufferMapping mapping,
PlatformSensorProvider* provider,
std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,
const PlatformSensorProviderBase::CreateSensorCallback& callback) {
  Factory::CreateSensorFusion(std::move(mapping), std::move(fusion_algorithm),
callback, provider);
}

bool FakePlatformSensor::CheckSensorConfiguration(
    const PlatformSensorConfiguration& configuration) {
  return configuration.frequency() <= GetMaximumSupportedFrequency() &&
         configuration.frequency() >= GetMinimumSupportedFrequency();
}

void PlatformSensorProviderLinux::ProcessStoredRequests() {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
  std::vector<mojom::SensorType> request_types = GetPendingRequestTypes();
  if (request_types.empty())
    return;

  for (auto const& type : request_types) {
    if (IsFusionSensorType(type))
      continue;

    SensorInfoLinux* device = nullptr;
    auto device_entry = sensor_devices_by_type_.find(type);
    if (device_entry != sensor_devices_by_type_.end())
      device = device_entry->second.get();
    CreateSensorAndNotify(type, device);
  }
}

void PlatformSensor::UpdateSharedBuffer(const SensorReading& reading) {
  ReadingBuffer* buffer =
      static_cast<ReadingBuffer*>(shared_buffer_mapping_.get());
auto& seqlock = buffer->seqlock.value();
seqlock.WriteBegin();
buffer->reading = reading;
seqlock.WriteEnd();
}

bool PlatformSensorLinux::StartSensor(
    const PlatformSensorConfiguration& configuration) {
  DCHECK(task_runner_->BelongsToCurrentThread());
  polling_thread_task_runner_->PostTask(
      FROM_HERE,
      base::Bind(&SensorReader::StartFetchingData,
                 base::Unretained(sensor_reader_.get()), configuration));
  return true;
}

bool PlatformSensorProviderBase::HasSensors() const {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
  return !sensor_map_.empty();
}

MockPlatformSensorClient::~MockPlatformSensorClient() {
  if (sensor_)
    sensor_->RemoveClient(this);
}

PlatformSensorAccelerometerMac::PlatformSensorAccelerometerMac(
    mojo::ScopedSharedBufferMapping mapping,
PlatformSensorProvider* provider)
    : PlatformSensor(SensorType::ACCELEROMETER, std::move(mapping), provider),
sudden_motion_sensor_(SuddenMotionSensor::Create()) {}

mojo::ScopedSharedBufferMapping FakePlatformSensorProvider::GetMapping(
mojom::SensorType type) {
  return CreateSharedBufferIfNeeded() ? MapSharedBufferForType(type) : nullptr;
}

PlatformSensorProviderAndroid::PlatformSensorProviderAndroid() {
  JNIEnv* env = AttachCurrentThread();
  j_object_.Reset(Java_PlatformSensorProvider_create(env));
}

PlatformSensorFusion::PlatformSensorFusion(
    mojo::ScopedSharedBufferMapping mapping,
PlatformSensorProvider* provider,
std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,
PlatformSensorFusion::SourcesMap sources)
    : PlatformSensor(fusion_algorithm->fused_type(),
                     std::move(mapping),
                     provider),
fusion_algorithm_(std::move(fusion_algorithm)),
source_sensors_(std::move(sources)),
reporting_mode_(mojom::ReportingMode::CONTINUOUS) {
for (const auto& pair : source_sensors_)
pair.second->AddClient(this);

fusion_algorithm_->set_fusion_sensor(this);

if (std::any_of(source_sensors_.begin(), source_sensors_.end(),
[](const SourcesMapEntry& pair) {
return pair.second->GetReportingMode() ==
mojom::ReportingMode::ON_CHANGE;
})) {
reporting_mode_ = mojom::ReportingMode::ON_CHANGE;
}
}

PlatformSensorAmbientLightMac::PlatformSensorAmbientLightMac(
    mojo::ScopedSharedBufferMapping mapping,
PlatformSensorProvider* provider)
    : PlatformSensor(SensorType::AMBIENT_LIGHT, std::move(mapping), provider),
light_sensor_port_(nullptr),
current_lux_(0.0) {}

  void CreateMagnetometer() {
    auto callback = base::Bind(&PlatformSensorFusionTest::MagnetometerCallback,
                               base::Unretained(this));
    provider_->CreateSensor(SensorType::MAGNETOMETER, callback);
    EXPECT_TRUE(magnetometer_callback_called_);
    EXPECT_TRUE(magnetometer_);
    EXPECT_EQ(SensorType::MAGNETOMETER, magnetometer_->GetType());
  }

bool PlatformSensorAndroid::CheckSensorConfiguration(
    const PlatformSensorConfiguration& configuration) {
  JNIEnv* env = AttachCurrentThread();
  return Java_PlatformSensor_checkSensorConfiguration(
      env, j_object_, configuration.frequency());
}

void PlatformSensorProviderWin::CreateSensorInternal(
mojom::SensorType type,
    mojo::ScopedSharedBufferMapping mapping,
const CreateSensorCallback& callback) {
DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
if (!StartSensorThread()) {
callback.Run(nullptr);
return;
}

switch (type) {
// Fusion sensor.
case mojom::SensorType::LINEAR_ACCELERATION: {
auto linear_acceleration_fusion_algorithm = std::make_unique<
LinearAccelerationFusionAlgorithmUsingAccelerometer>();
// If this PlatformSensorFusion object is successfully initialized,
// |callback| will be run with a reference to this object.
PlatformSensorFusion::Create(
          std::move(mapping), this,
          std::move(linear_acceleration_fusion_algorithm), callback);
break;
}

// Try to create low-level sensors by default.
default: {
base::PostTaskAndReplyWithResult(
sensor_thread_->task_runner().get(), FROM_HERE,
base::Bind(&PlatformSensorProviderWin::CreateSensorReader,
base::Unretained(this), type),
base::Bind(&PlatformSensorProviderWin::SensorReaderCreated,
                     base::Unretained(this), type, base::Passed(&mapping),
                     callback));
break;
}
}
}

void PlatformSensorAmbientLightMac::StopSensor() {
  light_sensor_port_.reset();
  light_sensor_notification_.reset();
  light_sensor_busy_notification_.reset();
  light_sensor_object_.reset();
  light_sensor_service_.reset();
  current_lux_ = 0.0;
}

void PlatformSensorProviderLinux::SetFileTaskRunner(
    scoped_refptr<base::SingleThreadTaskRunner> file_task_runner) {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
  if (!file_task_runner_)
    file_task_runner_ = file_task_runner;
}

void PlatformSensorAndroid::UpdatePlatformSensorReading(
    JNIEnv*,
    const base::android::JavaRef<jobject>& caller,
    jdouble timestamp,
    jdouble value1,
    jdouble value2,
    jdouble value3,
    jdouble value4) {
  SensorReading reading;
  reading.raw.timestamp = timestamp;
  reading.raw.values[0] = value1;
  reading.raw.values[1] = value2;
  reading.raw.values[2] = value3;
  reading.raw.values[3] = value4;

  UpdateSharedBufferAndNotifyClients(reading);
}

void PlatformSensorProviderLinux::Shutdown() {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
  const bool did_post_task = file_task_runner_->DeleteSoon(
      FROM_HERE, sensor_device_manager_.release());
  DCHECK(did_post_task);
  sensor_nodes_enumerated_ = false;
  sensor_nodes_enumeration_started_ = false;
  sensor_devices_by_type_.clear();
}

SensorInfoLinux* PlatformSensorProviderLinux::GetSensorDevice(
    mojom::SensorType type) {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
  auto sensor = sensor_devices_by_type_.find(type);
  if (sensor == sensor_devices_by_type_.end())
    return nullptr;
  return sensor->second.get();
}

PlatformSensorProviderLinux::~PlatformSensorProviderLinux() {
  DCHECK(!sensor_device_manager_);
}

bool HaveValuesChanged(const SensorReading& lhs, const SensorReading& rhs) {
  for (size_t i = 0; i < SensorReadingRaw::kValuesCount; ++i) {
    if (lhs.raw.values[i] != rhs.raw.values[i])
      return true;
  }
  return false;
}

bool PlatformSensorFusion::GetSourceReading(mojom::SensorType type,
                                            SensorReading* result) {
  auto it = source_sensors_.find(type);
  if (it != source_sensors_.end())
    return it->second->GetLatestReading(result);
  NOTREACHED();
  return false;
}

void PlatformSensorProviderMac::CreateSensorInternal(
mojom::SensorType type,
    mojo::ScopedSharedBufferMapping mapping,
const CreateSensorCallback& callback) {
// Create Sensors here.
switch (type) {
case mojom::SensorType::AMBIENT_LIGHT: {
scoped_refptr<PlatformSensor> sensor =
          new PlatformSensorAmbientLightMac(std::move(mapping), this);
callback.Run(std::move(sensor));
break;
}
case mojom::SensorType::ACCELEROMETER: {
callback.Run(base::MakeRefCounted<PlatformSensorAccelerometerMac>(
          std::move(mapping), this));
break;
}
case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES: {
auto fusion_algorithm = std::make_unique<
RelativeOrientationEulerAnglesFusionAlgorithmUsingAccelerometer>();
// If this PlatformSensorFusion object is successfully initialized,
// |callback| will be run with a reference to this object.
      PlatformSensorFusion::Create(std::move(mapping), this,
std::move(fusion_algorithm), callback);
break;
}
case mojom::SensorType::RELATIVE_ORIENTATION_QUATERNION: {
auto orientation_quaternion_fusion_algorithm_using_euler_angles =
std::make_unique<
OrientationQuaternionFusionAlgorithmUsingEulerAngles>(
false /* absolute */);
// If this PlatformSensorFusion object is successfully initialized,
// |callback| will be run with a reference to this object.
PlatformSensorFusion::Create(
          std::move(mapping), this,
std::move(orientation_quaternion_fusion_algorithm_using_euler_angles),
callback);
break;
}
default:
callback.Run(nullptr);
}
}

FakePlatformSensor::FakePlatformSensor(mojom::SensorType type,
                                       mojo::ScopedSharedBufferMapping mapping,
                                       PlatformSensorProvider* provider)
    : PlatformSensor(type, std::move(mapping), provider) {
ON_CALL(*this, StartSensor(_))
.WillByDefault(
Invoke([this](const PlatformSensorConfiguration& configuration) {
SensorReading reading;
// Only mocking the shared memory update for AMBIENT_LIGHT type is
// enough.
if (GetType() == mojom::SensorType::AMBIENT_LIGHT) {
// Set the shared buffer value as frequency for testing purpose.
reading.als.value = configuration.frequency();
UpdateSharedBufferAndNotifyClients(reading);
}
return true;
}));
}

bool PlatformSensorAccelerometerMac::CheckSensorConfiguration(
    const PlatformSensorConfiguration& configuration) {
  return configuration.frequency() > 0 &&
         configuration.frequency() <=
             SensorTraits<SensorType::ACCELEROMETER>::kMaxAllowedFrequency;
}

PlatformSensorConfiguration PlatformSensorFusion::GetDefaultConfiguration() {
  PlatformSensorConfiguration default_configuration;
  for (const auto& pair : source_sensors_) {
    double frequency = pair.second->GetDefaultConfiguration().frequency();
    if (frequency > default_configuration.frequency())
      default_configuration.set_frequency(frequency);
  }
  return default_configuration;
}

bool IsFusionSensorType(mojom::SensorType type) {
  switch (type) {
    case mojom::SensorType::LINEAR_ACCELERATION:
    case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES:
    case mojom::SensorType::RELATIVE_ORIENTATION_QUATERNION:
      return true;
    default:
      return false;
  }
}

double FakePlatformSensor::GetMaximumSupportedFrequency() {
  return 50.0;
}

void PlatformSensorProviderLinux::CreateFusionSensor(
mojom::SensorType type,
    mojo::ScopedSharedBufferMapping mapping,
const CreateSensorCallback& callback) {
DCHECK(IsFusionSensorType(type));
std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm;
switch (type) {
case mojom::SensorType::LINEAR_ACCELERATION:
fusion_algorithm = std::make_unique<
LinearAccelerationFusionAlgorithmUsingAccelerometer>();
break;
case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES:
fusion_algorithm = std::make_unique<
RelativeOrientationEulerAnglesFusionAlgorithmUsingAccelerometer>();
break;
case mojom::SensorType::RELATIVE_ORIENTATION_QUATERNION:
fusion_algorithm = std::make_unique<
OrientationQuaternionFusionAlgorithmUsingEulerAngles>(
false /* absolute */);
break;
default:
NOTREACHED();
}

DCHECK(fusion_algorithm);
  PlatformSensorFusion::Create(std::move(mapping), this,
std::move(fusion_algorithm), callback);
}

bool PlatformSensorProviderWin::StartSensorThread() {
  CreateSensorThread();
  if (!sensor_thread_->IsRunning())
    return sensor_thread_->Start();
  return true;
}

void PlatformSensor::AddClient(Client* client) {
  DCHECK(client);
  clients_.AddObserver(client);
}

void PlatformSensorProviderLinux::SensorDeviceFound(
mojom::SensorType type,
    mojo::ScopedSharedBufferMapping mapping,
const PlatformSensorProviderBase::CreateSensorCallback& callback,
const SensorInfoLinux* sensor_device) {
DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
DCHECK(sensor_device);

if (!StartPollingThread()) {
callback.Run(nullptr);
return;
}

scoped_refptr<PlatformSensorLinux> sensor =
      new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,
polling_thread_->task_runner());
callback.Run(sensor);
}

  void FetchSources() {
    for (mojom::SensorType type : fusion_algorithm_->source_types()) {
      scoped_refptr<PlatformSensor> sensor = provider_->GetSensor(type);
      if (sensor) {
        SensorCreated(std::move(sensor));
      } else {
        provider_->CreateSensor(type,
                                base::Bind(&Factory::SensorCreated, this));
      }
    }
  }

bool PlatformSensorProviderLinux::StartPollingThread() {
  if (!polling_thread_)
    polling_thread_.reset(new base::Thread("Sensor polling thread"));

  if (!polling_thread_->IsRunning()) {
    return polling_thread_->StartWithOptions(
        base::Thread::Options(base::MessageLoop::TYPE_IO, 0));
  }
  return true;
}

void PlatformSensor::RemoveClient(Client* client) {
  DCHECK(client);
  clients_.RemoveObserver(client);
  StopListening(client);
}

  void AccelerometerCallback(scoped_refptr<PlatformSensor> sensor) {
    accelerometer_callback_called_ = true;
    accelerometer_ = static_cast<FakePlatformSensor*>(sensor.get());
  }

PlatformSensorConfiguration PlatformSensorAndroid::GetDefaultConfiguration() {
  JNIEnv* env = AttachCurrentThread();
  jdouble frequency =
      Java_PlatformSensor_getDefaultConfiguration(env, j_object_);
  return PlatformSensorConfiguration(frequency);
}

PlatformSensorConfiguration PlatformSensorLinux::GetDefaultConfiguration() {
  DCHECK(task_runner_->BelongsToCurrentThread());
  return default_configuration_;
}

PlatformSensorProviderBase::MapSharedBufferForType(mojom::SensorType type) {
  mojo::ScopedSharedBufferMapping mapping = shared_buffer_handle_->MapAtOffset(
      kReadingBufferSize, SensorReadingSharedBuffer::GetOffset(type));
  if (mapping)
    memset(mapping.get(), 0, kReadingBufferSize);
  return mapping;
}

void FakePlatformSensorProvider::CreateSensorInternal(
mojom::SensorType type,
    mojo::ScopedSharedBufferMapping mapping,
const CreateSensorCallback& callback) {
DCHECK(type >= mojom::SensorType::FIRST && type <= mojom::SensorType::LAST);
auto sensor =
      base::MakeRefCounted<FakePlatformSensor>(type, std::move(mapping), this);
DoCreateSensorInternal(type, std::move(sensor), callback);
}

bool PlatformSensorFusion::CheckSensorConfiguration(
    const PlatformSensorConfiguration& configuration) {
  for (const auto& pair : source_sensors_) {
    if (!pair.second->CheckSensorConfiguration(configuration))
      return false;
  }
  return true;
}

mojom::ReportingMode PlatformSensorAmbientLightMac::GetReportingMode() {
  return mojom::ReportingMode::ON_CHANGE;
}

PlatformSensorWin::~PlatformSensorWin() {
  sensor_reader_->SetClient(nullptr);
  sensor_thread_runner_->DeleteSoon(FROM_HERE, sensor_reader_);
}

MockPlatformSensorClient::MockPlatformSensorClient(
    scoped_refptr<PlatformSensor> sensor)
    : MockPlatformSensorClient() {
  DCHECK(sensor);
  sensor_ = std::move(sensor);
  sensor_->AddClient(this);
}

void PlatformSensorProviderBase::NotifySensorCreated(
    mojom::SensorType type,
    scoped_refptr<PlatformSensor> sensor) {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
  DCHECK(!ContainsKey(sensor_map_, type));
  DCHECK(ContainsKey(requests_map_, type));

  if (sensor)
    sensor_map_[type] = sensor.get();

  auto it = requests_map_.find(type);
  CallbackQueue callback_queue = it->second;
  requests_map_.erase(type);

  FreeResourcesIfNeeded();

  for (auto& callback : callback_queue)
    callback.Run(sensor);
}

PlatformSensorWin::PlatformSensorWin(
mojom::SensorType type,
    mojo::ScopedSharedBufferMapping mapping,
PlatformSensorProvider* provider,
scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,
std::unique_ptr<PlatformSensorReaderWin> sensor_reader)
    : PlatformSensor(type, std::move(mapping), provider),
sensor_thread_runner_(sensor_thread_runner),
sensor_reader_(sensor_reader.release()),
weak_factory_(this) {
DCHECK(sensor_reader_);
sensor_reader_->SetClient(this);
}

bool PlatformSensorLinux::CheckSensorConfiguration(
    const PlatformSensorConfiguration& configuration) {
  DCHECK(task_runner_->BelongsToCurrentThread());
  return configuration.frequency() > 0 &&
         configuration.frequency() <= default_configuration_.frequency();
}

bool PlatformSensor::StopListening(Client* client,
                                   const PlatformSensorConfiguration& config) {
  DCHECK(clients_.HasObserver(client));
  auto client_entry = config_map_.find(client);
  if (client_entry == config_map_.end())
    return false;

  auto& config_list = client_entry->second;
  auto config_entry = std::find(config_list.begin(), config_list.end(), config);
  if (config_entry == config_list.end())
    return false;

  config_list.erase(config_entry);

  return UpdateSensorInternal(config_map_);
}

void PlatformSensorProviderLinux::CreateSensorInternal(
mojom::SensorType type,
    mojo::ScopedSharedBufferMapping mapping,
const CreateSensorCallback& callback) {
if (!sensor_device_manager_)
sensor_device_manager_.reset(new SensorDeviceManager());

if (IsFusionSensorType(type)) {
// For sensor fusion the device nodes initialization will happen
// during fetching the source sensors.
    CreateFusionSensor(type, std::move(mapping), callback);
return;
}

if (!sensor_nodes_enumerated_) {
if (!sensor_nodes_enumeration_started_) {
sensor_nodes_enumeration_started_ = file_task_runner_->PostTask(
FROM_HERE,
base::Bind(&SensorDeviceManager::Start,
base::Unretained(sensor_device_manager_.get()), this));
}
return;
}

SensorInfoLinux* sensor_device = GetSensorDevice(type);
if (!sensor_device) {
callback.Run(nullptr);
return;
}

  SensorDeviceFound(type, std::move(mapping), callback, sensor_device);
}

MockPlatformSensorClient::MockPlatformSensorClient() {
  ON_CALL(*this, IsSuspended()).WillByDefault(Return(false));
}

PlatformSensor::PlatformSensor(mojom::SensorType type,
                               mojo::ScopedSharedBufferMapping mapping,
PlatformSensorProvider* provider)
: task_runner_(base::ThreadTaskRunnerHandle::Get()),
      shared_buffer_mapping_(std::move(mapping)),
type_(type),
provider_(provider),
weak_factory_(this) {}

scoped_refptr<PlatformSensor> PlatformSensorProviderBase::GetSensor(
    mojom::SensorType type) {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);

  auto it = sensor_map_.find(type);
  if (it != sensor_map_.end())
    return it->second;
  return nullptr;
}

mojom::ReportingMode PlatformSensorAccelerometerMac::GetReportingMode() {
  return mojom::ReportingMode::ON_CHANGE;
}

void PlatformSensor::NotifySensorReadingChanged() {
  for (auto& client : clients_) {
    if (!client.IsSuspended())
      client.OnSensorReadingChanged(type_);
  }
}

mojom::SensorType PlatformSensor::GetType() const {
  return type_;
}

void PlatformSensorProviderBase::RemoveSensor(mojom::SensorType type,
                                              PlatformSensor* sensor) {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
  auto it = sensor_map_.find(type);
  if (it == sensor_map_.end()) {
    return;
  }

  if (sensor != it->second) {
    NOTREACHED()
        << "not expecting to track more than one sensor of the same type";
    return;
  }

  sensor_map_.erase(type);
  FreeResourcesIfNeeded();
}

bool PlatformSensorAmbientLightMac::StartSensor(
    const PlatformSensorConfiguration& configuration) {

  light_sensor_service_.reset(IOServiceGetMatchingService(
      kIOMasterPortDefault, IOServiceMatching("AppleLMUController")));

  if (!light_sensor_service_)
    return false;

  light_sensor_port_.reset(IONotificationPortCreate(kIOMasterPortDefault));
  if (!light_sensor_port_.is_valid())
    return false;

  IONotificationPortSetDispatchQueue(
      light_sensor_port_.get(),
      dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0));

  kern_return_t kr = IOServiceAddInterestNotification(
      light_sensor_port_.get(), light_sensor_service_, kIOGeneralInterest,
      IOServiceCallback, this, light_sensor_notification_.InitializeInto());
  if (kr != KERN_SUCCESS)
    return false;

  kr = IOServiceAddInterestNotification(
      light_sensor_port_.get(), light_sensor_service_, kIOBusyInterest,
      IOServiceCallback, this,
      light_sensor_busy_notification_.InitializeInto());
  if (kr != KERN_SUCCESS)
    return false;

  kr = IOServiceOpen(light_sensor_service_, mach_task_self(), 0,
                     light_sensor_object_.InitializeInto());
  if (kr != KERN_SUCCESS)
    return false;

  bool success = ReadAndUpdate();
  if (!success)
    StopSensor();

  return success;
}

PlatformSensorProviderWin::CreateSensorReader(mojom::SensorType type) {
  DCHECK(sensor_thread_->task_runner()->BelongsToCurrentThread());
  if (!sensor_thread_->sensor_manager())
    return nullptr;
  return PlatformSensorReaderWin::Create(type,
                                         sensor_thread_->sensor_manager());
}

 void PlatformSensorProviderBase::FreeResourcesIfNeeded() {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   if (sensor_map_.empty() && requests_map_.empty()) {
     FreeResources();
     shared_buffer_handle_.reset();
   }
 }

PlatformSensorProviderBase::GetPendingRequestTypes() {
  std::vector<mojom::SensorType> request_types;
  for (auto const& entry : requests_map_)
    request_types.push_back(entry.first);
   return request_types;
 }

mojom::ReportingMode PlatformSensorWin::GetReportingMode() {
  return mojom::ReportingMode::ON_CHANGE;
}

bool IsSignificantlyDifferent(const device::SensorReading& reading1,
                              const device::SensorReading& reading2) {
  return (std::fabs(reading1.accel.x - reading2.accel.x) >=
          kGravityThreshold) ||
         (std::fabs(reading1.accel.y - reading2.accel.y) >=
          kGravityThreshold) ||
         (std::fabs(reading1.accel.z - reading2.accel.z) >= kGravityThreshold);
}

  void CreateLinearAccelerationFusionSensor() {
    auto fusion_algorithm =
        std::make_unique<LinearAccelerationFusionAlgorithmUsingAccelerometer>();
    CreateFusionSensor(std::move(fusion_algorithm));
  }

Factory(mojo::ScopedSharedBufferMapping mapping,
std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,
const PlatformSensorProviderBase::CreateSensorCallback& callback,
PlatformSensorProvider* provider)
: fusion_algorithm_(std::move(fusion_algorithm)),
result_callback_(std::move(callback)),
        mapping_(std::move(mapping)),
provider_(provider) {
const auto& types = fusion_algorithm_->source_types();
DCHECK(!types.empty());
// Make sure there are no dups.
DCHECK(std::adjacent_find(types.begin(), types.end()) == types.end());
DCHECK(result_callback_);
    DCHECK(mapping_);
DCHECK(provider_);
}

void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(
JNIEnv* env,
    mojo::ScopedSharedBufferMapping mapping,
const CreateSensorCallback& callback) {
if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(
env, j_object_,
static_cast<jint>(
mojom::SensorType::RELATIVE_ORIENTATION_QUATERNION)))) {
auto sensor_fusion_algorithm =
std::make_unique<OrientationEulerAnglesFusionAlgorithmUsingQuaternion>(
false /* absolute */);

// If this PlatformSensorFusion object is successfully initialized,
// |callback| will be run with a reference to this object.
    PlatformSensorFusion::Create(std::move(mapping), this,
std::move(sensor_fusion_algorithm), callback);
} else {
callback.Run(nullptr);
}
}

PlatformSensorProviderAndroid* PlatformSensorProviderAndroid::GetInstance() {
  return base::Singleton<
      PlatformSensorProviderAndroid,
      base::LeakySingletonTraits<PlatformSensorProviderAndroid>>::get();
}

  SensorThread() : base::Thread("Sensor thread") { init_com_with_mta(true); }

void PlatformSensorProviderWin::SensorReaderCreated(
mojom::SensorType type,
    mojo::ScopedSharedBufferMapping mapping,
const CreateSensorCallback& callback,
std::unique_ptr<PlatformSensorReaderWin> sensor_reader) {
DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
if (!sensor_reader) {
callback.Run(nullptr);
return;
}

scoped_refptr<PlatformSensor> sensor = new PlatformSensorWin(
      type, std::move(mapping), this, sensor_thread_->task_runner(),
std::move(sensor_reader));
callback.Run(sensor);
}

  PlatformSensorFusionTest() {
    provider_ = std::make_unique<FakePlatformSensorProvider>();
    PlatformSensorProvider::SetProviderForTesting(provider_.get());
  }

void PlatformSensor::UpdateSensor() {
  UpdateSensorInternal(config_map_);
}

bool PlatformSensor::StopListening(Client* client) {
  DCHECK(client);
  auto client_entry = config_map_.find(client);
  if (client_entry == config_map_.end())
    return false;

  config_map_.erase(client_entry);

  return UpdateSensorInternal(config_map_);
}

PlatformSensorAndroid::~PlatformSensorAndroid() {
  JNIEnv* env = AttachCurrentThread();
  Java_PlatformSensor_sensorDestroyed(env, j_object_);
}

bool PlatformSensorFusion::StartSensor(
    const PlatformSensorConfiguration& configuration) {
  StopSensor();
  for (const auto& pair : source_sensors_) {
    if (!pair.second->StartListening(this, configuration)) {
      StopSensor();
      return false;
    }
  }

  fusion_algorithm_->SetFrequency(configuration.frequency());
  return true;
}

void PlatformSensorLinux::NotifyPlatformSensorError() {
  DCHECK(task_runner_->BelongsToCurrentThread());
  NotifySensorError();
}

PlatformSensorProviderLinux::PlatformSensorProviderLinux()
    : sensor_nodes_enumerated_(false),
      sensor_nodes_enumeration_started_(false),
      sensor_device_manager_(nullptr) {}

double PlatformSensorAndroid::GetMaximumSupportedFrequency() {
  JNIEnv* env = AttachCurrentThread();
  return Java_PlatformSensor_getMaximumSupportedFrequency(env, j_object_);
}

void CreateFusionSensor(
std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm) {
auto callback =
base::Bind(&PlatformSensorFusionTest::PlatformSensorFusionCallback,
base::Unretained(this));
SensorType type = fusion_algorithm->fused_type();
    PlatformSensorFusion::Create(provider_->GetMapping(type), provider_.get(),
                                 std::move(fusion_algorithm), callback);
EXPECT_TRUE(platform_sensor_fusion_callback_called_);
}

PlatformSensorAndroid::PlatformSensorAndroid(
mojom::SensorType type,
    mojo::ScopedSharedBufferMapping mapping,
PlatformSensorProvider* provider,
const JavaRef<jobject>& java_sensor)
    : PlatformSensor(type, std::move(mapping), provider) {
JNIEnv* env = AttachCurrentThread();
j_object_.Reset(java_sensor);

Java_PlatformSensor_initPlatformSensorAndroid(env, j_object_,
reinterpret_cast<jlong>(this));
}

void PlatformSensorProviderBase::CreateSensor(
mojom::SensorType type,
const CreateSensorCallback& callback) {
DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);

if (!CreateSharedBufferIfNeeded()) {
callback.Run(nullptr);
return;
}

  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);
  if (!mapping) {
callback.Run(nullptr);
return;
}

auto it = requests_map_.find(type);
if (it != requests_map_.end()) {
it->second.push_back(callback);
} else {  // This is the first CreateSensor call.
requests_map_[type] = CallbackQueue({callback});

CreateSensorInternal(
        type, std::move(mapping),
base::Bind(&PlatformSensorProviderBase::NotifySensorCreated,
base::Unretained(this), type));
}
}

void SensorCreated(scoped_refptr<PlatformSensor> sensor) {
if (!result_callback_) {
// It is possible, if this callback has been already called
// with nullptr (i.e. failed to fetch some of the required
// source sensors). See the condition below.
return;
}

if (!sensor) {
std::move(result_callback_).Run(nullptr);
return;
}
mojom::SensorType type = sensor->GetType();
sources_map_[type] = std::move(sensor);
if (sources_map_.size() == fusion_algorithm_->source_types().size()) {
scoped_refptr<PlatformSensor> fusion_sensor(new PlatformSensorFusion(
          std::move(mapping_), provider_, std::move(fusion_algorithm_),
std::move(sources_map_)));
std::move(result_callback_).Run(fusion_sensor);
}
}

PlatformSensor::~PlatformSensor() {
  if (provider_)
    provider_->RemoveSensor(GetType(), this);
}

bool PlatformSensor::StartListening(Client* client,
                                    const PlatformSensorConfiguration& config) {
  DCHECK(clients_.HasObserver(client));
  if (!CheckSensorConfiguration(config))
    return false;

  auto& config_list = config_map_[client];
  config_list.push_back(config);

  if (!UpdateSensorInternal(config_map_)) {
    config_list.pop_back();
    return false;
  }

  return true;
}

PlatformSensorConfiguration PlatformSensorWin::GetDefaultConfiguration() {
  return PlatformSensorConfiguration(kDefaultSensorReportingFrequency);
}

void PlatformSensorLinux::UpdatePlatformSensorReading(SensorReading reading) {
  DCHECK(task_runner_->BelongsToCurrentThread());
  if (GetReportingMode() == mojom::ReportingMode::ON_CHANGE &&
      !HaveValuesChanged(reading, old_values_)) {
    return;
  }
  old_values_ = reading;
  reading.raw.timestamp =
      (base::TimeTicks::Now() - base::TimeTicks()).InSecondsF();
  UpdateSharedBufferAndNotifyClients(reading);
}

void PlatformSensorFusion::OnSensorReadingChanged(mojom::SensorType type) {
  SensorReading reading;
  reading.raw.timestamp =
      (base::TimeTicks::Now() - base::TimeTicks()).InSecondsF();

  if (!fusion_algorithm_->GetFusedData(type, &reading))
    return;

  if (GetReportingMode() == mojom::ReportingMode::ON_CHANGE &&
      !fusion_algorithm_->IsReadingSignificantlyDifferent(reading_, reading)) {
    return;
  }

  reading_ = reading;
  UpdateSharedBufferAndNotifyClients(reading_);
}

void PlatformSensorLinux::StopSensor() {
  DCHECK(task_runner_->BelongsToCurrentThread());
  polling_thread_task_runner_->PostTask(
      FROM_HERE, base::Bind(&SensorReader::StopFetchingData,
                            base::Unretained(sensor_reader_.get())));
}

bool PlatformSensorAmbientLightMac::CheckSensorConfiguration(
    const PlatformSensorConfiguration& configuration) {
  return configuration.frequency() > 0 &&
         configuration.frequency() <=
             SensorTraits<SensorType::AMBIENT_LIGHT>::kMaxAllowedFrequency;
}

mojom::ReportingMode FakePlatformSensor::GetReportingMode() {
  return mojom::ReportingMode::ON_CHANGE;
}

void PlatformSensor::UpdateSharedBufferAndNotifyClients(
    const SensorReading& reading) {
  UpdateSharedBuffer(reading);
  task_runner_->PostTask(FROM_HERE,
                         base::Bind(&PlatformSensor::NotifySensorReadingChanged,
                                    weak_factory_.GetWeakPtr()));
 }

void PlatformSensorAndroid::NotifyPlatformSensorError(
    JNIEnv*,
    const JavaRef<jobject>& caller) {
  task_runner_->PostTask(
      FROM_HERE, base::Bind(&PlatformSensorAndroid::NotifySensorError, this));
}

double PlatformSensorWin::GetMaximumSupportedFrequency() {
  double minimal_reporting_interval_ms =
      sensor_reader_->GetMinimalReportingIntervalMs();
  if (!minimal_reporting_interval_ms)
    return kDefaultSensorReportingFrequency;
  return base::Time::kMillisecondsPerSecond / minimal_reporting_interval_ms;
}

PlatformSensorConfiguration FakePlatformSensor::GetDefaultConfiguration() {
  return PlatformSensorConfiguration(30.0);
}

  void PlatformSensorFusionCallback(scoped_refptr<PlatformSensor> sensor) {
    platform_sensor_fusion_callback_called_ = true;
    fusion_sensor_ = static_cast<PlatformSensorFusion*>(sensor.get());
  }

void PlatformSensorProviderAndroid::SetSensorManagerToNullForTesting() {
  JNIEnv* env = AttachCurrentThread();
  Java_PlatformSensorProvider_setSensorManagerToNullForTesting(env, j_object_);
}

void PlatformSensorProviderLinux::SetFileTaskRunnerForTesting(
    scoped_refptr<base::SingleThreadTaskRunner> task_runner) {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
  file_task_runner_ = std::move(task_runner);
}

void PlatformSensorWin::OnReadingUpdated(const SensorReading& reading) {
  UpdateSharedBufferAndNotifyClients(reading);
}

void PlatformSensorProviderAndroid::CreateSensorInternal(
mojom::SensorType type,
    mojo::ScopedSharedBufferMapping mapping,
const CreateSensorCallback& callback) {
JNIEnv* env = AttachCurrentThread();

// Some of the sensors may not be available depending on the device and
// Android version, so the fallback ensures selection of the best possible
// option.
switch (type) {
case mojom::SensorType::ABSOLUTE_ORIENTATION_EULER_ANGLES:
      CreateAbsoluteOrientationEulerAnglesSensor(env, std::move(mapping),
                                                 callback);
break;
case mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION:
      CreateAbsoluteOrientationQuaternionSensor(env, std::move(mapping),
                                                callback);
break;
case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES:
      CreateRelativeOrientationEulerAnglesSensor(env, std::move(mapping),
                                                 callback);
break;
default: {
ScopedJavaLocalRef<jobject> sensor =
Java_PlatformSensorProvider_createSensor(env, j_object_,
static_cast<jint>(type));

if (!sensor.obj()) {
callback.Run(nullptr);
return;
}

auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(
          type, std::move(mapping), this, sensor);
callback.Run(concrete_sensor);
break;
}
}
}

static void CreateSensorFusion(
      mojo::ScopedSharedBufferMapping mapping,
std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,
const PlatformSensorProviderBase::CreateSensorCallback& callback,
PlatformSensorProvider* provider) {
    scoped_refptr<Factory> factory(new Factory(std::move(mapping),
std::move(fusion_algorithm),
std::move(callback), provider));
factory->FetchSources();
}

bool PlatformSensorProviderBase::CreateSharedBufferIfNeeded() {
DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
  if (shared_buffer_handle_.is_valid())
return true;

  shared_buffer_handle_ =
      mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);
  return shared_buffer_handle_.is_valid();
}

void PlatformSensorProviderLinux::GetAllSensorDevices() {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
  NOTIMPLEMENTED();
}

void PlatformSensorAccelerometerMac::PollForData() {
  float axis_value[3];
  if (!sudden_motion_sensor_->ReadSensorValues(axis_value))
    return;

  SensorReading reading;
  reading.accel.timestamp =
      (base::TimeTicks::Now() - base::TimeTicks()).InSecondsF();
  reading.accel.x = axis_value[0] * kMeanGravity;
  reading.accel.y = axis_value[1] * kMeanGravity;
  reading.accel.z = axis_value[2] * kMeanGravity;

  if (IsSignificantlyDifferent(reading_, reading)) {
    reading_ = reading;
    UpdateSharedBufferAndNotifyClients(reading);
  }
}

mojom::ReportingMode PlatformSensorAndroid::GetReportingMode() {
  JNIEnv* env = AttachCurrentThread();
  return static_cast<mojom::ReportingMode>(
      Java_PlatformSensor_getReportingMode(env, j_object_));
}

bool PlatformSensorAndroid::StartSensor(
    const PlatformSensorConfiguration& configuration) {
  JNIEnv* env = AttachCurrentThread();
  return Java_PlatformSensor_startSensor(env, j_object_,
                                         configuration.frequency());
}

double PlatformSensor::GetMaximumSupportedFrequency() {
  return GetDefaultConfiguration().frequency();
}

PlatformSensorProviderBase::CloneSharedBufferHandle() {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
  CreateSharedBufferIfNeeded();
  return shared_buffer_handle_->Clone(
      mojo::SharedBufferHandle::AccessMode::READ_ONLY);
}

  void SetSensorManagerForTesting(
      Microsoft::WRL::ComPtr<ISensorManager> sensor_manager) {
    sensor_manager_ = sensor_manager;
  }

void PlatformSensorProviderWin::SetSensorManagerForTesting(
    Microsoft::WRL::ComPtr<ISensorManager> sensor_manager) {
  CreateSensorThread();
  sensor_thread_->SetSensorManagerForTesting(sensor_manager);
}

mojom::ReportingMode PlatformSensorFusion::GetReportingMode() {
  return reporting_mode_;
}

mojom::ReportingMode PlatformSensorLinux::GetReportingMode() {
  DCHECK(task_runner_->BelongsToCurrentThread());
  return reporting_mode_;
}

void PlatformSensorWin::OnSensorError() {
  task_runner_->PostTask(FROM_HERE,
                         base::Bind(&PlatformSensorWin::NotifySensorError,
                                    weak_factory_.GetWeakPtr()));
}

  void CreateAccelerometer() {
    auto callback = base::Bind(&PlatformSensorFusionTest::AccelerometerCallback,
                               base::Unretained(this));
    provider_->CreateSensor(SensorType::ACCELEROMETER, callback);
    EXPECT_TRUE(accelerometer_callback_called_);
    EXPECT_TRUE(accelerometer_);
    EXPECT_EQ(SensorType::ACCELEROMETER, accelerometer_->GetType());
  }

bool PlatformSensorFusion::IsSuspended() {
  for (auto& client : clients_) {
    if (!client.IsSuspended())
      return false;
  }
  return true;
}

void PlatformSensorWin::StopSensor() {
  DCHECK(task_runner_->BelongsToCurrentThread());
  sensor_reader_->StopSensor();
}

double PlatformSensor::GetMinimumSupportedFrequency() {
  return 1.0 / (60 * 60);
}

void PlatformSensorProviderLinux::CreateSensorAndNotify(
mojom::SensorType type,
SensorInfoLinux* sensor_device) {
DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
scoped_refptr<PlatformSensorLinux> sensor;
  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);
  if (sensor_device && mapping && StartPollingThread()) {
    sensor =
        new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,
                                polling_thread_->task_runner());
}
NotifySensorCreated(type, sensor);
}

PlatformSensorLinux::PlatformSensorLinux(
mojom::SensorType type,
    mojo::ScopedSharedBufferMapping mapping,
PlatformSensorProvider* provider,
const SensorInfoLinux* sensor_device,
scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner)
    : PlatformSensor(type, std::move(mapping), provider),
default_configuration_(
PlatformSensorConfiguration(sensor_device->device_frequency)),
reporting_mode_(sensor_device->reporting_mode),
polling_thread_task_runner_(std::move(polling_thread_task_runner)),
weak_factory_(this) {
sensor_reader_ = SensorReader::Create(
sensor_device, weak_factory_.GetWeakPtr(), task_runner_);
}

  void MagnetometerCallback(scoped_refptr<PlatformSensor> sensor) {
    magnetometer_callback_called_ = true;
    magnetometer_ = static_cast<FakePlatformSensor*>(sensor.get());
  }
