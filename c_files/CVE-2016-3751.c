update_display(struct display *dp)
/* called once after the first read to update all the info, original_pp and
* original_ip must have been filled in.
*/
{
png_structp pp;
png_infop   ip;

/* Now perform the initial read with a 0 tranform. */
read_png(dp, &dp->original_file, "original read", 0/*no transform*/);

/* Move the result to the 'original' fields */
dp->original_pp = pp = dp->read_pp, dp->read_pp = NULL;
dp->original_ip = ip = dp->read_ip, dp->read_ip = NULL;

dp->original_rowbytes = png_get_rowbytes(pp, ip);
if (dp->original_rowbytes == 0)
display_log(dp, LIBPNG_BUG, "png_get_rowbytes returned 0");

dp->chunks = png_get_valid(pp, ip, 0xffffffff);
if ((dp->chunks & PNG_INFO_IDAT) == 0) /* set by png_read_png */
display_log(dp, LIBPNG_BUG, "png_read_png did not set IDAT flag");

dp->original_rows = png_get_rows(pp, ip);
if (dp->original_rows == NULL)
display_log(dp, LIBPNG_BUG, "png_read_png did not create row buffers");

if (!png_get_IHDR(pp, ip,
&dp->width, &dp->height, &dp->bit_depth, &dp->color_type,
&dp->interlace_method, &dp->compression_method, &dp->filter_method))
display_log(dp, LIBPNG_BUG, "png_get_IHDR failed");

/* 'active' transforms are discovered based on the original image format;
* running one active transform can activate others.  At present the code
* does not attempt to determine the closure.
*/
{
png_uint_32 chunks = dp->chunks;
int active = 0, inactive = 0;
int ct = dp->color_type;

int bd = dp->bit_depth;
unsigned int i;

      for (i=0; i<TTABLE_SIZE; ++i)
{
int transform = transform_info[i].transform;

if ((transform_info[i].valid_chunks == 0 ||
(transform_info[i].valid_chunks & chunks) != 0) &&
            (transform_info[i].color_mask_required & ct) == 
transform_info[i].color_mask_required &&
(transform_info[i].color_mask_absent & ct) == 0 &&
(transform_info[i].bit_depths & bd) != 0 &&
(transform_info[i].when & TRANSFORM_R) != 0)
active |= transform;

else if ((transform_info[i].when & TRANSFORM_R) != 0)
inactive |= transform;
}

/* Some transforms appear multiple times in the table; the 'active' status
* is the logical OR of these and the inactive status must be adjusted to
* take this into account.
*/
inactive &= ~active;


dp->active_transforms = active;
dp->ignored_transforms = inactive; /* excluding write-only transforms */
      if (active == 0)
         display_log(dp, INTERNAL_ERROR, "bad transform table");
}
}

transform_info_imp(transform_display *dp, png_structp pp, png_infop pi)
{
/* Reuse the standard stuff as appropriate. */
standard_info_part1(&dp->this, pp, pi);

/* Now set the list of transforms. */
dp->transform_list->set(dp->transform_list, dp, pp, pi);

/* Update the info structure for these transforms: */
{
int i = dp->this.use_update_info;
/* Always do one call, even if use_update_info is 0. */
do
png_read_update_info(pp, pi);
while (--i > 0);
}

/* And get the output information into the standard_display */
standard_info_part2(&dp->this, pp, pi, 1/*images*/);

/* Plus the extra stuff we need for the transform tests: */

dp->output_colour_type = png_get_color_type(pp, pi);
dp->output_bit_depth = png_get_bit_depth(pp, pi);

/* Validate the combination of colour type and bit depth that we are getting
* out of libpng; the semantics of something not in the PNG spec are, at
* best, unclear.
*/
switch (dp->output_colour_type)
{
case PNG_COLOR_TYPE_PALETTE:
if (dp->output_bit_depth > 8) goto error;
/*FALL THROUGH*/
case PNG_COLOR_TYPE_GRAY:
if (dp->output_bit_depth == 1 || dp->output_bit_depth == 2 ||
dp->output_bit_depth == 4)
break;
/*FALL THROUGH*/
default:
if (dp->output_bit_depth == 8 || dp->output_bit_depth == 16)
break;
/*FALL THROUGH*/
error:
{
char message[128];
size_t pos;

pos = safecat(message, sizeof message, 0,
"invalid final bit depth: colour type(");
pos = safecatn(message, sizeof message, pos, dp->output_colour_type);
pos = safecat(message, sizeof message, pos, ") with bit depth: ");
pos = safecatn(message, sizeof message, pos, dp->output_bit_depth);

png_error(pp, message);
}

}

/* Use a test pixel to check that the output agrees with what we expect -
    * this avoids running the whole test if the output is unexpected.
*/
{
image_pixel test_pixel;

memset(&test_pixel, 0, sizeof test_pixel);
test_pixel.colour_type = dp->this.colour_type; /* input */
test_pixel.bit_depth = dp->this.bit_depth;
if (test_pixel.colour_type == PNG_COLOR_TYPE_PALETTE)
test_pixel.sample_depth = 8;
else
test_pixel.sample_depth = test_pixel.bit_depth;

/* Don't need sBIT here, but it must be set to non-zero to avoid
* arithmetic overflows.
*/
      test_pixel.have_tRNS = dp->this.is_transparent;
test_pixel.red_sBIT = test_pixel.green_sBIT = test_pixel.blue_sBIT =
test_pixel.alpha_sBIT = test_pixel.sample_depth;

dp->transform_list->mod(dp->transform_list, &test_pixel, pp, dp);

if (test_pixel.colour_type != dp->output_colour_type)
{
char message[128];
size_t pos = safecat(message, sizeof message, 0, "colour type ");

pos = safecatn(message, sizeof message, pos, dp->output_colour_type);
pos = safecat(message, sizeof message, pos, " expected ");
pos = safecatn(message, sizeof message, pos, test_pixel.colour_type);

png_error(pp, message);
}

if (test_pixel.bit_depth != dp->output_bit_depth)
{
char message[128];
size_t pos = safecat(message, sizeof message, 0, "bit depth ");

pos = safecatn(message, sizeof message, pos, dp->output_bit_depth);
pos = safecat(message, sizeof message, pos, " expected ");
pos = safecatn(message, sizeof message, pos, test_pixel.bit_depth);

png_error(pp, message);

}

/* If both bit depth and colour type are correct check the sample depth.
       * I believe these are both internal errors.
*/
      if (test_pixel.colour_type == PNG_COLOR_TYPE_PALETTE)
      {
         if (test_pixel.sample_depth != 8) /* oops - internal error! *
            png_error(pp, "pngvalid: internal: palette sample depth not 8");
      }
      else if (test_pixel.sample_depth != dp->output_bit_depth)
{
char message[128];
size_t pos = safecat(message, sizeof message, 0,
"internal: sample depth ");

pos = safecatn(message, sizeof message, pos, dp->output_bit_depth);
pos = safecat(message, sizeof message, pos, " expected ");
         pos = safecatn(message, sizeof message, pos, test_pixel.sample_depth);

png_error(pp, message);
}
}
}

compare_read(struct display *dp, int applied_transforms)
{
/* Compare the png_info from read_ip with original_info */
size_t rowbytes;
png_uint_32 width, height;
int bit_depth, color_type;
int interlace_method, compression_method, filter_method;
const char *e = NULL;

png_get_IHDR(dp->read_pp, dp->read_ip, &width, &height, &bit_depth,
&color_type, &interlace_method, &compression_method, &filter_method);

#  define C(item) if (item != dp->item) \
display_log(dp, APP_WARNING, "IHDR " #item "(%lu) changed to %lu",\
(unsigned long)dp->item, (unsigned long)item), e = #item

/* The IHDR should be identical: */
C(width);
C(height);
C(bit_depth);
C(color_type);
C(interlace_method);
C(compression_method);
C(filter_method);

/* 'e' remains set to the name of the last thing changed: */
if (e)
display_log(dp, APP_ERROR, "IHDR changed (%s)", e);

/* All the chunks from the original PNG should be preserved in the output PNG
* because the PNG format has not been changed.
*/

{
unsigned long chunks =
png_get_valid(dp->read_pp, dp->read_ip, 0xffffffff);
      
if (chunks != dp->chunks)
display_log(dp, APP_FAIL, "PNG chunks changed from 0x%lx to 0x%lx",
(unsigned long)dp->chunks, chunks);
}

/* rowbytes should be the same */
rowbytes = png_get_rowbytes(dp->read_pp, dp->read_ip);

/* NOTE: on 64-bit systems this may trash the top bits of rowbytes,
* which could lead to weird error messages.
*/
if (rowbytes != dp->original_rowbytes)
display_log(dp, APP_ERROR, "PNG rowbytes changed from %lu to %lu",
(unsigned long)dp->original_rowbytes, (unsigned long)rowbytes);

/* The rows should be the same too, unless the applied transforms includes
* the shift transform, in which case low bits may have been lost.
*/
{
png_bytepp rows = png_get_rows(dp->read_pp, dp->read_ip);
unsigned int mask; /* mask (if not zero) for the final byte */

if (bit_depth < 8)
{
/* Need the stray bits at the end, this depends only on the low bits
* of the image width; overflow does not matter.  If the width is an
* exact multiple of 8 bits this gives a mask of 0, not 0xff.
*/
mask = 0xff & (0xff00 >> ((bit_depth * width) & 7));
}

else
mask = 0;

if (rows == NULL)
display_log(dp, LIBPNG_BUG, "png_get_rows returned NULL");

if ((applied_transforms & PNG_TRANSFORM_SHIFT) == 0 ||
(dp->active_transforms & PNG_TRANSFORM_SHIFT) == 0 ||
color_type == PNG_COLOR_TYPE_PALETTE)
{
unsigned long y;

for (y=0; y<height; ++y)
{
png_bytep row = rows[y];
png_bytep orig = dp->original_rows[y];

if (memcmp(row, orig, rowbytes-(mask != 0)) != 0 || (mask != 0 &&
((row[rowbytes-1] & mask) != (orig[rowbytes-1] & mask))))
{
size_t x;

/* Find the first error */
for (x=0; x<rowbytes-1; ++x) if (row[x] != orig[x])
break;

display_log(dp, APP_FAIL,
"byte(%lu,%lu) changed 0x%.2x -> 0x%.2x",
(unsigned long)x, (unsigned long)y, orig[x], row[x]);
return 0; /* don't keep reporting failed rows on 'continue' */
}
}
}

else
{
unsigned long y;
int bpp; /* bits-per-pixel then bytes-per-pixel */
/* components are up to 8 bytes in size */
png_byte sig_bits[8];
png_color_8p sBIT;

if (png_get_sBIT(dp->read_pp, dp->read_ip, &sBIT) != PNG_INFO_sBIT)
display_log(dp, INTERNAL_ERROR,
"active shift transform but no sBIT in file");

switch (color_type)
{
case PNG_COLOR_TYPE_GRAY:
sig_bits[0] = sBIT->gray;
bpp = bit_depth;
break;

case PNG_COLOR_TYPE_GA:
sig_bits[0] = sBIT->gray;
sig_bits[1] = sBIT->alpha;
bpp = 2 * bit_depth;
break;

case PNG_COLOR_TYPE_RGB:
sig_bits[0] = sBIT->red;
sig_bits[1] = sBIT->green;
sig_bits[2] = sBIT->blue;
bpp = 3 * bit_depth;
break;

case PNG_COLOR_TYPE_RGBA:
sig_bits[0] = sBIT->red;
sig_bits[1] = sBIT->green;
sig_bits[2] = sBIT->blue;
sig_bits[3] = sBIT->alpha;
bpp = 4 * bit_depth;
break;

default:
display_log(dp, LIBPNG_ERROR, "invalid colour type %d",
color_type);
/*NOTREACHED*/
bpp = 0;
break;
}

{
int b;

for (b=0; 8*b<bpp; ++b)
{
/* libpng should catch this; if not there is a security issue
* because an app (like this one) may overflow an array. In fact
* libpng doesn't catch this at present.
*/
if (sig_bits[b] == 0 || sig_bits[b] > bit_depth/*!palette*/)
display_log(dp, LIBPNG_BUG,
"invalid sBIT[%u]  value %d returned for PNG bit depth %d",
b, sig_bits[b], bit_depth);
}
}

if (bpp < 8 && bpp != bit_depth)
{
/* sanity check; this is a grayscale PNG; something is wrong in the
* code above.
*/
display_log(dp, INTERNAL_ERROR, "invalid bpp %u for bit_depth %u",
bpp, bit_depth);
}

switch (bit_depth)

{
int b;

            case 16: /* Two bytes per component, bit-endian *
               for (b = (bpp >> 4); b > 0; )
{
unsigned int sig = (unsigned int)(0xffff0000 >> sig_bits[b]);

sig_bits[2*b+1] = (png_byte)sig;
sig_bits[2*b+0] = (png_byte)(sig >> 8); /* big-endian */
}
break;

case 8: /* One byte per component */
for (b=0; b*8 < bpp; ++b)
sig_bits[b] = (png_byte)(0xff00 >> sig_bits[b]);
break;

case 1: /* allowed, but dumb */
/* Value is 1 */
sig_bits[0] = 0xff;
break;

case 2: /* Replicate 4 times */
/* Value is 1 or 2 */
b = 0x3 & ((0x3<<2) >> sig_bits[0]);
b |= b << 2;
b |= b << 4;
sig_bits[0] = (png_byte)b;
break;

case 4: /* Relicate twice */
/* Value is 1, 2, 3 or 4 */
b = 0xf & ((0xf << 4) >> sig_bits[0]);
b |= b << 4;
sig_bits[0] = (png_byte)b;
break;

default:
display_log(dp, LIBPNG_BUG, "invalid bit depth %d", bit_depth);
break;
}

/* Convert bpp to bytes; this gives '1' for low-bit depth grayscale,
* where there are multiple pixels per byte.
*/
bpp = (bpp+7) >> 3;

/* The mask can be combined with sig_bits[0] */
if (mask != 0)
{
mask &= sig_bits[0];

if (bpp != 1 || mask == 0)
display_log(dp, INTERNAL_ERROR, "mask calculation error %u, %u",
bpp, mask);
}

for (y=0; y<height; ++y)
{
png_bytep row = rows[y];
png_bytep orig = dp->original_rows[y];
unsigned long x;

for (x=0; x<(width-(mask!=0)); ++x)
{
int b;

for (b=0; b<bpp; ++b)
{
if ((*row++ & sig_bits[b]) != (*orig++ & sig_bits[b]))
{
display_log(dp, APP_FAIL,
"significant bits at (%lu[%u],%lu) changed %.2x->%.2x",
x, b, y, orig[-1], row[-1]);
return 0;
}
}
}

if (mask != 0 && (*row & mask) != (*orig & mask))
{
display_log(dp, APP_FAIL,
"significant bits at (%lu[end],%lu) changed", x, y);
return 0;
}
} /* for y */
}
}

return 1; /* compare succeeded */
}

int validation_ascii_to_fp(int count, int argc, char **argv)
{
 int    showall = 0;
 double max_error=2; /* As a percentage error-in-last-digit/.5 */
 double max_error_abs=17; /* Used when precision is DBL_DIG */
 double max = 0;
 double max_abs = 0;
 double test = 0; /* Important to test this. */
 int    precision = 5;
 int    nonfinite = 0;
 int    finite = 0;
 int    ok = 0;
 int    failcount = 0;
 int    minorarith = 0;

 while (--argc > 0)
 if (strcmp(*++argv, "-a") == 0)
         showall = 1;
 else if (strcmp(*argv, "-e") == 0 && argc > 0)
 {
 --argc;
         max_error = atof(*++argv);
 }
 else if (strcmp(*argv, "-E") == 0 && argc > 0)
 {
 --argc;
         max_error_abs = atof(*++argv);
 }
 else
 {
         fprintf(stderr, "unknown argument %s\n", *argv);
 return 1;
 }

 do
 {
 png_size_t index;
 int state, failed = 0;
 char buffer[64];

 if (isfinite(test))
 ++finite;
 else
 ++nonfinite;

 if (verbose)
         fprintf(stderr, "%.*g %d\n", DBL_DIG, test, precision);

 /* Check for overflow in the buffer by setting a marker. */
      memset(buffer, 71, sizeof buffer);

      png_ascii_from_fp(0, buffer, precision+10, test, precision);

 /* Allow for a three digit exponent, this stuff will fail if
       * the exponent is bigger than this!
       */
 if (buffer[precision+7] != 71)
 {
         fprintf(stderr, "%g[%d] -> '%s'[%lu] buffer overflow\n", test,
            precision, buffer, (unsigned long)strlen(buffer));
         failed = 1;
 }

 /* Following are used for the number parser below and must be
       * initialized to zero.
       */
      state = 0;
      index = 0;
 if (!isfinite(test))
 {
 /* Expect 'inf' */
 if (test >= 0 && strcmp(buffer, "inf") ||
             test < 0 && strcmp(buffer, "-inf"))
 {
            fprintf(stderr, "%g[%d] -> '%s' but expected 'inf'\n", test,
               precision, buffer);
            failed = 1;
 }
 }
 else if (!png_check_fp_number(buffer, precision+10, &state, &index) ||
          buffer[index] != 0)
 {
         fprintf(stderr, "%g[%d] -> '%s' but has bad format ('%c')\n", test,
         precision, buffer, buffer[index]);
         failed = 1;
 }
 else if (PNG_FP_IS_NEGATIVE(state) && !(test < 0))
 {
         fprintf(stderr, "%g[%d] -> '%s' but negative value not so reported\n",
            test, precision, buffer);
         failed = 1;
         assert(!PNG_FP_IS_ZERO(state));
         assert(!PNG_FP_IS_POSITIVE(state));
 }
 else if (PNG_FP_IS_ZERO(state) && !(test == 0))
 {
         fprintf(stderr, "%g[%d] -> '%s' but zero value not so reported\n",
            test, precision, buffer);
         failed = 1;
         assert(!PNG_FP_IS_NEGATIVE(state));
         assert(!PNG_FP_IS_POSITIVE(state));
 }
 else if (PNG_FP_IS_POSITIVE(state) && !(test > 0))
 {
         fprintf(stderr, "%g[%d] -> '%s' but postive value not so reported\n",
            test, precision, buffer);
         failed = 1;
         assert(!PNG_FP_IS_NEGATIVE(state));
         assert(!PNG_FP_IS_ZERO(state));
 }
 else
 {
 /* Check the result against the original. */
 double out = atof(buffer);
 double change = fabs((out - test)/test);
 double allow = .5/pow(10,
 (precision >= DBL_DIG) ? DBL_DIG-1 : precision-1);

 /* NOTE: if you hit this error case are you compiling with gcc
          * and -O0?  Try -O2 - the errors can accumulate if the FP
          * code above is not optimized and may drift outside the .5 in
          * DBL_DIG allowed.  In any case a small number of errors may
          * occur (very small ones - 1 or 2%) because of rounding in the
          * calculations, either in the conversion API or in atof.
          */
 if (change >= allow && (isfinite(out) ||
             fabs(test/DBL_MAX) <= 1-allow))
 {
 double percent = (precision >= DBL_DIG) ? max_error_abs : max_error;
 double allowp = (change-allow)*100/allow;

 if (precision >= DBL_DIG)
 {
 if (max_abs < allowp) max_abs = allowp;
 }

 else
 {
 if (max < allowp) max = allowp;
 }

 if (showall || allowp >= percent)
 {
               fprintf(stderr,
 "%.*g[%d] -> '%s' -> %.*g number changed (%g > %g (%d%%))\n",
                  DBL_DIG, test, precision, buffer, DBL_DIG, out, change, allow,
 (int)round(allowp));
               failed = 1;
 }
 else
 ++minorarith;
 }
 }

 if (failed)
 ++failcount;
 else
 ++ok;

skip:
 /* Generate a new number and precision. */
      precision = rand();
 if (precision & 1) test = -test;
      precision >>= 1;

 /* Generate random numbers. */
 if (test == 0 || !isfinite(test))
         test = precision+1;
 else
 {
 /* Derive the exponent from the previous rand() value. */
 int exponent = precision % (DBL_MAX_EXP - DBL_MIN_EXP) + DBL_MIN_EXP;
 int tmp;
         test = frexp(test * rand(), &tmp);
         test = ldexp(test, exponent);
         precision >>= 8; /* arbitrary */
 }

 /* This limits the precision to 32 digits, enough for standard
       * IEEE implementations which have at most 15 digits.
       */
      precision = (precision & 0x1f) + 1;
 }
 while (--count);

   printf("Tested %d finite values, %d non-finite, %d OK (%d failed) %d minor "
 "arithmetic errors\n", finite, nonfinite, ok, failcount, minorarith);
   printf(" Error with >=%d digit precision %.2f%%\n", DBL_DIG, max_abs);
   printf(" Error with < %d digit precision %.2f%%\n", DBL_DIG, max);

 return 0;
}

sample_scale(double sample_value, unsigned int scale)
{
   sample_value = floor(sample_value * scale + .5);

 /* Return NaN as 0: */
 if (!(sample_value > 0))
      sample_value = 0;
 else if (sample_value > scale)
      sample_value = scale;

 return (unsigned int)sample_value;

 }

skip_transform(struct display *dp, int tr)
 /* Helper to test for a bad combo and log it if it is skipped */
{
 if ((dp->options & SKIP_BUGS) != 0 && is_bad_combo(tr))
 {
 /* Log this to stdout if logging is on, otherwise just do an information
       * display_log.
       */
 if ((dp->options & LOG_SKIPPED) != 0)
 {
         printf("SKIP: %s transforms ", dp->filename);

 while (tr != 0)
 {
 int next = first_transform(tr);
            tr &= ~next;

            printf("%s", transform_name(next));
 if (tr != 0)
               putchar('+');
 }

         putchar('\n');
 }

 else
         display_log(dp, INFORMATION, "%s: skipped known bad combo 0x%x",
            dp->filename, tr);

 return 1; /* skip */
 }

 return 0; /* don't skip */
}

static int format_set(format_list *pf, png_uint_32 format)
{
 if (format < FORMAT_COUNT)
 return pf->bits[format >> 5] |= ((png_uint_32)1) << (format & 31);

 return 0;
}

sync_stream(struct file *file)
 /* The stream seems to be messed up, attempt to resync from the current chunk
    * header.  Executes stop on a fatal error, otherwise calls process_chunk.
    */
{
   png_uint_32 file_crc;

   file->status_code |= STREAM_ERROR;

 if (file->global->verbose)
 {
      fputs(" SYNC ", stderr);
      type_name(file->type, stderr);
      putc('\n', stderr);
 }

 /* Return to the start of the chunk data */
   file_setpos(file, &file->data_pos);
   file->read_count = 8;

 if (read_4(file, &file_crc) == 4) /* else completely truncated */
 {
 /* Ignore the recorded chunk length, proceed through the data looking for
       * a leading sequence of bytes that match the CRC in the following four
       * bytes.  Each time a match is found check the next 8 bytes for a valid
       * length, chunk-type pair.
       */
      png_uint_32 length;
      png_uint_32 type = file->type;
      png_uint_32 crc = crc_init_4(type);
      png_byte buffer[8];
 unsigned int nread = 0, nused = 0;

 for (length=0; length <= 0x7fffffff; ++length)
 {
 int ch;

 if ((crc ^ 0xffffffff) == file_crc)
 {
 /* A match on the CRC; for IEND this is sufficient, but for anything
             * else expect a following chunk header.
             */
 if (type == png_IEND)
 {
               file->length = length;
               process_chunk(file, file_crc, 0, 0);
 return;
 }

 else
 {
 /* Need 8 bytes */
 while (nread < 8+nused)
 {
                  ch = read_byte(file);
 if (ch == EOF)
 goto truncated;
                  buffer[(nread++) & 7] = (png_byte)ch;
 }

 /* Prevent overflow */
               nread -= nused & ~7;
               nused -= nused & ~7; /* or, nused &= 7 ;-) */

 /* Examine the 8 bytes for a valid chunk header. */
 {
                  png_uint_32 next_length = get32(buffer, nused);

 if (next_length < 0x7fffffff)
 {
                     png_uint_32 next_type = get32(buffer, nused+4);

 if (chunk_type_valid(next_type))
 {
                        file->read_count -= 8;
                        process_chunk(file, file_crc, next_length, next_type);
 return;
 }
 }

 /* Not valid, keep going. */
 }
 }
 }

 /* This catches up with the circular buffer which gets filled above
          * while checking a chunk header.  This code is slightly tricky - if
          * the chunk_type is IEND the buffer will never be used, if it is not
          * the code will always read ahead exactly 8 bytes and pass this on to
          * process_chunk.  So the invariant that IEND leaves the file position
          * after the IEND CRC and other chunk leave it after the *next* chunk
          * header is not broken.
          */
 if (nread <= nused)
 {
            ch = read_byte(file);

 if (ch == EOF)
 goto truncated;
 }

 else
            ch = buffer[(++nused) & 7];

         crc = crc_one_byte(crc, file_crc >> 24);
         file_crc = (file_crc << 8) + ch;
 }

 /* Control gets to here if when 0x7fffffff bytes (plus 8) have been read,
       * ok, treat this as a damaged stream too:
       */
 }

truncated:
   stop(file, READ_ERROR_CODE, "damaged PNG stream");
}

standard_palette_init(standard_display *dp)
{
   store_palette_entry *palette = store_current_palette(dp->ps, &dp->npalette);

 /* The remaining entries remain white/opaque. */
 if (dp->npalette > 0)
 {
 int i = dp->npalette;
      memcpy(dp->palette, palette, i * sizeof *palette);

 /* Check for a non-opaque palette entry: */
 while (--i >= 0)
 if (palette[i].alpha < 255)
 break;

#     ifdef __GNUC__
 /* GCC can't handle the more obviously optimizable version. */
 if (i >= 0)
            dp->is_transparent = 1;
 else
            dp->is_transparent = 0;
#     else
         dp->is_transparent = (i >= 0);
#     endif
 }
}

static png_uint_32 png_log16bit(png_uint_32 x)
{
 if (x > 0)
 return (png_uint_32)floor(.5-log(x/65535.)*L2INV);

 return 0xffffffff;
}

main(int argc, const char **argv)
{
 FILE *fp;
   png_uint_32 default_flags[4/*valid,unknown{before,after}*/];
 int strict = 0, default_tests = 0;
 const char *count_argv = "default=save";
 const char *touch_file = NULL;
   display d;

   init_display(&d, argv[0]);

 while (++argv, --argc > 0)
 {
 if (strcmp(*argv, "--strict") == 0)
         strict = 1;

 else if (strcmp(*argv, "--default") == 0)
         default_tests = 1;

 else if (strcmp(*argv, "--touch") == 0)
 {
 if (argc > 1)
            touch_file = *++argv, --argc;

 else
            usage(d.program, "--touch: missing file name");
 }

 else
 break;
 }

 /* A file name is required, but there should be no other arguments if
    * --default was specified.
    */
 if (argc <= 0)
      usage(d.program, "missing test file");

 /* GCC BUG: if (default_tests && argc != 1) triggers some weird GCC argc
    * optimization which causes warnings with -Wstrict-overflow!
    */
 else if (default_tests) if (argc != 1)
      usage(d.program, "extra arguments");

 /* The name of the test file is the last argument; remove it. */
   d.file = argv[--argc];

   fp = fopen(d.file, "rb");
 if (fp == NULL)
 {
      perror(d.file);
      exit(99);
 }

 /* First find all the chunks, known and unknown, in the test file, a failure
    * here aborts the whole test.
    *
    * If 'save' is supported then the normal saving method should happen,
    * otherwise if 'read' is supported then the read callback will do the
    * same thing.  If both are supported the 'read' callback won't be
    * instantiated by default.  If 'save' is *not* supported then a user
    * callback is required even though we can call png_get_unknown_chunks.
    */
 if (check(fp, 1, &count_argv, default_flags, &d,
#     ifdef PNG_SAVE_UNKNOWN_CHUNKS_SUPPORTED
 0
#     else
 1
#     endif
 ) != PNG_HANDLE_CHUNK_ALWAYS)
 {
      fprintf(stderr, "%s: %s: internal error\n", d.program, d.file);
      exit(99);
 }

 /* Now find what the various supplied options cause to change: */
 if (!default_tests)
 {
      d.test = cmd; /* acts as a flag to say exit, do not longjmp */
#     ifdef PNG_SAVE_UNKNOWN_CHUNKS_SUPPORTED
         perform_one_test(fp, argc, argv, default_flags, &d, 0);
#     endif
#     ifdef PNG_READ_USER_CHUNKS_SUPPORTED
         perform_one_test(fp, argc, argv, default_flags, &d, 1);
#     endif
      d.test = init;
 }

 else
 {
 const char **test = standard_tests;

 /* Set the exit_test pointer here so we can continue after a libpng error.
       * NOTE: this leaks memory because the png_struct data from the failing
       * test is never freed.
       */
 while (*test)
 {
 const char *this_test = *test++;
 const char **next = test;
 int count = display_rc(&d, strict), new_count;
 const char *result;
 int arg_count = 0;

 while (*next) ++next, ++arg_count;

         perform_one_test_safe(fp, arg_count, test, default_flags, &d,
            this_test);

         new_count = display_rc(&d, strict);

 if (new_count == count)
            result = "PASS";

 else
            result = "FAIL";

         printf("%s: %s %s\n", result, d.program, this_test);

         test = next+1;
 }
 }

   fclose(fp);

 if (display_rc(&d, strict) == 0)
 {
 /* Success, touch the success file if appropriate */
 if (touch_file != NULL)
 {
 FILE *fsuccess = fopen(touch_file, "wt");

 if (fsuccess != NULL)
 {
 int err = 0;
            fprintf(fsuccess, "PNG unknown tests succeeded\n");
            fflush(fsuccess);
            err = ferror(fsuccess);

 if (fclose(fsuccess) || err)
 {
               fprintf(stderr, "%s: write failed\n", touch_file);
               exit(99);
 }
 }

 else
 {
            fprintf(stderr, "%s: open failed\n", touch_file);
            exit(99);
 }
 }

 return 0;
 }

 return 1;
}

 random_choice(void)
 {
 unsigned char x;

   RANDOMIZE(x);

 return x & 1;
}

zlib_advance(struct zlib *zlib, png_uint_32 nbytes)
/* Read nbytes compressed bytes; the stream will be initialized if required.
* Bytes are always being reread and errors are fatal.  The return code is as
* follows:
*
*    -1: saw the "too far back" error
*     0: ok, keep going
*     1: saw Z_STREAM_END (zlib->extra_bytes indicates too much data)
*     2: a zlib error that cannot be corrected (error message already
*        output if required.)
*/
#  define ZLIB_TOO_FAR_BACK (-1)
#  define ZLIB_OK           0
#  define ZLIB_STREAM_END   1
#  define ZLIB_FATAL        2
{
int state = zlib->state;
int endrc = ZLIB_OK;
png_uint_32 in_bytes = 0;
struct file *file = zlib->file;

assert(state >= 0);

while (in_bytes < nbytes && endrc == ZLIB_OK)
{
png_uint_32 out_bytes;
int flush;
png_byte bIn = reread_byte(file);
png_byte bOut;

switch (state)
{
case 0: /* first header byte */
{
int file_bits = 8+(bIn >> 4);
int new_bits = zlib->window_bits;


zlib->file_bits = file_bits;

/* Check against the existing value - it may not need to be
                * changed.
*/
if (new_bits == 0) /* no change */
                  zlib->window_bits = file_bits;

else if (new_bits != file_bits) /* rewrite required */
bIn = (png_byte)((bIn & 0xf) + ((new_bits-8) << 4));
}

zlib->header[0] = bIn;
zlib->state = state = 1;
break;

case 1: /* second header byte */
{
int b2 = bIn & 0xe0; /* top 3 bits */

/* The checksum calculation, on the first 11 bits: */
b2 += 0x1f - ((zlib->header[0] << 8) + b2) % 0x1f;

/* Update the checksum byte if required: */

if (bIn != b2)
{
/* If the first byte wasn't changed this indicates an error in
                   * the checksum calculation; signal this by setting file_bits
                   * (not window_bits) to 0.
*/
if (zlib->file_bits == zlib->window_bits)
zlib->cksum = 1;

bIn = (png_byte)b2;
}
}

zlib->header[1] = bIn;
zlib->state = state = 2;
break;

default: /* After the header bytes */
break;
}

/* For some streams, perhaps only those compressed with 'superfast
* compression' (which results in a lot of copying) Z_BUF_ERROR can happen
* immediately after all output has been flushed on the next input byte.
* This is handled below when Z_BUF_ERROR is detected by adding an output
* byte.
*/
zlib->z.next_in = &bIn;
zlib->z.avail_in = 1;
zlib->z.next_out = &bOut;
zlib->z.avail_out = 0; /* Initially */

/* Initially use Z_NO_FLUSH in an attempt to persuade zlib to look at this
* byte without confusing what is going on with output.
*/
flush = Z_NO_FLUSH;
out_bytes = 0;

/* NOTE: expression 3 is only evaluted on 'continue', because of the
* 'break' at the end of this loop below.
*/
for (;endrc == ZLIB_OK;
flush = Z_SYNC_FLUSH,
zlib->z.next_out = &bOut,
zlib->z.avail_out = 1,
++out_bytes)
{
zlib->rc = inflate(&zlib->z, flush);
out_bytes -= zlib->z.avail_out;

switch (zlib->rc)
{
case Z_BUF_ERROR:
if (zlib->z.avail_out == 0)
continue; /* Try another output byte. */

if (zlib->z.avail_in == 0)
break; /* Try another input byte */

/* Both avail_out and avail_in are 1 yet zlib returned a code
* indicating no progress was possible.  This is unexpected.
*/
zlib_message(zlib, 1/*unexpected*/);
endrc = ZLIB_FATAL; /* stop processing */
break;

case Z_OK:
/* Zlib is supposed to have made progress: */
assert(zlib->z.avail_out == 0 || zlib->z.avail_in == 0);
continue;

case Z_STREAM_END:
/* This is the successful end. */
zlib->state = 3; /* end of stream */
endrc = ZLIB_STREAM_END;
break;

case Z_NEED_DICT:
zlib_message(zlib, 0/*stream error*/);
endrc = ZLIB_FATAL;
break;

case Z_DATA_ERROR:
/* The too far back error can be corrected, others cannot: */
if (zlib->z.msg != NULL &&
strcmp(zlib->z.msg, "invalid distance too far back") == 0)
{
endrc = ZLIB_TOO_FAR_BACK;
break;
}
/* FALL THROUGH */

default:
zlib_message(zlib, 0/*stream error*/);
endrc = ZLIB_FATAL;
break;
} /* switch (inflate rc) */

/* Control gets here when further output is not possible; endrc may
* still be ZLIB_OK if more input is required.
*/
break;
} /* for (output bytes) */

/* Keep a running count of output byte produced: */
zlib->uncompressed_digits = uarb_add32(zlib->uncompressed_bytes,
zlib->uncompressed_digits, out_bytes);

/* Keep going, the loop will terminate when endrc is no longer set to
* ZLIB_OK or all the input bytes have been consumed; meanwhile keep
* adding input bytes.
*/
assert(zlib->z.avail_in == 0 || endrc != ZLIB_OK);

in_bytes += 1 - zlib->z.avail_in;
} /* while (input bytes) */

assert(in_bytes == nbytes || endrc != ZLIB_OK);

/* Update the running total of input bytes consumed */
zlib->compressed_digits = uarb_add32(zlib->compressed_bytes,
zlib->compressed_digits, in_bytes - zlib->z.avail_in);

/* At the end of the stream update the chunk with the accumulated
* information if it is an improvement:
*/
if (endrc == ZLIB_STREAM_END && zlib->window_bits < zlib->ok_bits)
{
struct chunk *chunk = zlib->chunk;

chunk->uncompressed_digits = uarb_copy(chunk->uncompressed_bytes,
zlib->uncompressed_bytes, zlib->uncompressed_digits);
chunk->compressed_digits = uarb_copy(chunk->compressed_bytes,
zlib->compressed_bytes, zlib->compressed_digits);
chunk->rewrite_buffer[0] = zlib->header[0];
chunk->rewrite_buffer[1] = zlib->header[1];

if (zlib->window_bits != zlib->file_bits || zlib->cksum)
{
/* A rewrite is required */
chunk->rewrite_offset = zlib->rewrite_offset;
chunk->rewrite_length = 2;
}

else
{
chunk->rewrite_offset = 0;
chunk->rewrite_length = 0;
}

if (in_bytes < nbytes)
chunk_message(chunk, "extra compressed data");

zlib->extra_bytes = nbytes - in_bytes;
zlib->ok_bits = zlib->window_bits;
}

return endrc;
}

int readpng2_check_sig(uch *sig, int num)
{
 return !png_sig_cmp(sig, 0, num);
}

standard_check_text(png_const_structp pp, png_const_textp tp,
   png_const_charp keyword, png_const_charp text)
{
 char msg[1024];
 size_t pos = safecat(msg, sizeof msg, 0, "text: ");
 size_t ok;

   pos = safecat(msg, sizeof msg, pos, keyword);
   pos = safecat(msg, sizeof msg, pos, ": ");
   ok = pos;

 if (tp->compression != TEXT_COMPRESSION)
 {
 char buf[64];

      sprintf(buf, "compression [%d->%d], ", TEXT_COMPRESSION,
         tp->compression);
      pos = safecat(msg, sizeof msg, pos, buf);
 }

 if (tp->key == NULL || strcmp(tp->key, keyword) != 0)
 {
      pos = safecat(msg, sizeof msg, pos, "keyword \"");
 if (tp->key != NULL)
 {
         pos = safecat(msg, sizeof msg, pos, tp->key);
         pos = safecat(msg, sizeof msg, pos, "\", ");
 }

 else
         pos = safecat(msg, sizeof msg, pos, "null, ");
 }

 if (tp->text == NULL)
      pos = safecat(msg, sizeof msg, pos, "text lost, ");

 else
 {
 if (tp->text_length != strlen(text))
 {
 char buf[64];
         sprintf(buf, "text length changed[%lu->%lu], ",
 (unsigned long)strlen(text), (unsigned long)tp->text_length);
         pos = safecat(msg, sizeof msg, pos, buf);
 }

 if (strcmp(tp->text, text) != 0)
 {
         pos = safecat(msg, sizeof msg, pos, "text becomes \"");
         pos = safecat(msg, sizeof msg, pos, tp->text);
         pos = safecat(msg, sizeof msg, pos, "\" (was \"");
         pos = safecat(msg, sizeof msg, pos, text);
         pos = safecat(msg, sizeof msg, pos, "\"), ");
 }
 }

 if (tp->itxt_length != 0)
      pos = safecat(msg, sizeof msg, pos, "iTXt length set, ");

 if (tp->lang != NULL)
 {
      pos = safecat(msg, sizeof msg, pos, "iTXt language \"");
      pos = safecat(msg, sizeof msg, pos, tp->lang);
      pos = safecat(msg, sizeof msg, pos, "\", ");
 }

 if (tp->lang_key != NULL)
 {
      pos = safecat(msg, sizeof msg, pos, "iTXt keyword \"");
      pos = safecat(msg, sizeof msg, pos, tp->lang_key);
      pos = safecat(msg, sizeof msg, pos, "\", ");
 }

 if (pos > ok)
 {
      msg[pos-2] = '\0'; /* Remove the ", " at the end */
      png_error(pp, msg);
 }
}

parse_color(char *arg, unsigned int *colors)
{
 unsigned int ncolors = 0;

 while (*arg && ncolors < 4)
 {
 char *ep = arg;

 unsigned long ul = strtoul(arg, &ep, 0);

 if (ul > 65535)
 {
         fprintf(stderr, "makepng --color=...'%s': too big\n", arg);
         exit(1);
 }

 if (ep == arg)
 {
         fprintf(stderr, "makepng --color=...'%s': not a valid color\n", arg);
         exit(1);
 }

 if (*ep) ++ep; /* skip a separator */
      arg = ep;

      colors[++ncolors] = (unsigned int)ul; /* checked above */
 }

 if (*arg)
 {
      fprintf(stderr, "makepng --color=...'%s': too many values\n", arg);
      exit(1);
 }

 *colors = ncolors;
}

 pixel_depth_of_type(int color_type, int bit_depth)
 {
    return channels_of_type(color_type) * bit_depth;
 }

static int rpng_x_create_window(void)
{
    uch *xdata;
 int need_colormap = FALSE;
 int screen, pad;
    ulg bg_pixel = 0L;
    ulg attrmask;
 Window root;
 XEvent e;
 XGCValues gcvalues;
 XSetWindowAttributes attr;
 XTextProperty windowName, *pWindowName = &windowName;
 XTextProperty iconName, *pIconName = &iconName;
 XVisualInfo visual_info;
 XSizeHints *size_hints;
 XWMHints *wm_hints;
 XClassHint *class_hints;


    screen = DefaultScreen(display);
    depth = DisplayPlanes(display, screen);
    root = RootWindow(display, screen);

#ifdef DEBUG
 XSynchronize(display, True);
#endif

#if 0
/* GRR:  add 8-bit support */
 if (/* depth != 8 && */ depth != 16 && depth != 24 && depth != 32) {
        fprintf(stderr,
 "screen depth %d not supported (only 16-, 24- or 32-bit TrueColor)\n",
          depth);
 return 2;
 }

 XMatchVisualInfo(display, screen, depth,
 (depth == 8)? PseudoColor : TrueColor, &visual_info);
    visual = visual_info.visual;
#else
 if (depth != 16 && depth != 24 && depth != 32) {
 int visuals_matched = 0;

 Trace((stderr, "default depth is %d:  checking other visuals\n",
          depth))

 /* 24-bit first */
        visual_info.screen = screen;
        visual_info.depth = 24;
        visual_list = XGetVisualInfo(display,
 VisualScreenMask | VisualDepthMask, &visual_info, &visuals_matched);
 if (visuals_matched == 0) {
/* GRR:  add 15-, 16- and 32-bit TrueColor visuals (also DirectColor?) */
            fprintf(stderr, "default screen depth %d not supported, and no"
 " 24-bit visuals found\n", depth);
 return 2;
 }
 Trace((stderr, "XGetVisualInfo() returned %d 24-bit visuals\n",
          visuals_matched))
        visual = visual_list[0].visual;
        depth = visual_list[0].depth;
/*
        colormap_size = visual_list[0].colormap_size;
        visual_class = visual->class;
        visualID = XVisualIDFromVisual(visual);
 */
        have_nondefault_visual = TRUE;
        need_colormap = TRUE;
 } else {
 XMatchVisualInfo(display, screen, depth, TrueColor, &visual_info);
        visual = visual_info.visual;
 }
#endif

 RMask = visual->red_mask;
 GMask = visual->green_mask;
 BMask = visual->blue_mask;

/* GRR:  add/check 8-bit support */
 if (depth == 8 || need_colormap) {
        colormap = XCreateColormap(display, root, visual, AllocNone);
 if (!colormap) {
            fprintf(stderr, "XCreateColormap() failed\n");
 return 2;
 }
        have_colormap = TRUE;
 }
 if (depth == 15 || depth == 16) {
 RShift = 15 - rpng_x_msb(RMask); /* these are right-shifts */
 GShift = 15 - rpng_x_msb(GMask);
 BShift = 15 - rpng_x_msb(BMask);
 } else if (depth > 16) {
#define NO_24BIT_MASKS
#ifdef NO_24BIT_MASKS
 RShift = rpng_x_msb(RMask) - 7; /* these are left-shifts */
 GShift = rpng_x_msb(GMask) - 7;
 BShift = rpng_x_msb(BMask) - 7;
#else
 RShift = 7 - rpng_x_msb(RMask); /* these are right-shifts, too */
 GShift = 7 - rpng_x_msb(GMask);
 BShift = 7 - rpng_x_msb(BMask);
#endif
 }
 if (depth >= 15 && (RShift < 0 || GShift < 0 || BShift < 0)) {
        fprintf(stderr, "rpng internal logic error:  negative X shift(s)!\n");
 return 2;
 }

/*---------------------------------------------------------------------------
    Finally, create the window.
  ---------------------------------------------------------------------------*/

    attr.backing_store = Always;
    attr.event_mask = ExposureMask | KeyPressMask | ButtonPressMask;
    attrmask = CWBackingStore | CWEventMask;
 if (have_nondefault_visual) {
        attr.colormap = colormap;
        attr.background_pixel = 0;
        attr.border_pixel = 1;
        attrmask |= CWColormap | CWBackPixel | CWBorderPixel;
 }

    window = XCreateWindow(display, root, 0, 0, image_width, image_height, 0,
      depth, InputOutput, visual, attrmask, &attr);

 if (window == None) {
        fprintf(stderr, "XCreateWindow() failed\n");
 return 2;
 } else
        have_window = TRUE;

 if (depth == 8)
 XSetWindowColormap(display, window, colormap);

 if (!XStringListToTextProperty(&window_name, 1, pWindowName))
        pWindowName = NULL;
 if (!XStringListToTextProperty(&icon_name, 1, pIconName))
        pIconName = NULL;

 /* OK if any hints allocation fails; XSetWMProperties() allows NULLs */

 if ((size_hints = XAllocSizeHints()) != NULL) {
 /* window will not be resizable */
        size_hints->flags = PMinSize | PMaxSize;
        size_hints->min_width = size_hints->max_width = (int)image_width;
        size_hints->min_height = size_hints->max_height = (int)image_height;
 }

 if ((wm_hints = XAllocWMHints()) != NULL) {
        wm_hints->initial_state = NormalState;
        wm_hints->input = True;
 /* wm_hints->icon_pixmap = icon_pixmap; */
        wm_hints->flags = StateHint | InputHint /* | IconPixmapHint */ ;
 }

 if ((class_hints = XAllocClassHint()) != NULL) {
        class_hints->res_name = res_name;
        class_hints->res_class = res_class;
 }

 XSetWMProperties(display, window, pWindowName, pIconName, NULL, 0,
      size_hints, wm_hints, class_hints);

 /* various properties and hints no longer needed; free memory */
 if (pWindowName)
 XFree(pWindowName->value);
 if (pIconName)
 XFree(pIconName->value);
 if (size_hints)
 XFree(size_hints);
 if (wm_hints)
 XFree(wm_hints);
 if (class_hints)
 XFree(class_hints);

 XMapWindow(display, window);

    gc = XCreateGC(display, window, 0, &gcvalues);
    have_gc = TRUE;

/*---------------------------------------------------------------------------
    Fill window with the specified background color.
  ---------------------------------------------------------------------------*/

 if (depth == 24 || depth == 32) {
        bg_pixel = ((ulg)bg_red   << RShift) |
 ((ulg)bg_green << GShift) |
 ((ulg)bg_blue  << BShift);
 } else if (depth == 16) {
        bg_pixel = ((((ulg)bg_red   << 8) >> RShift) & RMask) |
 ((((ulg)bg_green << 8) >> GShift) & GMask) |
 ((((ulg)bg_blue  << 8) >> BShift) & BMask);
 } else /* depth == 8 */ {

 /* GRR:  add 8-bit support */

 }

 XSetForeground(display, gc, bg_pixel);
 XFillRectangle(display, window, gc, 0, 0, image_width, image_height);

/*---------------------------------------------------------------------------
    Wait for first Expose event to do any drawing, then flush.
  ---------------------------------------------------------------------------*/

 do
 XNextEvent(display, &e);
 while (e.type != Expose || e.xexpose.count);

 XFlush(display);

/*---------------------------------------------------------------------------
    Allocate memory for the X- and display-specific version of the image.
  ---------------------------------------------------------------------------*/

 if (depth == 24 || depth == 32) {
        xdata = (uch *)malloc(4*image_width*image_height);
        pad = 32;
 } else if (depth == 16) {
        xdata = (uch *)malloc(2*image_width*image_height);
        pad = 16;
 } else /* depth == 8 */ {
        xdata = (uch *)malloc(image_width*image_height);
        pad = 8;
 }

 if (!xdata) {
        fprintf(stderr, PROGNAME ":  unable to allocate image memory\n");
 return 4;
 }

    ximage = XCreateImage(display, visual, depth, ZPixmap, 0,
 (char *)xdata, image_width, image_height, pad, 0);

 if (!ximage) {
        fprintf(stderr, PROGNAME ":  XCreateImage() failed\n");
        free(xdata);
 return 3;
 }

 /* to avoid testing the byte order every pixel (or doubling the size of
     * the drawing routine with a giant if-test), we arbitrarily set the byte
     * order to MSBFirst and let Xlib worry about inverting things on little-
     * endian machines (like Linux/x86, old VAXen, etc.)--this is not the most
     * efficient approach (the giant if-test would be better), but in the
     * interest of clarity, we take the easy way out... */

    ximage->byte_order = MSBFirst;

 return 0;

} /* end function rpng_x_create_window() */

read_callback(png_structp pp, png_unknown_chunkp pc)
{
/* This function mimics the behavior of png_set_keep_unknown_chunks by
* returning '0' to keep the chunk and '1' to discard it.
*/
display *d = voidcast(display*, png_get_user_chunk_ptr(pp));
int chunk = findb(pc->name);
int keep, discard;

if (chunk < 0) /* not one in our list, so not a known chunk */
keep = d->keep;

else
{
keep = chunk_info[chunk].keep;
if (keep == PNG_HANDLE_CHUNK_AS_DEFAULT)
{
/* See the comments in png.h - use the default for unknown chunks,
* do not keep known chunks.
*/
if (chunk_info[chunk].unknown)
keep = d->keep;

else
keep = PNG_HANDLE_CHUNK_NEVER;
}
}

switch (keep)
{
default:
fprintf(stderr, "%s(%s): %d: unrecognized chunk option\n", d->file,
d->test, chunk_info[chunk].keep);
display_exit(d);

case PNG_HANDLE_CHUNK_AS_DEFAULT:
case PNG_HANDLE_CHUNK_NEVER:
discard = 1/*handled; discard*/;
break;

case PNG_HANDLE_CHUNK_IF_SAFE:
case PNG_HANDLE_CHUNK_ALWAYS:
discard = 0/*not handled; keep*/;
break;
}

/* Also store information about this chunk in the display, the relevant flag
* is set if the chunk is to be kept ('not handled'.)
*/
if (chunk >= 0) if (!discard) /* stupidity to stop a GCC warning */
{
png_uint_32 flag = chunk_info[chunk].flag;

if (pc->location & PNG_AFTER_IDAT)
d->after_IDAT |= flag;

else
d->before_IDAT |= flag;
}


/* However if there is no support to store unknown chunks don't ask libpng to
* do it; there will be an png_error.
*/
#  ifdef PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED
return discard;
#  else
return 1; /*handled; discard*/
#  endif

}

next_format(png_bytep colour_type, png_bytep bit_depth,
   unsigned int* palette_number, int no_low_depth_gray)
{
if (*bit_depth == 0)
{
*colour_type = 0;
      if (no_low_depth_gray)
         *bit_depth = 8;
      else
*bit_depth = 1;
*palette_number = 0;
return 1;
}

   if (*colour_type == 3)
{
      /* Add multiple palettes for colour type 3. *
      if (++*palette_number < PALETTE_COUNT(*bit_depth))
return 1;

*palette_number = 0;
}

*bit_depth = (png_byte)(*bit_depth << 1);


/* Palette images are restricted to 8 bit depth */
if (*bit_depth <= 8
#     ifdef DO_16BIT
|| (*colour_type != 3 && *bit_depth <= 16)
#     endif
)
return 1;

/* Move to the next color type, or return 0 at the end. */
switch (*colour_type)
{
case 0:
*colour_type = 2;
*bit_depth = 8;
return 1;

case 2:
*colour_type = 3;
*bit_depth = 1;
return 1;

case 3:
*colour_type = 4;
*bit_depth = 8;
return 1;

case 4:
*colour_type = 6;
*bit_depth = 8;
return 1;

default:
return 0;
}
}

IDAT_init(struct IDAT * const idat, struct file * const file)
 /* When the chunk is png_IDAT instantiate an IDAT control structure in place
    * of a chunk control structure.  The IDAT will instantiate a chunk control
    * structure using the file alloc routine.
    *
    * NOTE: this routine must only be called from the file alloc routine!
    */
{
   assert(file->chunk == NULL);
   assert(file->idat == NULL);

   CLEAR(*idat);

   idat->file = file;
   idat->global = file->global;

 /* Initialize the tail to the pre-allocated buffer and set the count to 0
    * (empty.)
    */
   idat->global->idat_cache.count = 0;
   idat->idat_list_head = idat->idat_list_tail = &idat->global->idat_cache;

 /* Now the chunk.  The allocator calls the initializer of the new chunk and
    * stores the result in file->chunk:
    */
   file->alloc(file, 0/*chunk*/);
   assert(file->chunk != NULL);

 /* And store this for cleanup (and to check for double alloc or failure to
    * free.)
    */
   file->idat = idat;
}

gpc_b16c(Pixel *out, const Pixel *in, const Background *back)
{
 if (in->a <= 0)
 {
      out->r = back->ir;
      out->g = back->ig;
      out->b = back->ib;
 }

 else
 {
 double a = in->a/65535.;
 double a1 = 1-a;

      a /= 65535;
      out->r = sRGB(in->r * a + back->dr * a1);
      out->g = sRGB(in->g * a + back->dg * a1);
      out->b = sRGB(in->b * a + back->db * a1);
 }

   out->a = 255;
}

standard_info_part1(standard_display *dp, png_structp pp, png_infop pi)
{
if (png_get_bit_depth(pp, pi) != dp->bit_depth)
png_error(pp, "validate: bit depth changed");

if (png_get_color_type(pp, pi) != dp->colour_type)
png_error(pp, "validate: color type changed");

if (png_get_filter_type(pp, pi) != PNG_FILTER_TYPE_BASE)
png_error(pp, "validate: filter type changed");

if (png_get_interlace_type(pp, pi) != dp->interlace_type)
png_error(pp, "validate: interlacing changed");

if (png_get_compression_type(pp, pi) != PNG_COMPRESSION_TYPE_BASE)
png_error(pp, "validate: compression type changed");

dp->w = png_get_image_width(pp, pi);

if (dp->w != standard_width(pp, dp->id))
png_error(pp, "validate: image width changed");

dp->h = png_get_image_height(pp, pi);

if (dp->h != standard_height(pp, dp->id))
png_error(pp, "validate: image height changed");

/* Record (but don't check at present) the input sBIT according to the colour
* type information.
*/
{
png_color_8p sBIT = 0;

if (png_get_sBIT(pp, pi, &sBIT) & PNG_INFO_sBIT)
{
int sBIT_invalid = 0;

if (sBIT == 0)
png_error(pp, "validate: unexpected png_get_sBIT result");

if (dp->colour_type & PNG_COLOR_MASK_COLOR)
{
if (sBIT->red == 0 || sBIT->red > dp->bit_depth)
sBIT_invalid = 1;
else
dp->red_sBIT = sBIT->red;

if (sBIT->green == 0 || sBIT->green > dp->bit_depth)
sBIT_invalid = 1;
else
dp->green_sBIT = sBIT->green;

if (sBIT->blue == 0 || sBIT->blue > dp->bit_depth)
sBIT_invalid = 1;
else
dp->blue_sBIT = sBIT->blue;
}

else /* !COLOR */
{
if (sBIT->gray == 0 || sBIT->gray > dp->bit_depth)
sBIT_invalid = 1;
else
dp->blue_sBIT = dp->green_sBIT = dp->red_sBIT = sBIT->gray;
}

/* All 8 bits in tRNS for a palette image are significant - see the
* spec.
*/
if (dp->colour_type & PNG_COLOR_MASK_ALPHA)
{
if (sBIT->alpha == 0 || sBIT->alpha > dp->bit_depth)
sBIT_invalid = 1;
else
dp->alpha_sBIT = sBIT->alpha;
}

if (sBIT_invalid)
png_error(pp, "validate: sBIT value out of range");
}
}

/* Important: this is validating the value *before* any transforms have been
* put in place.  It doesn't matter for the standard tests, where there are
* no transforms, but it does for other tests where rowbytes may change after
* png_read_update_info.
*/
if (png_get_rowbytes(pp, pi) != standard_rowsize(pp, dp->id))
png_error(pp, "validate: row size changed");

/* Validate the colour type 3 palette (this can be present on other color
* types.)
*/
standard_palette_validate(dp, pp, pi);

/* In any case always check for a tranparent color (notice that the
* colour type 3 case must not give a successful return on the get_tRNS call
* with these arguments!)
*/
{
png_color_16p trans_color = 0;

if (png_get_tRNS(pp, pi, 0, 0, &trans_color) & PNG_INFO_tRNS)
{
if (trans_color == 0)
png_error(pp, "validate: unexpected png_get_tRNS (color) result");

switch (dp->colour_type)
{

case 0:
dp->transparent.red = dp->transparent.green = dp->transparent.blue =
trans_color->gray;
            dp->is_transparent = 1;
break;

case 2:
dp->transparent.red = trans_color->red;
dp->transparent.green = trans_color->green;
dp->transparent.blue = trans_color->blue;
            dp->is_transparent = 1;
break;

case 3:
/* Not expected because it should result in the array case
* above.
*/
png_error(pp, "validate: unexpected png_get_tRNS result");
break;

default:
png_error(pp, "validate: invalid tRNS chunk with alpha image");
}
}
}

/* Read the number of passes - expected to match the value used when
* creating the image (interlaced or not).  This has the side effect of

* turning on interlace handling (if do_interlace is not set.)
*/
dp->npasses = npasses_from_interlace_type(pp, dp->interlace_type);
   if (!dp->do_interlace && dp->npasses != png_set_interlace_handling(pp))
      png_error(pp, "validate: file changed interlace type");

/* Caller calls png_read_update_info or png_start_read_image now, then calls
* part2.
*/
}

clear_text(png_text *text, png_charp keyword)
{
   text->compression = -1; /* none */
   text->key = keyword;
   text->text = NULL;
   text->text_length = 0; /* libpng calculates this */
   text->itxt_length = 0; /* libpng calculates this */
   text->lang = NULL;
   text->lang_key = NULL;
}

static void signal_handler(int signum)
{

 size_t pos = 0;
 char msg[64];

   pos = safecat(msg, sizeof msg, pos, "caught signal: ");

 switch (signum)
 {
 case SIGABRT:
         pos = safecat(msg, sizeof msg, pos, "abort");
 break;

 case SIGFPE:
         pos = safecat(msg, sizeof msg, pos, "floating point exception");
 break;

 case SIGILL:
         pos = safecat(msg, sizeof msg, pos, "illegal instruction");
 break;

 case SIGINT:
         pos = safecat(msg, sizeof msg, pos, "interrupt");
 break;

 case SIGSEGV:
         pos = safecat(msg, sizeof msg, pos, "invalid memory access");
 break;

 case SIGTERM:
         pos = safecat(msg, sizeof msg, pos, "termination request");
 break;

 default:
         pos = safecat(msg, sizeof msg, pos, "unknown ");
         pos = safecatn(msg, sizeof msg, pos, signum);
 break;
 }

   store_log(&pm.this, NULL/*png_structp*/, msg, 1/*error*/);

 /* And finally throw an exception so we can keep going, unless this is
    * SIGTERM in which case stop now.
    */
 if (signum != SIGTERM)
 {
 struct exception_context *the_exception_context =
 &pm.this.exception_context;

 Throw &pm.this;
 }

 else
      exit(1);
}

transform_from_formats(Transform *result, Image *in_image,
 const Image *out_image, png_const_colorp background, int via_linear)
{
   png_uint_32 in_format, out_format;
   png_uint_32 in_base, out_base;

   memset(result, 0, sizeof *result);

 /* Store the original images for error messages */
   result->in_image = in_image;
   result->out_image = out_image;

   in_format = in_image->image.format;
   out_format = out_image->image.format;

 if (in_format & PNG_FORMAT_FLAG_LINEAR)
      result->in_opaque = 65535;
 else
      result->in_opaque = 255;

   result->output_8bit = (out_format & PNG_FORMAT_FLAG_LINEAR) == 0;

   result->is_palette = 0; /* set by caller if required */
   result->accumulate = (in_image->opts & ACCUMULATE) != 0;

 /* The loaders (which need the ordering information) */
   result->in_gp = get_pixel(in_format);
   result->out_gp = get_pixel(out_format);

 /* Remove the ordering information: */
   in_format &= BASE_FORMATS | PNG_FORMAT_FLAG_COLORMAP;
   in_base = in_format & BASE_FORMATS;
   out_format &= BASE_FORMATS | PNG_FORMAT_FLAG_COLORMAP;
   out_base = out_format & BASE_FORMATS;

 if (via_linear)
 {
 /* Check for an error in this program: */
 if (out_format & (PNG_FORMAT_FLAG_LINEAR|PNG_FORMAT_FLAG_COLORMAP))
 {
         fprintf(stderr, "internal transform via linear error 0x%x->0x%x\n",
            in_format, out_format);
         exit(1);
 }

      result->transform = gpc_fn[in_base][out_base | PNG_FORMAT_FLAG_LINEAR];
      result->from_linear = gpc_fn[out_base | PNG_FORMAT_FLAG_LINEAR][out_base];
      result->error_ptr = gpc_error_via_linear[in_format][out_format];
 }

 else if (~in_format & out_format & PNG_FORMAT_FLAG_COLORMAP)
 {
 /* The input is not colormapped but the output is, the errors will
       * typically be large (only the grayscale-no-alpha case permits preserving
       * even 8-bit values.)
       */
      result->transform = gpc_fn[in_base][out_base];
      result->from_linear = NULL;
      result->error_ptr = gpc_error_to_colormap[in_base][out_base];
 }

 else
 {
 /* The caller handles the colormap->pixel value conversion, so the
       * transform function just gets a pixel value, however because libpng
       * currently contains a different implementation for mapping a colormap if
       * both input and output are colormapped we need different conversion
       * functions to deal with errors in the libpng implementation.
       */
 if (in_format & out_format & PNG_FORMAT_FLAG_COLORMAP)
         result->transform = gpc_fn_colormapped[in_base][out_base];
 else
         result->transform = gpc_fn[in_base][out_base];
      result->from_linear = NULL;
      result->error_ptr = gpc_error[in_format][out_format];
 }

 /* Follow the libpng simplified API rules to work out what to pass to the gpc
    * routines as a background value, if one is not required pass NULL so that
    * this program crashes in the even of a programming error.
    */
   result->background = NULL; /* default: not required */

 /* Rule 1: background only need be supplied if alpha is to be removed */
 if (in_format & ~out_format & PNG_FORMAT_FLAG_ALPHA)
 {
 /* The input value is 'NULL' to use the background and (otherwise) an sRGB
       * background color (to use a solid color).  The code above uses a fixed
       * byte value, BUFFER_INIT8, for buffer even for 16-bit output.  For
       * linear (16-bit) output the sRGB background color is ignored; the
       * composition is always on the background (so BUFFER_INIT8 * 257), except
       * that for the colormap (i.e. linear colormapped output) black is used.
       */
      result->background = &result->background_color;

 if (out_format & PNG_FORMAT_FLAG_LINEAR || via_linear)
 {
 if (out_format & PNG_FORMAT_FLAG_COLORMAP)
 {
            result->background_color.ir =
               result->background_color.ig =
               result->background_color.ib = 0;
            result->background_color.dr =
               result->background_color.dg =
               result->background_color.db = 0;
 }

 else
 {
            result->background_color.ir =
               result->background_color.ig =
               result->background_color.ib = BUFFER_INIT8 * 257;
            result->background_color.dr =
               result->background_color.dg =
               result->background_color.db = 0;
 }
 }

 else /* sRGB output */
 {
 if (background != NULL)
 {
 if (out_format & PNG_FORMAT_FLAG_COLOR)
 {
               result->background_color.ir = background->red;
               result->background_color.ig = background->green;
               result->background_color.ib = background->blue;
 /* TODO: sometimes libpng uses the power law conversion here, how
                * to handle this?
                */
               result->background_color.dr = sRGB_to_d[background->red];
               result->background_color.dg = sRGB_to_d[background->green];
               result->background_color.db = sRGB_to_d[background->blue];
 }

 else /* grayscale: libpng only looks at 'g' */
 {
               result->background_color.ir =
                  result->background_color.ig =
                  result->background_color.ib = background->green;
 /* TODO: sometimes libpng uses the power law conversion here, how
                * to handle this?
                */
               result->background_color.dr =
                  result->background_color.dg =
                  result->background_color.db = sRGB_to_d[background->green];
 }
 }

 else if ((out_format & PNG_FORMAT_FLAG_COLORMAP) == 0)
 {
            result->background_color.ir =
               result->background_color.ig =
               result->background_color.ib = BUFFER_INIT8;
 /* TODO: sometimes libpng uses the power law conversion here, how
             * to handle this?
             */
            result->background_color.dr =
               result->background_color.dg =
               result->background_color.db = sRGB_to_d[BUFFER_INIT8];
 }

 /* Else the output is colormapped and a background color must be
          * provided; if pngstest crashes then that is a bug in this program
          * (though libpng should png_error as well.)
          */
 else
            result->background = NULL;
 }
 }

 if (result->background == NULL)
 {
      result->background_color.ir =
         result->background_color.ig =
         result->background_color.ib = -1; /* not used */
      result->background_color.dr =
         result->background_color.dg =
         result->background_color.db = 1E30; /* not used */
 }


 /* Copy the error values into the Transform: */
   result->error[0] = result->error_ptr[0];
   result->error[1] = result->error_ptr[1];
   result->error[2] = result->error_ptr[2];
   result->error[3] = result->error_ptr[3];
}

is_bad_combo(int transforms)
{
 unsigned int i;

 for (i=0; i<ARRAY_SIZE(known_bad_combos); ++i)
 {
 int combo = known_bad_combos[i][0];

 if ((combo & transforms) == combo &&
 (transforms & known_bad_combos[i][1]) == 0)
 return 1;
 }

 return 0; /* combo is ok */
}

static double calcerr(PNG_CONST png_modifier *pm, int in_depth, int out_depth)
 {
    /* Error in the linear composition arithmetic - only relevant when
     * composition actually happens (0 < alpha < 1).
    */
 if ((pm->calculations_use_input_precision ? in_depth : out_depth) == 16)
 return pm->maxcalc16;
 else if (pm->assume_16_bit_calculations)
 return pm->maxcalcG;
 else

       return pm->maxcalc8;
 }

gpc_nop6(Pixel *out, const Pixel *in, const Background *back)
{
 (void)back;
 if (in->a == 0)
      out->r = out->g = out->b = 65535;

 else
 {
      out->r = in->r;
      out->g = in->g;
      out->b = in->b;
 }

   out->a = in->a;
}

store_flush(png_structp ppIn)
{
   UNUSED(ppIn) /*DOES NOTHING*/
}

gpc_bckg(Pixel *out, const Pixel *in, const Background *back)
{
 if (in->a <= 0)
      out->r = out->g = out->b = back->ig;

 else if (in->a >= 255)
      out->r = out->g = out->b = in->g;

 else
 {
 double a = in->a / 255.;

      out->r = out->g = out->b = sRGB(sRGB_to_d[in->g] * a + back->dg * (1-a));
 }

   out->a = 255;
}

file_end(struct file *file)
{
 int rc;

 /* If either of the chunk pointers are set end them here, the IDAT structure
    * must be deallocated first as it may deallocate the chunk structure.
    */
 if (file->idat != NULL)
      IDAT_end(&file->idat);

 if (file->chunk != NULL)
      chunk_end(&file->chunk);

   rc = file->status_code;

 if (file->file != NULL)
 (void)fclose(file->file);

 if (file->out != NULL)
 {
 /* NOTE: this is bitwise |, all the following functions must execute and
       * must succeed.
       */
 if (ferror(file->out) | fflush(file->out) | fclose(file->out))
 {
         perror(file->out_name);
         emit_error(file, READ_ERROR_CODE, "output write error");
         rc |= WRITE_ERROR;
 }
 }

 /* Accumulate the result codes */
   file->global->status_code |= rc;

   CLEAR(*file);

 return rc; /* status code: non-zero on read or write error */
}

gpc_g16(Pixel *out, const Pixel *in, const Background *back)
{
 (void)back;
   out->r = out->g = out->b = u16d(YfromRGBint(in->r, in->g, in->b));
   out->a = 65535;
}

png_pass_start_col(int pass)
{
 int x, y;
 ++pass;
 for (x=0; x<8; ++x) for (y=0; y<8; ++y) if (adam7[y][x] == pass)
 return x;
 return 0xf;
}

find_parameters(png_const_charp what, png_charp param, png_charp *list,
 int nparams)
{
 /* Parameters are separated by '\n' or ':' characters, up to nparams are
    * accepted (more is an error) and the number found is returned.
    */
 int i;
 for (i=0; *param && i<nparams; ++i)
 {
 list[i] = param;
 while (*++param) if (*param == '\n' || *param == ':')
 {
 *param++ = 0; /* Terminate last parameter */
 break; /* And start a new one. */
 }
 }

 if (*param)
 {
      fprintf(stderr, "--insert %s: too many parameters (%s)\n", what, param);
      exit(1);
 }

 list[i] = NULL; /* terminates list */
 return i; /* number of parameters filled in */
}

global_end(struct global *global)
{

 int rc;

   IDAT_list_end(&global->idat_cache);
   rc = global->status_code;
   CLEAR(*global);
 return rc;
}

modifier_init(png_modifier *pm)
{
   memset(pm, 0, sizeof *pm);
   store_init(&pm->this);
   pm->modifications = NULL;
   pm->state = modifier_start;
   pm->sbitlow = 1U;
   pm->ngammas = 0;
   pm->ngamma_tests = 0;
   pm->gammas = 0;
   pm->current_gamma = 0;
   pm->encodings = 0;
   pm->nencodings = 0;
   pm->current_encoding = 0;
   pm->encoding_counter = 0;
   pm->encoding_ignored = 0;
   pm->repeat = 0;
   pm->test_uses_encoding = 0;
   pm->maxout8 = pm->maxpc8 = pm->maxabs8 = pm->maxcalc8 = 0;
   pm->maxout16 = pm->maxpc16 = pm->maxabs16 = pm->maxcalc16 = 0;
   pm->maxcalcG = 0;
   pm->limit = 4E-3;
   pm->log8 = pm->log16 = 0; /* Means 'off' */
   pm->error_gray_2 = pm->error_gray_4 = pm->error_gray_8 = 0;
   pm->error_gray_16 = pm->error_color_8 = pm->error_color_16 = 0;
   pm->error_indexed = 0;
   pm->use_update_info = 0;
   pm->interlace_type = PNG_INTERLACE_NONE;

    pm->test_standard = 0;
    pm->test_size = 0;
    pm->test_transform = 0;
    pm->use_input_precision = 0;
    pm->use_input_precision_sbit = 0;
    pm->use_input_precision_16to8 = 0;
   pm->calculations_use_input_precision = 0;
   pm->assume_16_bit_calculations = 0;
   pm->test_gamma_threshold = 0;
   pm->test_gamma_transform = 0;
   pm->test_gamma_sbit = 0;
   pm->test_gamma_scale16 = 0;

    pm->test_gamma_background = 0;
    pm->test_gamma_alpha_mode = 0;
    pm->test_gamma_expand16 = 0;
    pm->test_exhaustive = 0;
    pm->log = 0;
 
 /* Rely on the memset for all the other fields - there are no pointers */
}

gp_argb16(Pixel *p, png_const_voidp pb)
{
   png_const_uint_16p pp = voidcast(png_const_uint_16p, pb);

   p->r = pp[1];
   p->g = pp[2];
   p->b = pp[3];
   p->a = pp[0];
}

main(void)
{
unsigned int i;
unsigned char buf[MAX_LENGTH];
unsigned long crc;
unsigned char c;
int inchar;


/* Skip 8-byte signature */
for (i=8; i; i--)
{
      c=GETBREAK;
putchar(c);
}

if (inchar != EOF)
for (;;)
{
/* Read the length */
unsigned long length; /* must be 32 bits! */
   c=GETBREAK; buf[0] = c; length  = c; length <<= 8;
   c=GETBREAK; buf[1] = c; length += c; length <<= 8;
   c=GETBREAK; buf[2] = c; length += c; length <<= 8;
   c=GETBREAK; buf[3] = c; length += c;

/* Read the chunkname */
   c=GETBREAK; buf[4] = c;
   c=GETBREAK; buf[5] = c;
   c=GETBREAK; buf[6] = c;
   c=GETBREAK; buf[7] = c;


/* The iTXt chunk type expressed as integers is (105, 84, 88, 116) */
if (buf[4] == 105 && buf[5] == 84 && buf[6] == 88 && buf[7] == 116)
{
if (length >= MAX_LENGTH-12)
break; /* To do: handle this more gracefully */

/* Initialize the CRC */
crc = crc32(0, Z_NULL, 0);


/* Copy the data bytes */
for (i=8; i < length + 12; i++)
{
         c=GETBREAK; buf[i] = c;
}

/* Calculate the CRC */
crc = crc32(crc, buf+4, (uInt)length+4);

for (;;)
{
/* Check the CRC */
        if (((crc >> 24) & 0xff) == buf[length+8] &&
            ((crc >> 16) & 0xff) == buf[length+9] &&
            ((crc >>  8) & 0xff) == buf[length+10] &&
            ((crc      ) & 0xff) == buf[length+11])
break;

length++;


if (length >= MAX_LENGTH-12)
break;

        c=GETBREAK;
        buf[length+11]=c;

/* Update the CRC */
crc = crc32(crc, buf+7+length, 1);
}

/* Update length bytes */
      buf[0] = (unsigned char)((length << 24) & 0xff);
      buf[1] = (unsigned char)((length << 16) & 0xff);
      buf[2] = (unsigned char)((length <<  8) & 0xff);
      buf[3] = (unsigned char)((length      ) & 0xff);

/* Write the fixed iTXt chunk (length, name, data, crc) */
for (i=0; i<length+12; i++)
putchar(buf[i]);
}


else
{
/* Copy bytes that were already read (length and chunk name) */
for (i=0; i<8; i++)
putchar(buf[i]);


/* Copy data bytes and CRC */
for (i=8; i< length+12; i++)
{
         c=GETBREAK;
putchar(c);
}

      if (inchar == EOF)
{
break;
}

/* The IEND chunk type expressed as integers is (73, 69, 78, 68) */
if (buf[4] == 73 && buf[5] == 69 && buf[6] == 78 && buf[7] == 68)

break;
}

   if (inchar == EOF)
break;

if (buf[4] == 73 && buf[5] == 69 && buf[6] == 78 && buf[7] == 68)
break;
}

return 0;
}

random_32(void)
{

   for(;;)
{
png_byte mark[4];
png_uint_32 result;

store_pool_mark(mark);
result = png_get_uint_32(mark);

if (result != 0)
return result;
}
}

main(int argc, char **argv)
{
FILE *fp = stdout;

const char *file_name = NULL;
int color_type = 8; /* invalid */
int bit_depth = 32; /* invalid */
unsigned int colors[5];
unsigned int filters = PNG_ALL_FILTERS;
png_fixed_point gamma = 0; /* not set */
chunk_insert *head_insert = NULL;
chunk_insert **insert_ptr = &head_insert;

memset(colors, 0, sizeof colors);

while (--argc > 0)

{
char *arg = *++argv;

if (strcmp(arg, "--sRGB") == 0)
{
gamma = PNG_DEFAULT_sRGB;
continue;
}

if (strcmp(arg, "--linear") == 0)
{
gamma = PNG_FP_1;
continue;
}

if (strcmp(arg, "--1.8") == 0)
{
gamma = PNG_GAMMA_MAC_18;
continue;
}

if (strcmp(arg, "--nofilters") == 0)
{
filters = PNG_FILTER_NONE;
continue;
}

if (strncmp(arg, "--color=", 8) == 0)
{
parse_color(arg+8, colors);
continue;
}

if (argc >= 3 && strcmp(arg, "--insert") == 0)
{
png_const_charp what = *++argv;
png_charp param = *++argv;
chunk_insert *new_insert;

argc -= 2;

new_insert = find_insert(what, param);

if (new_insert != NULL)
{
*insert_ptr = new_insert;
insert_ptr = &new_insert->next;
}

continue;
}

if (arg[0] == '-')
{
fprintf(stderr, "makepng: %s: invalid option\n", arg);
exit(1);
}

if (strcmp(arg, "palette") == 0)
{
color_type = PNG_COLOR_TYPE_PALETTE;
continue;
}

if (strncmp(arg, "gray", 4) == 0)
{
if (arg[4] == 0)
{
color_type = PNG_COLOR_TYPE_GRAY;
continue;
}

else if (strcmp(arg+4, "a") == 0 ||
strcmp(arg+4, "alpha") == 0 ||
strcmp(arg+4, "-alpha") == 0)
{
color_type = PNG_COLOR_TYPE_GRAY_ALPHA;
continue;
}
}

if (strncmp(arg, "rgb", 3) == 0)
{
if (arg[3] == 0)
{
color_type = PNG_COLOR_TYPE_RGB;
continue;
}

else if (strcmp(arg+3, "a") == 0 ||
strcmp(arg+3, "alpha") == 0 ||
strcmp(arg+3, "-alpha") == 0)
{
color_type = PNG_COLOR_TYPE_RGB_ALPHA;
continue;
}
}

if (color_type == 8 && isdigit(arg[0]))
{
color_type = atoi(arg);
if (color_type < 0 || color_type > 6 || color_type == 1 ||
color_type == 5)
{
fprintf(stderr, "makepng: %s: not a valid color type\n", arg);
exit(1);
}

continue;
}

if (bit_depth == 32 && isdigit(arg[0]))
{
bit_depth = atoi(arg);
if (bit_depth <= 0 || bit_depth > 16 ||
(bit_depth & -bit_depth) != bit_depth)
{
fprintf(stderr, "makepng: %s: not a valid bit depth\n", arg);
exit(1);
}

continue;
}

if (argc == 1) /* It's the file name */
{
fp = fopen(arg, "wb");
if (fp == NULL)
{
fprintf(stderr, "%s: %s: could not open\n", arg, strerror(errno));
exit(1);
}

file_name = arg;
continue;
}

fprintf(stderr, "makepng: %s: unknown argument\n", arg);
exit(1);
} /* argument while loop */


if (color_type == 8 || bit_depth == 32)
{
      fprintf(stderr, "usage: makepng [--sRGB|--linear|--1.8] "
"[--color=...] color-type bit-depth [file-name]\n"
         "  Make a test PNG file, by default writes to stdout.\n");
exit(1);
}

/* Check the colors */
{
const unsigned int lim = (color_type == PNG_COLOR_TYPE_PALETTE ? 255U :
(1U<<bit_depth)-1);
unsigned int i;

for (i=1; i<=colors[0]; ++i)
if (colors[i] > lim)
{
fprintf(stderr, "makepng: --color=...: %u out of range [0..%u]\n",
colors[i], lim);
exit(1);

}
}

/* Restrict the filters for more speed to those we know are used for the
* generated images.
*/
   if (filters == PNG_ALL_FILTERS)
{
if ((color_type & PNG_COLOR_MASK_PALETTE) != 0 || bit_depth < 8)
filters = PNG_FILTER_NONE;

else if (color_type & PNG_COLOR_MASK_COLOR) /* rgb */
{
if (bit_depth == 8)
filters &= ~(PNG_FILTER_NONE | PNG_FILTER_AVG);

else
filters = PNG_FILTER_SUB | PNG_FILTER_PAETH;
}

else /* gray 8 or 16-bit */

filters &= ~PNG_FILTER_NONE;
}

{
int ret = write_png(&file_name, fp, color_type, bit_depth, gamma,
         head_insert, filters, colors);

if (ret != 0 && file_name != NULL)
remove(file_name);

return ret;
}
}

gp_ga8(Pixel *p, png_const_voidp pb)
{
   png_const_bytep pp = voidcast(png_const_bytep, pb);

   p->r = p->g = p->b = pp[0];
   p->a = pp[1];
}

static void initimage(Image *image, png_uint_32 opts, const char *file_name,
 int stride_extra)
{
   freeimage(image);
   memset(&image->image, 0, sizeof image->image);
   image->opts = opts;
   image->file_name = file_name;
   image->stride_extra = stride_extra;
}

static double pcerr(PNG_CONST png_modifier *pm, int in_depth, int out_depth)
 {
    /* Percentage error permitted in the linear values.  Note that the specified
     * value is a percentage but this routine returns a simple number.
    */
 if (pm->assume_16_bit_calculations ||
 (pm->calculations_use_input_precision ? in_depth : out_depth) == 16)
 return pm->maxpc16 * .01;
 else
 return pm->maxpc8 * .01;
}

image_transform_png_set_strip_alpha_set(PNG_CONST image_transform *this,
     transform_display *that, png_structp pp, png_infop pi)
 {
    png_set_strip_alpha(pp);
 this->next->set(this->next, that, pp, pi);

 }

void png_fixed_warning(png_const_structrp png_ptr, png_const_charp msg)
{
   fprintf(stderr, "overflow in: %s\n", msg);
}

gama_modify(png_modifier *pm, png_modification *me, int add)
{
   UNUSED(add)
 /* This simply dumps the given gamma value into the buffer. */
   png_save_uint_32(pm->buffer, 4);
   png_save_uint_32(pm->buffer+4, CHUNK_gAMA);
   png_save_uint_32(pm->buffer+8, ((gama_modification*)me)->gamma);
 return 1;
}

modification_init(png_modification *pmm)
{
   memset(pmm, 0, sizeof *pmm);
   pmm->next = NULL;
   pmm->chunk = 0;
   pmm->modify_fn = NULL;
   pmm->add = 0;
   modification_reset(pmm);
}

warning(png_structp png_ptr, const char *message)
{
   display *d = (display*)png_get_error_ptr(png_ptr);

   fprintf(stderr, "%s(%s): libpng warning: %s\n", d->file, d->test, message);
 ++(d->warning_count);
}

ilinear_g22(int fixed_srgb)
{
 return u16d(65535 * g22_to_d[fixed_srgb]);
}

gpc_pre(Pixel *out, const Pixel *in, const Background *back)
{
 (void)back;

   out->r = ilineara(in->r, in->a);

 if (in->g == in->r)
 {
      out->g = out->r;

 if (in->b == in->r)
         out->b = out->r;

 else
         out->b = ilineara(in->b, in->a);
 }

 else
 {
      out->g = ilineara(in->g, in->a);

 if (in->b == in->r)
         out->b = out->r;

 else if (in->b == in->g)
         out->b = out->g;

 else
         out->b = ilineara(in->b, in->a);
 }

   out->a = in->a * 257;
}

set_store_for_read(png_store *ps, png_infopp ppi, png_uint_32 id,
   PNG_CONST char *name)
{
/* Set the name for png_error */
safecat(ps->test, sizeof ps->test, 0, name);

if (ps->pread != NULL)
png_error(ps->pread, "read store already in use");

store_read_reset(ps);

/* Both the create APIs can return NULL if used in their default mode
* (because there is no other way of handling an error because the jmp_buf
* by default is stored in png_struct and that has not been allocated!)
* However, given that store_error works correctly in these circumstances
* we don't ever expect NULL in this program.
*/
#  ifdef PNG_USER_MEM_SUPPORTED
if (!ps->speed)
ps->pread = png_create_read_struct_2(PNG_LIBPNG_VER_STRING, ps,
store_error, store_warning, &ps->read_memory_pool, store_malloc,
store_free);

else
#  endif
ps->pread = png_create_read_struct(PNG_LIBPNG_VER_STRING, ps, store_error,
store_warning);

if (ps->pread == NULL)
{
struct exception_context *the_exception_context = &ps->exception_context;

store_log(ps, NULL, "png_create_read_struct returned NULL (unexpected)",
1 /*error*/);

Throw ps;
}

#  ifdef PNG_SET_OPTION_SUPPORTED
{
int opt;
for (opt=0; opt<ps->noptions; ++opt)
if (png_set_option(ps->pread, ps->options[opt].option,
ps->options[opt].setting) == PNG_OPTION_INVALID)
png_error(ps->pread, "png option invalid");
}
#  endif

store_read_set(ps, id);

if (ppi != NULL)
*ppi = ps->piread = png_create_info_struct(ps->pread);

return ps->pread;
}

int readpng2_init(mainprog_info *mainprog_ptr)
{
png_structp  png_ptr; /* note:  temporary variables! */
png_infop  info_ptr;



/* could also replace libpng warning-handler (final NULL), but no need: */

    png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, mainprog_ptr,
readpng2_error_handler, readpng2_warning_handler);
if (!png_ptr)
return 4;   /* out of memory */

info_ptr = png_create_info_struct(png_ptr);
if (!info_ptr) {
png_destroy_read_struct(&png_ptr, NULL, NULL);
return 4; /* out of memory */
}


/* we could create a second info struct here (end_info), but it's only
* useful if we want to keep pre- and post-IDAT chunk info separated
* (mainly for PNG-aware image editors and converters) */


/* setjmp() must be called in every function that calls a PNG-reading
* libpng function, unless an alternate error handler was installed--
* but compatible error handlers must either use longjmp() themselves
* (as in this program) or exit immediately, so here we are: */

if (setjmp(mainprog_ptr->jmpbuf)) {
png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
return 2;
}


#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
/* prepare the reader to ignore all recognized chunks whose data won't be
* used, i.e., all chunks recognized by libpng except for IHDR, PLTE, IDAT,
* IEND, tRNS, bKGD, gAMA, and sRGB (small performance improvement) */
{
/* These byte strings were copied from png.h.  If a future version
* of readpng2.c recognizes more chunks, add them to this list.
*/
static PNG_CONST png_byte chunks_to_process[] = {
98, 75, 71, 68, '\0', /* bKGD */
103, 65, 77, 65, '\0', /* gAMA */
115, 82, 71, 66, '\0', /* sRGB */
};

/* Ignore all chunks except for IHDR, PLTE, tRNS, IDAT, and IEND */
png_set_keep_unknown_chunks(png_ptr, -1 /* PNG_HANDLE_CHUNK_NEVER */,
NULL, -1);

/* But do not ignore chunks in the "chunks_to_process" list */
png_set_keep_unknown_chunks(png_ptr,
0 /* PNG_HANDLE_CHUNK_AS_DEFAULT */, chunks_to_process,
sizeof(chunks_to_process)/5);
}
#endif /* PNG_HANDLE_AS_UNKNOWN_SUPPORTED */


/* instead of doing png_init_io() here, now we set up our callback
* functions for progressive decoding */

png_set_progressive_read_fn(png_ptr, mainprog_ptr,
readpng2_info_callback, readpng2_row_callback, readpng2_end_callback);


/* make sure we save our pointers for use in readpng2_decode_data() */

mainprog_ptr->png_ptr = png_ptr;
mainprog_ptr->info_ptr = info_ptr;


/* and that's all there is to initialization */

return 0;
}

gp_bgr16(Pixel *p, png_const_voidp pb)
{
   png_const_uint_16p pp = voidcast(png_const_uint_16p, pb);

   p->r = pp[2];
   p->g = pp[1];
   p->b = pp[0];
   p->a = 65535;
}

standard_text_validate(standard_display *dp, png_const_structp pp,
   png_infop pi, int check_end)
{
   png_textp tp = NULL;
   png_uint_32 num_text = png_get_text(pp, pi, &tp, NULL);

 if (num_text == 2 && tp != NULL)
 {
      standard_check_text(pp, tp, "image name", dp->ps->current->name);

 /* This exists because prior to 1.5.18 the progressive reader left the
       * png_struct z_stream unreset at the end of the image, so subsequent
       * attempts to use it simply returns Z_STREAM_END.
       */
 if (check_end)
         standard_check_text(pp, tp+1, "end marker", "end");
 }

 else
 {
 char msg[64];

      sprintf(msg, "expected two text items, got %lu",
 (unsigned long)num_text);
      png_error(pp, msg);
 }
}

transform_range_check(png_const_structp pp, unsigned int r, unsigned int g,
unsigned int b, unsigned int a, unsigned int in_digitized, double in,
unsigned int out, png_byte sample_depth, double err, double limit,
   PNG_CONST char *name, double digitization_error)
{
/* Compare the scaled, digitzed, values of our local calculation (in+-err)
* with the digitized values libpng produced;  'sample_depth' is the actual
* digitization depth of the libpng output colors (the bit depth except for
* palette images where it is always 8.)  The check on 'err' is to detect
* internal errors in pngvalid itself.
*/
unsigned int max = (1U<<sample_depth)-1;
double in_min = ceil((in-err)*max - digitization_error);
double in_max = floor((in+err)*max + digitization_error);
if (err > limit || !(out >= in_min && out <= in_max))
{
char message[256];
size_t pos;

pos = safecat(message, sizeof message, 0, name);
pos = safecat(message, sizeof message, pos, " output value error: rgba(");
pos = safecatn(message, sizeof message, pos, r);
pos = safecat(message, sizeof message, pos, ",");
pos = safecatn(message, sizeof message, pos, g);
pos = safecat(message, sizeof message, pos, ",");
pos = safecatn(message, sizeof message, pos, b);
pos = safecat(message, sizeof message, pos, ",");
pos = safecatn(message, sizeof message, pos, a);
pos = safecat(message, sizeof message, pos, "): ");
pos = safecatn(message, sizeof message, pos, out);
pos = safecat(message, sizeof message, pos, " expected: ");
pos = safecatn(message, sizeof message, pos, in_digitized);
pos = safecat(message, sizeof message, pos, " (");
pos = safecatd(message, sizeof message, pos, (in-err)*max, 3);
pos = safecat(message, sizeof message, pos, "..");
pos = safecatd(message, sizeof message, pos, (in+err)*max, 3);
pos = safecat(message, sizeof message, pos, ")");

png_error(pp, message);
}
}

gp_g8(Pixel *p, png_const_voidp pb)
{
   png_const_bytep pp = voidcast(png_const_bytep, pb);

   p->r = p->g = p->b = pp[0];
   p->a = 255;
}

read_byte(struct file *file)
{
 int ch = getc(file->file);

 if (ch >= 0 && ch <= 255)
 {
 ++(file->read_count);
 return ch;
 }

 else if (ch != EOF)
 {
      file->status_code |= INTERNAL_ERROR;
      file->read_errno = ERANGE; /* out of range character */

 /* This is very unexpected; an error message is always output: */
      emit_error(file, UNEXPECTED_ERROR_CODE, "file read");
 }

#  ifdef EINTR
 else if (errno == EINTR) /* Interrupted, try again */
 {
         errno = 0;
 return read_byte(file);
 }
#  endif

 else
 {
 /* An error, it doesn't really matter what the error is but it gets
       * recorded anyway.
       */
 if (ferror(file->file))
         file->read_errno = errno;

 else if (feof(file->file))
         file->read_errno = 0; /* I.e. a regular EOF, no error */

 else /* unexpected */
         file->read_errno = EDOM;
 }

 /* 'TRUNCATED' is used for all cases of failure to read a byte, because of
    * the way libpng works a byte read is never attempted unless the byte is
    * expected to be there, so EOF should not occur.
    */
   file->status_code |= TRUNCATED;
 return EOF;
}

standard_row(png_const_structp pp, png_byte std[STANDARD_ROWMAX],
   png_uint_32 id, png_uint_32 y)
{
 if (WIDTH_FROM_ID(id) == 0)
      transform_row(pp, std, COL_FROM_ID(id), DEPTH_FROM_ID(id), y);
 else
      size_row(std, WIDTH_FROM_ID(id) * bit_size(pp, COL_FROM_ID(id),
         DEPTH_FROM_ID(id)), y);
}

modifier_setbuffer(png_modifier *pm)
{
   modifier_crc(pm->buffer);
   pm->buffer_count = png_get_uint_32(pm->buffer)+12;
   pm->buffer_position = 0;
}

perform_transform_test(png_modifier *pm)
{
png_byte colour_type = 0;

png_byte bit_depth = 0;
unsigned int palette_number = 0;

   while (next_format(&colour_type, &bit_depth, &palette_number, 0))
{
png_uint_32 counter = 0;
size_t base_pos;
char name[64];

base_pos = safecat(name, sizeof name, 0, "transform:");


for (;;)
{
size_t pos = base_pos;
         PNG_CONST image_transform *list = 0;

/* 'max' is currently hardwired to '1'; this should be settable on the
* command line.
*/
counter = image_transform_add(&list, 1/*max*/, counter,
name, sizeof name, &pos, colour_type, bit_depth);

if (counter == 0)
break;

/* The command line can change this to checking interlaced images. */
do
{
pm->repeat = 0;
transform_test(pm, FILEID(colour_type, bit_depth, palette_number,
pm->interlace_type, 0, 0, 0), list, name);

if (fail(pm))
return;
}
while (pm->repeat);
}
}
}

image_pixel_setf(image_pixel *this, unsigned int max)
{
   this->redf = this->red / (double)max;
   this->greenf = this->green / (double)max;
   this->bluef = this->blue / (double)max;
   this->alphaf = this->alpha / (double)max;

   if (this->red < max)
this->rede = this->redf * DBL_EPSILON;
else
this->rede = 0;
   if (this->green < max)
this->greene = this->greenf * DBL_EPSILON;
else
this->greene = 0;
   if (this->blue < max)
this->bluee = this->bluef * DBL_EPSILON;
else
this->bluee = 0;
   if (this->alpha < max)
this->alphae = this->alphaf * DBL_EPSILON;
else
this->alphae = 0;
}

checkbuffer(Image *image, const char *arg)
{
 if (check16(image->buffer, 95))
 {
      fflush(stdout);
      fprintf(stderr, "%s: overwrite at start of image buffer\n", arg);
      exit(1);
 }

 if (check16(image->buffer+16+image->allocsize, 95))
 {
      fflush(stdout);
      fprintf(stderr, "%s: overwrite at end of image buffer\n", arg);
      exit(1);
 }
}

static void perform_gamma_sbit_tests(png_modifier *pm)
{
png_byte sbit;

/* The only interesting cases are colour and grayscale, alpha is ignored here
* for overall speed.  Only bit depths where sbit is less than the bit depth
* are tested.
*/
for (sbit=pm->sbitlow; sbit<(1<<READ_BDHI); ++sbit)
{

png_byte colour_type = 0, bit_depth = 0;
unsigned int npalette = 0;

      while (next_format(&colour_type, &bit_depth, &npalette, 1/*gamma*/))
if ((colour_type & PNG_COLOR_MASK_ALPHA) == 0 &&
((colour_type == 3 && sbit < 8) ||
(colour_type != 3 && sbit < bit_depth)))
{
unsigned int i;

for (i=0; i<pm->ngamma_tests; ++i)
{
unsigned int j;

for (j=0; j<pm->ngamma_tests; ++j) if (i != j)
{
gamma_transform_test(pm, colour_type, bit_depth, npalette,
pm->interlace_type, 1/pm->gammas[i], pm->gammas[j],
sbit, pm->use_input_precision_sbit, 0 /*scale16*/);

if (fail(pm))
return;
}
}
}
}
}

standard_width(png_const_structp pp, png_uint_32 id)
{
   png_uint_32 width = WIDTH_FROM_ID(id);
   UNUSED(pp)

 if (width == 0)
      width = transform_width(pp, COL_FROM_ID(id), DEPTH_FROM_ID(id));

 return width;
}

error_handler(png_structp png_ptr, png_const_charp message)
{
   stop(get_control(png_ptr),  LIBPNG_ERROR_CODE, message);
}

sample(png_const_bytep row, png_byte colour_type, png_byte bit_depth,
    png_uint_32 x, unsigned int sample_index)
{
png_uint_32 bit_index, result;

/* Find a sample index for the desired sample: */
x *= bit_depth;
bit_index = x;

if ((colour_type & 1) == 0) /* !palette */
{
if (colour_type & 2)
bit_index *= 3;

if (colour_type & 4)
bit_index += x; /* Alpha channel */

/* Multiple channels; select one: */
if (colour_type & (2+4))
bit_index += sample_index * bit_depth;
}

/* Return the sample from the row as an integer. */
row += bit_index >> 3;
result = *row;

if (bit_depth == 8)

return result;

else if (bit_depth > 8)
      return (result << 8) + *++row;

   /* Less than 8 bits per sample. *
bit_index &= 7;
   return (result >> (8-bit_index-bit_depth)) & ((1U<<bit_depth)-1);
}

int main(int argc, char **argv)
{
#ifdef sgi
char tmpline[80];
#endif
char *p, *bgstr = NULL;
int rc, alen, flen;
int error = 0;
int timing = FALSE;
int have_bg = FALSE;
#ifdef FEATURE_LOOP
int loop = FALSE;
long loop_interval = -1; /* seconds (100,000 max) */
#endif
double LUT_exponent; /* just the lookup table */
double CRT_exponent = 2.2; /* just the monitor */
double default_display_exponent; /* whole display system */
XEvent e;
KeySym k;


/* First initialize a few things, just to be sure--memset takes care of
* default background color (black), booleans (FALSE), pointers (NULL),
* etc. */

displayname = (char *)NULL;
filename = (char *)NULL;
memset(&rpng2_info, 0, sizeof(mainprog_info));


/* Set the default value for our display-system exponent, i.e., the
* product of the CRT exponent and the exponent corresponding to
* the frame-buffer's lookup table (LUT), if any.  This is not an
* exhaustive list of LUT values (e.g., OpenStep has a lot of weird
* ones), but it should cover 99% of the current possibilities. */

#if defined(NeXT)
/* third-party utilities can modify the default LUT exponent */
LUT_exponent = 1.0 / 2.2;
/*
if (some_next_function_that_returns_gamma(&next_gamma))
LUT_exponent = 1.0 / next_gamma;
*/
#elif defined(sgi)
LUT_exponent = 1.0 / 1.7;
/* there doesn't seem to be any documented function to
* get the "gamma" value, so we do it the hard way */
infile = fopen("/etc/config/system.glGammaVal", "r");
if (infile) {
double sgi_gamma;

fgets(tmpline, 80, infile);
fclose(infile);
sgi_gamma = atof(tmpline);
if (sgi_gamma > 0.0)
LUT_exponent = 1.0 / sgi_gamma;
}
#elif defined(Macintosh)
LUT_exponent = 1.8 / 2.61;
/*
if (some_mac_function_that_returns_gamma(&mac_gamma))
LUT_exponent = mac_gamma / 2.61;
*/
#else
LUT_exponent = 1.0; /* assume no LUT:  most PCs */
#endif

/* the defaults above give 1.0, 1.3, 1.5 and 2.2, respectively: */
default_display_exponent = LUT_exponent * CRT_exponent;


/* If the user has set the SCREEN_GAMMA environment variable as suggested
* (somewhat imprecisely) in the libpng documentation, use that; otherwise
* use the default value we just calculated.  Either way, the user may
* override this via a command-line option. */

if ((p = getenv("SCREEN_GAMMA")) != NULL)
rpng2_info.display_exponent = atof(p);
else
rpng2_info.display_exponent = default_display_exponent;


/* Now parse the command line for options and the PNG filename. */

while (*++argv && !error) {
if (!strncmp(*argv, "-display", 2)) {
if (!*++argv)
++error;
else
displayname = *argv;
} else if (!strncmp(*argv, "-gamma", 2)) {
if (!*++argv)
++error;
else {
rpng2_info.display_exponent = atof(*argv);
if (rpng2_info.display_exponent <= 0.0)
++error;
}
} else if (!strncmp(*argv, "-bgcolor", 4)) {
if (!*++argv)
++error;
else {
bgstr = *argv;
if (strlen(bgstr) != 7 || bgstr[0] != '#')
++error;
else {
have_bg = TRUE;
bg_image = FALSE;
}
}
} else if (!strncmp(*argv, "-bgpat", 4)) {
if (!*++argv)
++error;
else {
pat = atoi(*argv);
if (pat >= 0 && pat < num_bgpat) {
bg_image = TRUE;
have_bg = FALSE;
} else
++error;
}
} else if (!strncmp(*argv, "-usleep", 2)) {
if (!*++argv)
++error;
else {
usleep_duration = (ulg)atol(*argv);
demo_timing = TRUE;
}
} else if (!strncmp(*argv, "-pause", 2)) {
pause_after_pass = TRUE;
} else if (!strncmp(*argv, "-timing", 2)) {
timing = TRUE;
#ifdef FEATURE_LOOP
} else if (!strncmp(*argv, "-loop", 2)) {
loop = TRUE;
if (!argv[1] || !is_number(argv[1]))
loop_interval = 2;
else {
++argv;
loop_interval = atol(*argv);
if (loop_interval < 0)
loop_interval = 2;
else if (loop_interval > 100000) /* bit more than one day */
loop_interval = 100000;
}
#endif
} else {
if (**argv != '-') {
filename = *argv;
if (argv[1]) /* shouldn't be any more args after filename */
++error;
} else
++error; /* not expecting any other options */
}
}

if (!filename)
++error;


/* print usage screen if any errors up to this point */

if (error) {

fprintf(stderr, "\n%s %s:  %s\n\n", PROGNAME, VERSION, appname);
readpng2_version_info();
fprintf(stderr, "\n"
          "Usage:  %s [-display xdpy] [-gamma exp] [-bgcolor bg | -bgpat pat]\n"
#ifdef FEATURE_LOOP
          "        %*s [-usleep dur | -timing] [-pause] [-loop [sec]] file.png\n\n"
#else
          "        %*s [-usleep dur | -timing] [-pause] file.png\n\n"
#endif
"    xdpy\tname of the target X display (e.g., ``hostname:0'')\n"
"    exp \ttransfer-function exponent (``gamma'') of the display\n"
"\t\t  system in floating-point format (e.g., ``%.1f''); equal\n"
          "\t\t  to the product of the lookup-table exponent (varies)\n"
"\t\t  and the CRT exponent (usually 2.2); must be positive\n"
"    bg  \tdesired background color in 7-character hex RGB format\n"
"\t\t  (e.g., ``#ff7700'' for orange:  same as HTML colors);\n"
"\t\t  used with transparent images; overrides -bgpat\n"
"    pat \tdesired background pattern number (0-%d); used with\n"
          "\t\t  transparent images; overrides -bgcolor\n"
#ifdef FEATURE_LOOP
"    -loop\tloops through background images after initial display\n"
"\t\t  is complete (depends on -bgpat)\n"
          "    sec \tseconds to display each background image (default = 2)\n"
#endif
"    dur \tduration in microseconds to wait after displaying each\n"
"\t\t  row (for demo purposes)\n"
"    -timing\tenables delay for every block read, to simulate modem\n"
"\t\t  download of image (~36 Kbps)\n"
"    -pause\tpauses after displaying each pass until mouse clicked\n"
"\nPress Q, Esc or mouse button 1 (within image window, after image\n"
          "is displayed) to quit.\n"
          "\n", PROGNAME,
          (int)strlen(PROGNAME), " ", default_display_exponent, num_bgpat-1);
exit(1);
}

if (!(infile = fopen(filename, "rb"))) {
fprintf(stderr, PROGNAME ":  can't open PNG file [%s]\n", filename);
++error;
} else {
incount = fread(inbuf, 1, INBUFSIZE, infile);
if (incount < 8 || !readpng2_check_sig(inbuf, 8)) {
fprintf(stderr, PROGNAME
":  [%s] is not a PNG file: incorrect signature\n",
filename);
++error;
} else if ((rc = readpng2_init(&rpng2_info)) != 0) {
switch (rc) {
case 2:
fprintf(stderr, PROGNAME
":  [%s] has bad IHDR (libpng longjmp)\n", filename);
break;
case 4:
fprintf(stderr, PROGNAME ":  insufficient memory\n");
break;
default:
fprintf(stderr, PROGNAME
":  unknown readpng2_init() error\n");
break;
}
++error;
} else {
Trace((stderr, "about to call XOpenDisplay()\n"))
display = XOpenDisplay(displayname);
if (!display) {
readpng2_cleanup(&rpng2_info);
fprintf(stderr, PROGNAME ":  can't open X display [%s]\n",
displayname? displayname : "default");
++error;
}
}
if (error)
fclose(infile);
}


if (error) {
fprintf(stderr, PROGNAME ":  aborting.\n");
exit(2);
}


/* set the title-bar string, but make sure buffer doesn't overflow */

alen = strlen(appname);
flen = strlen(filename);
if (alen + flen + 3 > 1023)
sprintf(titlebar, "%s:  ...%s", appname, filename+(alen+flen+6-1023));
else
sprintf(titlebar, "%s:  %s", appname, filename);


/* set some final rpng2_info variables before entering main data loop */

if (have_bg) {
unsigned r, g, b; /* this approach quiets compiler warnings */

sscanf(bgstr+1, "%2x%2x%2x", &r, &g, &b);
rpng2_info.bg_red   = (uch)r;
rpng2_info.bg_green = (uch)g;
rpng2_info.bg_blue  = (uch)b;
} else
rpng2_info.need_bgcolor = TRUE;

rpng2_info.state = kPreInit;
rpng2_info.mainprog_init = rpng2_x_init;
rpng2_info.mainprog_display_row = rpng2_x_display_row;
rpng2_info.mainprog_finish_display = rpng2_x_finish_display;


/* OK, this is the fun part:  call readpng2_decode_data() at the start of
* the loop to deal with our first buffer of data (read in above to verify
* that the file is a PNG image), then loop through the file and continue
* calling the same routine to handle each chunk of data.  It in turn
* passes the data to libpng, which will invoke one or more of our call-
* backs as decoded data become available.  We optionally call sleep() for
* one second per iteration to simulate downloading the image via an analog
* modem. */

for (;;) {
Trace((stderr, "about to call readpng2_decode_data()\n"))
if (readpng2_decode_data(&rpng2_info, inbuf, incount))
++error;
Trace((stderr, "done with readpng2_decode_data()\n"))

if (error || incount != INBUFSIZE || rpng2_info.state == kDone) {
if (rpng2_info.state == kDone) {
Trace((stderr, "done decoding PNG image\n"))
} else if (ferror(infile)) {
fprintf(stderr, PROGNAME
":  error while reading PNG image file\n");
exit(3);
} else if (feof(infile)) {
fprintf(stderr, PROGNAME ":  end of file reached "
"(unexpectedly) while reading PNG image file\n");
exit(3);
} else /* if (error) */ {
/* will print error message below */
}
break;
}

if (timing)
sleep(1);

incount = fread(inbuf, 1, INBUFSIZE, infile);
}


/* clean up PNG stuff and report any decoding errors */

fclose(infile);
Trace((stderr, "about to call readpng2_cleanup()\n"))
readpng2_cleanup(&rpng2_info);

if (error) {
fprintf(stderr, PROGNAME ":  libpng error while decoding PNG image\n");
exit(3);
}


#ifdef FEATURE_LOOP

if (loop && bg_image) {
Trace((stderr, "entering -loop loop (FEATURE_LOOP)\n"))
for (;;) {
int i, use_sleep;
struct timeval now, then;

/* get current time and add loop_interval to get target time */
if (gettimeofday(&then, NULL) == 0) {
then.tv_sec += loop_interval;
use_sleep = FALSE;
} else
use_sleep = TRUE;

/* do quick check for a quit event but don't wait for it */
/* GRR BUG:  should also check for Expose events and redraw... */
if (XCheckMaskEvent(display, KeyPressMask | ButtonPressMask, &e))
if (QUIT(e,k))
break;

/* generate next background image */
if (++pat >= num_bgpat)
pat = 0;
rpng2_x_reload_bg_image();

/* wait for timeout, using whatever means are available */
if (use_sleep || gettimeofday(&now, NULL) != 0) {
for (i = loop_interval;  i > 0; --i) {
sleep(1);
/* GRR BUG:  also need to check for Expose (and redraw!) */
if (XCheckMaskEvent(display, KeyPressMask | ButtonPressMask,
&e) && QUIT(e,k))
break;
}
} else {
/* Y2038 BUG! */
if (now.tv_sec < then.tv_sec ||
(now.tv_sec == then.tv_sec && now.tv_usec < then.tv_usec))
{
int quit = FALSE;
long seconds_to_go = then.tv_sec - now.tv_sec;
long usleep_usec;

/* basically chew up most of remaining loop-interval with
*  calls to sleep(1) interleaved with checks for quit
*  events, but also recalc time-to-go periodically; when
*  done, clean up any remaining time with usleep() call
*  (could also use SIGALRM, but signals are a pain...) */
while (seconds_to_go-- > 1) {
int seconds_done = 0;

for (i = seconds_to_go;  i > 0 && !quit; --i) {
sleep(1);
/* GRR BUG:  need to check for Expose and redraw */
if (XCheckMaskEvent(display, KeyPressMask |
ButtonPressMask, &e) && QUIT(e,k))
quit = TRUE;
if (++seconds_done > 1000)
break; /* time to redo seconds_to_go meas. */
}
if (quit)
break;

/* OK, more than 1000 seconds since last check:
*  correct the time-to-go measurement for drift */
if (gettimeofday(&now, NULL) == 0) {
if (now.tv_sec >= then.tv_sec)
break;
seconds_to_go = then.tv_sec - now.tv_sec;
} else
++seconds_to_go; /* restore what we subtracted */
}
if (quit)
break; /* breaks outer do-loop, skips redisplay */

/* since difference between "now" and "then" is already
*  eaten up to within a couple of seconds, don't need to
*  worry about overflow--but might have overshot (neg.) */
if (gettimeofday(&now, NULL) == 0) {
usleep_usec = 1000000L*(then.tv_sec - now.tv_sec) +
then.tv_usec - now.tv_usec;
if (usleep_usec > 0)
usleep((ulg)usleep_usec);
}
}
}

/* composite image against new background and display (note that
*  we do not take into account the time spent doing this...) */
rpng2_x_redisplay_image (0, 0, rpng2_info.width, rpng2_info.height);
}

} else /* FALL THROUGH and do the normal thing */

#endif /* FEATURE_LOOP */

/* wait for the user to tell us when to quit */

if (rpng2_info.state >= kWindowInit) {
Trace((stderr, "entering final wait-for-quit-event loop\n"))
do {
XNextEvent(display, &e);
if (e.type == Expose) {
XExposeEvent *ex = (XExposeEvent *)&e;
rpng2_x_redisplay_image (ex->x, ex->y, ex->width, ex->height);
}
} while (!QUIT(e,k));
} else {
fprintf(stderr, PROGNAME ":  init callback never called:  probable "
"libpng error while decoding PNG metadata\n");
exit(4);
}


/* we're done:  clean up all image and X resources and go away */


Trace((stderr, "about to call rpng2_x_cleanup()\n"))
rpng2_x_cleanup();

return 0;
}

store_pool_init(png_store *ps, store_pool *pool)
{
   memset(pool, 0, sizeof *pool);

   pool->store = ps;
   pool->list = NULL;
   pool->max = pool->current = pool->limit = pool->total = 0;
   pool->max_max = pool->max_limit = pool->max_total = 0;
   store_pool_mark(pool->mark);
}

store_freefile(png_store_file **ppf)
{
 if (*ppf != NULL)
 {
      store_freefile(&(*ppf)->next);

      store_freebuffer(&(*ppf)->data);
 (*ppf)->datacount = 0;
 if ((*ppf)->palette != NULL)
 {
         free((*ppf)->palette);
 (*ppf)->palette = NULL;
 (*ppf)->npalette = 0;
 }
      free(*ppf);
 *ppf = NULL;
 }
}

image_size_of_type(int color_type, int bit_depth, unsigned int *colors)
{
if (*colors)
return 16;

else

{
int pixel_depth = pixel_depth_of_type(color_type, bit_depth);

      if (pixel_depth < 8)
return 64;

else if (pixel_depth > 16)
return 1024;

else
return 256;
}
}

summarize_gamma_errors(png_modifier *pm, png_const_charp who, int low_bit_depth,
 int indexed)
{
   fflush(stderr);

 if (who)
      printf("\nGamma correction with %s:\n", who);

 else
      printf("\nBasic gamma correction:\n");

 if (low_bit_depth)
 {
      print_one(" 2 bit gray: ", pm->error_gray_2);
      print_one(" 4 bit gray: ", pm->error_gray_4);
      print_one(" 8 bit gray: ", pm->error_gray_8);
      print_one(" 8 bit color:", pm->error_color_8);
 if (indexed)
         print_one(" indexed:    ", pm->error_indexed);
 }

   print_one("16 bit gray: ", pm->error_gray_16);
   print_one("16 bit color:", pm->error_color_16);

   fflush(stdout);
}

IDAT_list_init(struct IDAT_list *list)
{
   CLEAR(*list);

 list->next = NULL;
 list->length = IDAT_INIT_LENGTH;
}

gpc_gprq(Pixel *out, const Pixel *in, const Background *back)
{
 (void)back;

 if (in->r == in->g && in->g == in->b)
      out->r = out->g = out->b = ilineara(in->g, in->a);

 else
      out->r = out->g = out->b = u16d(in->a * 257 *
 YfromRGB(sRGB_to_d[in->r], sRGB_to_d[in->g], sRGB_to_d[in->b]));

   out->a = 65535;
}

modifier_color_encoding_is_sRGB(PNG_CONST png_modifier *pm)
 {
    return pm->current_encoding != 0 && pm->current_encoding == pm->encodings &&
       pm->current_encoding->gamma == pm->current_gamma;
 }

emit_error(struct file *file, int code, const char *what)
 /* Generic error message routine, takes a 'stop' code but can be used
    * elsewhere.  Always outputs a message.
    */
{
 const char *reason;
 int err = 0;

 switch (code)
 {
 case LIBPNG_WARNING_CODE:   reason = "libpng warning:"; break;
 case LIBPNG_ERROR_CODE:     reason = "libpng error:"; break;
 case ZLIB_ERROR_CODE:       reason = "zlib error:"; break;
 case INVALID_ERROR_CODE:    reason = "invalid"; break;
 case READ_ERROR_CODE:       reason = "read failure:";
                                  err = file->read_errno;
 break;
 case WRITE_ERROR_CODE:      reason = "write error";
                                  err = file->write_errno;
 break;
 case UNEXPECTED_ERROR_CODE: reason = "unexpected error:";
                                  err = file->read_errno;
 if (err == 0)
                                     err = file->write_errno;
 break;
 default:                    reason = "INVALID (internal error):"; break;
 }

 if (err != 0)
      fprintf(stderr, "%s: %s %s [%s]\n", file->file_name, reason, what,
         strerror(err));

 else
      fprintf(stderr, "%s: %s %s\n", file->file_name, reason, what);
}

 randomize(void *pv, size_t size)
 {
 static png_uint_32 random_seed[2] = {0x56789abc, 0xd};
   make_random_bytes(random_seed, pv, size);

 }

int main(int argc, char *argv[])
{
FILE *fp_rd = stdin;
FILE *fp_wr = stdout;
FILE *fp_al = NULL;
BOOL raw = TRUE;
BOOL alpha = FALSE;
int argi;

for (argi = 1; argi < argc; argi++)
{
if (argv[argi][0] == '-')
{
switch (argv[argi][1])
{
case 'n':
raw = FALSE;
break;
case 'r':
raw = TRUE;
break;
case 'a':
alpha = TRUE;
argi++;

if ((fp_al = fopen (argv[argi], "wb")) == NULL)
{
fprintf (stderr, "PNM2PNG\n");
            fprintf (stderr, "Error:  can not create alpha-channel file %s\n", argv[argi]);
exit (1);
}
break;
case 'h':
case '?':
usage();
exit(0);
break;
default:
fprintf (stderr, "PNG2PNM\n");
fprintf (stderr, "Error:  unknown option %s\n", argv[argi]);
usage();
exit(1);
break;
} /* end switch */
}
else if (fp_rd == stdin)
{
if ((fp_rd = fopen (argv[argi], "rb")) == NULL)
{
fprintf (stderr, "PNG2PNM\n");
fprintf (stderr, "Error:  file %s does not exist\n", argv[argi]);
exit (1);
}
}
else if (fp_wr == stdout)
{
if ((fp_wr = fopen (argv[argi], "wb")) == NULL)
{
fprintf (stderr, "PNG2PNM\n");
fprintf (stderr, "Error:  can not create file %s\n", argv[argi]);
exit (1);
}
}
else
{
fprintf (stderr, "PNG2PNM\n");
fprintf (stderr, "Error:  too many parameters\n");
usage();
exit(1);
}
} /* end for */

#ifdef __TURBOC__
/* set stdin/stdout if required to binary */
if (fp_rd == stdin)
{
setmode (STDIN, O_BINARY);
}
if ((raw) && (fp_wr == stdout))
{
setmode (STDOUT, O_BINARY);
}
#endif

/* call the conversion program itself */
if (png2pnm (fp_rd, fp_wr, fp_al, raw, alpha) == FALSE)
{
fprintf (stderr, "PNG2PNM\n");
fprintf (stderr, "Error:  unsuccessful conversion of PNG-image\n");
exit(1);
}

/* close input file */
fclose (fp_rd);
/* close output file */
fclose (fp_wr);
/* close alpha file */
if (alpha)
fclose (fp_al);

return 0;
}

make_size_images(png_store *ps)
{
 /* This is in case of errors. */
   safecat(ps->test, sizeof ps->test, 0, "make size images");

 /* Arguments are colour_type, low bit depth, high bit depth
    */
   make_size(ps, 0, 0, WRITE_BDHI);
   make_size(ps, 2, 3, WRITE_BDHI);
   make_size(ps, 3, 0, 3 /*palette: max 8 bits*/);
   make_size(ps, 4, 3, WRITE_BDHI);
   make_size(ps, 6, 3, WRITE_BDHI);
}

gpc_Gpre(Pixel *out, const Pixel *in, const Background *back)
{
 (void)back;

 if (in->r == in->g && in->g == in->b)
      out->r = out->g = out->b = ilineara_g22(in->g, in->a);

 else
      out->r = out->g = out->b = u16d(in->a * 257 *
 YfromRGB(g22_to_d[in->r], g22_to_d[in->g], g22_to_d[in->b]));

   out->a = 257 * in->a;
}

chunk_type_valid(png_uint_32 c)
/* Bit whacking approach to chunk name validation that is intended to avoid
* branches.  The cost is that it uses a lot of 32-bit constants, which might
* be bad on some architectures.
*/
{
png_uint_32 t;

/* Remove bit 5 from all but the reserved byte; this means every
* 8-bit unit must be in the range 65-90 to be valid.  So bit 5
* must be zero, bit 6 must be set and bit 7 zero.
*/

c &= ~PNG_U32(32,32,0,32);
t = (c & ~0x1f1f1f1f) ^ 0x40404040;

   /* Subtract 65 for each 8 bit quantity, this must not overflow
* and each byte must then be in the range 0-25.
*/
c -= PNG_U32(65,65,65,65);
t |=c ;

/* Subtract 26, handling the overflow which should set the top
* three bits of each byte.
*/
c -= PNG_U32(25,25,25,26);
t |= ~c;

return (t & 0xe0e0e0e0) == 0;
}

get_pixel(png_uint_32 format))(Pixel *p, png_const_voidp pb)
{
 /* The color-map flag is irrelevant here - the caller of the function
    * returned must either pass the buffer or, for a color-mapped image, the
    * correct entry in the color-map.
    */
 if (format & PNG_FORMAT_FLAG_LINEAR)
 {
 if (format & PNG_FORMAT_FLAG_COLOR)
 {
#        ifdef PNG_FORMAT_BGR_SUPPORTED
 if (format & PNG_FORMAT_FLAG_BGR)
 {
 if (format & PNG_FORMAT_FLAG_ALPHA)
 {
#                 ifdef PNG_FORMAT_AFIRST_SUPPORTED
 if (format & PNG_FORMAT_FLAG_AFIRST)
 return gp_abgr16;

 else
#                 endif
 return gp_bgra16;
 }

 else
 return gp_bgr16;
 }

 else
#        endif
 {
 if (format & PNG_FORMAT_FLAG_ALPHA)
 {
#              ifdef PNG_FORMAT_AFIRST_SUPPORTED
 if (format & PNG_FORMAT_FLAG_AFIRST)
 return gp_argb16;

 else
#              endif
 return gp_rgba16;
 }

 else
 return gp_rgb16;
 }
 }

 else
 {
 if (format & PNG_FORMAT_FLAG_ALPHA)
 {
#           ifdef PNG_FORMAT_AFIRST_SUPPORTED
 if (format & PNG_FORMAT_FLAG_AFIRST)
 return gp_ag16;

 else
#           endif
 return gp_ga16;
 }

 else
 return gp_g16;
 }
 }

 else
 {
 if (format & PNG_FORMAT_FLAG_COLOR)
 {
#        ifdef PNG_FORMAT_BGR_SUPPORTED
 if (format & PNG_FORMAT_FLAG_BGR)
 {
 if (format & PNG_FORMAT_FLAG_ALPHA)
 {
#                 ifdef PNG_FORMAT_AFIRST_SUPPORTED
 if (format & PNG_FORMAT_FLAG_AFIRST)
 return gp_abgr8;

 else
#                 endif
 return gp_bgra8;
 }

 else
 return gp_bgr8;
 }

 else
#        endif
 {
 if (format & PNG_FORMAT_FLAG_ALPHA)
 {
#              ifdef PNG_FORMAT_AFIRST_SUPPORTED
 if (format & PNG_FORMAT_FLAG_AFIRST)
 return gp_argb8;

 else
#              endif
 return gp_rgba8;
 }

 else
 return gp_rgb8;
 }
 }

 else
 {
 if (format & PNG_FORMAT_FLAG_ALPHA)
 {
#           ifdef PNG_FORMAT_AFIRST_SUPPORTED
 if (format & PNG_FORMAT_FLAG_AFIRST)
 return gp_ag8;

 else
#           endif
 return gp_ga8;
 }

 else
 return gp_g8;
 }
 }
}

display_warning(png_structp pp, png_const_charp warning)
{
   display_log(get_dp(pp), LIBPNG_WARNING, "%s", warning);
}

static png_uint_32 png_log8bit(unsigned x)
{
 if (x > 0)
 return (png_uint_32)floor(.5-log(x/255.)*L2INV);

 return 0xffffffff;
}

bit_size(png_const_structp pp, png_byte colour_type, png_byte bit_depth)
{
 switch (colour_type)
 {
 default: png_error(pp, "invalid color type");

 case 0: return bit_depth;

 case 2: return 3*bit_depth;

 case 3: return bit_depth;

 case 4: return 2*bit_depth;

 case 6: return 4*bit_depth;
 }
}

store_write(png_structp ppIn, png_bytep pb, png_size_t st)
{
   png_const_structp pp = ppIn;
   png_store *ps = voidcast(png_store*, png_get_io_ptr(pp));

 if (ps->pwrite != pp)
      png_error(pp, "store state damaged");

 while (st > 0)
 {
 size_t cb;

 if (ps->writepos >= STORE_BUFFER_SIZE)
         store_storenew(ps);

      cb = st;

 if (cb > STORE_BUFFER_SIZE - ps->writepos)
         cb = STORE_BUFFER_SIZE - ps->writepos;

      memcpy(ps->new.buffer + ps->writepos, pb, cb);
      pb += cb;
      st -= cb;
      ps->writepos += cb;
 }
}

void readpng2_version_info(void)
{
    fprintf(stderr, "   Compiled with libpng %s; using libpng %s\n",
      PNG_LIBPNG_VER_STRING, png_libpng_ver);

    fprintf(stderr, "   and with zlib %s; using zlib %s.\n",
      ZLIB_VERSION, zlib_version);
}

static int format_is_initial(format_list *pf)
{
 int i;
 for (i=0; i<FORMAT_SET_COUNT; ++i)
 if (pf->bits[i] != 0)
 return 0;

 return 1;
}

store_pool_mark(png_bytep mark)
{
 static png_uint_32 store_seed[2] = { 0x12345678, 1};


    make_four_random_bytes(store_seed, mark);
 }

init_display(display *d, const char *program)
{
   memset(d, 0, sizeof *d);
   d->png_ptr = NULL;
   d->info_ptr = d->end_ptr = NULL;
   d->error_count = d->warning_count = 0;
   d->program = program;
   d->file = program;
   d->test = init;
}

image_transform_mod_end(PNG_CONST image_transform *this, image_pixel *that,
    png_const_structp pp, PNG_CONST transform_display *display)
{
   PNG_CONST unsigned int scale = (1U<<that->sample_depth)-1;

UNUSED(this)
UNUSED(pp)
UNUSED(display)

/* At the end recalculate the digitized red green and blue values according
* to the current sample_depth of the pixel.
*
* The sample value is simply scaled to the maximum, checking for over
* and underflow (which can both happen for some image transforms,
* including simple size scaling, though libpng doesn't do that at present.

*/
that->red = sample_scale(that->redf, scale);

/* The error value is increased, at the end, according to the lowest sBIT
* value seen.  Common sense tells us that the intermediate integer
* representations are no more accurate than +/- 0.5 in the integral values,
* the sBIT allows the implementation to be worse than this.  In addition the
* PNG specification actually permits any error within the range (-1..+1),
* but that is ignored here.  Instead the final digitized value is compared,
* below to the digitized value of the error limits - this has the net effect
* of allowing (almost) +/-1 in the output value.  It's difficult to see how
* any algorithm that digitizes intermediate results can be more accurate.
*/
that->rede += 1./(2*((1U<<that->red_sBIT)-1));


if (that->colour_type & PNG_COLOR_MASK_COLOR)
{
that->green = sample_scale(that->greenf, scale);
that->blue = sample_scale(that->bluef, scale);
that->greene += 1./(2*((1U<<that->green_sBIT)-1));
that->bluee += 1./(2*((1U<<that->blue_sBIT)-1));
}
else
{
that->blue = that->green = that->red;
that->bluef = that->greenf = that->redf;
that->bluee = that->greene = that->rede;
}

if ((that->colour_type & PNG_COLOR_MASK_ALPHA) ||
that->colour_type == PNG_COLOR_TYPE_PALETTE)
{
that->alpha = sample_scale(that->alphaf, scale);
that->alphae += 1./(2*((1U<<that->alpha_sBIT)-1));
}

else
{
that->alpha = scale; /* opaque */
      that->alpha = 1;     /* Override this. *
that->alphae = 0;    /* It's exact ;-) */
}
}

IDAT_list_end(struct IDAT_list *IDAT_list)
{
 struct IDAT_list *list = IDAT_list->next;

   CLEAR(*IDAT_list);

 while (list != NULL)
 {
 struct IDAT_list *next = list->next;

      clear(list, IDAT_list_size(list, 0));
      free(list);
 list = next;
 }
}

perform_standard_test(png_modifier *pm)
{
 /* Test each colour type over the valid range of bit depths (expressed as
    * log2(bit_depth) in turn, stop as soon as any error is detected.
    */
 if (!test_standard(pm, 0, 0, READ_BDHI))
 return;

 if (!test_standard(pm, 2, 3, READ_BDHI))
 return;

 if (!test_standard(pm, 3, 0, 3))
 return;

 if (!test_standard(pm, 4, 3, READ_BDHI))
 return;

 if (!test_standard(pm, 6, 3, READ_BDHI))
 return;
}

skip_12(struct file *file)
 /* Skip exactly 12 bytes in the input stream - used to skip a CRC and chunk
    * header that has been read before.
    */
{
 /* Since the chunks were read before this shouldn't fail: */
 if (fseek(file->file, 12, SEEK_CUR) != 0)
 {
 if (errno != 0)
         file->read_errno = errno;

      stop(file, UNEXPECTED_ERROR_CODE, "reskip");
 }
}

gpc_bckc(Pixel *out, const Pixel *in, const Background *back)
{
 if (in->a <= 0)
 {
      out->r = back->ir;
      out->g = back->ig;
      out->b = back->ib;
 }

 else if (in->a >= 255)
 {
      out->r = in->r;
      out->g = in->g;
      out->b = in->b;
 }

 else
 {
 double a = in->a / 255.;

      out->r = sRGB(sRGB_to_d[in->r] * a + back->dr * (1-a));
      out->g = sRGB(sRGB_to_d[in->g] * a + back->dg * (1-a));
      out->b = sRGB(sRGB_to_d[in->b] * a + back->db * (1-a));
 }

   out->a = 255;
}

get_valid(display *d, png_infop info_ptr)
{
   png_uint_32 flags = png_get_valid(d->png_ptr, info_ptr, (png_uint_32)~0);

 /* Map the text chunks back into the flags */
 {
      png_textp text;
      png_uint_32 ntext = png_get_text(d->png_ptr, info_ptr, &text, NULL);

 while (ntext-- > 0) switch (text[ntext].compression)
 {
 case -1:
            flags |= PNG_INFO_tEXt;
 break;
 case 0:
            flags |= PNG_INFO_zTXt;
 break;
 case 1:
 case 2:
            flags |= PNG_INFO_iTXt;
 break;
 default:
            fprintf(stderr, "%s(%s): unknown text compression %d\n", d->file,
               d->test, text[ntext].compression);
            display_exit(d);
 }
 }

 return flags;
}

buffer_write(struct display *dp, struct buffer *buffer, png_bytep data,
 png_size_t size)
 /* Generic write function used both from the write callback provided to
    * libpng and from the generic read code.
    */
{
 /* Write the data into the buffer, adding buffers as required */
 struct buffer_list *last = buffer->last;
 size_t end_count = buffer->end_count;

 while (size > 0)
 {
 size_t avail;

 if (end_count >= sizeof last->buffer)
 {
 if (last->next == NULL)
 {
            last = buffer_extend(last);

 if (last == NULL)
               display_log(dp, APP_ERROR, "out of memory saving file");
 }

 else
            last = last->next;

         buffer->last = last; /* avoid the need to rewrite every time */
         end_count = 0;
 }

      avail = (sizeof last->buffer) - end_count;
 if (avail > size)
         avail = size;

      memcpy(last->buffer + end_count, data, avail);
      end_count += avail;
      size -= avail;
      data += avail;
 }

   buffer->end_count = end_count;
}

store_init(png_store* ps)
{
   memset(ps, 0, sizeof *ps);
   init_exception_context(&ps->exception_context);
   store_pool_init(ps, &ps->read_memory_pool);
   store_pool_init(ps, &ps->write_memory_pool);
   ps->verbose = 0;
   ps->treat_warnings_as_errors = 0;
   ps->expect_error = 0;
   ps->expect_warning = 0;
   ps->saw_warning = 0;
   ps->speed = 0;
   ps->progressive = 0;
   ps->validated = 0;
   ps->nerrors = ps->nwarnings = 0;
   ps->pread = NULL;
   ps->piread = NULL;
   ps->saved = ps->current = NULL;
   ps->next = NULL;
   ps->readpos = 0;
   ps->image = NULL;
   ps->cb_image = 0;
   ps->cb_row = 0;
   ps->image_h = 0;
   ps->pwrite = NULL;
   ps->piwrite = NULL;
   ps->writepos = 0;
   ps->new.prev = NULL;
   ps->palette = NULL;
   ps->npalette = 0;
   ps->noptions = 0;
}

png_read_filter_row_paeth3_neon(png_row_infop row_info, png_bytep row,
   png_const_bytep prev_row)
{
   png_bytep rp = row;
   png_const_bytep pp = prev_row;
   png_bytep rp_stop = row + row_info->rowbytes;

 uint8x16_t vtmp;
 uint8x8x2_t *vrpt;
 uint8x8x2_t vrp;
 uint8x8_t vlast = vdup_n_u8(0);
 uint8x8x4_t vdest;
   vdest.val[3] = vdup_n_u8(0);

   vtmp = vld1q_u8(rp);
   vrpt = png_ptr(uint8x8x2_t,&vtmp);
   vrp = *vrpt;

 for (; rp < rp_stop; pp += 12)
 {
 uint8x8x2_t *vppt;
 uint8x8x2_t vpp;
 uint8x8_t vtmp1, vtmp2, vtmp3;
 uint32x2_t *temp_pointer;

      vtmp = vld1q_u8(pp);
      vppt = png_ptr(uint8x8x2_t,&vtmp);
      vpp = *vppt;

      vdest.val[0] = paeth(vdest.val[3], vpp.val[0], vlast);
      vdest.val[0] = vadd_u8(vdest.val[0], vrp.val[0]);

      vtmp1 = vext_u8(vrp.val[0], vrp.val[1], 3);
      vtmp2 = vext_u8(vpp.val[0], vpp.val[1], 3);
      vdest.val[1] = paeth(vdest.val[0], vtmp2, vpp.val[0]);
      vdest.val[1] = vadd_u8(vdest.val[1], vtmp1);

      vtmp1 = vext_u8(vrp.val[0], vrp.val[1], 6);
      vtmp3 = vext_u8(vpp.val[0], vpp.val[1], 6);
      vdest.val[2] = paeth(vdest.val[1], vtmp3, vtmp2);
      vdest.val[2] = vadd_u8(vdest.val[2], vtmp1);

      vtmp1 = vext_u8(vrp.val[1], vrp.val[1], 1);
      vtmp2 = vext_u8(vpp.val[1], vpp.val[1], 1);

      vtmp = vld1q_u8(rp + 12);
      vrpt = png_ptr(uint8x8x2_t,&vtmp);
      vrp = *vrpt;

      vdest.val[3] = paeth(vdest.val[2], vtmp2, vtmp3);
      vdest.val[3] = vadd_u8(vdest.val[3], vtmp1);

      vlast = vtmp2;

      vst1_lane_u32(png_ptr(uint32_t,rp), png_ldr(uint32x2_t,&vdest.val[0]), 0);
      rp += 3;
      vst1_lane_u32(png_ptr(uint32_t,rp), png_ldr(uint32x2_t,&vdest.val[1]), 0);
      rp += 3;
      vst1_lane_u32(png_ptr(uint32_t,rp), png_ldr(uint32x2_t,&vdest.val[2]), 0);
      rp += 3;
      vst1_lane_u32(png_ptr(uint32_t,rp), png_ldr(uint32x2_t,&vdest.val[3]), 0);
      rp += 3;
 }
}

set_color(png_colorp color, png_bytep trans, unsigned int red,
 unsigned int green, unsigned int blue, unsigned int alpha,
   png_const_bytep gamma_table)
{
   color->red = gamma_table[red];
   color->green = gamma_table[green];
   color->blue = gamma_table[blue];
 *trans = (png_byte)alpha;
}

check16(png_const_bytep bp, int b)
{
 int i = 16;

 do
 if (*bp != b) return 1;
 while (--i);

 return 0;
}

isRGB(int fixed_linear)
{
 return sRGB(fixed_linear / 65535.);
}

display_log(struct display *dp, error_level level, const char *fmt, ...)
/* 'level' is as above, fmt is a stdio style format string.  This routine
* does not return if level is above LIBPNG_WARNING
*/
{
dp->results |= 1U << level;

if (level > (error_level)(dp->options & LEVEL_MASK))
{
const char *lp;
va_list ap;

switch (level)
{
case INFORMATION:    lp = "information"; break;
case LIBPNG_WARNING: lp = "warning(libpng)"; break;
case APP_WARNING:    lp = "warning(pngimage)"; break;
case APP_FAIL:       lp = "error(continuable)"; break;
case LIBPNG_ERROR:   lp = "error(libpng)"; break;
case LIBPNG_BUG:     lp = "bug(libpng)"; break;
case APP_ERROR:      lp = "error(pngimage)"; break;
case USER_ERROR:     lp = "error(user)"; break;

case INTERNAL_ERROR: /* anything unexpected is an internal error: */
case VERBOSE: case WARNINGS: case ERRORS: case QUIET:
default:             lp = "bug(pngimage)"; break;
}

fprintf(stderr, "%s: %s: %s",
dp->filename != NULL ? dp->filename : "<stdin>", lp, dp->operation);

if (dp->transforms != 0)
{

int tr = dp->transforms;

if (is_combo(tr))
            fprintf(stderr, "(0x%x)", tr);

else
fprintf(stderr, "(%s)", transform_name(tr));
}

fprintf(stderr, ": ");

va_start(ap, fmt);
vfprintf(stderr, fmt, ap);
va_end(ap);

fputc('\n', stderr);
}
/* else do not output any message */

/* Errors cause this routine to exit to the fail code */
if (level > APP_FAIL || (level > ERRORS && !(dp->options & CONTINUE)))
longjmp(dp->error_return, level);
}

static void rpng2_win_cleanup()
{
 if (bg_image && bg_data) {
        free(bg_data);
        bg_data = NULL;
 }

 if (rpng2_info.image_data) {
        free(rpng2_info.image_data);
        rpng2_info.image_data = NULL;
 }

 if (rpng2_info.row_pointers) {
        free(rpng2_info.row_pointers);
        rpng2_info.row_pointers = NULL;
 }

 if (dib) {
        free(dib);
        dib = NULL;
 }
}

row_copy(png_bytep toBuffer, png_const_bytep fromBuffer, unsigned int bitWidth)
{
memcpy(toBuffer, fromBuffer, bitWidth >> 3);

if ((bitWidth & 7) != 0)
{
unsigned int mask;


toBuffer += bitWidth >> 3;
fromBuffer += bitWidth >> 3;
      /* The remaining bits are in the top of the byte, the mask is the bits to
       * retain.
       *
      mask = 0xff >> (bitWidth & 7);
*toBuffer = (png_byte)((*toBuffer & mask) | (*fromBuffer & ~mask));
}
}

png_pass_col_shift(int pass)
{
 int x, y, base=(-1), inc=8;
 ++pass;
 for (x=0; x<8; ++x) for (y=0; y<8; ++y) if (adam7[y][x] == pass)
 {
 if (base == (-1))
         base = x;
 else if (base == x)
 {}
 else if (inc == x-base)
         base=x;
 else if (inc == 8)
         inc = x-base, base=x;
 else if (inc != x-base)
 return 0xff; /* error - more than one 'inc' value! */
 }

 if (base == (-1)) return 0xfe; /* error - no row in pass! */

 /* The shift is always 1, 2 or 3 - no pass has all the rows! */
 switch (inc)
 {
case 1: return 0; /* pass 7 has all the columns */
case 2: return 1;
case 4: return 2;
case 8: return 3;
default: break;
 }

 /* error - unrecognized 'inc' */
 return (inc << 8) + 0xfd;
}

logerror(Image *image, const char *a1, const char *a2, const char *a3)
{
   fflush(stdout);
 if (image->image.warning_or_error)
      fprintf(stderr, "%s%s%s: %s\n", a1, a2, a3, image->image.message);

 else
      fprintf(stderr, "%s%s%s\n", a1, a2, a3);

 if (image->image.opaque != NULL)
 {
      fprintf(stderr, "%s: image opaque pointer non-NULL on error\n",
         image->file_name);
      png_image_free(&image->image);
 }

 return 0;
}

bad_parameter_count(png_const_charp what, int nparams)
{
   fprintf(stderr, "--insert %s: bad parameter count %d\n", what, nparams);
   exit(1);
}

store_warning(png_structp ppIn, png_const_charp message)
{
   png_const_structp pp = ppIn;
   png_store *ps = voidcast(png_store*, png_get_error_ptr(pp));

 if (!ps->expect_warning)
      store_log(ps, pp, message, 0 /* warning */);
 else
      ps->saw_warning = 1;
}

standard_end(png_structp ppIn, png_infop pi)
{
   png_const_structp pp = ppIn;
   standard_display *dp = voidcast(standard_display*,
      png_get_progressive_ptr(pp));

   UNUSED(pi)

 /* Validate the image - progressive reading only produces one variant for
    * interlaced images.
    */
   standard_text_validate(dp, pp, pi,
      PNG_LIBPNG_VER >= 10518/*check_end: see comments above*/);
   standard_image_validate(dp, pp, 0, -1);
}

image_transform_ini_end(PNG_CONST image_transform *this,
    transform_display *that)
 {
    UNUSED(this)
   UNUSED(that)

 }

gpc_glin(Pixel *out, const Pixel *in, const Background *back)
{
 (void)back;

 if (in->r == in->g && in->g == in->b)
      out->r = out->g = out->b = ilinear(in->g);

 else
      out->r = out->g = out->b = u16d(65535 *
 YfromRGB(sRGB_to_d[in->r], sRGB_to_d[in->g], sRGB_to_d[in->b]));

   out->a = 65535;
}

put_chunk(const unsigned char *chunk, uInt length)
{
   uLong crc;

   put_uLong(length-4); /* Exclude the tag */

   fwrite(chunk, length, 1, stdout);

   crc = crc32(0, Z_NULL, 0);
   put_uLong(crc32(crc, chunk, length));
}

store_ensure_image(png_store *ps, png_const_structp pp, int nImages,
 png_size_t cbRow, png_uint_32 cRows)
{
 png_size_t cb = nImages * cRows * (cbRow + 5);

 if (ps->cb_image < cb)
 {
      png_bytep image;

      store_image_free(ps, pp);

 /* The buffer is deliberately mis-aligned. */
      image = voidcast(png_bytep, malloc(cb+2));
 if (image == NULL)
 {
 /* Called from the startup - ignore the error for the moment. */
 if (pp == NULL)
 return;

         png_error(pp, "OOM allocating image buffer");
 }

 /* These magic tags are used to detect overwrites above. */
 ++image;
      image[-1] = 0xed;
      image[cb] = 0xfe;

      ps->image = image;
      ps->cb_image = cb;
 }

 /* We have an adequate sized image; lay out the rows.  There are 2 bytes at
    * the start and three at the end of each (this ensures that the row
    * alignment starts out odd - 2+1 and changes for larger images on each row.)
    */
   ps->cb_row = cbRow;
   ps->image_h = cRows;

 /* For error checking, the whole buffer is set to 10110010 (0xb2 - 178).
    * This deliberately doesn't match the bits in the size test image which are
    * outside the image; these are set to 0xff (all 1).  To make the row
    * comparison work in the 'size' test case the size rows are pre-initialized
    * to the same value prior to calling 'standard_row'.
    */
   memset(ps->image, 178, cb);

 /* Then put in the marks. */
 while (--nImages >= 0)
 {
      png_uint_32 y;

 for (y=0; y<cRows; ++y)
 {
         png_bytep row = store_image_row(ps, pp, nImages, y);

 /* The markers: */
         row[-2] = 190;
         row[-1] = 239;
         row[cbRow] = 222;
         row[cbRow+1] = 173;
         row[cbRow+2] = 17;
 }
 }
}

uarb_inc(uarb num, int in_digits, png_int_32 add)
 /* This is a signed 32-bit add, except that to avoid overflow the value added
    * or subtracted must be no more than 2^31-65536.  A negative result
    * indicates a negative number (which is an error below).  The size of
    * 'num' should be max(in_digits+1,2) for arbitrary 'add' but can be just
    * in_digits+1 if add is known to be in the range -65535..65535.
    */
{
   FIX_GCC int out_digits = 0;

 while (out_digits < in_digits)
 {
      add += num[out_digits];
      num[out_digits++] = (png_uint_16)(add & 0xffff);
      add >>= 16;
 }

 while (add != 0 && add != (-1))
 {
      num[out_digits++] = (png_uint_16)(add & 0xffff);
      add >>= 16;
 }

 if (add == 0)
 {
 while (out_digits > 0 && num[out_digits-1] == 0)
 --out_digits;
 return out_digits; /* may be 0 */
 }

 else /* negative result */
 {
 while (out_digits > 1 && num[out_digits-1] == 0xffff)
 --out_digits;

 return -out_digits;
 }
}

static void format_default(format_list *pf, int redundant)
{
 if (redundant)
 {
 int i;

 /* set everything, including flags that are pointless */
 for (i=0; i<FORMAT_SET_COUNT; ++i)
         pf->bits[i] = ~(png_uint_32)0;
 }

 else
 {
      png_uint_32 f;

 for (f=0; f<FORMAT_COUNT; ++f)
 {
 /* Eliminate redundant and unsupported settings. */
#        ifdef PNG_FORMAT_BGR_SUPPORTED
 /* BGR is meaningless if no color: */
 if ((f & PNG_FORMAT_FLAG_COLOR) == 0 &&
 (f & PNG_FORMAT_FLAG_BGR) != 0)
#        else
 if ((f & 0x10U/*HACK: fixed value*/) != 0)
#        endif
 continue;

 /* AFIRST is meaningless if no alpha: */
#        ifdef PNG_FORMAT_AFIRST_SUPPORTED
 if ((f & PNG_FORMAT_FLAG_ALPHA) == 0 &&
 (f & PNG_FORMAT_FLAG_AFIRST) != 0)
#        else
 if ((f & 0x20U/*HACK: fixed value*/) != 0)
#        endif
 continue;

         format_set(pf, f);
 }
 }
}

usage(const char *prog)
{
/* ANSI C-90 limits strings to 509 characters, so use a string array: */
size_t i;
static const char *usage_string[] = {
"  Tests, optimizes and optionally fixes the zlib header in PNG files.",
"  Optionally, when fixing, strips ancilliary chunks from the file.",
0,
"OPTIONS",
"  OPERATION",
"      By default files are just checked for readability with a summary of the",
"      of zlib issues founds for each compressed chunk and the IDAT stream in",
"      the file.",
"    --optimize (-o):",
"      Find the smallest deflate window size for the compressed data.",
"    --strip=[none|crc|unsafe|unused|transform|color|all]:",
"        none (default):   Retain all chunks.",
"        crc:    Remove chunks with a bad CRC.",
"        unsafe: Remove chunks that may be unsafe to retain if the image data",
"                is modified.  This is set automatically if --max is given but",
"                may be cancelled by a later --strip=none.",
"        unused: Remove chunks not used by libpng when decoding an image.",
"                This retains any chunks that might be used by libpng image",
"                transformations.",
"        transform: unused+bKGD.",
"        color:  transform+iCCP and cHRM.",
"        all:    color+gAMA and sRGB.",
"      Only ancillary chunks are ever removed.  In addition the tRNS and sBIT",
"      chunks are never removed as they affect exact interpretation of the",
"      image pixel values.  The following known chunks are treated specially",
"      by the above options:",

"        gAMA, sRGB [all]: These specify the gamma encoding used for the pixel",
"            values.",
"        cHRM, iCCP [color]: These specify how colors are encoded.  iCCP also",
"            specifies the exact encoding of a pixel value however in practice",
"            most programs will ignore it.",
"        bKGD [transform]: This is used by libpng transforms."
"    --max=<number>:",
"      Use IDAT chunks sized <number>.  If no number is given the the IDAT",
"      chunks will be the maximum size permitted; 2^31-1 bytes.  If the option",
"      is omitted the original chunk sizes will not be changed.  When the",
"      option is given --strip=unsafe is set automatically, this may be",
"      cancelled if you know that all unknown unsafe-to-copy chunks really are",
"      safe to copy across an IDAT size change.  This is true of all chunks",
"      that have ever been formally proposed as PNG extensions.",
"  MESSAGES",
"      By default the program only outputs summaries for each file.",
"    --quiet (-q):",
"      Do not output the summaries except for files which cannot be read. With",
"      two --quiets these are not output either.",
"    --errors (-e):",
"      Output errors from libpng and the program (except too-far-back).",
"    --warnings (-w):",
"      Output warnings from libpng.",
"  OUTPUT",
"      By default nothing is written.",
"    --out=<file>:",
"      Write the optimized/corrected version of the next PNG to <file>.  This",
"      overrides the following two options",
"    --suffix=<suffix>:",
"      Set --out=<name><suffix> for all following files unless overridden on",
"      a per-file basis by explicit --out.",
"    --prefix=<prefix>:",
"      Set --out=<prefix><name> for all the following files unless overridden",
"      on a per-file basis by explicit --out.",
"      These two options can be used together to produce a suffix and prefix.",
"  INTERNAL OPTIONS",
#if 0 /*NYI*/
#ifdef PNG_MAXIMUM_INFLATE_WINDOW
"    --test:",
"      Test the PNG_MAXIMUM_INFLATE_WINDOW option.  Setting this disables",
"      output as this would produce a broken file.",
#endif
#endif
0,
"EXIT CODES",
"  *** SUBJECT TO CHANGE ***",
"  The program exit code is value in the range 0..127 holding a bit mask of",

"  the following codes.  Notice that the results for each file are combined",
"  together - check one file at a time to get a meaningful error code!",
"    0x01: The zlib too-far-back error existed in at least one chunk.",
"    0x02: At least once chunk had a CRC error.",
"    0x04: A chunk length was incorrect.",
"    0x08: The file was truncated.",
"  Errors less than 16 are potentially recoverable, for a single file if the",
"  exit code is less than 16 the file could be read (with corrections if a",

"  non-zero code is returned).",
"    0x10: The file could not be read, even with corrections.",
"    0x20: The output file could not be written.",
"    0x40: An unexpected, potentially internal, error occured.",
"  If the command line arguments are incorrect the program exits with exit",
"  255.  Some older operating systems only support 7-bit exit codes, on those",
"  systems it is suggested that this program is first tested by supplying",
"  invalid arguments.",
0,
"DESCRIPTION",
"  " PROGRAM_NAME ":",
"  checks each PNG file on the command line for errors.  By default errors are",
"  not output and the program just returns an exit code and prints a summary.",
"  With the --quiet (-q) option the summaries are suppressed too and the",
"  program only outputs unexpected errors (internal errors and file open",
"  errors).",
"  Various known problems in PNG files are fixed while the file is being read",
"  The exit code says what problems were fixed.  In particular the zlib error:",
0,
"        \"invalid distance too far back\"",
0,
"  caused by an incorrect optimization of a zlib stream is fixed in any",
"  compressed chunk in which it is encountered.  An integrity problem of the",
"  PNG stream caused by a bug in libpng which wrote an incorrect chunk length",
"  is also fixed.  Chunk CRC errors are automatically fixed up.",
0,
"  Setting one of the \"OUTPUT\" options causes the possibly modified file to",
"  be written to a new file.",
0,
"  Notice that some PNG files with the zlib optimization problem can still be",
"  read by libpng under some circumstances.  This program will still detect",
"  and, if requested, correct the error.",
0,
"  The program will reliably process all files on the command line unless",
"  either an invalid argument causes the usage message (this message) to be",
"  produced or the program crashes.",
0,
"  The summary lines describe issues encountered with the zlib compressed",
"  stream of a chunk.  They have the following format, which is SUBJECT TO",
"  CHANGE in the future:",
0,
"     chunk reason comp-level p1 p2 p3 p4 file",
0,
"  p1 through p4 vary according to the 'reason'.  There are always 8 space",
"  separated fields.  Reasons specific formats are:",
0,
"     chunk ERR status code read-errno write-errno message file",
"     chunk SKP comp-level file-bits zlib-rc compressed message file",
"     chunk ??? comp-level file-bits ok-bits compressed uncompress file",
0,
"  The various fields are",
0,
"$1 chunk:      The chunk type of a chunk in the file or 'HEAD' if a problem",
"               is reported by libpng at the start of the IDAT stream.",
"$2 reason:     One of:",
"          CHK: A zlib header checksum was detected and fixed.",
"          TFB: The zlib too far back error was detected and fixed.",
"          OK : No errors were detected in the zlib stream and optimization",
"               was not requested, or was not possible.",
"          OPT: The zlib stream window bits value could be improved (and was).",

"          SKP: The chunk was skipped because of a zlib issue (zlib-rc) with",
"               explanation 'message'",
"          ERR: The read of the file was aborted.  The parameters explain why.",
"$3 status:     For 'ERR' the accumulate status code from 'EXIT CODES' above.",
"               This is printed as a 2 digit hexadecimal value",
"   comp-level: The recorded compression level (FLEVEL) of a zlib stream",
"               expressed as a string {supfast,stdfast,default,maximum}",
"$4 code:       The file exit code; where stop was called, as a fairly terse",
"               string {warning,libpng,zlib,invalid,read,write,unexpected}.",
"   file-bits:  The zlib window bits recorded in the file.",
"$5 read-errno: A system errno value from a read translated by strerror(3).",
"   zlib-rc:    A zlib return code as a string (see zlib.h).",
"   ok-bits:    The smallest zlib window bits value that works.",
"$6 write-errno:A system errno value from a write translated by strerror(3).",
"   compressed: The count of compressed bytes in the zlib stream, when the",
"               reason is 'SKP'; this is a count of the bytes read from the",
"               stream when the fatal error was encountered.",
"$7 message:    An error message (spaces replaced by _, as in all parameters),",
"   uncompress: The count of bytes from uncompressing the zlib stream; this",
"               may not be the same as the number of bytes in the image.",
"$8 file:       The name of the file (this may contain spaces).",
};

fprintf(stderr, "Usage: %s {[options] png-file}\n", prog);

for (i=0; i < (sizeof usage_string)/(sizeof usage_string[0]); ++i)
{
if (usage_string[i] != 0)
fputs(usage_string[i], stderr);

fputc('\n', stderr);
}

exit(255);
}

gama_modification_init(gama_modification *me, png_modifier *pm, double gammad)
{
 double g;

   modification_init(&me->this);
   me->this.chunk = CHUNK_gAMA;
   me->this.modify_fn = gama_modify;
   me->this.add = CHUNK_PLTE;
   g = fix(gammad);
   me->gamma = (png_fixed_point)g;
   me->this.next = pm->modifications;
   pm->modifications = &me->this;
}

write_png(struct display *dp, png_infop ip, int transforms)
{
   display_clean_write(dp); /* safety */

   buffer_start_write(&dp->written_file);
   dp->operation = "write";
   dp->transforms = transforms;

   dp->write_pp = png_create_write_struct(PNG_LIBPNG_VER_STRING, dp,
      display_error, display_warning);

 if (dp->write_pp == NULL)
      display_log(dp, APP_ERROR, "failed to create write png_struct");

   png_set_write_fn(dp->write_pp, &dp->written_file, write_function,
      NULL/*flush*/);

#  ifdef PNG_SET_USER_LIMITS_SUPPORTED
 /* Remove the user limits, if any */
      png_set_user_limits(dp->write_pp, 0x7fffffff, 0x7fffffff);
#  endif

 /* Certain transforms require the png_info to be zapped to allow the
    * transform to work correctly.
    */
 if (transforms & (PNG_TRANSFORM_PACKING|
                     PNG_TRANSFORM_STRIP_FILLER|
                     PNG_TRANSFORM_STRIP_FILLER_BEFORE))
 {
 int ct = dp->color_type;

 if (transforms & (PNG_TRANSFORM_STRIP_FILLER|
                        PNG_TRANSFORM_STRIP_FILLER_BEFORE))
         ct &= ~PNG_COLOR_MASK_ALPHA;

      png_set_IHDR(dp->write_pp, ip, dp->width, dp->height, dp->bit_depth, ct,
         dp->interlace_method, dp->compression_method, dp->filter_method);
 }

   png_write_png(dp->write_pp, ip, transforms, NULL/*params*/);

 /* Clean it on the way out - if control returns to the caller then the
    * written_file contains the required data.
    */
   display_clean_write(dp);
}

u8d(double d)
{
   d = closestinteger(d);
 return (png_byte)d;
}

display_rc(const display *d, int strict)
{
 return d->error_count + (strict ? d->warning_count : 0);
}

main(void)
{
 /* Exit code 0 on success. */
 return !read_png(stdin);
}

gp_bgra16(Pixel *p, png_const_voidp pb)
{
   png_const_uint_16p pp = voidcast(png_const_uint_16p, pb);

   p->r = pp[2];
   p->g = pp[1];
   p->b = pp[0];
   p->a = pp[3];
}

static int check_one_character(checkfp_command *co, checkfp_control c, int ch)
{
 /* Test this character (ch) to ensure the parser does the correct thing.
    */
 png_size_t index = 0;
 const char test = (char)ch;
 const int number_is_valid = png_check_fp_number(&test, 1, &c.state, &index);
 const int character_accepted = (index == 1);

 if (c.check_state != exponent && isdigit(ch) && ch != '0')
      c.is_zero = 0;

 if (c.check_state == start && c.at_start && ch == '-')
      c.is_negative = 1;

 if (isprint(ch))
      co->number[c.cnumber++] = (char)ch;
 else
 {
      co->number[c.cnumber++] = '<';
      co->number[c.cnumber++] = hexdigits[(ch >> 4) & 0xf];
      co->number[c.cnumber++] = hexdigits[ch & 0xf];
      co->number[c.cnumber++] = '>';
 }
   co->number[c.cnumber] = 0;

 if (co->verbose > 1)
      fprintf(stderr, "%s\n", co->number);

 if (++(co->ctimes) == 1000000)
 {
 if (co->verbose == 1)
         fputc('.', stderr);
      co->ctimes = 0;
 ++(co->cmillions);
 }

 if (!number_is_valid)
 ++(co->cinvalid);

 if (!character_accepted)
 ++(co->cnoaccept);

 /* This should never fail (it's a serious bug if it does): */
 if (index != 0 && index != 1)
 {
      fprintf(stderr, "%s: read beyond end of string (%lu)\n", co->number,
 (unsigned long)index);
 return 0;
 }

 /* Validate the new state, note that the PNG_FP_IS_ macros all return
    * false unless the number is valid.
    */
 if (PNG_FP_IS_NEGATIVE(c.state) !=
 (number_is_valid && !c.is_zero && c.is_negative))
 {
      fprintf(stderr, "%s: negative when it is not\n", co->number);
 return 0;
 }

 if (PNG_FP_IS_ZERO(c.state) != (number_is_valid && c.is_zero))
 {
      fprintf(stderr, "%s: zero when it is not\n", co->number);
 return 0;
 }

 if (PNG_FP_IS_POSITIVE(c.state) !=
 (number_is_valid && !c.is_zero && !c.is_negative))
 {
      fprintf(stderr, "%s: positive when it is not\n", co->number);
 return 0;
 }

 /* Testing a digit */
 if (isdigit(ch))
 {
 if (!character_accepted)
 {
         fprintf(stderr, "%s: digit '%c' not accepted\n", co->number, ch);
 return 0;
 }

 if (!number_is_valid)
 {
         fprintf(stderr, "%s: saw a digit (%c) but number not valid\n",
            co->number, ch);
 return 0;
 }

 ++c.cdigits_in_state;
      c.at_start = 0;
      c.number_was_valid = 1;

 /* Continue testing characters in this state.  Either test all of
       * them or, if we have already seen one digit in this state, just test a
       * limited set.
       */
 if (c.cdigits_in_state < 1)
 return check_all_characters(co, c);

 else
 return check_some_characters(co, c,
            state_characters[c.check_state].tests);
 }

 /* A non-digit; is it allowed here? */
 else if (((ch == '+' || ch == '-') && c.check_state != fraction &&
               c.at_start) ||
 (ch == '.' && c.check_state == start) ||
 ((ch == 'e' || ch == 'E') && c.number_was_valid &&
               c.check_state != exponent))
 {
 if (!character_accepted)
 {
         fprintf(stderr, "%s: character '%c' not accepted\n", co->number, ch);
 return 0;
 }

 /* The number remains valid after start of fraction but nowhere else. */
 if (number_is_valid && (c.check_state != start || ch != '.'))
 {
         fprintf(stderr, "%s: saw a non-digit (%c) but number valid\n",
            co->number, ch);
 return 0;
 }

      c.number_was_valid = number_is_valid;

 /* Check for a state change.  When changing to 'fraction' if the number
       * is valid at this point set the at_start to false to allow an exponent
       * 'e' to come next.
       */
 if (c.check_state == start && ch == '.')
 {
         c.check_state = fraction;
         c.at_start = !number_is_valid;
         c.cdigits_in_state = 0;
         c.limit = co->limit;
 return check_all_characters(co, c);
 }

 else if (c.check_state < exponent && (ch == 'e' || ch == 'E'))
 {
         c.check_state = exponent;
         c.at_start = 1;
         c.cdigits_in_state = 0;
         c.limit = co->limit;
 return check_all_characters(co, c);
 }

 /* Else it was a sign, and the state doesn't change. */
 else
 {
 if (ch != '-' && ch != '+')
 {
            fprintf(stderr, "checkfp: internal error (1)\n");
 return 0;
 }

         c.at_start = 0;
 return check_all_characters(co, c);
 }
 }

 /* Testing an invalid character */
 else
 {
 if (character_accepted)
 {
         fprintf(stderr, "%s: character '%c' [0x%.2x] accepted\n", co->number,
            ch, ch);
 return 0;
 }

 if (number_is_valid != c.number_was_valid)
 {
         fprintf(stderr,
 "%s: character '%c' [0x%.2x] changed number validity\n", co->number,
            ch, ch);
 return 0;
 }

 /* Do nothing - the parser has stuck; return success and keep going with
       * the next character.
       */
 }

 /* Successful return (the caller will try the next character.) */
 return 1;
}

generate_palette(png_colorp palette, png_bytep trans, int bit_depth,
png_const_bytep gamma_table, unsigned int *colors)
{
/*
* 1-bit: entry 0 is transparent-red, entry 1 is opaque-white
* 2-bit: entry 0: transparent-green
*        entry 1: 40%-red
*        entry 2: 80%-blue
*        entry 3: opaque-white
* 4-bit: the 16 combinations of the 2-bit case
* 8-bit: the 256 combinations of the 4-bit case
*/
switch (colors[0])
{
default:
fprintf(stderr, "makepng: --colors=...: invalid count %u\n",
colors[0]);
exit(1);

case 1:
set_color(palette+0, trans+0, colors[1], colors[1], colors[1], 255,
gamma_table);
return 1;

case 2:
set_color(palette+0, trans+0, colors[1], colors[1], colors[1],
colors[2], gamma_table);
return 1;

case 3:
set_color(palette+0, trans+0, colors[1], colors[2], colors[3], 255,
gamma_table);
return 1;

case 4:
set_color(palette+0, trans+0, colors[1], colors[2], colors[3],
colors[4], gamma_table);
return 1;

case 0:
if (bit_depth == 1)
{
set_color(palette+0, trans+0, 255, 0, 0, 0, gamma_table);
set_color(palette+1, trans+1, 255, 255, 255, 255, gamma_table);
return 2;
}


else
{
unsigned int size = 1U << (bit_depth/2); /* 2, 4 or 16 */
            unsigned int x, y, ip;

for (x=0; x<size; ++x) for (y=0; y<size; ++y)
{
ip = x + (size * y);

/* size is at most 16, so the scaled value below fits in 16 bits
*/
#              define interp(pos, c1, c2) ((pos * c1) + ((size-pos) * c2))
#              define xyinterp(x, y, c1, c2, c3, c4) (((size * size / 2) +\
(interp(x, c1, c2) * y + (size-y) * interp(x, c3, c4))) /\
(size*size))

set_color(palette+ip, trans+ip,
/* color:    green, red,blue,white */
xyinterp(x, y, 0, 255, 0, 255),
xyinterp(x, y, 255, 0, 0, 255),
xyinterp(x, y, 0, 0, 255, 255),
/* alpha:        0, 102, 204, 255) */
xyinterp(x, y, 0, 102, 204, 255),
gamma_table);
}

return ip+1;
}
}
}

main(void)
{
   fprintf(stderr,
 " test ignored: no support to modify unknown chunk handling\n");
 /* So the test is skipped: */
 return 77;
}

make_random_bytes(png_uint_32* seed, void* pv, size_t size)
{
   png_uint_32 u0 = seed[0], u1 = seed[1];
   png_bytep bytes = voidcast(png_bytep, pv);

 /* There are thirty three bits, the next bit in the sequence is bit-33 XOR
    * bit-20.  The top 1 bit is in u1, the bottom 32 are in u0.
    */
 size_t i;
 for (i=0; i<size; ++i)
 {
 /* First generate 8 new bits then shift them in at the end. */
      png_uint_32 u = ((u0 >> (20-8)) ^ ((u1 << 7) | (u0 >> (32-7)))) & 0xff;
      u1 <<= 8;
      u1 |= u0 >> 24;
      u0 <<= 8;
      u0 |= u;
 *bytes++ = (png_byte)u;
 }

   seed[0] = u0;
   seed[1] = u1;
}

static double outlog(PNG_CONST png_modifier *pm, int in_depth, int out_depth)
 {
    /* The command line parameters are either 8 bit (0..255) or 16 bit (0..65535)
     * and so must be adjusted for low bit depth grayscale:
    */
 if (out_depth <= 8)
 {
 if (pm->log8 == 0) /* switched off */
 return 256;

 if (out_depth < 8)
 return pm->log8 / 255 * ((1<<out_depth)-1);

 return pm->log8;
 }

 if ((pm->calculations_use_input_precision ? in_depth : out_depth) == 16)
 {
 if (pm->log16 == 0)
 return 65536;

 return pm->log16;
 }

 /* This is the case where the value was calculated at 8-bit precision then
    * scaled to 16 bits.
    */
 if (pm->log8 == 0)
 return 65536;

 return pm->log8 * 257;
}

read_4(struct file *file, png_uint_32 *pu)
 /* Read four bytes, returns the number of bytes read successfully and, if all
    * four bytes are read, assigns the result to *pu.
    */
{
 unsigned int i = 0;
   png_uint_32 val = 0;

 do
 {
 int ch = read_byte(file);

 if (ch == EOF)
 return i;

      val = (val << 8) + ch;
 } while (++i < 4);

 *pu = val;
 return i;
}

store_progressive_read(png_store *ps, png_structp pp, png_infop pi)
{
 /* Notice that a call to store_read will cause this function to fail because
    * readpos will be set.
    */
 if (ps->pread != pp || ps->current == NULL || ps->next == NULL)
      png_error(pp, "store state damaged (progressive)");

 do
 {
 if (ps->readpos != 0)
         png_error(pp, "store_read called during progressive read");

      png_process_data(pp, pi, ps->next->buffer, store_read_buffer_size(ps));
 }
 while (store_read_buffer_next(ps));
}

standard_info(png_structp pp, png_infop pi)
{
   standard_display *dp = voidcast(standard_display*,
      png_get_progressive_ptr(pp));

 /* Call with nImages==1 because the progressive reader can only produce one
    * image.
    */
   standard_info_imp(dp, pp, pi, 1 /*only one image*/);
}

image_transform_png_set_@_set(PNG_CONST image_transform *this,
    transform_display *that, png_structp pp, png_infop pi)
{
   png_set_@(pp);
   this->next->set(this->next, that, pp, pi);
}

gp_ga16(Pixel *p, png_const_voidp pb)
{
   png_const_uint_16p pp = voidcast(png_const_uint_16p, pb);

   p->r = p->g = p->b = pp[0];
   p->a = pp[1];
}

insert_iCCP(png_structp png_ptr, png_infop info_ptr, int nparams,
   png_charpp params)
{
   png_bytep profile = NULL;
   png_uint_32 proflen = 0;
 int result;

   check_param_count(nparams, 2);

 switch (params[1][0])
 {
 case '<':
 {
 png_size_t filelen = load_file(params[1]+1, &profile);
 if (filelen > 0xfffffffc) /* Maximum profile length */
 {
               fprintf(stderr, "%s: file too long (%lu) for an ICC profile\n",
                  params[1]+1, (unsigned long)filelen);
               exit(1);
 }

            proflen = (png_uint_32)filelen;
 }
 break;

 case '0': case '1': case '2': case '3': case '4':
 case '5': case '6': case '7': case '8': case '9':
 {
 png_size_t fake_len = load_fake(params[1], &profile);

 if (fake_len > 0) /* else a simple parameter */
 {
 if (fake_len > 0xffffffff) /* Maximum profile length */
 {
                  fprintf(stderr,
 "%s: fake data too long (%lu) for an ICC profile\n",
                     params[1], (unsigned long)fake_len);
                  exit(1);
 }
               proflen = (png_uint_32)(fake_len & ~3U);
 /* Always fix up the profile length. */
               png_save_uint_32(profile, proflen);
 break;
 }
 }

 default:
         fprintf(stderr, "--insert iCCP \"%s\": unrecognized\n", params[1]);
         fprintf(stderr, "  use '<' to read a file: \"<filename\"\n");
         exit(1);
 }

   result = 1;

 if (proflen & 3)
 {
      fprintf(stderr,
 "makepng: --insert iCCP %s: profile length made a multiple of 4\n",
         params[1]);

 /* load_file allocates extra space for this padding, the ICC spec requires
       * padding with zero bytes.
       */
 while (proflen & 3)
         profile[proflen++] = 0;
 }

 if (profile != NULL && proflen > 3)
 {
      png_uint_32 prof_header = png_get_uint_32(profile);

 if (prof_header != proflen)
 {
         fprintf(stderr, "--insert iCCP %s: profile length field wrong:\n",
            params[1]);
         fprintf(stderr, "  actual %lu, recorded value %lu (corrected)\n",
 (unsigned long)proflen, (unsigned long)prof_header);
         png_save_uint_32(profile, proflen);
 }
 }

 if (result && profile != NULL && proflen >=4)
      png_set_iCCP(png_ptr, info_ptr, params[0], PNG_COMPRESSION_TYPE_BASE,
         profile, proflen);

 if (profile)
      free(profile);

 if (!result)
      exit(1);
}

modifier_read_imp(png_modifier *pm, png_bytep pb, png_size_t st)
{
 while (st > 0)
 {
 size_t cb;
      png_uint_32 len, chunk;
      png_modification *mod;

 if (pm->buffer_position >= pm->buffer_count) switch (pm->state)
 {
 static png_byte sign[8] = { 137, 80, 78, 71, 13, 10, 26, 10 };
 case modifier_start:
            store_read_imp(&pm->this, pm->buffer, 8); /* size of signature. */
            pm->buffer_count = 8;
            pm->buffer_position = 0;

 if (memcmp(pm->buffer, sign, 8) != 0)
               png_error(pm->this.pread, "invalid PNG file signature");
            pm->state = modifier_signature;
 break;

 case modifier_signature:
            store_read_imp(&pm->this, pm->buffer, 13+12); /* size of IHDR */
            pm->buffer_count = 13+12;
            pm->buffer_position = 0;

 if (png_get_uint_32(pm->buffer) != 13 ||
                png_get_uint_32(pm->buffer+4) != CHUNK_IHDR)
               png_error(pm->this.pread, "invalid IHDR");

 /* Check the list of modifiers for modifications to the IHDR. */
            mod = pm->modifications;
 while (mod != NULL)
 {
 if (mod->chunk == CHUNK_IHDR && mod->modify_fn &&
 (*mod->modify_fn)(pm, mod, 0))
 {
                  mod->modified = 1;
                  modifier_setbuffer(pm);
 }

 /* Ignore removal or add if IHDR! */
               mod = mod->next;
 }

 /* Cache information from the IHDR (the modified one.) */
            pm->bit_depth = pm->buffer[8+8];
            pm->colour_type = pm->buffer[8+8+1];

            pm->state = modifier_IHDR;
            pm->flush = 0;
 break;

 case modifier_IHDR:
 default:
 /* Read a new chunk and process it until we see PLTE, IDAT or
             * IEND.  'flush' indicates that there is still some data to
             * output from the preceding chunk.
             */
 if ((cb = pm->flush) > 0)
 {
 if (cb > st) cb = st;
               pm->flush -= cb;
               store_read_imp(&pm->this, pb, cb);
               pb += cb;
               st -= cb;
 if (st == 0) return;
 }

 /* No more bytes to flush, read a header, or handle a pending
             * chunk.
             */
 if (pm->pending_chunk != 0)
 {
               png_save_uint_32(pm->buffer, pm->pending_len);
               png_save_uint_32(pm->buffer+4, pm->pending_chunk);
               pm->pending_len = 0;
               pm->pending_chunk = 0;
 }
 else
               store_read_imp(&pm->this, pm->buffer, 8);

            pm->buffer_count = 8;
            pm->buffer_position = 0;

 /* Check for something to modify or a terminator chunk. */
            len = png_get_uint_32(pm->buffer);
            chunk = png_get_uint_32(pm->buffer+4);

 /* Terminators first, they may have to be delayed for added
             * chunks
             */
 if (chunk == CHUNK_PLTE || chunk == CHUNK_IDAT ||
                chunk == CHUNK_IEND)
 {
               mod = pm->modifications;

 while (mod != NULL)
 {
 if ((mod->add == chunk ||
 (mod->add == CHUNK_PLTE && chunk == CHUNK_IDAT)) &&
                      mod->modify_fn != NULL && !mod->modified && !mod->added)
 {
 /* Regardless of what the modify function does do not run
                      * this again.
                      */
                     mod->added = 1;

 if ((*mod->modify_fn)(pm, mod, 1 /*add*/))
 {
 /* Reset the CRC on a new chunk */
 if (pm->buffer_count > 0)
                           modifier_setbuffer(pm);

 else
 {
                           pm->buffer_position = 0;
                           mod->removed = 1;
 }

 /* The buffer has been filled with something (we assume)
                         * so output this.  Pend the current chunk.
                         */
                        pm->pending_len = len;
                        pm->pending_chunk = chunk;
 break; /* out of while */
 }
 }

                  mod = mod->next;
 }

 /* Don't do any further processing if the buffer was modified -
                * otherwise the code will end up modifying a chunk that was
                * just added.
                */
 if (mod != NULL)
 break; /* out of switch */
 }

 /* If we get to here then this chunk may need to be modified.  To
             * do this it must be less than 1024 bytes in total size, otherwise
             * it just gets flushed.
             */
 if (len+12 <= sizeof pm->buffer)
 {
               store_read_imp(&pm->this, pm->buffer+pm->buffer_count,
                   len+12-pm->buffer_count);
               pm->buffer_count = len+12;

 /* Check for a modification, else leave it be. */
               mod = pm->modifications;
 while (mod != NULL)
 {
 if (mod->chunk == chunk)
 {
 if (mod->modify_fn == NULL)
 {
 /* Remove this chunk */
                        pm->buffer_count = pm->buffer_position = 0;
                        mod->removed = 1;
 break; /* Terminate the while loop */
 }

 else if ((*mod->modify_fn)(pm, mod, 0))
 {
                        mod->modified = 1;
 /* The chunk may have been removed: */
 if (pm->buffer_count == 0)
 {
                           pm->buffer_position = 0;
 break;
 }
                        modifier_setbuffer(pm);
 }
 }

                  mod = mod->next;
 }
 }

 else
               pm->flush = len+12 - pm->buffer_count; /* data + crc */

 /* Take the data from the buffer (if there is any). */
 break;
 }

 /* Here to read from the modifier buffer (not directly from
       * the store, as in the flush case above.)
       */
      cb = pm->buffer_count - pm->buffer_position;

 if (cb > st)
         cb = st;

      memcpy(pb, pm->buffer + pm->buffer_position, cb);
      st -= cb;
      pb += cb;
      pm->buffer_position += cb;
 }
}

read_png(FILE *fp)
{
png_structp png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING,0,0,0);
png_infop info_ptr = NULL;
png_bytep row = NULL, display = NULL;

if (png_ptr == NULL)
return 0;

if (setjmp(png_jmpbuf(png_ptr)))
{
png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
if (row != NULL) free(row);
if (display != NULL) free(display);
return 0;
}

png_init_io(png_ptr, fp);

info_ptr = png_create_info_struct(png_ptr);
if (info_ptr == NULL)
png_error(png_ptr, "OOM allocating info structure");

png_set_keep_unknown_chunks(png_ptr, PNG_HANDLE_CHUNK_ALWAYS, NULL, 0);

png_read_info(png_ptr, info_ptr);


{
png_size_t rowbytes = png_get_rowbytes(png_ptr, info_ptr);

row = malloc(rowbytes);
display = malloc(rowbytes);

if (row == NULL || display == NULL)
png_error(png_ptr, "OOM allocating row buffers");


{
png_uint_32 height = png_get_image_height(png_ptr, info_ptr);
         int passes = png_set_interlace_handling(png_ptr);
int pass;

png_start_read_image(png_ptr);

for (pass = 0; pass < passes; ++pass)

{
png_uint_32 y = height;

/* NOTE: this trashes the row each time; interlace handling won't
* work, but this avoids memory thrashing for speed testing.
*/
while (y-- > 0)
png_read_row(png_ptr, row, display);
}
}
}

/* Make sure to read to the end of the file: */
png_read_end(png_ptr, info_ptr);
png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
free(row);
free(display);
return 1;
}

cmppixel(Transform *transform, png_const_voidp in, png_const_voidp out,
   png_uint_32 x, png_uint_32 y/*or palette index*/)
{
 int maxerr;
   png_const_charp errmsg;
 Pixel pixel_in, pixel_calc, pixel_out;

   transform->in_gp(&pixel_in, in);

 if (transform->from_linear == NULL)
      transform->transform(&pixel_calc, &pixel_in, transform->background);

 else
 {
      transform->transform(&pixel_out, &pixel_in, transform->background);
      transform->from_linear(&pixel_calc, &pixel_out, NULL);
 }

   transform->out_gp(&pixel_out, out);

 /* Eliminate the case where the input and output values match exactly. */
 if (pixel_calc.a == pixel_out.a && pixel_calc.r == pixel_out.r &&
      pixel_calc.g == pixel_out.g && pixel_calc.b == pixel_out.b)
 return 1;

 /* Eliminate the case where the output pixel is transparent and the output
    * is 8-bit - any component values are valid.  Don't check the input alpha
    * here to also skip the 16-bit small alpha cases.
    */
 if (transform->output_8bit && pixel_calc.a == 0 && pixel_out.a == 0)
 return 1;

 /* Check for alpha errors first; an alpha error can damage the components too
    * so avoid spurious checks on components if one is found.
    */
   errmsg = NULL;
 {
 int err_a = abs(pixel_calc.a-pixel_out.a);

 if (err_a > transform->error[3])
 {
 /* If accumulating check the components too */
 if (transform->accumulate)
            transform->error[3] = (png_uint_16)err_a;

 else
            errmsg = "alpha";
 }
 }

 /* Now if *either* of the output alphas are 0 but alpha is within tolerance
    * eliminate the 8-bit component comparison.
    */
 if (errmsg == NULL && transform->output_8bit &&
 (pixel_calc.a == 0 || pixel_out.a == 0))
 return 1;

 if (errmsg == NULL) /* else just signal an alpha error */
 {
 int err_r = abs(pixel_calc.r - pixel_out.r);
 int err_g = abs(pixel_calc.g - pixel_out.g);
 int err_b = abs(pixel_calc.b - pixel_out.b);
 int limit;

 if ((err_r | err_g | err_b) == 0)
 return 1; /* exact match */

 /* Mismatch on a component, check the input alpha */
 if (pixel_in.a >= transform->in_opaque)
 {
         errmsg = "opaque component";
         limit = 2; /* opaque */
 }

 else if (pixel_in.a > 0)
 {
         errmsg = "alpha component";
         limit = 1; /* partially transparent */
 }

 else
 {
         errmsg = "transparent component (background)";
         limit = 0; /* transparent */
 }

      maxerr = err_r;
 if (maxerr < err_g) maxerr = err_g;
 if (maxerr < err_b) maxerr = err_b;

 if (maxerr <= transform->error[limit])
 return 1; /* within the error limits */

 /* Handle a component mis-match; log it, just return an error code, or
       * accumulate it.
       */
 if (transform->accumulate)
 {
         transform->error[limit] = (png_uint_16)maxerr;
 return 1; /* to cause the caller to keep going */
 }
 }

 /* Failure to match and not accumulating, so the error must be logged. */
 return logpixel(transform, x, y, &pixel_in, &pixel_calc, &pixel_out, errmsg);
}

type_char(png_uint_32 v)
{
 /* In fact because chunk::chunk_type is validated prior to any call to this
    * function it will always return a-zA-Z, but the extra codes are just there
    * to help in finding internal (programming) errors.  Note that the code only
    * ever considers the low 7 bits of the value (so it is not necessary for the
    * type_name function to mask of the byte.)
    */
 if (v & 32)
 return "!abcdefghijklmnopqrstuvwxyz56789"[(v-96)&31];

 else
 return "@ABCDEFGHIJKLMNOPQRSTUVWXYZ01234"[(v-64)&31];
}

paeth(uint8x8_t a, uint8x8_t b, uint8x8_t c)
{
 uint8x8_t d, e;
 uint16x8_t p1, pa, pb, pc;

   p1 = vaddl_u8(a, b); /* a + b */
   pc = vaddl_u8(c, c); /* c * 2 */
   pa = vabdl_u8(b, c); /* pa */
   pb = vabdl_u8(a, c); /* pb */
   pc = vabdq_u16(p1, pc); /* pc */

   p1 = vcleq_u16(pa, pb); /* pa <= pb */
   pa = vcleq_u16(pa, pc); /* pa <= pc */
   pb = vcleq_u16(pb, pc); /* pb <= pc */

   p1 = vandq_u16(p1, pa); /* pa <= pb && pa <= pc */

   d = vmovn_u16(pb);
   e = vmovn_u16(p1);

   d = vbsl_u8(d, b, c);
   e = vbsl_u8(e, a, d);

 return e;
}

static png_uint_32 png_exp(png_uint_32 x)
{
 return (png_uint_32)floor(.5 + exp(x * -LN2) * 0xffffffffU);
}

srgb_modify(png_modifier *pm, png_modification *me, int add)
{
   UNUSED(add)
 /* As above, ignore add and just make a new chunk */
   png_save_uint_32(pm->buffer, 1);
   png_save_uint_32(pm->buffer+4, CHUNK_sRGB);
   pm->buffer[8] = ((srgb_modification*)me)->intent;
 return 1;
}

IDAT_end(struct IDAT **idat_var)
{
 struct IDAT *idat = *idat_var;
 struct file *file = idat->file;

 *idat_var = NULL;

   CLEAR(*idat);

   assert(file->chunk != NULL);
   chunk_end(&file->chunk);

 /* Regardless of why the IDAT was killed set the state back to CHUNKS (it may
    * already be CHUNKS because the state isn't changed until process_IDAT
    * returns; a stop will cause IDAT_end to be entered in state CHUNKS!)
    */
   file->state = STATE_CHUNKS;
}

transform_enable(PNG_CONST char *name)
 {
    /* Everything starts out enabled, so if we see an 'enable' disabled
     * everything else the first time round.
    */
 static int all_disabled = 0;
 int found_it = 0;
   image_transform *list = image_transform_first;

 while (list != &image_transform_end)
 {
 if (strcmp(list->name, name) == 0)
 {
 list->enable = 1;
         found_it = 1;
 }
 else if (!all_disabled)
 list->enable = 0;

 list = list->list;
 }

   all_disabled = 1;

 if (!found_it)
 {
      fprintf(stderr, "pngvalid: --transform-enable=%s: unknown transform\n",
         name);
      exit(99);
 }

 }

image_transform_png_set_expand_gray_1_2_4_to_8_set(
    PNG_CONST image_transform *this, transform_display *that, png_structp pp,
png_infop pi)
{
png_set_expand_gray_1_2_4_to_8(pp);
this->next->set(this->next, that, pp, pi);
}

one_file(struct global *global, const char *file_name, const char *out_name)
{
 int rc;
 struct control control;

 if (global->verbose)
      fprintf(stderr, "FILE %s -> %s\n", file_name,
         out_name ? out_name : "<none>");

 /* Although control_init can return a failure code the structure is always
    * initialized, so control_end can be used to accumulate any status codes.
    */
   rc = control_init(&control, global, file_name, out_name);

 if (rc == 0)
      rc = read_png(&control);

   rc |= control_end(&control);

 return rc;
}

static void rpng2_win_display_row(ulg row)
{
    uch bg_red   = rpng2_info.bg_red;
    uch bg_green = rpng2_info.bg_green;
    uch bg_blue  = rpng2_info.bg_blue;
    uch *src, *src2=NULL, *dest;
    uch r, g, b, a;
    ulg i;
 static int rows=0;
 static ulg firstrow;

/*---------------------------------------------------------------------------
    rows and firstrow simply track how many rows (and which ones) have not
    yet been displayed; alternatively, we could call InvalidateRect() for
    every row and not bother with the records-keeping.
  ---------------------------------------------------------------------------*/

 Trace((stderr, "beginning rpng2_win_display_row()\n"))

 if (rows == 0)
        firstrow = row; /* first row not yet displayed */

 ++rows; /* count of rows received but not yet displayed */

/*---------------------------------------------------------------------------
    Aside from the use of the rpng2_info struct and the lack of an outer
    loop (over rows), this routine is identical to rpng_win_display_image()
    in the non-progressive version of the program.
  ---------------------------------------------------------------------------*/

    src = rpng2_info.image_data + row*rpng2_info.rowbytes;
 if (bg_image)
        src2 = bg_data + row*bg_rowbytes;
    dest = wimage_data + row*wimage_rowbytes;

 if (rpng2_info.channels == 3) {
 for (i = rpng2_info.width;  i > 0; --i) {
            r = *src++;
            g = *src++;
            b = *src++;
 *dest++ = b;
 *dest++ = g; /* note reverse order */
 *dest++ = r;
 }
 } else /* if (rpng2_info.channels == 4) */ {
 for (i = rpng2_info.width;  i > 0; --i) {
            r = *src++;
            g = *src++;
            b = *src++;
            a = *src++;
 if (bg_image) {
                bg_red   = *src2++;
                bg_green = *src2++;
                bg_blue  = *src2++;
 }
 if (a == 255) {
 *dest++ = b;
 *dest++ = g;
 *dest++ = r;
 } else if (a == 0) {
 *dest++ = bg_blue;
 *dest++ = bg_green;
 *dest++ = bg_red;
 } else {
 /* this macro (copied from png.h) composites the
                 * foreground and background values and puts the
                 * result into the first argument; there are no
                 * side effects with the first argument */
                alpha_composite(*dest++, b, a, bg_blue);
                alpha_composite(*dest++, g, a, bg_green);
                alpha_composite(*dest++, r, a, bg_red);
 }
 }
 }

/*---------------------------------------------------------------------------
    Display after every 16 rows or when on last row.  (Region may include
    previously displayed lines due to interlacing--i.e., not contiguous.)
  ---------------------------------------------------------------------------*/

 if ((rows & 0xf) == 0 || row == rpng2_info.height-1) {
        RECT rect;

        rect.left = 0L;
        rect.top = (LONG)firstrow;
        rect.right = (LONG)rpng2_info.width; /* possibly off by one? */
        rect.bottom = (LONG)row + 1L; /* possibly off by one? */
 InvalidateRect(global_hwnd, &rect, FALSE);
 UpdateWindow(global_hwnd); /* similar to XFlush() */
        rows = 0;
 }

} /* end function rpng2_win_display_row() */

 chromaticity_x(CIE_color c)
 {
 return c.X / (c.X + c.Y + c.Z);
}

current_type(struct file *file, int code)
 /* Guess the actual chunk type that causes a stop() */
{
 /* This may return png_IDAT for errors detected (late) in the header; that
    * includes any inter-chunk consistency check that libpng performs.  Assume
    * that if the chunk_type is png_IDAT and the file write count is 8 this is
    * what is happening.
    */
 if (file->chunk != NULL)
 {
      png_uint_32 type = file->chunk->chunk_type;

 /* This is probably wrong for the excess IDATs case, because then libpng
       * whines about too many of them (apparently in some cases erroneously)
       * when the header is read.
       */
 if (code <= LIBPNG_ERROR_CODE && type == png_IDAT &&
         file->write_count == 8)
         type = 0; /* magic */

 return type;
 }

 else
 return file->type;
}

modifier_progressive_read(png_modifier *pm, png_structp pp, png_infop pi)
{
 if (pm->this.pread != pp || pm->this.current == NULL ||
       pm->this.next == NULL)
      png_error(pp, "store state damaged (progressive)");

 /* This is another Horowitz and Hill random noise generator.  In this case
    * the aim is to stress the progressive reader with truly horrible variable
    * buffer sizes in the range 1..500, so a sequence of 9 bit random numbers
    * is generated.  We could probably just count from 1 to 32767 and get as
    * good a result.
    */
 for (;;)
 {
 static png_uint_32 noise = 1;
 png_size_t cb, cbAvail;
      png_byte buffer[512];

 /* Generate 15 more bits of stuff: */
      noise = (noise << 9) | ((noise ^ (noise >> (9-5))) & 0x1ff);
      cb = noise & 0x1ff;

 /* Check that this number of bytes are available (in the current buffer.)
       * (This doesn't quite work - the modifier might delete a chunk; unlikely
       * but possible, it doesn't happen at present because the modifier only
       * adds chunks to standard images.)
       */
      cbAvail = store_read_buffer_avail(&pm->this);
 if (pm->buffer_count > pm->buffer_position)
         cbAvail += pm->buffer_count - pm->buffer_position;

 if (cb > cbAvail)
 {
 /* Check for EOF: */
 if (cbAvail == 0)
 break;

         cb = cbAvail;
 }

      modifier_read_imp(pm, buffer, cb);
      png_process_data(pp, pi, buffer, cb);
 }

 /* Check the invariants at the end (if this fails it's a problem in this
    * file!)
    */
 if (pm->buffer_count > pm->buffer_position ||
       pm->this.next != &pm->this.current->data ||
       pm->this.readpos < pm->this.current->datacount)
      png_error(pp, "progressive read implementation error");
}

read_palette(store_palette palette, int *npalette, png_const_structp pp,
   png_infop pi)
{
   png_colorp pal;
   png_bytep trans_alpha;
 int num;

   pal = 0;
 *npalette = -1;

 if (png_get_PLTE(pp, pi, &pal, npalette) & PNG_INFO_PLTE)
 {
 int i = *npalette;

 if (i <= 0 || i > 256)
         png_error(pp, "validate: invalid PLTE count");

 while (--i >= 0)
 {
         palette[i].red = pal[i].red;
         palette[i].green = pal[i].green;
         palette[i].blue = pal[i].blue;
 }

 /* Mark the remainder of the entries with a flag value (other than
       * white/opaque which is the flag value stored above.)
       */
      memset(palette + *npalette, 126, (256-*npalette) * sizeof *palette);
 }

 else /* !png_get_PLTE */
 {
 if (*npalette != (-1))
         png_error(pp, "validate: invalid PLTE result");
 /* But there is no palette, so record this: */
 *npalette = 0;
      memset(palette, 113, sizeof (store_palette));
 }

   trans_alpha = 0;
   num = 2; /* force error below */
 if ((png_get_tRNS(pp, pi, &trans_alpha, &num, 0) & PNG_INFO_tRNS) != 0 &&
 (trans_alpha != NULL || num != 1/*returns 1 for a transparent color*/) &&
 /* Oops, if a palette tRNS gets expanded png_read_update_info (at least so
       * far as 1.5.4) does not remove the trans_alpha pointer, only num_trans,
       * so in the above call we get a success, we get a pointer (who knows what
       * to) and we get num_trans == 0:
       */
 !(trans_alpha != NULL && num == 0)) /* TODO: fix this in libpng. */
 {
 int i;

 /* Any of these are crash-worthy - given the implementation of
       * png_get_tRNS up to 1.5 an app won't crash if it just checks the
       * result above and fails to check that the variables it passed have
       * actually been filled in!  Note that if the app were to pass the
       * last, png_color_16p, variable too it couldn't rely on this.
       */
 if (trans_alpha == NULL || num <= 0 || num > 256 || num > *npalette)
         png_error(pp, "validate: unexpected png_get_tRNS (palette) result");

 for (i=0; i<num; ++i)
         palette[i].alpha = trans_alpha[i];

 for (num=*npalette; i<num; ++i)
         palette[i].alpha = 255;

 for (; i<256; ++i)
         palette[i].alpha = 33; /* flag value */

 return 1; /* transparency */
 }

 else
 {
 /* No palette transparency - just set the alpha channel to opaque. */
 int i;

 for (i=0, num=*npalette; i<num; ++i)
         palette[i].alpha = 255;

 for (; i<256; ++i)
         palette[i].alpha = 55; /* flag value */

 return 0; /* no transparency */
 }
}

static void readpng2_end_callback(png_structp png_ptr, png_infop info_ptr)
{
    mainprog_info  *mainprog_ptr;


 /* retrieve the pointer to our special-purpose struct */

    mainprog_ptr = png_get_progressive_ptr(png_ptr);


 /* let the main program know that it should flush any buffered image
     * data to the display now and set a "done" flag or whatever, but note
     * that it SHOULD NOT DESTROY THE PNG STRUCTS YET--in other words, do
     * NOT call readpng2_cleanup() either here or in the finish_display()
     * routine; wait until control returns to the main program via
     * readpng2_decode_data() */

 (*mainprog_ptr->mainprog_finish_display)();


 
     /* all done */
 
     return;
 }

testimage(Image *image, png_uint_32 opts, format_list *pf)
{
 int result;
 Image copy;

 /* Copy the original data, stealing it from 'image' */
   checkopaque(image);
   copy = *image;

   copy.opts = opts;
   copy.buffer = NULL;
   copy.bufsize = 0;
   copy.allocsize = 0;

   image->input_file = NULL;
   image->input_memory = NULL;
   image->input_memory_size = 0;
   image->tmpfile_name[0] = 0;

 {
      png_uint_32 counter;
 Image output;

      newimage(&output);

      result = 1;

 /* Use the low bit of 'counter' to indicate whether or not to do alpha
       * removal with a background color or by composting onto the image; this
       * step gets skipped if it isn't relevant
       */
 for (counter=0; counter<2*FORMAT_COUNT; ++counter)
 if (format_isset(pf, counter >> 1))
 {
         png_uint_32 format = counter >> 1;

         png_color background_color;
         png_colorp background = NULL;

 /* If there is a format change that removes the alpha channel then
          * the background is relevant.  If the output is 8-bit color-mapped
          * then a background color *must* be provided, otherwise there are
          * two tests to do - one with a color, the other with NULL.  The
          * NULL test happens second.
          */
 if ((counter & 1) == 0)
 {
 if ((format & PNG_FORMAT_FLAG_ALPHA) == 0 &&
 (image->image.format & PNG_FORMAT_FLAG_ALPHA) != 0)
 {
 /* Alpha/transparency will be removed, the background is
                * relevant: make it a color the first time
                */
               random_color(&background_color);
               background = &background_color;

 /* BUT if the output is to a color-mapped 8-bit format then
                * the background must always be a color, so increment 'counter'
                * to skip the NULL test.
                */
 if ((format & PNG_FORMAT_FLAG_COLORMAP) != 0 &&
 (format & PNG_FORMAT_FLAG_LINEAR) == 0)
 ++counter;
 }

 /* Otherwise an alpha channel is not being eliminated, just leave
             * background NULL and skip the (counter & 1) NULL test.
             */
 else
 ++counter;
 }
 /* else just use NULL for background */

         resetimage(&copy);
         copy.opts = opts; /* in case read_file needs to change it */

         result = read_file(&copy, format, background);
 if (!result)
 break;

 /* Make sure the file just read matches the original file. */
         result = compare_two_images(image, &copy, 0/*via linear*/, background);
 if (!result)
 break;

#        ifdef PNG_SIMPLIFIED_WRITE_SUPPORTED
 /* Write the *copy* just made to a new file to make sure the write
             * side works ok.  Check the conversion to sRGB if the copy is
             * linear.
             */
            output.opts = opts;
            result = write_one_file(&output, &copy, 0/*convert to 8bit*/);
 if (!result)
 break;

 /* Validate against the original too; the background is needed here
             * as well so that compare_two_images knows what color was used.
             */
            result = compare_two_images(image, &output, 0, background);
 if (!result)
 break;

 if ((format & PNG_FORMAT_FLAG_LINEAR) != 0 &&
 (format & PNG_FORMAT_FLAG_COLORMAP) == 0)
 {
 /* 'output' is linear, convert to the corresponding sRGB format.
                */
               output.opts = opts;
               result = write_one_file(&output, &copy, 1/*convert to 8bit*/);
 if (!result)
 break;

 /* This may involve a conversion via linear; in the ideal world
                * this would round-trip correctly, but libpng 1.5.7 is not the
                * ideal world so allow a drift (error_via_linear).
                *
                * 'image' has an alpha channel but 'output' does not then there
                * will a strip-alpha-channel operation (because 'output' is
                * linear), handle this by composing on black when doing the
                * comparison.
                */
               result = compare_two_images(image, &output, 1/*via_linear*/,
                  background);
 if (!result)
 break;
 }
#        endif /* PNG_SIMPLIFIED_WRITE_SUPPORTED */
 }

      freeimage(&output);
 }

   freeimage(&copy);

 return result;
}

image_transform_png_set_@_add(image_transform *this,
    PNG_CONST image_transform **that, char *name, size_t sizeof_name,
    size_t *pos, png_byte colour_type, png_byte bit_depth)
{
   this->next = *that;
   *that = this;
   *pos = safecat(name, sizeof_name, *pos, " +@");
   return 1;
}

chunk_message(struct chunk *chunk, const char *message)
{
   type_message(chunk->file, chunk->chunk_type, message);
}

gpc_g8b(Pixel *out, const Pixel *in, const Background *back)
{
 if (in->a <= 0)
      out->r = out->g = out->b = back->ig;

 else if (in->a >= 255)
 {
 if (in->r == in->g && in->g == in->b)
         out->r = out->g = out->b = in->g;

 else
         out->r = out->g = out->b = sRGB(YfromRGB(
            sRGB_to_d[in->r], sRGB_to_d[in->g], sRGB_to_d[in->b]));
 }

 else
 {
 double a = in->a/255.;

      out->r = out->g = out->b = sRGB(a * YfromRGB(sRGB_to_d[in->r],
         sRGB_to_d[in->g], sRGB_to_d[in->b]) + back->dg * (1-a));
 }

   out->a = 255;
}

emit_string(const char *str, FILE *out)
 /* Print a string with spaces replaced by '_' and non-printing characters by
    * an octal escape.
    */
{
 for (; *str; ++str)
 if (isgraph(UCHAR_MAX & *str))
         putc(*str, out);

 
       else if (isspace(UCHAR_MAX & *str))
          putc('_', out);
       else
          fprintf(out, "\\%.3o", *str);
 }

png_read_filter_row_sub4_neon(png_row_infop row_info, png_bytep row,
   png_const_bytep prev_row)
{
   png_bytep rp = row;
   png_bytep rp_stop = row + row_info->rowbytes;

 uint8x8x4_t vdest;
   vdest.val[3] = vdup_n_u8(0);

 for (; rp < rp_stop; rp += 16)
 {
 uint32x2x4_t vtmp = vld4_u32(png_ptr(uint32_t,rp));
 uint8x8x4_t *vrpt = png_ptr(uint8x8x4_t,&vtmp);
 uint8x8x4_t vrp = *vrpt;
 uint32x2x4_t *temp_pointer;

      vdest.val[0] = vadd_u8(vdest.val[3], vrp.val[0]);
      vdest.val[1] = vadd_u8(vdest.val[0], vrp.val[1]);
      vdest.val[2] = vadd_u8(vdest.val[1], vrp.val[2]);
      vdest.val[3] = vadd_u8(vdest.val[2], vrp.val[3]);
      vst4_lane_u32(png_ptr(uint32_t,rp), png_ldr(uint32x2x4_t,&vdest), 0);
 }

   PNG_UNUSED(prev_row)
}

print_pixel(png_structp png_ptr, png_infop info_ptr, png_const_bytep row,
png_uint_32 x)
{
PNG_CONST unsigned int bit_depth = png_get_bit_depth(png_ptr, info_ptr);

switch (png_get_color_type(png_ptr, info_ptr))
{
case PNG_COLOR_TYPE_GRAY:
printf("GRAY %u\n", component(row, x, 0, bit_depth, 1));
return;

/* The palette case is slightly more difficult - the palette and, if
* present, the tRNS ('transparency', though the values are really
* opacity) data must be read to give the full picture:

*/
case PNG_COLOR_TYPE_PALETTE:
{
            PNG_CONST unsigned int index = component(row, x, 0, bit_depth, 1);
png_colorp palette = NULL;
int num_palette = 0;

if ((png_get_PLTE(png_ptr, info_ptr, &palette, &num_palette) &
PNG_INFO_PLTE) && num_palette > 0 && palette != NULL)
{
png_bytep trans_alpha = NULL;
int num_trans = 0;
if ((png_get_tRNS(png_ptr, info_ptr, &trans_alpha, &num_trans,
NULL) & PNG_INFO_tRNS) && num_trans > 0 &&
trans_alpha != NULL)
printf("INDEXED %u = %d %d %d %d\n", index,
palette[index].red, palette[index].green,
palette[index].blue,
index < num_trans ? trans_alpha[index] : 255);

else /* no transparency */
printf("INDEXED %u = %d %d %d\n", index,
palette[index].red, palette[index].green,
palette[index].blue);
}

else
printf("INDEXED %u = invalid index\n", index);
}
return;

case PNG_COLOR_TYPE_RGB:
printf("RGB %u %u %u\n", component(row, x, 0, bit_depth, 3),
component(row, x, 1, bit_depth, 3),
component(row, x, 2, bit_depth, 3));
return;

case PNG_COLOR_TYPE_GRAY_ALPHA:
printf("GRAY+ALPHA %u %u\n", component(row, x, 0, bit_depth, 2),
component(row, x, 1, bit_depth, 2));
return;

case PNG_COLOR_TYPE_RGB_ALPHA:
printf("RGBA %u %u %u %u\n", component(row, x, 0, bit_depth, 4),
component(row, x, 1, bit_depth, 4),
component(row, x, 2, bit_depth, 4),
component(row, x, 3, bit_depth, 4));
return;

default:
png_error(png_ptr, "pngpixel: invalid color type");
}
}

int main(int argc, char **argv)
{
 int count = COUNT;

 while (argc > 1)
 {
 if (argc > 2 && strcmp(argv[1], "-c") == 0)
 {
         count = atoi(argv[2]);
         argc -= 2;
         argv += 2;
 }

 else if (strcmp(argv[1], "-v") == 0)
 {
 ++verbose;
 --argc;
 ++argv;
 }

 else
 break;
 }

 if (count > 0 && argc > 1)
 {
 if (strcmp(argv[1], "ascii") == 0)
 return validation_ascii_to_fp(count, argc-1, argv+1);
 else if (strcmp(argv[1], "checkfp") == 0)
 return validation_checkfp(count, argc-1, argv+1);
 else if (strcmp(argv[1], "muldiv") == 0)
 return validation_muldiv(count, argc-1, argv+1);
 else if (strcmp(argv[1], "gamma") == 0)
 return validation_gamma(argc-1, argv+1);
 }

 /* Bad argument: */
   fprintf(stderr,
 "usage: tarith [-v] [-c count] {ascii,muldiv,gamma} [args]\n");
   fprintf(stderr, " arguments: ascii [-a (all results)] [-e error%%]\n");
   fprintf(stderr, "            checkfp [-l max-number-chars]\n");
   fprintf(stderr, "            muldiv\n");
   fprintf(stderr, "            gamma -s (silent) -g (only gamma; no log)\n");
 return 1;
}

png_read_filter_row_sub3_neon(png_row_infop row_info, png_bytep row,
   png_const_bytep prev_row)
{
   png_bytep rp = row;
   png_bytep rp_stop = row + row_info->rowbytes;

 uint8x16_t vtmp = vld1q_u8(rp);
 uint8x8x2_t *vrpt = png_ptr(uint8x8x2_t, &vtmp);
 uint8x8x2_t vrp = *vrpt;

 uint8x8x4_t vdest;
   vdest.val[3] = vdup_n_u8(0);

 for (; rp < rp_stop;)
 {
 uint8x8_t vtmp1, vtmp2;
 uint32x2_t *temp_pointer;

      vtmp1 = vext_u8(vrp.val[0], vrp.val[1], 3);
      vdest.val[0] = vadd_u8(vdest.val[3], vrp.val[0]);
      vtmp2 = vext_u8(vrp.val[0], vrp.val[1], 6);
      vdest.val[1] = vadd_u8(vdest.val[0], vtmp1);

      vtmp1 = vext_u8(vrp.val[1], vrp.val[1], 1);
      vdest.val[2] = vadd_u8(vdest.val[1], vtmp2);
      vdest.val[3] = vadd_u8(vdest.val[2], vtmp1);

      vtmp = vld1q_u8(rp + 12);
      vrpt = png_ptr(uint8x8x2_t, &vtmp);
      vrp = *vrpt;

      vst1_lane_u32(png_ptr(uint32_t,rp), png_ldr(uint32x2_t,&vdest.val[0]), 0);
      rp += 3;
      vst1_lane_u32(png_ptr(uint32_t,rp), png_ldr(uint32x2_t,&vdest.val[1]), 0);
      rp += 3;
      vst1_lane_u32(png_ptr(uint32_t,rp), png_ldr(uint32x2_t,&vdest.val[2]), 0);
      rp += 3;
      vst1_lane_u32(png_ptr(uint32_t,rp), png_ldr(uint32x2_t,&vdest.val[3]), 0);
      rp += 3;
 }

   PNG_UNUSED(prev_row)
}

makepng_error(png_structp png_ptr, png_const_charp message)
{
   makepng_warning(png_ptr, message);
   png_longjmp(png_ptr, 1);
}

process_zTXt_iCCP(struct file *file)
 /* zTXt and iCCP have exactly the same form - keyword, null, compression
    * method then compressed data.
    */
{
 struct chunk *chunk = file->chunk;
   png_uint_32 length;
   png_uint_32 index = 0;

   assert(chunk != NULL && file->idat == NULL);
   length = chunk->chunk_length;
   setpos(chunk);

 while (length >= 9)
 {
 --length;
 ++index;
 if (reread_byte(file) == 0) /* keyword null terminator */
 {
 --length;
 ++index;
 (void)reread_byte(file); /* compression method */
 return zlib_check(file, index);
 }
 }

   chunk_message(chunk, "too short");
 return 0; /* skip */
}

void usage()
{
fprintf (stderr, "PNM2PNG\n");
fprintf (stderr, "   by Willem van Schaik, 1999\n");
#ifdef __TURBOC__
fprintf (stderr, "   for Turbo-C and Borland-C compilers\n");
#else
fprintf (stderr, "   for Linux (and Unix) compilers\n");
#endif
fprintf (stderr, "Usage:  pnm2png [options] <file>.<pnm> [<file>.png]\n");

fprintf (stderr, "   or:  ... | pnm2png [options]\n");
fprintf (stderr, "Options:\n");
fprintf (stderr, "   -i[nterlace]   write png-file with interlacing on\n");
  fprintf (stderr, "   -a[lpha] <file>.pgm read PNG alpha channel as pgm-file\n");
fprintf (stderr, "   -h | -?  print this help-information\n");
}

store_write_reset(png_store *ps)
{
 if (ps->pwrite != NULL)
 {
      anon_context(ps);

 Try
         png_destroy_write_struct(&ps->pwrite, &ps->piwrite);

 Catch_anonymous
 {
 /* memory corruption: continue. */
 }

      ps->pwrite = NULL;
      ps->piwrite = NULL;
 }

 /* And make sure that all the memory has been freed - this will output
    * spurious errors in the case of memory corruption above, but this is safe.
    */
#  ifdef PNG_USER_MEM_SUPPORTED
      store_pool_delete(ps, &ps->write_memory_pool);
#  endif

   store_freenew(ps);
}

display_clean(struct display *dp)
{
#  ifdef PNG_WRITE_SUPPORTED
      display_clean_write(dp);
#  endif
   display_clean_read(dp);

   dp->original_rowbytes = 0;
   dp->original_rows = NULL;
   dp->chunks = 0;

   png_destroy_read_struct(&dp->original_pp, &dp->original_ip, NULL);
 /* leave the filename for error detection */

    dp->results = 0; /* reset for next time */
 }

image_transform_png_set_tRNS_to_alpha_add(image_transform *this,
    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)
{
UNUSED(bit_depth)

this->next = *that;
*that = this;


/* We don't know yet whether there will be a tRNS chunk, but we know that
* this transformation should do nothing if there already is an alpha
    * channel.
*/
   return (colour_type & PNG_COLOR_MASK_ALPHA) == 0;
}

gamma_info_imp(gamma_display *dp, png_structp pp, png_infop pi)
{
/* Reuse the standard stuff as appropriate. */
standard_info_part1(&dp->this, pp, pi);


/* If requested strip 16 to 8 bits - this is handled automagically below
* because the output bit depth is read from the library.  Note that there
* are interactions with sBIT but, internally, libpng makes sbit at most
    * PNG_MAX_GAMMA_8 when doing the following.
*/
if (dp->scale16)
#     ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED
png_set_scale_16(pp);
#     else
/* The following works both in 1.5.4 and earlier versions: */
#        ifdef PNG_READ_16_TO_8_SUPPORTED
png_set_strip_16(pp);
#        else
png_error(pp, "scale16 (16 to 8 bit conversion) not supported");
#        endif
#     endif

if (dp->expand16)
#     ifdef PNG_READ_EXPAND_16_SUPPORTED
png_set_expand_16(pp);
#     else
png_error(pp, "expand16 (8 to 16 bit conversion) not supported");
#     endif

if (dp->do_background >= ALPHA_MODE_OFFSET)
{
#     ifdef PNG_READ_ALPHA_MODE_SUPPORTED
{
/* This tests the alpha mode handling, if supported. */
int mode = dp->do_background - ALPHA_MODE_OFFSET;

/* The gamma value is the output gamma, and is in the standard,

* non-inverted, represenation.  It provides a default for the PNG file
* gamma, but since the file has a gAMA chunk this does not matter.
*/
         PNG_CONST double sg = dp->screen_gamma;
#        ifndef PNG_FLOATING_POINT_SUPPORTED
            PNG_CONST png_fixed_point g = fix(sg);
#        endif

#        ifdef PNG_FLOATING_POINT_SUPPORTED
png_set_alpha_mode(pp, mode, sg);
#        else
png_set_alpha_mode_fixed(pp, mode, g);
#        endif

/* However, for the standard Porter-Duff algorithm the output defaults
* to be linear, so if the test requires non-linear output it must be
* corrected here.
*/
if (mode == PNG_ALPHA_STANDARD && sg != 1)
{
#           ifdef PNG_FLOATING_POINT_SUPPORTED
png_set_gamma(pp, sg, dp->file_gamma);
#           else
png_fixed_point f = fix(dp->file_gamma);
png_set_gamma_fixed(pp, g, f);
#           endif
}
}
#     else
png_error(pp, "alpha mode handling not supported");
#     endif
}

else
{
/* Set up gamma processing. */
#     ifdef PNG_FLOATING_POINT_SUPPORTED
png_set_gamma(pp, dp->screen_gamma, dp->file_gamma);
#     else
{
png_fixed_point s = fix(dp->screen_gamma);
png_fixed_point f = fix(dp->file_gamma);
png_set_gamma_fixed(pp, s, f);
}
#     endif

if (dp->do_background)
{

#     ifdef PNG_READ_BACKGROUND_SUPPORTED
/* NOTE: this assumes the caller provided the correct background gamma!
*/
         PNG_CONST double bg = dp->background_gamma;
#        ifndef PNG_FLOATING_POINT_SUPPORTED
            PNG_CONST png_fixed_point g = fix(bg);
#        endif

#        ifdef PNG_FLOATING_POINT_SUPPORTED
png_set_background(pp, &dp->background_color, dp->do_background,
0/*need_expand*/, bg);
#        else
png_set_background_fixed(pp, &dp->background_color,
dp->do_background, 0/*need_expand*/, g);
#        endif
#     else
png_error(pp, "png_set_background not supported");
#     endif
}
}

{
int i = dp->this.use_update_info;
/* Always do one call, even if use_update_info is 0. */
do
png_read_update_info(pp, pi);
while (--i > 0);
}

/* Now we may get a different cbRow: */
standard_info_part2(&dp->this, pp, pi, 1 /*images*/);
}

write_one_file(Image *output, Image *image, int convert_to_8bit)
{
 if (image->opts & FAST_WRITE)
      image->image.flags |= PNG_IMAGE_FLAG_FAST;

 
    if (image->opts & USE_STDIO)
    {
       FILE *f = tmpfile();
 
       if (f != NULL)
       {
 if (png_image_write_to_stdio(&image->image, f, convert_to_8bit,
            image->buffer+16, (png_int_32)image->stride, image->colormap))
 {
 if (fflush(f) == 0)
 {
               rewind(f);
               initimage(output, image->opts, "tmpfile", image->stride_extra);
               output->input_file = f;
 if (!checkopaque(image))
 return 0;
 }

 else
 return logclose(image, f, "tmpfile", ": flush: ");
 }

 else
 {
            fclose(f);
 return logerror(image, "tmpfile", ": write failed", "");
 }
 }

 else
 return logerror(image, "tmpfile", ": open: ", strerror(errno));
 }

 else
 {
 static int counter = 0;
 char name[32];

      sprintf(name, "%s%d.png", tmpf, ++counter);

 if (png_image_write_to_file(&image->image, name, convert_to_8bit,
         image->buffer+16, (png_int_32)image->stride, image->colormap))
 {
         initimage(output, image->opts, output->tmpfile_name,
            image->stride_extra);
 /* Afterwards, or freeimage will delete it! */
         strcpy(output->tmpfile_name, name);

 if (!checkopaque(image))
 return 0;
 }

 else
 return logerror(image, name, ": write failed", "");
 }

 /* 'output' has an initialized temporary image, read this back in and compare
    * this against the original: there should be no change since the original
    * format was written unmodified unless 'convert_to_8bit' was specified.
    * However, if the original image was color-mapped, a simple read will zap
    * the linear, color and maybe alpha flags, this will cause spurious failures
    * under some circumstances.
    */
 if (read_file(output, image->image.format | FORMAT_NO_CHANGE, NULL))
 {
      png_uint_32 original_format = image->image.format;

 if (convert_to_8bit)
         original_format &= ~PNG_FORMAT_FLAG_LINEAR;

 if ((output->image.format & BASE_FORMATS) !=
 (original_format & BASE_FORMATS))
 return logerror(image, image->file_name, ": format changed on read: ",
            output->file_name);

 return compare_two_images(image, output, 0/*via linear*/, NULL);
 }

 else
 return logerror(output, output->tmpfile_name,
 ": read of new file failed", "");
}

PNG_FUNCTION(void, (PNGCBAPI error), (png_structp png_ptr, const char *message),
 static PNG_NORETURN)
{
   display *d = (display*)png_get_error_ptr(png_ptr);

   fprintf(stderr, "%s(%s): libpng error: %s\n", d->file, d->test, message);
   display_exit(d);
}

ilineara_g22(int fixed_srgb, int alpha)
{
 return u16d((257 * alpha) * g22_to_d[fixed_srgb]);
}

static void readpng2_info_callback(png_structp png_ptr, png_infop info_ptr)
{
mainprog_info  *mainprog_ptr;
int  color_type, bit_depth;
png_uint_32 width, height;
#ifdef PNG_FLOATING_POINT_SUPPORTED
double  gamma;
#else
png_fixed_point gamma;
#endif


/* setjmp() doesn't make sense here, because we'd either have to exit(),
* longjmp() ourselves, or return control to libpng, which doesn't want
* to see us again.  By not doing anything here, libpng will instead jump
* to readpng2_decode_data(), which can return an error value to the main
* program. */


/* retrieve the pointer to our special-purpose struct, using the png_ptr
* that libpng passed back to us (i.e., not a global this time--there's
* no real difference for a single image, but for a multithreaded browser
* decoding several PNG images at the same time, one needs to avoid mixing
* up different images' structs) */

mainprog_ptr = png_get_progressive_ptr(png_ptr);

if (mainprog_ptr == NULL) { /* we be hosed */
fprintf(stderr,
"readpng2 error:  main struct not recoverable in info_callback.\n");
fflush(stderr);
return;
/*
* Alternatively, we could call our error-handler just like libpng
* does, which would effectively terminate the program.  Since this
* can only happen if png_ptr gets redirected somewhere odd or the
* main PNG struct gets wiped, we're probably toast anyway.  (If
* png_ptr itself is NULL, we would not have been called.)
*/
}


/* this is just like in the non-progressive case */

png_get_IHDR(png_ptr, info_ptr, &width, &height, &bit_depth, &color_type,
NULL, NULL, NULL);
mainprog_ptr->width = (ulg)width;
mainprog_ptr->height = (ulg)height;



/* since we know we've read all of the PNG file's "header" (i.e., up
* to IDAT), we can check for a background color here */

    if (mainprog_ptr->need_bgcolor &&
        png_get_valid(png_ptr, info_ptr, PNG_INFO_bKGD))
{
png_color_16p pBackground;

/* it is not obvious from the libpng documentation, but this function
* takes a pointer to a pointer, and it always returns valid red,
* green and blue values, regardless of color_type: */
        png_get_bKGD(png_ptr, info_ptr, &pBackground);

        /* however, it always returns the raw bKGD data, regardless of any
         * bit-depth transformations, so check depth and adjust if necessary *
        if (bit_depth == 16) {
            mainprog_ptr->bg_red   = pBackground->red   >> 8;
            mainprog_ptr->bg_green = pBackground->green >> 8;
            mainprog_ptr->bg_blue  = pBackground->blue  >> 8;
        } else if (color_type == PNG_COLOR_TYPE_GRAY && bit_depth < 8) {
            if (bit_depth == 1)
                mainprog_ptr->bg_red = mainprog_ptr->bg_green =
                  mainprog_ptr->bg_blue = pBackground->gray? 255 : 0;
            else if (bit_depth == 2)
                mainprog_ptr->bg_red = mainprog_ptr->bg_green =
                  mainprog_ptr->bg_blue = (255/3) * pBackground->gray;
            else /* bit_depth == 4 *
                mainprog_ptr->bg_red = mainprog_ptr->bg_green =
                  mainprog_ptr->bg_blue = (255/15) * pBackground->gray;
        } else {
            mainprog_ptr->bg_red   = (uch)pBackground->red;
            mainprog_ptr->bg_green = (uch)pBackground->green;
            mainprog_ptr->bg_blue  = (uch)pBackground->blue;
}
}


/* as before, let libpng expand palette images to RGB, low-bit-depth
* grayscale images to 8 bits, transparency chunks to full alpha channel;
* strip 16-bit-per-sample images to 8 bits per sample; and convert
* grayscale to RGB[A] */

if (color_type == PNG_COLOR_TYPE_PALETTE)
png_set_expand(png_ptr);
if (color_type == PNG_COLOR_TYPE_GRAY && bit_depth < 8)
png_set_expand(png_ptr);
if (png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS))
png_set_expand(png_ptr);
#ifdef PNG_READ_16_TO_8_SUPPORTED
if (bit_depth == 16)
#  ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED
png_set_scale_16(png_ptr);
#  else
png_set_strip_16(png_ptr);
#  endif
#endif
if (color_type == PNG_COLOR_TYPE_GRAY ||
color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
png_set_gray_to_rgb(png_ptr);


/* Unlike the basic viewer, which was designed to operate on local files,
* this program is intended to simulate a web browser--even though we
* actually read from a local file, too.  But because we are pretending
* that most of the images originate on the Internet, we follow the recom-
* mendation of the sRGB proposal and treat unlabelled images (no gAMA
* chunk) as existing in the sRGB color space.  That is, we assume that
* such images have a file gamma of 0.45455, which corresponds to a PC-like
* display system.  This change in assumptions will have no effect on a
* PC-like system, but on a Mac, SGI, NeXT or other system with a non-
* identity lookup table, it will darken unlabelled images, which effec-
* tively favors images from PC-like systems over those originating on
* the local platform.  Note that mainprog_ptr->display_exponent is the
* "gamma" value for the entire display system, i.e., the product of
* LUT_exponent and CRT_exponent. */

#ifdef PNG_FLOATING_POINT_SUPPORTED
if (png_get_gAMA(png_ptr, info_ptr, &gamma))
png_set_gamma(png_ptr, mainprog_ptr->display_exponent, gamma);
else
png_set_gamma(png_ptr, mainprog_ptr->display_exponent, 0.45455);
#else
if (png_get_gAMA_fixed(png_ptr, info_ptr, &gamma))
png_set_gamma_fixed(png_ptr,
(png_fixed_point)(100000*mainprog_ptr->display_exponent+.5), gamma);
else
png_set_gamma_fixed(png_ptr,
(png_fixed_point)(100000*mainprog_ptr->display_exponent+.5), 45455);
#endif

/* we'll let libpng expand interlaced images, too */

mainprog_ptr->passes = png_set_interlace_handling(png_ptr);


/* all transformations have been registered; now update info_ptr data and
* then get rowbytes and channels */

png_read_update_info(png_ptr, info_ptr);

mainprog_ptr->rowbytes = (int)png_get_rowbytes(png_ptr, info_ptr);
mainprog_ptr->channels = png_get_channels(png_ptr, info_ptr);


/* Call the main program to allocate memory for the image buffer and
* initialize windows and whatnot.  (The old-style function-pointer
* invocation is used for compatibility with a few supposedly ANSI
* compilers that nevertheless barf on "fn_ptr()"-style syntax.) */

(*mainprog_ptr->mainprog_init)();


/* and that takes care of initialization */

return;
}

transform_end(png_structp ppIn, png_infop pi)
{
   png_const_structp pp = ppIn;
   transform_display *dp = voidcast(transform_display*,
      png_get_progressive_ptr(pp));

 if (!dp->this.speed)
      transform_image_validate(dp, pp, pi);
 else
      dp->this.ps->validated = 1;
}

chromaticity_y(CIE_color c)
{
 return c.Y / (c.X + c.Y + c.Z);

 }

ilinear(int fixed_srgb)
{
 return u16d(65535 * sRGB_to_d[fixed_srgb]);
}

void png_warning(png_const_structrp png_ptr, png_const_charp msg)
{
   fprintf(stderr, "validation: %s\n", msg);
}

int readpng_init(FILE *infile, ulg *pWidth, ulg *pHeight)
{
 static uch ppmline[256];
 int maxval;


    saved_infile = infile;

    fgets(ppmline, 256, infile);
 if (ppmline[0] != 'P' || ppmline[1] != '6') {
        fprintf(stderr, "ERROR:  not a PPM file\n");
 return 1;
 }
 /* possible color types:  P5 = grayscale (0), P6 = RGB (2), P8 = RGBA (6) */
 if (ppmline[1] == '6') {
        color_type = 2;
        channels = 3;
 } else if (ppmline[1] == '8') {
        color_type = 6;
        channels = 4;
 } else /* if (ppmline[1] == '5') */ {
        color_type = 0;
        channels = 1;
 }

 do {
        fgets(ppmline, 256, infile);
 } while (ppmline[0] == '#');
    sscanf(ppmline, "%lu %lu", &width, &height);

 do {
        fgets(ppmline, 256, infile);
 } while (ppmline[0] == '#');
    sscanf(ppmline, "%d", &maxval);
 if (maxval != 255) {
        fprintf(stderr, "ERROR:  maxval = %d\n", maxval);
 return 2;
 }
    bit_depth = 8;

 *pWidth = width;
 *pHeight = height;

 return 0;
}

put_uLong(uLong val)
{
   putchar(val >> 24);
   putchar(val >> 16);
   putchar(val >> 8);
   putchar(val >> 0);
}

image_pixel_init(image_pixel *this, png_const_bytep row, png_byte colour_type,
    png_byte bit_depth, png_uint_32 x, store_palette palette)
{
   PNG_CONST png_byte sample_depth = (png_byte)(colour_type ==
PNG_COLOR_TYPE_PALETTE ? 8 : bit_depth);
   PNG_CONST unsigned int max = (1U<<sample_depth)-1;

/* Initially just set everything to the same number and the alpha to opaque.
* Note that this currently assumes a simple palette where entry x has colour
* rgb(x,x,x)!
*/
this->palette_index = this->red = this->green = this->blue =
      sample(row, colour_type, bit_depth, x, 0);
this->alpha = max;
this->red_sBIT = this->green_sBIT = this->blue_sBIT = this->alpha_sBIT =
sample_depth;

/* Then override as appropriate: */
if (colour_type == 3) /* palette */
{

/* This permits the caller to default to the sample value. */
if (palette != 0)
{
         PNG_CONST unsigned int i = this->palette_index;

this->red = palette[i].red;
this->green = palette[i].green;
this->blue = palette[i].blue;
this->alpha = palette[i].alpha;
}
}

else /* not palette */

{
unsigned int i = 0;

if (colour_type & 2)
{
         this->green = sample(row, colour_type, bit_depth, x, 1);
         this->blue = sample(row, colour_type, bit_depth, x, 2);
         i = 2;
}
      if (colour_type & 4)
         this->alpha = sample(row, colour_type, bit_depth, x, ++i);
}

/* Calculate the scaled values, these are simply the values divided by
* 'max' and the error is initialized to the double precision epsilon value
* from the header file.
*/
   image_pixel_setf(this, max);

/* Store the input information for use in the transforms - these will
* modify the information.
*/
this->colour_type = colour_type;

this->bit_depth = bit_depth;
this->sample_depth = sample_depth;
this->have_tRNS = 0;
}

png_have_neon(png_structp png_ptr)
{
 int fd = open("/proc/self/auxv", O_RDONLY);
 Elf32_auxv_t aux;

 /* Failsafe: failure to open means no NEON */
 if (fd == -1)
 {
      png_warning(png_ptr, "/proc/self/auxv open failed");
 return 0;
 }

 while (safe_read(png_ptr, fd, &aux, sizeof aux) == sizeof aux)
 {
 if (aux.a_type == AT_HWCAP && (aux.a_un.a_val & HWCAP_NEON) != 0)
 {
         close(fd);
 return 1;
 }
 }

   close(fd);
 return 0;
}

transform_image_validate(transform_display *dp, png_const_structp pp,

png_infop pi)
{
/* Constants for the loop below: */
   PNG_CONST png_store* PNG_CONST ps = dp->this.ps;
   PNG_CONST png_byte in_ct = dp->this.colour_type;
   PNG_CONST png_byte in_bd = dp->this.bit_depth;
   PNG_CONST png_uint_32 w = dp->this.w;
   PNG_CONST png_uint_32 h = dp->this.h;
   PNG_CONST png_byte out_ct = dp->output_colour_type;
   PNG_CONST png_byte out_bd = dp->output_bit_depth;
   PNG_CONST png_byte sample_depth = (png_byte)(out_ct ==
PNG_COLOR_TYPE_PALETTE ? 8 : out_bd);
   PNG_CONST png_byte red_sBIT = dp->this.red_sBIT;
   PNG_CONST png_byte green_sBIT = dp->this.green_sBIT;
   PNG_CONST png_byte blue_sBIT = dp->this.blue_sBIT;
   PNG_CONST png_byte alpha_sBIT = dp->this.alpha_sBIT;
   PNG_CONST int have_tRNS = dp->this.is_transparent;
double digitization_error;

store_palette out_palette;
png_uint_32 y;

UNUSED(pi)

/* Check for row overwrite errors */
store_image_check(dp->this.ps, pp, 0);

/* Read the palette corresponding to the output if the output colour type
* indicates a palette, othewise set out_palette to garbage.
*/
if (out_ct == PNG_COLOR_TYPE_PALETTE)
{
/* Validate that the palette count itself has not changed - this is not
* expected.
*/
int npalette = (-1);

(void)read_palette(out_palette, &npalette, pp, pi);
if (npalette != dp->this.npalette)
png_error(pp, "unexpected change in palette size");

digitization_error = .5;
}
else
{
png_byte in_sample_depth;

memset(out_palette, 0x5e, sizeof out_palette);

/* use-input-precision means assume that if the input has 8 bit (or less)
* samples and the output has 16 bit samples the calculations will be done
* with 8 bit precision, not 16.
*/
if (in_ct == PNG_COLOR_TYPE_PALETTE || in_bd < 16)
in_sample_depth = 8;
else
in_sample_depth = in_bd;

if (sample_depth != 16 || in_sample_depth > 8 ||
!dp->pm->calculations_use_input_precision)
digitization_error = .5;

/* Else calculations are at 8 bit precision, and the output actually
* consists of scaled 8-bit values, so scale .5 in 8 bits to the 16 bits:
*/
else
digitization_error = .5 * 257;
}


for (y=0; y<h; ++y)
{
      png_const_bytep PNG_CONST pRow = store_image_row(ps, pp, 0, y);
png_uint_32 x;

/* The original, standard, row pre-transforms. */
png_byte std[STANDARD_ROWMAX];

transform_row(pp, std, in_ct, in_bd, y);

/* Go through each original pixel transforming it and comparing with what
* libpng did to the same pixel.
*/
for (x=0; x<w; ++x)
{
image_pixel in_pixel, out_pixel;

unsigned int r, g, b, a;

/* Find out what we think the pixel should be: */
         image_pixel_init(&in_pixel, std, in_ct, in_bd, x, dp->this.palette);

in_pixel.red_sBIT = red_sBIT;
in_pixel.green_sBIT = green_sBIT;
in_pixel.blue_sBIT = blue_sBIT;
in_pixel.alpha_sBIT = alpha_sBIT;
         in_pixel.have_tRNS = have_tRNS;

/* For error detection, below. */
r = in_pixel.red;
g = in_pixel.green;

b = in_pixel.blue;
a = in_pixel.alpha;

dp->transform_list->mod(dp->transform_list, &in_pixel, pp, dp);

/* Read the output pixel and compare it to what we got, we don't
          * use the error field here, so no need to update sBIT.
*/
         image_pixel_init(&out_pixel, pRow, out_ct, out_bd, x, out_palette);

/* We don't expect changes to the index here even if the bit depth is
* changed.
*/
if (in_ct == PNG_COLOR_TYPE_PALETTE &&
out_ct == PNG_COLOR_TYPE_PALETTE)
{
if (in_pixel.palette_index != out_pixel.palette_index)
png_error(pp, "unexpected transformed palette index");
}

/* Check the colours for palette images too - in fact the palette could
* be separately verified itself in most cases.
*/
if (in_pixel.red != out_pixel.red)
transform_range_check(pp, r, g, b, a, in_pixel.red, in_pixel.redf,
out_pixel.red, sample_depth, in_pixel.rede,
dp->pm->limit + 1./(2*((1U<<in_pixel.red_sBIT)-1)), "red/gray",
digitization_error);

if ((out_ct & PNG_COLOR_MASK_COLOR) != 0 &&
in_pixel.green != out_pixel.green)
transform_range_check(pp, r, g, b, a, in_pixel.green,
in_pixel.greenf, out_pixel.green, sample_depth, in_pixel.greene,
dp->pm->limit + 1./(2*((1U<<in_pixel.green_sBIT)-1)), "green",
digitization_error);

if ((out_ct & PNG_COLOR_MASK_COLOR) != 0 &&
in_pixel.blue != out_pixel.blue)
transform_range_check(pp, r, g, b, a, in_pixel.blue, in_pixel.bluef,
out_pixel.blue, sample_depth, in_pixel.bluee,
dp->pm->limit + 1./(2*((1U<<in_pixel.blue_sBIT)-1)), "blue",
digitization_error);

if ((out_ct & PNG_COLOR_MASK_ALPHA) != 0 &&
in_pixel.alpha != out_pixel.alpha)
transform_range_check(pp, r, g, b, a, in_pixel.alpha,
in_pixel.alphaf, out_pixel.alpha, sample_depth, in_pixel.alphae,
dp->pm->limit + 1./(2*((1U<<in_pixel.alpha_sBIT)-1)), "alpha",
digitization_error);
} /* pixel (x) loop */
} /* row (y) loop */

/* Record that something was actually checked to avoid a false positive. */
dp->this.ps->validated = 1;
}

gpc_g8(Pixel *out, const Pixel *in, const Background *back)
{
 (void)back;

 if (in->r == in->g && in->g == in->b)
      out->r = out->g = out->b = in->g;

 else
      out->r = out->g = out->b =
         sRGB(YfromRGB(sRGB_to_d[in->r], sRGB_to_d[in->g], sRGB_to_d[in->b]));

   out->a = in->a;
}

closestinteger(double x)
{
 return floor(x + .5);
}

static double digitize(double value, int depth, int do_round)
{
/* 'value' is in the range 0 to 1, the result is the same value rounded to a
* multiple of the digitization factor - 8 or 16 bits depending on both the
* sample depth and the 'assume' setting.  Digitization is normally by

* rounding and 'do_round' should be 1, if it is 0 the digitized value will
* be truncated.
*/
   PNG_CONST unsigned int digitization_factor = (1U << depth) -1;

/* Limiting the range is done as a convenience to the caller - it's easier to
* do it once here than every time at the call site.
*/
if (value <= 0)
value = 0;

else if (value >= 1)
value = 1;

value *= digitization_factor;
if (do_round) value += .5;
return floor(value)/digitization_factor;
}

store_storefile(png_store *ps, png_uint_32 id)
{
   png_store_file *pf = voidcast(png_store_file*, malloc(sizeof *pf));
 if (pf == NULL)
      png_error(ps->pwrite, "storefile: OOM");
   safecat(pf->name, sizeof pf->name, 0, ps->wname);
   pf->id = id;
   pf->data = ps->new;
   pf->datacount = ps->writepos;
   ps->new.prev = NULL;
   ps->writepos = 0;
   pf->palette = ps->palette;
   pf->npalette = ps->npalette;
   ps->palette = 0;
   ps->npalette = 0;

 /* And save it. */
   pf->next = ps->saved;
   ps->saved = pf;
}

zlib_init(struct zlib *zlib, struct IDAT *idat, struct chunk *chunk,
int window_bits, png_uint_32 offset)
/* Initialize a zlib_control; the result is true/false */
{
CLEAR(*zlib);

zlib->idat = idat;
zlib->chunk = chunk;
zlib->file = chunk->file;
zlib->global = chunk->global;
zlib->rewrite_offset = offset; /* never changed for this zlib */

/* *_out does not need to be set: */
zlib->z.next_in = Z_NULL;
zlib->z.avail_in = 0;
zlib->z.zalloc = Z_NULL;
zlib->z.zfree = Z_NULL;
zlib->z.opaque = Z_NULL;

zlib->state = -1;
zlib->window_bits = window_bits;

zlib->compressed_digits = 0;
zlib->uncompressed_digits = 0;


/* These values are sticky across reset (in addition to the stuff in the
* first block, which is actually constant.)
*/
   zlib->file_bits = 16;
zlib->ok_bits = 16; /* unset */
zlib->cksum = 0; /* set when a checksum error is detected */

/* '0' means use the header; inflateInit2 should always succeed because it
* does nothing apart from allocating the internal zstate.
*/
zlib->rc = inflateInit2(&zlib->z, 0);
if (zlib->rc != Z_OK)
{
zlib_message(zlib, 1/*unexpected*/);
return 0;
}

else
{
zlib->state = 0; /* initialized */
return 1;
}
}

static void gamma_threshold_test(png_modifier *pm, png_byte colour_type,
    png_byte bit_depth, int interlace_type, double file_gamma,
 double screen_gamma)
{
 size_t pos = 0;
 char name[64];
   pos = safecat(name, sizeof name, pos, "threshold ");
   pos = safecatd(name, sizeof name, pos, file_gamma, 3);
   pos = safecat(name, sizeof name, pos, "/");
   pos = safecatd(name, sizeof name, pos, screen_gamma, 3);

 (void)gamma_test(pm, colour_type, bit_depth, 0/*palette*/, interlace_type,
      file_gamma, screen_gamma, 0/*sBIT*/, 1/*threshold test*/, name,
 0 /*no input precision*/,
 0 /*no scale16*/, 0 /*no expand16*/, 0 /*no background*/, 0 /*hence*/,
 0 /*no background gamma*/);
}

static void readpng2_error_handler(png_structp png_ptr, png_const_charp msg)
{
    mainprog_info  *mainprog_ptr;

 /* This function, aside from the extra step of retrieving the "error
     * pointer" (below) and the fact that it exists within the application
     * rather than within libpng, is essentially identical to libpng's
     * default error handler.  The second point is critical:  since both
     * setjmp() and longjmp() are called from the same code, they are
     * guaranteed to have compatible notions of how big a jmp_buf is,
     * regardless of whether _BSD_SOURCE or anything else has (or has not)
     * been defined. */

    fprintf(stderr, "readpng2 libpng error: %s\n", msg);
    fflush(stderr);

    mainprog_ptr = png_get_error_ptr(png_ptr);
 if (mainprog_ptr == NULL) { /* we are completely hosed now */
        fprintf(stderr,
 "readpng2 severe error:  jmpbuf not recoverable; terminating.\n");
        fflush(stderr);
        exit(99);
 }

 /* Now we have our data structure we can use the information in it
     * to return control to our own higher level code (all the points
     * where 'setjmp' is called in this file.)  This will work with other
     * error handling mechanisms as well - libpng always calls png_error
     * when it can proceed no further, thus, so long as the error handler
     * is intercepted, application code can do its own error recovery.
     */
    longjmp(mainprog_ptr->jmpbuf, 1);
}

newimage(Image *image)
{
   memset(image, 0, sizeof *image);
}

gp_ag8(Pixel *p, png_const_voidp pb)
{
   png_const_bytep pp = voidcast(png_const_bytep, pb);

   p->r = p->g = p->b = pp[1];
   p->a = pp[0];
}

gp_rgba16(Pixel *p, png_const_voidp pb)
{
   png_const_uint_16p pp = voidcast(png_const_uint_16p, pb);

   p->r = pp[0];
   p->g = pp[1];
   p->b = pp[2];
   p->a = pp[3];
}

store_verbose(png_store *ps, png_const_structp pp, png_const_charp prefix,
   png_const_charp message)
{
 char buffer[512];

 if (prefix)
      fputs(prefix, stderr);

 (void)store_message(ps, pp, buffer, sizeof buffer, 0, message);
   fputs(buffer, stderr);
   fputc('\n', stderr);
}

interlace_row(png_bytep buffer, png_const_bytep imageRow,
   unsigned int pixel_size, png_uint_32 w, int pass)
{
   png_uint_32 xin, xout, xstep;
   /* Note that this can, trivially, be optimized to a memcpy on pass 7, the
    * code is presented this way to make it easier to understand.  In practice
    * consult the code in the libpng source to see other ways of doing this.
    *
   xin = PNG_PASS_START_COL(pass);
   xstep = 1U<<PNG_PASS_COL_SHIFT(pass);
   for (xout=0; xin<w; xin+=xstep)
   {
      pixel_copy(buffer, xout, imageRow, xin, pixel_size);
      ++xout;
   }
}

image_transform_png_set_rgb_to_gray_add(image_transform *this,
    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)
{
UNUSED(bit_depth)

this->next = *that;
*that = this;

return (colour_type & PNG_COLOR_MASK_COLOR) != 0;
}

file_init(struct file *file, struct global *global, const char *file_name,
 const char *out_name, void *alloc_ptr, void (*alloc)(struct file*,int))
 /* Initialize a file control structure.  This will open the given files as
    * well.  The status code returned is 0 on success, non zero (using the flags
    * above) on a file open error.
    */
{
   CLEAR(*file);
   file->global = global;

   file->file_name = file_name;
   file->out_name = out_name;
   file->status_code = 0;
   file->read_errno = 0;
   file->write_errno = 0;

   file->file = NULL;
   file->out = NULL;
 /* jmpbuf is garbage: must be set by read_png */

   file->read_count = 0;
   file->state = STATE_SIGNATURE;

   file->chunk = NULL;
   file->idat = NULL;

   file->alloc_ptr = alloc_ptr;
   file->alloc = alloc;

 /* Open the files: */
   assert(file_name != NULL);
   file->file = fopen(file_name, "rb");

 if (file->file == NULL)
 {
      file->read_errno = errno;
      file->status_code |= FILE_ERROR;
 /* Always output: please give a readable file! */
      perror(file_name);
 return FILE_ERROR;
 }

 if (out_name != NULL)
 {
      file->out = fopen(out_name, "wb");

 if (file->out == NULL)
 {
         file->write_errno = errno;
         file->status_code |= WRITE_ERROR;
         perror(out_name);
 return WRITE_ERROR;
 }
 }

 return 0;
}

gp_rgba8(Pixel *p, png_const_voidp pb)
{
   png_const_bytep pp = voidcast(png_const_bytep, pb);

   p->r = pp[0];
   p->g = pp[1];
   p->b = pp[2];
   p->a = pp[3];
}

gpc_b16g(Pixel *out, const Pixel *in, const Background *back)
{
 if (in->a <= 0)
      out->r = out->g = out->b = back->ig;

 else
 {
 double a = in->a/65535.;
 double a1 = 1-a;

      a /= 65535;
      out->r = out->g = out->b = sRGB(in->g * a + back->dg * a1);
 }

   out->a = 255;
}

void get_token(FILE *pnm_file, char *token)
{
 int i = 0;
 int ret;

 /* remove white-space and comment lines */
 do
 {
    ret = fgetc(pnm_file);
 if (ret == '#') {
 /* the rest of this line is a comment */
 do
 {
        ret = fgetc(pnm_file);
 }
 while ((ret != '\n') && (ret != '\r') && (ret != EOF));
 }
 if (ret == EOF) break;
    token[i] = (unsigned char) ret;
 }
 while ((token[i] == '\n') || (token[i] == '\r') || (token[i] == ' '));

 /* read string */
 do
 {
    ret = fgetc(pnm_file);
 if (ret == EOF) break;
    i++;
    token[i] = (unsigned char) ret;
 }
 while ((token[i] != '\n') && (token[i] != '\r') && (token[i] != ' '));

  token[i] = '\0';

 return;
}

main(const int argc, const char * const * const argv)
{
 /* For each file on the command line test it with a range of transforms */
 int option_end, ilog = 0;
 struct display d;

   validate_T();
   display_init(&d);

 for (option_end=1; option_end<argc; ++option_end)
 {
 const char *name = argv[option_end];

 if (strcmp(name, "--verbose") == 0)
         d.options = (d.options & ~LEVEL_MASK) | VERBOSE;

 else if (strcmp(name, "--warnings") == 0)
         d.options = (d.options & ~LEVEL_MASK) | WARNINGS;

 else if (strcmp(name, "--errors") == 0)
         d.options = (d.options & ~LEVEL_MASK) | ERRORS;

 else if (strcmp(name, "--quiet") == 0)
         d.options = (d.options & ~LEVEL_MASK) | QUIET;

 else if (strcmp(name, "--exhaustive") == 0)
         d.options |= EXHAUSTIVE;

 else if (strcmp(name, "--fast") == 0)
         d.options &= ~EXHAUSTIVE;

 else if (strcmp(name, "--strict") == 0)
         d.options |= STRICT;

 else if (strcmp(name, "--relaxed") == 0)
         d.options &= ~STRICT;

 else if (strcmp(name, "--log") == 0)
 {
         ilog = option_end; /* prevent display */
         d.options |= LOG;
 }

 else if (strcmp(name, "--nolog") == 0)
         d.options &= ~LOG;

 else if (strcmp(name, "--continue") == 0)
         d.options |= CONTINUE;

 else if (strcmp(name, "--stop") == 0)
         d.options &= ~CONTINUE;

 else if (strcmp(name, "--skip-bugs") == 0)
         d.options |= SKIP_BUGS;

 else if (strcmp(name, "--test-all") == 0)
         d.options &= ~SKIP_BUGS;

 else if (strcmp(name, "--log-skipped") == 0)
         d.options |= LOG_SKIPPED;

 else if (strcmp(name, "--nolog-skipped") == 0)
         d.options &= ~LOG_SKIPPED;

 else if (strcmp(name, "--find-bad-combos") == 0)
         d.options |= FIND_BAD_COMBOS;


       else if (strcmp(name, "--nofind-bad-combos") == 0)
          d.options &= ~FIND_BAD_COMBOS;
 
       else if (name[0] == '-' && name[1] == '-')
       {
          fprintf(stderr, "pngimage: %s: unknown option\n", name);
 return 99;
 }

 else
 break; /* Not an option */
 }

 {
 int i;
 int errors = 0;

 for (i=option_end; i<argc; ++i)
 {
 {
 int ret = do_test(&d, argv[i]);

 if (ret > QUIET) /* abort on user or internal error */
 return 99;
 }

 /* Here on any return, including failures, except user/internal issues
          */
 {
 const int pass = (d.options & STRICT) ?
               RESULT_STRICT(d.results) : RESULT_RELAXED(d.results);

 if (!pass)
 ++errors;

 if (d.options & LOG)
 {
 int j;

               printf("%s: pngimage ", pass ? "PASS" : "FAIL");

 for (j=1; j<option_end; ++j) if (j != ilog)
                  printf("%s ", argv[j]);

               printf("%s\n", d.filename);
 }
 }


          display_clean(&d);
       }
 
       return errors != 0;
    }
 }

extract_one_file(const char *filename)
{
 int result = 0;
 FILE *fp = fopen(filename, "rb");

 if (fp != NULL)
 {
      png_uint_32 proflen = 0;
      png_bytep profile = extract(fp, &proflen);

 if (profile != NULL && profile != no_profile)
 {
 size_t len;
 char *output;

 {
 const char *ep = strrchr(filename, '.');

 if (ep != NULL)
               len = ep-filename;

 else
               len = strlen(filename);
 }

         output = malloc(len + 5);
 if (output != NULL)
 {
 FILE *of;

            memcpy(output, filename, len);
            strcpy(output+len, ".icc");

            of = fopen(output, "wb");
 if (of != NULL)
 {
 if (fwrite(profile, proflen, 1, of) == 1 &&
                  fflush(of) == 0 &&
                  fclose(of) == 0)
 {
 if (verbose)
                     printf("%s -> %s\n", filename, output);
 /* Success return */
                  result = 1;
 }

 else
 {
                  fprintf(stderr, "%s: error writing profile\n", output);
 if (remove(output))
                     fprintf(stderr, "%s: could not remove file\n", output);
 }
 }

 else
               fprintf(stderr, "%s: failed to open output file\n", output);

            free(output);
 }

 else
            fprintf(stderr, "%s: OOM allocating string!\n", filename);

         free(profile);
 }

 else if (verbose && profile == no_profile)
	printf("%s has no profile\n", filename);
 }

 else
      fprintf(stderr, "%s: could not open file\n", filename);

 return result;
}

static void rpng_x_cleanup(void)
{
 if (image_data) {
        free(image_data);
        image_data = NULL;
 }

 if (ximage) {
 if (ximage->data) {
            free(ximage->data); /* we allocated it, so we free it */
            ximage->data = (char *)NULL; /*  instead of XDestroyImage() */
 }
 XDestroyImage(ximage);
        ximage = NULL;
 }

 if (have_gc)
 XFreeGC(display, gc);

 if (have_window)
 XDestroyWindow(display, window);

 if (have_colormap)
 XFreeColormap(display, colormap);

 if (have_nondefault_visual)
 XFree(visual_list);
}

store_read_imp(png_store *ps, png_bytep pb, png_size_t st)
{
 if (ps->current == NULL || ps->next == NULL)
      png_error(ps->pread, "store state damaged");

 while (st > 0)
 {
 size_t cbAvail = store_read_buffer_size(ps) - ps->readpos;

 if (cbAvail > 0)
 {
 if (cbAvail > st) cbAvail = st;
         memcpy(pb, ps->next->buffer + ps->readpos, cbAvail);
         st -= cbAvail;
         pb += cbAvail;
         ps->readpos += cbAvail;
 }

 else if (!store_read_buffer_next(ps))
         png_error(ps->pread, "read beyond end of file");
 }
}

static void readpng2_warning_handler(png_structp png_ptr, png_const_charp msg)

 {
     fprintf(stderr, "readpng2 libpng warning: %s\n", msg);
     fflush(stderr);
 }

stop_invalid(struct file *file, const char *what)
{
   stop(file, INVALID_ERROR_CODE, what);
}

image_transform_png_set_strip_alpha_mod(PNG_CONST image_transform *this,
image_pixel *that, png_const_structp pp,
    PNG_CONST transform_display *display)
{
if (that->colour_type == PNG_COLOR_TYPE_GRAY_ALPHA)
that->colour_type = PNG_COLOR_TYPE_GRAY;
else if (that->colour_type == PNG_COLOR_TYPE_RGB_ALPHA)
that->colour_type = PNG_COLOR_TYPE_RGB;

that->have_tRNS = 0;
that->alphaf = 1;

this->next->mod(this->next, that, pp, display);
}

main(void)
{
   fprintf(stderr, "pngfix does not work without read support\n");
return 77;
}

gpc_Glin(Pixel *out, const Pixel *in, const Background *back)
{
 (void)back;

 if (in->r == in->g && in->g == in->b)
      out->r = out->g = out->b = ilinear_g22(in->g);

 else
      out->r = out->g = out->b = u16d(65535 *
 YfromRGB(g22_to_d[in->r], g22_to_d[in->g], g22_to_d[in->b]));

   out->a = 65535;
}

store_image_free(png_store *ps, png_const_structp pp)
{
 if (ps->image != NULL)
 {
      png_bytep image = ps->image;

 if (image[-1] != 0xed || image[ps->cb_image] != 0xfe)
 {
 if (pp != NULL)
            png_error(pp, "png_store image overwrite (1)");
 else
            store_log(ps, NULL, "png_store image overwrite (2)", 1);
 }

      ps->image = NULL;
      ps->cb_image = 0;
 --image;
      free(image);
 }
}

modifier_read(png_structp ppIn, png_bytep pb, png_size_t st)
{
   png_const_structp pp = ppIn;
   png_modifier *pm = voidcast(png_modifier*, png_get_io_ptr(pp));

 if (pm == NULL || pm->this.pread != pp)
      png_error(pp, "bad modifier_read call");

   modifier_read_imp(pm, pb, st);
}

png_pass_start_row(int pass)
{
 int x, y;
 ++pass;
 for (y=0; y<8; ++y) for (x=0; x<8; ++x) if (adam7[y][x] == pass)
 return y;
 return 0xf;
}

static size_t safecatd(char *buffer, size_t bufsize, size_t pos, double d,
 int precision)
{
 char number[64];
   sprintf(number, "%.*f", precision, d);
 return safecat(buffer, bufsize, pos, number);

 }

read_png(struct control *control)
/* Read a PNG, return 0 on success else an error (status) code; a bit mask as
* defined for file::status_code as above.
*/

{
png_structp png_ptr;
png_infop info_ptr = NULL;
   volatile png_bytep row = NULL, display = NULL;
volatile int rc;

png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, control,
error_handler, warning_handler);

if (png_ptr == NULL)
{
/* This is not really expected. */
log_error(&control->file, LIBPNG_ERROR_CODE, "OOM allocating png_struct");
control->file.status_code |= INTERNAL_ERROR;
return LIBPNG_ERROR_CODE;
}


rc = setjmp(control->file.jmpbuf);
if (rc == 0)
{
png_set_read_fn(png_ptr, control, read_callback);

info_ptr = png_create_info_struct(png_ptr);
if (info_ptr == NULL)
png_error(png_ptr, "OOM allocating info structure");

if (control->file.global->verbose)
fprintf(stderr, " INFO\n");


png_read_info(png_ptr, info_ptr);

{
         png_size_t rowbytes = png_get_rowbytes(png_ptr, info_ptr);

         row = png_voidcast(png_byte*, malloc(rowbytes));
         display = png_voidcast(png_byte*, malloc(rowbytes));

         if (row == NULL || display == NULL)
            png_error(png_ptr, "OOM allocating row buffers");

         {
            png_uint_32 height = png_get_image_height(png_ptr, info_ptr);
            int passes = png_set_interlace_handling(png_ptr);
            int pass;
            png_start_read_image(png_ptr);
            for (pass = 0; pass < passes; ++pass)
            {
               png_uint_32 y = height;
               /* NOTE: this trashes the row each time; interlace handling won't
                * work, but this avoids memory thrashing for speed testing.
                *
               while (y-- > 0)
                  png_read_row(png_ptr, row, display);
            }
         }
}

if (control->file.global->verbose)
fprintf(stderr, " END\n");

/* Make sure to read to the end of the file: */
png_read_end(png_ptr, info_ptr);

}

png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
   if (row != NULL) free(row);
   if (display != NULL) free(display);
return rc;
}

global_init(struct global *global)
 /* Call this once (and only once) to initialize the control */
{
   CLEAR(*global);

 /* Globals */
   global->errors        = 0;
   global->warnings      = 0;
   global->quiet         = 0;
   global->verbose       = 0;
   global->idat_max      = 0; /* no re-chunking of IDAT */
   global->optimize_zlib = 0;
   global->skip          = SKIP_NONE;
   global->status_code   = 0;

   IDAT_list_init(&global->idat_cache);
}

store_delete(png_store *ps)
{
   store_write_reset(ps);
   store_read_reset(ps);
   store_freefile(&ps->saved);
   store_image_free(ps, NULL);
}

gp_bgr8(Pixel *p, png_const_voidp pb)
{
   png_const_bytep pp = voidcast(png_const_bytep, pb);

   p->r = pp[2];
   p->g = pp[1];
   p->b = pp[0];
   p->a = 255;
}

calc_image_size(struct file *file)
 /* Fill in the image_bytes field given the IHDR information, calls stop on
    * error.
    */
{
   png_uint_16 pd = file->bit_depth;

 switch (file->color_type)
 {
 default:
         stop_invalid(file, "IHDR: colour type");

      invalid_bit_depth:
         stop_invalid(file, "IHDR: bit depth");

 case 0: /* g */
 if (pd != 1 && pd != 2 && pd != 4 && pd != 8 && pd != 16)
 goto invalid_bit_depth;
 break;

 case 3:
 if (pd != 1 && pd != 2 && pd != 4 && pd != 8)
 goto invalid_bit_depth;
 break;

 case 2: /* rgb */
 if (pd != 8 && pd != 16)
 goto invalid_bit_depth;

         pd = (png_uint_16)(pd * 3);
 break;

 case 4: /* ga */
 if (pd != 8 && pd != 16)
 goto invalid_bit_depth;

         pd = (png_uint_16)(pd * 2);
 break;

 case 6: /* rgba */
 if (pd != 8 && pd != 16)
 goto invalid_bit_depth;

         pd = (png_uint_16)(pd * 4);
 break;
 }

 if (file->width < 1 || file->width > 0x7fffffff)
      stop_invalid(file, "IHDR: width");

 else if (file->height < 1 || file->height > 0x7fffffff)
      stop_invalid(file, "IHDR: height");

 else if (file->compression_method != 0)
      stop_invalid(file, "IHDR: compression method");

 else if (file->filter_method != 0)
      stop_invalid(file, "IHDR: filter method");

 else switch (file->interlace_method)
 {
 case PNG_INTERLACE_ADAM7:
 /* Interlacing makes the image larger because of the replication of
          * both the filter byte and the padding to a byte boundary.
          */
 {
 int pass;
 int image_digits = 0;
            udigit row_width[2], row_bytes[3];

 for (pass=0; pass<=6; ++pass)
 {
               png_uint_32 pw = PNG_PASS_COLS(file->width, pass);

 if (pw > 0)
 {
 int  digits;

 /* calculate 1+((pw*pd+7)>>3) in row_bytes */
                  digits = uarb_mult_digit(row_bytes, uarb_set(row_bytes, 7),
                     row_width, uarb_set(row_width, pw), pd);
                  digits = uarb_shift(row_bytes, digits, 3);
                  digits = uarb_inc(row_bytes, digits, 1);

 /* Add row_bytes * pass-height to the file image_bytes field
                   */
                  image_digits = uarb_mult32(file->image_bytes, image_digits,
                     row_bytes, digits,
                     PNG_PASS_ROWS(file->height, pass));
 }
 }

            file->image_digits = image_digits;
 }
 break;

 case PNG_INTERLACE_NONE:
 {
 int  digits;
            udigit row_width[2], row_bytes[3];

 /* As above, but use image_width in place of the pass width: */
            digits = uarb_mult_digit(row_bytes, uarb_set(row_bytes, 7),
               row_width, uarb_set(row_width, file->width), pd);
            digits = uarb_shift(row_bytes, digits, 3);
            digits = uarb_inc(row_bytes, digits, 1);

 /* Set row_bytes * image-height to the file image_bytes field */
            file->image_digits = uarb_mult32(file->image_bytes, 0,
               row_bytes, digits, file->height);
 }
 break;

 default:
         stop_invalid(file, "IHDR: interlace method");
 }

   assert(file->image_digits >= 1 && file->image_digits <= 5);
 return 1;
}

store_error(png_structp ppIn, png_const_charp message) /* PNG_NORETURN */
{
   png_const_structp pp = ppIn;
   png_store *ps = voidcast(png_store*, png_get_error_ptr(pp));

 if (!ps->expect_error)
      store_log(ps, pp, message, 1 /* error */);

 /* And finally throw an exception. */
 {
 struct exception_context *the_exception_context = &ps->exception_context;
 Throw ps;
 }
}

check(FILE *fp, int argc, const char **argv, png_uint_32p flags/*out*/,
display *d, int set_callback)
{
int i, npasses, ipass;
png_uint_32 height;

d->keep = PNG_HANDLE_CHUNK_AS_DEFAULT;
d->before_IDAT = 0;
d->after_IDAT = 0;

/* Some of these errors are permanently fatal and cause an exit here, others
* are per-test and cause an error return.
*/
d->png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, d, error,
warning);
if (d->png_ptr == NULL)
{
fprintf(stderr, "%s(%s): could not allocate png struct\n", d->file,
d->test);
/* Terminate here, this error is not test specific. */
exit(1);
}

d->info_ptr = png_create_info_struct(d->png_ptr);
d->end_ptr = png_create_info_struct(d->png_ptr);
if (d->info_ptr == NULL || d->end_ptr == NULL)
{
fprintf(stderr, "%s(%s): could not allocate png info\n", d->file,
d->test);
clean_display(d);
exit(1);
}

png_init_io(d->png_ptr, fp);

#  ifdef PNG_READ_USER_CHUNKS_SUPPORTED
/* This is only done if requested by the caller; it interferes with the
* standard store/save mechanism.
*/
if (set_callback)
png_set_read_user_chunk_fn(d->png_ptr, d, read_callback);
#  else
UNUSED(set_callback)
#  endif

/* Handle each argument in turn; multiple settings are possible for the same
* chunk and multiple calls will occur (the last one should override all
* preceding ones).
*/
for (i=0; i<argc; ++i)
{
const char *equals = strchr(argv[i], '=');

if (equals != NULL)
{
int chunk, option;

if (strcmp(equals+1, "default") == 0)
option = PNG_HANDLE_CHUNK_AS_DEFAULT;
else if (strcmp(equals+1, "discard") == 0)
option = PNG_HANDLE_CHUNK_NEVER;
else if (strcmp(equals+1, "if-safe") == 0)
option = PNG_HANDLE_CHUNK_IF_SAFE;
else if (strcmp(equals+1, "save") == 0)
option = PNG_HANDLE_CHUNK_ALWAYS;
else
{
fprintf(stderr, "%s(%s): %s: unrecognized chunk option\n", d->file,
d->test, argv[i]);
display_exit(d);
}

switch (equals - argv[i])
{
case 4: /* chunk name */
chunk = find(argv[i]);

if (chunk >= 0)
{
/* These #if tests have the effect of skipping the arguments
* if SAVE support is unavailable - we can't do a useful test

* in this case, so we just check the arguments!  This could
* be improved in the future by using the read callback.
*/
                  png_byte name[5];

                  memcpy(name, chunk_info[chunk].name, 5);
                  png_set_keep_unknown_chunks(d->png_ptr, option, name, 1);
                  chunk_info[chunk].keep = option;
continue;
}

break;


case 7: /* default */
if (memcmp(argv[i], "default", 7) == 0)
{
                  png_set_keep_unknown_chunks(d->png_ptr, option, NULL, 0);
d->keep = option;
continue;
}

break;


case 3: /* all */
if (memcmp(argv[i], "all", 3) == 0)
{
                  png_set_keep_unknown_chunks(d->png_ptr, option, NULL, -1);
d->keep = option;

for (chunk = 0; chunk < NINFO; ++chunk)
if (chunk_info[chunk].all)
chunk_info[chunk].keep = option;
continue;
}

break;

default: /* some misplaced = */

break;
}
}

fprintf(stderr, "%s(%s): %s: unrecognized chunk argument\n", d->file,
d->test, argv[i]);
display_exit(d);
}

png_read_info(d->png_ptr, d->info_ptr);

switch (png_get_interlace_type(d->png_ptr, d->info_ptr))
{
case PNG_INTERLACE_NONE:
npasses = 1;
break;

case PNG_INTERLACE_ADAM7:
npasses = PNG_INTERLACE_ADAM7_PASSES;
break;

default:
/* Hard error because it is not test specific */
fprintf(stderr, "%s(%s): invalid interlace type\n", d->file, d->test);
clean_display(d);
exit(1);
}

/* Skip the image data, if IDAT is not being handled then don't do this
* because it will cause a CRC error.
*/
if (chunk_info[0/*IDAT*/].keep == PNG_HANDLE_CHUNK_AS_DEFAULT)
{
png_start_read_image(d->png_ptr);
height = png_get_image_height(d->png_ptr, d->info_ptr);

if (npasses > 1)
{
png_uint_32 width = png_get_image_width(d->png_ptr, d->info_ptr);

for (ipass=0; ipass<npasses; ++ipass)
{
png_uint_32 wPass = PNG_PASS_COLS(width, ipass);

if (wPass > 0)
{
png_uint_32 y;

for (y=0; y<height; ++y) if (PNG_ROW_IN_INTERLACE_PASS(y, ipass))
png_read_row(d->png_ptr, NULL, NULL);
}
}
} /* interlaced */

else /* not interlaced */
{
png_uint_32 y;

for (y=0; y<height; ++y)
png_read_row(d->png_ptr, NULL, NULL);
}
}

png_read_end(d->png_ptr, d->end_ptr);

flags[0] = get_valid(d, d->info_ptr);
flags[1] = get_unknown(d, d->info_ptr, 0/*before IDAT*/);

/* Only png_read_png sets PNG_INFO_IDAT! */
flags[chunk_info[0/*IDAT*/].keep != PNG_HANDLE_CHUNK_AS_DEFAULT] |=
PNG_INFO_IDAT;

flags[2] = get_valid(d, d->end_ptr);
flags[3] = get_unknown(d, d->end_ptr, 1/*after IDAT*/);

clean_display(d);

return d->keep;
}

image_transform_png_set_scale_16_set(PNG_CONST image_transform *this,
     transform_display *that, png_structp pp, png_infop pi)
 {
    png_set_scale_16(pp);
    this->next->set(this->next, that, pp, pi);
 }

BOOL png2pnm (FILE *png_file, FILE *pnm_file, FILE *alpha_file, BOOL raw, BOOL alpha)
{
png_struct    *png_ptr = NULL;
png_info        *info_ptr = NULL;
png_byte      buf[8];
png_byte      *png_pixels = NULL;
png_byte      **row_pointers = NULL;
png_byte      *pix_ptr = NULL;
png_uint_32   row_bytes;

png_uint_32   width;
png_uint_32   height;
int           bit_depth;
int           channels;
int           color_type;
int           alpha_present;
int           row, col;
int           ret;
int           i;
long          dep_16;

/* read and check signature in PNG file */
ret = fread (buf, 1, 8, png_file);
if (ret != 8)
return FALSE;

ret = png_sig_cmp (buf, 0, 8);
if (ret)
return FALSE;


/* create png and info structures */

  png_ptr = png_create_read_struct (PNG_LIBPNG_VER_STRING,
NULL, NULL, NULL);
if (!png_ptr)
return FALSE;   /* out of memory */

info_ptr = png_create_info_struct (png_ptr);
if (!info_ptr)
{
png_destroy_read_struct (&png_ptr, NULL, NULL);
return FALSE; /* out of memory */
}

if (setjmp (png_jmpbuf(png_ptr)))
{
png_destroy_read_struct (&png_ptr, &info_ptr, NULL);
return FALSE;
}

/* set up the input control for C streams */
png_init_io (png_ptr, png_file);
png_set_sig_bytes (png_ptr, 8); /* we already read the 8 signature bytes */

/* read the file information */
png_read_info (png_ptr, info_ptr);

/* get size and bit-depth of the PNG-image */
png_get_IHDR (png_ptr, info_ptr,
&width, &height, &bit_depth, &color_type,
NULL, NULL, NULL);

/* set-up the transformations */

/* transform paletted images into full-color rgb */
if (color_type == PNG_COLOR_TYPE_PALETTE)
png_set_expand (png_ptr);
/* expand images to bit-depth 8 (only applicable for grayscale images) */
if (color_type == PNG_COLOR_TYPE_GRAY && bit_depth < 8)
png_set_expand (png_ptr);
/* transform transparency maps into full alpha-channel */
if (png_get_valid (png_ptr, info_ptr, PNG_INFO_tRNS))

png_set_expand (png_ptr);

#ifdef NJET
  /* downgrade 16-bit images to 8 bit *
if (bit_depth == 16)
png_set_strip_16 (png_ptr);
/* transform grayscale images into full-color */
if (color_type == PNG_COLOR_TYPE_GRAY ||
color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
png_set_gray_to_rgb (png_ptr);
/* only if file has a file gamma, we do a correction */
if (png_get_gAMA (png_ptr, info_ptr, &file_gamma))
png_set_gamma (png_ptr, (double) 2.2, file_gamma);
#endif

/* all transformations have been registered; now update info_ptr data,
* get rowbytes and channels, and allocate image memory */

png_read_update_info (png_ptr, info_ptr);

/* get the new color-type and bit-depth (after expansion/stripping) */
png_get_IHDR (png_ptr, info_ptr, &width, &height, &bit_depth, &color_type,
NULL, NULL, NULL);

/* check for 16-bit files */
if (bit_depth == 16)
{
raw = FALSE;
#ifdef __TURBOC__
pnm_file->flags &= ~((unsigned) _F_BIN);
#endif
}

/* calculate new number of channels and store alpha-presence */
if (color_type == PNG_COLOR_TYPE_GRAY)
channels = 1;
else if (color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
channels = 2;
else if (color_type == PNG_COLOR_TYPE_RGB)
channels = 3;
else if (color_type == PNG_COLOR_TYPE_RGB_ALPHA)
channels = 4;
else
channels = 0; /* should never happen */
alpha_present = (channels - 1) % 2;

/* check if alpha is expected to be present in file */
if (alpha && !alpha_present)
{
fprintf (stderr, "PNG2PNM\n");
fprintf (stderr, "Error:  PNG-file doesn't contain alpha channel\n");
exit (1);
}


/* row_bytes is the width x number of channels x (bit-depth / 8) */
row_bytes = png_get_rowbytes (png_ptr, info_ptr);

  if ((png_pixels = (png_byte *) malloc (row_bytes * height * sizeof (png_byte))) == NULL) {
png_destroy_read_struct (&png_ptr, &info_ptr, NULL);
return FALSE;
}

  if ((row_pointers = (png_byte **) malloc (height * sizeof (png_bytep))) == NULL)
{
png_destroy_read_struct (&png_ptr, &info_ptr, NULL);
free (png_pixels);
png_pixels = NULL;
return FALSE;

}

/* set the individual row_pointers to point at the correct offsets */
  for (i = 0; i < (height); i++)
row_pointers[i] = png_pixels + i * row_bytes;

/* now we can go ahead and just read the whole image */
png_read_image (png_ptr, row_pointers);

/* read rest of file, and get additional chunks in info_ptr - REQUIRED */
png_read_end (png_ptr, info_ptr);

/* clean up after the read, and free any memory allocated - REQUIRED */
png_destroy_read_struct (&png_ptr, &info_ptr, (png_infopp) NULL);

/* write header of PNM file */

if ((color_type == PNG_COLOR_TYPE_GRAY) ||
(color_type == PNG_COLOR_TYPE_GRAY_ALPHA))
{
fprintf (pnm_file, "%s\n", (raw) ? "P5" : "P2");
fprintf (pnm_file, "%d %d\n", (int) width, (int) height);
fprintf (pnm_file, "%ld\n", ((1L << (int) bit_depth) - 1L));
}
else if ((color_type == PNG_COLOR_TYPE_RGB) ||
(color_type == PNG_COLOR_TYPE_RGB_ALPHA))
{
fprintf (pnm_file, "%s\n", (raw) ? "P6" : "P3");
fprintf (pnm_file, "%d %d\n", (int) width, (int) height);
fprintf (pnm_file, "%ld\n", ((1L << (int) bit_depth) - 1L));
}

/* write header of PGM file with alpha channel */

if ((alpha) &&
((color_type == PNG_COLOR_TYPE_GRAY_ALPHA) ||
(color_type == PNG_COLOR_TYPE_RGB_ALPHA)))
{
fprintf (alpha_file, "%s\n", (raw) ? "P5" : "P2");
fprintf (alpha_file, "%d %d\n", (int) width, (int) height);
fprintf (alpha_file, "%ld\n", ((1L << (int) bit_depth) - 1L));
}


/* write data to PNM file */
pix_ptr = png_pixels;

  for (row = 0; row < height; row++)
{
    for (col = 0; col < width; col++)
{
for (i = 0; i < (channels - alpha_present); i++)
{
if (raw)
fputc ((int) *pix_ptr++ , pnm_file);
else
if (bit_depth == 16){
dep_16 = (long) *pix_ptr++;
fprintf (pnm_file, "%ld ", (dep_16 << 8) + ((long) *pix_ptr++));
}
else
fprintf (pnm_file, "%ld ", (long) *pix_ptr++);
}
if (alpha_present)
{
if (!alpha)
{
pix_ptr++; /* alpha */
if (bit_depth == 16)
pix_ptr++;
}
else /* output alpha-channel as pgm file */
{
if (raw)
fputc ((int) *pix_ptr++ , alpha_file);
else
if (bit_depth == 16){
dep_16 = (long) *pix_ptr++;
fprintf (alpha_file, "%ld ", (dep_16 << 8) + (long) *pix_ptr++);
}
else
fprintf (alpha_file, "%ld ", (long) *pix_ptr++);
}
} /* if alpha_present */

if (!raw)
if (col % 4 == 3)
fprintf (pnm_file, "\n");
} /* end for col */

if (!raw)
if (col % 4 != 0)
fprintf (pnm_file, "\n");
} /* end for row */

if (row_pointers != (unsigned char**) NULL)
free (row_pointers);
if (png_pixels != (unsigned char*) NULL)
free (png_pixels);

return TRUE;

} /* end of source */

log_error(struct file *file, int code, const char *what)
 /* Like emit_error but checks the global 'errors' flag */
{
 if (file->global->errors)
      emit_error(file, code, what);
}

int writepng_init(mainprog_info *mainprog_ptr)
{
png_structp  png_ptr; /* note:  temporary variables! */
png_infop  info_ptr;
int color_type, interlace_type;



/* could also replace libpng warning-handler (final NULL), but no need: */

    png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, mainprog_ptr,
writepng_error_handler, NULL);
if (!png_ptr)
return 4;   /* out of memory */

info_ptr = png_create_info_struct(png_ptr);
if (!info_ptr) {
png_destroy_write_struct(&png_ptr, NULL);
return 4; /* out of memory */
}


/* setjmp() must be called in every function that calls a PNG-writing
* libpng function, unless an alternate error handler was installed--
* but compatible error handlers must either use longjmp() themselves
* (as in this program) or some other method to return control to
* application code, so here we go: */

if (setjmp(mainprog_ptr->jmpbuf)) {
png_destroy_write_struct(&png_ptr, &info_ptr);
return 2;
}


/* make sure outfile is (re)opened in BINARY mode */

png_init_io(png_ptr, mainprog_ptr->outfile);


/* set the compression levels--in general, always want to leave filtering
* turned on (except for palette images) and allow all of the filters,
* which is the default; want 32K zlib window, unless entire image buffer
* is 16K or smaller (unknown here)--also the default; usually want max
* compression (NOT the default); and remaining compression flags should
* be left alone */

png_set_compression_level(png_ptr, Z_BEST_COMPRESSION);
/*
>> this is default for no filtering; Z_FILTERED is default otherwise:
png_set_compression_strategy(png_ptr, Z_DEFAULT_STRATEGY);
>> these are all defaults:
png_set_compression_mem_level(png_ptr, 8);
png_set_compression_window_bits(png_ptr, 15);
png_set_compression_method(png_ptr, 8);
*/


/* set the image parameters appropriately */

if (mainprog_ptr->pnmtype == 5)
color_type = PNG_COLOR_TYPE_GRAY;
else if (mainprog_ptr->pnmtype == 6)
color_type = PNG_COLOR_TYPE_RGB;
else if (mainprog_ptr->pnmtype == 8)
color_type = PNG_COLOR_TYPE_RGB_ALPHA;
else {
png_destroy_write_struct(&png_ptr, &info_ptr);
return 11;
}

interlace_type = mainprog_ptr->interlaced? PNG_INTERLACE_ADAM7 :
PNG_INTERLACE_NONE;

png_set_IHDR(png_ptr, info_ptr, mainprog_ptr->width, mainprog_ptr->height,
mainprog_ptr->sample_depth, color_type, interlace_type,
PNG_COMPRESSION_TYPE_DEFAULT, PNG_FILTER_TYPE_DEFAULT);

if (mainprog_ptr->gamma > 0.0)
png_set_gAMA(png_ptr, info_ptr, mainprog_ptr->gamma);

if (mainprog_ptr->have_bg) { /* we know it's RGBA, not gray+alpha */
png_color_16  background;

background.red = mainprog_ptr->bg_red;
background.green = mainprog_ptr->bg_green;
background.blue = mainprog_ptr->bg_blue;
png_set_bKGD(png_ptr, info_ptr, &background);
}

if (mainprog_ptr->have_time) {
png_time  modtime;

png_convert_from_time_t(&modtime, mainprog_ptr->modtime);
png_set_tIME(png_ptr, info_ptr, &modtime);
}

if (mainprog_ptr->have_text) {
png_text  text[6];
int  num_text = 0;

if (mainprog_ptr->have_text & TEXT_TITLE) {
text[num_text].compression = PNG_TEXT_COMPRESSION_NONE;
text[num_text].key = "Title";
text[num_text].text = mainprog_ptr->title;
++num_text;
}
if (mainprog_ptr->have_text & TEXT_AUTHOR) {
text[num_text].compression = PNG_TEXT_COMPRESSION_NONE;
text[num_text].key = "Author";
text[num_text].text = mainprog_ptr->author;
++num_text;
}
if (mainprog_ptr->have_text & TEXT_DESC) {
text[num_text].compression = PNG_TEXT_COMPRESSION_NONE;
text[num_text].key = "Description";
text[num_text].text = mainprog_ptr->desc;
++num_text;
}
if (mainprog_ptr->have_text & TEXT_COPY) {
text[num_text].compression = PNG_TEXT_COMPRESSION_NONE;
text[num_text].key = "Copyright";
text[num_text].text = mainprog_ptr->copyright;
++num_text;
}
if (mainprog_ptr->have_text & TEXT_EMAIL) {
text[num_text].compression = PNG_TEXT_COMPRESSION_NONE;
text[num_text].key = "E-mail";
text[num_text].text = mainprog_ptr->email;
++num_text;
}
if (mainprog_ptr->have_text & TEXT_URL) {
text[num_text].compression = PNG_TEXT_COMPRESSION_NONE;
text[num_text].key = "URL";
text[num_text].text = mainprog_ptr->url;
++num_text;
}
png_set_text(png_ptr, info_ptr, text, num_text);
}


/* write all chunks up to (but not including) first IDAT */

png_write_info(png_ptr, info_ptr);


/* if we wanted to write any more text info *after* the image data, we
* would set up text struct(s) here and call png_set_text() again, with
* just the new data; png_set_tIME() could also go here, but it would
* have no effect since we already called it above (only one tIME chunk
* allowed) */


/* set up the transformations:  for now, just pack low-bit-depth pixels
* into bytes (one, two or four pixels per byte) */

png_set_packing(png_ptr);
/*  png_set_shift(png_ptr, &sig_bit);  to scale low-bit-depth values */


/* make sure we save our pointers for use in writepng_encode_image() */

mainprog_ptr->png_ptr = png_ptr;
mainprog_ptr->info_ptr = info_ptr;


/* OK, that's all we need to do for now; return happy */

return 0;
}

PNG_FUNCTION(voidpf /* PRIVATE */,
png_zalloc,(voidpf png_ptr, uInt items, uInt size),PNG_ALLOCATED)
{
 png_alloc_size_t num_bytes = size;

 if (png_ptr == NULL)
 return NULL;

 if (items >= (~(png_alloc_size_t)0)/size)
 {
      png_warning (png_voidcast(png_structrp, png_ptr),
 "Potential overflow in png_zalloc()");
 return NULL;
 }

   num_bytes *= items;
 return png_malloc_warn(png_voidcast(png_structrp, png_ptr), num_bytes);
}

png_row_from_pass_row(png_uint_32 yIn, int pass)
{
 /* By examination of the array: */
 switch (pass)
 {
case 0: return yIn * 8;
case 1: return yIn * 8;
case 2: return yIn * 8 + 4;
case 3: return yIn * 4;
case 4: return yIn * 4 + 2;
case 5: return yIn * 2;
case 6: return yIn * 2 + 1;
default: break;
 }

 return 0xff; /* bad pass number */
}

safecat_current_encoding(char *buffer, size_t bufsize, size_t pos,
   PNG_CONST png_modifier *pm)
{
pos = safecat_color_encoding(buffer, bufsize, pos, pm->current_encoding,
pm->current_gamma);

if (pm->encoding_ignored)
pos = safecat(buffer, bufsize, pos, "[overridden]");


return pos;
}

uch *readpng_get_image(double display_exponent, int *pChannels, ulg *pRowbytes)
{
 double  gamma;
    png_uint_32  i, rowbytes;
    png_bytepp  row_pointers = NULL;


 /* setjmp() must be called in every function that calls a PNG-reading
     * libpng function */

 if (setjmp(png_jmpbuf(png_ptr))) {
        free(image_data);
        image_data = NULL;
        free(row_pointers);
        row_pointers = NULL;
        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
 return NULL;
 }


 /* expand palette images to RGB, low-bit-depth grayscale images to 8 bits,
     * transparency chunks to full alpha channel; strip 16-bit-per-sample
     * images to 8 bits per sample; and convert grayscale to RGB[A] */

 if (color_type == PNG_COLOR_TYPE_PALETTE)
        png_set_expand(png_ptr);
 if (color_type == PNG_COLOR_TYPE_GRAY && bit_depth < 8)
        png_set_expand(png_ptr);
 if (png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS))
        png_set_expand(png_ptr);
#ifdef PNG_READ_16_TO_8_SUPPORTED
 if (bit_depth == 16)
#  ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED
        png_set_scale_16(png_ptr);
#  else
        png_set_strip_16(png_ptr);
#  endif
#endif
 if (color_type == PNG_COLOR_TYPE_GRAY ||
        color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
        png_set_gray_to_rgb(png_ptr);


 /* unlike the example in the libpng documentation, we have *no* idea where
     * this file may have come from--so if it doesn't have a file gamma, don't
     * do any correction ("do no harm") */

 if (png_get_gAMA(png_ptr, info_ptr, &gamma))
        png_set_gamma(png_ptr, display_exponent, gamma);


 /* all transformations have been registered; now update info_ptr data,
     * get rowbytes and channels, and allocate image memory */

    png_read_update_info(png_ptr, info_ptr);

 *pRowbytes = rowbytes = png_get_rowbytes(png_ptr, info_ptr);
 *pChannels = (int)png_get_channels(png_ptr, info_ptr);

 if ((image_data = (uch *)malloc(rowbytes*height)) == NULL) {
        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
 return NULL;
 }
 if ((row_pointers = (png_bytepp)malloc(height*sizeof(png_bytep))) == NULL) {
        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
        free(image_data);
        image_data = NULL;
 return NULL;
 }

 Trace((stderr, "readpng_get_image:  channels = %d, rowbytes = %ld, height = %ld\n",
 *pChannels, rowbytes, height));


 /* set the individual row_pointers to point at the correct offsets */

 for (i = 0;  i < height; ++i)
        row_pointers[i] = image_data + i*rowbytes;


 /* now we can go ahead and just read the whole image */

    png_read_image(png_ptr, row_pointers);


 /* and we're done!  (png_read_end() can be omitted if no processing of
     * post-IDAT text/time/etc. is desired) */

    free(row_pointers);
    row_pointers = NULL;

    png_read_end(png_ptr, NULL);

 return image_data;
}

is_combo(int transforms)
{
 return transforms & (transforms-1); /* non-zero if more than one set bit */
}

YfromRGBint(int ir, int ig, int ib)
{
 double r = ir;
 double g = ig;
 double b = ib;
 return YfromRGB(r, g, b);
}

static int rpng2_win_create_window()
{
    uch bg_red   = rpng2_info.bg_red;
    uch bg_green = rpng2_info.bg_green;
    uch bg_blue  = rpng2_info.bg_blue;
    uch *dest;
 int extra_width, extra_height;
    ulg i, j;
    WNDCLASSEX wndclass;
    RECT rect;


/*---------------------------------------------------------------------------
    Allocate memory for the display-specific version of the image (round up
    to multiple of 4 for Windows DIB).
  ---------------------------------------------------------------------------*/

    wimage_rowbytes = ((3*rpng2_info.width + 3L) >> 2) << 2;

 if (!(dib = (uch *)malloc(sizeof(BITMAPINFOHEADER) +
                              wimage_rowbytes*rpng2_info.height)))
 {
 return 4; /* fail */
 }

/*---------------------------------------------------------------------------
    Initialize the DIB.  Negative height means to use top-down BMP ordering
    (must be uncompressed, but that's what we want).  Bit count of 1, 4 or 8
    implies a colormap of RGBX quads, but 24-bit BMPs just use B,G,R values
    directly => wimage_data begins immediately after BMP header.
  ---------------------------------------------------------------------------*/

    memset(dib, 0, sizeof(BITMAPINFOHEADER));
    bmih = (BITMAPINFOHEADER *)dib;
    bmih->biSize = sizeof(BITMAPINFOHEADER);
    bmih->biWidth = rpng2_info.width;
    bmih->biHeight = -((long)rpng2_info.height);
    bmih->biPlanes = 1;
    bmih->biBitCount = 24;
    bmih->biCompression = 0;
    wimage_data = dib + sizeof(BITMAPINFOHEADER);

/*---------------------------------------------------------------------------
    Fill window with the specified background color (default is black), but
    defer loading faked "background image" until window is displayed (may be
    slow to compute).  Data are in BGR order.
  ---------------------------------------------------------------------------*/

 if (bg_image) { /* just fill with black for now */
        memset(wimage_data, 0, wimage_rowbytes*rpng2_info.height);
 } else {
 for (j = 0;  j < rpng2_info.height; ++j) {
            dest = wimage_data + j*wimage_rowbytes;
 for (i = rpng2_info.width;  i > 0; --i) {
 *dest++ = bg_blue;
 *dest++ = bg_green;
 *dest++ = bg_red;
 }
 }
 }

/*---------------------------------------------------------------------------
    Set the window parameters.
  ---------------------------------------------------------------------------*/

    memset(&wndclass, 0, sizeof(wndclass));

    wndclass.cbSize = sizeof(wndclass);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = rpng2_win_wndproc;
    wndclass.hInstance = global_hInst;
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)GetStockObject(DKGRAY_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = progname;
    wndclass.hIconSm = LoadIcon(NULL, IDI_APPLICATION);

 RegisterClassEx(&wndclass);

/*---------------------------------------------------------------------------
    Finally, create the window.
  ---------------------------------------------------------------------------*/

    extra_width  = 2*(GetSystemMetrics(SM_CXBORDER) +
 GetSystemMetrics(SM_CXDLGFRAME));
    extra_height = 2*(GetSystemMetrics(SM_CYBORDER) +
 GetSystemMetrics(SM_CYDLGFRAME)) +
 GetSystemMetrics(SM_CYCAPTION);

    global_hwnd = CreateWindow(progname, titlebar, WS_OVERLAPPEDWINDOW,
      CW_USEDEFAULT, CW_USEDEFAULT, rpng2_info.width+extra_width,
      rpng2_info.height+extra_height, NULL, NULL, global_hInst, NULL);

 ShowWindow(global_hwnd, global_showmode);
 UpdateWindow(global_hwnd);

/*---------------------------------------------------------------------------
    Now compute the background image and display it.  If it fails (memory
    allocation), revert to a plain background color.
  ---------------------------------------------------------------------------*/

 if (bg_image) {
 static const char *msg = "Computing background image...";
 int x, y, len = strlen(msg);
        HDC hdc = GetDC(global_hwnd);
        TEXTMETRIC tm;

 GetTextMetrics(hdc, &tm);
        x = (rpng2_info.width - len*tm.tmAveCharWidth)/2;
        y = (rpng2_info.height - tm.tmHeight)/2;
 SetBkMode(hdc, TRANSPARENT);
 SetTextColor(hdc, GetSysColor(COLOR_HIGHLIGHTTEXT));
 /* this can still begin out of bounds even if x is positive (???): */
 TextOut(hdc, ((x < 0)? 0 : x), ((y < 0)? 0 : y), msg, len);
 ReleaseDC(global_hwnd, hdc);

        rpng2_win_load_bg_image(); /* resets bg_image if fails */
 }

 if (!bg_image) {
 for (j = 0;  j < rpng2_info.height; ++j) {
            dest = wimage_data + j*wimage_rowbytes;
 for (i = rpng2_info.width;  i > 0; --i) {
 *dest++ = bg_blue;
 *dest++ = bg_green;
 *dest++ = bg_red;
 }
 }
 }

    rect.left = 0L;
    rect.top = 0L;
    rect.right = (LONG)rpng2_info.width; /* possibly off by one? */
    rect.bottom = (LONG)rpng2_info.height; /* possibly off by one? */
 InvalidateRect(global_hwnd, &rect, FALSE);
 UpdateWindow(global_hwnd); /* similar to XFlush() */

 return 0;

} /* end function rpng2_win_create_window() */

uch *readpng_get_image(double display_exponent, int *pChannels, ulg *pRowbytes)
{
ulg  rowbytes;


/* expand palette images to RGB, low-bit-depth grayscale images to 8 bits,
* transparency chunks to full alpha channel; strip 16-bit-per-sample
* images to 8 bits per sample; and convert grayscale to RGB[A] */

/* GRR WARNING:  grayscale needs to be expanded and channels reset! */

*pRowbytes = rowbytes = channels*width;
*pChannels = channels;

if ((image_data = (uch *)malloc(rowbytes*height)) == NULL) {
return NULL;
}

Trace((stderr, "readpng_get_image:  rowbytes = %ld, height = %ld\n", rowbytes, height));



/* now we can go ahead and just read the whole image */

    fread(image_data, 1L, rowbytes*height, saved_infile);

return image_data;
}

gpc_sGp(Pixel *out, const Pixel *in, const Background *back)
{
 (void)back;

 if (in->a <= 128)
 {
      out->r = out->g = out->b = 255;
      out->a = 0;
 }

 else
 {
      out->r = out->g = out->b = sRGB(YfromRGBint(in->r, in->g, in->b)/in->a);
      out->a = u8d(in->a / 257.);
 }
}

random_color(png_colorp color)
{
 static png_uint_32 color_seed[2] = { 0x12345678, 0x9abcdef };
   make_random_bytes(color_seed, color, sizeof *color);
}

gp_rgb8(Pixel *p, png_const_voidp pb)
{
   png_const_bytep pp = voidcast(png_const_bytep, pb);

   p->r = pp[0];
   p->g = pp[1];
   p->b = pp[2];
   p->a = 255;
}

allocbuffer(Image *image)
{
 png_size_t size = PNG_IMAGE_BUFFER_SIZE(image->image, image->stride);

 if (size+32 > image->bufsize)
 {
      freebuffer(image);
      image->buffer = voidcast(png_bytep, malloc(size+32));
 if (image->buffer == NULL)
 {
         fflush(stdout);
         fprintf(stderr,
 "simpletest: out of memory allocating %lu(+32) byte buffer\n",
 (unsigned long)size);
         exit(1);
 }
      image->bufsize = size+32;
 }

   memset(image->buffer, 95, image->bufsize);
   memset(image->buffer+16, BUFFER_INIT8, size);
   image->allocsize = size;
}

void readpng_cleanup(int free_image_data)
{
 if (free_image_data && image_data) {
        free(image_data);
        image_data = NULL;
 }

 if (png_ptr && info_ptr) {
        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
        png_ptr = NULL;
        info_ptr = NULL;
 }
}

chrm_modify(png_modifier *pm, png_modification *me, int add)
{
   UNUSED(add)
 /* As with gAMA this just adds the required cHRM chunk to the buffer. */
   png_save_uint_32(pm->buffer   , 32);
   png_save_uint_32(pm->buffer+ 4, CHUNK_cHRM);
   png_save_uint_32(pm->buffer+ 8, ((chrm_modification*)me)->wx);
   png_save_uint_32(pm->buffer+12, ((chrm_modification*)me)->wy);
   png_save_uint_32(pm->buffer+16, ((chrm_modification*)me)->rx);
   png_save_uint_32(pm->buffer+20, ((chrm_modification*)me)->ry);
   png_save_uint_32(pm->buffer+24, ((chrm_modification*)me)->gx);
   png_save_uint_32(pm->buffer+28, ((chrm_modification*)me)->gy);
   png_save_uint_32(pm->buffer+32, ((chrm_modification*)me)->bx);
   png_save_uint_32(pm->buffer+36, ((chrm_modification*)me)->by);
 return 1;
}

store_pool_delete(png_store *ps, store_pool *pool)
{
if (pool->list != NULL)
{
fprintf(stderr, "%s: %s %s: memory lost (list follows):\n", ps->test,
pool == &ps->read_memory_pool ? "read" : "write",
pool == &ps->read_memory_pool ? (ps->current != NULL ?
ps->current->name : "unknown file") : ps->wname);
++ps->nerrors;

do
{
store_memory *next = pool->list;
pool->list = next->next;

next->next = NULL;

fprintf(stderr, "\t%lu bytes @ %p\n",
             (unsigned long)next->size, (PNG_CONST void*)(next+1));
/* The NULL means this will always return, even if the memory is
* corrupted.
*/
store_memory_free(NULL, pool, next);
}
while (pool->list != NULL);
}

/* And reset the other fields too for the next time. */
if (pool->max > pool->max_max) pool->max_max = pool->max;
pool->max = 0;
if (pool->current != 0) /* unexpected internal error */
fprintf(stderr, "%s: %s %s: memory counter mismatch (internal error)\n",
ps->test, pool == &ps->read_memory_pool ? "read" : "write",
pool == &ps->read_memory_pool ? (ps->current != NULL ?
ps->current->name : "unknown file") : ps->wname);
pool->current = 0;

if (pool->limit > pool->max_limit)
pool->max_limit = pool->limit;

pool->limit = 0;

if (pool->total > pool->max_total)
pool->max_total = pool->total;

pool->total = 0;

/* Get a new mark too. */
store_pool_mark(pool->mark);
}

image_transform_png_set_rgb_to_gray_set(PNG_CONST image_transform *this,
transform_display *that, png_structp pp, png_infop pi)
{
   PNG_CONST int error_action = 1; /* no error, no defines in png.h *

#  ifdef PNG_FLOATING_POINT_SUPPORTED
png_set_rgb_to_gray(pp, error_action, data.red_to_set, data.green_to_set);
#  else
png_set_rgb_to_gray_fixed(pp, error_action, data.red_to_set,
data.green_to_set);
#  endif

#  ifdef PNG_READ_cHRM_SUPPORTED
if (that->pm->current_encoding != 0)
{
/* We have an encoding so a cHRM chunk may have been set; if so then
* check that the libpng APIs give the correct (X,Y,Z) values within
* some margin of error for the round trip through the chromaticity
* form.
*/
#        ifdef PNG_FLOATING_POINT_SUPPORTED
#           define API_function png_get_cHRM_XYZ
#           define API_form "FP"
#           define API_type double
#           define API_cvt(x) (x)
#        else
#           define API_function png_get_cHRM_XYZ_fixed
#           define API_form "fixed"
#           define API_type png_fixed_point
#           define API_cvt(x) ((double)(x)/PNG_FP_1)
#        endif

API_type rX, gX, bX;
API_type rY, gY, bY;
API_type rZ, gZ, bZ;

if ((API_function(pp, pi, &rX, &rY, &rZ, &gX, &gY, &gZ, &bX, &bY, &bZ)

& PNG_INFO_cHRM) != 0)
{
double maxe;
            PNG_CONST char *el;
color_encoding e, o;

/* Expect libpng to return a normalized result, but the original
* color space encoding may not be normalized.
*/
modifier_current_encoding(that->pm, &o);
normalize_color_encoding(&o);

/* Sanity check the pngvalid code - the coefficients should match
* the normalized Y values of the encoding unless they were
* overridden.
*/
if (data.red_to_set == -1 && data.green_to_set == -1 &&
(fabs(o.red.Y - data.red_coefficient) > DBL_EPSILON ||
fabs(o.green.Y - data.green_coefficient) > DBL_EPSILON ||
fabs(o.blue.Y - data.blue_coefficient) > DBL_EPSILON))
png_error(pp, "internal pngvalid cHRM coefficient error");

/* Generate a colour space encoding. */
e.gamma = o.gamma; /* not used */
e.red.X = API_cvt(rX);
e.red.Y = API_cvt(rY);
e.red.Z = API_cvt(rZ);
e.green.X = API_cvt(gX);
e.green.Y = API_cvt(gY);
e.green.Z = API_cvt(gZ);
e.blue.X = API_cvt(bX);
e.blue.Y = API_cvt(bY);
e.blue.Z = API_cvt(bZ);

/* This should match the original one from the png_modifier, within
* the range permitted by the libpng fixed point representation.
*/
maxe = 0;
el = "-"; /* Set to element name with error */

#           define CHECK(col,x)\
{\
double err = fabs(o.col.x - e.col.x);\
if (err > maxe)\
{\
maxe = err;\
el = #col "(" #x ")";\
}\
}

CHECK(red,X)
CHECK(red,Y)
CHECK(red,Z)
CHECK(green,X)
CHECK(green,Y)
CHECK(green,Z)
CHECK(blue,X)
CHECK(blue,Y)
CHECK(blue,Z)

/* Here in both fixed and floating cases to check the values read
* from the cHRm chunk.  PNG uses fixed point in the cHRM chunk, so
* we can't expect better than +/-.5E-5 on the result, allow 1E-5.
*/
if (maxe >= 1E-5)
{
size_t pos = 0;
char buffer[256];

pos = safecat(buffer, sizeof buffer, pos, API_form);
pos = safecat(buffer, sizeof buffer, pos, " cHRM ");
pos = safecat(buffer, sizeof buffer, pos, el);
pos = safecat(buffer, sizeof buffer, pos, " error: ");
pos = safecatd(buffer, sizeof buffer, pos, maxe, 7);
pos = safecat(buffer, sizeof buffer, pos, " ");
/* Print the color space without the gamma value: */
pos = safecat_color_encoding(buffer, sizeof buffer, pos, &o, 0);
pos = safecat(buffer, sizeof buffer, pos, " -> ");
pos = safecat_color_encoding(buffer, sizeof buffer, pos, &e, 0);

png_error(pp, buffer);
}
}
}
#  endif /* READ_cHRM */

this->next->set(this->next, that, pp, pi);

}

static png_byte png_exp8bit(png_uint_32 log)
{
 return (png_byte)floor(.5 + exp(log * -LN2) * 255);
}

void writepng_version_info(void)
{
  fprintf(stderr, "   Compiled with libpng %s; using libpng %s.\n",
    PNG_LIBPNG_VER_STRING, png_libpng_ver);
  fprintf(stderr, "   Compiled with zlib %s; using zlib %s.\n",
    ZLIB_VERSION, zlib_version);
}

static void rpng2_x_redisplay_image(ulg startcol, ulg startrow,
                                    ulg width, ulg height)
{
    uch bg_red   = rpng2_info.bg_red;
    uch bg_green = rpng2_info.bg_green;
    uch bg_blue  = rpng2_info.bg_blue;
    uch *src, *src2=NULL;
 char *dest;
    uch r, g, b, a;
    ulg i, row, lastrow = 0;
    ulg pixel;
 int ximage_rowbytes = ximage->bytes_per_line;


 Trace((stderr, "beginning display loop (image_channels == %d)\n",
      rpng2_info.channels))
 Trace((stderr, "   (width = %ld, rowbytes = %d, ximage_rowbytes = %d)\n",
      rpng2_info.width, rpng2_info.rowbytes, ximage_rowbytes))
 Trace((stderr, "   (bpp = %d)\n", ximage->bits_per_pixel))
 Trace((stderr, "   (byte_order = %s)\n", ximage->byte_order == MSBFirst?
 "MSBFirst" : (ximage->byte_order == LSBFirst? "LSBFirst" : "unknown")))

/*---------------------------------------------------------------------------
    Aside from the use of the rpng2_info struct and of src2 (for background
    image), this routine is identical to rpng_x_display_image() in the non-
    progressive version of the program--for the simple reason that redisplay
    of the image against a new background happens after the image is fully
    decoded and therefore is, by definition, non-progressive.
  ---------------------------------------------------------------------------*/

 if (depth == 24 || depth == 32) {
        ulg red, green, blue;
 int bpp = ximage->bits_per_pixel;

 for (lastrow = row = startrow;  row < startrow+height; ++row) {
            src = rpng2_info.image_data + row*rpng2_info.rowbytes;
 if (bg_image)
                src2 = bg_data + row*bg_rowbytes;
            dest = ximage->data + row*ximage_rowbytes;
 if (rpng2_info.channels == 3) {
 for (i = rpng2_info.width;  i > 0; --i) {
                    red   = *src++;
                    green = *src++;
                    blue  = *src++;
#ifdef NO_24BIT_MASKS
                    pixel = (red   << RShift) |
 (green << GShift) |
 (blue  << BShift);
 /* recall that we set ximage->byte_order = MSBFirst above */
 if (bpp == 32) {
 *dest++ = (char)((pixel >> 24) & 0xff);
 *dest++ = (char)((pixel >> 16) & 0xff);
 *dest++ = (char)((pixel >> 8) & 0xff);
 *dest++ = (char)( pixel        & 0xff);
 } else {
 /* this assumes bpp == 24 & bits are packed low */
 /* (probably need to use RShift, RMask, etc.) */
 *dest++ = (char)((pixel >> 16) & 0xff);
 *dest++ = (char)((pixel >> 8) & 0xff);
 *dest++ = (char)( pixel        & 0xff);
 }
#else
                    red   = (RShift < 0)? red   << (-RShift) : red   >> RShift;
                    green = (GShift < 0)? green << (-GShift) : green >> GShift;
                    blue  = (BShift < 0)? blue  << (-BShift) : blue  >> BShift;
                    pixel = (red & RMask) | (green & GMask) | (blue & BMask);
 /* recall that we set ximage->byte_order = MSBFirst above */
 if (bpp == 32) {
 *dest++ = (char)((pixel >> 24) & 0xff);
 *dest++ = (char)((pixel >> 16) & 0xff);
 *dest++ = (char)((pixel >> 8) & 0xff);
 *dest++ = (char)( pixel        & 0xff);
 } else {
 /* GRR BUG */
 /* this assumes bpp == 24 & bits are packed low */
 /* (probably need to use RShift/RMask/etc. here, too) */
 *dest++ = (char)((pixel >> 16) & 0xff);
 *dest++ = (char)((pixel >> 8) & 0xff);
 *dest++ = (char)( pixel        & 0xff);
 }
#endif
 }

 } else /* if (rpng2_info.channels == 4) */ {
 for (i = rpng2_info.width;  i > 0; --i) {
                    r = *src++;
                    g = *src++;
                    b = *src++;
                    a = *src++;
 if (bg_image) {
                        bg_red   = *src2++;
                        bg_green = *src2++;
                        bg_blue  = *src2++;
 }
 if (a == 255) {
                        red   = r;
                        green = g;
                        blue  = b;
 } else if (a == 0) {
                        red   = bg_red;
                        green = bg_green;
                        blue  = bg_blue;
 } else {
 /* this macro (from png.h) composites the foreground
                         * and background values and puts the result into the
                         * first argument */
                        alpha_composite(red,   r, a, bg_red);
                        alpha_composite(green, g, a, bg_green);
                        alpha_composite(blue,  b, a, bg_blue);
 }
#ifdef NO_24BIT_MASKS
                    pixel = (red   << RShift) |
 (green << GShift) |
 (blue  << BShift);
 /* recall that we set ximage->byte_order = MSBFirst above */
 if (bpp == 32) {
 *dest++ = (char)((pixel >> 24) & 0xff);
 *dest++ = (char)((pixel >> 16) & 0xff);
 *dest++ = (char)((pixel >> 8) & 0xff);
 *dest++ = (char)( pixel        & 0xff);
 } else {
 /* this assumes bpp == 24 & bits are packed low */
 /* (probably need to use RShift, RMask, etc.) */
 *dest++ = (char)((pixel >> 16) & 0xff);
 *dest++ = (char)((pixel >> 8) & 0xff);
 *dest++ = (char)( pixel        & 0xff);
 }
#else
                    red   = (RShift < 0)? red   << (-RShift) : red   >> RShift;
                    green = (GShift < 0)? green << (-GShift) : green >> GShift;
                    blue  = (BShift < 0)? blue  << (-BShift) : blue  >> BShift;
                    pixel = (red & RMask) | (green & GMask) | (blue & BMask);
 /* recall that we set ximage->byte_order = MSBFirst above */
 if (bpp == 32) {
 *dest++ = (char)((pixel >> 24) & 0xff);
 *dest++ = (char)((pixel >> 16) & 0xff);
 *dest++ = (char)((pixel >> 8) & 0xff);
 *dest++ = (char)( pixel        & 0xff);
 } else {
 /* GRR BUG */
 /* this assumes bpp == 24 & bits are packed low */
 /* (probably need to use RShift/RMask/etc. here, too) */
 *dest++ = (char)((pixel >> 16) & 0xff);
 *dest++ = (char)((pixel >> 8) & 0xff);
 *dest++ = (char)( pixel        & 0xff);
 }
#endif
 }
 }
 /* display after every 16 lines */
 if (((row+1) & 0xf) == 0) {
 XPutImage(display, window, gc, ximage, 0, (int)lastrow, 0,
 (int)lastrow, rpng2_info.width, 16);
 XFlush(display);
                lastrow = row + 1;
 }
 }

 } else if (depth == 16) {
        ush red, green, blue;

 for (lastrow = row = startrow;  row < startrow+height; ++row) {
            src = rpng2_info.row_pointers[row];
 if (bg_image)
                src2 = bg_data + row*bg_rowbytes;
            dest = ximage->data + row*ximage_rowbytes;
 if (rpng2_info.channels == 3) {
 for (i = rpng2_info.width;  i > 0; --i) {
                    red   = ((ush)(*src) << 8);
 ++src;
                    green = ((ush)(*src) << 8);
 ++src;
                    blue  = ((ush)(*src) << 8);
 ++src;
                    pixel = ((red   >> RShift) & RMask) |
 ((green >> GShift) & GMask) |
 ((blue  >> BShift) & BMask);
 /* recall that we set ximage->byte_order = MSBFirst above */
 *dest++ = (char)((pixel >> 8) & 0xff);
 *dest++ = (char)( pixel        & 0xff);
 }
 } else /* if (rpng2_info.channels == 4) */ {
 for (i = rpng2_info.width;  i > 0; --i) {
                    r = *src++;
                    g = *src++;
                    b = *src++;
                    a = *src++;
 if (bg_image) {
                        bg_red   = *src2++;
                        bg_green = *src2++;
                        bg_blue  = *src2++;
 }
 if (a == 255) {
                        red   = ((ush)r << 8);
                        green = ((ush)g << 8);
                        blue  = ((ush)b << 8);
 } else if (a == 0) {
                        red   = ((ush)bg_red   << 8);
                        green = ((ush)bg_green << 8);
                        blue  = ((ush)bg_blue  << 8);
 } else {
 /* this macro (from png.h) composites the foreground
                         * and background values and puts the result back into
                         * the first argument (== fg byte here:  safe) */
                        alpha_composite(r, r, a, bg_red);
                        alpha_composite(g, g, a, bg_green);
                        alpha_composite(b, b, a, bg_blue);
                        red   = ((ush)r << 8);
                        green = ((ush)g << 8);
                        blue  = ((ush)b << 8);
 }
                    pixel = ((red   >> RShift) & RMask) |
 ((green >> GShift) & GMask) |
 ((blue  >> BShift) & BMask);
 /* recall that we set ximage->byte_order = MSBFirst above */
 *dest++ = (char)((pixel >> 8) & 0xff);
 *dest++ = (char)( pixel        & 0xff);
 }
 }
 /* display after every 16 lines */
 if (((row+1) & 0xf) == 0) {
 XPutImage(display, window, gc, ximage, 0, (int)lastrow, 0,
 (int)lastrow, rpng2_info.width, 16);
 XFlush(display);
                lastrow = row + 1;
 }
 }

 } else /* depth == 8 */ {

 /* GRR:  add 8-bit support */

 }

 Trace((stderr, "calling final XPutImage()\n"))
 if (lastrow < startrow+height) {
 XPutImage(display, window, gc, ximage, 0, (int)lastrow, 0,
 (int)lastrow, rpng2_info.width, rpng2_info.height-lastrow);

         XFlush(display);
     }
 
 } /* end function rpng2_x_redisplay_image() */

sbit_modification_init(sbit_modification *me, png_modifier *pm, png_byte sbit)
{
   modification_init(&me->this);
   me->this.chunk = CHUNK_sBIT;
   me->this.modify_fn = sbit_modify;
   me->this.add = CHUNK_PLTE;
   me->sbit = sbit;
   me->this.next = pm->modifications;
   pm->modifications = &me->this;
}

sbit_modify(png_modifier *pm, png_modification *me, int add)
{
   png_byte sbit = ((sbit_modification*)me)->sbit;
 if (pm->bit_depth > sbit)
 {
 int cb = 0;
 switch (pm->colour_type)
 {
 case 0:
            cb = 1;
 break;

 case 2:
 case 3:
            cb = 3;
 break;

 case 4:
            cb = 2;
 break;

 case 6:
            cb = 4;
 break;

 default:
            png_error(pm->this.pread,
 "unexpected colour type in sBIT modification");
 }

      png_save_uint_32(pm->buffer, cb);
      png_save_uint_32(pm->buffer+4, CHUNK_sBIT);

 while (cb > 0)
 (pm->buffer+8)[--cb] = sbit;

 return 1;
 }
 else if (!add)
 {
 /* Remove the sBIT chunk */
      pm->buffer_count = pm->buffer_position = 0;
 return 1;
 }
 else
 return 0; /* do nothing */
}

static void perform_gamma_scale16_tests(png_modifier *pm)
{

#  ifndef PNG_MAX_GAMMA_8
#     define PNG_MAX_GAMMA_8 11
#  endif
#  define SBIT_16_TO_8 PNG_MAX_GAMMA_8
/* Include the alpha cases here. Note that sbit matches the internal value
* used by the library - otherwise we will get spurious errors from the
* internal sbit style approximation.
*
* The threshold test is here because otherwise the 16 to 8 conversion will
* proceed *without* gamma correction, and the tests above will fail (but not
* by much) - this could be fixed, it only appears with the -g option.
*/
unsigned int i, j;
for (i=0; i<pm->ngamma_tests; ++i)
{
for (j=0; j<pm->ngamma_tests; ++j)
{
if (i != j &&
fabs(pm->gammas[j]/pm->gammas[i]-1) >= PNG_GAMMA_THRESHOLD)
{
gamma_transform_test(pm, 0, 16, 0, pm->interlace_type,
1/pm->gammas[i], pm->gammas[j], SBIT_16_TO_8,
pm->use_input_precision_16to8, 1 /*scale16*/);

if (fail(pm))
return;

gamma_transform_test(pm, 2, 16, 0, pm->interlace_type,
1/pm->gammas[i], pm->gammas[j], SBIT_16_TO_8,
pm->use_input_precision_16to8, 1 /*scale16*/);

if (fail(pm))
return;

gamma_transform_test(pm, 4, 16, 0, pm->interlace_type,
1/pm->gammas[i], pm->gammas[j], SBIT_16_TO_8,
pm->use_input_precision_16to8, 1 /*scale16*/);

if (fail(pm))
return;

gamma_transform_test(pm, 6, 16, 0, pm->interlace_type,
1/pm->gammas[i], pm->gammas[j], SBIT_16_TO_8,
pm->use_input_precision_16to8, 1 /*scale16*/);

if (fail(pm))
return;
}
}
}
}

gp_ag16(Pixel *p, png_const_voidp pb)
{
   png_const_uint_16p pp = voidcast(png_const_uint_16p, pb);

   p->r = p->g = p->b = pp[1];
   p->a = pp[0];
}

int readpng_get_bgcolor(uch *red, uch *green, uch *blue)
{
    png_color_16p pBackground;


 /* setjmp() must be called in every function that calls a PNG-reading
     * libpng function */

 if (setjmp(png_jmpbuf(png_ptr))) {
        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
 return 2;
 }


 if (!png_get_valid(png_ptr, info_ptr, PNG_INFO_bKGD))
 return 1;

 /* it is not obvious from the libpng documentation, but this function
     * takes a pointer to a pointer, and it always returns valid red, green
     * and blue values, regardless of color_type: */

    png_get_bKGD(png_ptr, info_ptr, &pBackground);


 /* however, it always returns the raw bKGD data, regardless of any
     * bit-depth transformations, so check depth and adjust if necessary */

 if (bit_depth == 16) {
 *red   = pBackground->red   >> 8;
 *green = pBackground->green >> 8;
 *blue  = pBackground->blue  >> 8;
 } else if (color_type == PNG_COLOR_TYPE_GRAY && bit_depth < 8) {
 if (bit_depth == 1)
 *red = *green = *blue = pBackground->gray? 255 : 0;
 else if (bit_depth == 2)
 *red = *green = *blue = (255/3) * pBackground->gray;
 else /* bit_depth == 4 */
 *red = *green = *blue = (255/15) * pBackground->gray;
 } else {
 *red   = (uch)pBackground->red;
 *green = (uch)pBackground->green;
 *blue  = (uch)pBackground->blue;
 }

 return 0;
}

gamma_image_validate(gamma_display *dp, png_const_structp pp,

png_infop pi)
{
/* Get some constants derived from the input and output file formats: */
   PNG_CONST png_store* PNG_CONST ps = dp->this.ps;
   PNG_CONST png_byte in_ct = dp->this.colour_type;
   PNG_CONST png_byte in_bd = dp->this.bit_depth;
   PNG_CONST png_uint_32 w = dp->this.w;
   PNG_CONST png_uint_32 h = dp->this.h;
   PNG_CONST size_t cbRow = dp->this.cbRow;
   PNG_CONST png_byte out_ct = png_get_color_type(pp, pi);
   PNG_CONST png_byte out_bd = png_get_bit_depth(pp, pi);

/* There are three sources of error, firstly the quantization in the
* file encoding, determined by sbit and/or the file depth, secondly
* the output (screen) gamma and thirdly the output file encoding.
*
* Since this API receives the screen and file gamma in double
* precision it is possible to calculate an exact answer given an input
* pixel value.  Therefore we assume that the *input* value is exact -
* sample/maxsample - calculate the corresponding gamma corrected
* output to the limits of double precision arithmetic and compare with
* what libpng returns.
*
* Since the library must quantize the output to 8 or 16 bits there is
* a fundamental limit on the accuracy of the output of +/-.5 - this
* quantization limit is included in addition to the other limits
* specified by the paramaters to the API.  (Effectively, add .5
* everywhere.)
*
* The behavior of the 'sbit' paramter is defined by section 12.5
* (sample depth scaling) of the PNG spec.  That section forces the
* decoder to assume that the PNG values have been scaled if sBIT is
* present:
*
*     png-sample = floor( input-sample * (max-out/max-in) + .5);
*
* This means that only a subset of the possible PNG values should
* appear in the input. However, the spec allows the encoder to use a
* variety of approximations to the above and doesn't require any
* restriction of the values produced.
*
* Nevertheless the spec requires that the upper 'sBIT' bits of the
* value stored in a PNG file be the original sample bits.
* Consequently the code below simply scales the top sbit bits by
* (1<<sbit)-1 to obtain an original sample value.
*
* Because there is limited precision in the input it is arguable that
* an acceptable result is any valid result from input-.5 to input+.5.

* The basic tests below do not do this, however if 'use_input_precision'
* is set a subsequent test is performed above.
*/
   PNG_CONST unsigned int samples_per_pixel = (out_ct & 2U) ? 3U : 1U;
int processing;
png_uint_32 y;
   PNG_CONST store_palette_entry *in_palette = dp->this.palette;
   PNG_CONST int in_is_transparent = dp->this.is_transparent;
int out_npalette = -1;
int out_is_transparent = 0; /* Just refers to the palette case */
store_palette out_palette;
validate_info vi;

/* Check for row overwrite errors */
store_image_check(dp->this.ps, pp, 0);

/* Supply the input and output sample depths here - 8 for an indexed image,
* otherwise the bit depth.
*/
init_validate_info(&vi, dp, pp, in_ct==3?8:in_bd, out_ct==3?8:out_bd);


processing = (vi.gamma_correction > 0 && !dp->threshold_test)
|| in_bd != out_bd || in_ct != out_ct || vi.do_background;

/* TODO: FIX THIS: MAJOR BUG!  If the transformations all happen inside
* the palette there is no way of finding out, because libpng fails to
* update the palette on png_read_update_info.  Indeed, libpng doesn't
* even do the required work until much later, when it doesn't have any
* info pointer.  Oops.  For the moment 'processing' is turned off if
* out_ct is palette.
*/
if (in_ct == 3 && out_ct == 3)
processing = 0;

if (processing && out_ct == 3)
out_is_transparent = read_palette(out_palette, &out_npalette, pp, pi);

for (y=0; y<h; ++y)
{
png_const_bytep pRow = store_image_row(ps, pp, 0, y);
png_byte std[STANDARD_ROWMAX];

transform_row(pp, std, in_ct, in_bd, y);

if (processing)
{
unsigned int x;

for (x=0; x<w; ++x)
{

double alpha = 1; /* serves as a flag value */

/* Record the palette index for index images. */
            PNG_CONST unsigned int in_index =
               in_ct == 3 ? sample(std, 3, in_bd, x, 0) : 256;
            PNG_CONST unsigned int out_index =
               out_ct == 3 ? sample(std, 3, out_bd, x, 0) : 256;

/* Handle input alpha - png_set_background will cause the output
* alpha to disappear so there is nothing to check.
*/
            if ((in_ct & PNG_COLOR_MASK_ALPHA) != 0 || (in_ct == 3 &&
               in_is_transparent))
{
               PNG_CONST unsigned int input_alpha = in_ct == 3 ?
dp->this.palette[in_index].alpha :
                  sample(std, in_ct, in_bd, x, samples_per_pixel);

unsigned int output_alpha = 65536 /* as a flag value */;

if (out_ct == 3)
{
if (out_is_transparent)
output_alpha = out_palette[out_index].alpha;
}


else if ((out_ct & PNG_COLOR_MASK_ALPHA) != 0)
output_alpha = sample(pRow, out_ct, out_bd, x,
                     samples_per_pixel);

if (output_alpha != 65536)
alpha = gamma_component_validate("alpha", &vi, input_alpha,
output_alpha, -1/*alpha*/, 0/*background*/);

else /* no alpha in output */
{
/* This is a copy of the calculation of 'i' above in order to
* have the alpha value to use in the background calculation.
*/
alpha = input_alpha >> vi.isbit_shift;
alpha /= vi.sbit_max;

}
}

/* Handle grayscale or RGB components. */
if ((in_ct & PNG_COLOR_MASK_COLOR) == 0) /* grayscale */
(void)gamma_component_validate("gray", &vi,
                  sample(std, in_ct, in_bd, x, 0),
                  sample(pRow, out_ct, out_bd, x, 0), alpha/*component*/,
                  vi.background_red);
else /* RGB or palette */
{
(void)gamma_component_validate("red", &vi,
in_ct == 3 ? in_palette[in_index].red :
                     sample(std, in_ct, in_bd, x, 0),
out_ct == 3 ? out_palette[out_index].red :
                     sample(pRow, out_ct, out_bd, x, 0),
alpha/*component*/, vi.background_red);

(void)gamma_component_validate("green", &vi,
in_ct == 3 ? in_palette[in_index].green :
                     sample(std, in_ct, in_bd, x, 1),
out_ct == 3 ? out_palette[out_index].green :
                     sample(pRow, out_ct, out_bd, x, 1),
alpha/*component*/, vi.background_green);

(void)gamma_component_validate("blue", &vi,
in_ct == 3 ? in_palette[in_index].blue :
                     sample(std, in_ct, in_bd, x, 2),
out_ct == 3 ? out_palette[out_index].blue :
                     sample(pRow, out_ct, out_bd, x, 2),
alpha/*component*/, vi.background_blue);
}
}
}

else if (memcmp(std, pRow, cbRow) != 0)
{
char msg[64];

/* No transform is expected on the threshold tests. */
sprintf(msg, "gamma: below threshold row %lu changed",
(unsigned long)y);

png_error(pp, msg);
}
} /* row (y) loop */

dp->this.ps->validated = 1;
}

gamma_component_compose(int do_background, double input_sample, double alpha,
 double background, int *compose)
{
 switch (do_background)
 {
#ifdef PNG_READ_BACKGROUND_SUPPORTED
 case PNG_BACKGROUND_GAMMA_SCREEN:
 case PNG_BACKGROUND_GAMMA_FILE:
 case PNG_BACKGROUND_GAMMA_UNIQUE:
 /* Standard PNG background processing. */
 if (alpha < 1)
 {
 if (alpha > 0)
 {
               input_sample = input_sample * alpha + background * (1-alpha);
 if (compose != NULL)
 *compose = 1;
 }

 else
               input_sample = background;
 }
 break;
#endif

#ifdef PNG_READ_ALPHA_MODE_SUPPORTED
 case ALPHA_MODE_OFFSET + PNG_ALPHA_STANDARD:
 case ALPHA_MODE_OFFSET + PNG_ALPHA_BROKEN:
 /* The components are premultiplied in either case and the output is
          * gamma encoded (to get standard Porter-Duff we expect the output
          * gamma to be set to 1.0!)
          */
 case ALPHA_MODE_OFFSET + PNG_ALPHA_OPTIMIZED:
 /* The optimization is that the partial-alpha entries are linear
          * while the opaque pixels are gamma encoded, but this only affects the
          * output encoding.
          */
 if (alpha < 1)
 {
 if (alpha > 0)
 {
               input_sample *= alpha;
 if (compose != NULL)
 *compose = 1;
 }

 else
               input_sample = 0;
 }
 break;
#endif

 default:
 /* Standard cases where no compositing is done (so the component
          * value is already correct.)
          */
         UNUSED(alpha)
         UNUSED(background)
         UNUSED(compose)
 break;
 }

 return input_sample;
}

perform_error_test(png_modifier *pm)
{
#ifdef PNG_WARNINGS_SUPPORTED /* else there are no cases that work! */
 /* Need to do this here because we just write in this test. */
   safecat(pm->this.test, sizeof pm->this.test, 0, "error test");

 if (!make_errors(pm, 0, 0, WRITE_BDHI))
 return;

 if (!make_errors(pm, 2, 3, WRITE_BDHI))
 return;

 if (!make_errors(pm, 3, 0, 3))
 return;

 if (!make_errors(pm, 4, 3, WRITE_BDHI))
 return;

 if (!make_errors(pm, 6, 3, WRITE_BDHI))
 return;
#else
   UNUSED(pm)
#endif
}

make_transform_image(png_store* PNG_CONST ps, png_byte PNG_CONST colour_type,
    png_byte PNG_CONST bit_depth, unsigned int palette_number,
int interlace_type, png_const_charp name)
{
context(ps, fault);

check_interlace_type(interlace_type);

Try

{
png_infop pi;
png_structp pp = set_store_for_write(ps, &pi, name);
      png_uint_32 h;

/* In the event of a problem return control to the Catch statement below
* to do the clean up - it is not possible to 'return' directly from a Try
* block.
*/

if (pp == NULL)
Throw ps;

h = transform_height(pp, colour_type, bit_depth);

      png_set_IHDR(pp, pi, transform_width(pp, colour_type, bit_depth), h,
         bit_depth, colour_type, interlace_type,
PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);

#ifdef PNG_TEXT_SUPPORTED
#  if defined(PNG_READ_zTXt_SUPPORTED) && defined(PNG_WRITE_zTXt_SUPPORTED)
#     define TEXT_COMPRESSION PNG_TEXT_COMPRESSION_zTXt
#  else
#     define TEXT_COMPRESSION PNG_TEXT_COMPRESSION_NONE
#  endif
{
static char key[] = "image name"; /* must be writeable */
size_t pos;
png_text text;
char copy[FILE_NAME_SIZE];

/* Use a compressed text string to test the correct interaction of text
* compression and IDAT compression.
*/
text.compression = TEXT_COMPRESSION;
text.key = key;
/* Yuck: the text must be writable! */
pos = safecat(copy, sizeof copy, 0, ps->wname);
text.text = copy;
text.text_length = pos;
text.itxt_length = 0;
text.lang = 0;
text.lang_key = 0;

png_set_text(pp, pi, &text, 1);
}
#endif


if (colour_type == 3) /* palette */
init_standard_palette(ps, pp, pi, 1U << bit_depth, 1/*do tRNS*/);

png_write_info(pp, pi);

if (png_get_rowbytes(pp, pi) !=
transform_rowsize(pp, colour_type, bit_depth))
         png_error(pp, "row size incorrect");

else
{
/* Somewhat confusingly this must be called *after* png_write_info

* because if it is called before, the information in *pp has not been
* updated to reflect the interlaced image.
*/
         int npasses = png_set_interlace_handling(pp);
int pass;

if (npasses != npasses_from_interlace_type(pp, interlace_type))
png_error(pp, "write: png_set_interlace_handling failed");

for (pass=0; pass<npasses; ++pass)

{
png_uint_32 y;

for (y=0; y<h; ++y)
{
png_byte buffer[TRANSFORM_ROWMAX];

transform_row(pp, buffer, colour_type, bit_depth, y);
png_write_row(pp, buffer);
}
}
}

#ifdef PNG_TEXT_SUPPORTED
{
static char key[] = "end marker";
static char comment[] = "end";
png_text text;

/* Use a compressed text string to test the correct interaction of text
* compression and IDAT compression.
*/
text.compression = TEXT_COMPRESSION;
text.key = key;
text.text = comment;
text.text_length = (sizeof comment)-1;
text.itxt_length = 0;
text.lang = 0;
text.lang_key = 0;

png_set_text(pp, pi, &text, 1);
}
#endif

png_write_end(pp, pi);

/* And store this under the appropriate id, then clean up. */
store_storefile(ps, FILEID(colour_type, bit_depth, palette_number,
interlace_type, 0, 0, 0));

store_write_reset(ps);
}

Catch(fault)
{
/* Use the png_store returned by the exception. This may help the compiler
* because 'ps' is not used in this branch of the setjmp.  Note that fault
* and ps will always be the same value.
*/
store_write_reset(fault);
}

}

image_transform_png_set_gray_to_rgb_add(image_transform *this,
    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)
{
UNUSED(bit_depth)

this->next = *that;
*that = this;

return (colour_type & PNG_COLOR_MASK_COLOR) == 0;
}

buffer_read(struct display *dp, struct buffer *bp, png_bytep data,
 png_size_t size)
{
 struct buffer_list *last = bp->current;
 size_t read_count = bp->read_count;

 while (size > 0)
 {
 size_t avail;

 if (last == NULL ||
 (last == bp->last && read_count >= bp->end_count))
 {
         display_log(dp, USER_ERROR, "file truncated (%lu bytes)",
 (unsigned long)size);
 /*NOTREACHED*/
 break;
 }

 else if (read_count >= sizeof last->buffer)
 {
 /* Move to the next buffer: */
         last = last->next;
         read_count = 0;
         bp->current = last; /* Avoid update outside the loop */

 /* And do a sanity check (the EOF case is caught above) */
 if (last == NULL)
 {
            display_log(dp, INTERNAL_ERROR, "damaged buffer list");
 /*NOTREACHED*/
 break;
 }
 }

      avail = (sizeof last->buffer) - read_count;
 if (avail > size)
         avail = size;

      memcpy(data, last->buffer + read_count, avail);
      read_count += avail;
      size -= avail;
      data += avail;
 }

   bp->read_count = read_count;
}

test_size(png_modifier* PNG_CONST pm, png_byte PNG_CONST colour_type,
    int bdlo, int PNG_CONST bdhi)
{
/* Run the tests on each combination.
*
* NOTE: on my 32 bit x86 each of the following blocks takes
* a total of 3.5 seconds if done across every combo of bit depth

* width and height.  This is a waste of time in practice, hence the
* hinc and winc stuff:
*/
   static PNG_CONST png_byte hinc[] = {1, 3, 11, 1, 5};
   static PNG_CONST png_byte winc[] = {1, 9, 5, 7, 1};
for (; bdlo <= bdhi; ++bdlo)
{
png_uint_32 h, w;

for (h=1; h<=16; h+=hinc[bdlo]) for (w=1; w<=16; w+=winc[bdlo])
{
/* First test all the 'size' images against the sequential
* reader using libpng to deinterlace (where required.)  This
* validates the write side of libpng.  There are four possibilities
* to validate.
*/
standard_test(&pm->this, FILEID(colour_type, DEPTH(bdlo), 0/*palette*/,
PNG_INTERLACE_NONE, w, h, 0), 0/*do_interlace*/,
pm->use_update_info);

if (fail(pm))
return 0;

standard_test(&pm->this, FILEID(colour_type, DEPTH(bdlo), 0/*palette*/,
PNG_INTERLACE_NONE, w, h, 1), 0/*do_interlace*/,
pm->use_update_info);


if (fail(pm))
return 0;

#     ifdef PNG_WRITE_INTERLACING_SUPPORTED
         standard_test(&pm->this, FILEID(colour_type, DEPTH(bdlo), 0/*palette*/,
            PNG_INTERLACE_ADAM7, w, h, 0), 0/*do_interlace*/,
            pm->use_update_info);
         if (fail(pm))
            return 0;
         standard_test(&pm->this, FILEID(colour_type, DEPTH(bdlo), 0/*palette*/,
            PNG_INTERLACE_ADAM7, w, h, 1), 0/*do_interlace*/,
            pm->use_update_info);
         if (fail(pm))
            return 0;
#     endif
/* Now validate the interlaced read side - do_interlace true,
* in the progressive case this does actually make a difference
* to the code used in the non-interlaced case too.
*/
standard_test(&pm->this, FILEID(colour_type, DEPTH(bdlo), 0/*palette*/,
PNG_INTERLACE_NONE, w, h, 0), 1/*do_interlace*/,
pm->use_update_info);


if (fail(pm))
return 0;

#     ifdef PNG_WRITE_INTERLACING_SUPPORTED
standard_test(&pm->this, FILEID(colour_type, DEPTH(bdlo), 0/*palette*/,
PNG_INTERLACE_ADAM7, w, h, 0), 1/*do_interlace*/,
pm->use_update_info);


if (fail(pm))
return 0;
#     endif
}
}

return 1; /* keep going */
}

main(int argc, char **argv)
{
png_uint_32 opts = FAST_WRITE;
format_list formats;
const char *touch = NULL;
int log_pass = 0;
int redundant = 0;
int stride_extra = 0;
int retval = 0;
int c;

init_sRGB_to_d();
#if 0
init_error_via_linear();
#endif
format_init(&formats);

for (c=1; c<argc; ++c)
{
const char *arg = argv[c];

if (strcmp(arg, "--log") == 0)
log_pass = 1;
else if (strcmp(arg, "--fresh") == 0)
{
memset(gpc_error, 0, sizeof gpc_error);
memset(gpc_error_via_linear, 0, sizeof gpc_error_via_linear);
}
else if (strcmp(arg, "--file") == 0)
#        ifdef PNG_STDIO_SUPPORTED
opts |= READ_FILE;
#        else
return 77; /* skipped: no support */
#        endif
else if (strcmp(arg, "--memory") == 0)
opts &= ~READ_FILE;
else if (strcmp(arg, "--stdio") == 0)
#        ifdef PNG_STDIO_SUPPORTED
opts |= USE_STDIO;
#        else
return 77; /* skipped: no support */
#        endif
else if (strcmp(arg, "--name") == 0)
opts &= ~USE_STDIO;
else if (strcmp(arg, "--verbose") == 0)
opts |= VERBOSE;
else if (strcmp(arg, "--quiet") == 0)
opts &= ~VERBOSE;
else if (strcmp(arg, "--preserve") == 0)
opts |= KEEP_TMPFILES;
else if (strcmp(arg, "--nopreserve") == 0)
opts &= ~KEEP_TMPFILES;
else if (strcmp(arg, "--keep-going") == 0)
opts |= KEEP_GOING;
else if (strcmp(arg, "--fast") == 0)
opts |= FAST_WRITE;
else if (strcmp(arg, "--slow") == 0)
opts &= ~FAST_WRITE;
else if (strcmp(arg, "--accumulate") == 0)
opts |= ACCUMULATE;
else if (strcmp(arg, "--redundant") == 0)
redundant = 1;
else if (strcmp(arg, "--stop") == 0)
opts &= ~KEEP_GOING;
else if (strcmp(arg, "--strict") == 0)
opts |= STRICT;
else if (strcmp(arg, "--sRGB-16bit") == 0)
opts |= sRGB_16BIT;
else if (strcmp(arg, "--linear-16bit") == 0)
opts &= ~sRGB_16BIT;
else if (strcmp(arg, "--tmpfile") == 0)
{
if (c+1 < argc)
{
if (strlen(argv[++c]) >= sizeof tmpf)
{
fflush(stdout);
fprintf(stderr, "%s: %s is too long for a temp file prefix\n",
argv[0], argv[c]);
exit(99);

}

/* Safe: checked above */
            strcpy(tmpf, argv[c]);
}

else
{
fflush(stdout);
fprintf(stderr, "%s: %s requires a temporary file prefix\n",
argv[0], arg);
exit(99);
}
}
else if (strcmp(arg, "--touch") == 0)
{
if (c+1 < argc)
touch = argv[++c];

else
{
fflush(stdout);
fprintf(stderr, "%s: %s requires a file name argument\n",
argv[0], arg);
exit(99);
}
}
else if (arg[0] == '+')
{
png_uint_32 format = formatof(arg+1);

if (format > FORMAT_COUNT)
exit(99);

format_set(&formats, format);
}
else if (arg[0] == '-' && arg[1] != 0 && (arg[1] != '0' || arg[2] != 0))
{
fflush(stdout);
fprintf(stderr, "%s: unknown option: %s\n", argv[0], arg);
exit(99);
}
else
{
if (format_is_initial(&formats))
format_default(&formats, redundant);

if (arg[0] == '-')
{
const int term = (arg[1] == '0' ? 0 : '\n');
unsigned int ich = 0;

/* Loop reading files, use a static buffer to simplify this and just
* stop if the name gets to long.
*/
static char buffer[4096];

do
{
int ch = getchar();

/* Don't allow '\0' in file names, and terminate with '\n' or,
* for -0, just '\0' (use -print0 to find to make this work!)
*/
if (ch == EOF || ch == term || ch == 0)
{
buffer[ich] = 0;

if (ich > 0 && !test_one_file(buffer, &formats, opts,
stride_extra, log_pass))
retval = 1;

if (ch == EOF)
break;

ich = 0;
--ich; /* so that the increment below sets it to 0 again */
}

else
buffer[ich] = (char)ch;
} while (++ich < sizeof buffer);

if (ich)
{
buffer[32] = 0;
buffer[4095] = 0;
fprintf(stderr, "%s...%s: file name too long\n", buffer,
buffer+(4096-32));
exit(99);
}
}

else if (!test_one_file(arg, &formats, opts, stride_extra, log_pass))
retval = 1;
}
}

if (opts & ACCUMULATE)

{
unsigned int in;

printf("static png_uint_16 gpc_error[16/*in*/][16/*out*/][4/*a*/] =\n");
printf("{\n");
for (in=0; in<16; ++in)
{
unsigned int out;
printf(" { /* input: %s */\n ", format_names[in]);
for (out=0; out<16; ++out)
{
unsigned int alpha;
printf(" {");
for (alpha=0; alpha<4; ++alpha)
{
printf(" %d", gpc_error[in][out][alpha]);
if (alpha < 3) putchar(',');
}
printf(" }");
if (out < 15)
{
putchar(',');
if (out % 4 == 3) printf("\n ");
}
}
printf("\n }");

if (in < 15)
putchar(',');
else
putchar('\n');
}
printf("};\n");

printf("static png_uint_16 gpc_error_via_linear[16][4/*out*/][4] =\n");
printf("{\n");
for (in=0; in<16; ++in)
{
unsigned int out;
printf(" { /* input: %s */\n ", format_names[in]);
for (out=0; out<4; ++out)
{
unsigned int alpha;
printf(" {");
for (alpha=0; alpha<4; ++alpha)
{
printf(" %d", gpc_error_via_linear[in][out][alpha]);
if (alpha < 3) putchar(',');
}
printf(" }");
if (out < 3)
putchar(',');
}
printf("\n }");

if (in < 15)
putchar(',');
else
putchar('\n');
}
printf("};\n");

printf("static png_uint_16 gpc_error_to_colormap[8/*i*/][8/*o*/][4] =\n");
printf("{\n");
for (in=0; in<8; ++in)
{
unsigned int out;
printf(" { /* input: %s */\n ", format_names[in]);
for (out=0; out<8; ++out)
{
unsigned int alpha;
printf(" {");
for (alpha=0; alpha<4; ++alpha)
{
printf(" %d", gpc_error_to_colormap[in][out][alpha]);
if (alpha < 3) putchar(',');
}
printf(" }");
if (out < 7)
{
putchar(',');
if (out % 4 == 3) printf("\n ");
}
}
printf("\n }");

if (in < 7)
putchar(',');
else

putchar('\n');
}
printf("};\n");
}

if (retval == 0 && touch != NULL)
{
FILE *fsuccess = fopen(touch, "wt");

if (fsuccess != NULL)
{
int error = 0;
fprintf(fsuccess, "PNG simple API tests succeeded\n");
fflush(fsuccess);
error = ferror(fsuccess);

if (fclose(fsuccess) || error)
{
fflush(stdout);
fprintf(stderr, "%s: write failed\n", touch);
exit(99);
}
}

else
{
fflush(stdout);
fprintf(stderr, "%s: open failed\n", touch);
exit(99);
}
}

return retval;
}

main(int argc, const char **argv)
{
const char *  prog = *argv;
const char *  outfile = NULL;
const char *  suffix = NULL;
const char *  prefix = NULL;
int           done = 0; /* if at least one file is processed */
struct global global;

global_init(&global);

while (--argc > 0)
{
++argv;

if (strcmp(*argv, "--debug") == 0)
{
/* To help debugging problems: */
global.errors = global.warnings = 1;
global.quiet = 0;
global.verbose = 7;
}

else if (strncmp(*argv, "--max=", 6) == 0)
{
global.idat_max = (png_uint_32)atol(6+*argv);

if (global.skip < SKIP_UNSAFE)
global.skip = SKIP_UNSAFE;
}

else if (strcmp(*argv, "--max") == 0)
{
global.idat_max = 0x7fffffff;

if (global.skip < SKIP_UNSAFE)
global.skip = SKIP_UNSAFE;
}

else if (strcmp(*argv, "--optimize") == 0 || strcmp(*argv, "-o") == 0)
global.optimize_zlib = 1;

else if (strncmp(*argv, "--out=", 6) == 0)
outfile = 6+*argv;

else if (strncmp(*argv, "--suffix=", 9) == 0)
suffix = 9+*argv;

else if (strncmp(*argv, "--prefix=", 9) == 0)
prefix = 9+*argv;

else if (strcmp(*argv, "--strip=none") == 0)
global.skip = SKIP_NONE;

else if (strcmp(*argv, "--strip=crc") == 0)
global.skip = SKIP_BAD_CRC;

else if (strcmp(*argv, "--strip=unsafe") == 0)
global.skip = SKIP_UNSAFE;

else if (strcmp(*argv, "--strip=unused") == 0)
global.skip = SKIP_UNUSED;

else if (strcmp(*argv, "--strip=transform") == 0)
global.skip = SKIP_TRANSFORM;

else if (strcmp(*argv, "--strip=color") == 0)
global.skip = SKIP_COLOR;

else if (strcmp(*argv, "--strip=all") == 0)
global.skip = SKIP_ALL;

else if (strcmp(*argv, "--errors") == 0 || strcmp(*argv, "-e") == 0)
global.errors = 1;

else if (strcmp(*argv, "--warnings") == 0 || strcmp(*argv, "-w") == 0)
global.warnings = 1;

else if (strcmp(*argv, "--quiet") == 0 || strcmp(*argv, "-q") == 0)
{
if (global.quiet)
global.quiet = 2;

else
global.quiet = 1;
}

else if (strcmp(*argv, "--verbose") == 0 || strcmp(*argv, "-v") == 0)
++global.verbose;

#if 0
/* NYI */
#     ifdef PNG_MAXIMUM_INFLATE_WINDOW
else if (strcmp(*argv, "--test") == 0)
++set_option;
#     endif
#endif

else if ((*argv)[0] == '-')
usage(prog);


else
{
size_t outlen = strlen(*argv);
         char temp_name[FILENAME_MAX+1];

if (outfile == NULL) /* else this takes precedence */
{
/* Consider the prefix/suffix options */
if (prefix != NULL)
{
size_t prefixlen = strlen(prefix);

if (prefixlen+outlen > FILENAME_MAX)
{
fprintf(stderr, "%s: output file name too long: %s%s%s\n",
prog, prefix, *argv, suffix ? suffix : "");
global.status_code |= WRITE_ERROR;
continue;
}

memcpy(temp_name, prefix, prefixlen);
memcpy(temp_name+prefixlen, *argv, outlen);
outlen += prefixlen;
outfile = temp_name;
}

else if (suffix != NULL)
memcpy(temp_name, *argv, outlen);

temp_name[outlen] = 0;

if (suffix != NULL)
{
size_t suffixlen = strlen(suffix);

if (outlen+suffixlen > FILENAME_MAX)
{
fprintf(stderr, "%s: output file name too long: %s%s\n",
prog, *argv, suffix);
global.status_code |= WRITE_ERROR;
continue;
}

memcpy(temp_name+outlen, suffix, suffixlen);
outlen += suffixlen;
temp_name[outlen] = 0;
outfile = temp_name;
}
}

(void)one_file(&global, *argv, outfile);
++done;
outfile = NULL;
}
}

if (!done)
usage(prog);


return global_end(&global);
}

int main(void)
{
   fprintf(stderr,
 "pngvalid: no low level write support in libpng, all tests skipped\n");
 /* So the test is skipped: */
 return SKIP;
}

store_message(png_store *ps, png_const_structp pp, char *buffer, size_t bufsize,
   size_t pos, PNG_CONST char *msg)
{
if (pp != NULL && pp == ps->pread)
{
/* Reading a file */
pos = safecat(buffer, bufsize, pos, "read: ");

if (ps->current != NULL)
{
pos = safecat(buffer, bufsize, pos, ps->current->name);
pos = safecat(buffer, bufsize, pos, sep);
}
}

else if (pp != NULL && pp == ps->pwrite)
{
/* Writing a file */
pos = safecat(buffer, bufsize, pos, "write: ");
pos = safecat(buffer, bufsize, pos, ps->wname);
pos = safecat(buffer, bufsize, pos, sep);
}

else
{
/* Neither reading nor writing (or a memory error in struct delete) */
pos = safecat(buffer, bufsize, pos, "pngvalid: ");
}

if (ps->test[0] != 0)
{
pos = safecat(buffer, bufsize, pos, ps->test);
pos = safecat(buffer, bufsize, pos, sep);
}
pos = safecat(buffer, bufsize, pos, msg);
return pos;
}

read_one_file(Image *image)
{
if (!(image->opts & READ_FILE) || (image->opts & USE_STDIO))
{
/* memory or stdio. */
FILE *f = fopen(image->file_name, "rb");

if (f != NULL)
{
if (image->opts & READ_FILE)
image->input_file = f;

else /* memory */
{
if (fseek(f, 0, SEEK_END) == 0)

{
long int cb = ftell(f);

               if (cb > 0 && (unsigned long int)cb < (size_t)~(size_t)0)
{
                  png_bytep b = voidcast(png_bytep, malloc((size_t)cb));
                  if (b != NULL)
{
                     rewind(f);

                     if (fread(b, (size_t)cb, 1, f) == 1)
{
                        fclose(f);
                        image->input_memory_size = cb;
                        image->input_memory = b;
}

else
                     {
                        free(b);
return logclose(image, f, image->file_name,
                           ": read failed: ");
                     }
}

else
return logclose(image, f, image->file_name,
                        ": out of memory: ");
}

else if (cb == 0)
return logclose(image, f, image->file_name,
": zero length: ");

else
return logclose(image, f, image->file_name,
": tell failed: ");
}

else
return logclose(image, f, image->file_name, ": seek failed: ");
}
}

else
return logerror(image, image->file_name, ": open failed: ",
strerror(errno));
}

return read_file(image, FORMAT_NO_CHANGE, NULL);
}

print_opts(png_uint_32 opts)
{
 if (opts & READ_FILE)
      printf(" --file");
 if (opts & USE_STDIO)
      printf(" --stdio");
 if (opts & STRICT)
      printf(" --strict");
 if (opts & VERBOSE)
      printf(" --verbose");
 if (opts & KEEP_TMPFILES)
      printf(" --preserve");
 if (opts & KEEP_GOING)
      printf(" --keep-going");
 if (opts & ACCUMULATE)
      printf(" --accumulate");
 if (!(opts & FAST_WRITE)) /* --fast is currently the default */
      printf(" --slow");
 if (opts & sRGB_16BIT)
      printf(" --sRGB-16bit");
}

pixel_copy(png_bytep toBuffer, png_uint_32 toIndex,
   png_const_bytep fromBuffer, png_uint_32 fromIndex, unsigned int pixelSize)
{
/* Assume we can multiply by 'size' without overflow because we are
* just working in a single buffer.
*/
toIndex *= pixelSize;
fromIndex *= pixelSize;

if (pixelSize < 8) /* Sub-byte */
{
/* Mask to select the location of the copied pixel: */
      unsigned int destMask = ((1U<<pixelSize)-1) << (8-pixelSize-(toIndex&7));
/* The following read the entire pixels and clears the extra: */
unsigned int destByte = toBuffer[toIndex >> 3] & ~destMask;
unsigned int sourceByte = fromBuffer[fromIndex >> 3];

/* Don't rely on << or >> supporting '0' here, just in case: */
fromIndex &= 7;
      if (fromIndex > 0) sourceByte <<= fromIndex;
      if ((toIndex & 7) > 0) sourceByte >>= toIndex & 7;

toBuffer[toIndex >> 3] = (png_byte)(destByte | (sourceByte & destMask));
}
else /* One or more bytes */
memmove(toBuffer+(toIndex>>3), fromBuffer+(fromIndex>>3), pixelSize>>3);
}

store_malloc(png_structp ppIn, png_alloc_size_t cb)
{
   png_const_structp pp = ppIn;
   store_pool *pool = voidcast(store_pool*, png_get_mem_ptr(pp));
   store_memory *new = voidcast(store_memory*, malloc(cb + (sizeof *new) +
 (sizeof pool->mark)));

 if (new != NULL)
 {
 if (cb > pool->max)
         pool->max = cb;

      pool->current += cb;

 if (pool->current > pool->limit)
         pool->limit = pool->current;

      pool->total += cb;

 new->size = cb;
      memcpy(new->mark, pool->mark, sizeof new->mark);
      memcpy((png_byte*)(new+1) + cb, pool->mark, sizeof pool->mark);
 new->pool = pool;
 new->next = pool->list;
      pool->list = new;
 ++new;
 }

 else
 {
 /* NOTE: the PNG user malloc function cannot use the png_ptr it is passed
       * other than to retrieve the allocation pointer!  libpng calls the
       * store_malloc callback in two basic cases:
       *
       * 1) From png_malloc; png_malloc will do a png_error itself if NULL is
       *    returned.
       * 2) From png_struct or png_info structure creation; png_malloc is
       *    to return so cleanup can be performed.
       *
       * To handle this store_malloc can log a message, but can't do anything
       * else.
       */
      store_log(pool->store, pp, "out of memory", 1 /* is_error */);
 }

 return new;
}

image_transform_png_set_expand_16_set(PNG_CONST image_transform *this,
     transform_display *that, png_structp pp, png_infop pi)
 {
    png_set_expand_16(pp);
    this->next->set(this->next, that, pp, pi);
 }

static int rpng_x_msb(ulg u32val)
{
 int i;

 for (i = 31;  i >= 0; --i) {
 if (u32val & 0x80000000L)
 break;
        u32val <<= 1;
 }
 return i;
}

image_transform_png_set_expand_mod(PNG_CONST image_transform *this,
image_pixel *that, png_const_structp pp,
    PNG_CONST transform_display *display)
{
/* The general expand case depends on what the colour type is: */
if (that->colour_type == PNG_COLOR_TYPE_PALETTE)
image_pixel_convert_PLTE(that);
else if (that->bit_depth < 8) /* grayscale */

that->sample_depth = that->bit_depth = 8;

if (that->have_tRNS)
      image_pixel_add_alpha(that, &display->this);

this->next->mod(this->next, that, pp, display);
}

static png_uint_16 png_exp16bit(png_uint_32 log)
{
 return (png_uint_16)floor(.5 + exp(log * -LN2) * 65535);
}

get32(png_bytep buffer, int offset)
 /* Read a 32-bit value from an 8-byte circular buffer (used only below).
    */
{
 return
 (buffer[ offset    & 7] << 24) +
 (buffer[(offset+1) & 7] << 16) +
 (buffer[(offset+2) & 7] << 8) +
 (buffer[(offset+3) & 7] );
}

make_transform_images(png_store *ps)
{
png_byte colour_type = 0;
png_byte bit_depth = 0;
unsigned int palette_number = 0;

/* This is in case of errors. */
   safecat(ps->test, sizeof ps->test, 0, "make standard images");

/* Use next_format to enumerate all the combinations we test, including
    * generating multiple low bit depth palette images.
*/
   while (next_format(&colour_type, &bit_depth, &palette_number, 0))
{
int interlace_type;

for (interlace_type = PNG_INTERLACE_NONE;
interlace_type < INTERLACE_LAST; ++interlace_type)
{

char name[FILE_NAME_SIZE];

standard_name(name, sizeof name, 0, colour_type, bit_depth,
            palette_number, interlace_type, 0, 0, 0);
         make_transform_image(ps, colour_type, bit_depth, palette_number,
interlace_type, name);
}
}
}

process_IDAT(struct file *file)
 /* Process the IDAT stream, this is the more complex than the preceding
    * cases because the compressed data is spread across multiple IDAT chunks
    * (typically).  Rechunking of the data is not handled here; all this
    * function does is establish whether the zlib header needs to be modified.
    *
    * Initially the function returns false, indicating that the chunk should not
    * be written.  It does this until the last IDAT chunk is passed in, then it
    * checks the zlib data and returns true.
    *
    * It does not return false on a fatal error; it calls stop instead.
    *
    * The caller must have an instantiated (IDAT) control structure and it must
    * have extent over the whole read of the IDAT stream.  For a PNG this means
    * the whole PNG read, for MNG it could have lesser extent.
    */
{
 struct IDAT_list *list;

   assert(file->idat != NULL && file->chunk != NULL);

 /* We need to first check the entire sequence of IDAT chunks to ensure the
    * stream is in sync.  Do this by building a list of all the chunks and
    * recording the length of each because the length may have been fixed up by
    * sync_stream below.
    *
    * At the end of the list of chunks, where the type of the next chunk is not
    * png_IDAT, process the whole stream using the list data to check validity
    * then return control to the start and rewrite everything.
    */
 list = file->idat->idat_list_tail;

 if (list->count == list->length)
 {
 list = IDAT_list_extend(list);

 if (list == NULL)
         stop(file, READ_ERROR_CODE, "out of memory");

 /* Move to the next block */

       list->count = 0;
       file->idat->idat_list_tail = list;
    }
    /* And fill in the next IDAT information buffer. */
    list->lengths[(list->count)++] = file->chunk->chunk_length;
 
 /* The type of the next chunk was recorded in the file control structure by
    * the caller, if this is png_IDAT return 'skip' to the caller.
    */
 if (file->type == png_IDAT)
 return 0; /* skip this for the moment */

 /* This is the final IDAT chunk, so run the tests to check for the too far
    * back error and possibly optimize the window bits.  This means going back
    * to the start of the first chunk data, which is stored in the original
    * chunk allocation.
    */
   setpos(file->chunk);

 if (zlib_check(file, 0))
 {
 struct IDAT *idat;
 int cmp;

 /* The IDAT stream was successfully uncompressed; see whether it
       * contained the correct number of bytes of image data.
       */
      cmp = uarb_cmp(file->image_bytes, file->image_digits,
         file->chunk->uncompressed_bytes, file->chunk->uncompressed_digits);

 if (cmp < 0)
         type_message(file, png_IDAT, "extra uncompressed data");

 else if (cmp > 0)
         stop(file, LIBPNG_ERROR_CODE, "IDAT: uncompressed data too small");

 /* Return the stream to the start of the first IDAT chunk; the length
       * is set in the write case below but the input chunk variables must be
       * set (once) here:
       */
      setpos(file->chunk);

      idat = file->idat;
      idat->idat_cur = idat->idat_list_head;
      idat->idat_length = idat->idat_cur->lengths[0];
      idat->idat_count = 0; /* Count of chunks read in current list */
      idat->idat_index = 0; /* Index into chunk data */

 /* Update the chunk length to the correct value for the IDAT chunk: */
      file->chunk->chunk_length = rechunk_length(idat);

 /* Change the state to writing IDAT chunks */
      file->state = STATE_IDAT;

 return 1;
 }

 else /* Failure to decompress the IDAT stream; give up. */
      stop(file, ZLIB_ERROR_CODE, "could not uncompress IDAT");
}

modification_reset(png_modification *pmm)
{
 if (pmm != NULL)
 {
      pmm->modified = 0;
      pmm->added = 0;
      pmm->removed = 0;
      modification_reset(pmm->next);
 }
}

modifier_color_encoding_is_set(PNG_CONST png_modifier *pm)
 {
    return pm->current_gamma != 0;
 }

PNG_FUNCTION(void, display_exit, (display *d), static PNG_NORETURN)
{
 ++(d->error_count);

 if (d->png_ptr != NULL)
      clean_display(d);

 /* During initialization and if this is a single command line argument set
    * exit now - there is only one test, otherwise longjmp to do the next test.
    */
 if (d->test == init || d->test == cmd)
      exit(1);

   longjmp(d->error_return, 1);
}

modifier_reset(png_modifier *pm)
{
   store_read_reset(&pm->this);
   pm->limit = 4E-3;
   pm->pending_len = pm->pending_chunk = 0;
   pm->flush = pm->buffer_count = pm->buffer_position = 0;
   pm->modifications = NULL;
   pm->state = modifier_start;
   modifier_encoding_iterate(pm);
 /* The following must be set in the next run.  In particular
    * test_uses_encodings must be set in the _ini function of each transform
    * that looks at the encodings.  (Not the 'add' function!)
    */
   pm->test_uses_encoding = 0;
   pm->current_gamma = 0;
   pm->current_encoding = 0;
   pm->encoding_ignored = 0;
 /* These only become value after IHDR is read: */
   pm->bit_depth = pm->colour_type = 0;
}

gpc_Preq(Pixel *out, const Pixel *in, const Background *back)
{
 (void)back;

   out->r = ilineara_g22(in->r, in->a);

 if (in->g == in->r)
 {
      out->g = out->r;

 if (in->b == in->r)
         out->b = out->r;

 else
         out->b = ilineara_g22(in->b, in->a);
 }

 else
 {
      out->g = ilineara_g22(in->g, in->a);

 if (in->b == in->r)
         out->b = out->r;

 else if (in->b == in->g)
         out->b = out->g;

 else
         out->b = ilineara_g22(in->b, in->a);
 }

   out->a = 65535;
}

static int rpng_x_display_image(void)
{
    uch *src;
 char *dest;
    uch r, g, b, a;
    ulg i, row, lastrow = 0;
    ulg pixel;
 int ximage_rowbytes = ximage->bytes_per_line;
/*  int bpp = ximage->bits_per_pixel;  */


 Trace((stderr, "beginning display loop (image_channels == %d)\n",
      image_channels))
 Trace((stderr, "   (width = %ld, rowbytes = %ld, ximage_rowbytes = %d)\n",
      image_width, image_rowbytes, ximage_rowbytes))
 Trace((stderr, "   (bpp = %d)\n", ximage->bits_per_pixel))
 Trace((stderr, "   (byte_order = %s)\n", ximage->byte_order == MSBFirst?
 "MSBFirst" : (ximage->byte_order == LSBFirst? "LSBFirst" : "unknown")))

 if (depth == 24 || depth == 32) {
        ulg red, green, blue;

 for (lastrow = row = 0;  row < image_height; ++row) {
            src = image_data + row*image_rowbytes;
            dest = ximage->data + row*ximage_rowbytes;
 if (image_channels == 3) {
 for (i = image_width;  i > 0; --i) {
                    red   = *src++;
                    green = *src++;
                    blue  = *src++;
#ifdef NO_24BIT_MASKS
                    pixel = (red   << RShift) |
 (green << GShift) |
 (blue  << BShift);
 /* recall that we set ximage->byte_order = MSBFirst above */
 /* GRR BUG:  this assumes bpp == 32, but may be 24: */
 *dest++ = (char)((pixel >> 24) & 0xff);
 *dest++ = (char)((pixel >> 16) & 0xff);
 *dest++ = (char)((pixel >> 8) & 0xff);
 *dest++ = (char)( pixel        & 0xff);
#else
                    red   = (RShift < 0)? red   << (-RShift) : red   >> RShift;
                    green = (GShift < 0)? green << (-GShift) : green >> GShift;
                    blue  = (BShift < 0)? blue  << (-BShift) : blue  >> BShift;
                    pixel = (red & RMask) | (green & GMask) | (blue & BMask);
 /* recall that we set ximage->byte_order = MSBFirst above */
 *dest++ = (char)((pixel >> 24) & 0xff);
 *dest++ = (char)((pixel >> 16) & 0xff);
 *dest++ = (char)((pixel >> 8) & 0xff);
 *dest++ = (char)( pixel        & 0xff);
#endif
 }
 } else /* if (image_channels == 4) */ {
 for (i = image_width;  i > 0; --i) {
                    r = *src++;
                    g = *src++;
                    b = *src++;
                    a = *src++;
 if (a == 255) {
                        red   = r;
                        green = g;
                        blue  = b;
 } else if (a == 0) {
                        red   = bg_red;
                        green = bg_green;
                        blue  = bg_blue;
 } else {
 /* this macro (from png.h) composites the foreground
                         * and background values and puts the result into the
                         * first argument */
                        alpha_composite(red,   r, a, bg_red);
                        alpha_composite(green, g, a, bg_green);
                        alpha_composite(blue,  b, a, bg_blue);
 }
                    pixel = (red   << RShift) |
 (green << GShift) |
 (blue  << BShift);
 /* recall that we set ximage->byte_order = MSBFirst above */
 *dest++ = (char)((pixel >> 24) & 0xff);
 *dest++ = (char)((pixel >> 16) & 0xff);
 *dest++ = (char)((pixel >> 8) & 0xff);
 *dest++ = (char)( pixel        & 0xff);
 }
 }
 /* display after every 16 lines */
 if (((row+1) & 0xf) == 0) {
 XPutImage(display, window, gc, ximage, 0, (int)lastrow, 0,
 (int)lastrow, image_width, 16);
 XFlush(display);
                lastrow = row + 1;
 }
 }

 } else if (depth == 16) {
        ush red, green, blue;

 for (lastrow = row = 0;  row < image_height; ++row) {
            src = image_data + row*image_rowbytes;
            dest = ximage->data + row*ximage_rowbytes;
 if (image_channels == 3) {
 for (i = image_width;  i > 0; --i) {
                    red   = ((ush)(*src) << 8);
 ++src;
                    green = ((ush)(*src) << 8);
 ++src;
                    blue  = ((ush)(*src) << 8);
 ++src;
                    pixel = ((red   >> RShift) & RMask) |
 ((green >> GShift) & GMask) |
 ((blue  >> BShift) & BMask);
 /* recall that we set ximage->byte_order = MSBFirst above */
 *dest++ = (char)((pixel >> 8) & 0xff);
 *dest++ = (char)( pixel        & 0xff);
 }
 } else /* if (image_channels == 4) */ {
 for (i = image_width;  i > 0; --i) {
                    r = *src++;
                    g = *src++;
                    b = *src++;
                    a = *src++;
 if (a == 255) {
                        red   = ((ush)r << 8);
                        green = ((ush)g << 8);
                        blue  = ((ush)b << 8);
 } else if (a == 0) {
                        red   = ((ush)bg_red   << 8);
                        green = ((ush)bg_green << 8);
                        blue  = ((ush)bg_blue  << 8);
 } else {
 /* this macro (from png.h) composites the foreground
                         * and background values and puts the result back into
                         * the first argument (== fg byte here:  safe) */
                        alpha_composite(r, r, a, bg_red);
                        alpha_composite(g, g, a, bg_green);
                        alpha_composite(b, b, a, bg_blue);
                        red   = ((ush)r << 8);
                        green = ((ush)g << 8);
                        blue  = ((ush)b << 8);
 }
                    pixel = ((red   >> RShift) & RMask) |
 ((green >> GShift) & GMask) |
 ((blue  >> BShift) & BMask);
 /* recall that we set ximage->byte_order = MSBFirst above */
 *dest++ = (char)((pixel >> 8) & 0xff);
 *dest++ = (char)( pixel        & 0xff);
 }
 }
 /* display after every 16 lines */
 if (((row+1) & 0xf) == 0) {
 XPutImage(display, window, gc, ximage, 0, (int)lastrow, 0,
 (int)lastrow, image_width, 16);
 XFlush(display);
                lastrow = row + 1;
 }
 }

 } else /* depth == 8 */ {

 /* GRR:  add 8-bit support */

 }

 Trace((stderr, "calling final XPutImage()\n"))
 if (lastrow < image_height) {
 XPutImage(display, window, gc, ximage, 0, (int)lastrow, 0,
 (int)lastrow, image_width, image_height-lastrow);
 XFlush(display);
 }

 return 0;
}

gpc_noop(Pixel *out, const Pixel *in, const Background *back)
{
 (void)back;
   out->r = in->r;
   out->g = in->g;
   out->b = in->b;
   out->a = in->a;
}

resetimage(Image *image)
{
 if (image->input_file != NULL)
      rewind(image->input_file);
}

buffer_init(struct buffer *buffer)
 /* Call this only once for a given buffer */
{
   buffer->first.next = NULL;
   buffer->last = NULL;

    buffer->current = NULL;
 }

main(void)
{

fwrite(signature, sizeof signature, 1, stdout);
put_chunk(IHDR, sizeof IHDR);

   for(;;)
put_chunk(unknown, sizeof unknown);
}

store_storenew(png_store *ps)
{
   png_store_buffer *pb;

 if (ps->writepos != STORE_BUFFER_SIZE)
      png_error(ps->pwrite, "invalid store call");

   pb = voidcast(png_store_buffer*, malloc(sizeof *pb));

 if (pb == NULL)
      png_error(ps->pwrite, "store new: OOM");

 *pb = ps->new;
   ps->new.prev = pb;
   ps->writepos = 0;
}

make_four_random_bytes(png_uint_32* seed, png_bytep bytes)
{

    make_random_bytes(seed, bytes, 4);
 }

gpc_sCp(Pixel *out, const Pixel *in, const Background *back)
{
 (void)back;

 if (in->a <= 128)
 {
      out->r = out->g = out->b = 255;
      out->a = 0;
 }

 else
 {
      out->r = sRGB((double)in->r / in->a);
      out->g = sRGB((double)in->g / in->a);
      out->b = sRGB((double)in->b / in->a);
      out->a = u8d(in->a / 257.);
 }
}

read_file(Image *image, png_uint_32 format, png_const_colorp background)
{
   memset(&image->image, 0, sizeof image->image);
   image->image.version = PNG_IMAGE_VERSION;

 if (image->input_memory != NULL)
 {
 if (!png_image_begin_read_from_memory(&image->image, image->input_memory,
         image->input_memory_size))
 return logerror(image, "memory init: ", image->file_name, "");
 }

#  ifdef PNG_STDIO_SUPPORTED
 else if (image->input_file != NULL)
 {
 if (!png_image_begin_read_from_stdio(&image->image, image->input_file))
 return logerror(image, "stdio init: ", image->file_name, "");
 }

 else
 {
 if (!png_image_begin_read_from_file(&image->image, image->file_name))
 return logerror(image, "file init: ", image->file_name, "");
 }
#  else
 else
 {
 return logerror(image, "unsupported file/stdio init: ",
            image->file_name, "");
 }
#  endif

 /* This must be set after the begin_read call: */
 if (image->opts & sRGB_16BIT)
      image->image.flags |= PNG_IMAGE_FLAG_16BIT_sRGB;

 /* Have an initialized image with all the data we need plus, maybe, an
    * allocated file (myfile) or buffer (mybuffer) that need to be freed.
    */
 {
 int result;
      png_uint_32 image_format;

 /* Print both original and output formats. */
      image_format = image->image.format;

 if (image->opts & VERBOSE)
 {
         printf("%s %lu x %lu %s -> %s", image->file_name,
 (unsigned long)image->image.width,
 (unsigned long)image->image.height,
            format_names[image_format & FORMAT_MASK],
 (format & FORMAT_NO_CHANGE) != 0 || image->image.format == format
 ? "no change" : format_names[format & FORMAT_MASK]);

 if (background != NULL)
            printf(" background(%d,%d,%d)\n", background->red,
               background->green, background->blue);
 else
            printf("\n");

         fflush(stdout);
 }

 /* 'NO_CHANGE' combined with the color-map flag forces the base format
       * flags to be set on read to ensure that the original representation is
       * not lost in the pass through a colormap format.
       */
 if ((format & FORMAT_NO_CHANGE) != 0)
 {
 if ((format & PNG_FORMAT_FLAG_COLORMAP) != 0 &&
 (image_format & PNG_FORMAT_FLAG_COLORMAP) != 0)
            format = (image_format & ~BASE_FORMATS) | (format & BASE_FORMATS);

 else
            format = image_format;
 }

      image->image.format = format;

      image->stride = PNG_IMAGE_ROW_STRIDE(image->image) + image->stride_extra;
      allocbuffer(image);

      result = png_image_finish_read(&image->image, background,
         image->buffer+16, (png_int_32)image->stride, image->colormap);

      checkbuffer(image, image->file_name);

 if (result)
 return checkopaque(image);

 else
 return logerror(image, image->file_name, ": image read failed", "");
 }
}

image_transform_png_set_palette_to_rgb_mod(PNG_CONST image_transform *this,
image_pixel *that, png_const_structp pp,
    PNG_CONST transform_display *display)
{
if (that->colour_type == PNG_COLOR_TYPE_PALETTE)
image_pixel_convert_PLTE(that);

this->next->mod(this->next, that, pp, display);
}

checkopaque(Image *image)
{
 if (image->image.opaque != NULL)
 {
      png_image_free(&image->image);
 return logerror(image, image->file_name, ": opaque not NULL", "");
 }

 else if (image->image.warning_or_error != 0 && (image->opts & STRICT) != 0)
 return logerror(image, image->file_name, " --strict", "");

 else
 return 1;
}

gpc_Lin(Pixel *out, const Pixel *in, const Background *back)
{
 (void)back;

   out->r = ilinear_g22(in->r);

 if (in->g == in->r)
 {
      out->g = out->r;

 if (in->b == in->r)
         out->b = out->r;

 else
         out->b = ilinear_g22(in->b);
 }

 else
 {
      out->g = ilinear_g22(in->g);

 if (in->b == in->r)
         out->b = out->r;

 else if (in->b == in->g)
         out->b = out->g;

 else
         out->b = ilinear_g22(in->b);
 }

   out->a = 65535;
}

gp_argb8(Pixel *p, png_const_voidp pb)
{
   png_const_bytep pp = voidcast(png_const_bytep, pb);

   p->r = pp[1];
   p->g = pp[2];
   p->b = pp[3];
   p->a = pp[0];
}

transform_rowsize(png_const_structp pp, png_byte colour_type,
   png_byte bit_depth)
{
 return (TRANSFORM_WIDTH * bit_size(pp, colour_type, bit_depth)) / 8;
}

transform_test(png_modifier *pmIn, PNG_CONST png_uint_32 idIn,
    PNG_CONST image_transform* transform_listIn, PNG_CONST char * volatile name)
{
transform_display d;
context(&pmIn->this, fault);

transform_display_init(&d, pmIn, idIn, transform_listIn);

Try
{
size_t pos = 0;
png_structp pp;
png_infop pi;
char full_name[256];

/* Make sure the encoding fields are correct and enter the required
* modifications.
*/
transform_set_encoding(&d);

/* Add any modifications required by the transform list. */
d.transform_list->ini(d.transform_list, &d);

/* Add the color space information, if any, to the name. */
pos = safecat(full_name, sizeof full_name, pos, name);
pos = safecat_current_encoding(full_name, sizeof full_name, pos, d.pm);

/* Get a png_struct for reading the image. */
pp = set_modifier_for_read(d.pm, &pi, d.this.id, full_name);
standard_palette_init(&d.this);

#     if 0
/* Logging (debugging only) */
{
char buffer[256];

(void)store_message(&d.pm->this, pp, buffer, sizeof buffer, 0,
"running test");

fprintf(stderr, "%s\n", buffer);
}
#     endif

/* Introduce the correct read function. */
if (d.pm->this.progressive)
{
/* Share the row function with the standard implementation. */
png_set_progressive_read_fn(pp, &d, transform_info, progressive_row,
transform_end);

/* Now feed data into the reader until we reach the end: */
modifier_progressive_read(d.pm, pp, pi);
}
else
{
/* modifier_read expects a png_modifier* */
png_set_read_fn(pp, d.pm, modifier_read);

/* Check the header values: */
png_read_info(pp, pi);

/* Process the 'info' requirements. Only one image is generated */
transform_info_imp(&d, pp, pi);

sequential_row(&d.this, pp, pi, -1, 0);

if (!d.this.speed)
transform_image_validate(&d, pp, pi);
else
d.this.ps->validated = 1;
}

modifier_reset(d.pm);
}

Catch(fault)
{
modifier_reset(voidcast(png_modifier*,(void*)fault));
}
}

png_pass_cols(png_uint_32 width, int pass)
{
   png_uint_32 tiles = width>>3;
   png_uint_32 cols = 0;
 unsigned int x, y;

   width &= 7;
 ++pass;
 for (x=0; x<8; ++x) for (y=0; y<8; ++y) if (adam7[y][x] == pass)
 {
      cols += tiles;
 if (x < width) ++cols;
 break; /* i.e. break the 'y', row, loop. */
 }

 return cols;
}

control_init(struct control *control, struct global *global,
 const char *file_name, const char *out_name)
 /* This wraps file_init(&control::file) and simply returns the result from
    * file_init.
    */
{
 return file_init(&control->file, global, file_name, out_name, control,
      allocate);
}

sRGB(double linear /*range 0.0 .. 1.0*/)
{
 return u8d(255 * sRGB_from_linear(linear));
}

zlib_flevel(struct zlib *zlib)
{
 switch (zlib->header[1] >> 6)
 {
 case 0: return "supfast";
 case 1: return "stdfast";
 case 2: return "default";
 case 3: return "maximum";
 default: assert(UNREACHED);
 }

 return "COMPILER BUG";
}

make_errors(png_modifier* PNG_CONST pm, png_byte PNG_CONST colour_type,
    int bdlo, int PNG_CONST bdhi)
{
for (; bdlo <= bdhi; ++bdlo)
{
int interlace_type;

for (interlace_type = PNG_INTERLACE_NONE;
interlace_type < INTERLACE_LAST; ++interlace_type)
{
unsigned int test;

char name[FILE_NAME_SIZE];

standard_name(name, sizeof name, 0, colour_type, 1<<bdlo, 0,
            interlace_type, 0, 0, 0);

         for (test=0; test<(sizeof error_test)/(sizeof error_test[0]); ++test)
{
make_error(&pm->this, colour_type, DEPTH(bdlo), interlace_type,
test, name);

if (fail(pm))
return 0;
}
}
}

return 1; /* keep going */
}

file_setpos(struct file *file, const fpos_t *pos)
{
 if (fsetpos(file->file, pos))
 {
      perror(file->file_name);
      stop(file, READ_ERROR_CODE, "fsetpos");
 }
}

read_callback(png_structp png_ptr, png_bytep buffer, size_t count)
 /* Return 'count' bytes to libpng in 'buffer' */
{
 struct file *file = get_control(png_ptr);
   png_uint_32 type, length; /* For the chunk be *WRITTEN* */
 struct chunk *chunk;

 /* libpng should always ask for at least one byte */
 if (count == 0)
      stop(file, UNEXPECTED_ERROR_CODE, "read callback for 0 bytes");

 /* The callback always reads ahead by 8 bytes - the signature or chunk header
    * - these bytes are stored in chunk_length and chunk_type.  This block is
    * executed once for the signature and once for the first chunk right at the
    * start.
    */
 if (file->read_count < 8)
 {
      assert(file->read_count == 0);
      assert((file->status_code & TRUNCATED) == 0);

 (void)read_4(file, &file->length);

 if (file->read_count == 4)
 (void)read_4(file, &file->type);

 if (file->read_count < 8)
 {
         assert((file->status_code & TRUNCATED) != 0);
         stop(file, READ_ERROR_CODE, "not a PNG (too short)");
 }

 if (file->state == STATE_SIGNATURE)
 {
 if (file->length != sig1 || file->type != sig2)
            stop(file, LIBPNG_ERROR_CODE, "not a PNG (signature)");

 /* Else write it (this is the initialization of write_count, prior to
          * this it contains CLEAR garbage.)
          */
         file->write_count = 0;
 }

 else
 {
         assert(file->state == STATE_CHUNKS);

 /* The first chunk must be a well formed IHDR (this could be relaxed to
          * use the checks in process_chunk, but that seems unnecessary.)
          */
 if (file->length != 13 || file->type != png_IHDR)
            stop(file, LIBPNG_ERROR_CODE, "not a PNG (IHDR)");

 /* The position of the data must be stored too */
         getpos(file);
 }
 }

 /* Retrieve previous state (because the read callbacks are made pretty much
    * byte-by-byte in the sequential reader prior to 1.7).
    */
   chunk = file->chunk;

 if (chunk != NULL)
 {
      length = chunk->chunk_length;
      type = chunk->chunk_type;
 }

 else
 {
 /* This is the signature case; for IDAT and other chunks these values will
       * be overwritten when read_chunk is called below.
       */
      length = file->length;
      type = file->type;
 }

 do
 {
      png_uint_32 b;

 /* Complete the read of a chunk; as a side effect this also instantiates
       * a chunk control structure and sets the file length/type/data_pos fields
       * for the *NEXT* chunk header.
       *
       * NOTE: at an IDAT any following IDAT chunks will also be read and the
       * next_ fields will refer to the chunk after the last IDAT.
       *
       * NOTE: read_chunk only returns when it has read a chunk that must now be
       * written.
       */
 if (file->state != STATE_SIGNATURE && chunk == NULL)
 {
         assert(file->read_count == 8);
         assert(file->idat == NULL);
         read_chunk(file);
         chunk = file->chunk;
         assert(chunk != NULL);

 /* Do the initialization that was not done before. */
         length = chunk->chunk_length;
         type = chunk->chunk_type;

 /* And start writing the new chunk. */
         file->write_count = 0;
 }

 /* The chunk_ fields describe a chunk that must be written, or hold the
       * signature.  Write the header first.  In the signature case this
       * rewrites the signature.
       */
 switch (file->write_count)
 {
 case 0: b = length >> 24; break;
 case 1: b = length >> 16; break;
 case 2: b = length >> 8; break;
 case 3: b = length      ; break;

 case 4: b = type >> 24; break;
 case 5: b = type >> 16; break;
 case 6: b = type >> 8; break;
 case 7: b = type      ; break;

 case 8:
 /* The header has been written.  If this is really the signature
             * that's all that is required and we can go to normal chunk
             * processing.
             */
 if (file->state == STATE_SIGNATURE)
 {
 /* The signature has been written, the tail call to read_callback
                * below (it's just a goto to the start with a decent compiler)
                * will read the IHDR header ahead and validate it.
                */
               assert(length == sig1 && type == sig2);
               file->read_count = 0; /* Forces a header read */
               file->state = STATE_CHUNKS; /* IHDR: checked above */
               read_callback(png_ptr, buffer, count);
 return;
 }

 else
 {
               assert(chunk != NULL);

 /* Set up for write, notice that repositioning the input stream
                * is only necessary if something is to be read from it.  Also
                * notice that for the IDAT stream this must only happen once -
                * on the first IDAT - to get back to the start of the list and
                * this is done inside process_IDAT:
                */
               chunk->write_crc = crc_init_4(type);
 if (file->state != STATE_IDAT && length > 0)
                  setpos(chunk);
 }
 /* FALL THROUGH */

 default:
            assert(chunk != NULL);

 /* NOTE: the arithmetic below overflows and gives a large positive
             * png_uint_32 value until the whole chunk data has been written.
             */
 switch (file->write_count - length)
 {
 /* Write the chunk data, normally this just comes from
                * the file.  The only exception is for that part of a
                * chunk which is zlib data and which must be rewritten,
                * and IDAT chunks which can be completely
                * reconstructed.
                */
 default:
 if (file->state == STATE_IDAT)
 {
 struct IDAT *idat = file->idat;

                     assert(idat != NULL);

 /* Read an IDAT byte from the input stream of IDAT chunks.
                      * Because the IDAT stream can be re-chunked this stream is
                      * held in the struct IDAT members.  The chunk members, in
                      * particular chunk_length (and therefore the length local)
                      * refer to the output chunk.
                      */
 while (idat->idat_index >= idat->idat_length)
 {
 /* Advance one chunk */
 struct IDAT_list *cur = idat->idat_cur;

                        assert(idat->idat_index == idat->idat_length);
                        assert(cur != NULL && cur->count > 0);

 /* NOTE: IDAT_list::count here, not IDAT_list::length */
 if (++(idat->idat_count) >= cur->count)
 {
                           assert(idat->idat_count == cur->count);

 /* Move on to the next IDAT_list: */
                           cur = cur->next;

 /* This is an internal error - read beyond the end of
                            * the pre-calculated stream.
                            */
 if (cur == NULL || cur->count == 0)
                              stop(file, UNEXPECTED_ERROR_CODE,
 "read beyond end of IDAT");

                           idat->idat_count = 0;
                           idat->idat_cur = cur;
 }

                        idat->idat_index = 0;
 /* Zero length IDAT chunks are permitted, so the length
                         * here may be 0.
                         */
                        idat->idat_length = cur->lengths[idat->idat_count];

 /* And skip 12 bytes to the next chunk data */
                        skip_12(file);
 }

 /* The index is always that of the next byte, the rest of
                      * the information is always the current IDAT chunk and the
                      * current list.
                      */
 ++(idat->idat_index);
 }

 /* Read the byte from the stream. */
                  b = reread_byte(file);

 /* If the byte must be rewritten handle that here */
 if (chunk->rewrite_length > 0)
 {
 if (chunk->rewrite_offset > 0)
 --(chunk->rewrite_offset);

 else
 {
                        b = chunk->rewrite_buffer[0];
                        memmove(chunk->rewrite_buffer, chunk->rewrite_buffer+1,
 (sizeof chunk->rewrite_buffer)-
 (sizeof chunk->rewrite_buffer[0]));

 --(chunk->rewrite_length);
 }
 }

                  chunk->write_crc = crc_one_byte(chunk->write_crc, b);
 break;

 /* The CRC is written at:
                *
                *    chunk_write == chunk_length+8..chunk_length+11
                *
                * so 8 to 11.  The CRC is not (yet) conditioned.
                */
 case 8: b = chunk->write_crc >> 24; goto write_crc;
 case 9: b = chunk->write_crc >> 16; goto write_crc;
 case 10: b = chunk->write_crc >> 8; goto write_crc;
 case 11:
 /* This must happen before the chunk_end below: */
                  b = chunk->write_crc;

 if (file->global->verbose > 2)
 {
                     fputs("   ", stderr);
                     type_name(type, stderr);
                     fprintf(stderr, " %lu 0x%.8x\n", (unsigned long)length,
                        chunk->write_crc ^ 0xffffffff);
 }

 /* The IDAT stream is written without a call to read_chunk
                   * until the end is reached.  rechunk_length() calculates the
                   * length of the output chunks.  Control gets to this point at
                   * the end of an *output* chunk - the length calculated by
                   * rechunk_length.  If this corresponds to the end of the
                   * input stream stop writing IDAT chunks, otherwise continue.
                   */
 if (file->state == STATE_IDAT &&
 (file->idat->idat_index < file->idat->idat_length ||
 1+file->idat->idat_count < file->idat->idat_cur->count ||
                      file->idat->idat_cur != file->idat->idat_list_tail))
 {
 /* Write another IDAT chunk.  Call rechunk_length to
                      * calculate the length required.
                      */
                     length = chunk->chunk_length = rechunk_length(file->idat);
                     assert(type == png_IDAT);
                     file->write_count = 0; /* for the new chunk */
 --(file->write_count); /* fake out the increment below */
 }

 else
 {
 /* Entered at the end of a non-IDAT chunk and at the end of
                      * the IDAT stream.  The rewrite should have been cleared.
                      */
 if (chunk->rewrite_length > 0 || chunk->rewrite_offset > 0)
                        stop(file, UNEXPECTED_ERROR_CODE, "pending rewrite");

 /* This is the last byte so reset chunk_read for the next
                      * chunk and move the input file to the position after the
                      * *next* chunk header if required.
                      */
                     file->read_count = 8;
                     file_setpos(file, &file->data_pos);

 if (file->idat == NULL)
                        chunk_end(&file->chunk);

 else
                        IDAT_end(&file->idat);
 }

               write_crc:
                  b ^= 0xff; /* conditioning */
 break;
 }
 break;
 }

 /* Write one byte */
      b &= 0xff;
 *buffer++ = (png_byte)b;
 --count;
      write_byte(file, (png_byte)b); /* increments chunk_write */
 }
 while (count > 0);
}

image_transform_png_set_@_mod(PNG_CONST image_transform *this,
    image_pixel *that, png_const_structp pp,
    PNG_CONST transform_display *display)
{
   this->next->mod(this->next, that, pp, display);
}

uarb_mult32(uarb acc, int a_digits, uarb num, int n_digits, png_uint_32 val)
 /* calculate acc += num * val, 'val' may be any 32-bit value, 'acc' and 'num'
    * may be any value, returns the number of digits in 'acc'.
    */
{
 if (n_digits > 0 && val > 0)
 {
      a_digits = uarb_mult_digit(acc, a_digits, num, n_digits,
 (png_uint_16)(val & 0xffff));

 /* Because n_digits and val are >0 the following must be true: */
      assert(a_digits > 0);

      val >>= 16;
 if (val > 0)
         a_digits = uarb_mult_digit(acc+1, a_digits-1, num, n_digits,
 (png_uint_16)val) + 1;
 }

 return a_digits;
}

process_iTXt(struct file *file)
{
 /* Like zTXt but more fields. */
 struct chunk *chunk = file->chunk;
   png_uint_32 length;
   png_uint_32 index = 0;

   assert(chunk != NULL && file->idat == NULL);
   length = chunk->chunk_length;
   setpos(chunk);

 while (length >= 5)
 {
 --length;
 ++index;
 if (reread_byte(file) == 0) /* keyword null terminator */
 {
 --length;
 ++index;
 if (reread_byte(file) == 0) /* uncompressed text */
 return 1; /* nothing to check */

 --length;
 ++index;
 (void)reread_byte(file); /* compression method */

 /* Skip the language tag (null terminated). */
 while (length >= 9)
 {
 --length;
 ++index;
 if (reread_byte(file) == 0) /* terminator */
 {
 /* Skip the translated keyword */
 while (length >= 8)
 {
 --length;
 ++index;
 if (reread_byte(file) == 0) /* terminator */
 return zlib_check(file, index);
 }
 }
 }

 /* Ran out of bytes in the compressed case. */
 break;
 }
 }

   log_error(file, INVALID_ERROR_CODE, "iTXt chunk length");

 return 0; /* skip */
}

store_read_reset(png_store *ps)
{
#  ifdef PNG_READ_SUPPORTED
 if (ps->pread != NULL)
 {
         anon_context(ps);

 Try
            png_destroy_read_struct(&ps->pread, &ps->piread, NULL);

 Catch_anonymous
 {
 /* error already output: continue */
 }

         ps->pread = NULL;
         ps->piread = NULL;
 }
#  endif

#  ifdef PNG_USER_MEM_SUPPORTED
 /* Always do this to be safe. */
      store_pool_delete(ps, &ps->read_memory_pool);
#  endif

   ps->current = NULL;
   ps->next = NULL;
   ps->readpos = 0;
   ps->validated = 0;
}

int writepng_encode_row(mainprog_info *mainprog_ptr) /* NON-interlaced only! */
{
    png_structp png_ptr = (png_structp)mainprog_ptr->png_ptr;
    png_infop info_ptr = (png_infop)mainprog_ptr->info_ptr;


 /* as always, setjmp() must be called in every function that calls a
     * PNG-writing libpng function */

 if (setjmp(mainprog_ptr->jmpbuf)) {
        png_destroy_write_struct(&png_ptr, &info_ptr);
        mainprog_ptr->png_ptr = NULL;
        mainprog_ptr->info_ptr = NULL;
 return 2;
 }


 /* image_data points at our one row of image data */

    png_write_row(png_ptr, mainprog_ptr->image_data);

 return 0;
}

store_read(png_structp ppIn, png_bytep pb, png_size_t st)
{
   png_const_structp pp = ppIn;
   png_store *ps = voidcast(png_store*, png_get_io_ptr(pp));

 if (ps == NULL || ps->pread != pp)
      png_error(pp, "bad store read call");

   store_read_imp(ps, pb, st);
}

 ancillaryb(const png_byte *name)
 {
 return PNG_CHUNK_ANCILLARY(PNG_U32(name[0], name[1], name[2], name[3]));
}

test_standard(png_modifier* PNG_CONST pm, png_byte PNG_CONST colour_type,
    int bdlo, int PNG_CONST bdhi)
{
for (; bdlo <= bdhi; ++bdlo)
{
int interlace_type;

for (interlace_type = PNG_INTERLACE_NONE;

interlace_type < INTERLACE_LAST; ++interlace_type)
{
standard_test(&pm->this, FILEID(colour_type, DEPTH(bdlo), 0/*palette*/,
            interlace_type, 0, 0, 0), 0/*do_interlace*/, pm->use_update_info);

if (fail(pm))
return 0;
}
}

return 1; /* keep going */
}

png_row_in_interlace_pass(png_uint_32 y, int pass)
{
 /* Is row 'y' in pass 'pass'? */
 int x;
   y &= 7;
 ++pass;
 for (x=0; x<8; ++x) if (adam7[y][x] == pass)
 return 1;

 return 0;
}

image_transform_png_set_expand_set(PNG_CONST image_transform *this,
     transform_display *that, png_structp pp, png_infop pi)
 {
    png_set_expand(pp);
    this->next->set(this->next, that, pp, pi);
 }

transform_display_init(transform_display *dp, png_modifier *pm, png_uint_32 id,
    PNG_CONST image_transform *transform_list)
{
memset(dp, 0, sizeof *dp);

/* Standard fields */
   standard_display_init(&dp->this, &pm->this, id, 0/*do_interlace*/,
pm->use_update_info);

/* Parameter fields */
dp->pm = pm;
dp->transform_list = transform_list;

/* Local variable fields */
dp->output_colour_type = 255; /* invalid */
dp->output_bit_depth = 255;  /* invalid */
}

gpc_unpg(Pixel *out, const Pixel *in, const Background *back)
{
 (void)back;

 if (in->a <= 128)
 {
      out->r = out->g = out->b = 255;
      out->a = 0;
 }

 else
 {
      out->r = out->g = out->b = sRGB((double)in->g / in->a);
      out->a = u8d(in->a / 257.);
 }
}

strcode(int code)
{
 switch (code)
 {
 case LIBPNG_WARNING_CODE: return "warning";
 case LIBPNG_ERROR_CODE: return "libpng";
 case ZLIB_ERROR_CODE: return "zlib";
 case INVALID_ERROR_CODE: return "invalid";
 case READ_ERROR_CODE: return "read";
 case WRITE_ERROR_CODE: return "write";
 case UNEXPECTED_ERROR_CODE: return "unexpected";
 default: return "INVALID";
 }
}

chunk_end(struct chunk **chunk_var)
{
 struct chunk *chunk = *chunk_var;

 *chunk_var = NULL;
   CLEAR(*chunk);
}

standard_display_init(standard_display *dp, png_store* ps, png_uint_32 id,
 int do_interlace, int use_update_info)
{
   memset(dp, 0, sizeof *dp);

   dp->ps = ps;
   dp->colour_type = COL_FROM_ID(id);
   dp->bit_depth = DEPTH_FROM_ID(id);
 if (dp->bit_depth < 1 || dp->bit_depth > 16)
      internal_error(ps, "internal: bad bit depth");
 if (dp->colour_type == 3)
      dp->red_sBIT = dp->blue_sBIT = dp->green_sBIT = dp->alpha_sBIT = 8;
 else
      dp->red_sBIT = dp->blue_sBIT = dp->green_sBIT = dp->alpha_sBIT =
         dp->bit_depth;
   dp->interlace_type = INTERLACE_FROM_ID(id);
   check_interlace_type(dp->interlace_type);
   dp->id = id;
 /* All the rest are filled in after the read_info: */
   dp->w = 0;
   dp->h = 0;
   dp->npasses = 0;
   dp->pixel_size = 0;

    dp->bit_width = 0;
    dp->cbRow = 0;
    dp->do_interlace = do_interlace;
    dp->is_transparent = 0;
    dp->speed = ps->speed;
    dp->use_update_info = use_update_info;
   dp->npalette = 0;
 /* Preset the transparent color to black: */
   memset(&dp->transparent, 0, sizeof dp->transparent);
 /* Preset the palette to full intensity/opaque througout: */
   memset(dp->palette, 0xff, sizeof dp->palette);
}

ilineara(int fixed_srgb, int alpha)
{
 return u16d((257 * alpha) * sRGB_to_d[fixed_srgb]);
}

modifier_total_encodings(PNG_CONST png_modifier *pm)
 {
    return 1 +                 /* (1) nothing */
       pm->ngammas +           /* (2) gamma values to test */
      pm->nencodings + /* (3) total number of encodings */
 /* The following test only works after the first time through the
       * png_modifier code because 'bit_depth' is set when the IHDR is read.
       * modifier_reset, below, preserves the setting until after it has called
       * the iterate function (also below.)
       *
       * For this reason do not rely on this function outside a call to
       * modifier_reset.
       */
 ((pm->bit_depth == 16 || pm->assume_16_bit_calculations) ?
         pm->nencodings : 0); /* (4) encodings with gamma == 1.0 */
}

image_transform_png_set_palette_to_rgb_add(image_transform *this,
    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)
{
UNUSED(bit_depth)

this->next = *that;
*that = this;

return colour_type == PNG_COLOR_TYPE_PALETTE;
}

image_transform_png_set_background_mod(PNG_CONST image_transform *this,
image_pixel *that, png_const_structp pp,
    PNG_CONST transform_display *display)
{
/* Check for tRNS first: */
if (that->have_tRNS && that->colour_type != PNG_COLOR_TYPE_PALETTE)
      image_pixel_add_alpha(that, &display->this);

/* This is only necessary if the alpha value is less than 1. */
if (that->alphaf < 1)
{
/* Now we do the background calculation without any gamma correction. */
if (that->alphaf <= 0)
{
that->redf = data.redf;
that->greenf = data.greenf;
that->bluef = data.bluef;

that->rede = data.rede;
that->greene = data.greene;
that->bluee = data.bluee;

that->red_sBIT= data.red_sBIT;
that->green_sBIT= data.green_sBIT;
that->blue_sBIT= data.blue_sBIT;
}

else /* 0 < alpha < 1 */
{
double alf = 1 - that->alphaf;

that->redf = that->redf * that->alphaf + data.redf * alf;
that->rede = that->rede * that->alphaf + data.rede * alf +
DBL_EPSILON;
that->greenf = that->greenf * that->alphaf + data.greenf * alf;
that->greene = that->greene * that->alphaf + data.greene * alf +
DBL_EPSILON;
that->bluef = that->bluef * that->alphaf + data.bluef * alf;
that->bluee = that->bluee * that->alphaf + data.bluee * alf +
DBL_EPSILON;
}


/* Remove the alpha type and set the alpha (not in that order.) */
that->alphaf = 1;
that->alphae = 0;
      if (that->colour_type == PNG_COLOR_TYPE_RGB_ALPHA)
         that->colour_type = PNG_COLOR_TYPE_RGB;
      else if (that->colour_type == PNG_COLOR_TYPE_GRAY_ALPHA)
         that->colour_type = PNG_COLOR_TYPE_GRAY;
      /* PNG_COLOR_TYPE_PALETTE is not changed *
}

this->next->mod(this->next, that, pp, display);
}

test_one_file(const char *file_name, format_list *formats, png_uint_32 opts,
 int stride_extra, int log_pass)
{
 int result;
 Image image;

   newimage(&image);
   initimage(&image, opts, file_name, stride_extra);
   result = read_one_file(&image);
 if (result)
      result = testimage(&image, opts, formats);
   freeimage(&image);

 /* Ensure that stderr is flushed into any log file */
   fflush(stderr);

 if (log_pass)
 {
 if (result)
         printf("PASS:");

 else
         printf("FAIL:");

#     ifndef PNG_SIMPLIFIED_WRITE_SUPPORTED
         printf(" (no write)");
#     endif

      print_opts(opts);
      printf(" %s\n", file_name);
 /* stdout may not be line-buffered if it is piped to a file, so: */
      fflush(stdout);
 }

 else if (!result)
      exit(1);

 return result;
}

static void rpng2_x_init(void)
{
    ulg i;
    ulg rowbytes = rpng2_info.rowbytes;

 Trace((stderr, "beginning rpng2_x_init()\n"))
 Trace((stderr, "  rowbytes = %d\n", rpng2_info.rowbytes))
 Trace((stderr, "  width  = %ld\n", rpng2_info.width))
 Trace((stderr, "  height = %ld\n", rpng2_info.height))

    rpng2_info.image_data = (uch *)malloc(rowbytes * rpng2_info.height);
 if (!rpng2_info.image_data) {
        readpng2_cleanup(&rpng2_info);
 return;
 }

    rpng2_info.row_pointers = (uch **)malloc(rpng2_info.height * sizeof(uch *));
 if (!rpng2_info.row_pointers) {
        free(rpng2_info.image_data);
        rpng2_info.image_data = NULL;
        readpng2_cleanup(&rpng2_info);
 return;
 }

 for (i = 0;  i < rpng2_info.height; ++i)
        rpng2_info.row_pointers[i] = rpng2_info.image_data + i*rowbytes;


 /* do the basic X initialization stuff, make the window, and fill it with
     * the user-specified, file-specified or default background color or
     * pattern */

 if (rpng2_x_create_window()) {

 /* GRR TEMPORARY HACK:  this is fundamentally no different from cases
         * above; libpng should call our error handler to longjmp() back to us
         * when png_ptr goes away.  If we/it segfault instead, seems like a
         * libpng bug... */

 /* we're here via libpng callback, so if window fails, clean and bail */
        readpng2_cleanup(&rpng2_info);
        rpng2_x_cleanup();
        exit(2);
 }

    rpng2_info.state = kWindowInit;
}

uarb_shift(uarb inout, int ndigits, unsigned int right_shift)
 /* Shift inout right by right_shift bits, right_shift must be in the range
    * 1..15
    */
{
   FIX_GCC int i = ndigits;
   png_uint_16 carry = 0;

   assert(right_shift >= 1 && right_shift <= 15);

 while (--i >= 0)
 {
      png_uint_16 temp = (png_uint_16)(carry | (inout[i] >> right_shift));

 /* Bottom bits to top bits of carry */
      carry = (png_uint_16)((inout[i] << (16-right_shift)) & 0xffff);

      inout[i] = temp;

 /* The shift may reduce ndigits */
 if (i == ndigits-1 && temp == 0)
         ndigits = i;
 }

 return ndigits;
}

int main(void)
{
   fprintf(stderr, "pngstest: no read support in libpng, test skipped\n");
 /* So the test is skipped: */
 return 77;
}

gpc_cb16(Pixel *out, const Pixel *in, const Background *back)
{
 if (in->a <= 0)
 {
      out->r = back->ir;
      out->g = back->ig;
      out->b = back->ib;
 }

 else if (in->a >= 65535)
 {
      out->r = isRGB(in->r);
      out->g = isRGB(in->g);
      out->b = isRGB(in->b);
 }

 else
 {
 double a = in->a / 65535.;
 double a1 = 1-a;

      a /= 65535;
      out->r = sRGB(in->r * a + back->dr * a1);
      out->g = sRGB(in->g * a + back->dg * a1);
      out->b = sRGB(in->b * a + back->db * a1);
 }

   out->a = 255;
}

safe_read(png_structp png_ptr, int fd, void *buffer_in, size_t nbytes)
{
 size_t ntotal = 0;
 char *buffer = png_voidcast(char*, buffer_in);

 while (nbytes > 0)
 {
 unsigned int nread;
 int iread;

 /* Passing nread > INT_MAX to read is implementation defined in POSIX
       * 1003.1, therefore despite the unsigned argument portable code must
       * limit the value to INT_MAX!
       */
 if (nbytes > INT_MAX)
         nread = INT_MAX;

 else
         nread = (unsigned int)/*SAFE*/nbytes;

      iread = read(fd, buffer, nread);

 if (iread == -1)
 {
 /* This is the devil in the details, a read can terminate early with 0
          * bytes read because of EINTR, yet it still returns -1 otherwise end
          * of file cannot be distinguished.
          */
 if (errno != EINTR)
 {
            png_warning(png_ptr, "/proc read failed");
 return 0; /* I.e., a permanent failure */
 }
 }

 else if (iread < 0)
 {
 /* Not a valid 'read' result: */
         png_warning(png_ptr, "OS /proc read bug");
 return 0;
 }

 else if (iread > 0)
 {
 /* Continue reading until a permanent failure, or EOF */
         buffer += iread;
         nbytes -= (unsigned int)/*SAFE*/iread;
         ntotal += (unsigned int)/*SAFE*/iread;
 }

 else
 return ntotal;
 }

 return ntotal; /* nbytes == 0 */
}

gpc_gpre(Pixel *out, const Pixel *in, const Background *back)
{
 (void)back;

 if (in->r == in->g && in->g == in->b)
      out->r = out->g = out->b = ilineara(in->g, in->a);

 else
      out->r = out->g = out->b = u16d(in->a * 257 *
 YfromRGB(sRGB_to_d[in->r], sRGB_to_d[in->g], sRGB_to_d[in->b]));

   out->a = 257 * in->a;
}

image_transform_png_set_gray_to_rgb_set(PNG_CONST image_transform *this,
     transform_display *that, png_structp pp, png_infop pi)
 {
    png_set_gray_to_rgb(pp);
    this->next->set(this->next, that, pp, pi);
 }

int WINAPI WinMain(HINSTANCE hInst, HINSTANCE hPrevInst, PSTR cmd, int showmode)
{
 char *args[1024]; /* arbitrary limit, but should suffice */
 char **argv = args;
 char *p, *q, *bgstr = NULL;
 int argc = 0;
 int rc, alen, flen;
 int error = 0;
 int timing = FALSE;
 int have_bg = FALSE;
 double LUT_exponent; /* just the lookup table */
 double CRT_exponent = 2.2; /* just the monitor */
 double default_display_exponent; /* whole display system */
    MSG msg;


 /* First initialize a few things, just to be sure--memset takes care of
     * default background color (black), booleans (FALSE), pointers (NULL),
     * etc. */

    global_hInst = hInst;
    global_showmode = showmode;
    filename = (char *)NULL;
    memset(&rpng2_info, 0, sizeof(mainprog_info));

#ifndef __CYGWIN__
 /* Next reenable console output, which normally goes to the bit bucket
     * for windowed apps.  Closing the console window will terminate the
     * app.  Thanks to David.Geldreich@realviz.com for supplying the magical
     * incantation. */

 AllocConsole();
    freopen("CONOUT$", "a", stderr);
    freopen("CONOUT$", "a", stdout);
#endif

 /* Set the default value for our display-system exponent, i.e., the
     * product of the CRT exponent and the exponent corresponding to
     * the frame-buffer's lookup table (LUT), if any.  This is not an
     * exhaustive list of LUT values (e.g., OpenStep has a lot of weird
     * ones), but it should cover 99% of the current possibilities.  And
     * yes, these ifdefs are completely wasted in a Windows program... */

#if defined(NeXT)
 /* third-party utilities can modify the default LUT exponent */
    LUT_exponent = 1.0 / 2.2;
 /*
    if (some_next_function_that_returns_gamma(&next_gamma))
        LUT_exponent = 1.0 / next_gamma;
     */
#elif defined(sgi)
    LUT_exponent = 1.0 / 1.7;
 /* there doesn't seem to be any documented function to
     * get the "gamma" value, so we do it the hard way */
    infile = fopen("/etc/config/system.glGammaVal", "r");
 if (infile) {
 double sgi_gamma;

        fgets(tmpline, 80, infile);
        fclose(infile);
        sgi_gamma = atof(tmpline);
 if (sgi_gamma > 0.0)
            LUT_exponent = 1.0 / sgi_gamma;
 }
#elif defined(Macintosh)
    LUT_exponent = 1.8 / 2.61;
 /*
    if (some_mac_function_that_returns_gamma(&mac_gamma))
        LUT_exponent = mac_gamma / 2.61;
     */
#else
    LUT_exponent = 1.0; /* assume no LUT:  most PCs */
#endif

 /* the defaults above give 1.0, 1.3, 1.5 and 2.2, respectively: */
    default_display_exponent = LUT_exponent * CRT_exponent;


 /* If the user has set the SCREEN_GAMMA environment variable as suggested
     * (somewhat imprecisely) in the libpng documentation, use that; otherwise
     * use the default value we just calculated.  Either way, the user may
     * override this via a command-line option. */

 if ((p = getenv("SCREEN_GAMMA")) != NULL)
        rpng2_info.display_exponent = atof(p);
 else
        rpng2_info.display_exponent = default_display_exponent;


 /* Windows really hates command lines, so we have to set up our own argv.
     * Note that we do NOT bother with quoted arguments here, so don't use
     * filenames with spaces in 'em! */

    argv[argc++] = PROGNAME;
    p = cmd;
 for (;;) {
 if (*p == ' ')
 while (*++p == ' ')
 ;
 /* now p points at the first non-space after some spaces */
 if (*p == '\0')
 break; /* nothing after the spaces:  done */
        argv[argc++] = q = p;
 while (*q && *q != ' ')
 ++q;
 /* now q points at a space or the end of the string */
 if (*q == '\0')
 break; /* last argv already terminated; quit */
 *q = '\0'; /* change space to terminator */
        p = q + 1;
 }
    argv[argc] = NULL; /* terminate the argv array itself */


 /* Now parse the command line for options and the PNG filename. */

 while (*++argv && !error) {
 if (!strncmp(*argv, "-gamma", 2)) {
 if (!*++argv)
 ++error;
 else {
                rpng2_info.display_exponent = atof(*argv);
 if (rpng2_info.display_exponent <= 0.0)
 ++error;
 }
 } else if (!strncmp(*argv, "-bgcolor", 4)) {
 if (!*++argv)
 ++error;
 else {
                bgstr = *argv;
 if (strlen(bgstr) != 7 || bgstr[0] != '#')
 ++error;
 else {
                    have_bg = TRUE;
                    bg_image = FALSE;
 }
 }
 } else if (!strncmp(*argv, "-bgpat", 4)) {
 if (!*++argv)
 ++error;
 else {
                pat = atoi(*argv) - 1;
 if (pat < 0 || pat >= num_bgpat)
 ++error;
 else {
                    bg_image = TRUE;
                    have_bg = FALSE;
 }
 }
 } else if (!strncmp(*argv, "-timing", 2)) {
            timing = TRUE;
 } else {
 if (**argv != '-') {
                filename = *argv;
 if (argv[1]) /* shouldn't be any more args after filename */
 ++error;
 } else
 ++error; /* not expecting any other options */
 }
 }

 if (!filename)
 ++error;


 /* print usage screen if any errors up to this point */

 if (error) {
#ifndef __CYGWIN__
 int ch;
#endif

        fprintf(stderr, "\n%s %s:  %s\n\n", PROGNAME, VERSION, appname);
        readpng2_version_info();
        fprintf(stderr, "\n"
 "Usage:  %s [-gamma exp] [-bgcolor bg | -bgpat pat] [-timing]\n"
 "        %*s file.png\n\n"
 "    exp \ttransfer-function exponent (``gamma'') of the display\n"
 "\t\t  system in floating-point format (e.g., ``%.1f''); equal\n"
 "\t\t  to the product of the lookup-table exponent (varies)\n"
 "\t\t  and the CRT exponent (usually 2.2); must be positive\n"
 "    bg  \tdesired background color in 7-character hex RGB format\n"
 "\t\t  (e.g., ``#ff7700'' for orange:  same as HTML colors);\n"
 "\t\t  used with transparent images; overrides -bgpat option\n"
 "    pat \tdesired background pattern number (1-%d); used with\n"
 "\t\t  transparent images; overrides -bgcolor option\n"
 "    -timing\tenables delay for every block read, to simulate modem\n"
 "\t\t  download of image (~36 Kbps)\n"
 "\nPress Q, Esc or mouse button 1 after image is displayed to quit.\n"
#ifndef __CYGWIN__
 "Press Q or Esc to quit this usage screen. ",
#else
 ,
#endif
          PROGNAME,
#if (defined(__i386__) || defined(_M_IX86) || defined(__x86_64__)) && \
 !(defined(__CYGWIN__) || defined(__MINGW32__))
 (int)strlen(PROGNAME), " ",
#endif
 (int)strlen(PROGNAME), " ", default_display_exponent, num_bgpat);
        fflush(stderr);
#ifndef __CYGWIN__
 do
            ch = _getch();
 while (ch != 'q' && ch != 'Q' && ch != 0x1B);
#endif
        exit(1);
 }


 if (!(infile = fopen(filename, "rb"))) {
        fprintf(stderr, PROGNAME ":  can't open PNG file [%s]\n", filename);
 ++error;
 } else {
        incount = fread(inbuf, 1, INBUFSIZE, infile);
 if (incount < 8 || !readpng2_check_sig(inbuf, 8)) {
            fprintf(stderr, PROGNAME
 ":  [%s] is not a PNG file: incorrect signature\n",
              filename);
 ++error;
 } else if ((rc = readpng2_init(&rpng2_info)) != 0) {
 switch (rc) {
 case 2:
                    fprintf(stderr, PROGNAME
 ":  [%s] has bad IHDR (libpng longjmp)\n", filename);
 break;
 case 4:
                    fprintf(stderr, PROGNAME ":  insufficient memory\n");
 break;
 default:
                    fprintf(stderr, PROGNAME
 ":  unknown readpng2_init() error\n");
 break;
 }
 ++error;
 }
 if (error)
            fclose(infile);
 }


 if (error) {
#ifndef __CYGWIN__
 int ch;
#endif

        fprintf(stderr, PROGNAME ":  aborting.\n");
#ifndef __CYGWIN__
 do
            ch = _getch();
 while (ch != 'q' && ch != 'Q' && ch != 0x1B);
#endif
        exit(2);
 } else {
        fprintf(stderr, "\n%s %s:  %s\n", PROGNAME, VERSION, appname);
#ifndef __CYGWIN__
        fprintf(stderr,
 "\n   [console window:  closing this window will terminate %s]\n\n",
          PROGNAME);
#endif
        fflush(stderr);
 }


 /* set the title-bar string, but make sure buffer doesn't overflow */

    alen = strlen(appname);
    flen = strlen(filename);
 if (alen + flen + 3 > 1023)
        sprintf(titlebar, "%s:  ...%s", appname, filename+(alen+flen+6-1023));
 else
        sprintf(titlebar, "%s:  %s", appname, filename);


 /* set some final rpng2_info variables before entering main data loop */

 if (have_bg) {
 unsigned r, g, b; /* this approach quiets compiler warnings */

        sscanf(bgstr+1, "%2x%2x%2x", &r, &g, &b);
        rpng2_info.bg_red   = (uch)r;
        rpng2_info.bg_green = (uch)g;
        rpng2_info.bg_blue  = (uch)b;
 } else
        rpng2_info.need_bgcolor = TRUE;

    rpng2_info.state = kPreInit;
    rpng2_info.mainprog_init = rpng2_win_init;
    rpng2_info.mainprog_display_row = rpng2_win_display_row;
    rpng2_info.mainprog_finish_display = rpng2_win_finish_display;


 /* OK, this is the fun part:  call readpng2_decode_data() at the start of
     * the loop to deal with our first buffer of data (read in above to verify
     * that the file is a PNG image), then loop through the file and continue
     * calling the same routine to handle each chunk of data.  It in turn
     * passes the data to libpng, which will invoke one or more of our call-
     * backs as decoded data become available.  We optionally call Sleep() for
     * one second per iteration to simulate downloading the image via an analog
     * modem. */

 for (;;) {
 Trace((stderr, "about to call readpng2_decode_data()\n"))
 if (readpng2_decode_data(&rpng2_info, inbuf, incount))
 ++error;
 Trace((stderr, "done with readpng2_decode_data()\n"))

 if (error || incount != INBUFSIZE || rpng2_info.state == kDone) {
 if (rpng2_info.state == kDone) {
 Trace((stderr, "done decoding PNG image\n"))
 } else if (ferror(infile)) {
                fprintf(stderr, PROGNAME
 ":  error while reading PNG image file\n");
                exit(3);
 } else if (feof(infile)) {
                fprintf(stderr, PROGNAME ":  end of file reached "
 "(unexpectedly) while reading PNG image file\n");
                exit(3);
 } else /* if (error) */ {
 /* will print error message below */
 }
 break;
 }

 if (timing)
 Sleep(1000L);

        incount = fread(inbuf, 1, INBUFSIZE, infile);
 }


 /* clean up PNG stuff and report any decoding errors */

    fclose(infile);
 Trace((stderr, "about to call readpng2_cleanup()\n"))
    readpng2_cleanup(&rpng2_info);

 if (error) {
        fprintf(stderr, PROGNAME ":  libpng error while decoding PNG image\n");
        exit(3);
 }


 /* wait for the user to tell us when to quit */

 while (GetMessage(&msg, NULL, 0, 0)) {
 TranslateMessage(&msg);
 DispatchMessage(&msg);
 }


 /* we're done:  clean up all image and Windows resources and go away */

 Trace((stderr, "about to call rpng2_win_cleanup()\n"))
    rpng2_win_cleanup();

 return msg.wParam;
}

chrm_modification_init(chrm_modification *me, png_modifier *pm,
   PNG_CONST color_encoding *encoding)
{
CIE_color white = white_point(encoding);

/* Original end points: */
me->encoding = encoding;

/* Chromaticities (in fixed point): */
me->wx = fix(chromaticity_x(white));
me->wy = fix(chromaticity_y(white));

me->rx = fix(chromaticity_x(encoding->red));
me->ry = fix(chromaticity_y(encoding->red));
me->gx = fix(chromaticity_x(encoding->green));
me->gy = fix(chromaticity_y(encoding->green));
me->bx = fix(chromaticity_x(encoding->blue));
me->by = fix(chromaticity_y(encoding->blue));

modification_init(&me->this);
me->this.chunk = CHUNK_cHRM;
me->this.modify_fn = chrm_modify;
me->this.add = CHUNK_PLTE;
me->this.next = pm->modifications;
pm->modifications = &me->this;
}

validate_T(void)
/* Validate the above table - this just builds the above values */

{
unsigned int i;

   for (i=0; i<TTABLE_SIZE; ++i)
{
if (transform_info[i].when & TRANSFORM_R)
read_transforms |= transform_info[i].transform;

if (transform_info[i].when & TRANSFORM_W)
write_transforms |= transform_info[i].transform;
}

/* Reversible transforms are those which are supported on both read and
* write.
*/
rw_transforms = read_transforms & write_transforms;
}

void readpng2_cleanup(mainprog_info *mainprog_ptr)
{
    png_structp png_ptr = (png_structp)mainprog_ptr->png_ptr;
    png_infop info_ptr = (png_infop)mainprog_ptr->info_ptr;

 if (png_ptr && info_ptr)
        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);

    mainprog_ptr->png_ptr = NULL;
    mainprog_ptr->info_ptr = NULL;
}

png_uint_32 get_value (FILE *pnm_file, int depth)
{
 static png_uint_32 mask = 0;
  png_byte token[16];
 unsigned long ul_ret_value;
  png_uint_32 ret_value;
 int i = 0;

 if (mask == 0)
 for (i = 0; i < depth; i++)
      mask = (mask << 1) | 0x01;

  get_token (pnm_file, (char *) token);
  sscanf ((const char *) token, "%lu", &ul_ret_value);
  ret_value = (png_uint_32) ul_ret_value;

  ret_value &= mask;

 if (depth < 8)
 for (i = 0; i < (8 / depth); i++)
      ret_value = (ret_value << depth) || ret_value;

 return ret_value;
}

first_transform(int transforms)
{
 return transforms & -transforms; /* lowest set bit */
}

freebuffer(Image *image)
{
 if (image->buffer) free(image->buffer);
   image->buffer = NULL;
   image->bufsize = 0;
   image->allocsize = 0;
}

make_size(png_store* PNG_CONST ps, png_byte PNG_CONST colour_type, int bdlo,
    int PNG_CONST bdhi)
{
for (; bdlo <= bdhi; ++bdlo)
{
png_uint_32 width;

for (width = 1; width <= 16; ++width)
{
png_uint_32 height;

for (height = 1; height <= 16; ++height)
{
/* The four combinations of DIY interlace and interlace or not -
* no interlace + DIY should be identical to no interlace with
* libpng doing it.
*/
make_size_image(ps, colour_type, DEPTH(bdlo), PNG_INTERLACE_NONE,
width, height, 0);
make_size_image(ps, colour_type, DEPTH(bdlo), PNG_INTERLACE_NONE,
width, height, 1);

#        ifdef PNG_WRITE_INTERLACING_SUPPORTED
make_size_image(ps, colour_type, DEPTH(bdlo), PNG_INTERLACE_ADAM7,
width, height, 0);
make_size_image(ps, colour_type, DEPTH(bdlo), PNG_INTERLACE_ADAM7,
width, height, 1);
#        endif
}
}
}
}

image_transform_png_set_expand_gray_1_2_4_to_8_mod(
    PNG_CONST image_transform *this, image_pixel *that, png_const_structp pp,
    PNG_CONST transform_display *display)
{
image_transform_png_set_expand_mod(this, that, pp, display);
}

image_transform_png_set_gray_to_rgb_mod(PNG_CONST image_transform *this,
image_pixel *that, png_const_structp pp,
    PNG_CONST transform_display *display)
{
/* NOTE: we can actually pend the tRNS processing at this point because we
* can correctly recognize the original pixel value even though we have
* mapped the one gray channel to the three RGB ones, but in fact libpng

* doesn't do this, so we don't either.
*/
if ((that->colour_type & PNG_COLOR_MASK_COLOR) == 0 && that->have_tRNS)
      image_pixel_add_alpha(that, &display->this);

/* Simply expand the bit depth and alter the colour type as required. */
if (that->colour_type == PNG_COLOR_TYPE_GRAY)
{
/* RGB images have a bit depth at least equal to '8' */
if (that->bit_depth < 8)
that->sample_depth = that->bit_depth = 8;

/* And just changing the colour type works here because the green and blue
* channels are being maintained in lock-step with the red/gray:
*/
that->colour_type = PNG_COLOR_TYPE_RGB;
}

else if (that->colour_type == PNG_COLOR_TYPE_GRAY_ALPHA)
that->colour_type = PNG_COLOR_TYPE_RGB_ALPHA;

this->next->mod(this->next, that, pp, display);
}

insert_hIST(png_structp png_ptr, png_infop info_ptr, int nparams, png_charpp params)
 {
    int i;
    png_uint_16 freq[256];

 /* libpng takes the count from the PLTE count; we don't check it here but we
    * do set the array to 0 for unspecified entries.
    */
   memset(freq, 0, sizeof freq);
 for (i=0; i<nparams; ++i)
 {
 char *endptr = NULL;
 unsigned long int l = strtoul(params[i], &endptr, 0/*base*/);

 if (params[i][0] && *endptr == 0 && l <= 65535)
         freq[i] = (png_uint_16)l;

 else
 {
         fprintf(stderr, "hIST[%d]: %s: invalid frequency\n", i, params[i]);
         exit(1);
 }
 }


    png_set_hIST(png_ptr, info_ptr, freq);
 }

perform_gamma_test(png_modifier *pm, int summary)
{
 /*TODO: remove this*/
 /* Save certain values for the temporary overrides below. */
 unsigned int calculations_use_input_precision =
      pm->calculations_use_input_precision;
#  ifdef PNG_READ_BACKGROUND_SUPPORTED
 double maxout8 = pm->maxout8;
#  endif

 /* First some arbitrary no-transform tests: */
 if (!pm->this.speed && pm->test_gamma_threshold)
 {
      perform_gamma_threshold_tests(pm);

 if (fail(pm))
 return;
 }

 /* Now some real transforms. */
 if (pm->test_gamma_transform)
 {
 if (summary)
 {
         fflush(stderr);
         printf("Gamma correction error summary\n\n");
         printf("The printed value is the maximum error in the pixel values\n");
         printf("calculated by the libpng gamma correction code.  The error\n");
         printf("is calculated as the difference between the output pixel\n");
         printf("value (always an integer) and the ideal value from the\n");
         printf("libpng specification (typically not an integer).\n\n");

         printf("Expect this value to be less than .5 for 8 bit formats,\n");
         printf("less than 1 for formats with fewer than 8 bits and a small\n");
         printf("number (typically less than 5) for the 16 bit formats.\n");
         printf("For performance reasons the value for 16 bit formats\n");
         printf("increases when the image file includes an sBIT chunk.\n");
         fflush(stdout);
 }

      init_gamma_errors(pm);
 /*TODO: remove this.  Necessary because the current libpng
       * implementation works in 8 bits:
       */
 if (pm->test_gamma_expand16)
         pm->calculations_use_input_precision = 1;
      perform_gamma_transform_tests(pm);
 if (!calculations_use_input_precision)
         pm->calculations_use_input_precision = 0;

 if (summary)
         summarize_gamma_errors(pm, 0/*who*/, 1/*low bit depth*/, 1/*indexed*/);

 if (fail(pm))
 return;
 }

 /* The sbit tests produce much larger errors: */
 if (pm->test_gamma_sbit)
 {
      init_gamma_errors(pm);
      perform_gamma_sbit_tests(pm);

 if (summary)
         summarize_gamma_errors(pm, "sBIT", pm->sbitlow < 8U, 1/*indexed*/);

 if (fail(pm))
 return;
 }

#ifdef DO_16BIT /* Should be READ_16BIT_SUPPORTED */
 if (pm->test_gamma_scale16)
 {
 /* The 16 to 8 bit strip operations: */
      init_gamma_errors(pm);
      perform_gamma_scale16_tests(pm);

 if (summary)
 {
         fflush(stderr);
         printf("\nGamma correction with 16 to 8 bit reduction:\n");
         printf(" 16 bit gray:  %.5f\n", pm->error_gray_16);
         printf(" 16 bit color: %.5f\n", pm->error_color_16);
         fflush(stdout);
 }

 if (fail(pm))
 return;
 }
#endif

#ifdef PNG_READ_BACKGROUND_SUPPORTED
 if (pm->test_gamma_background)
 {
      init_gamma_errors(pm);

 /*TODO: remove this.  Necessary because the current libpng
       * implementation works in 8 bits:
       */
 if (pm->test_gamma_expand16)
 {
         pm->calculations_use_input_precision = 1;
         pm->maxout8 = .499; /* because the 16 bit background is smashed */
 }
      perform_gamma_composition_tests(pm, PNG_BACKGROUND_GAMMA_UNIQUE,
         pm->test_gamma_expand16);
 if (!calculations_use_input_precision)
         pm->calculations_use_input_precision = 0;
      pm->maxout8 = maxout8;

 if (summary)
         summarize_gamma_errors(pm, "background", 1, 0/*indexed*/);

 if (fail(pm))
 return;
 }
#endif

#ifdef PNG_READ_ALPHA_MODE_SUPPORTED
 if (pm->test_gamma_alpha_mode)
 {
 int do_background;

      init_gamma_errors(pm);

 /*TODO: remove this.  Necessary because the current libpng
       * implementation works in 8 bits:
       */
 if (pm->test_gamma_expand16)
         pm->calculations_use_input_precision = 1;
 for (do_background = ALPHA_MODE_OFFSET + PNG_ALPHA_STANDARD;
         do_background <= ALPHA_MODE_OFFSET + PNG_ALPHA_BROKEN && !fail(pm);
 ++do_background)
         perform_gamma_composition_tests(pm, do_background,
            pm->test_gamma_expand16);
 if (!calculations_use_input_precision)
         pm->calculations_use_input_precision = 0;

 if (summary)
         summarize_gamma_errors(pm, "alpha mode", 1, 0/*indexed*/);

 if (fail(pm))
 return;
 }
#endif
}

standard_name(char *buffer, size_t bufsize, size_t pos, png_byte colour_type,
int bit_depth, unsigned int npalette, int interlace_type,

png_uint_32 w, png_uint_32 h, int do_interlace)
{
pos = safecat(buffer, bufsize, pos, colour_types[colour_type]);
   if (npalette > 0)
{
pos = safecat(buffer, bufsize, pos, "[");
pos = safecatn(buffer, bufsize, pos, npalette);
pos = safecat(buffer, bufsize, pos, "]");
}
pos = safecat(buffer, bufsize, pos, " ");
pos = safecatn(buffer, bufsize, pos, bit_depth);
pos = safecat(buffer, bufsize, pos, " bit");

if (interlace_type != PNG_INTERLACE_NONE)
{
pos = safecat(buffer, bufsize, pos, " interlaced");
if (do_interlace)
pos = safecat(buffer, bufsize, pos, "(pngvalid)");
else
pos = safecat(buffer, bufsize, pos, "(libpng)");
}

if (w > 0 || h > 0)
{
pos = safecat(buffer, bufsize, pos, " ");
pos = safecatn(buffer, bufsize, pos, w);
pos = safecat(buffer, bufsize, pos, "x");
pos = safecatn(buffer, bufsize, pos, h);
}

return pos;
}

max_window_bits(uarbc size, int ndigits)
 /* Return the zlib stream window bits required for data of the given size. */
{
   png_uint_16 cb;

 if (ndigits > 1)
 return 15;

   cb = size[0];

 if (cb > 16384) return 15;
 if (cb > 8192) return 14;
 if (cb > 4096) return 13;
 if (cb > 2048) return 12;
 if (cb > 1024) return 11;
 if (cb > 512) return 10;
 if (cb > 256) return 9;
 return 8;
}

 buffer_extend(struct buffer_list *current)
 {
 struct buffer_list *add;

   assert(current->next == NULL);

   add = NEW(struct buffer_list);
 if (add == NULL)
 return NULL;

   add->next = NULL;
   current->next = add;

 return add;
}

static void perform_gamma_transform_tests(png_modifier *pm)
{
png_byte colour_type = 0;

png_byte bit_depth = 0;
unsigned int palette_number = 0;

   while (next_format(&colour_type, &bit_depth, &palette_number, 1/*gamma*/))
{
unsigned int i, j;

for (i=0; i<pm->ngamma_tests; ++i) for (j=0; j<pm->ngamma_tests; ++j)
if (i != j)
{
gamma_transform_test(pm, colour_type, bit_depth, palette_number,
pm->interlace_type, 1/pm->gammas[i], pm->gammas[j], 0/*sBIT*/,
pm->use_input_precision, 0 /*do not scale16*/);

if (fail(pm))
return;
}
}
}

png_col_in_interlace_pass(png_uint_32 x, int pass)
{
 /* Is column 'x' in pass 'pass'? */
 int y;
   x &= 7;
 ++pass;
 for (y=0; y<8; ++y) if (adam7[y][x] == pass)
 return 1;

 return 0;
}

png_read_filter_row_avg4_neon(png_row_infop row_info, png_bytep row,
   png_const_bytep prev_row)
{
   png_bytep rp = row;
   png_bytep rp_stop = row + row_info->rowbytes;
   png_const_bytep pp = prev_row;

 uint8x8x4_t vdest;
   vdest.val[3] = vdup_n_u8(0);

 for (; rp < rp_stop; rp += 16, pp += 16)
 {
 uint32x2x4_t vtmp;
 uint8x8x4_t *vrpt, *vppt;
 uint8x8x4_t vrp, vpp;
 uint32x2x4_t *temp_pointer;

      vtmp = vld4_u32(png_ptr(uint32_t,rp));
      vrpt = png_ptr(uint8x8x4_t,&vtmp);
      vrp = *vrpt;
      vtmp = vld4_u32(png_ptrc(uint32_t,pp));
      vppt = png_ptr(uint8x8x4_t,&vtmp);
      vpp = *vppt;

      vdest.val[0] = vhadd_u8(vdest.val[3], vpp.val[0]);
      vdest.val[0] = vadd_u8(vdest.val[0], vrp.val[0]);
      vdest.val[1] = vhadd_u8(vdest.val[0], vpp.val[1]);
      vdest.val[1] = vadd_u8(vdest.val[1], vrp.val[1]);
      vdest.val[2] = vhadd_u8(vdest.val[1], vpp.val[2]);
      vdest.val[2] = vadd_u8(vdest.val[2], vrp.val[2]);
      vdest.val[3] = vhadd_u8(vdest.val[2], vpp.val[3]);
      vdest.val[3] = vadd_u8(vdest.val[3], vrp.val[3]);

      vst4_lane_u32(png_ptr(uint32_t,rp), png_ldr(uint32x2x4_t,&vdest), 0);
 }
}

generate_row(png_bytep row, size_t rowbytes, unsigned int y, int color_type,
int bit_depth, png_const_bytep gamma_table, double conv,
   unsigned int *colors)
{
   png_uint_32 size_max = image_size_of_type(color_type, bit_depth, colors)-1;
png_uint_32 depth_max = (1U << bit_depth)-1; /* up to 65536 */

   if (colors[0] == 0) switch (channels_of_type(color_type))
{
/* 1 channel: a square image with a diamond, the least luminous colors are on
*    the edge of the image, the most luminous in the center.
*/
case 1:
{
png_uint_32 x;
png_uint_32 base = 2*size_max - abs(2*y-size_max);

for (x=0; x<=size_max; ++x)
{
png_uint_32 luma = base - abs(2*x-size_max);

/* 'luma' is now in the range 0..2*size_max, we need
* 0..depth_max
*/
luma = (luma*depth_max + size_max) / (2*size_max);
set_value(row, rowbytes, x, bit_depth, luma, gamma_table, conv);
}
}
break;

/* 2 channels: the color channel increases in luminosity from top to bottom,
*    the alpha channel increases in opacity from left to right.
*/
case 2:
{
png_uint_32 alpha = (depth_max * y * 2 + size_max) / (2 * size_max);
png_uint_32 x;

for (x=0; x<=size_max; ++x)
{
set_value(row, rowbytes, 2*x, bit_depth,
(depth_max * x * 2 + size_max) / (2 * size_max), gamma_table,
conv);
set_value(row, rowbytes, 2*x+1, bit_depth, alpha, gamma_table,
conv);
}
}
break;

/* 3 channels: linear combinations of, from the top-left corner clockwise,
*    black, green, white, red.
*/
case 3:
{
/* x0: the black->red scale (the value of the red component) at the
*     start of the row (blue and green are 0).
* x1: the green->white scale (the value of the red and blue
*     components at the end of the row; green is depth_max).
*/
png_uint_32 Y = (depth_max * y * 2 + size_max) / (2 * size_max);
png_uint_32 x;

/* Interpolate x/depth_max from start to end:
*
*        start end         difference
* red:     Y    Y            0
* green:   0   depth_max   depth_max
* blue:    0    Y            Y
*/
for (x=0; x<=size_max; ++x)
{
set_value(row, rowbytes, 3*x+0, bit_depth, /* red */ Y,
gamma_table, conv);
set_value(row, rowbytes, 3*x+1, bit_depth, /* green */
(depth_max * x * 2 + size_max) / (2 * size_max),
gamma_table, conv);
set_value(row, rowbytes, 3*x+2, bit_depth, /* blue */
(Y * x * 2 + size_max) / (2 * size_max),
gamma_table, conv);
}
}
break;

/* 4 channels: linear combinations of, from the top-left corner clockwise,
*    transparent, red, green, blue.
*/
case 4:
{
/* x0: the transparent->blue scale (the value of the blue and alpha
*     components) at the start of the row (red and green are 0).
* x1: the red->green scale (the value of the red and green
*     components at the end of the row; blue is 0 and alpha is
*     depth_max).
*/
png_uint_32 Y = (depth_max * y * 2 + size_max) / (2 * size_max);
png_uint_32 x;

/* Interpolate x/depth_max from start to end:
*
*        start    end       difference
* red:     0   depth_max-Y depth_max-Y
* green:   0       Y             Y
* blue:    Y       0            -Y
* alpha:   Y    depth_max  depth_max-Y
*/
for (x=0; x<=size_max; ++x)
{
set_value(row, rowbytes, 4*x+0, bit_depth, /* red */
((depth_max-Y) * x * 2 + size_max) / (2 * size_max),
gamma_table, conv);
set_value(row, rowbytes, 4*x+1, bit_depth, /* green */
(Y * x * 2 + size_max) / (2 * size_max),
gamma_table, conv);
set_value(row, rowbytes, 4*x+2, bit_depth, /* blue */
Y - (Y * x * 2 + size_max) / (2 * size_max),
gamma_table, conv);
set_value(row, rowbytes, 4*x+3, bit_depth, /* alpha */
Y + ((depth_max-Y) * x * 2 + size_max) / (2 * size_max),
gamma_table, conv);
}
}
break;

default:
fprintf(stderr, "makepng: internal bad channel count\n");
exit(2);
}

else if (color_type & PNG_COLOR_MASK_PALETTE)
{
/* Palette with fixed color: the image rows are all 0 and the image width
* is 16.
*/
memset(row, 0, rowbytes);
}

else if (colors[0] == channels_of_type(color_type))
switch (channels_of_type(color_type))
{
case 1:
{
const png_uint_32 luma = colors[1];
png_uint_32 x;

for (x=0; x<=size_max; ++x)
set_value(row, rowbytes, x, bit_depth, luma, gamma_table,
conv);
}
break;

case 2:
{
const png_uint_32 luma = colors[1];
const png_uint_32 alpha = colors[2];
png_uint_32 x;

for (x=0; x<size_max; ++x)
{
set_value(row, rowbytes, 2*x, bit_depth, luma, gamma_table,
conv);
set_value(row, rowbytes, 2*x+1, bit_depth, alpha, gamma_table,
conv);
}
}
break;

case 3:
{
const png_uint_32 red = colors[1];
const png_uint_32 green = colors[2];
const png_uint_32 blue = colors[3];
png_uint_32 x;

for (x=0; x<=size_max; ++x)
{
set_value(row, rowbytes, 3*x+0, bit_depth, red, gamma_table,
conv);
set_value(row, rowbytes, 3*x+1, bit_depth, green, gamma_table,
conv);
set_value(row, rowbytes, 3*x+2, bit_depth, blue, gamma_table,
conv);
}
}
break;

case 4:
{
const png_uint_32 red = colors[1];
const png_uint_32 green = colors[2];
const png_uint_32 blue = colors[3];
const png_uint_32 alpha = colors[4];
png_uint_32 x;

for (x=0; x<=size_max; ++x)
{
set_value(row, rowbytes, 4*x+0, bit_depth, red, gamma_table,
conv);
set_value(row, rowbytes, 4*x+1, bit_depth, green, gamma_table,
conv);
set_value(row, rowbytes, 4*x+2, bit_depth, blue, gamma_table,
conv);
set_value(row, rowbytes, 4*x+3, bit_depth, alpha, gamma_table,
conv);
}
}
break;

default:
fprintf(stderr, "makepng: internal bad channel count\n");
exit(2);
}

else
{
fprintf(stderr,
"makepng: --color: count(%u) does not match channels(%u)\n",

colors[0], channels_of_type(color_type));
exit(1);
}
}

init_gamma_errors(png_modifier *pm)
{
 /* Use -1 to catch tests that were not actually run */
   pm->error_gray_2 = pm->error_gray_4 = pm->error_gray_8 = -1.;
   pm->error_color_8 = -1.;
   pm->error_indexed = -1.;
   pm->error_gray_16 = pm->error_color_16 = -1.;
}

standard_rowsize(png_const_structp pp, png_uint_32 id)
{
   png_uint_32 width = standard_width(pp, id);

 /* This won't overflow: */
   width *= bit_size(pp, COL_FROM_ID(id), DEPTH_FROM_ID(id));
 return (width + 7) / 8;
}

check_param_count(int nparams, int expect)
{
 if (nparams != expect)
 {
      fprintf(stderr, "bad parameter count (internal error)\n");
      exit(1);
 }
}

int main(int argc, const char **argv)
{
 /* This program uses the default, <setjmp.h> based, libpng error handling
    * mechanism, therefore any local variable that exists before the call to
    * setjmp and is changed after the call to setjmp returns successfully must
    * be declared with 'volatile' to ensure that their values don't get
    * destroyed by longjmp:
    */
 volatile int result = 1/*fail*/;

 if (argc == 4)
 {
 long x = atol(argv[1]);
 long y = atol(argv[2]);
 FILE *f = fopen(argv[3], "rb");
 volatile png_bytep row = NULL;

 if (f != NULL)
 {
 /* libpng requires a callback function for handling errors; this
          * callback must not return.  The default callback function uses a
          * stored <setjmp.h> style jmp_buf which is held in a png_struct and
          * writes error messages to stderr.  Creating the png_struct is a
          * little tricky; just copy the following code.
          */
         png_structp png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING,
            NULL, NULL, NULL);

 if (png_ptr != NULL)
 {
            png_infop info_ptr = png_create_info_struct(png_ptr);

 if (info_ptr != NULL)
 {
 /* Declare stack variables to hold pointers to locally allocated
                * data.
                */

 /* Initialize the error control buffer: */
 if (setjmp(png_jmpbuf(png_ptr)) == 0)
 {
                  png_uint_32 width, height;
 int bit_depth, color_type, interlace_method,
                     compression_method, filter_method;
                  png_bytep row_tmp;

 /* Now associate the recently opened (FILE*) with the default
                   * libpng initialization functions.  Sometimes libpng is
                   * compiled without stdio support (it can be difficult to do
                   * in some environments); in that case you will have to write
                   * your own read callback to read data from the (FILE*).
                   */
                  png_init_io(png_ptr, f);

 /* And read the first part of the PNG file - the header and
                   * all the information up to the first pixel.
                   */
                  png_read_info(png_ptr, info_ptr);

 /* This fills in enough information to tell us the width of
                   * each row in bytes, allocate the appropriate amount of
                   * space.  In this case png_malloc is used - it will not
                   * return if memory isn't available.
                   */
                  row = png_malloc(png_ptr, png_get_rowbytes(png_ptr,
                     info_ptr));

 /* To avoid the overhead of using a volatile auto copy row_tmp
                   * to a local here - just use row for the png_free below.
                   */
                  row_tmp = row;

 /* All the information we need is in the header is returned by
                   * png_get_IHDR, if this fails we can now use 'png_error' to
                   * signal the error and return control to the setjmp above.
                   */
 if (png_get_IHDR(png_ptr, info_ptr, &width, &height,
 &bit_depth, &color_type, &interlace_method,
 &compression_method, &filter_method))
 {
 int passes, pass;

 /* png_set_interlace_handling returns the number of
                      * passes required as well as turning on libpng's
                      * handling, but since we do it ourselves this is
                      * necessary:
                      */
 switch (interlace_method)
 {
 case PNG_INTERLACE_NONE:
                           passes = 1;
 break;

 case PNG_INTERLACE_ADAM7:
                           passes = PNG_INTERLACE_ADAM7_PASSES;
 break;

 default:
                           png_error(png_ptr, "pngpixel: unknown interlace");
 }

 /* Now read the pixels, pass-by-pass, row-by-row: */
                     png_start_read_image(png_ptr);

 for (pass=0; pass<passes; ++pass)
 {
                        png_uint_32 ystart, xstart, ystep, xstep;
                        png_uint_32 py;

 if (interlace_method == PNG_INTERLACE_ADAM7)
 {
 /* Sometimes the whole pass is empty because the
                            * image is too narrow or too short.  libpng
                            * expects to be called for each row that is
                            * present in the pass, so it may be necessary to
                            * skip the loop below (over py) if the image is
                            * too narrow.
                            */
 if (PNG_PASS_COLS(width, pass) == 0)
 continue;

 /* We need the starting pixel and the offset
                            * between each pixel in this pass; use the macros
                            * in png.h:
                            */
                           xstart = PNG_PASS_START_COL(pass);
                           ystart = PNG_PASS_START_ROW(pass);
                           xstep = PNG_PASS_COL_OFFSET(pass);
                           ystep = PNG_PASS_ROW_OFFSET(pass);
 }

 else
 {
                           ystart = xstart = 0;
                           ystep = xstep = 1;
 }

 /* To find the pixel, loop over 'py' for each pass
                         * reading a row and then checking to see if it
                         * contains the pixel.
                         */
 for (py = ystart; py < height; py += ystep)
 {
                           png_uint_32 px, ppx;

 /* png_read_row takes two pointers.  When libpng
                            * handles the interlace the first is filled in
                            * pixel-by-pixel, and the second receives the same
                            * pixels but they are replicated across the
                            * unwritten pixels so far for each pass.  When we
                            * do the interlace, however, they just contain
                            * the pixels from the interlace pass - giving
                            * both is wasteful and pointless, so we pass a
                            * NULL pointer.
                            */
                           png_read_row(png_ptr, row_tmp, NULL);

 /* Now find the pixel if it is in this row; there
                            * are, of course, much better ways of doing this
                            * than using a for loop:
                            */
 if (y == py) for (px = xstart, ppx = 0;
                              px < width; px += xstep, ++ppx) if (x == px)
 {
 /* 'ppx' is the index of the pixel in the row
                               * buffer.
                               */
                              print_pixel(png_ptr, info_ptr, row_tmp, ppx);

 /* Now terminate the loops early - we have
                               * found and handled the required data.
                               */
 goto pass_loop_end;
 } /* x loop */
 } /* y loop */
 } /* pass loop */

 /* Finally free the temporary buffer: */
                  pass_loop_end:
                     row = NULL;
                     png_free(png_ptr, row_tmp);
 }

 else
                     png_error(png_ptr, "pngpixel: png_get_IHDR failed");

 }

 else
 {
 /* Else libpng has raised an error.  An error message has
                   * already been output, so it is only necessary to clean up
                   * locally allocated data:
                   */
 if (row != NULL)
 {
 /* The default implementation of png_free never errors out
                      * (it just crashes if something goes wrong), but the safe
                      * way of using it is still to clear 'row' before calling
                      * png_free:
                      */
                     png_bytep row_tmp = row;
                     row = NULL;
                     png_free(png_ptr, row_tmp);
 }
 }

               png_destroy_info_struct(png_ptr, &info_ptr);
 }

 else
               fprintf(stderr, "pngpixel: out of memory allocating png_info\n");

            png_destroy_read_struct(&png_ptr, NULL, NULL);
 }

 else
            fprintf(stderr, "pngpixel: out of memory allocating png_struct\n");
 }

 else
         fprintf(stderr, "pngpixel: %s: could not open file\n", argv[3]);
 }

 else
 /* Wrong number of arguments */
      fprintf(stderr, "pngpixel: usage: pngpixel x y png-file\n");

 
    return result;
 }

main(void)
{
fprintf(stderr,
"pngfix needs libpng with a zlib >=1.2.4 (not 0x%x)\n",
      PNG_ZLIB_VERNUM);
return 77;
}

gpc_preq(Pixel *out, const Pixel *in, const Background *back)
{
 (void)back;

   out->r = ilineara(in->r, in->a);

 if (in->g == in->r)
 {
      out->g = out->r;

 if (in->b == in->r)
         out->b = out->r;

 else
         out->b = ilineara(in->b, in->a);
 }

 else
 {
      out->g = ilineara(in->g, in->a);

 if (in->b == in->r)
         out->b = out->r;

 else if (in->b == in->g)
         out->b = out->g;

 else
         out->b = ilineara(in->b, in->a);
 }

   out->a = 65535;
}

static int format_isset(format_list *pf, png_uint_32 format)
{
 return format < FORMAT_COUNT &&
 (pf->bits[format >> 5] & (((png_uint_32)1) << (format & 31))) != 0;
}

formatof(const char *arg)
{
 char *ep;
 unsigned long format = strtoul(arg, &ep, 0);

 if (ep > arg && *ep == 0 && format < FORMAT_COUNT)
 return (png_uint_32)format;

 else for (format=0; format < FORMAT_COUNT; ++format)
 {
 if (strcmp(format_names[format], arg) == 0)
 return (png_uint_32)format;
 }

   fprintf(stderr, "pngstest: format name '%s' invalid\n", arg);
 return FORMAT_COUNT;
}

image_transform_png_set_rgb_to_gray_ini(PNG_CONST image_transform *this,
transform_display *that)
{
png_modifier *pm = that->pm;
   PNG_CONST color_encoding *e = pm->current_encoding;

UNUSED(this)

/* Since we check the encoding this flag must be set: */
pm->test_uses_encoding = 1;

/* If 'e' is not NULL chromaticity information is present and either a cHRM
* or an sRGB chunk will be inserted.
*/
if (e != 0)
{

/* Coefficients come from the encoding, but may need to be normalized to a
* white point Y of 1.0
*/
      PNG_CONST double whiteY = e->red.Y + e->green.Y + e->blue.Y;

data.red_coefficient = e->red.Y;
data.green_coefficient = e->green.Y;
data.blue_coefficient = e->blue.Y;

if (whiteY != 1)
{
data.red_coefficient /= whiteY;
data.green_coefficient /= whiteY;
data.blue_coefficient /= whiteY;
}
}


else
{
/* The default (built in) coeffcients, as above: */
      data.red_coefficient = 6968 / 32768.;
      data.green_coefficient = 23434 / 32768.;
      data.blue_coefficient = 2366 / 32768.;
}

data.gamma = pm->current_gamma;

/* If not set then the calculations assume linear encoding (implicitly): */
if (data.gamma == 0)
data.gamma = 1;

/* The arguments to png_set_rgb_to_gray can override the coefficients implied
* by the color space encoding.  If doing exhaustive checks do the override
* in each case, otherwise do it randomly.
*/
if (pm->test_exhaustive)
{
/* First time in coefficients_overridden is 0, the following sets it to 1,
* so repeat if it is set.  If a test fails this may mean we subsequently
* skip a non-override test, ignore that.
*/
data.coefficients_overridden = !data.coefficients_overridden;
pm->repeat = data.coefficients_overridden != 0;
}

else
data.coefficients_overridden = random_choice();

if (data.coefficients_overridden)
{
/* These values override the color encoding defaults, simply use random
* numbers.
*/
png_uint_32 ru;
double total;

RANDOMIZE(ru);
data.green_coefficient = total = (ru & 0xffff) / 65535.;
ru >>= 16;
data.red_coefficient = (1 - total) * (ru & 0xffff) / 65535.;
total += data.red_coefficient;
data.blue_coefficient = 1 - total;

#     ifdef PNG_FLOATING_POINT_SUPPORTED
data.red_to_set = data.red_coefficient;
data.green_to_set = data.green_coefficient;
#     else
data.red_to_set = fix(data.red_coefficient);
data.green_to_set = fix(data.green_coefficient);
#     endif

/* The following just changes the error messages: */
pm->encoding_ignored = 1;
}

else
{
data.red_to_set = -1;
data.green_to_set = -1;
}

/* Adjust the error limit in the png_modifier because of the larger errors
* produced in the digitization during the gamma handling.
*/
if (data.gamma != 1) /* Use gamma tables */
{
if (that->this.bit_depth == 16 || pm->assume_16_bit_calculations)
{
/* The computations have the form:
*
*    r * rc + g * gc + b * bc
*
*  Each component of which is +/-1/65535 from the gamma_to_1 table
*  lookup, resulting in a base error of +/-6.  The gamma_from_1

*  conversion adds another +/-2 in the 16-bit case and
*  +/-(1<<(15-PNG_MAX_GAMMA_8)) in the 8-bit case.
*/
that->pm->limit += pow(
#           if PNG_MAX_GAMMA_8 < 14
               (that->this.bit_depth == 16 ? 8. :
                  6. + (1<<(15-PNG_MAX_GAMMA_8)))
#           else
               8.
#           endif
               /65535, data.gamma);
}

else
{
/* Rounding to 8 bits in the linear space causes massive errors which
* will trigger the error check in transform_range_check.  Fix that
* here by taking the gamma encoding into account.
*

* When DIGITIZE is set because a pre-1.7 version of libpng is being
* tested allow a bigger slack.
*
          * NOTE: this magic number was determined by experiment to be 1.1 (when
          * using fixed point arithmetic).  There's no great merit to the value
          * below, however it only affects the limit used for checking for
          * internal calculation errors, not the actual limit imposed by
          * pngvalid on the output errors.
*/
that->pm->limit += pow(
#           if DIGITIZE
               1.1
#           else
               1.
#           endif
               /255, data.gamma);
}
}

else
{
/* With no gamma correction a large error comes from the truncation of the
* calculation in the 8 bit case, allow for that here.
*/
if (that->this.bit_depth != 16 && !pm->assume_16_bit_calculations)
that->pm->limit += 4E-3;
}

}

main(int argc, char **argv)
{
 int i;
 int extracted = 0;

 for (i=1; i<argc; ++i)
 {
 if (strcmp(argv[i], "-q") == 0)
         verbose = 0;

 else if (extract_one_file(argv[i]))
         extracted = 1;
 }


    /* Exit code is true if any extract succeeds */
    return extracted == 0;
 }

gamma_display_init(gamma_display *dp, png_modifier *pm, png_uint_32 id,
double file_gamma, double screen_gamma, png_byte sbit, int threshold_test,
int use_input_precision, int scale16, int expand16,
    int do_background, PNG_CONST png_color_16 *pointer_to_the_background_color,
double background_gamma)
{
/* Standard fields */
   standard_display_init(&dp->this, &pm->this, id, 0/*do_interlace*/,
pm->use_update_info);

/* Parameter fields */
dp->pm = pm;
dp->file_gamma = file_gamma;
dp->screen_gamma = screen_gamma;
dp->background_gamma = background_gamma;
dp->sbit = sbit;
dp->threshold_test = threshold_test;
dp->use_input_precision = use_input_precision;
dp->scale16 = scale16;
dp->expand16 = expand16;
dp->do_background = do_background;
if (do_background && pointer_to_the_background_color != 0)
dp->background_color = *pointer_to_the_background_color;
else
memset(&dp->background_color, 0, sizeof dp->background_color);

/* Local variable fields */
dp->maxerrout = dp->maxerrpc = dp->maxerrabs = 0;
}

ancillary(const char *name)
{

    return PNG_CHUNK_ANCILLARY(PNG_U32(name[0], name[1], name[2], name[3]));
 }

gpc_sRGB(Pixel *out, const Pixel *in, const Background *back)
{
 (void)back;

   out->r = isRGB(in->r);

 if (in->g == in->r)
 {
      out->g = out->r;

 if (in->b == in->r)
         out->b = out->r;

 else
         out->b = isRGB(in->b);
 }

 else
 {
      out->g = isRGB(in->g);

 if (in->b == in->r)
         out->b = out->r;

 else if (in->b == in->g)
         out->b = out->g;

 else
         out->b = isRGB(in->b);
 }

   out->a = 255;
}

png_read_filter_row_paeth4_neon(png_row_infop row_info, png_bytep row,
   png_const_bytep prev_row)
{
   png_bytep rp = row;
   png_bytep rp_stop = row + row_info->rowbytes;
   png_const_bytep pp = prev_row;

 uint8x8_t vlast = vdup_n_u8(0);
 uint8x8x4_t vdest;
   vdest.val[3] = vdup_n_u8(0);

 for (; rp < rp_stop; rp += 16, pp += 16)
 {
 uint32x2x4_t vtmp;
 uint8x8x4_t *vrpt, *vppt;
 uint8x8x4_t vrp, vpp;
 uint32x2x4_t *temp_pointer;

      vtmp = vld4_u32(png_ptr(uint32_t,rp));
      vrpt = png_ptr(uint8x8x4_t,&vtmp);
      vrp = *vrpt;
      vtmp = vld4_u32(png_ptrc(uint32_t,pp));
      vppt = png_ptr(uint8x8x4_t,&vtmp);
      vpp = *vppt;

      vdest.val[0] = paeth(vdest.val[3], vpp.val[0], vlast);
      vdest.val[0] = vadd_u8(vdest.val[0], vrp.val[0]);
      vdest.val[1] = paeth(vdest.val[0], vpp.val[1], vpp.val[0]);
      vdest.val[1] = vadd_u8(vdest.val[1], vrp.val[1]);
      vdest.val[2] = paeth(vdest.val[1], vpp.val[2], vpp.val[1]);
      vdest.val[2] = vadd_u8(vdest.val[2], vrp.val[2]);
      vdest.val[3] = paeth(vdest.val[2], vpp.val[3], vpp.val[2]);
      vdest.val[3] = vadd_u8(vdest.val[3], vrp.val[3]);

      vlast = vpp.val[3];

      vst4_lane_u32(png_ptr(uint32_t,rp), png_ldr(uint32x2x4_t,&vdest), 0);
 }

 }

sequential_row(standard_display *dp, png_structp pp, png_infop pi,
    PNG_CONST int iImage, PNG_CONST int iDisplay)
{
   PNG_CONST int         npasses = dp->npasses;
   PNG_CONST int         do_interlace = dp->do_interlace &&
dp->interlace_type == PNG_INTERLACE_ADAM7;
   PNG_CONST png_uint_32 height = standard_height(pp, dp->id);
   PNG_CONST png_uint_32 width = standard_width(pp, dp->id);
   PNG_CONST png_store*  ps = dp->ps;
int pass;

for (pass=0; pass<npasses; ++pass)
{
png_uint_32 y;
png_uint_32 wPass = PNG_PASS_COLS(width, pass);

for (y=0; y<height; ++y)
{
if (do_interlace)
{
/* wPass may be zero or this row may not be in this pass.
* png_read_row must not be called in either case.
*/
if (wPass > 0 && PNG_ROW_IN_INTERLACE_PASS(y, pass))
{
/* Read the row into a pair of temporary buffers, then do the
* merge here into the output rows.
*/
png_byte row[STANDARD_ROWMAX], display[STANDARD_ROWMAX];

/* The following aids (to some extent) error detection - we can
* see where png_read_row wrote.  Use opposite values in row and
* display to make this easier.  Don't use 0xff (which is used in
* the image write code to fill unused bits) or 0 (which is a
* likely value to overwrite unused bits with).
*/
memset(row, 0xc5, sizeof row);
memset(display, 0x5c, sizeof display);

png_read_row(pp, row, display);


if (iImage >= 0)
deinterlace_row(store_image_row(ps, pp, iImage, y), row,
                     dp->pixel_size, dp->w, pass);

if (iDisplay >= 0)
deinterlace_row(store_image_row(ps, pp, iDisplay, y), display,
                     dp->pixel_size, dp->w, pass);
}
}
else
png_read_row(pp,
iImage >= 0 ? store_image_row(ps, pp, iImage, y) : NULL,
iDisplay >= 0 ? store_image_row(ps, pp, iDisplay, y) : NULL);
}
}

/* And finish the read operation (only really necessary if the caller wants
* to find additional data in png_info from chunks after the last IDAT.)
*/
png_read_end(pp, pi);
}

modifier_current_encoding(PNG_CONST png_modifier *pm, color_encoding *ce)
 {
    if (pm->current_encoding != 0)
       *ce = *pm->current_encoding;

 else
      memset(ce, 0, sizeof *ce);

   ce->gamma = pm->current_gamma;

 }

crc_init_4(png_uint_32 value)
{
 /* This is an alternative to the algorithm used in zlib, which requires four
    * separate tables to parallelize the four byte operations, it only works for
    * a CRC of the first four bytes of the stream, but this is what happens in
    * the parser below where length+chunk-name is read and chunk-name used to
    * initialize the CRC.  Notice that the calculation here avoids repeated
    * conditioning (xor with 0xffffffff) by storing the conditioned value.
    */
   png_uint_32 crc = crc_table[(~value >> 24)] ^ 0xffffff;

   crc = crc_table[(crc ^ (value >> 16)) & 0xff] ^ (crc >> 8);
   crc = crc_table[(crc ^ (value >> 8)) & 0xff] ^ (crc >> 8);
 return crc_table[(crc ^ value) & 0xff] ^ (crc >> 8);
}

int validation_gamma(int argc, char **argv)
{
double gamma[9] = { 2.2, 1.8, 1.52, 1.45, 1., 1/1.45, 1/1.52, 1/1.8, 1/2.2 };
double maxerr;
int i, silent=0, onlygamma=0;

/* Silence the output with -s, just test the gamma functions with -g: */
while (--argc > 0)
if (strcmp(*++argv, "-s") == 0)
silent = 1;
else if (strcmp(*argv, "-g") == 0)
onlygamma = 1;
else
{
fprintf(stderr, "unknown argument %s\n", *argv);
return 1;
}

if (!onlygamma)
{
/* First validate the log functions: */
maxerr = 0;
for (i=0; i<256; ++i)
{
double correct = -log(i/255.)/log(2.)*65536;
double error = png_log8bit(i) - correct;

if (i != 0 && fabs(error) > maxerr)
maxerr = fabs(error);


if (i == 0 && png_log8bit(i) != 0xffffffff ||
i != 0 && png_log8bit(i) != floor(correct+.5))
{
            fprintf(stderr, "8 bit log error: %d: got %u, expected %f\n",
i, png_log8bit(i), correct);
}
}

if (!silent)
         printf("maximum 8 bit log error = %f\n", maxerr);

maxerr = 0;
for (i=0; i<65536; ++i)
{
double correct = -log(i/65535.)/log(2.)*65536;
double error = png_log16bit(i) - correct;

if (i != 0 && fabs(error) > maxerr)
maxerr = fabs(error);

if (i == 0 && png_log16bit(i) != 0xffffffff ||
i != 0 && png_log16bit(i) != floor(correct+.5))

{
if (error > .68) /* By experiment error is less than .68 */
{
               fprintf(stderr, "16 bit log error: %d: got %u, expected %f"
" error: %f\n", i, png_log16bit(i), correct, error);
}
}
}

if (!silent)
         printf("maximum 16 bit log error = %f\n", maxerr);

/* Now exponentiations. */
maxerr = 0;
for (i=0; i<=0xfffff; ++i)
{
double correct = exp(-i/65536. * log(2.)) * (65536. * 65536);
double error = png_exp(i) - correct;

if (fabs(error) > maxerr)

maxerr = fabs(error);
if (fabs(error) > 1883) /* By experiment. */
{
            fprintf(stderr, "32 bit exp error: %d: got %u, expected %f"
" error: %f\n", i, png_exp(i), correct, error);
}
}

if (!silent)
         printf("maximum 32 bit exp error = %f\n", maxerr);

maxerr = 0;
for (i=0; i<=0xfffff; ++i)
{
double correct = exp(-i/65536. * log(2.)) * 255;
double error = png_exp8bit(i) - correct;

if (fabs(error) > maxerr)

maxerr = fabs(error);
if (fabs(error) > .50002) /* By experiment */
{
            fprintf(stderr, "8 bit exp error: %d: got %u, expected %f"
" error: %f\n", i, png_exp8bit(i), correct, error);
}
}

if (!silent)
         printf("maximum 8 bit exp error = %f\n", maxerr);

maxerr = 0;
for (i=0; i<=0xfffff; ++i)
{
double correct = exp(-i/65536. * log(2.)) * 65535;
double error = png_exp16bit(i) - correct;

if (fabs(error) > maxerr)

maxerr = fabs(error);
if (fabs(error) > .524) /* By experiment */
{
            fprintf(stderr, "16 bit exp error: %d: got %u, expected %f"
" error: %f\n", i, png_exp16bit(i), correct, error);
}
}

if (!silent)
         printf("maximum 16 bit exp error = %f\n", maxerr);
} /* !onlygamma */

/* Test the overall gamma correction. */
for (i=0; i<9; ++i)
{
unsigned j;
double g = gamma[i];
png_fixed_point gfp = floor(g * PNG_FP_1 + .5);

if (!silent)
printf("Test gamma %f\n", g);

maxerr = 0;
for (j=0; j<256; ++j)
{
double correct = pow(j/255., g) * 255;
png_byte out = png_gamma_8bit_correct(j, gfp);
double error = out - correct;

if (fabs(error) > maxerr)
maxerr = fabs(error);
if (out != floor(correct+.5))
{
fprintf(stderr, "8bit %d ^ %f: got %d expected %f error %f\n",
j, g, out, correct, error);
}

}

if (!silent)
         printf("gamma %f: maximum 8 bit error %f\n", g, maxerr);

maxerr = 0;
for (j=0; j<65536; ++j)
{
double correct = pow(j/65535., g) * 65535;
png_uint_16 out = png_gamma_16bit_correct(j, gfp);
double error = out - correct;

if (fabs(error) > maxerr)
maxerr = fabs(error);
if (fabs(error) > 1.62)
{
fprintf(stderr, "16bit %d ^ %f: got %d expected %f error %f\n",
j, g, out, correct, error);
}

}

if (!silent)
         printf("gamma %f: maximum 16 bit error %f\n", g, maxerr);
}

return 0;
}

internal_error(png_store *ps, png_const_charp message)
{
   store_log(ps, NULL, message, 1 /* error */);

 /* And finally throw an exception. */
 {
 struct exception_context *the_exception_context = &ps->exception_context;
 Throw ps;
 }
}

make_size_image(png_store* PNG_CONST ps, png_byte PNG_CONST colour_type,
    png_byte PNG_CONST bit_depth, int PNG_CONST interlace_type,
    png_uint_32 PNG_CONST w, png_uint_32 PNG_CONST h,
    int PNG_CONST do_interlace)
{
context(ps, fault);

   /* At present libpng does not support the write of an interlaced image unless
    * PNG_WRITE_INTERLACING_SUPPORTED, even with do_interlace so the code here
    * does the pixel interlace itself, so:
    *
check_interlace_type(interlace_type);

Try
{
png_infop pi;
png_structp pp;
unsigned int pixel_size;


/* Make a name and get an appropriate id for the store: */
char name[FILE_NAME_SIZE];
      PNG_CONST png_uint_32 id = FILEID(colour_type, bit_depth, 0/*palette*/,
interlace_type, w, h, do_interlace);

standard_name_from_id(name, sizeof name, 0, id);
pp = set_store_for_write(ps, &pi, name);

/* In the event of a problem return control to the Catch statement below
* to do the clean up - it is not possible to 'return' directly from a Try
* block.
*/
if (pp == NULL)
Throw ps;

png_set_IHDR(pp, pi, w, h, bit_depth, colour_type, interlace_type,
PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);

#ifdef PNG_TEXT_SUPPORTED
{
static char key[] = "image name"; /* must be writeable */
size_t pos;
png_text text;
char copy[FILE_NAME_SIZE];

/* Use a compressed text string to test the correct interaction of text
* compression and IDAT compression.
*/
text.compression = TEXT_COMPRESSION;
text.key = key;
/* Yuck: the text must be writable! */
pos = safecat(copy, sizeof copy, 0, ps->wname);
text.text = copy;
text.text_length = pos;
text.itxt_length = 0;
text.lang = 0;
text.lang_key = 0;

png_set_text(pp, pi, &text, 1);
}
#endif

if (colour_type == 3) /* palette */
init_standard_palette(ps, pp, pi, 1U << bit_depth, 0/*do tRNS*/);

png_write_info(pp, pi);

/* Calculate the bit size, divide by 8 to get the byte size - this won't
* overflow because we know the w values are all small enough even for
* a system where 'unsigned int' is only 16 bits.

*/
pixel_size = bit_size(pp, colour_type, bit_depth);
if (png_get_rowbytes(pp, pi) != ((w * pixel_size) + 7) / 8)
         png_error(pp, "row size incorrect");

else
{
int npasses = npasses_from_interlace_type(pp, interlace_type);
png_uint_32 y;
int pass;
#        ifdef PNG_WRITE_FILTER_SUPPORTED
int nfilter = PNG_FILTER_VALUE_LAST;
#        endif
png_byte image[16][SIZE_ROWMAX];

/* To help consistent error detection make the parts of this buffer
* that aren't set below all '1':

*/
memset(image, 0xff, sizeof image);

         if (!do_interlace && npasses != png_set_interlace_handling(pp))
png_error(pp, "write: png_set_interlace_handling failed");

/* Prepare the whole image first to avoid making it 7 times: */
for (y=0; y<h; ++y)
size_row(image[y], w * pixel_size, y);


for (pass=0; pass<npasses; ++pass)
{
/* The following two are for checking the macros: */
            PNG_CONST png_uint_32 wPass = PNG_PASS_COLS(w, pass);

/* If do_interlace is set we don't call png_write_row for every
* row because some of them are empty.  In fact, for a 1x1 image,
* most of them are empty!
*/
for (y=0; y<h; ++y)
{
png_const_bytep row = image[y];
png_byte tempRow[SIZE_ROWMAX];

/* If do_interlace *and* the image is interlaced we
* need a reduced interlace row; this may be reduced
* to empty.
*/
if (do_interlace && interlace_type == PNG_INTERLACE_ADAM7)
{
/* The row must not be written if it doesn't exist, notice
* that there are two conditions here, either the row isn't
* ever in the pass or the row would be but isn't wide
* enough to contribute any pixels.  In fact the wPass test
* can be used to skip the whole y loop in this case.
*/
if (PNG_ROW_IN_INTERLACE_PASS(y, pass) && wPass > 0)
{
/* Set to all 1's for error detection (libpng tends to

* set unset things to 0).
*/
memset(tempRow, 0xff, sizeof tempRow);
                     interlace_row(tempRow, row, pixel_size, w, pass);
row = tempRow;
}
else
continue;
}

#           ifdef PNG_WRITE_FILTER_SUPPORTED
/* Only get to here if the row has some pixels in it, set the
* filters to 'all' for the very first row and thereafter to a
* single filter.  It isn't well documented, but png_set_filter
* does accept a filter number (per the spec) as well as a bit
* mask.
*
* The apparent wackiness of decrementing nfilter rather than
* incrementing is so that Paeth gets used in all images bigger
* than 1 row - it's the tricky one.
*/
png_set_filter(pp, 0/*method*/,
nfilter >= PNG_FILTER_VALUE_LAST ? PNG_ALL_FILTERS : nfilter);

if (nfilter-- == 0)
nfilter = PNG_FILTER_VALUE_LAST-1;
#           endif

png_write_row(pp, row);
}
}
}

#ifdef PNG_TEXT_SUPPORTED
{
static char key[] = "end marker";
static char comment[] = "end";
png_text text;

/* Use a compressed text string to test the correct interaction of text
* compression and IDAT compression.
*/
text.compression = TEXT_COMPRESSION;
text.key = key;
text.text = comment;
text.text_length = (sizeof comment)-1;
text.itxt_length = 0;
text.lang = 0;
text.lang_key = 0;

png_set_text(pp, pi, &text, 1);
}
#endif

png_write_end(pp, pi);

/* And store this under the appropriate id, then clean up. */
store_storefile(ps, id);

store_write_reset(ps);
}

Catch(fault)
{
/* Use the png_store returned by the exception. This may help the compiler
* because 'ps' is not used in this branch of the setjmp.  Note that fault
* and ps will always be the same value.
*/
store_write_reset(fault);
}

}

skip_chunk_type(const struct global *global, png_uint_32 type)
 /* Return true if this chunk is to be skipped according to the --strip
    * option.  This code needs to recognize all known ancillary chunks in order
    * to handle the --strip=unsafe option.
    */
{
 /* Never strip critical chunks: */
 if (CRITICAL(type))
 return 0;

 switch (type)
 {
 /* Chunks that are treated as, effectively, critical because they affect
       * correct interpretation of the pixel values:
       */
 case png_tRNS: case png_sBIT:
 return 0;

 /* Chunks that specify gamma encoding which should therefore only be
       * removed the the user insists:
       */
 case png_gAMA: case png_sRGB:
 if (global->skip >= SKIP_ALL)
 return 1;
 return 0;

 /* Chunks that affect color interpretation - not used by libpng and rarely
       * used by applications, but technically still required for correct
       * interpretation of the image data:
       */
 case png_cHRM: case png_iCCP:
 if (global->skip >= SKIP_COLOR)
 return 1;
 return 0;

 /* Other chunks that are used by libpng in image transformations (as
       * opposed to known chunks that have get/set APIs but are not otherwise
       * used.)
       */
 case png_bKGD:
 if (global->skip >= SKIP_TRANSFORM)
 return 1;
 return 0;

 /* All other chunks that libpng knows about and affect neither image
       * interpretation nor libpng transforms - chunks that are effectively
       * unused by libpng even though libpng might recognize and store them.
       */
 case png_fRAc: case png_gIFg: case png_gIFt: case png_gIFx: case png_hIST:
 case png_iTXt: case png_oFFs: case png_pCAL: case png_pHYs: case png_sCAL:
 case png_sPLT: case png_sTER: case png_tEXt: case png_tIME: case png_zTXt:
 if (global->skip >= SKIP_UNUSED)
 return 1;
 return 0;

 /* Chunks that libpng does not know about (notice that this depends on the
       * list above including all known chunks!)  The decision here depends on
       * whether the safe-to-copy bit is set in the chunk type.
       */
 default:
 if (SAFE_TO_COPY(type))
 {
 if (global->skip >= SKIP_UNUSED) /* as above */
 return 1;
 }

 else if (global->skip >= SKIP_UNSAFE)
 return 1;

 return 0;
 }
}

normalize_color_encoding(color_encoding *encoding)
{
   PNG_CONST double whiteY = encoding->red.Y + encoding->green.Y +
encoding->blue.Y;

if (whiteY != 1)
{
encoding->red.X /= whiteY;
encoding->red.Y /= whiteY;
encoding->red.Z /= whiteY;
encoding->green.X /= whiteY;
encoding->green.Y /= whiteY;
encoding->green.Z /= whiteY;
encoding->blue.X /= whiteY;
encoding->blue.Y /= whiteY;
encoding->blue.Z /= whiteY;
}

}

extract(FILE *fp, png_uint_32 *proflen)
{
   png_structp png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING,0,0,0);
   png_infop info_ptr = NULL;
   png_bytep result = NULL;

 /* Initialize for error or no profile: */
 *proflen = 0;

 if (png_ptr == NULL)
 {
      fprintf(stderr, "iccfrompng: version library mismatch?\n");
 return 0;
 }

 if (setjmp(png_jmpbuf(png_ptr)))
 {
      png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
 return 0;
 }

   png_init_io(png_ptr, fp);

   info_ptr = png_create_info_struct(png_ptr);
 if (info_ptr == NULL)
      png_error(png_ptr, "OOM allocating info structure");

   png_read_info(png_ptr, info_ptr);

 {
      png_charp name;
 int compression_type;
      png_bytep profile;

 if (png_get_iCCP(png_ptr, info_ptr, &name, &compression_type, &profile,
         proflen) & PNG_INFO_iCCP)
 {
         result = malloc(*proflen);
 if (result != NULL)
            memcpy(result, profile, *proflen);

 else
            png_error(png_ptr, "OOM allocating profile buffer");
 }

 else
	result = no_profile;
 }

   png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
 return result;
}

display_clean_read(struct display *dp)
{
 if (dp->read_pp != NULL)
      png_destroy_read_struct(&dp->read_pp, &dp->read_ip, NULL);
}

find_insert(png_const_charp what, png_charp param)
{
   png_uint_32 chunk = 0;
   png_charp parameter_list[1024];
 int i, nparams;

 /* Assemble the chunk name */
 for (i=0; i<4; ++i)
 {
 char ch = what[i];

 if ((ch >= 65 && ch <= 90) || (ch >= 97 && ch <= 122))
         chunk = (chunk << 8) + what[i];

 else
 break;
 }

 if (i < 4 || what[4] != 0)
 {
      fprintf(stderr, "makepng --insert \"%s\": invalid chunk name\n", what);
      exit(1);
 }

 /* Assemble the parameter list. */
   nparams = find_parameters(what, param, parameter_list, 1024);

#  define CHUNK(a,b,c,d) (((a)<<24)+((b)<<16)+((c)<<8)+(d))

 switch (chunk)
 {
 case CHUNK(105,67,67,80): /* iCCP */
 if (nparams == 2)
 return make_insert(what, insert_iCCP, nparams, parameter_list);
 break;

 case CHUNK(116,69,88,116): /* tEXt */
 if (nparams == 2)
 return make_insert(what, insert_tEXt, nparams, parameter_list);
 break;

 case CHUNK(122,84,88,116): /* zTXt */
 if (nparams == 2)
 return make_insert(what, insert_zTXt, nparams, parameter_list);
 break;

 case CHUNK(105,84,88,116): /* iTXt */
 if (nparams == 4)
 return make_insert(what, insert_iTXt, nparams, parameter_list);
 break;

 case CHUNK(104,73,83,84): /* hIST */
 if (nparams <= 256)

             return make_insert(what, insert_hIST, nparams, parameter_list);
          break;
 
 #if 0
       case CHUNK(115,80,76,84):  /* sPLT */
          return make_insert(what, insert_sPLT, nparams, parameter_list);
#endif

 default:
         fprintf(stderr, "makepng --insert \"%s\": unrecognized chunk name\n",
            what);
         exit(1);
 }

   bad_parameter_count(what, nparams);

    return NULL;
 }

chunk_init(struct chunk * const chunk, struct file * const file)
 /* When a chunk is initialized the file length/type/pos are copied into the
    * corresponding chunk fields and the new chunk is registered in the file
    * structure.  There can only be one chunk at a time.
    *
    * NOTE: this routine must onely be called from the file alloc routine!
    */
{
   assert(file->chunk == NULL);

   CLEAR(*chunk);

   chunk->file = file;
   chunk->global = file->global;

   chunk->chunk_data_pos = file->data_pos;
   chunk->chunk_length = file->length;
   chunk->chunk_type = file->type;

 /* Compresssed/uncompressed size information (from the zlib control structure
    * that is used to check the compressed data in a chunk.)
    */
   chunk->uncompressed_digits = 0;
   chunk->compressed_digits = 0;

   file->chunk = chunk;
}

static void format_init(format_list *pf)
{
 int i;
 for (i=0; i<FORMAT_SET_COUNT; ++i)
      pf->bits[i] = 0; /* All off */
}

image_transform_png_set_tRNS_to_alpha_mod(PNG_CONST image_transform *this,
image_pixel *that, png_const_structp pp,
   PNG_CONST transform_display *display)
{
/* LIBPNG BUG: this always forces palette images to RGB. */
if (that->colour_type == PNG_COLOR_TYPE_PALETTE)
image_pixel_convert_PLTE(that);

/* This effectively does an 'expand' only if there is some transparency to
* convert to an alpha channel.
*/
if (that->have_tRNS)
      image_pixel_add_alpha(that, &display->this);

/* LIBPNG BUG: otherwise libpng still expands to 8 bits! */
else
{
if (that->bit_depth < 8)
that->bit_depth =8;

if (that->sample_depth < 8)
that->sample_depth = 8;
}

this->next->mod(this->next, that, pp, display);
}

IDAT_list_size(struct IDAT_list *list, unsigned int length)
 /* Return the size in bytes of an IDAT_list of the given length. */
{
 if (list != NULL)
      length = list->length;

 return sizeof *list - sizeof list->lengths +
      length * sizeof list->lengths[0];
}

gpc_A(Pixel *out, const Pixel *in, const Background *back)
{
 (void)back;
   out->r = in->r;
   out->g = in->g;
   out->b = in->b;
   out->a = 65535;
}

gpc_lin(Pixel *out, const Pixel *in, const Background *back)
{
 (void)back;

   out->r = ilinear(in->r);

 if (in->g == in->r)
 {
      out->g = out->r;

 if (in->b == in->r)
         out->b = out->r;

 else
         out->b = ilinear(in->b);
 }

 else
 {
      out->g = ilinear(in->g);

 if (in->b == in->r)
         out->b = out->r;

 else if (in->b == in->g)
         out->b = out->g;

 else
         out->b = ilinear(in->b);
 }

   out->a = 65535;
}

zlib_run(struct zlib *zlib)
 /* Like zlib_advance but also handles a stream of IDAT chunks. */
{
 /* The 'extra_bytes' field is set by zlib_advance if there is extra
    * compressed data in the chunk it handles (if it sees Z_STREAM_END before
    * all the input data has been used.)  This function uses the value to update
    * the correct chunk length, so the problem should only ever be detected once
    * for each chunk.  zlib_advance outputs the error message, though see the
    * IDAT specific check below.
    */
   zlib->extra_bytes = 0;

 if (zlib->idat != NULL)
 {
 struct IDAT_list *list = zlib->idat->idat_list_head;
 struct IDAT_list *last = zlib->idat->idat_list_tail;
 int        skip = 0;

 /* 'rewrite_offset' is the offset of the LZ data within the chunk, for
       * IDAT it should be 0:
       */
      assert(zlib->rewrite_offset == 0);

 /* Process each IDAT_list in turn; the caller has left the stream
       * positioned at the start of the first IDAT chunk data.
       */
 for (;;)
 {
 const unsigned int count = list->count;
 unsigned int i;

 for (i = 0; i<count; ++i)
 {
 int rc;

 if (skip > 0) /* Skip CRC and next IDAT header */
               skip_12(zlib->file);

            skip = 12; /* for the next time */

            rc = zlib_advance(zlib, list->lengths[i]);

 switch (rc)
 {
 case ZLIB_OK: /* keep going */
 break;

 case ZLIB_STREAM_END: /* stop */
 /* There may be extra chunks; if there are and one of them is
                   * not zero length output the 'extra data' message.  Only do
                   * this check if errors are being output.
                   */
 if (zlib->global->errors && zlib->extra_bytes == 0)
 {
 struct IDAT_list *check = list;
 int j = i+1, jcount = count;

 for (;;)
 {
 for (; j<jcount; ++j)
 if (check->lengths[j] > 0)
 {
                              chunk_message(zlib->chunk,
 "extra compressed data");
 goto end_check;
 }

 if (check == last)
 break;

                        check = check->next;
                        jcount = check->count;
                        j = 0;
 }
 }

               end_check:
 /* Terminate the list at the current position, reducing the
                   * length of the last IDAT too if required.
                   */
 list->lengths[i] -= zlib->extra_bytes;
 list->count = i+1;
                  zlib->idat->idat_list_tail = list;
 /* FALL THROUGH */

 default:
 return rc;
 }
 }

 /* At the end of the compressed data and Z_STREAM_END was not seen. */
 if (list == last)
 return ZLIB_OK;

 list = list->next;
 }
 }

 else

    {
       struct chunk *chunk = zlib->chunk;
       int rc;
       assert(zlib->rewrite_offset < chunk->chunk_length);
 
       rc = zlib_advance(zlib, chunk->chunk_length - zlib->rewrite_offset);

 /* The extra bytes in the chunk are handled now by adjusting the chunk
       * length to exclude them; the zlib data is always stored at the end of
       * the PNG chunk (although clearly this is not necessary.)  zlib_advance
       * has already output a warning message.
       */
      chunk->chunk_length -= zlib->extra_bytes;
 return rc;
 }
}

uarb_add32(uarb num, int in_digits, png_uint_32 add)
 /* As above but this works with any 32-bit value and only does 'add' */
{
 if (in_digits > 0)
 {
      in_digits = uarb_inc(num, in_digits, add & 0xffff);
 return uarb_inc(num+1, in_digits-1, add >> 16)+1;
 }

 return uarb_set(num, add);
}

srgb_modification_init(srgb_modification *me, png_modifier *pm, png_byte intent)
{
   modification_init(&me->this);
   me->this.chunk = CHUNK_sBIT;

 if (intent <= 3) /* if valid, else *delete* sRGB chunks */
 {
      me->this.modify_fn = srgb_modify;
      me->this.add = CHUNK_PLTE;
      me->intent = intent;
 }

 else
 {
      me->this.modify_fn = 0;
      me->this.add = 0;
      me->intent = 0;
 }

   me->this.next = pm->modifications;
   pm->modifications = &me->this;
}

standard_info_part2(standard_display *dp, png_const_structp pp,

png_const_infop pi, int nImages)
{
/* Record cbRow now that it can be found. */
   dp->pixel_size = bit_size(pp, png_get_color_type(pp, pi),
      png_get_bit_depth(pp, pi));
dp->bit_width = png_get_image_width(pp, pi) * dp->pixel_size;
dp->cbRow = png_get_rowbytes(pp, pi);

/* Validate the rowbytes here again. */
if (dp->cbRow != (dp->bit_width+7)/8)
png_error(pp, "bad png_get_rowbytes calculation");

/* Then ensure there is enough space for the output image(s). */
store_ensure_image(dp->ps, pp, nImages, dp->cbRow, dp->h);
}

void usage()
{
fprintf (stderr, "PNG2PNM\n");
fprintf (stderr, "   by Willem van Schaik, 1999\n");
#ifdef __TURBOC__
fprintf (stderr, "   for Turbo-C and Borland-C compilers\n");
#else
fprintf (stderr, "   for Linux (and Unix) compilers\n");
#endif

fprintf (stderr, "Usage:  png2pnm [options] <file>.png [<file>.pnm]\n");
fprintf (stderr, "   or:  ... | png2pnm [options]\n");
fprintf (stderr, "Options:\n");
  fprintf (stderr, "   -r[aw]   write pnm-file in binary format (P4/P5/P6) (default)\n");
fprintf (stderr, "   -n[oraw] write pnm-file in ascii format (P1/P2/P3)\n");
  fprintf (stderr, "   -a[lpha] <file>.pgm write PNG alpha channel as pgm-file\n");
fprintf (stderr, "   -h | -?  print this help-information\n");
}

transform_height(png_const_structp pp, png_byte colour_type, png_byte bit_depth)
{
 switch (bit_size(pp, colour_type, bit_depth))
 {
 case 1:
 case 2:
 case 4:
 return 1; /* Total of 128 pixels */

 case 8:
 return 2; /* Total of 256 pixels/bytes */

 case 16:
 return 512; /* Total of 65536 pixels */

 case 24:
 case 32:
 return 512; /* 65536 pixels */

 case 48:
 case 64:
 return 2048;/* 4 x 65536 pixels. */
#        define TRANSFORM_HEIGHTMAX 2048

 default:
 return 0; /* Error, will be caught later */
 }
}

static void gamma_composition_test(png_modifier *pm,
   PNG_CONST png_byte colour_type, PNG_CONST png_byte bit_depth,
   PNG_CONST int palette_number,
   PNG_CONST int interlace_type, PNG_CONST double file_gamma,
   PNG_CONST double screen_gamma,
   PNG_CONST int use_input_precision, PNG_CONST int do_background,
   PNG_CONST int expand_16)
{
size_t pos = 0;
png_const_charp base;
double bg;
char name[128];
png_color_16 background;

/* Make up a name and get an appropriate background gamma value. */
switch (do_background)
{
default:
base = "";
bg = 4; /* should not be used */
break;
case PNG_BACKGROUND_GAMMA_SCREEN:
base = " bckg(Screen):";
bg = 1/screen_gamma;
break;
case PNG_BACKGROUND_GAMMA_FILE:
base = " bckg(File):";
bg = file_gamma;
break;
case PNG_BACKGROUND_GAMMA_UNIQUE:
base = " bckg(Unique):";
/* This tests the handling of a unique value, the math is such that the
* value tends to be <1, but is neither screen nor file (even if they
* match!)
*/
bg = (file_gamma + screen_gamma) / 3;
break;
#ifdef PNG_READ_ALPHA_MODE_SUPPORTED
case ALPHA_MODE_OFFSET + PNG_ALPHA_PNG:
base = " alpha(PNG)";
bg = 4; /* should not be used */
break;
case ALPHA_MODE_OFFSET + PNG_ALPHA_STANDARD:
base = " alpha(Porter-Duff)";
bg = 4; /* should not be used */
break;
case ALPHA_MODE_OFFSET + PNG_ALPHA_OPTIMIZED:
base = " alpha(Optimized)";
bg = 4; /* should not be used */
break;
case ALPHA_MODE_OFFSET + PNG_ALPHA_BROKEN:
base = " alpha(Broken)";
bg = 4; /* should not be used */
break;
#endif
}

/* Use random background values - the background is always presented in the
* output space (8 or 16 bit components).
*/
if (expand_16 || bit_depth == 16)
{
png_uint_32 r = random_32();

background.red = (png_uint_16)r;
background.green = (png_uint_16)(r >> 16);
r = random_32();
background.blue = (png_uint_16)r;
background.gray = (png_uint_16)(r >> 16);

/* In earlier libpng versions, those where DIGITIZE is set, any background
* gamma correction in the expand16 case was done using 8-bit gamma
* correction tables, resulting in larger errors.  To cope with those
* cases use a 16-bit background value which will handle this gamma
* correction.
*/
#     if DIGITIZE
if (expand_16 && (do_background == PNG_BACKGROUND_GAMMA_UNIQUE ||
do_background == PNG_BACKGROUND_GAMMA_FILE) &&
fabs(bg*screen_gamma-1) > PNG_GAMMA_THRESHOLD)
{
/* The background values will be looked up in an 8-bit table to do
* the gamma correction, so only select values which are an exact
* match for the 8-bit table entries:
*/
background.red = (png_uint_16)((background.red >> 8) * 257);
background.green = (png_uint_16)((background.green >> 8) * 257);
background.blue = (png_uint_16)((background.blue >> 8) * 257);
background.gray = (png_uint_16)((background.gray >> 8) * 257);
}
#     endif
}

else /* 8 bit colors */
{
png_uint_32 r = random_32();

background.red = (png_byte)r;
background.green = (png_byte)(r >> 8);
background.blue = (png_byte)(r >> 16);
background.gray = (png_byte)(r >> 24);

}

background.index = 193; /* rgb(193,193,193) to detect errors */
if (!(colour_type & PNG_COLOR_MASK_COLOR))
{
/* Grayscale input, we do not convert to RGB (TBD), so we must set the
* background to gray - else libpng seems to fail.
*/
background.red = background.green = background.blue = background.gray;
}

pos = safecat(name, sizeof name, pos, "gamma ");
pos = safecatd(name, sizeof name, pos, file_gamma, 3);
pos = safecat(name, sizeof name, pos, "->");
pos = safecatd(name, sizeof name, pos, screen_gamma, 3);

pos = safecat(name, sizeof name, pos, base);
if (do_background < ALPHA_MODE_OFFSET)
{
/* Include the background color and gamma in the name: */
pos = safecat(name, sizeof name, pos, "(");
/* This assumes no expand gray->rgb - the current code won't handle that!
*/
if (colour_type & PNG_COLOR_MASK_COLOR)
{
pos = safecatn(name, sizeof name, pos, background.red);
pos = safecat(name, sizeof name, pos, ",");
pos = safecatn(name, sizeof name, pos, background.green);
pos = safecat(name, sizeof name, pos, ",");
pos = safecatn(name, sizeof name, pos, background.blue);
}
else
pos = safecatn(name, sizeof name, pos, background.gray);
pos = safecat(name, sizeof name, pos, ")^");
pos = safecatd(name, sizeof name, pos, bg, 3);
}

gamma_test(pm, colour_type, bit_depth, palette_number, interlace_type,
file_gamma, screen_gamma, 0/*sBIT*/, 0, name, use_input_precision,
0/*strip 16*/, expand_16, do_background, &background, bg);
}

print_one(const char *leader, double err)
{
 if (err != -1.)
      printf(" %s %.5f\n", leader, err);
}

clear_keep(void)
{
 int i = NINFO;
 while (--i >= 0)
      chunk_info[i].keep = 0;
}

store_read_buffer_next(png_store *ps)
{
   png_store_buffer *pbOld = ps->next;
   png_store_buffer *pbNew = &ps->current->data;
 if (pbOld != pbNew)
 {
 while (pbNew != NULL && pbNew->prev != pbOld)
         pbNew = pbNew->prev;

 if (pbNew != NULL)
 {
         ps->next = pbNew;
         ps->readpos = 0;
 return 1;
 }

      png_error(ps->pread, "buffer lost");
 }

 return 0; /* EOF or error */
}

static int is_number(char *p)
{
 while (*p) {
 if (!isdigit(*p))
 return FALSE;
 ++p;
 }
 return TRUE;
}

gpc_gb16(Pixel *out, const Pixel *in, const Background *back)
{
 if (in->a <= 0)
      out->r = out->g = out->b = back->ig;

 else if (in->a >= 65535)
      out->r = out->g = out->b = isRGB(in->g);

 else
 {
 double a = in->a / 65535.;
 double a1 = 1-a;

      a /= 65535;
      out->r = out->g = out->b = sRGB(in->g * a + back->dg * a1);
 }

   out->a = 255;
}

gamma_test(png_modifier *pmIn, PNG_CONST png_byte colour_typeIn,
    PNG_CONST png_byte bit_depthIn, PNG_CONST int palette_numberIn,
    PNG_CONST int interlace_typeIn,
    PNG_CONST double file_gammaIn, PNG_CONST double screen_gammaIn,
    PNG_CONST png_byte sbitIn, PNG_CONST int threshold_testIn,
    PNG_CONST char *name,
    PNG_CONST int use_input_precisionIn, PNG_CONST int scale16In,
    PNG_CONST int expand16In, PNG_CONST int do_backgroundIn,
    PNG_CONST png_color_16 *bkgd_colorIn, double bkgd_gammaIn)
{
gamma_display d;
context(&pmIn->this, fault);

gamma_display_init(&d, pmIn, FILEID(colour_typeIn, bit_depthIn,
palette_numberIn, interlace_typeIn, 0, 0, 0),
file_gammaIn, screen_gammaIn, sbitIn,
threshold_testIn, use_input_precisionIn, scale16In,
expand16In, do_backgroundIn, bkgd_colorIn, bkgd_gammaIn);

Try
{
png_structp pp;
png_infop pi;
gama_modification gama_mod;
srgb_modification srgb_mod;
sbit_modification sbit_mod;

/* For the moment don't use the png_modifier support here. */
d.pm->encoding_counter = 0;
modifier_set_encoding(d.pm); /* Just resets everything */
d.pm->current_gamma = d.file_gamma;

/* Make an appropriate modifier to set the PNG file gamma to the
* given gamma value and the sBIT chunk to the given precision.
*/
d.pm->modifications = NULL;
gama_modification_init(&gama_mod, d.pm, d.file_gamma);
srgb_modification_init(&srgb_mod, d.pm, 127 /*delete*/);
if (d.sbit > 0)
sbit_modification_init(&sbit_mod, d.pm, d.sbit);


modification_reset(d.pm->modifications);

      /* Get a png_struct for writing the image. *
pp = set_modifier_for_read(d.pm, &pi, d.this.id, name);
standard_palette_init(&d.this);

/* Introduce the correct read function. */
if (d.pm->this.progressive)
{
/* Share the row function with the standard implementation. */
png_set_progressive_read_fn(pp, &d, gamma_info, progressive_row,
gamma_end);

/* Now feed data into the reader until we reach the end: */
modifier_progressive_read(d.pm, pp, pi);
}
else
{
/* modifier_read expects a png_modifier* */
png_set_read_fn(pp, d.pm, modifier_read);

/* Check the header values: */
png_read_info(pp, pi);

/* Process the 'info' requirements. Only one image is generated */
gamma_info_imp(&d, pp, pi);

sequential_row(&d.this, pp, pi, -1, 0);

if (!d.this.speed)
gamma_image_validate(&d, pp, pi);
else
d.this.ps->validated = 1;
}

modifier_reset(d.pm);

if (d.pm->log && !d.threshold_test && !d.this.speed)
fprintf(stderr, "%d bit %s %s: max error %f (%.2g, %2g%%)\n",
d.this.bit_depth, colour_types[d.this.colour_type], name,
d.maxerrout, d.maxerrabs, 100*d.maxerrpc);

/* Log the summary values too. */
if (d.this.colour_type == 0 || d.this.colour_type == 4)
{
switch (d.this.bit_depth)
{
case 1:
break;

case 2:
if (d.maxerrout > d.pm->error_gray_2)
d.pm->error_gray_2 = d.maxerrout;

break;

case 4:
if (d.maxerrout > d.pm->error_gray_4)
d.pm->error_gray_4 = d.maxerrout;

break;

case 8:
if (d.maxerrout > d.pm->error_gray_8)
d.pm->error_gray_8 = d.maxerrout;

break;

case 16:
if (d.maxerrout > d.pm->error_gray_16)
d.pm->error_gray_16 = d.maxerrout;

break;

default:
png_error(pp, "bad bit depth (internal: 1)");
}
}

else if (d.this.colour_type == 2 || d.this.colour_type == 6)
{
switch (d.this.bit_depth)
{
case 8:

if (d.maxerrout > d.pm->error_color_8)
d.pm->error_color_8 = d.maxerrout;

break;

case 16:

if (d.maxerrout > d.pm->error_color_16)
d.pm->error_color_16 = d.maxerrout;

break;

default:
png_error(pp, "bad bit depth (internal: 2)");
}
}

else if (d.this.colour_type == 3)
{
if (d.maxerrout > d.pm->error_indexed)
d.pm->error_indexed = d.maxerrout;
}
}

Catch(fault)
modifier_reset(voidcast(png_modifier*,(void*)fault));
}

standard_name_from_id(char *buffer, size_t bufsize, size_t pos, png_uint_32 id)
{
 return standard_name(buffer, bufsize, pos, COL_FROM_ID(id),
      DEPTH_FROM_ID(id), PALETTE_FROM_ID(id), INTERLACE_FROM_ID(id),
      WIDTH_FROM_ID(id), HEIGHT_FROM_ID(id), DO_INTERLACE_FROM_ID(id));
}

transform_disable(PNG_CONST char *name)
 {
    image_transform *list = image_transform_first;
 
 while (list != &image_transform_end)
 {
 if (strcmp(list->name, name) == 0)
 {
 list->enable = 0;
 return;
 }

 list = list->list;
 }

   fprintf(stderr, "pngvalid: --transform-disable=%s: unknown transform\n",
      name);
   exit(99);
}

type_name(png_uint_32 type, FILE *out)
{
   putc(type_char(type >> 24), out);
   putc(type_char(type >> 16), out);
   putc(type_char(type >> 8), out);
   putc(type_char(type      ), out);
}

 get_unknown(display *d, png_infop info_ptr, int after_IDAT)
 {
 /* Create corresponding 'unknown' flags */
   png_uint_32 flags = 0;

   UNUSED(after_IDAT)

 {
      png_unknown_chunkp unknown;
 int num_unknown = png_get_unknown_chunks(d->png_ptr, info_ptr, &unknown);

 while (--num_unknown >= 0)
 {
 int chunk = findb(unknown[num_unknown].name);

 /* Chunks not known to pngunknown must be validated here; since they
          * must also be unknown to libpng the 'display->keep' behavior should
          * have been used.
          */
 if (chunk < 0) switch (d->keep)
 {
 default: /* impossible */
 case PNG_HANDLE_CHUNK_AS_DEFAULT:
 case PNG_HANDLE_CHUNK_NEVER:
               fprintf(stderr, "%s(%s): %s: %s: unknown chunk saved\n",
                  d->file, d->test, d->keep ? "discard" : "default",
                  unknown[num_unknown].name);
 ++(d->error_count);
 break;

 case PNG_HANDLE_CHUNK_IF_SAFE:
 if (!ancillaryb(unknown[num_unknown].name))
 {
                  fprintf(stderr,
 "%s(%s): if-safe: %s: unknown critical chunk saved\n",
                     d->file, d->test, unknown[num_unknown].name);
 ++(d->error_count);
 break;
 }
 /* FALL THROUGH (safe) */
 case PNG_HANDLE_CHUNK_ALWAYS:
 break;
 }

 else
            flags |= chunk_info[chunk].flag;
 }
 }

 return flags;
}

init_validate_info(validate_info *vi, gamma_display *dp, png_const_structp pp,
int in_depth, int out_depth)
{
   PNG_CONST unsigned int outmax = (1U<<out_depth)-1;

vi->pp = pp;
vi->dp = dp;

if (dp->sbit > 0 && dp->sbit < in_depth)
{
vi->sbit = dp->sbit;
vi->isbit_shift = in_depth - dp->sbit;
}

else
{
vi->sbit = (png_byte)in_depth;
vi->isbit_shift = 0;
}

vi->sbit_max = (1U << vi->sbit)-1;

/* This mimics the libpng threshold test, '0' is used to prevent gamma
* correction in the validation test.
*/
vi->screen_gamma = dp->screen_gamma;
if (fabs(vi->screen_gamma-1) < PNG_GAMMA_THRESHOLD)
vi->screen_gamma = vi->screen_inverse = 0;
else
vi->screen_inverse = 1/vi->screen_gamma;

vi->use_input_precision = dp->use_input_precision;
vi->outmax = outmax;
vi->maxabs = abserr(dp->pm, in_depth, out_depth);
vi->maxpc = pcerr(dp->pm, in_depth, out_depth);
vi->maxcalc = calcerr(dp->pm, in_depth, out_depth);
vi->maxout = outerr(dp->pm, in_depth, out_depth);
vi->outquant = output_quantization_factor(dp->pm, in_depth, out_depth);
vi->maxout_total = vi->maxout + vi->outquant * .5;

vi->outlog = outlog(dp->pm, in_depth, out_depth);

if ((dp->this.colour_type & PNG_COLOR_MASK_ALPHA) != 0 ||
      (dp->this.colour_type == 3 && dp->this.is_transparent))
{
vi->do_background = dp->do_background;

if (vi->do_background != 0)
{
         PNG_CONST double bg_inverse = 1/dp->background_gamma;
double r, g, b;

/* Caller must at least put the gray value into the red channel */
r = dp->background_color.red; r /= outmax;
g = dp->background_color.green; g /= outmax;
b = dp->background_color.blue; b /= outmax;

#     if 0
/* libpng doesn't do this optimization, if we do pngvalid will fail.
*/
if (fabs(bg_inverse-1) >= PNG_GAMMA_THRESHOLD)
#     endif
{
r = pow(r, bg_inverse);
g = pow(g, bg_inverse);
b = pow(b, bg_inverse);
}

vi->background_red = r;
vi->background_green = g;

vi->background_blue = b;
}
}
   else
vi->do_background = 0;

if (vi->do_background == 0)
vi->background_red = vi->background_green = vi->background_blue = 0;

vi->gamma_correction = 1/(dp->file_gamma*dp->screen_gamma);
if (fabs(vi->gamma_correction-1) < PNG_GAMMA_THRESHOLD)
vi->gamma_correction = 0;

vi->file_inverse = 1/dp->file_gamma;
if (fabs(vi->file_inverse-1) < PNG_GAMMA_THRESHOLD)
vi->file_inverse = 0;

vi->scale16 = dp->scale16;
}

static int check_all_characters(checkfp_command *co, checkfp_control c)
{
 int ch;

 if (c.cnumber+4 < sizeof co->number) for (ch=0; ch<256; ++ch)
 {
 if (!check_one_character(co, c, ch))
 return 0;
 }

 return 1;
}

load_fake(png_charp param, png_bytepp profile)
{
char *endptr = NULL;
   unsigned long long int size = strtoull(param, &endptr, 0/*base*/);

/* The 'fake' format is <number>*[string] */
if (endptr != NULL && *endptr == '*')
{
size_t len = strlen(++endptr);
size_t result = (size_t)size;

if (len == 0) len = 1; /* capture the terminating '\0' */

/* Now repeat that string to fill 'size' bytes. */
if (result == size && (*profile = malloc(result)) != NULL)
{
png_bytep out = *profile;

if (len == 1)
memset(out, *endptr, result);

else
{
while (size >= len)
{
memcpy(out, endptr, len);
out += len;
size -= len;
}
memcpy(out, endptr, size);
}

return result;
}

else
{
fprintf(stderr, "%s: size exceeds system limits\n", param);
exit(1);
}
}

return 0;
}

static void writepng_error_handler(png_structp png_ptr, png_const_charp msg)
{
    mainprog_info  *mainprog_ptr;

 /* This function, aside from the extra step of retrieving the "error
     * pointer" (below) and the fact that it exists within the application
     * rather than within libpng, is essentially identical to libpng's
     * default error handler.  The second point is critical:  since both
     * setjmp() and longjmp() are called from the same code, they are
     * guaranteed to have compatible notions of how big a jmp_buf is,
     * regardless of whether _BSD_SOURCE or anything else has (or has not)
     * been defined. */

    fprintf(stderr, "writepng libpng error: %s\n", msg);
    fflush(stderr);

    mainprog_ptr = png_get_error_ptr(png_ptr);
 if (mainprog_ptr == NULL) { /* we are completely hosed now */
        fprintf(stderr,
 "writepng severe error:  jmpbuf not recoverable; terminating.\n");
        fflush(stderr);
        exit(99);
 }

 /* Now we have our data structure we can use the information in it
     * to return control to our own higher level code (all the points
     * where 'setjmp' is called in this file.)  This will work with other
     * error handling mechanisms as well - libpng always calls png_error
     * when it can proceed no further, thus, so long as the error handler
     * is intercepted, application code can do its own error recovery.
     */
    longjmp(mainprog_ptr->jmpbuf, 1);
}

static int output_quantization_factor(PNG_CONST png_modifier *pm, int in_depth,
    int out_depth)
 {
    if (out_depth == 16 && in_depth != 16 &&
      pm->calculations_use_input_precision)
 return 257;
 else
 return 1;
}

uarb_printx(uarb num, int digits, FILE *out)
 /* Print 'num' as a hexadecimal number (easier than decimal!) */
{
 while (digits > 0)
 if (num[--digits] > 0)
 {
         fprintf(out, "0x%x", num[digits]);

 while (digits > 0)
            fprintf(out, "%.4x", num[--digits]);
 }

 else if (digits == 0) /* the number is 0 */
         fputs("0x0", out);
}

image_transform_reset_count(void)
{
   image_transform *next = image_transform_first;
 int count = 0;

 while (next != &image_transform_end)
 {
      next->local_use = 0;
      next->next = 0;
      next = next->list;
 ++count;
 }

 /* This can only happen if we every have more than 32 transforms (excluding
    * the end) in the list.
    */
 if (count > 32) abort();
}

int validation_muldiv(int count, int argc, char **argv)
{
int tested = 0;
int overflow = 0;
int error = 0;
int error64 = 0;
int passed = 0;
int randbits = 0;
png_uint_32 randbuffer;
png_fixed_point a;
png_int_32 times, div;

while (--argc > 0)
{
fprintf(stderr, "unknown argument %s\n", *++argv);
return 1;
}

/* Find out about the random number generator. */
randbuffer = RAND_MAX;
while (randbuffer != 0) ++randbits, randbuffer >>= 1;
printf("Using random number generator that makes %d bits\n", randbits);
for (div=0; div<32; div += randbits)
randbuffer = (randbuffer << randbits) ^ rand();

a = 0;
times = div = 0;
do

{
png_fixed_point result;
/* NOTE: your mileage may vary, a type is required below that can
       * hold 64 bits or more, if floating point is used a 64 bit or
* better mantissa is required.
*/
long long int fp, fpround;
unsigned long hi, lo;
int ok;

/* Check the values, png_64bit_product can only handle positive
* numbers, so correct for that here.
*/
{
long u1, u2;
int n = 0;
if (a < 0) u1 = -a, n = 1; else u1 = a;
if (times < 0) u2 = -times, n = !n; else u2 = times;
png_64bit_product(u1, u2, &hi, &lo);
if (n)
{
/* -x = ~x+1 */
lo = ((~lo) + 1) & 0xffffffff;
hi = ~hi;
if (lo == 0) ++hi;
}
}

fp = a;
fp *= times;
if ((fp & 0xffffffff) != lo || ((fp >> 32) & 0xffffffff) != hi)
{
fprintf(stderr, "png_64bit_product %d * %d -> %lx|%.8lx not %llx\n",
a, times, hi, lo, fp);
++error64;
}

if (div != 0)
{
/* Round - this is C round to zero. */
if ((fp < 0) != (div < 0))
fp -= div/2;
else
fp += div/2;

fp /= div;
fpround = fp;
/* Assume 2's complement here: */
ok = fpround <= PNG_UINT_31_MAX &&
fpround >= -1-(long long int)PNG_UINT_31_MAX;
if (!ok) ++overflow;
}
else
ok = 0, ++overflow, fpround = fp/*misleading*/;

if (verbose)
fprintf(stderr, "TEST %d * %d / %d -> %lld (%s)\n", a, times, div,
fp, ok ? "ok" : "overflow");

++tested;
if (png_muldiv(&result, a, times, div) != ok)
{
++error;
if (ok)
fprintf(stderr, "%d * %d / %d -> overflow (expected %lld)\n", a,
times, div, fp);
else
fprintf(stderr, "%d * %d / %d -> %d (expected overflow %lld)\n", a,
times, div, result, fp);
}
else if (ok && result != fpround)
{
++error;
fprintf(stderr, "%d * %d / %d -> %d not %lld\n", a, times, div, result,
fp);
}
else
++passed;

/* Generate three new values, this uses rand() and rand() only returns
* up to RAND_MAX.
*/
/* CRUDE */
a += times;
times += div;
div = randbuffer;
randbuffer = (randbuffer << randbits) ^ rand();

}
while (--count > 0);

   printf("%d tests including %d overflows, %d passed, %d failed (%d 64 bit "
"errors)\n", tested, overflow, passed, error, error64);
return 0;
}

int repl_getch( void )
{
 char ch;
 int fd = fileno(stdin);
 struct termio old_tty, new_tty;

  ioctl(fd, TCGETA, &old_tty);
  new_tty = old_tty;
  new_tty.c_lflag &= ~(ICANON | ECHO | ISIG);
  ioctl(fd, TCSETA, &new_tty);
  fread(&ch, 1, sizeof(ch), stdin);
  ioctl(fd, TCSETA, &old_tty);

 return ch;
}

insert_tEXt(png_structp png_ptr, png_infop info_ptr, int nparams,
   png_charpp params)
{
   png_text text;

   check_param_count(nparams, 2);
   clear_text(&text, params[0]);
   set_text(png_ptr, info_ptr, &text, params[1]);
}

image_transform_default_add(image_transform *this,
    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)
{
UNUSED(colour_type)
UNUSED(bit_depth)

this->next = *that;
*that = this;

return 1;
}

perform_size_test(png_modifier *pm)
{
 /* Test each colour type over the valid range of bit depths (expressed as
    * log2(bit_depth) in turn, stop as soon as any error is detected.
    */
 if (!test_size(pm, 0, 0, READ_BDHI))
 return;

 if (!test_size(pm, 2, 3, READ_BDHI))
 return;

 /* For the moment don't do the palette test - it's a waste of time when
    * compared to the grayscale test.
    */
#if 0
 if (!test_size(pm, 3, 0, 3))
 return;
#endif

 if (!test_size(pm, 4, 3, READ_BDHI))
 return;

 if (!test_size(pm, 6, 3, READ_BDHI))
 return;
}

make_insert(png_const_charp what,
 void (*insert)(png_structp, png_infop, int, png_charpp),
 int nparams, png_charpp list)
{
 int i;
   chunk_insert *cip;

   cip = malloc(offsetof(chunk_insert,parameters) +
      nparams * sizeof (png_charp));

 if (cip == NULL)
 {
      fprintf(stderr, "--insert %s: out of memory allocating %d parameters\n",
         what, nparams);
      exit(1);
 }

   cip->next = NULL;
   cip->insert = insert;
   cip->nparams = nparams;
 for (i=0; i<nparams; ++i)
      cip->parameters[i] = list[i];

 return cip;
}

uarb_print(uarb num, int digits, FILE *out)
 /* Prints 'num' as a decimal if it will fit in an unsigned long, else as a
    * hexadecimal number.  Notice that the results vary for images over 4GByte
    * in a system dependent way, and the hexadecimal form doesn't work very well
    * in awk script input.
    *
    *
    * TODO: write uarb_div10
    */
{
 if (digits * sizeof (udigit) > sizeof (unsigned long))
      uarb_printx(num, digits, out);

 else
 {
 unsigned long n = 0;

 while (digits > 0)
         n = (n << 16) + num[--digits];

      fprintf(out, "%lu", n);
 }
}

gpc_nop8(Pixel *out, const Pixel *in, const Background *back)
{
 (void)back;
 if (in->a == 0)
      out->r = out->g = out->b = 255;

 else
 {
      out->r = in->r;
      out->g = in->g;
      out->b = in->b;
 }

   out->a = in->a;
}

 channels_of_type(int color_type)
 {
    if (color_type & PNG_COLOR_MASK_PALETTE)
 return 1;

 else
 {
 int channels = 1;

 if (color_type & PNG_COLOR_MASK_COLOR)
         channels = 3;

 if (color_type & PNG_COLOR_MASK_ALPHA)
 return channels + 1;

 else
 return channels;

    }
 }

static void rpng2_x_cleanup(void)
{
 if (bg_image && bg_data) {
        free(bg_data);
        bg_data = NULL;
 }

 if (rpng2_info.image_data) {
        free(rpng2_info.image_data);
        rpng2_info.image_data = NULL;
 }

 if (rpng2_info.row_pointers) {
        free(rpng2_info.row_pointers);
        rpng2_info.row_pointers = NULL;
 }

 if (ximage) {
 if (ximage->data) {
            free(ximage->data); /* we allocated it, so we free it */
            ximage->data = (char *)NULL; /*  instead of XDestroyImage() */
 }
 XDestroyImage(ximage);
        ximage = NULL;
 }

 if (have_gc)
 XFreeGC(display, gc);

 if (have_window)
 XDestroyWindow(display, window);

 if (have_colormap)
 XFreeColormap(display, colormap);

 if (have_nondefault_visual)
 XFree(visual_list);
}

npasses_from_interlace_type(png_const_structp pp, int interlace_type)
{
 switch (interlace_type)
 {
 default:
      png_error(pp, "invalid interlace type");

 case PNG_INTERLACE_NONE:
 return 1;

 case PNG_INTERLACE_ADAM7:
 return PNG_INTERLACE_ADAM7_PASSES;
 }
}

do_test(struct display *dp, const char *file)
 /* Exists solely to isolate the setjmp clobbers */
{
 int ret = setjmp(dp->error_return);

 if (ret == 0)
 {
      test_one_file(dp, file);
 return 0;
 }

 else if (ret < ERRORS) /* shouldn't longjmp on warnings */
      display_log(dp, INTERNAL_ERROR, "unexpected return code %d", ret);

 return ret;
}

progressive_row(png_structp ppIn, png_bytep new_row, png_uint_32 y, int pass)
{
png_const_structp pp = ppIn;
   PNG_CONST standard_display *dp = voidcast(standard_display*,
png_get_progressive_ptr(pp));

/* When handling interlacing some rows will be absent in each pass, the
* callback still gets called, but with a NULL pointer.  This is checked
* in the 'else' clause below.  We need our own 'cbRow', but we can't call
* png_get_rowbytes because we got no info structure.
*/
if (new_row != NULL)
{
png_bytep row;

/* In the case where the reader doesn't do the interlace it gives
* us the y in the sub-image:
*/
if (dp->do_interlace && dp->interlace_type == PNG_INTERLACE_ADAM7)
{
#ifdef PNG_USER_TRANSFORM_INFO_SUPPORTED
/* Use this opportunity to validate the png 'current' APIs: */
if (y != png_get_current_row_number(pp))
png_error(pp, "png_get_current_row_number is broken");


if (pass != png_get_current_pass_number(pp))
png_error(pp, "png_get_current_pass_number is broken");
#endif

y = PNG_ROW_FROM_PASS_ROW(y, pass);
}

/* Validate this just in case. */
if (y >= dp->h)
png_error(pp, "invalid y to progressive row callback");


row = store_image_row(dp->ps, pp, 0, y);

#ifdef PNG_READ_INTERLACING_SUPPORTED
/* Combine the new row into the old: */
if (dp->do_interlace)
{
if (dp->interlace_type == PNG_INTERLACE_ADAM7)
            deinterlace_row(row, new_row, dp->pixel_size, dp->w, pass);
else
            row_copy(row, new_row, dp->pixel_size * dp->w);
}
else
png_progressive_combine_row(pp, row, new_row);
#endif /* PNG_READ_INTERLACING_SUPPORTED */
}

#ifdef PNG_READ_INTERLACING_SUPPORTED
else if (dp->interlace_type == PNG_INTERLACE_ADAM7 &&
PNG_ROW_IN_INTERLACE_PASS(y, pass) &&
PNG_PASS_COLS(dp->w, pass) > 0)
png_error(pp, "missing row in progressive de-interlacing");
#endif /* PNG_READ_INTERLACING_SUPPORTED *
}

store_memory_free(png_const_structp pp, store_pool *pool, store_memory *memory)
{
 /* Note that pp may be NULL (see store_pool_delete below), the caller has
    * found 'memory' in pool->list *and* unlinked this entry, so this is a valid
    * pointer (for sure), but the contents may have been trashed.
    */
 if (memory->pool != pool)
      store_pool_error(pool->store, pp, "memory corrupted (pool)");

 else if (memcmp(memory->mark, pool->mark, sizeof memory->mark) != 0)
      store_pool_error(pool->store, pp, "memory corrupted (start)");

 /* It should be safe to read the size field now. */
 else
 {
 png_alloc_size_t cb = memory->size;

 if (cb > pool->max)
         store_pool_error(pool->store, pp, "memory corrupted (size)");

 else if (memcmp((png_bytep)(memory+1)+cb, pool->mark, sizeof pool->mark)
 != 0)
         store_pool_error(pool->store, pp, "memory corrupted (end)");

 /* Finally give the library a chance to find problems too: */
 else
 {
         pool->current -= cb;
         free(memory);
 }
 }
}

setpos(struct chunk *chunk)
 /* Reset the position to 'chunk_data_pos' - the start of the data for this
    * chunk.  As a side effect the read_count in the file is reset to 8, just
    * after the length/type header.
    */
{
   chunk->file->read_count = 8;
   file_setpos(chunk->file, &chunk->chunk_data_pos);
}

init_sRGB_to_d(void)
{
 int i;

   sRGB_to_d[0] = 0;
 for (i=1; i<255; ++i)
      sRGB_to_d[i] = linear_from_sRGB(i/255.);
   sRGB_to_d[255] = 1;

   g22_to_d[0] = 0;
 for (i=1; i<255; ++i)
      g22_to_d[i] = pow(i/255., 1/.45455);
   g22_to_d[255] = 1;
}

int main(int argc, char **argv)
{
   volatile int summary = 1;  /* Print the error summary at the end *
   volatile int memstats = 0; /* Print memory statistics at the end *

/* Create the given output file on success: */
   PNG_CONST char *volatile touch = NULL;

/* This is an array of standard gamma values (believe it or not I've seen
* every one of these mentioned somewhere.)
*
* In the following list the most useful values are first!
*/
static double
gammas[]={2.2, 1.0, 2.2/1.45, 1.8, 1.5, 2.4, 2.5, 2.62, 2.9};

/* This records the command and arguments: */
size_t cp = 0;
char command[1024];


anon_context(&pm.this);

/* Add appropriate signal handlers, just the ANSI specified ones: */
signal(SIGABRT, signal_handler);
signal(SIGFPE, signal_handler);
signal(SIGILL, signal_handler);
signal(SIGINT, signal_handler);
signal(SIGSEGV, signal_handler);
signal(SIGTERM, signal_handler);

#ifdef HAVE_FEENABLEEXCEPT
/* Only required to enable FP exceptions on platforms where they start off
* disabled; this is not necessary but if it is not done pngvalid will likely
* end up ignoring FP conditions that other platforms fault.
*/
feenableexcept(FE_DIVBYZERO | FE_INVALID | FE_OVERFLOW);
#endif

modifier_init(&pm);

/* Preallocate the image buffer, because we know how big it needs to be,
* note that, for testing purposes, it is deliberately mis-aligned by tag
* bytes either side.  All rows have an additional five bytes of padding for
* overwrite checking.
*/
store_ensure_image(&pm.this, NULL, 2, TRANSFORM_ROWMAX, TRANSFORM_HEIGHTMAX);

/* Don't give argv[0], it's normally some horrible libtool string: */
cp = safecat(command, sizeof command, cp, "pngvalid");

/* Default to error on warning: */
pm.this.treat_warnings_as_errors = 1;

/* Default assume_16_bit_calculations appropriately; this tells the checking
* code that 16-bit arithmetic is used for 8-bit samples when it would make a
* difference.
*/
pm.assume_16_bit_calculations = PNG_LIBPNG_VER >= 10700;

/* Currently 16 bit expansion happens at the end of the pipeline, so the
* calculations are done in the input bit depth not the output.
*
* TODO: fix this
*/
pm.calculations_use_input_precision = 1U;


/* Store the test gammas */
pm.gammas = gammas;
   pm.ngammas = (sizeof gammas) / (sizeof gammas[0]);
pm.ngamma_tests = 0; /* default to off */

/* And the test encodings */
pm.encodings = test_encodings;
   pm.nencodings = (sizeof test_encodings) / (sizeof test_encodings[0]);

   pm.sbitlow = 8U; /* because libpng doesn't do sBIT below 8! *

/* The following allows results to pass if they correspond to anything in the
* transformed range [input-.5,input+.5]; this is is required because of the
* way libpng treates the 16_TO_8 flag when building the gamma tables in
* releases up to 1.6.0.
*
* TODO: review this
*/
pm.use_input_precision_16to8 = 1U;
pm.use_input_precision_sbit = 1U; /* because libpng now rounds sBIT */

/* Some default values (set the behavior for 'make check' here).
* These values simply control the maximum error permitted in the gamma
* transformations.  The practial limits for human perception are described
* below (the setting for maxpc16), however for 8 bit encodings it isn't
* possible to meet the accepted capabilities of human vision - i.e. 8 bit
* images can never be good enough, regardless of encoding.
*/
pm.maxout8 = .1; /* Arithmetic error in *encoded* value */
pm.maxabs8 = .00005; /* 1/20000 */
pm.maxcalc8 = 1./255; /* +/-1 in 8 bits for compose errors */
pm.maxpc8 = .499; /* I.e., .499% fractional error */

pm.maxout16 = .499;  /* Error in *encoded* value */
pm.maxabs16 = .00005;/* 1/20000 */
pm.maxcalc16 =1./65535;/* +/-1 in 16 bits for compose errors */
   pm.maxcalcG = 1./((1<<PNG_MAX_GAMMA_8)-1);

/* NOTE: this is a reasonable perceptual limit. We assume that humans can
* perceive light level differences of 1% over a 100:1 range, so we need to
* maintain 1 in 10000 accuracy (in linear light space), which is what the
* following guarantees.  It also allows significantly higher errors at
* higher 16 bit values, which is important for performance.  The actual
* maximum 16 bit error is about +/-1.9 in the fixed point implementation but
* this is only allowed for values >38149 by the following:
*/
pm.maxpc16 = .005; /* I.e., 1/200% - 1/20000 */

/* Now parse the command line options. */
while (--argc >= 1)
{
int catmore = 0; /* Set if the argument has an argument. */

/* Record each argument for posterity: */
cp = safecat(command, sizeof command, cp, " ");
cp = safecat(command, sizeof command, cp, *++argv);

if (strcmp(*argv, "-v") == 0)
pm.this.verbose = 1;

else if (strcmp(*argv, "-l") == 0)
pm.log = 1;


else if (strcmp(*argv, "-q") == 0)
summary = pm.this.verbose = pm.log = 0;

      else if (strcmp(*argv, "-w") == 0)
pm.this.treat_warnings_as_errors = 0;

else if (strcmp(*argv, "--speed") == 0)
pm.this.speed = 1, pm.ngamma_tests = pm.ngammas, pm.test_standard = 0,
summary = 0;

else if (strcmp(*argv, "--memory") == 0)
memstats = 1;

else if (strcmp(*argv, "--size") == 0)
pm.test_size = 1;

else if (strcmp(*argv, "--nosize") == 0)
pm.test_size = 0;

else if (strcmp(*argv, "--standard") == 0)
pm.test_standard = 1;

else if (strcmp(*argv, "--nostandard") == 0)
pm.test_standard = 0;

else if (strcmp(*argv, "--transform") == 0)
pm.test_transform = 1;

else if (strcmp(*argv, "--notransform") == 0)
pm.test_transform = 0;

#ifdef PNG_READ_TRANSFORMS_SUPPORTED
else if (strncmp(*argv, "--transform-disable=",
sizeof "--transform-disable") == 0)
{
pm.test_transform = 1;
transform_disable(*argv + sizeof "--transform-disable");
}

else if (strncmp(*argv, "--transform-enable=",
sizeof "--transform-enable") == 0)
{
pm.test_transform = 1;
transform_enable(*argv + sizeof "--transform-enable");
}
#endif /* PNG_READ_TRANSFORMS_SUPPORTED */

else if (strcmp(*argv, "--gamma") == 0)
{
/* Just do two gamma tests here (2.2 and linear) for speed: */
pm.ngamma_tests = 2U;
pm.test_gamma_threshold = 1;

pm.test_gamma_transform = 1;
pm.test_gamma_sbit = 1;
pm.test_gamma_scale16 = 1;
         pm.test_gamma_background = 1;
pm.test_gamma_alpha_mode = 1;
}

else if (strcmp(*argv, "--nogamma") == 0)
pm.ngamma_tests = 0;

else if (strcmp(*argv, "--gamma-threshold") == 0)
pm.ngamma_tests = 2U, pm.test_gamma_threshold = 1;

else if (strcmp(*argv, "--nogamma-threshold") == 0)
pm.test_gamma_threshold = 0;

else if (strcmp(*argv, "--gamma-transform") == 0)
pm.ngamma_tests = 2U, pm.test_gamma_transform = 1;

else if (strcmp(*argv, "--nogamma-transform") == 0)
pm.test_gamma_transform = 0;

else if (strcmp(*argv, "--gamma-sbit") == 0)
pm.ngamma_tests = 2U, pm.test_gamma_sbit = 1;

else if (strcmp(*argv, "--nogamma-sbit") == 0)
pm.test_gamma_sbit = 0;

else if (strcmp(*argv, "--gamma-16-to-8") == 0)
pm.ngamma_tests = 2U, pm.test_gamma_scale16 = 1;

else if (strcmp(*argv, "--nogamma-16-to-8") == 0)
pm.test_gamma_scale16 = 0;

else if (strcmp(*argv, "--gamma-background") == 0)
pm.ngamma_tests = 2U, pm.test_gamma_background = 1;

else if (strcmp(*argv, "--nogamma-background") == 0)
pm.test_gamma_background = 0;

else if (strcmp(*argv, "--gamma-alpha-mode") == 0)
pm.ngamma_tests = 2U, pm.test_gamma_alpha_mode = 1;

else if (strcmp(*argv, "--nogamma-alpha-mode") == 0)
pm.test_gamma_alpha_mode = 0;

else if (strcmp(*argv, "--expand16") == 0)
pm.test_gamma_expand16 = 1;


else if (strcmp(*argv, "--noexpand16") == 0)
pm.test_gamma_expand16 = 0;

else if (strcmp(*argv, "--more-gammas") == 0)
pm.ngamma_tests = 3U;

else if (strcmp(*argv, "--all-gammas") == 0)
pm.ngamma_tests = pm.ngammas;

else if (strcmp(*argv, "--progressive-read") == 0)
pm.this.progressive = 1;

else if (strcmp(*argv, "--use-update-info") == 0)
++pm.use_update_info; /* Can call multiple times */


else if (strcmp(*argv, "--interlace") == 0)
{
#        ifdef PNG_WRITE_INTERLACING_SUPPORTED
pm.interlace_type = PNG_INTERLACE_ADAM7;
#        else
fprintf(stderr, "pngvalid: no write interlace support\n");
return SKIP;
#        endif
}

else if (strcmp(*argv, "--use-input-precision") == 0)
pm.use_input_precision = 1U;

else if (strcmp(*argv, "--use-calculation-precision") == 0)
pm.use_input_precision = 0;

else if (strcmp(*argv, "--calculations-use-input-precision") == 0)
pm.calculations_use_input_precision = 1U;

else if (strcmp(*argv, "--assume-16-bit-calculations") == 0)
pm.assume_16_bit_calculations = 1U;

else if (strcmp(*argv, "--calculations-follow-bit-depth") == 0)
pm.calculations_use_input_precision =
pm.assume_16_bit_calculations = 0;

else if (strcmp(*argv, "--exhaustive") == 0)
pm.test_exhaustive = 1;

else if (argc > 1 && strcmp(*argv, "--sbitlow") == 0)
--argc, pm.sbitlow = (png_byte)atoi(*++argv), catmore = 1;

else if (argc > 1 && strcmp(*argv, "--touch") == 0)
--argc, touch = *++argv, catmore = 1;

else if (argc > 1 && strncmp(*argv, "--max", 5) == 0)
{
--argc;

if (strcmp(5+*argv, "abs8") == 0)
pm.maxabs8 = atof(*++argv);

else if (strcmp(5+*argv, "abs16") == 0)
pm.maxabs16 = atof(*++argv);

else if (strcmp(5+*argv, "calc8") == 0)
pm.maxcalc8 = atof(*++argv);

else if (strcmp(5+*argv, "calc16") == 0)
pm.maxcalc16 = atof(*++argv);

else if (strcmp(5+*argv, "out8") == 0)
pm.maxout8 = atof(*++argv);

else if (strcmp(5+*argv, "out16") == 0)
pm.maxout16 = atof(*++argv);

else if (strcmp(5+*argv, "pc8") == 0)
pm.maxpc8 = atof(*++argv);

else if (strcmp(5+*argv, "pc16") == 0)
pm.maxpc16 = atof(*++argv);

else
{
fprintf(stderr, "pngvalid: %s: unknown 'max' option\n", *argv);
exit(99);
}

catmore = 1;
}

else if (strcmp(*argv, "--log8") == 0)
--argc, pm.log8 = atof(*++argv), catmore = 1;

else if (strcmp(*argv, "--log16") == 0)
--argc, pm.log16 = atof(*++argv), catmore = 1;

#ifdef PNG_SET_OPTION_SUPPORTED
else if (strncmp(*argv, "--option=", 9) == 0)
{
/* Syntax of the argument is <option>:{on|off} */

const char *arg = 9+*argv;
unsigned char option=0, setting=0;

#ifdef PNG_ARM_NEON_API_SUPPORTED
if (strncmp(arg, "arm-neon:", 9) == 0)
option = PNG_ARM_NEON, arg += 9;

else
#endif
#ifdef PNG_MAXIMUM_INFLATE_WINDOW
if (strncmp(arg, "max-inflate-window:", 19) == 0)
option = PNG_MAXIMUM_INFLATE_WINDOW, arg += 19;

else
#endif
{
fprintf(stderr, "pngvalid: %s: %s: unknown option\n", *argv, arg);
exit(99);
}

if (strcmp(arg, "off") == 0)
setting = PNG_OPTION_OFF;

else if (strcmp(arg, "on") == 0)
setting = PNG_OPTION_ON;

else
{
fprintf(stderr,
"pngvalid: %s: %s: unknown setting (use 'on' or 'off')\n",
*argv, arg);
exit(99);
}

pm.this.options[pm.this.noptions].option = option;
pm.this.options[pm.this.noptions++].setting = setting;
}
#endif /* PNG_SET_OPTION_SUPPORTED */

else
{
fprintf(stderr, "pngvalid: %s: unknown argument\n", *argv);
exit(99);
}

if (catmore) /* consumed an extra *argv */
{
cp = safecat(command, sizeof command, cp, " ");
cp = safecat(command, sizeof command, cp, *argv);
}
}

/* If pngvalid is run with no arguments default to a reasonable set of the
* tests.
*/
if (pm.test_standard == 0 && pm.test_size == 0 && pm.test_transform == 0 &&
pm.ngamma_tests == 0)
{
/* Make this do all the tests done in the test shell scripts with the same
* parameters, where possible.  The limitation is that all the progressive
* read and interlace stuff has to be done in separate runs, so only the
* basic 'standard' and 'size' tests are done.
*/
pm.test_standard = 1;
pm.test_size = 1;
pm.test_transform = 1;
pm.ngamma_tests = 2U;
}

if (pm.ngamma_tests > 0 &&
pm.test_gamma_threshold == 0 && pm.test_gamma_transform == 0 &&
pm.test_gamma_sbit == 0 && pm.test_gamma_scale16 == 0 &&
pm.test_gamma_background == 0 && pm.test_gamma_alpha_mode == 0)
{
pm.test_gamma_threshold = 1;
pm.test_gamma_transform = 1;
pm.test_gamma_sbit = 1;
pm.test_gamma_scale16 = 1;
pm.test_gamma_background = 1;
pm.test_gamma_alpha_mode = 1;
}

else if (pm.ngamma_tests == 0)
{
/* Nothing to test so turn everything off: */
pm.test_gamma_threshold = 0;
pm.test_gamma_transform = 0;
pm.test_gamma_sbit = 0;
pm.test_gamma_scale16 = 0;
pm.test_gamma_background = 0;
pm.test_gamma_alpha_mode = 0;
}


Try
{
/* Make useful base images */
      make_transform_images(&pm.this);

/* Perform the standard and gamma tests. */
if (pm.test_standard)
{
perform_interlace_macro_validation();
perform_formatting_test(&pm.this);
#        ifdef PNG_READ_SUPPORTED
perform_standard_test(&pm);
#        endif
perform_error_test(&pm);
}

/* Various oddly sized images: */
if (pm.test_size)
{
make_size_images(&pm.this);
#        ifdef PNG_READ_SUPPORTED
perform_size_test(&pm);
#        endif
}

#ifdef PNG_READ_TRANSFORMS_SUPPORTED
/* Combinatorial transforms: */
if (pm.test_transform)
perform_transform_test(&pm);
#endif /* PNG_READ_TRANSFORMS_SUPPORTED */

#ifdef PNG_READ_GAMMA_SUPPORTED
if (pm.ngamma_tests > 0)
perform_gamma_test(&pm, summary);
#endif
}

Catch_anonymous
{
fprintf(stderr, "pngvalid: test aborted (probably failed in cleanup)\n");
if (!pm.this.verbose)
{
if (pm.this.error[0] != 0)
fprintf(stderr, "pngvalid: first error: %s\n", pm.this.error);

fprintf(stderr, "pngvalid: run with -v to see what happened\n");
}
exit(1);
}

if (summary)
{
printf("%s: %s (%s point arithmetic)\n",
(pm.this.nerrors || (pm.this.treat_warnings_as_errors &&
pm.this.nwarnings)) ? "FAIL" : "PASS",
command,
#if defined(PNG_FLOATING_ARITHMETIC_SUPPORTED) || PNG_LIBPNG_VER < 10500
"floating"
#else
"fixed"
#endif
);
}

if (memstats)
{
printf("Allocated memory statistics (in bytes):\n"
"\tread  %lu maximum single, %lu peak, %lu total\n"
"\twrite %lu maximum single, %lu peak, %lu total\n",
(unsigned long)pm.this.read_memory_pool.max_max,
(unsigned long)pm.this.read_memory_pool.max_limit,
(unsigned long)pm.this.read_memory_pool.max_total,
(unsigned long)pm.this.write_memory_pool.max_max,
(unsigned long)pm.this.write_memory_pool.max_limit,
(unsigned long)pm.this.write_memory_pool.max_total);
}

/* Do this here to provoke memory corruption errors in memory not directly
* allocated by libpng - not a complete test, but better than nothing.
*/
store_delete(&pm.this);

/* Error exit if there are any errors, and maybe if there are any
* warnings.
*/
if (pm.this.nerrors || (pm.this.treat_warnings_as_errors &&
pm.this.nwarnings))
{
if (!pm.this.verbose)
fprintf(stderr, "pngvalid: %s\n", pm.this.error);

fprintf(stderr, "pngvalid: %d errors, %d warnings\n", pm.this.nerrors,
pm.this.nwarnings);

exit(1);
}

/* Success case. */
if (touch != NULL)
{
FILE *fsuccess = fopen(touch, "wt");

if (fsuccess != NULL)
{
int error = 0;
fprintf(fsuccess, "PNG validation succeeded\n");
fflush(fsuccess);
error = ferror(fsuccess);

if (fclose(fsuccess) || error)
{
fprintf(stderr, "%s: write failed\n", touch);
exit(1);
}
}

else
{
fprintf(stderr, "%s: open failed\n", touch);
exit(1);
}
}

/* This is required because some very minimal configurations do not use it:
*/
UNUSED(fail)
return 0;
}

deinterlace_row(png_bytep buffer, png_const_bytep row,
   unsigned int pixel_size, png_uint_32 w, int pass)
{
   /* The inverse of the above, 'row' is part of row 'y' of the output image,
    * in 'buffer'.  The image is 'w' wide and this is pass 'pass', distribute
    * the pixels of row into buffer and return the number written (to allow
    * this to be checked).
    *
   png_uint_32 xin, xout, xstep;
   xout = PNG_PASS_START_COL(pass);
   xstep = 1U<<PNG_PASS_COL_SHIFT(pass);
   for (xin=0; xout<w; xout+=xstep)
   {
      pixel_copy(buffer, xout, row, xin, pixel_size);
      ++xin;
   }
}

void readpng_cleanup(int free_image_data)
{
 if (free_image_data && image_data) {
        free(image_data);
        image_data = NULL;
 }
}

image_transform_png_set_tRNS_to_alpha_set(PNG_CONST image_transform *this,
    transform_display *that, png_structp pp, png_infop pi)
 {
    png_set_tRNS_to_alpha(pp);
    this->next->set(this->next, that, pp, pi);
 }

perform_gamma_composition_tests(png_modifier *pm, int do_background,
int expand_16)
{
png_byte colour_type = 0;
png_byte bit_depth = 0;
unsigned int palette_number = 0;


/* Skip the non-alpha cases - there is no setting of a transparency colour at
* present.
*/
   while (next_format(&colour_type, &bit_depth, &palette_number, 1/*gamma*/))
      if ((colour_type & PNG_COLOR_MASK_ALPHA) != 0)
{
unsigned int i, j;

/* Don't skip the i==j case here - it's relevant. */
for (i=0; i<pm->ngamma_tests; ++i) for (j=0; j<pm->ngamma_tests; ++j)
{
gamma_composition_test(pm, colour_type, bit_depth, palette_number,
pm->interlace_type, 1/pm->gammas[i], pm->gammas[j],
pm->use_input_precision, do_background, expand_16);

if (fail(pm))
return;
}
}
}

void readpng_version_info(void)
{
    fprintf(stderr, "   Compiled with libpng %s; using libpng %s.\n",
      PNG_LIBPNG_VER_STRING, png_libpng_ver);
    fprintf(stderr, "   Compiled with zlib %s; using zlib %s.\n",
      ZLIB_VERSION, zlib_version);
}

image_transform_add(PNG_CONST image_transform **this, unsigned int max,
    png_uint_32 counter, char *name, size_t sizeof_name, size_t *pos,
    png_byte colour_type, png_byte bit_depth)
 {
 for (;;) /* until we manage to add something */
 {
      png_uint_32 mask;
      image_transform *list;

 /* Find the next counter value, if the counter is zero this is the start
       * of the list.  This routine always returns the current counter (not the
       * next) so it returns 0 at the end and expects 0 at the beginning.
       */
 if (counter == 0) /* first time */
 {
         image_transform_reset_count();
 if (max <= 1)
            counter = 1;
 else
            counter = random_32();
 }
 else /* advance the counter */
 {
 switch (max)
 {
 case 0: ++counter; break;
 case 1:  counter <<= 1; break;
 default: counter = random_32(); break;
 }
 }

 /* Now add all these items, if possible */
 *this = &image_transform_end;
 list = image_transform_first;
      mask = 1;

 /* Go through the whole list adding anything that the counter selects: */
 while (list != &image_transform_end)
 {
 if ((counter & mask) != 0 && list->enable &&
 (max == 0 || list->local_use < max))
 {
 /* Candidate to add: */
 if (list->add(list, this, colour_type, bit_depth) || max == 0)
 {
 /* Added, so add to the name too. */
 *pos = safecat(name, sizeof_name, *pos, " +");
 *pos = safecat(name, sizeof_name, *pos, list->name);
 }

 else
 {
 /* Not useful and max>0, so remove it from *this: */
 *this = list->next;
 list->next = 0;

 /* And, since we know it isn't useful, stop it being added again
                * in this run:
                */
 list->local_use = max;
 }
 }

         mask <<= 1;
 list = list->list;
 }

 /* Now if anything was added we have something to do. */
 if (*this != &image_transform_end)
 return counter;

 /* Nothing added, but was there anything in there to add? */
 if (!image_transform_test_counter(counter, max))
 return 0;

    }
 }

png_init_filter_functions_neon(png_structp pp, unsigned int bpp)
{
 /* The switch statement is compiled in for ARM_NEON_API, the call to
    * png_have_neon is compiled in for ARM_NEON_CHECK.  If both are defined
    * the check is only performed if the API has not set the NEON option on
    * or off explicitly.  In this case the check controls what happens.
    *
    * If the CHECK is not compiled in and the option is UNSET the behavior prior
    * to 1.6.7 was to use the NEON code - this was a bug caused by having the
    * wrong order of the 'ON' and 'default' cases.  UNSET now defaults to OFF,
    * as documented in png.h
    */
#ifdef PNG_ARM_NEON_API_SUPPORTED
 switch ((pp->options >> PNG_ARM_NEON) & 3)
 {
 case PNG_OPTION_UNSET:
 /* Allow the run-time check to execute if it has been enabled -
          * thus both API and CHECK can be turned on.  If it isn't supported
          * this case will fall through to the 'default' below, which just
          * returns.
          */
#endif /* PNG_ARM_NEON_API_SUPPORTED */
#ifdef PNG_ARM_NEON_CHECK_SUPPORTED
 {
 static volatile sig_atomic_t no_neon = -1; /* not checked */

 if (no_neon < 0)
               no_neon = !png_have_neon(pp);

 if (no_neon)
 return;
 }
#ifdef PNG_ARM_NEON_API_SUPPORTED
 break;
#endif
#endif /* PNG_ARM_NEON_CHECK_SUPPORTED */

#ifdef PNG_ARM_NEON_API_SUPPORTED
 default: /* OFF or INVALID */
 return;

 case PNG_OPTION_ON:
 /* Option turned on */
 break;
 }
#endif

 /* IMPORTANT: any new external functions used here must be declared using
    * PNG_INTERNAL_FUNCTION in ../pngpriv.h.  This is required so that the
    * 'prefix' option to configure works:
    *
    *    ./configure --with-libpng-prefix=foobar_
    *
    * Verify you have got this right by running the above command, doing a build
    * and examining pngprefix.h; it must contain a #define for every external
    * function you add.  (Notice that this happens automatically for the
    * initialization function.)
    */
   pp->read_filter[PNG_FILTER_VALUE_UP-1] = png_read_filter_row_up_neon;

 if (bpp == 3)
 {
      pp->read_filter[PNG_FILTER_VALUE_SUB-1] = png_read_filter_row_sub3_neon;
      pp->read_filter[PNG_FILTER_VALUE_AVG-1] = png_read_filter_row_avg3_neon;
      pp->read_filter[PNG_FILTER_VALUE_PAETH-1] =
         png_read_filter_row_paeth3_neon;
 }

 else if (bpp == 4)
 {
      pp->read_filter[PNG_FILTER_VALUE_SUB-1] = png_read_filter_row_sub4_neon;
      pp->read_filter[PNG_FILTER_VALUE_AVG-1] = png_read_filter_row_avg4_neon;
      pp->read_filter[PNG_FILTER_VALUE_PAETH-1] =
          png_read_filter_row_paeth4_neon;

    }
 }

image_transform_png_set_expand_16_mod(PNG_CONST image_transform *this,
image_pixel *that, png_const_structp pp,
    PNG_CONST transform_display *display)
{
/* Expect expand_16 to expand everything to 16 bits as a result of also
* causing 'expand' to happen.
*/
if (that->colour_type == PNG_COLOR_TYPE_PALETTE)

image_pixel_convert_PLTE(that);

if (that->have_tRNS)
      image_pixel_add_alpha(that, &display->this);

if (that->bit_depth < 16)
that->sample_depth = that->bit_depth = 16;

this->next->mod(this->next, that, pp, display);
}

check_error(display *d, png_uint_32 flags, const char *message)
{
 while (flags)
 {
      png_uint_32 flag = flags & -(png_int_32)flags;
 int i = find_by_flag(flag);

      fprintf(stderr, "%s(%s): chunk %s: %s\n", d->file, d->test,
         chunk_info[i].name, message);
 ++(d->error_count);

      flags &= ~flag;
 }
}

png_read_filter_row_avg3_neon(png_row_infop row_info, png_bytep row,
   png_const_bytep prev_row)
{
   png_bytep rp = row;
   png_const_bytep pp = prev_row;
   png_bytep rp_stop = row + row_info->rowbytes;

 uint8x16_t vtmp;
 uint8x8x2_t *vrpt;
 uint8x8x2_t vrp;
 uint8x8x4_t vdest;
   vdest.val[3] = vdup_n_u8(0);

   vtmp = vld1q_u8(rp);
   vrpt = png_ptr(uint8x8x2_t,&vtmp);
   vrp = *vrpt;

 for (; rp < rp_stop; pp += 12)
 {
 uint8x8_t vtmp1, vtmp2, vtmp3;

 uint8x8x2_t *vppt;
 uint8x8x2_t vpp;

 uint32x2_t *temp_pointer;

      vtmp = vld1q_u8(pp);
      vppt = png_ptr(uint8x8x2_t,&vtmp);
      vpp = *vppt;

      vtmp1 = vext_u8(vrp.val[0], vrp.val[1], 3);
      vdest.val[0] = vhadd_u8(vdest.val[3], vpp.val[0]);
      vdest.val[0] = vadd_u8(vdest.val[0], vrp.val[0]);

      vtmp2 = vext_u8(vpp.val[0], vpp.val[1], 3);
      vtmp3 = vext_u8(vrp.val[0], vrp.val[1], 6);
      vdest.val[1] = vhadd_u8(vdest.val[0], vtmp2);
      vdest.val[1] = vadd_u8(vdest.val[1], vtmp1);

      vtmp2 = vext_u8(vpp.val[0], vpp.val[1], 6);
      vtmp1 = vext_u8(vrp.val[1], vrp.val[1], 1);

      vtmp = vld1q_u8(rp + 12);
      vrpt = png_ptr(uint8x8x2_t,&vtmp);
      vrp = *vrpt;

      vdest.val[2] = vhadd_u8(vdest.val[1], vtmp2);
      vdest.val[2] = vadd_u8(vdest.val[2], vtmp3);

      vtmp2 = vext_u8(vpp.val[1], vpp.val[1], 1);

      vdest.val[3] = vhadd_u8(vdest.val[2], vtmp2);
      vdest.val[3] = vadd_u8(vdest.val[3], vtmp1);

      vst1_lane_u32(png_ptr(uint32_t,rp), png_ldr(uint32x2_t,&vdest.val[0]), 0);
      rp += 3;
      vst1_lane_u32(png_ptr(uint32_t,rp), png_ldr(uint32x2_t,&vdest.val[1]), 0);
      rp += 3;
      vst1_lane_u32(png_ptr(uint32_t,rp), png_ldr(uint32x2_t,&vdest.val[2]), 0);
      rp += 3;
      vst1_lane_u32(png_ptr(uint32_t,rp), png_ldr(uint32x2_t,&vdest.val[3]), 0);
      rp += 3;
 }
}

gpc_sG(Pixel *out, const Pixel *in, const Background *back)
{
 (void)back;

   out->r = out->g = out->b = sRGB(YfromRGBint(in->r, in->g, in->b)/65535);
   out->a = 255;
}

makepng_warning(png_structp png_ptr, png_const_charp message)
{
 const char **ep = png_get_error_ptr(png_ptr);
 const char *name;

 if (ep != NULL && *ep != NULL)
      name = *ep;

 else
      name = "makepng";

  fprintf(stderr, "%s: warning: %s\n", name, message);
}

sBIT_error_fn(png_structp pp, png_infop pi)
{
   png_byte bit_depth;
   png_color_8 bad;

 if (png_get_color_type(pp, pi) == PNG_COLOR_TYPE_PALETTE)
      bit_depth = 8;

 else
      bit_depth = png_get_bit_depth(pp, pi);

 /* Now we know the bit depth we can easily generate an invalid sBIT entry */
   bad.red = bad.green = bad.blue = bad.gray = bad.alpha =
 (png_byte)(bit_depth+1);

    png_set_sBIT(pp, pi, &bad);
 }

int main(int argc, char **argv)
{
#ifdef sgi
char tmpline[80];
#endif
char *p;
int rc, alen, flen;
int error = 0;
int have_bg = FALSE;
double LUT_exponent; /* just the lookup table */
double CRT_exponent = 2.2; /* just the monitor */
double default_display_exponent; /* whole display system */
XEvent e;
KeySym k;


displayname = (char *)NULL;
filename = (char *)NULL;


/* First set the default value for our display-system exponent, i.e.,
* the product of the CRT exponent and the exponent corresponding to
* the frame-buffer's lookup table (LUT), if any.  This is not an
* exhaustive list of LUT values (e.g., OpenStep has a lot of weird
* ones), but it should cover 99% of the current possibilities. */

#if defined(NeXT)
LUT_exponent = 1.0 / 2.2;
/*
if (some_next_function_that_returns_gamma(&next_gamma))
LUT_exponent = 1.0 / next_gamma;
*/
#elif defined(sgi)
LUT_exponent = 1.0 / 1.7;
/* there doesn't seem to be any documented function to get the
* "gamma" value, so we do it the hard way */
infile = fopen("/etc/config/system.glGammaVal", "r");
if (infile) {
double sgi_gamma;

fgets(tmpline, 80, infile);
fclose(infile);
sgi_gamma = atof(tmpline);
if (sgi_gamma > 0.0)
LUT_exponent = 1.0 / sgi_gamma;
}
#elif defined(Macintosh)
LUT_exponent = 1.8 / 2.61;
/*
if (some_mac_function_that_returns_gamma(&mac_gamma))
LUT_exponent = mac_gamma / 2.61;
*/
#else
LUT_exponent = 1.0; /* assume no LUT:  most PCs */
#endif

/* the defaults above give 1.0, 1.3, 1.5 and 2.2, respectively: */
default_display_exponent = LUT_exponent * CRT_exponent;


/* If the user has set the SCREEN_GAMMA environment variable as suggested
* (somewhat imprecisely) in the libpng documentation, use that; otherwise
* use the default value we just calculated.  Either way, the user may
* override this via a command-line option. */

if ((p = getenv("SCREEN_GAMMA")) != NULL)
display_exponent = atof(p);
else
display_exponent = default_display_exponent;


/* Now parse the command line for options and the PNG filename. */

while (*++argv && !error) {
if (!strncmp(*argv, "-display", 2)) {
if (!*++argv)
++error;
else
displayname = *argv;
} else if (!strncmp(*argv, "-gamma", 2)) {
if (!*++argv)
++error;
else {
display_exponent = atof(*argv);
if (display_exponent <= 0.0)
++error;
}
} else if (!strncmp(*argv, "-bgcolor", 2)) {
if (!*++argv)
++error;
else {
bgstr = *argv;
if (strlen(bgstr) != 7 || bgstr[0] != '#')
++error;
else
have_bg = TRUE;
}
} else {
if (**argv != '-') {
filename = *argv;
if (argv[1]) /* shouldn't be any more args after filename */
++error;
} else
++error; /* not expecting any other options */
}
}

if (!filename)
++error;


/* print usage screen if any errors up to this point */

if (error) {
fprintf(stderr, "\n%s %s:  %s\n", PROGNAME, VERSION, appname);
readpng_version_info();
fprintf(stderr, "\n"

"Usage:  %s [-display xdpy] [-gamma exp] [-bgcolor bg] file.png\n"
"    xdpy\tname of the target X display (e.g., ``hostname:0'')\n"
"    exp \ttransfer-function exponent (``gamma'') of the display\n"
          "\t\t  system in floating-point format (e.g., ``%.1f''); equal\n"
"\t\t  to the product of the lookup-table exponent (varies)\n"
"\t\t  and the CRT exponent (usually 2.2); must be positive\n"
"    bg  \tdesired background color in 7-character hex RGB format\n"
"\t\t  (e.g., ``#ff7700'' for orange:  same as HTML colors);\n"
"\t\t  used with transparent images\n"
"\nPress Q, Esc or mouse button 1 (within image window, after image\n"
          "is displayed) to quit.\n"
          "\n", PROGNAME, default_display_exponent);
exit(1);
}


if (!(infile = fopen(filename, "rb"))) {
fprintf(stderr, PROGNAME ":  can't open PNG file [%s]\n", filename);
++error;
} else {
if ((rc = readpng_init(infile, &image_width, &image_height)) != 0) {
switch (rc) {
case 1:
fprintf(stderr, PROGNAME
":  [%s] is not a PNG file: incorrect signature\n",
filename);
break;
case 2:
fprintf(stderr, PROGNAME
":  [%s] has bad IHDR (libpng longjmp)\n", filename);
break;
case 4:
fprintf(stderr, PROGNAME ":  insufficient memory\n");
break;
default:
fprintf(stderr, PROGNAME
":  unknown readpng_init() error\n");
break;
}
++error;
} else {
display = XOpenDisplay(displayname);
if (!display) {
readpng_cleanup(TRUE);
fprintf(stderr, PROGNAME ":  can't open X display [%s]\n",
displayname? displayname : "default");
++error;
}
}
if (error)
fclose(infile);
}


if (error) {
fprintf(stderr, PROGNAME ":  aborting.\n");
exit(2);
}


/* set the title-bar string, but make sure buffer doesn't overflow */

alen = strlen(appname);
flen = strlen(filename);
if (alen + flen + 3 > 1023)
sprintf(titlebar, "%s:  ...%s", appname, filename+(alen+flen+6-1023));
else
sprintf(titlebar, "%s:  %s", appname, filename);


/* if the user didn't specify a background color on the command line,
* check for one in the PNG file--if not, the initialized values of 0
* (black) will be used */

if (have_bg) {
unsigned r, g, b; /* this approach quiets compiler warnings */

sscanf(bgstr+1, "%2x%2x%2x", &r, &g, &b);
bg_red   = (uch)r;
bg_green = (uch)g;
bg_blue  = (uch)b;
} else if (readpng_get_bgcolor(&bg_red, &bg_green, &bg_blue) > 1) {
readpng_cleanup(TRUE);
fprintf(stderr, PROGNAME
":  libpng error while checking for background color\n");
exit(2);
}


/* do the basic X initialization stuff, make the window and fill it
* with the background color */

if (rpng_x_create_window())
exit(2);


/* decode the image, all at once */

Trace((stderr, "calling readpng_get_image()\n"))
image_data = readpng_get_image(display_exponent, &image_channels,
&image_rowbytes);
Trace((stderr, "done with readpng_get_image()\n"))


/* done with PNG file, so clean up to minimize memory usage (but do NOT
* nuke image_data!) */

readpng_cleanup(FALSE);
fclose(infile);

if (!image_data) {
fprintf(stderr, PROGNAME ":  unable to decode PNG image\n");
exit(3);
}


/* display image (composite with background if requested) */

Trace((stderr, "calling rpng_x_display_image()\n"))
if (rpng_x_display_image()) {
free(image_data);
exit(4);
}
Trace((stderr, "done with rpng_x_display_image()\n"))


/* wait for the user to tell us when to quit */

printf(
"Done.  Press Q, Esc or mouse button 1 (within image window) to quit.\n");
fflush(stdout);

do
XNextEvent(display, &e);
while (!(e.type == ButtonPress && e.xbutton.button == Button1) &&
!(e.type == KeyPress && /*  v--- or 1 for shifted keys */
((k = XLookupKeysym(&e.xkey, 0)) == XK_q || k == XK_Escape) ));


/* OK, we're done:  clean up all image and X resources and go away */


rpng_x_cleanup();

return 0;
}

crc_read_many(struct file *file, png_uint_32 length)
 /* Reads 'length' bytes and updates the CRC, returns true on success, false
    * if the input is truncated.
    */
{
 if (length > 0)
 {
      png_uint_32 crc = file->crc;

 do
 {
 int ch = read_byte(file);

 if (ch == EOF)
 return 0; /* Truncated */

         crc = crc_one_byte(crc, ch);
 }
 while (--length > 0);

      file->crc = crc;
 }

 return 1; /* OK */
}

get_buffer(png_structp pp)
 /* Used from libpng callbacks to get the current buffer */
{

    return (struct buffer*)png_get_io_ptr(pp);
 }

perform_interlace_macro_validation(void)
{
 /* The macros to validate, first those that depend only on pass:
    *
    * PNG_PASS_START_ROW(pass)
    * PNG_PASS_START_COL(pass)
    * PNG_PASS_ROW_SHIFT(pass)
    * PNG_PASS_COL_SHIFT(pass)
    */
 int pass;

 for (pass=0; pass<7; ++pass)
 {
      png_uint_32 m, f, v;

      m = PNG_PASS_START_ROW(pass);
      f = png_pass_start_row(pass);
 if (m != f)
 {
         fprintf(stderr, "PNG_PASS_START_ROW(%d) = %u != %x\n", pass, m, f);
         exit(99);
 }

      m = PNG_PASS_START_COL(pass);
      f = png_pass_start_col(pass);
 if (m != f)
 {
         fprintf(stderr, "PNG_PASS_START_COL(%d) = %u != %x\n", pass, m, f);
         exit(99);
 }

      m = PNG_PASS_ROW_SHIFT(pass);
      f = png_pass_row_shift(pass);
 if (m != f)
 {
         fprintf(stderr, "PNG_PASS_ROW_SHIFT(%d) = %u != %x\n", pass, m, f);
         exit(99);
 }

      m = PNG_PASS_COL_SHIFT(pass);
      f = png_pass_col_shift(pass);
 if (m != f)
 {
         fprintf(stderr, "PNG_PASS_COL_SHIFT(%d) = %u != %x\n", pass, m, f);
         exit(99);
 }

 /* Macros that depend on the image or sub-image height too:
       *
       * PNG_PASS_ROWS(height, pass)
       * PNG_PASS_COLS(width, pass)
       * PNG_ROW_FROM_PASS_ROW(yIn, pass)
       * PNG_COL_FROM_PASS_COL(xIn, pass)
       * PNG_ROW_IN_INTERLACE_PASS(y, pass)
       * PNG_COL_IN_INTERLACE_PASS(x, pass)
       */
 for (v=0;;)
 {
 /* First the base 0 stuff: */
         m = PNG_ROW_FROM_PASS_ROW(v, pass);
         f = png_row_from_pass_row(v, pass);
 if (m != f)
 {
            fprintf(stderr, "PNG_ROW_FROM_PASS_ROW(%u, %d) = %u != %x\n",
               v, pass, m, f);
            exit(99);
 }

         m = PNG_COL_FROM_PASS_COL(v, pass);
         f = png_col_from_pass_col(v, pass);
 if (m != f)
 {
            fprintf(stderr, "PNG_COL_FROM_PASS_COL(%u, %d) = %u != %x\n",
               v, pass, m, f);
            exit(99);
 }

         m = PNG_ROW_IN_INTERLACE_PASS(v, pass);
         f = png_row_in_interlace_pass(v, pass);
 if (m != f)
 {
            fprintf(stderr, "PNG_ROW_IN_INTERLACE_PASS(%u, %d) = %u != %x\n",
               v, pass, m, f);
            exit(99);
 }

         m = PNG_COL_IN_INTERLACE_PASS(v, pass);
         f = png_col_in_interlace_pass(v, pass);
 if (m != f)
 {
            fprintf(stderr, "PNG_COL_IN_INTERLACE_PASS(%u, %d) = %u != %x\n",
               v, pass, m, f);
            exit(99);
 }

 /* Then the base 1 stuff: */
 ++v;
         m = PNG_PASS_ROWS(v, pass);
         f = png_pass_rows(v, pass);
 if (m != f)
 {
            fprintf(stderr, "PNG_PASS_ROWS(%u, %d) = %u != %x\n",
               v, pass, m, f);
            exit(99);
 }

         m = PNG_PASS_COLS(v, pass);
         f = png_pass_cols(v, pass);
 if (m != f)
 {
            fprintf(stderr, "PNG_PASS_COLS(%u, %d) = %u != %x\n",
               v, pass, m, f);
            exit(99);
 }

 /* Move to the next v - the stepping algorithm starts skipping
          * values above 1024.
          */
 if (v > 1024)
 {
 if (v == PNG_UINT_31_MAX)
 break;

            v = (v << 1) ^ v;
 if (v >= PNG_UINT_31_MAX)
               v = PNG_UINT_31_MAX-1;
 }
 }
 }
}

perform_formatting_test(png_store *volatile ps)
 {
 #ifdef PNG_TIME_RFC1123_SUPPORTED
    /* The handle into the formatting code is the RFC1123 support; this test does
    * nothing if that is compiled out.
    */
   context(ps, fault);

 Try
 {
      png_const_charp correct = "29 Aug 2079 13:53:60 +0000";
      png_const_charp result;
#     if PNG_LIBPNG_VER >= 10600
 char timestring[29];
#     endif
      png_structp pp;
      png_time pt;

      pp = set_store_for_write(ps, NULL, "libpng formatting test");

 if (pp == NULL)
 Throw ps;


 /* Arbitrary settings: */
      pt.year = 2079;
      pt.month = 8;
      pt.day = 29;
      pt.hour = 13;
      pt.minute = 53;
      pt.second = 60; /* a leap second */

#     if PNG_LIBPNG_VER < 10600
         result = png_convert_to_rfc1123(pp, &pt);
#     else
 if (png_convert_to_rfc1123_buffer(timestring, &pt))
            result = timestring;

 else
            result = NULL;
#     endif

 if (result == NULL)
         png_error(pp, "png_convert_to_rfc1123 failed");

 if (strcmp(result, correct) != 0)
 {
 size_t pos = 0;
 char msg[128];

         pos = safecat(msg, sizeof msg, pos, "png_convert_to_rfc1123(");
         pos = safecat(msg, sizeof msg, pos, correct);
         pos = safecat(msg, sizeof msg, pos, ") returned: '");
         pos = safecat(msg, sizeof msg, pos, result);
         pos = safecat(msg, sizeof msg, pos, "'");

         png_error(pp, msg);
 }

      store_write_reset(ps);
 }

 Catch(fault)
 {
      store_write_reset(fault);
 }
#else
   UNUSED(ps)
#endif
}

static double outerr(PNG_CONST png_modifier *pm, int in_depth, int out_depth)
 {
    /* There is a serious error in the 2 and 4 bit grayscale transform because
     * the gamma table value (8 bits) is simply shifted, not rounded, so the
    * error in 4 bit grayscale gamma is up to the value below.  This is a hack
    * to allow pngvalid to succeed:
    *
    * TODO: fix this in libpng
    */
 if (out_depth == 2)
 return .73182-.5;

 if (out_depth == 4)
 return .90644-.5;

 if ((pm->calculations_use_input_precision ? in_depth : out_depth) == 16)
 return pm->maxout16;

 /* This is the case where the value was calculated at 8-bit precision then
    * scaled to 16 bits.
    */
 else if (out_depth == 16)
 return pm->maxout8 * 257;

 else
 return pm->maxout8;
}

clean_display(display *d)
{
   png_destroy_read_struct(&d->png_ptr, &d->info_ptr, &d->end_ptr);

 /* This must not happen - it might cause an app crash */
 if (d->png_ptr != NULL || d->info_ptr != NULL || d->end_ptr != NULL)
 {
      fprintf(stderr, "%s(%s): png_destroy_read_struct error\n", d->file,
         d->test);
      exit(1);
 }
}

png_pass_row_shift(int pass)
{
 int x, y, base=(-1), inc=8;
 ++pass;
 for (y=0; y<8; ++y) for (x=0; x<8; ++x) if (adam7[y][x] == pass)
 {
 if (base == (-1))
         base = y;
 else if (base == y)
 {}
 else if (inc == y-base)
         base=y;
 else if (inc == 8)
         inc = y-base, base=y;
 else if (inc != y-base)
 return 0xff; /* error - more than one 'inc' value! */
 }

 if (base == (-1)) return 0xfe; /* error - no row in pass! */

 /* The shift is always 1, 2 or 3 - no pass has all the rows! */
 switch (inc)
 {
case 2: return 1;
case 4: return 2;
case 8: return 3;
default: break;
 }

 /* error - unrecognized 'inc' */
 return (inc << 8) + 0xfd;
}

write_byte(struct file *file, int b)
 /* Write one byte to the output - this causes a fatal error if the write
    * fails and the read of this PNG file immediately terminates.  Just
    * increments the write count if there is no output file.
    */
{
 if (file->out != NULL)
 {
 if (putc(b, file->out) != b)
 {
         file->write_errno = errno;
         file->status_code |= WRITE_ERROR;
         stop(file, WRITE_ERROR_CODE, "write byte");
 }
 }

 ++(file->write_count);
}

stop(struct file *file, int code, const char *what)
 /* Return control when a PNG file cannot be read. This outputs an 'ERR'
    * summary line too.
    */
{
   log_error(file, code, what);

 /* The chunk being read is typically identified by file->chunk or, if this is
    * NULL, by file->type.  This may be wrong if libpng reads ahead, but this
    * only happens with IDAT where libpng reads the header then jumps around
    * finding errors in the previous chunks.  We know that is happening because
    * we are at the start of the IDAT (i.e. no IDAT data has yet been written.)
    *
    * SUMMARY FORMAT (stop):
    *
    * IDAT ERR status code read-errno write-errno message file
    *
    * 'uncompressed' will be 0 if there was a problem in the IHDR.  The errno
    * values are emit_string(strerror(errno)).
    */
 if (file->global->quiet < 2) /* need two quiets to stop this. */
 {
      png_uint_32 type;

 if (file->chunk != NULL)
         type = current_type(file, code); /* Gropes in struct chunk and IDAT */

 else
         type = file->type;

 if (type)
         type_name(type, stdout);

 else /* magic: an IDAT header, produces bogons for too many IDATs */
         fputs("HEAD", stdout); /* not a registered chunk! */

      printf(" ERR %.2x %s ", file->status_code, strcode(code));
 /* This only works one strerror at a time, because of the way strerror is
       * implemented.
       */
      emit_string(strerror(file->read_errno), stdout);
      putc(' ', stdout);
      emit_string(strerror(file->write_errno), stdout);
      putc(' ', stdout);
      emit_string(what, stdout);
      putc(' ', stdout);
      fputs(file->file_name, stdout);
      putc('\n', stdout);
 }

   file->status_code |= FILE_ERROR;
   longjmp(file->jmpbuf, code);
}

zlib_message(struct zlib *zlib, int unexpected)
 /* Output a message given a zlib rc */
{
 if (zlib->global->errors)
 {
 const char *reason = zlib->z.msg;

 if (reason == NULL)
         reason = "[no message]";

      fputs(zlib->file->file_name, stderr);
      type_sep(stderr);
      type_name(zlib->chunk->chunk_type, stderr);
      fprintf(stderr, ": %szlib error: %d (%s) (%s)\n",
         unexpected ? "unexpected " : "", zlib->rc, zlib_rc(zlib), reason);
 }
}

uarb_mult_digit(uarb acc, int a_digits, uarb num, FIX_GCC int n_digits,
   png_uint_16 val)
 /* Primitive one-digit multiply - 'val' must be 0..65535. Note that this
    * primitive is a multiply and accumulate - the result of *num * val is added
    * to *acc.
    *
    * This is a one-digit multiply, so the product may be up to one digit longer
    * than 'num', however the add to 'acc' means that the caller must ensure
    * that 'acc' is at least one digit longer than this *and* at least one digit
    * longer than the current length of 'acc'.  (Or the caller must otherwise
    * ensure 'adigits' is adequate from knowledge of the values.)
    */
{
 /* The digits in *acc, *num and val are in the range 0..65535, so the
    * result below is at most (65535*65535)+2*65635 = 65535*(65535+2), which is
    * exactly 0xffffffff.
    */
 if (val > 0 && n_digits > 0) /* Else the product is 0 */
 {
      png_uint_32 carry = 0;
 int out_digits = 0;

 while (out_digits < n_digits || carry > 0)
 {
 if (out_digits < a_digits)
            carry += acc[out_digits];

 if (out_digits < n_digits)
            carry += (png_uint_32)num[out_digits] * val;

         acc[out_digits++] = (png_uint_16)(carry & 0xffff);
         carry >>= 16;
 }

 /* So carry is 0 and all the input digits have been consumed. This means
       * that it is possible to skip any remaining digits in acc.
       */
 if (out_digits > a_digits)
 return out_digits;
 }

 return a_digits;
}

uarb_cmp(uarb a, int adigits, uarb b, int bdigits)
 /* Return -1/0/+1 according as a<b/a==b/a>b */
{
 if (adigits < bdigits)
 return -1;

 if (adigits > bdigits)
 return 1;

 while (adigits-- > 0)
 if (a[adigits] < b[adigits])
 return -1;

 else if (a[adigits] > b[adigits])
 return 1;

 return 0;
}

getpos(struct file *file)
 /* Get the current position and store it in 'data_pos'.  The corresponding
    * setpos() function is chunk specific because it uses the copy of the
    * position for the specific chunk.
    */
{
   file_getpos(file, &file->data_pos);
}

zlib_rc(struct zlib *zlib)
 /* Return a string for the zlib return code */
{
 switch (zlib->rc)
 {
 case Z_OK: return "Z_OK";
 case Z_STREAM_END: return "Z_STREAM_END";
 case Z_NEED_DICT: return "Z_NEED_DICT";
 case Z_ERRNO: return "Z_ERRNO";
 case Z_STREAM_ERROR: return "Z_STREAM_ERROR";
 case Z_DATA_ERROR: return "Z_DATA_ERROR";
 case Z_MEM_ERROR: return "Z_MEM_ERROR";
 case Z_BUF_ERROR: return "Z_BUF_ERROR";
 case Z_VERSION_ERROR: return "Z_VERSION_ERROR";
 default: return "Z_*INVALID_RC*";
 }
}

set_modifier_for_read(png_modifier *pm, png_infopp ppi, png_uint_32 id,
    PNG_CONST char *name)
{
/* Do this first so that the modifier fields are cleared even if an error
* happens allocating the png_struct.  No allocation is done here so no
* cleanup is required.
*/
pm->state = modifier_start;
pm->bit_depth = 0;
pm->colour_type = 255;

pm->pending_len = 0;
pm->pending_chunk = 0;
pm->flush = 0;
pm->buffer_count = 0;
pm->buffer_position = 0;

return set_store_for_read(&pm->this, ppi, id, name);
}

image_transform_test_counter(png_uint_32 counter, unsigned int max)
{
 /* Test the list to see if there is any point contining, given a current
    * counter and a 'max' value.
    */
   image_transform *next = image_transform_first;

 while (next != &image_transform_end)
 {
 /* For max 0 or 1 continue until the counter overflows: */
      counter >>= 1;

 /* Continue if any entry hasn't reacked the max. */
 if (max > 1 && next->local_use < max)
 return 1;
      next = next->list;
 }

 return max <= 1 && counter == 0;

 }

gp_abgr16(Pixel *p, png_const_voidp pb)
{
   png_const_uint_16p pp = voidcast(png_const_uint_16p, pb);

   p->r = pp[3];
   p->g = pp[2];
   p->b = pp[1];
   p->a = pp[0];
}

static int rpng2_x_create_window(void)
{
    ulg bg_red   = rpng2_info.bg_red;
    ulg bg_green = rpng2_info.bg_green;
    ulg bg_blue  = rpng2_info.bg_blue;
    ulg bg_pixel = 0L;
    ulg attrmask;
 int need_colormap = FALSE;
 int screen, pad;
    uch *xdata;
 Window root;
 XEvent e;
 XGCValues gcvalues;
 XSetWindowAttributes attr;
 XTextProperty windowName, *pWindowName = &windowName;
 XTextProperty iconName, *pIconName = &iconName;
 XVisualInfo visual_info;
 XSizeHints *size_hints;
 XWMHints *wm_hints;
 XClassHint *class_hints;


 Trace((stderr, "beginning rpng2_x_create_window()\n"))

    screen = DefaultScreen(display);
    depth = DisplayPlanes(display, screen);
    root = RootWindow(display, screen);

#ifdef DEBUG
 XSynchronize(display, True);
#endif

 if (depth != 16 && depth != 24 && depth != 32) {
 int visuals_matched = 0;

 Trace((stderr, "default depth is %d:  checking other visuals\n",
          depth))

 /* 24-bit first */
        visual_info.screen = screen;
        visual_info.depth = 24;
        visual_list = XGetVisualInfo(display,
 VisualScreenMask | VisualDepthMask, &visual_info, &visuals_matched);
 if (visuals_matched == 0) {
/* GRR:  add 15-, 16- and 32-bit TrueColor visuals (also DirectColor?) */
            fprintf(stderr, "default screen depth %d not supported, and no"
 " 24-bit visuals found\n", depth);
 return 2;
 }
 Trace((stderr, "XGetVisualInfo() returned %d 24-bit visuals\n",
          visuals_matched))
        visual = visual_list[0].visual;
        depth = visual_list[0].depth;
/*
        colormap_size = visual_list[0].colormap_size;
        visual_class = visual->class;
        visualID = XVisualIDFromVisual(visual);
 */
        have_nondefault_visual = TRUE;
        need_colormap = TRUE;
 } else {
 XMatchVisualInfo(display, screen, depth, TrueColor, &visual_info);
        visual = visual_info.visual;
 }

 RMask = visual->red_mask;
 GMask = visual->green_mask;
 BMask = visual->blue_mask;

/* GRR:  add/check 8-bit support */
 if (depth == 8 || need_colormap) {
        colormap = XCreateColormap(display, root, visual, AllocNone);
 if (!colormap) {
            fprintf(stderr, "XCreateColormap() failed\n");
 return 2;
 }
        have_colormap = TRUE;
 if (depth == 8)
            bg_image = FALSE; /* gradient just wastes palette entries */
 }
 if (depth == 15 || depth == 16) {
 RShift = 15 - rpng2_x_msb(RMask); /* these are right-shifts */
 GShift = 15 - rpng2_x_msb(GMask);
 BShift = 15 - rpng2_x_msb(BMask);
 } else if (depth > 16) {
 RShift = rpng2_x_msb(RMask) - 7; /* these are left-shifts */
 GShift = rpng2_x_msb(GMask) - 7;
 BShift = rpng2_x_msb(BMask) - 7;
 }
 if (depth >= 15 && (RShift < 0 || GShift < 0 || BShift < 0)) {
        fprintf(stderr, "rpng2 internal logic error:  negative X shift(s)!\n");
 return 2;
 }

/*---------------------------------------------------------------------------
    Finally, create the window.
  ---------------------------------------------------------------------------*/

    attr.backing_store = Always;
    attr.event_mask = ExposureMask | KeyPressMask | ButtonPressMask;
    attrmask = CWBackingStore | CWEventMask;
 if (have_nondefault_visual) {
        attr.colormap = colormap;
        attr.background_pixel = 0;
        attr.border_pixel = 1;
        attrmask |= CWColormap | CWBackPixel | CWBorderPixel;
 }

    window = XCreateWindow(display, root, 0, 0, rpng2_info.width,
      rpng2_info.height, 0, depth, InputOutput, visual, attrmask, &attr);

 if (window == None) {
        fprintf(stderr, "XCreateWindow() failed\n");
 return 2;
 } else
        have_window = TRUE;

 if (depth == 8)
 XSetWindowColormap(display, window, colormap);

 if (!XStringListToTextProperty(&window_name, 1, pWindowName))
        pWindowName = NULL;
 if (!XStringListToTextProperty(&icon_name, 1, pIconName))
        pIconName = NULL;

 /* OK if either hints allocation fails; XSetWMProperties() allows NULLs */

 if ((size_hints = XAllocSizeHints()) != NULL) {
 /* window will not be resizable */
        size_hints->flags = PMinSize | PMaxSize;
        size_hints->min_width = size_hints->max_width = (int)rpng2_info.width;
        size_hints->min_height = size_hints->max_height =
 (int)rpng2_info.height;
 }

 if ((wm_hints = XAllocWMHints()) != NULL) {
        wm_hints->initial_state = NormalState;
        wm_hints->input = True;
 /* wm_hints->icon_pixmap = icon_pixmap; */
        wm_hints->flags = StateHint | InputHint /* | IconPixmapHint */ ;
 }

 if ((class_hints = XAllocClassHint()) != NULL) {
        class_hints->res_name = res_name;
        class_hints->res_class = res_class;
 }

 XSetWMProperties(display, window, pWindowName, pIconName, NULL, 0,
      size_hints, wm_hints, class_hints);

 /* various properties and hints no longer needed; free memory */
 if (pWindowName)
 XFree(pWindowName->value);
 if (pIconName)
 XFree(pIconName->value);
 if (size_hints)
 XFree(size_hints);
 if (wm_hints)
 XFree(wm_hints);
 if (class_hints)
 XFree(class_hints);

 XMapWindow(display, window);

    gc = XCreateGC(display, window, 0, &gcvalues);
    have_gc = TRUE;

/*---------------------------------------------------------------------------
    Allocate memory for the X- and display-specific version of the image.
  ---------------------------------------------------------------------------*/

 if (depth == 24 || depth == 32) {
        xdata = (uch *)malloc(4*rpng2_info.width*rpng2_info.height);
        pad = 32;
 } else if (depth == 16) {
        xdata = (uch *)malloc(2*rpng2_info.width*rpng2_info.height);
        pad = 16;
 } else /* depth == 8 */ {
        xdata = (uch *)malloc(rpng2_info.width*rpng2_info.height);
        pad = 8;
 }

 if (!xdata) {
        fprintf(stderr, PROGNAME ":  unable to allocate image memory\n");
 return 4;
 }

    ximage = XCreateImage(display, visual, depth, ZPixmap, 0,
 (char *)xdata, rpng2_info.width, rpng2_info.height, pad, 0);

 if (!ximage) {
        fprintf(stderr, PROGNAME ":  XCreateImage() failed\n");
        free(xdata);
 return 3;
 }

 /* to avoid testing the byte order every pixel (or doubling the size of
     * the drawing routine with a giant if-test), we arbitrarily set the byte
     * order to MSBFirst and let Xlib worry about inverting things on little-
     * endian machines (e.g., Linux/x86, old VAXen, etc.)--this is not the
     * most efficient approach (the giant if-test would be better), but in
     * the interest of clarity, we'll take the easy way out... */

    ximage->byte_order = MSBFirst;

/*---------------------------------------------------------------------------
    Fill window with the specified background color (default is black) or
    faked "background image" (but latter is disabled if 8-bit; gradients
    just waste palette entries).
  ---------------------------------------------------------------------------*/

 if (bg_image)
        rpng2_x_load_bg_image(); /* resets bg_image if fails */

 if (!bg_image) {
 if (depth == 24 || depth == 32) {
            bg_pixel = (bg_red   << RShift) |
 (bg_green << GShift) |
 (bg_blue  << BShift);
 } else if (depth == 16) {
            bg_pixel = (((bg_red   << 8) >> RShift) & RMask) |
 (((bg_green << 8) >> GShift) & GMask) |
 (((bg_blue  << 8) >> BShift) & BMask);
 } else /* depth == 8 */ {

 /* GRR:  add 8-bit support */

 }
 XSetForeground(display, gc, bg_pixel);
 XFillRectangle(display, window, gc, 0, 0, rpng2_info.width,
          rpng2_info.height);
 }

/*---------------------------------------------------------------------------
    Wait for first Expose event to do any drawing, then flush and return.
  ---------------------------------------------------------------------------*/

 do
 XNextEvent(display, &e);
 while (e.type != Expose || e.xexpose.count);

 XFlush(display);

 return 0;

} /* end function rpng2_x_create_window() */

modifier_encoding_iterate(png_modifier *pm)
{
 if (!pm->repeat && /* Else something needs the current encoding again. */
      pm->test_uses_encoding) /* Some transform is encoding dependent */
 {
 if (pm->test_exhaustive)
 {
 if (++pm->encoding_counter >= modifier_total_encodings(pm))
            pm->encoding_counter = 0; /* This will stop the repeat */
 }

 else
 {
 /* Not exhaustive - choose an encoding at random; generate a number in
          * the range 1..(max-1), so the result is always non-zero:
          */
 if (pm->encoding_counter == 0)
            pm->encoding_counter = random_mod(modifier_total_encodings(pm)-1)+1;
 else
            pm->encoding_counter = 0;
 }

 if (pm->encoding_counter > 0)
         pm->repeat = 1;
 }

 else if (!pm->repeat)
      pm->encoding_counter = 0;
}

warning_handler(png_structp png_ptr, png_const_charp message)
{
 struct file *file = get_control(png_ptr);

 if (file->global->warnings)
      emit_error(file, LIBPNG_WARNING_CODE, message);
}

standard_palette_validate(standard_display *dp, png_const_structp pp,
   png_infop pi)
{
 int npalette;
   store_palette palette;

 if (read_palette(palette, &npalette, pp, pi) != dp->is_transparent)
      png_error(pp, "validate: palette transparency changed");

 if (npalette != dp->npalette)
 {
 size_t pos = 0;
 char msg[64];

      pos = safecat(msg, sizeof msg, pos, "validate: palette size changed: ");
      pos = safecatn(msg, sizeof msg, pos, dp->npalette);
      pos = safecat(msg, sizeof msg, pos, " -> ");
      pos = safecatn(msg, sizeof msg, pos, npalette);
      png_error(pp, msg);
 }

 {
 int i = npalette; /* npalette is aliased */

 while (--i >= 0)
 if (palette[i].red != dp->palette[i].red ||
            palette[i].green != dp->palette[i].green ||
            palette[i].blue != dp->palette[i].blue ||
            palette[i].alpha != dp->palette[i].alpha)
            png_error(pp, "validate: PLTE or tRNS chunk changed");
 }
}

transform_row(png_const_structp pp, png_byte buffer[TRANSFORM_ROWMAX],
   png_byte colour_type, png_byte bit_depth, png_uint_32 y)
{
   png_uint_32 v = y << 7;
   png_uint_32 i = 0;

 switch (bit_size(pp, colour_type, bit_depth))
 {
 case 1:
 while (i<128/8) buffer[i] = (png_byte)(v & 0xff), v += 17, ++i;
 return;

 case 2:
 while (i<128/4) buffer[i] = (png_byte)(v & 0xff), v += 33, ++i;
 return;

 case 4:
 while (i<128/2) buffer[i] = (png_byte)(v & 0xff), v += 65, ++i;
 return;

 case 8:
 /* 256 bytes total, 128 bytes in each row set as follows: */
 while (i<128) buffer[i] = (png_byte)(v & 0xff), ++v, ++i;
 return;

 case 16:
 /* Generate all 65536 pixel values in order, which includes the 8 bit
          * GA case as well as the 16 bit G case.
          */
 while (i<128)
 {
            buffer[2*i] = (png_byte)((v>>8) & 0xff);
            buffer[2*i+1] = (png_byte)(v & 0xff);
 ++v;
 ++i;
 }

 return;

 case 24:
 /* 65535 pixels, but rotate the values. */
 while (i<128)
 {
 /* Three bytes per pixel, r, g, b, make b by r^g */
            buffer[3*i+0] = (png_byte)((v >> 8) & 0xff);
            buffer[3*i+1] = (png_byte)(v & 0xff);
            buffer[3*i+2] = (png_byte)(((v >> 8) ^ v) & 0xff);
 ++v;
 ++i;
 }

 return;

 case 32:
 /* 65535 pixels, r, g, b, a; just replicate */
 while (i<128)
 {
            buffer[4*i+0] = (png_byte)((v >> 8) & 0xff);
            buffer[4*i+1] = (png_byte)(v & 0xff);
            buffer[4*i+2] = (png_byte)((v >> 8) & 0xff);
            buffer[4*i+3] = (png_byte)(v & 0xff);
 ++v;
 ++i;
 }

 return;

 case 48:
 /* y is maximum 2047, giving 4x65536 pixels, make 'r' increase by 1 at
          * each pixel, g increase by 257 (0x101) and 'b' by 0x1111:
          */
 while (i<128)
 {
            png_uint_32 t = v++;
            buffer[6*i+0] = (png_byte)((t >> 8) & 0xff);
            buffer[6*i+1] = (png_byte)(t & 0xff);
            t *= 257;
            buffer[6*i+2] = (png_byte)((t >> 8) & 0xff);
            buffer[6*i+3] = (png_byte)(t & 0xff);
            t *= 17;
            buffer[6*i+4] = (png_byte)((t >> 8) & 0xff);
            buffer[6*i+5] = (png_byte)(t & 0xff);
 ++i;
 }

 return;

 case 64:
 /* As above in the 32 bit case. */
 while (i<128)
 {
            png_uint_32 t = v++;
            buffer[8*i+0] = (png_byte)((t >> 8) & 0xff);
            buffer[8*i+1] = (png_byte)(t & 0xff);
            buffer[8*i+4] = (png_byte)((t >> 8) & 0xff);
            buffer[8*i+5] = (png_byte)(t & 0xff);
            t *= 257;
            buffer[8*i+2] = (png_byte)((t >> 8) & 0xff);
            buffer[8*i+3] = (png_byte)(t & 0xff);
            buffer[8*i+6] = (png_byte)((t >> 8) & 0xff);
            buffer[8*i+7] = (png_byte)(t & 0xff);
 ++i;
 }
 return;

 default:
 break;
 }

   png_error(pp, "internal error");
}

static int fail(png_modifier *pm)
{
 return !pm->log && !pm->this.verbose && (pm->this.nerrors > 0 ||
 (pm->this.treat_warnings_as_errors && pm->this.nwarnings > 0));
}

store_image_row(PNG_CONST png_store* ps, png_const_structp pp, int nImage,
    png_uint_32 y)
 {
    png_size_t coffset = (nImage * ps->image_h + y) * (ps->cb_row + 5) + 2;

 if (ps->image == NULL)
      png_error(pp, "no allocated image");

 if (coffset + ps->cb_row + 3 > ps->cb_image)
      png_error(pp, "image too small");

 return ps->image + coffset;
}

image_transform_png_set_scale_16_mod(PNG_CONST image_transform *this,
image_pixel *that, png_const_structp pp,
    PNG_CONST transform_display *display)
{
if (that->bit_depth == 16)
{
that->sample_depth = that->bit_depth = 8;
if (that->red_sBIT > 8) that->red_sBIT = 8;
if (that->green_sBIT > 8) that->green_sBIT = 8;
if (that->blue_sBIT > 8) that->blue_sBIT = 8;
if (that->alpha_sBIT > 8) that->alpha_sBIT = 8;
}

this->next->mod(this->next, that, pp, display);
}

static void rpng2_x_finish_display(void)
{
 Trace((stderr, "beginning rpng2_x_finish_display()\n"))

 /* last row has already been displayed by rpng2_x_display_row(), so we
     * have nothing to do here except set a flag and let the user know that
     * the image is done */

    rpng2_info.state = kDone;
    printf(
 "Done.  Press Q, Esc or mouse button 1 (within image window) to quit.\n");
    fflush(stdout);
}

insert_iTXt(png_structp png_ptr, png_infop info_ptr, int nparams,
   png_charpp params)
{
   png_text text;

   check_param_count(nparams, 4);
   clear_text(&text, params[0]);
   text.compression = 2; /* iTXt + deflate */
   text.lang = params[1];/* language tag */
   text.lang_key = params[2]; /* translated keyword */
   set_text(png_ptr, info_ptr, &text, params[3]);

 }

gp_rgb16(Pixel *p, png_const_voidp pb)
{
   png_const_uint_16p pp = voidcast(png_const_uint_16p, pb);

   p->r = pp[0];
   p->g = pp[1];
   p->b = pp[2];
   p->a = 65535;
}

uarb_set(uarb result, png_alloc_size_t val)
 /* Set (initialize) 'result' to 'val'.  The size required for 'result' must
    * be determined by the caller from a knowledge of the maximum for 'val'.
    */
{
 int ndigits = 0;

 while (val > 0)
 {
      result[ndigits++] = (png_uint_16)(val & 0xffff);
      val >>= 16;
 }

 return ndigits;
}

image_transform_png_set_strip_alpha_add(image_transform *this,
    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)
{
UNUSED(bit_depth)

this->next = *that;
*that = this;

return (colour_type & PNG_COLOR_MASK_ALPHA) != 0;
}

logpixel(const Transform *transform, png_uint_32 x, png_uint_32 y,
 const Pixel *in, const Pixel *calc, const Pixel *out, const char *reason)
{
 const png_uint_32 in_format = transform->in_image->image.format;
 const png_uint_32 out_format = transform->out_image->image.format;

   png_uint_32 back_format = out_format & ~PNG_FORMAT_FLAG_ALPHA;
 const char *via_linear = "";

 char pixel_in[64], pixel_calc[64], pixel_out[64], pixel_loc[64];
 char background_info[100];

   print_pixel(pixel_in, in, in_format);
   print_pixel(pixel_calc, calc, out_format);
   print_pixel(pixel_out, out, out_format);

 if (transform->is_palette)
      sprintf(pixel_loc, "palette: %lu", (unsigned long)y);
 else
      sprintf(pixel_loc, "%lu,%lu", (unsigned long)x, (unsigned long)y);

 if (transform->from_linear != NULL)
 {
      via_linear = " (via linear)";
 /* And as a result the *read* format which did any background processing
       * was itself linear, so the background color information is also
       * linear.
       */
      back_format |= PNG_FORMAT_FLAG_LINEAR;
 }

 if (transform->background != NULL)
 {
 Pixel back;
 char pixel_back[64];

      back.r = transform->background->ir;
      back.g = transform->background->ig;
      back.b = transform->background->ib;
      back.a = -1; /* not used */

      print_pixel(pixel_back, &back, back_format);
      sprintf(background_info, " on background %s", pixel_back);
 }

 else
      background_info[0] = 0;

 if (transform->in_image->file_name != transform->out_image->file_name)
 {
 char error_buffer[512];
      sprintf(error_buffer,
 "(%s) %s error%s:\n %s%s ->\n       %s\n  not: %s.\n"
 "Use --preserve and examine: ", pixel_loc, reason, via_linear,
         pixel_in, background_info, pixel_out, pixel_calc);
 return logerror(transform->in_image, transform->in_image->file_name,
         error_buffer, transform->out_image->file_name);
 }

 else
 {
 char error_buffer[512];
      sprintf(error_buffer,
 "(%s) %s error%s:\n %s%s ->\n       %s\n  not: %s.\n"
 " The error happened when reading the original file with this format.",
         pixel_loc, reason, via_linear, pixel_in, background_info, pixel_out,
         pixel_calc);
 return logerror(transform->in_image, transform->in_image->file_name,
         error_buffer, "");
 }
}

png_read_filter_row_up_neon(png_row_infop row_info, png_bytep row,
   png_const_bytep prev_row)
{
   png_bytep rp = row;
   png_bytep rp_stop = row + row_info->rowbytes;
   png_const_bytep pp = prev_row;

 for (; rp < rp_stop; rp += 16, pp += 16)
 {
 uint8x16_t qrp, qpp;

      qrp = vld1q_u8(rp);
      qpp = vld1q_u8(pp);
      qrp = vaddq_u8(qrp, qpp);
      vst1q_u8(rp, qrp);
 }
}

allocate(struct file *file, int allocate_idat)
{
   struct control *control = png_voidcast(struct control*, file->alloc_ptr);

if (allocate_idat)
{
assert(file->idat == NULL);
IDAT_init(&control->idat, file);
}

else /* chunk */
{
assert(file->chunk == NULL);
chunk_init(&control->chunk, file);
}
}

static size_t safecatn(char *buffer, size_t bufsize, size_t pos, int n)
{
 char number[64];
   sprintf(number, "%d", n);
 return safecat(buffer, bufsize, pos, number);
}

 random_mod(unsigned int max)
 {
 unsigned int x;

   RANDOMIZE(x);


    return x % max; /* 0 .. max-1 */
 }

compare_two_images(Image *a, Image *b, int via_linear,
png_const_colorp background)
{
ptrdiff_t stridea = a->stride;
ptrdiff_t strideb = b->stride;
png_const_bytep rowa = a->buffer+16;
png_const_bytep rowb = b->buffer+16;
const png_uint_32 width = a->image.width;
const png_uint_32 height = a->image.height;
const png_uint_32 formata = a->image.format;
const png_uint_32 formatb = b->image.format;
const unsigned int a_sample = PNG_IMAGE_SAMPLE_SIZE(formata);
const unsigned int b_sample = PNG_IMAGE_SAMPLE_SIZE(formatb);
int alpha_added, alpha_removed;
int bchannels;
int btoa[4];
png_uint_32 y;
Transform tr;

/* This should never happen: */
if (width != b->image.width || height != b->image.height)
return logerror(a, a->file_name, ": width x height changed: ",
b->file_name);

/* Set up the background and the transform */
transform_from_formats(&tr, a, b, background, via_linear);

/* Find the first row and inter-row space. */
if (!(formata & PNG_FORMAT_FLAG_COLORMAP) &&
(formata & PNG_FORMAT_FLAG_LINEAR))
stridea *= 2;

if (!(formatb & PNG_FORMAT_FLAG_COLORMAP) &&
(formatb & PNG_FORMAT_FLAG_LINEAR))
strideb *= 2;

if (stridea < 0) rowa += (height-1) * (-stridea);
if (strideb < 0) rowb += (height-1) * (-strideb);

/* First shortcut the two colormap case by comparing the image data; if it
* matches then we expect the colormaps to match, although this is not
* absolutely necessary for an image match.  If the colormaps fail to match
* then there is a problem in libpng.
*/
if (formata & formatb & PNG_FORMAT_FLAG_COLORMAP)
{
/* Only check colormap entries that actually exist; */
png_const_bytep ppa, ppb;
int match;
png_byte in_use[256], amax = 0, bmax = 0;

memset(in_use, 0, sizeof in_use);

ppa = rowa;
ppb = rowb;

/* Do this the slow way to accumulate the 'in_use' flags, don't break out
* of the loop until the end; this validates the color-mapped data to
* ensure all pixels are valid color-map indexes.
*/
for (y=0, match=1; y<height && match; ++y, ppa += stridea, ppb += strideb)
{
png_uint_32 x;

for (x=0; x<width; ++x)
{
png_byte bval = ppb[x];
png_byte aval = ppa[x];

if (bval > bmax)
bmax = bval;

if (bval != aval)
match = 0;

in_use[aval] = 1;
if (aval > amax)
amax = aval;
}
}

/* If the buffers match then the colormaps must too. */
if (match)
{
/* Do the color-maps match, entry by entry?  Only check the 'in_use'
* entries.  An error here should be logged as a color-map error.
*/
png_const_bytep a_cmap = (png_const_bytep)a->colormap;
png_const_bytep b_cmap = (png_const_bytep)b->colormap;
int result = 1; /* match by default */

/* This is used in logpixel to get the error message correct. */
tr.is_palette = 1;

for (y=0; y<256; ++y, a_cmap += a_sample, b_cmap += b_sample)
if (in_use[y])
{
/* The colormap entries should be valid, but because libpng doesn't
* do any checking at present the original image may contain invalid
* pixel values.  These cause an error here (at present) unless
* accumulating errors in which case the program just ignores them.
*/
if (y >= a->image.colormap_entries)
{
if ((a->opts & ACCUMULATE) == 0)
{
char pindex[9];
sprintf(pindex, "%lu[%lu]", (unsigned long)y,
(unsigned long)a->image.colormap_entries);
logerror(a, a->file_name, ": bad pixel index: ", pindex);
}
result = 0;
}


else if (y >= b->image.colormap_entries)
{
               if ((a->opts & ACCUMULATE) == 0)
{
char pindex[9];
sprintf(pindex, "%lu[%lu]", (unsigned long)y,
(unsigned long)b->image.colormap_entries);
logerror(b, b->file_name, ": bad pixel index: ", pindex);
}
result = 0;
}

/* All the mismatches are logged here; there can only be 256! */
else if (!cmppixel(&tr, a_cmap, b_cmap, 0, y))
result = 0;
}

/* If reqested copy the error values back from the Transform. */
if (a->opts & ACCUMULATE)
{
tr.error_ptr[0] = tr.error[0];
tr.error_ptr[1] = tr.error[1];
tr.error_ptr[2] = tr.error[2];
tr.error_ptr[3] = tr.error[3];
result = 1; /* force a continue */
}

return result;
}

/* else the image buffers don't match pixel-wise so compare sample values
* instead, but first validate that the pixel indexes are in range (but
* only if not accumulating, when the error is ignored.)
*/
else if ((a->opts & ACCUMULATE) == 0)
{
/* Check the original image first,
* TODO: deal with input images with bad pixel values?
*/
if (amax >= a->image.colormap_entries)
{
char pindex[9];
sprintf(pindex, "%d[%lu]", amax,
(unsigned long)a->image.colormap_entries);
return logerror(a, a->file_name, ": bad pixel index: ", pindex);
}

else if (bmax >= b->image.colormap_entries)
{
char pindex[9];
sprintf(pindex, "%d[%lu]", bmax,
(unsigned long)b->image.colormap_entries);
return logerror(b, b->file_name, ": bad pixel index: ", pindex);
}
}
}

/* We can directly compare pixel values without the need to use the read
* or transform support (i.e. a memory compare) if:
*
* 1) The bit depth has not changed.
* 2) RGB to grayscale has not been done (the reverse is ok; we just compare
*    the three RGB values to the original grayscale.)
* 3) An alpha channel has not been removed from an 8-bit format, or the
*    8-bit alpha value of the pixel was 255 (opaque).
*
* If an alpha channel has been *added* then it must have the relevant opaque
* value (255 or 65535).
*
* The fist two the tests (in the order given above) (using the boolean
* equivalence !a && !b == !(a || b))
*/
if (!(((formata ^ formatb) & PNG_FORMAT_FLAG_LINEAR) |
(formata & (formatb ^ PNG_FORMAT_FLAG_COLOR) & PNG_FORMAT_FLAG_COLOR)))
{
/* Was an alpha channel changed? */
const png_uint_32 alpha_changed = (formata ^ formatb) &
PNG_FORMAT_FLAG_ALPHA;

/* Was an alpha channel removed?  (The third test.)  If so the direct
* comparison is only possible if the input alpha is opaque.
*/
alpha_removed = (formata & alpha_changed) != 0;

/* Was an alpha channel added? */
alpha_added = (formatb & alpha_changed) != 0;

/* The channels may have been moved between input and output, this finds
* out how, recording the result in the btoa array, which says where in
* 'a' to find each channel of 'b'.  If alpha was added then btoa[alpha]
* ends up as 4 (and is not used.)
*/
{
int i;
png_byte aloc[4];
png_byte bloc[4];

/* The following are used only if the formats match, except that
* 'bchannels' is a flag for matching formats.  btoa[x] says, for each
* channel in b, where to find the corresponding value in a, for the
* bchannels.  achannels may be different for a gray to rgb transform
* (a will be 1 or 2, b will be 3 or 4 channels.)
*/
(void)component_loc(aloc, formata);
bchannels = component_loc(bloc, formatb);

/* Hence the btoa array. */
for (i=0; i<4; ++i) if (bloc[i] < 4)
btoa[bloc[i]] = aloc[i]; /* may be '4' for alpha */

if (alpha_added)
alpha_added = bloc[0]; /* location of alpha channel in image b */

else
alpha_added = 4; /* Won't match an image b channel */

if (alpha_removed)
alpha_removed = aloc[0]; /* location of alpha channel in image a */

else
alpha_removed = 4;
}
}

else
{
/* Direct compare is not possible, cancel out all the corresponding local
* variables.
*/
bchannels = 0;
alpha_removed = alpha_added = 4;
btoa[3] = btoa[2] = btoa[1] = btoa[0] = 4; /* 4 == not present */
}

for (y=0; y<height; ++y, rowa += stridea, rowb += strideb)
{
png_const_bytep ppa, ppb;
png_uint_32 x;

for (x=0, ppa=rowa, ppb=rowb; x<width; ++x)
{
png_const_bytep psa, psb;

if (formata & PNG_FORMAT_FLAG_COLORMAP)
psa = (png_const_bytep)a->colormap + a_sample * *ppa++;
else
psa = ppa, ppa += a_sample;

if (formatb & PNG_FORMAT_FLAG_COLORMAP)
psb = (png_const_bytep)b->colormap + b_sample * *ppb++;
else
psb = ppb, ppb += b_sample;

/* Do the fast test if possible. */
if (bchannels)
{
/* Check each 'b' channel against either the corresponding 'a'
* channel or the opaque alpha value, as appropriate.  If
* alpha_removed value is set (not 4) then also do this only if the
* 'a' alpha channel (alpha_removed) is opaque; only relevant for
* the 8-bit case.
*/
if (formatb & PNG_FORMAT_FLAG_LINEAR) /* 16-bit checks */
{
png_const_uint_16p pua = aligncastconst(png_const_uint_16p, psa);
png_const_uint_16p pub = aligncastconst(png_const_uint_16p, psb);

switch (bchannels)
{
case 4:
if (pua[btoa[3]] != pub[3]) break;
case 3:
if (pua[btoa[2]] != pub[2]) break;
case 2:
if (pua[btoa[1]] != pub[1]) break;
case 1:
if (pua[btoa[0]] != pub[0]) break;
if (alpha_added != 4 && pub[alpha_added] != 65535) break;
continue; /* x loop */
default:
break; /* impossible */
}
}

else if (alpha_removed == 4 || psa[alpha_removed] == 255)
{
switch (bchannels)
{
case 4:
if (psa[btoa[3]] != psb[3]) break;
case 3:
if (psa[btoa[2]] != psb[2]) break;
case 2:
if (psa[btoa[1]] != psb[1]) break;
case 1:
if (psa[btoa[0]] != psb[0]) break;
if (alpha_added != 4 && psb[alpha_added] != 255) break;
continue; /* x loop */
default:
break; /* impossible */
}
}
}

/* If we get to here the fast match failed; do the slow match for this
* pixel.
*/
if (!cmppixel(&tr, psa, psb, x, y) && (a->opts & KEEP_GOING) == 0)
return 0; /* error case */
}
}

/* If reqested copy the error values back from the Transform. */
if (a->opts & ACCUMULATE)
{
tr.error_ptr[0] = tr.error[0];
tr.error_ptr[1] = tr.error[1];
tr.error_ptr[2] = tr.error[2];
tr.error_ptr[3] = tr.error[3];
}

return 1;
}

buffer_start_read(struct buffer *buffer)
{
   buffer->current = &buffer->first;
   buffer->read_count = 0;
}

gpc_g16q(Pixel *out, const Pixel *in, const Background *back)
{
 (void)back;
   out->r = out->g = out->b = u16d(YfromRGBint(in->r, in->g, in->b));
   out->a = in->a;
}

int readpng2_decode_data(mainprog_info *mainprog_ptr, uch *rawbuf, ulg length)
{
    png_structp png_ptr = (png_structp)mainprog_ptr->png_ptr;
    png_infop info_ptr = (png_infop)mainprog_ptr->info_ptr;


 /* setjmp() must be called in every function that calls a PNG-reading
     * libpng function */

 if (setjmp(mainprog_ptr->jmpbuf)) {
        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
        mainprog_ptr->png_ptr = NULL;
        mainprog_ptr->info_ptr = NULL;
 return 2;
 }


 /* hand off the next chunk of input data to libpng for decoding */

    png_process_data(png_ptr, info_ptr, rawbuf, length);

 return 0;
}

store_log(png_store* ps, png_const_structp pp, png_const_charp message,
 int is_error)
{
 /* The warning is copied to the error buffer if there are no errors and it is
    * the first warning.  The error is copied to the error buffer if it is the
    * first error (overwriting any prior warnings).
    */
 if (is_error ? (ps->nerrors)++ == 0 :
 (ps->nwarnings)++ == 0 && ps->nerrors == 0)
      store_message(ps, pp, ps->error, sizeof ps->error, 0, message);

 if (ps->verbose)
      store_verbose(ps, pp, is_error ? "error: " : "warning: ", message);
}

write_function(png_structp pp, png_bytep data, png_size_t size)
{
   buffer_write(get_dp(pp), get_buffer(pp), data, size);
}
