IMPEG2D_ERROR_CODES_T impeg2d_process_video_header(dec_state_t *ps_dec)
{
 stream_t *ps_stream;
    ps_stream = &ps_dec->s_bit_stream;
    IMPEG2D_ERROR_CODES_T e_error;

    impeg2d_next_code(ps_dec, SEQUENCE_HEADER_CODE);
 if(ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset)
 {
        e_error = impeg2d_dec_seq_hdr(ps_dec);
 if ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE != e_error)
 {
 return e_error;
 }
 }
 else
 {
 return IMPEG2D_BITSTREAM_BUFF_EXCEEDED_ERR;
 }
 if (impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) == EXTENSION_START_CODE)
 {
 /* MPEG2 Decoder */
 if(ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset)
 {
            e_error = impeg2d_dec_seq_ext(ps_dec);
 if ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE != e_error)
 {
 return e_error;
 }
 }
 else
 {
 return IMPEG2D_BITSTREAM_BUFF_EXCEEDED_ERR;
 }
 if(ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset)
 {
            e_error = impeg2d_dec_seq_ext_data(ps_dec);
 if ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE != e_error)
 {
 return e_error;
 }
 }
 return impeg2d_init_video_state(ps_dec,MPEG_2_VIDEO);
 }
 else
 {
 /* MPEG1 Decoder */
 if(ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset)
 {
            impeg2d_flush_ext_and_user_data(ps_dec);
 }
 return impeg2d_init_video_state(ps_dec,MPEG_1_VIDEO);
 }
}

IMPEG2D_ERROR_CODES_T impeg2d_dec_pic_ext_data(dec_state_t *ps_dec)
{
 stream_t *ps_stream;
    UWORD32     u4_start_code;
    IMPEG2D_ERROR_CODES_T e_error;

    e_error = (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;

    ps_stream      = &ps_dec->s_bit_stream;
    u4_start_code   = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
 while ( (u4_start_code == EXTENSION_START_CODE ||
            u4_start_code == USER_DATA_START_CODE) &&
 (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error &&
 (ps_stream->u4_offset < ps_stream->u4_max_offset))
 {
 if(u4_start_code == USER_DATA_START_CODE)
 {
            impeg2d_dec_user_data(ps_dec);
 }
 else
 {
            impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);
            u4_start_code   = impeg2d_bit_stream_nxt(ps_stream,EXT_ID_LEN);
 switch(u4_start_code)
 {
 case QUANT_MATRIX_EXT_ID:
                impeg2d_dec_quant_matrix_ext(ps_dec);
 break;
 case COPYRIGHT_EXT_ID:
                impeg2d_dec_copyright_ext(ps_dec);
 break;
 case PIC_DISPLAY_EXT_ID:
                impeg2d_dec_pic_disp_ext(ps_dec);
 break;
 case CAMERA_PARAM_EXT_ID:
                impeg2d_dec_cam_param_ext(ps_dec);
 break;
 case ITU_T_EXT_ID:
                impeg2d_dec_itu_t_ext(ps_dec);
 break;
 case PIC_SPATIAL_SCALABLE_EXT_ID:
 case PIC_TEMPORAL_SCALABLE_EXT_ID:
                e_error = IMPEG2D_SCALABLITY_NOT_SUP;
 break;
 default:
 /* In case its a reserved extension code */
                impeg2d_bit_stream_flush(ps_stream,EXT_ID_LEN);
                impeg2d_next_start_code(ps_dec);
 break;
 }
 }
        u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
 }
 return e_error;
}

void impeg2d_peek_next_start_code(dec_state_t *ps_dec)
{
 stream_t *ps_stream;
    ps_stream = &ps_dec->s_bit_stream;
    impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);

 while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)
 && (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))
 {
        impeg2d_bit_stream_get(ps_stream,8);
 }
 return;
}

void impeg2d_next_code(dec_state_t *ps_dec, UWORD32 u4_start_code_val)
{
 stream_t *ps_stream;
    ps_stream = &ps_dec->s_bit_stream;
    impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);

 while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val) &&
 (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))
 {

 if (impeg2d_bit_stream_get(ps_stream,8) != 0)
 {
 /* Ignore stuffing bit errors. */
 }

 }
 return;
}

static WORD32 impeg2d_init_thread_dec_ctxt(dec_state_t *ps_dec,
 dec_state_t *ps_dec_thd,
                                           WORD32 i4_min_mb_y)
{
    UNUSED(i4_min_mb_y);
    ps_dec_thd->i4_start_mb_y = 0;
    ps_dec_thd->i4_end_mb_y = ps_dec->u2_num_vert_mb;
    ps_dec_thd->u2_mb_x = 0;
    ps_dec_thd->u2_mb_y = 0;
    ps_dec_thd->u2_is_mpeg2 = ps_dec->u2_is_mpeg2;
    ps_dec_thd->u2_frame_width = ps_dec->u2_frame_width;
    ps_dec_thd->u2_frame_height = ps_dec->u2_frame_height;
    ps_dec_thd->u2_picture_width = ps_dec->u2_picture_width;
    ps_dec_thd->u2_horizontal_size = ps_dec->u2_horizontal_size;
    ps_dec_thd->u2_vertical_size = ps_dec->u2_vertical_size;
    ps_dec_thd->u2_create_max_width = ps_dec->u2_create_max_width;
    ps_dec_thd->u2_create_max_height = ps_dec->u2_create_max_height;
    ps_dec_thd->u2_header_done = ps_dec->u2_header_done;
    ps_dec_thd->u2_decode_header = ps_dec->u2_decode_header;

    ps_dec_thd->u2_num_horiz_mb = ps_dec->u2_num_horiz_mb;
    ps_dec_thd->u2_num_vert_mb = ps_dec->u2_num_vert_mb;
    ps_dec_thd->u2_num_flds_decoded = ps_dec->u2_num_flds_decoded;

    ps_dec_thd->u4_frm_buf_stride = ps_dec->u4_frm_buf_stride;

    ps_dec_thd->u2_field_dct = ps_dec->u2_field_dct;
    ps_dec_thd->u2_read_dct_type = ps_dec->u2_read_dct_type;

    ps_dec_thd->u2_read_motion_type = ps_dec->u2_read_motion_type;
    ps_dec_thd->u2_motion_type = ps_dec->u2_motion_type;

    ps_dec_thd->pu2_mb_type = ps_dec->pu2_mb_type;
    ps_dec_thd->u2_fld_pic = ps_dec->u2_fld_pic;
    ps_dec_thd->u2_frm_pic = ps_dec->u2_frm_pic;

    ps_dec_thd->u2_fld_parity = ps_dec->u2_fld_parity;

    ps_dec_thd->au2_fcode_data[0] = ps_dec->au2_fcode_data[0];
    ps_dec_thd->au2_fcode_data[1] = ps_dec->au2_fcode_data[1];

    ps_dec_thd->u1_quant_scale = ps_dec->u1_quant_scale;

    ps_dec_thd->u2_num_mbs_left = ps_dec->u2_num_mbs_left;
    ps_dec_thd->u2_first_mb = ps_dec->u2_first_mb;
    ps_dec_thd->u2_num_skipped_mbs = ps_dec->u2_num_skipped_mbs;

    memcpy(&ps_dec_thd->s_cur_frm_buf, &ps_dec->s_cur_frm_buf, sizeof(yuv_buf_t));
    memcpy(&ps_dec_thd->as_recent_fld[0][0], &ps_dec->as_recent_fld[0][0], sizeof(yuv_buf_t));
    memcpy(&ps_dec_thd->as_recent_fld[0][1], &ps_dec->as_recent_fld[0][1], sizeof(yuv_buf_t));
    memcpy(&ps_dec_thd->as_recent_fld[1][0], &ps_dec->as_recent_fld[1][0], sizeof(yuv_buf_t));
    memcpy(&ps_dec_thd->as_recent_fld[1][1], &ps_dec->as_recent_fld[1][1], sizeof(yuv_buf_t));
    memcpy(&ps_dec_thd->as_ref_buf, &ps_dec->as_ref_buf, sizeof(yuv_buf_t) * 2 * 2);


    ps_dec_thd->pf_decode_slice = ps_dec->pf_decode_slice;

    ps_dec_thd->pf_vld_inv_quant = ps_dec->pf_vld_inv_quant;

    memcpy(ps_dec_thd->pf_idct_recon, ps_dec->pf_idct_recon, sizeof(ps_dec->pf_idct_recon));

    memcpy(ps_dec_thd->pf_mc, ps_dec->pf_mc, sizeof(ps_dec->pf_mc));
    ps_dec_thd->pf_interpolate = ps_dec->pf_interpolate;
    ps_dec_thd->pf_copy_mb = ps_dec->pf_copy_mb;
    ps_dec_thd->pf_fullx_halfy_8x8              =  ps_dec->pf_fullx_halfy_8x8;
    ps_dec_thd->pf_halfx_fully_8x8              =  ps_dec->pf_halfx_fully_8x8;
    ps_dec_thd->pf_halfx_halfy_8x8              =  ps_dec->pf_halfx_halfy_8x8;
    ps_dec_thd->pf_fullx_fully_8x8              =  ps_dec->pf_fullx_fully_8x8;

    ps_dec_thd->pf_memset_8bit_8x8_block        =  ps_dec->pf_memset_8bit_8x8_block;
    ps_dec_thd->pf_memset_16bit_8x8_linear_block        =  ps_dec->pf_memset_16bit_8x8_linear_block;
    ps_dec_thd->pf_copy_yuv420p_buf             =   ps_dec->pf_copy_yuv420p_buf;
    ps_dec_thd->pf_fmt_conv_yuv420p_to_yuv422ile    =   ps_dec->pf_fmt_conv_yuv420p_to_yuv422ile;
    ps_dec_thd->pf_fmt_conv_yuv420p_to_yuv420sp_uv  =   ps_dec->pf_fmt_conv_yuv420p_to_yuv420sp_uv;
    ps_dec_thd->pf_fmt_conv_yuv420p_to_yuv420sp_vu  =   ps_dec->pf_fmt_conv_yuv420p_to_yuv420sp_vu;


    memcpy(ps_dec_thd->au1_intra_quant_matrix, ps_dec->au1_intra_quant_matrix, NUM_PELS_IN_BLOCK * sizeof(UWORD8));
    memcpy(ps_dec_thd->au1_inter_quant_matrix, ps_dec->au1_inter_quant_matrix, NUM_PELS_IN_BLOCK * sizeof(UWORD8));
    ps_dec_thd->pu1_inv_scan_matrix = ps_dec->pu1_inv_scan_matrix;


    ps_dec_thd->u2_progressive_sequence = ps_dec->u2_progressive_sequence;
    ps_dec_thd->e_pic_type =  ps_dec->e_pic_type;
    ps_dec_thd->u2_full_pel_forw_vector = ps_dec->u2_full_pel_forw_vector;
    ps_dec_thd->u2_forw_f_code =   ps_dec->u2_forw_f_code;
    ps_dec_thd->u2_full_pel_back_vector = ps_dec->u2_full_pel_back_vector;
    ps_dec_thd->u2_back_f_code = ps_dec->u2_back_f_code;

    memcpy(ps_dec_thd->ai2_mv, ps_dec->ai2_mv, (2*2*2)*sizeof(WORD16));
    memcpy(ps_dec_thd->au2_f_code, ps_dec->au2_f_code, (2*2)*sizeof(UWORD16));
    ps_dec_thd->u2_intra_dc_precision = ps_dec->u2_intra_dc_precision;
    ps_dec_thd->u2_picture_structure = ps_dec->u2_picture_structure;
    ps_dec_thd->u2_top_field_first = ps_dec->u2_top_field_first;
    ps_dec_thd->u2_frame_pred_frame_dct = ps_dec->u2_frame_pred_frame_dct;
    ps_dec_thd->u2_concealment_motion_vectors = ps_dec->u2_concealment_motion_vectors;
    ps_dec_thd->u2_q_scale_type =  ps_dec->u2_q_scale_type;
    ps_dec_thd->u2_intra_vlc_format = ps_dec->u2_intra_vlc_format;
    ps_dec_thd->u2_alternate_scan = ps_dec->u2_alternate_scan;
    ps_dec_thd->u2_repeat_first_field = ps_dec->u2_repeat_first_field;
    ps_dec_thd->u2_progressive_frame = ps_dec->u2_progressive_frame;
    ps_dec_thd->pu1_inp_bits_buf = ps_dec->pu1_inp_bits_buf;
    ps_dec_thd->u4_num_inp_bytes = ps_dec->u4_num_inp_bytes;
    ps_dec_thd->pv_jobq = ps_dec->pv_jobq;
    ps_dec_thd->pv_jobq_buf = ps_dec->pv_jobq_buf;
    ps_dec_thd->i4_jobq_buf_size = ps_dec->i4_jobq_buf_size;


    ps_dec_thd->u2_frame_rate_code = ps_dec->u2_frame_rate_code;
    ps_dec_thd->u2_frame_rate_extension_n = ps_dec->u2_frame_rate_extension_n;
    ps_dec_thd->u2_frame_rate_extension_d = ps_dec->u2_frame_rate_extension_d;
    ps_dec_thd->u2_framePeriod =   ps_dec->u2_framePeriod;
    ps_dec_thd->u2_display_horizontal_size = ps_dec->u2_display_horizontal_size;
    ps_dec_thd->u2_display_vertical_size = ps_dec->u2_display_vertical_size;
    ps_dec_thd->u2_aspect_ratio_info = ps_dec->u2_aspect_ratio_info;

    ps_dec_thd->ps_func_bi_direct = ps_dec->ps_func_bi_direct;
    ps_dec_thd->ps_func_forw_or_back = ps_dec->ps_func_forw_or_back;

 return 0;

}

WORD32 impeg2d_get_slice_pos(dec_state_multi_core_t *ps_dec_state_multi_core)
{
WORD32 u4_bits;
WORD32 i4_row;


dec_state_t *ps_dec = ps_dec_state_multi_core->ps_dec_state[0];
WORD32 i4_prev_row;
stream_t s_bitstrm;
WORD32 i4_start_row;
WORD32 i4_slice_bistream_ofst;
WORD32 i;
s_bitstrm = ps_dec->s_bit_stream;
i4_prev_row = -1;

ps_dec_state_multi_core->ps_dec_state[0]->i4_start_mb_y = 0;
ps_dec_state_multi_core->ps_dec_state[1]->i4_start_mb_y = -1;
ps_dec_state_multi_core->ps_dec_state[2]->i4_start_mb_y = -1;
ps_dec_state_multi_core->ps_dec_state[3]->i4_start_mb_y = -1;

ps_dec_state_multi_core->ps_dec_state[0]->i4_end_mb_y = ps_dec->u2_num_vert_mb;
ps_dec_state_multi_core->ps_dec_state[1]->i4_end_mb_y = -1;
ps_dec_state_multi_core->ps_dec_state[2]->i4_end_mb_y = -1;
ps_dec_state_multi_core->ps_dec_state[3]->i4_end_mb_y = -1;

if(ps_dec->i4_num_cores == 1)
return 0;
/* Reset the jobq to start of the jobq buffer */
impeg2_jobq_reset((jobq_t *)ps_dec->pv_jobq);

i4_start_row = -1;
i4_slice_bistream_ofst = 0;
while(1)
{
WORD32 i4_is_slice;

if(s_bitstrm.u4_offset + START_CODE_LEN >= s_bitstrm.u4_max_offset)
{
break;
}
u4_bits = impeg2d_bit_stream_nxt(&s_bitstrm,START_CODE_LEN);

i4_row = u4_bits & 0xFF;

/* Detect end of frame */
i4_is_slice = (((u4_bits >> 8) == 0x01) && (i4_row) && (i4_row <= ps_dec->u2_num_vert_mb));
if(!i4_is_slice)
break;


i4_row -= 1;


        if(i4_prev_row != i4_row)
{
/* Create a job for previous slice row */
if(i4_start_row != -1)
{
job_t s_job;
IV_API_CALL_STATUS_T ret;
s_job.i2_start_mb_y = i4_start_row;
s_job.i2_end_mb_y = i4_row;
s_job.i4_cmd = CMD_PROCESS;
s_job.i4_bistream_ofst = i4_slice_bistream_ofst;
ret = impeg2_jobq_queue(ps_dec->pv_jobq, &s_job, sizeof(s_job), 1, 0);
if(ret != IV_SUCCESS)
return ret;

}
/* Store current slice's bitstream offset */
i4_slice_bistream_ofst = s_bitstrm.u4_offset >> 3;
i4_slice_bistream_ofst -= (size_t)s_bitstrm.pv_bs_buf & 3;
i4_prev_row = i4_row;


/* Store current slice's row position */
i4_start_row = i4_row;

}


impeg2d_bit_stream_flush(&s_bitstrm, START_CODE_LEN);

// flush bytes till next start code
/* Flush the bytes till a  start code is encountered  */
while(impeg2d_bit_stream_nxt(&s_bitstrm, 24) != START_CODE_PREFIX)
{
impeg2d_bit_stream_get(&s_bitstrm, 8);

if(s_bitstrm.u4_offset >= s_bitstrm.u4_max_offset)
{
break;
}
}
}

/* Create job for the last slice row */
{
job_t s_job;
IV_API_CALL_STATUS_T e_ret;
s_job.i2_start_mb_y = i4_start_row;
s_job.i2_end_mb_y = ps_dec->u2_num_vert_mb;
s_job.i4_cmd = CMD_PROCESS;
s_job.i4_bistream_ofst = i4_slice_bistream_ofst;
e_ret = impeg2_jobq_queue(ps_dec->pv_jobq, &s_job, sizeof(s_job), 1, 0);
if(e_ret != IV_SUCCESS)
return e_ret;

}
if((NULL != ps_dec->ps_disp_pic) && ((0 == ps_dec->u4_share_disp_buf) || (IV_YUV_420P != ps_dec->i4_chromaFormat)))
{
for(i = 0; i < ps_dec->u2_vertical_size; i+=64)
{
job_t s_job;
IV_API_CALL_STATUS_T ret;
s_job.i2_start_mb_y = i;
s_job.i2_start_mb_y >>= 4;
s_job.i2_end_mb_y = (i + 64);
s_job.i2_end_mb_y >>= 4;
s_job.i4_cmd = CMD_FMTCONV;
s_job.i4_bistream_ofst = 0;
ret = impeg2_jobq_queue(ps_dec->pv_jobq, &s_job, sizeof(s_job), 1, 0);
if(ret != IV_SUCCESS)
return ret;

}
}

impeg2_jobq_terminate(ps_dec->pv_jobq);
ps_dec->i4_bytes_consumed = s_bitstrm.u4_offset >> 3;
ps_dec->i4_bytes_consumed -= ((size_t)s_bitstrm.pv_bs_buf & 3);

return 0;
}

void impeg2d_dec_cam_param_ext(dec_state_t *ps_dec)
{

    UWORD32 u4_bits_to_flush;

    u4_bits_to_flush = CAMERA_PARAMETER_EXTENSION_LEN;

 while(u4_bits_to_flush >= 32 )
 {
        impeg2d_bit_stream_flush(&ps_dec->s_bit_stream,32);
        u4_bits_to_flush = u4_bits_to_flush - 32;
 }

 if(u4_bits_to_flush > 0)
 {
        impeg2d_bit_stream_flush(&ps_dec->s_bit_stream,u4_bits_to_flush);
 }

  impeg2d_next_start_code(ps_dec);
}

IMPEG2D_ERROR_CODES_T impeg2d_dec_seq_scale_ext(dec_state_t *ps_dec)
{
    UNUSED(ps_dec);
 return IMPEG2D_SCALABILITIY_NOT_SUPPORTED;
}

void impeg2d_dec_p_mb_params(dec_state_t *ps_dec)
 {
     stream_t *ps_stream = &ps_dec->s_bit_stream;
     UWORD16 u2_mb_addr_incr;
    UWORD16 u2_total_len;
    UWORD16 u2_len;
    UWORD16 u2_mb_type;
    UWORD32 u4_next_word;
 const dec_mb_params_t *ps_dec_mb_params;
 if(impeg2d_bit_stream_nxt(ps_stream,1) == 1)
 {
        impeg2d_bit_stream_flush(ps_stream,1);

 }
 else
 {
        u2_mb_addr_incr = impeg2d_get_mb_addr_incr(ps_stream);
 if(0 == ps_dec->u2_first_mb)
 {
 /****************************************************************/
 /* If the 2nd member of a field picture pair is a P picture and */
 /* the first one was an I picture, there cannot be any skipped  */
 /* MBs in the second field picture                              */
 /****************************************************************/
 /*
            if((dec->picture_structure != FRAME_PICTURE) &&
                (dec->f->FieldFuncCall != 0) &&
                (dec->las->u1_last_coded_vop_type == I))
            {
                core0_err_handler((void *)(VOLParams),
                    ITTMPEG2_ERR_INVALID_MB_SKIP);
            }
            */
 /****************************************************************/
 /* In MPEG-2, the last MB of the row cannot be skipped and the  */
 /* MBAddrIncr cannot be such that it will take the current MB   */
 /* beyond the current row                                       */
 /* In MPEG-1, the slice could start and end anywhere and is not */
 /* restricted to a row like in MPEG-2. Hence this check should  */
 /* not be done for MPEG-1 streams.                              */
 /****************************************************************/
 if(ps_dec->u2_is_mpeg2 && ((ps_dec->u2_mb_x + u2_mb_addr_incr) > ps_dec->u2_num_horiz_mb) )
 {
                u2_mb_addr_incr    = ps_dec->u2_num_horiz_mb - ps_dec->u2_mb_x;
 }

            impeg2d_dec_skip_mbs(ps_dec, (UWORD16)(u2_mb_addr_incr - 1));
 }

 }
    u4_next_word = (UWORD16)impeg2d_bit_stream_nxt(ps_stream,16);
 /*-----------------------------------------------------------------------*/
 /* MB type                                                               */
 /*-----------------------------------------------------------------------*/
 {
        u2_mb_type   = ps_dec->pu2_mb_type[BITS((UWORD16)u4_next_word,15,10)];
        u2_len      = BITS(u2_mb_type,15,8);
        u2_total_len = u2_len;
        u4_next_word = (UWORD16)LSW((UWORD16)u4_next_word << u2_len);
 }
 /*-----------------------------------------------------------------------*/
 /* motion type                                                           */
 /*-----------------------------------------------------------------------*/
 {
 if((u2_mb_type & MB_FORW_OR_BACK) &&  ps_dec->u2_read_motion_type)
 {
            WORD32 i4_motion_type;
            ps_dec->u2_motion_type = BITS((UWORD16)u4_next_word,15,14);
            u2_total_len        += MB_MOTION_TYPE_LEN;
            u4_next_word        = (UWORD16)LSW((UWORD16)u4_next_word << MB_MOTION_TYPE_LEN);
            i4_motion_type     = ps_dec->u2_motion_type;

 if((i4_motion_type == 0) ||
 (i4_motion_type == 4) ||
 (i4_motion_type > 7))
 {
                i4_motion_type = 1;
 }

 }
 }
 /*-----------------------------------------------------------------------*/
 /* dct type                                                              */
 /*-----------------------------------------------------------------------*/
 {
 if((u2_mb_type & MB_CODED) && ps_dec->u2_read_dct_type)
 {
            ps_dec->u2_field_dct = BIT((UWORD16)u4_next_word,15);
            u2_total_len += MB_DCT_TYPE_LEN;
            u4_next_word = (UWORD16)LSW((UWORD16)u4_next_word << MB_DCT_TYPE_LEN);
 }
 }
 /*-----------------------------------------------------------------------*/
 /* Quant scale code                                                      */
 /*-----------------------------------------------------------------------*/
 if(u2_mb_type & MB_QUANT)
 {
        UWORD16 u2_quant_scale_code;
        u2_quant_scale_code = BITS((UWORD16)u4_next_word,15,11);

        ps_dec->u1_quant_scale = (ps_dec->u2_q_scale_type) ?
            gau1_impeg2_non_linear_quant_scale[u2_quant_scale_code] : (u2_quant_scale_code << 1);
        u2_total_len += MB_QUANT_SCALE_CODE_LEN;
 }
    impeg2d_bit_stream_flush(ps_stream,u2_total_len);
 /*-----------------------------------------------------------------------*/
 /* Set the function pointers                                             */
 /*-----------------------------------------------------------------------*/
    ps_dec->u2_coded_mb    = (UWORD16)(u2_mb_type & MB_CODED);

 if(u2_mb_type & MB_FORW_OR_BACK)
 {

        UWORD16 refPic      = !(u2_mb_type & MB_MV_FORW);
        UWORD16 index       = (ps_dec->u2_motion_type);
        ps_dec->u2_prev_intra_mb    = 0;

         ps_dec->e_mb_pred         = (e_pred_direction_t)refPic;
         ps_dec_mb_params = &ps_dec->ps_func_forw_or_back[index];
         ps_dec->s_mb_type = ps_dec_mb_params->s_mb_type;
         ps_dec_mb_params->pf_func_mb_params(ps_dec);
 
     }
 else if(u2_mb_type & MB_TYPE_INTRA)
 {
        ps_dec->u2_prev_intra_mb    = 1;
        impeg2d_dec_intra_mb(ps_dec);

 }
 else
 {
        ps_dec->u2_prev_intra_mb    = 0;
        ps_dec->e_mb_pred = FORW;
        ps_dec->u2_motion_type = 0;
        impeg2d_dec_0mv_coded_mb(ps_dec);
 }

 /*-----------------------------------------------------------------------*/
 /* decode cbp                                                            */
 /*-----------------------------------------------------------------------*/
 if((u2_mb_type & MB_TYPE_INTRA))
 {
        ps_dec->u2_cbp  = 0x3f;
        ps_dec->u2_prev_intra_mb    = 1;
 }
 else
 {
        ps_dec->u2_prev_intra_mb  = 0;
        ps_dec->u2_def_dc_pred[Y_LUMA] = 128 << ps_dec->u2_intra_dc_precision;
        ps_dec->u2_def_dc_pred[U_CHROMA] = 128 << ps_dec->u2_intra_dc_precision;
        ps_dec->u2_def_dc_pred[V_CHROMA] = 128 << ps_dec->u2_intra_dc_precision;
 if((ps_dec->u2_coded_mb))
 {
            UWORD16 cbpValue;
            cbpValue  = gau2_impeg2d_cbp_code[impeg2d_bit_stream_nxt(ps_stream,MB_CBP_LEN)];
            ps_dec->u2_cbp  = cbpValue & 0xFF;
            impeg2d_bit_stream_flush(ps_stream,(cbpValue >> 8) & 0x0FF);
 }
 else
 {

             ps_dec->u2_cbp  = 0;
         }
     }
 }

void impeg2d_dec_pnb_mb_params(dec_state_t *ps_dec)
 {
     stream_t *ps_stream = &ps_dec->s_bit_stream;
     UWORD16 u2_mb_addr_incr;
    UWORD16 u2_total_len;
    UWORD16 u2_len;
    UWORD16 u2_mb_type;
    UWORD32 u4_next_word;
 const dec_mb_params_t *ps_dec_mb_params;
 if(impeg2d_bit_stream_nxt(ps_stream,1) == 1)
 {
        impeg2d_bit_stream_flush(ps_stream,1);

 }
 else
 {
        u2_mb_addr_incr = impeg2d_get_mb_addr_incr(ps_stream);

 if(ps_dec->u2_first_mb)
 {
 /****************************************************************/
 /* Section 6.3.17                                               */
 /* The first MB of a slice cannot be skipped                    */
 /* But the mb_addr_incr can be > 1, because at the beginning of */
 /* a slice, it indicates the offset from the last MB in the     */
 /* previous row. Hence for the first slice in a row, the        */
 /* mb_addr_incr needs to be 1.                                  */
 /****************************************************************/
 /* MB_x is set to zero whenever MB_y changes.                   */
            ps_dec->u2_mb_x = u2_mb_addr_incr - 1;
 /* For error resilience */
            ps_dec->u2_mb_x = MIN(ps_dec->u2_mb_x, (ps_dec->u2_num_horiz_mb - 1));

 /****************************************************************/
 /* mb_addr_incr is forced to 1 because in this decoder it is used */
 /* more as an indicator of the number of MBs skipped than the   */
 /* as defined by the standard (Section 6.3.17)                  */
 /****************************************************************/
            u2_mb_addr_incr = 1;
            ps_dec->u2_first_mb = 0;
 }
 else
 {
 /****************************************************************/
 /* In MPEG-2, the last MB of the row cannot be skipped and the  */
 /* mb_addr_incr cannot be such that it will take the current MB   */
 /* beyond the current row                                       */
 /* In MPEG-1, the slice could start and end anywhere and is not */
 /* restricted to a row like in MPEG-2. Hence this check should  */
 /* not be done for MPEG-1 streams.                              */
 /****************************************************************/
 if(ps_dec->u2_is_mpeg2 &&
 ((ps_dec->u2_mb_x + u2_mb_addr_incr) > ps_dec->u2_num_horiz_mb))
 {
                u2_mb_addr_incr    = ps_dec->u2_num_horiz_mb - ps_dec->u2_mb_x;
 }


            impeg2d_dec_skip_mbs(ps_dec, (UWORD16)(u2_mb_addr_incr - 1));
 }

 }
    u4_next_word = (UWORD16)impeg2d_bit_stream_nxt(ps_stream,16);
 /*-----------------------------------------------------------------------*/
 /* MB type                                                               */
 /*-----------------------------------------------------------------------*/
 {
        u2_mb_type   = ps_dec->pu2_mb_type[BITS((UWORD16)u4_next_word,15,10)];
        u2_len      = BITS(u2_mb_type,15,8);
        u2_total_len = u2_len;
        u4_next_word = (UWORD16)LSW((UWORD16)u4_next_word << u2_len);
 }
 /*-----------------------------------------------------------------------*/
 /* motion type                                                           */
 /*-----------------------------------------------------------------------*/
 {
        WORD32 i4_motion_type = ps_dec->u2_motion_type;

 if((u2_mb_type & MB_FORW_OR_BACK) &&  ps_dec->u2_read_motion_type)
 {
            ps_dec->u2_motion_type = BITS((UWORD16)u4_next_word,15,14);
            u2_total_len += MB_MOTION_TYPE_LEN;
            u4_next_word = (UWORD16)LSW((UWORD16)u4_next_word << MB_MOTION_TYPE_LEN);
            i4_motion_type     = ps_dec->u2_motion_type;

 }


 if ((u2_mb_type & MB_FORW_OR_BACK) &&
 ((i4_motion_type == 0) ||
 (i4_motion_type == 3) ||
 (i4_motion_type == 4) ||
 (i4_motion_type >= 7)))
 {
            i4_motion_type = 1;
 }

 }
 /*-----------------------------------------------------------------------*/
 /* dct type                                                              */
 /*-----------------------------------------------------------------------*/
 {
 if((u2_mb_type & MB_CODED) && ps_dec->u2_read_dct_type)
 {
            ps_dec->u2_field_dct = BIT((UWORD16)u4_next_word,15);
            u2_total_len += MB_DCT_TYPE_LEN;
            u4_next_word = (UWORD16)LSW((UWORD16)u4_next_word << MB_DCT_TYPE_LEN);
 }
 }
 /*-----------------------------------------------------------------------*/
 /* Quant scale code                                                      */
 /*-----------------------------------------------------------------------*/
 if(u2_mb_type & MB_QUANT)
 {
        UWORD16 u2_quant_scale_code;
        u2_quant_scale_code = BITS((UWORD16)u4_next_word,15,11);

        ps_dec->u1_quant_scale = (ps_dec->u2_q_scale_type) ?
            gau1_impeg2_non_linear_quant_scale[u2_quant_scale_code] : (u2_quant_scale_code << 1);
        u2_total_len += MB_QUANT_SCALE_CODE_LEN;
 }
    impeg2d_bit_stream_flush(ps_stream,u2_total_len);
 /*-----------------------------------------------------------------------*/
 /* Set the function pointers                                             */
 /*-----------------------------------------------------------------------*/
    ps_dec->u2_coded_mb    = (UWORD16)(u2_mb_type & MB_CODED);

 if(u2_mb_type & MB_BIDRECT)
 {
        UWORD16 u2_index       = (ps_dec->u2_motion_type);

        ps_dec->u2_prev_intra_mb    = 0;

         ps_dec->e_mb_pred         = BIDIRECT;
         ps_dec_mb_params = &ps_dec->ps_func_bi_direct[u2_index];
         ps_dec->s_mb_type = ps_dec_mb_params->s_mb_type;
         ps_dec_mb_params->pf_func_mb_params(ps_dec);
     }
     else if(u2_mb_type & MB_FORW_OR_BACK)
 {

        UWORD16 u2_refPic      = !(u2_mb_type & MB_MV_FORW);
        UWORD16 u2_index       = (ps_dec->u2_motion_type);
        ps_dec->u2_prev_intra_mb    = 0;

         ps_dec->e_mb_pred         = (e_pred_direction_t)u2_refPic;
         ps_dec_mb_params = &ps_dec->ps_func_forw_or_back[u2_index];
         ps_dec->s_mb_type = ps_dec_mb_params->s_mb_type;
         ps_dec_mb_params->pf_func_mb_params(ps_dec);
 
     }
 else if(u2_mb_type & MB_TYPE_INTRA)
 {
        ps_dec->u2_prev_intra_mb    = 1;
        impeg2d_dec_intra_mb(ps_dec);

 }
 else
 {
        ps_dec->u2_prev_intra_mb =0;
        ps_dec->e_mb_pred = FORW;
        ps_dec->u2_motion_type = 0;
        impeg2d_dec_0mv_coded_mb(ps_dec);
 }

 /*-----------------------------------------------------------------------*/
 /* decode cbp                                                            */
 /*-----------------------------------------------------------------------*/
 if((u2_mb_type & MB_TYPE_INTRA))
 {
        ps_dec->u2_cbp  = 0x3f;
        ps_dec->u2_prev_intra_mb    = 1;
 }
 else
 {
        ps_dec->u2_prev_intra_mb  = 0;
        ps_dec->u2_def_dc_pred[Y_LUMA] = 128 << ps_dec->u2_intra_dc_precision;
        ps_dec->u2_def_dc_pred[U_CHROMA] = 128 << ps_dec->u2_intra_dc_precision;
        ps_dec->u2_def_dc_pred[V_CHROMA] = 128 << ps_dec->u2_intra_dc_precision;
 if((ps_dec->u2_coded_mb))
 {
            UWORD16 cbpValue;
            cbpValue  = gau2_impeg2d_cbp_code[impeg2d_bit_stream_nxt(ps_stream,MB_CBP_LEN)];
            ps_dec->u2_cbp  = cbpValue & 0xFF;
            impeg2d_bit_stream_flush(ps_stream,(cbpValue >> 8) & 0x0FF);
 }
 else
 {

             ps_dec->u2_cbp  = 0;
         }
     }
 }

void impeg2d_dec_copyright_ext(dec_state_t *ps_dec)
{
    UWORD32 u4_bits_to_flush;

    u4_bits_to_flush = COPYRIGHT_EXTENSION_LEN;

 while(u4_bits_to_flush >= 32 )
 {
        impeg2d_bit_stream_flush(&ps_dec->s_bit_stream,32);
        u4_bits_to_flush = u4_bits_to_flush - 32;
 }

 if(u4_bits_to_flush > 0)
 {
        impeg2d_bit_stream_flush(&ps_dec->s_bit_stream,u4_bits_to_flush);
 }


  impeg2d_next_start_code(ps_dec);
}

void impeg2d_dec_pic_data(dec_state_t *ps_dec)
{

    WORD32 i;
 dec_state_multi_core_t *ps_dec_state_multi_core;

    UWORD32  u4_error_code;

 dec_state_t *ps_dec_thd;
    WORD32 i4_status;
    WORD32 i4_min_mb_y;


 /* Resetting the MB address and MB coordinates at the start of the Frame */
    ps_dec->u2_mb_x = ps_dec->u2_mb_y = 0;
    u4_error_code = 0;

    ps_dec_state_multi_core = ps_dec->ps_dec_state_multi_core;
    impeg2d_get_slice_pos(ps_dec_state_multi_core);

    i4_min_mb_y = 1;
 for(i=0; i < ps_dec->i4_num_cores - 1; i++)
 {

        ps_dec_thd = ps_dec_state_multi_core->ps_dec_state[i+1];

        ps_dec_thd->ps_disp_pic = ps_dec->ps_disp_pic;
        ps_dec_thd->ps_disp_frm_buf = ps_dec->ps_disp_frm_buf;

        i4_status = impeg2d_init_thread_dec_ctxt(ps_dec, ps_dec_thd, i4_min_mb_y);

 if(i4_status == 0)
 {
            ithread_create(ps_dec_thd->pv_codec_thread_handle, NULL, (void *)impeg2d_dec_pic_data_thread, ps_dec_thd);
            ps_dec_state_multi_core->au4_thread_launched[i + 1] = 1;
            i4_min_mb_y = ps_dec_thd->u2_mb_y + 1;
 }
 else
 {
            ps_dec_state_multi_core->au4_thread_launched[i + 1] = 0;
 break;
 }
 }

    impeg2d_dec_pic_data_thread(ps_dec);

 for(i=0; i < (ps_dec->i4_num_cores - 1); i++)
 {
 if(ps_dec_state_multi_core->au4_thread_launched[i + 1] == 1)
 {
            ps_dec_thd = ps_dec_state_multi_core->ps_dec_state[i+1];
            ithread_join(ps_dec_thd->pv_codec_thread_handle, NULL);
 }
 }

    ps_dec->u4_error_code = u4_error_code;

}

IMPEG2D_ERROR_CODES_T impeg2d_dec_slice(dec_state_t *ps_dec)
{
 stream_t *ps_stream;
    UWORD32 u4_slice_vertical_position;
    UWORD32 u4_slice_vertical_position_extension;
    IMPEG2D_ERROR_CODES_T e_error;

    ps_stream = &ps_dec->s_bit_stream;

 /*------------------------------------------------------------------------*/
 /* All the profiles supported require restricted slice structure. Hence   */
 /* there is no need to store slice_vertical_position. Note that max       */
 /* height supported does not exceed 2800 and scalablity is not supported  */
 /*------------------------------------------------------------------------*/

 /* Remove the slice start code */
    impeg2d_bit_stream_flush(ps_stream,START_CODE_PREFIX_LEN);
    u4_slice_vertical_position = impeg2d_bit_stream_get(ps_stream, 8);
 if(u4_slice_vertical_position > 2800)
 {
        u4_slice_vertical_position_extension = impeg2d_bit_stream_get(ps_stream, 3);
        u4_slice_vertical_position += (u4_slice_vertical_position_extension << 7);
 }

 if((u4_slice_vertical_position > ps_dec->u2_num_vert_mb) ||
 (u4_slice_vertical_position == 0))
 {
 return IMPEG2D_INVALID_VERT_SIZE;
 }

    u4_slice_vertical_position--;
 if (ps_dec->u2_mb_y != u4_slice_vertical_position)
 {
        ps_dec->u2_mb_y    = u4_slice_vertical_position;
        ps_dec->u2_mb_x    = 0;
 }
    ps_dec->u2_first_mb = 1;

 /*------------------------------------------------------------------------*/
 /* Quant scale code decoding                                              */
 /*------------------------------------------------------------------------*/
 {
        UWORD16 u2_quant_scale_code;
        u2_quant_scale_code = impeg2d_bit_stream_get(ps_stream,5);
        ps_dec->u1_quant_scale = (ps_dec->u2_q_scale_type) ?
            gau1_impeg2_non_linear_quant_scale[u2_quant_scale_code] : (u2_quant_scale_code << 1);
 }

 if (impeg2d_bit_stream_nxt(ps_stream,1) == 1)
 {
        impeg2d_bit_stream_flush(ps_stream,9);
 /* Flush extra bit information */
 while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&
               ps_stream->u4_offset < ps_stream->u4_max_offset)
 {
            impeg2d_bit_stream_flush(ps_stream,9);
 }
 }
    impeg2d_bit_stream_get_bit(ps_stream);

 /* Reset the DC predictors to reset values given in Table 7.2 at the start*/
 /* of slice data */
    ps_dec->u2_def_dc_pred[Y_LUMA] = 128 << ps_dec->u2_intra_dc_precision;
    ps_dec->u2_def_dc_pred[U_CHROMA] = 128 << ps_dec->u2_intra_dc_precision;
    ps_dec->u2_def_dc_pred[V_CHROMA] = 128 << ps_dec->u2_intra_dc_precision;
 /*------------------------------------------------------------------------*/
 /* dec->DecMBsinSlice() implements the following psuedo code from standard*/
 /* do                                                                     */
 /* {                                                                      */
 /*      macroblock()                                                      */
 /* } while (impeg2d_bit_stream_nxt() != '000 0000 0000 0000 0000 0000')      */
 /*------------------------------------------------------------------------*/

    e_error = ps_dec->pf_decode_slice(ps_dec);
 if ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE != e_error)
 {
 return e_error;
 }

 /* Check for the MBy index instead of number of MBs left, because the
     * number of MBs left in case of multi-thread decode is the number of MBs
     * in that row only
     */
 if(ps_dec->u2_mb_y < ps_dec->u2_num_vert_mb)
        impeg2d_next_start_code(ps_dec);

 return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;
}

void impeg2d_dec_pic_coding_ext(dec_state_t *ps_dec)
{
 stream_t *ps_stream;

    ps_stream = &ps_dec->s_bit_stream;
    impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);
 /* extension code identifier */
    impeg2d_bit_stream_get(ps_stream,4);

    ps_dec->au2_f_code[0][0] = impeg2d_bit_stream_get(ps_stream,4);
    ps_dec->au2_f_code[0][1] = impeg2d_bit_stream_get(ps_stream,4);
    ps_dec->au2_f_code[1][0] = impeg2d_bit_stream_get(ps_stream,4);
    ps_dec->au2_f_code[1][1] = impeg2d_bit_stream_get(ps_stream,4);
    ps_dec->u2_intra_dc_precision        = impeg2d_bit_stream_get(ps_stream,2);
    ps_dec->u2_picture_structure            = impeg2d_bit_stream_get(ps_stream,2);
    ps_dec->u2_top_field_first              = impeg2d_bit_stream_get_bit(ps_stream);
    ps_dec->u2_frame_pred_frame_dct         = impeg2d_bit_stream_get_bit(ps_stream);
    ps_dec->u2_concealment_motion_vectors   = impeg2d_bit_stream_get_bit(ps_stream);
    ps_dec->u2_q_scale_type                 = impeg2d_bit_stream_get_bit(ps_stream);
    ps_dec->u2_intra_vlc_format             = impeg2d_bit_stream_get_bit(ps_stream);
    ps_dec->u2_alternate_scan               = impeg2d_bit_stream_get_bit(ps_stream);
    ps_dec->u2_repeat_first_field           = impeg2d_bit_stream_get_bit(ps_stream);
 /* Flush chroma_420_type */
    impeg2d_bit_stream_get_bit(ps_stream);

    ps_dec->u2_progressive_frame            = impeg2d_bit_stream_get_bit(ps_stream);
 if (impeg2d_bit_stream_get_bit(ps_stream))
 {
 /* Flush v_axis, field_sequence, burst_amplitude, sub_carrier_phase */
        impeg2d_bit_stream_flush(ps_stream,20);
 }
    impeg2d_next_start_code(ps_dec);


 if(VERTICAL_SCAN == ps_dec->u2_alternate_scan)
 {
        ps_dec->pu1_inv_scan_matrix = (UWORD8 *)gau1_impeg2_inv_scan_vertical;
 }
 else
 {
        ps_dec->pu1_inv_scan_matrix = (UWORD8 *)gau1_impeg2_inv_scan_zig_zag;
 }
}

IMPEG2D_ERROR_CODES_T impeg2d_process_video_bit_stream(dec_state_t *ps_dec)
{
 stream_t *ps_stream;
    UWORD32 u4_next_bits, u4_start_code_found;
    IMPEG2D_ERROR_CODES_T e_error;

    ps_stream = &ps_dec->s_bit_stream;
    impeg2d_next_start_code(ps_dec);
 /* If the stream is MPEG-2 compliant stream */
    u4_start_code_found = 0;

 if(ps_dec->u2_is_mpeg2)
 {
 /* MPEG2 decoding starts */
 while((u4_start_code_found == 0) && (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))
 {
            u4_next_bits = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);

 if(u4_next_bits == SEQUENCE_HEADER_CODE)
 {
 if(ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset)
 {
                    e_error = impeg2d_dec_seq_hdr(ps_dec);
 if ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE != e_error)
 {
 return e_error;
 }

                    u4_start_code_found = 0;

 }
 else
 {
 return IMPEG2D_BITSTREAM_BUFF_EXCEEDED_ERR;
 }


 if(ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset)
 {
                    IMPEG2D_ERROR_CODES_T e_error;
                    e_error = impeg2d_dec_seq_ext(ps_dec);
 if ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE != e_error)
 {
 return e_error;
 }
                    u4_start_code_found = 0;

 }
 else
 {
 return IMPEG2D_BITSTREAM_BUFF_EXCEEDED_ERR;
 }
 }
 else if((u4_next_bits == USER_DATA_START_CODE) || (u4_next_bits == EXTENSION_START_CODE))
 {
 if(ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset)
 {
                    impeg2d_dec_seq_ext_data(ps_dec);
                    u4_start_code_found = 0;

 }

 }
 else if((ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset)
 && (u4_next_bits == GOP_START_CODE))
 {
                impeg2d_dec_grp_of_pic_hdr(ps_dec);
                impeg2d_dec_user_data(ps_dec);
                u4_start_code_found = 0;

 }
 else if((ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset)
 && (u4_next_bits == PICTURE_START_CODE))
 {

                e_error = impeg2d_dec_pic_hdr(ps_dec);
 if ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE != e_error)
 {
 return e_error;
 }
                impeg2d_dec_pic_coding_ext(ps_dec);
                e_error = impeg2d_dec_pic_ext_data(ps_dec);
 if ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE != e_error)
 {
 return e_error;
 }
                impeg2d_pre_pic_dec_proc(ps_dec);
                impeg2d_dec_pic_data(ps_dec);
                impeg2d_post_pic_dec_proc(ps_dec);
                u4_start_code_found = 1;
 }
 else

 {
                FLUSH_BITS(ps_dec->s_bit_stream.u4_offset, ps_dec->s_bit_stream.u4_buf, ps_dec->s_bit_stream.u4_buf_nxt, 8, ps_dec->s_bit_stream.pu4_buf_aligned);

 }
 if(u4_start_code_found == 0)
 {
                impeg2d_next_start_code(ps_dec);
 }
 }
 if((u4_start_code_found == 0) && (ps_dec->s_bit_stream.u4_offset > ps_dec->s_bit_stream.u4_max_offset))
 {
 return IMPEG2D_FRM_HDR_START_CODE_NOT_FOUND;
 }

 }
 /* If the stream is MPEG-1 compliant stream */
 else
 {
 while((u4_start_code_found == 0) && (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))
 {
            u4_next_bits = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);

 if(impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) == SEQUENCE_HEADER_CODE)
 {
 if(ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset)
 {
                    e_error = impeg2d_dec_seq_hdr(ps_dec);
 if ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE != e_error)
 {
 return e_error;
 }

                    u4_start_code_found = 0;
 }
 else
 {
 return IMPEG2D_BITSTREAM_BUFF_EXCEEDED_ERR;
 }
 }
 else if((ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset) && (u4_next_bits == EXTENSION_START_CODE || u4_next_bits == USER_DATA_START_CODE))
 {
                impeg2d_flush_ext_and_user_data(ps_dec);
                u4_start_code_found = 0;
 }


 else if ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) == GOP_START_CODE)
 && (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))
 {
                impeg2d_dec_grp_of_pic_hdr(ps_dec);
                impeg2d_flush_ext_and_user_data(ps_dec);
                u4_start_code_found = 0;
 }
 else if ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) == PICTURE_START_CODE)
 && (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))
 {

                e_error = impeg2d_dec_pic_hdr(ps_dec);
 if ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE != e_error)
 {
 return e_error;
 }
                impeg2d_flush_ext_and_user_data(ps_dec);
                impeg2d_pre_pic_dec_proc(ps_dec);
                impeg2d_dec_pic_data(ps_dec);
                impeg2d_post_pic_dec_proc(ps_dec);
                u4_start_code_found = 1;
 }
 else
 {
                FLUSH_BITS(ps_dec->s_bit_stream.u4_offset, ps_dec->s_bit_stream.u4_buf, ps_dec->s_bit_stream.u4_buf_nxt, 8, ps_dec->s_bit_stream.pu4_buf_aligned);
 }
            impeg2d_next_start_code(ps_dec);

 }
 if((u4_start_code_found == 0) && (ps_dec->s_bit_stream.u4_offset > ps_dec->s_bit_stream.u4_max_offset))
 {
 return IMPEG2D_FRM_HDR_START_CODE_NOT_FOUND;
 }
 }

 return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;
}

IMPEG2D_ERROR_CODES_T impeg2d_dec_pic_hdr(dec_state_t *ps_dec)
{
 stream_t *ps_stream;
    ps_stream = &ps_dec->s_bit_stream;

    impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);
 /* Flush temporal reference */
    impeg2d_bit_stream_get(ps_stream,10);

 /* Picture type */
    ps_dec->e_pic_type = (e_pic_type_t)impeg2d_bit_stream_get(ps_stream,3);
 if((ps_dec->e_pic_type < I_PIC) || (ps_dec->e_pic_type > D_PIC))
 {
        impeg2d_next_code(ps_dec, PICTURE_START_CODE);
 return IMPEG2D_INVALID_PIC_TYPE;
 }

 /* Flush vbv_delay */
    impeg2d_bit_stream_get(ps_stream,16);

 if(ps_dec->e_pic_type == P_PIC || ps_dec->e_pic_type == B_PIC)
 {
        ps_dec->u2_full_pel_forw_vector = impeg2d_bit_stream_get_bit(ps_stream);
        ps_dec->u2_forw_f_code          = impeg2d_bit_stream_get(ps_stream,3);
 }
 if(ps_dec->e_pic_type == B_PIC)
 {
        ps_dec->u2_full_pel_back_vector = impeg2d_bit_stream_get_bit(ps_stream);
        ps_dec->u2_back_f_code          = impeg2d_bit_stream_get(ps_stream,3);
 }

 if(ps_dec->u2_is_mpeg2 == 0)
 {
        ps_dec->au2_f_code[0][0] = ps_dec->au2_f_code[0][1] = ps_dec->u2_forw_f_code;
        ps_dec->au2_f_code[1][0] = ps_dec->au2_f_code[1][1] = ps_dec->u2_back_f_code;
 }

 /*-----------------------------------------------------------------------*/
 /*  Flush the extra bit value                                            */
 /*                                                                       */
 /*  while(impeg2d_bit_stream_nxt() == '1')                                  */
 /*  {                                                                    */
 /*      extra_bit_picture         1                                      */
 /*      extra_information_picture 8                                      */
 /*  }                                                                    */
 /*  extra_bit_picture             1                                      */
 /*-----------------------------------------------------------------------*/
 while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&
           ps_stream->u4_offset < ps_stream->u4_max_offset)
 {
        impeg2d_bit_stream_get(ps_stream,9);
 }
    impeg2d_bit_stream_get_bit(ps_stream);
    impeg2d_next_start_code(ps_dec);

 return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;
}

void impeg2d_dec_pic_disp_ext(dec_state_t *ps_dec)
{
    WORD16 i2_number_of_frame_centre_offsets ;
 stream_t *ps_stream;

    ps_stream = &ps_dec->s_bit_stream;
    impeg2d_bit_stream_flush(ps_stream,4);

 if (ps_dec->u2_progressive_sequence)
 {
        i2_number_of_frame_centre_offsets = (ps_dec->u2_repeat_first_field) ?
 2 + ps_dec->u2_top_field_first : 1;
 }
 else
 {
        i2_number_of_frame_centre_offsets =
 (ps_dec->u2_picture_structure != FRAME_PICTURE) ?
 1 : 2 + ps_dec->u2_repeat_first_field;
 }
 while(i2_number_of_frame_centre_offsets--)
 {
 /* frame_centre_horizontal_offset */
        impeg2d_bit_stream_get(ps_stream,16);
        GET_MARKER_BIT(ps_dec,ps_stream);
 /* frame_centre_vertical_offset */
        impeg2d_bit_stream_get(ps_stream,16);
        GET_MARKER_BIT(ps_dec,ps_stream);
 }
    impeg2d_next_start_code(ps_dec);
}

IMPEG2D_ERROR_CODES_T impeg2d_dec_seq_ext_data(dec_state_t *ps_dec)
{
 stream_t *ps_stream;
    UWORD32     u4_start_code;
    IMPEG2D_ERROR_CODES_T e_error;

    e_error = (IMPEG2D_ERROR_CODES_T) IVD_ERROR_NONE;

    ps_stream      = &ps_dec->s_bit_stream;
    u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
 while( (u4_start_code == EXTENSION_START_CODE ||
            u4_start_code == USER_DATA_START_CODE) &&
 (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error &&
 (ps_stream->u4_offset < ps_stream->u4_max_offset))
 {
 if(u4_start_code == USER_DATA_START_CODE)
 {
            impeg2d_dec_user_data(ps_dec);
 }
 else
 {
            impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);
            u4_start_code   = impeg2d_bit_stream_nxt(ps_stream,EXT_ID_LEN);
 switch(u4_start_code)
 {
 case SEQ_DISPLAY_EXT_ID:
                impeg2d_dec_seq_disp_ext(ps_dec);
 break;
 case SEQ_SCALABLE_EXT_ID:
                e_error = IMPEG2D_SCALABILITIY_NOT_SUPPORTED;
 break;
 default:
 /* In case its a reserved extension code */
                impeg2d_bit_stream_flush(ps_stream,EXT_ID_LEN);
                impeg2d_peek_next_start_code(ps_dec);
 break;
 }
 }
        u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
 }
 return e_error;
}

void impeg2d_next_start_code(dec_state_t *ps_dec)
{
 stream_t *ps_stream;
    ps_stream = &ps_dec->s_bit_stream;
    impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);

 while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)
 && (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))
 {
        impeg2d_bit_stream_get(ps_stream,8);
 }
 return;
}

void impeg2d_dec_itu_t_ext(dec_state_t *ps_dec)
{
  impeg2d_bit_stream_flush(&ps_dec->s_bit_stream,EXT_ID_LEN);
  impeg2d_next_start_code(ps_dec);
}

void impeg2d_dec_seq_disp_ext(dec_state_t *ps_dec)
{
 stream_t *ps_stream;
    ps_stream = &ps_dec->s_bit_stream;

 /*
    sequence_display_extension()
    {
        extension_start_code_identifier 4
        video_format                    3
        colour_description              1
        if (colour_description)
        {
            colour_primaries            8
            transfer_characteristics    8
            matrix_coefficients         8
        }
        display_horizontal_size         14
        marker_bit                      1
        display_vertical_size           14
        next_start_code()
    }
    */

    impeg2d_bit_stream_get(ps_stream,7);
 if (impeg2d_bit_stream_get_bit(ps_stream) == 1)
 {
        impeg2d_bit_stream_get(ps_stream,24);
 }

 /* display_horizontal_size and display_vertical_size */
    ps_dec->u2_display_horizontal_size = impeg2d_bit_stream_get(ps_stream,14);;
    GET_MARKER_BIT(ps_dec,ps_stream);
    ps_dec->u2_display_vertical_size   = impeg2d_bit_stream_get(ps_stream,14);

    impeg2d_next_start_code(ps_dec);
}
