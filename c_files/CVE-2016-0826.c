status_t CameraService::removeListener(
 const sp<ICameraServiceListener>& listener) {
    ALOGV("%s: Remove listener %p", __FUNCTION__, listener.get());

 if (listener == 0) {
        ALOGE("%s: Listener must not be null", __FUNCTION__);
 return BAD_VALUE;
 }

 Mutex::Autolock lock(mServiceLock);

 Vector<sp<ICameraServiceListener> >::iterator it;
 for (it = mListenerList.begin(); it != mListenerList.end(); ++it) {
 if ((*it)->asBinder() == listener->asBinder()) {
            mListenerList.erase(it);
 return OK;
 }
 }

    ALOGW("%s: Tried to remove a listener %p which was not subscribed",
          __FUNCTION__, listener.get());

 return BAD_VALUE;
}

status_t CameraDeviceClient::getCameraInfo(/*out*/CameraMetadata* info)
{
    ATRACE_CALL();
    ALOGV("%s", __FUNCTION__);

 status_t res = OK;

 if ( (res = checkPid(__FUNCTION__) ) != OK) return res;

 Mutex::Autolock icl(mBinderSerializationLock);

 if (!mDevice.get()) return DEAD_OBJECT;

 if (info != NULL) {
 *info = mDevice->info(); // static camera metadata
 }

 return res;
}

status_t ProCamera2Client::cancelRequest(int requestId) {
 (void)requestId;
    ATRACE_CALL();
    ALOGV("%s", __FUNCTION__);

 Mutex::Autolock icl(mBinderSerializationLock);

 if (!mDevice.get()) return DEAD_OBJECT;

 if (!mExclusiveLock) {
 return PERMISSION_DENIED;
 }

    ALOGE("%s: not fully implemented yet", __FUNCTION__);
 return INVALID_OPERATION;
}

void Camera2Client::stopRecording() {
    ATRACE_CALL();
    ALOGV("%s: E", __FUNCTION__);
 Mutex::Autolock icl(mBinderSerializationLock);
 SharedParameters::Lock l(mParameters);

 status_t res;
 if ( (res = checkPid(__FUNCTION__) ) != OK) return;

 switch (l.mParameters.state) {
 case Parameters::RECORD:
 break;
 case Parameters::STOPPED:
 case Parameters::PREVIEW:
 case Parameters::STILL_CAPTURE:
 case Parameters::VIDEO_SNAPSHOT:
 default:
            ALOGE("%s: Camera %d: Can't stop recording in state %s",
                    __FUNCTION__, mCameraId,
 Parameters::getStateName(l.mParameters.state));
 return;
 };

    mCameraService->playSound(CameraService::SOUND_RECORDING);

    res = startPreviewL(l.mParameters, true);
 if (res != OK) {
        ALOGE("%s: Camera %d: Unable to return to preview",
                __FUNCTION__, mCameraId);
 }
}

status_t Camera2Client::syncWithDevice() {
    ATRACE_CALL();
 const nsecs_t kMaxSyncTimeout = 500000000; // 500 ms
 status_t res;

 int32_t activeRequestId = mStreamingProcessor->getActiveRequestId();
 if (activeRequestId == 0) return OK;

    res = mDevice->waitUntilRequestReceived(activeRequestId, kMaxSyncTimeout);
 if (res == TIMED_OUT) {
        ALOGE("%s: Camera %d: Timed out waiting sync with HAL",
                __FUNCTION__, mCameraId);
 } else if (res != OK) {
        ALOGE("%s: Camera %d: Error while waiting to sync with HAL",
                __FUNCTION__, mCameraId);
 }
 return res;
}

status_t CameraClient::startPreviewMode() {
    LOG1("startPreviewMode");
 status_t result = NO_ERROR;

 if (mHardware->previewEnabled()) {
 return NO_ERROR;
 }

 if (mPreviewWindow != 0) {
        native_window_set_scaling_mode(mPreviewWindow.get(),
                NATIVE_WINDOW_SCALING_MODE_SCALE_TO_WINDOW);
        native_window_set_buffers_transform(mPreviewWindow.get(),
                mOrientation);
 }
    mHardware->setPreviewWindow(mPreviewWindow);
    result = mHardware->startPreview();

 return result;
}

status_t CameraClient::sendCommand(int32_t cmd, int32_t arg1, int32_t arg2) {
    LOG1("sendCommand (pid %d)", getCallingPid());
 int orientation;
 Mutex::Autolock lock(mLock);
 status_t result = checkPidAndHardware();
 if (result != NO_ERROR) return result;

 if (cmd == CAMERA_CMD_SET_DISPLAY_ORIENTATION) {
        orientation = getOrientation(arg1, mCameraFacing == CAMERA_FACING_FRONT);
 if (orientation == -1) return BAD_VALUE;

 if (mOrientation != orientation) {
            mOrientation = orientation;
 if (mPreviewWindow != 0) {
                native_window_set_buffers_transform(mPreviewWindow.get(),
                        mOrientation);
 }
 }
 return OK;
 } else if (cmd == CAMERA_CMD_ENABLE_SHUTTER_SOUND) {
 switch (arg1) {
 case 0:
 return enableShutterSound(false);
 case 1:
 return enableShutterSound(true);
 default:
 return BAD_VALUE;
 }
 return OK;
 } else if (cmd == CAMERA_CMD_PLAY_RECORDING_SOUND) {
        mCameraService->playSound(CameraService::SOUND_RECORDING);
 } else if (cmd == CAMERA_CMD_SET_VIDEO_BUFFER_COUNT) {
 return INVALID_OPERATION;
 } else if (cmd == CAMERA_CMD_PING) {
 return OK;
 }

 return mHardware->sendCommand(cmd, arg1, arg2);
}

void CameraClient::dataCallback(int32_t msgType,
 const sp<IMemory>& dataPtr, camera_frame_metadata_t *metadata, void* user) {
    LOG2("dataCallback(%d)", msgType);

 Mutex* lock = getClientLockFromCookie(user);
 if (lock == NULL) return;
 Mutex::Autolock alock(*lock);

 CameraClient* client =
 static_cast<CameraClient*>(getClientFromCookie(user));
 if (client == NULL) return;

 if (!client->lockIfMessageWanted(msgType)) return;
 if (dataPtr == 0 && metadata == NULL) {
        ALOGE("Null data returned in data callback");
        client->handleGenericNotify(CAMERA_MSG_ERROR, UNKNOWN_ERROR, 0);
 return;
 }

 switch (msgType & ~CAMERA_MSG_PREVIEW_METADATA) {
 case CAMERA_MSG_PREVIEW_FRAME:
            client->handlePreviewData(msgType, dataPtr, metadata);
 break;
 case CAMERA_MSG_POSTVIEW_FRAME:
            client->handlePostview(dataPtr);
 break;
 case CAMERA_MSG_RAW_IMAGE:
            client->handleRawPicture(dataPtr);
 break;
 case CAMERA_MSG_COMPRESSED_IMAGE:
            client->handleCompressedPicture(dataPtr);
 break;
 default:
            client->handleGenericData(msgType, dataPtr, metadata);
 break;
 }
}

void CameraClient::stopPreview() {
    LOG1("stopPreview (pid %d)", getCallingPid());
 Mutex::Autolock lock(mLock);
 if (checkPidAndHardware() != NO_ERROR) return;


    disableMsgType(CAMERA_MSG_PREVIEW_FRAME);
    mHardware->stopPreview();

    mPreviewBuffer.clear();
}

CameraService::Client::Client(const sp<CameraService>& cameraService,
 const sp<ICameraClient>& cameraClient,
 const String16& clientPackageName,
 int cameraId, int cameraFacing,
 int clientPid, uid_t clientUid,
 int servicePid) :
 CameraService::BasicClient(cameraService, cameraClient->asBinder(),
                clientPackageName,
                cameraId, cameraFacing,
                clientPid, clientUid,
                servicePid)
{
 int callingPid = getCallingPid();
    LOG1("Client::Client E (pid %d, id %d)", callingPid, cameraId);

    mRemoteCallback = cameraClient;

    cameraService->setCameraBusy(cameraId);
    cameraService->loadSound();

    LOG1("Client::Client X (pid %d, id %d)", callingPid, cameraId);
}

void CameraClient::handleShutter(void) {
 if (mPlayShutterSound) {
        mCameraService->playSound(CameraService::SOUND_SHUTTER);
 }

    sp<ICameraClient> c = mRemoteCallback;
 if (c != 0) {
        mLock.unlock();
        c->notifyCallback(CAMERA_MSG_SHUTTER, 0, 0);
 if (!lockIfMessageWanted(CAMERA_MSG_SHUTTER)) return;
 }
    disableMsgType(CAMERA_MSG_SHUTTER);

    mLock.unlock();
}

void CameraClient::handleCompressedPicture(const sp<IMemory>& mem) {
    disableMsgType(CAMERA_MSG_COMPRESSED_IMAGE);

    sp<ICameraClient> c = mRemoteCallback;
    mLock.unlock();
 if (c != 0) {
        c->dataCallback(CAMERA_MSG_COMPRESSED_IMAGE, mem, NULL);
 }
}

status_t Camera2Client::startPreviewL(Parameters &params, bool restart) {
    ATRACE_CALL();
 status_t res;

    ALOGV("%s: state == %d, restart = %d", __FUNCTION__, params.state, restart);

 if ( (params.state == Parameters::PREVIEW ||
                    params.state == Parameters::RECORD ||
                    params.state == Parameters::VIDEO_SNAPSHOT)
 && !restart) {
        ALOGI("%s: Camera %d: Preview already active, ignoring restart",
                __FUNCTION__, mCameraId);
 return OK;
 }
 if (params.state > Parameters::PREVIEW && !restart) {
        ALOGE("%s: Can't start preview in state %s",
                __FUNCTION__,
 Parameters::getStateName(params.state));
 return INVALID_OPERATION;
 }

 if (!mStreamingProcessor->haveValidPreviewWindow()) {
        params.state = Parameters::WAITING_FOR_PREVIEW_WINDOW;
 return OK;
 }
    params.state = Parameters::STOPPED;
 int lastPreviewStreamId = mStreamingProcessor->getPreviewStreamId();

    res = mStreamingProcessor->updatePreviewStream(params);
 if (res != OK) {
        ALOGE("%s: Camera %d: Unable to update preview stream: %s (%d)",
                __FUNCTION__, mCameraId, strerror(-res), res);
 return res;
 }

 bool previewStreamChanged = mStreamingProcessor->getPreviewStreamId() != lastPreviewStreamId;

    res = updateProcessorStream(mJpegProcessor, params);
 if (res != OK) {
        ALOGE("%s: Camera %d: Can't pre-configure still image "
 "stream: %s (%d)",
                __FUNCTION__, mCameraId, strerror(-res), res);
 return res;
 }

 Vector<int32_t> outputStreams;
 bool callbacksEnabled = (params.previewCallbackFlags &
            CAMERA_FRAME_CALLBACK_FLAG_ENABLE_MASK) ||
            params.previewCallbackSurface;

 if (callbacksEnabled) {
 if (mStreamingProcessor->getRecordingStreamId() != NO_STREAM) {
            ALOGV("%s: Camera %d: Clearing out recording stream before "
 "creating callback stream", __FUNCTION__, mCameraId);
            res = mStreamingProcessor->stopStream();
 if (res != OK) {
                ALOGE("%s: Camera %d: Can't stop streaming to delete "
 "recording stream", __FUNCTION__, mCameraId);
 return res;
 }
            res = mStreamingProcessor->deleteRecordingStream();
 if (res != OK) {
                ALOGE("%s: Camera %d: Unable to delete recording stream before "
 "enabling callbacks: %s (%d)", __FUNCTION__, mCameraId,
                        strerror(-res), res);
 return res;
 }
 }

        res = mCallbackProcessor->updateStream(params);
 if (res != OK) {
            ALOGE("%s: Camera %d: Unable to update callback stream: %s (%d)",
                    __FUNCTION__, mCameraId, strerror(-res), res);
 return res;
 }
        outputStreams.push(getCallbackStreamId());
 } else if (previewStreamChanged && mCallbackProcessor->getStreamId() != NO_STREAM) {
 /**
         * Delete the unused callback stream when preview stream is changed and
         * preview is not enabled. Don't need stop preview stream as preview is in
         * STOPPED state now.
         */
        ALOGV("%s: Camera %d: Delete unused preview callback stream.",  __FUNCTION__, mCameraId);
        res = mCallbackProcessor->deleteStream();
 if (res != OK) {
            ALOGE("%s: Camera %d: Unable to delete callback stream %s (%d)",
                    __FUNCTION__, mCameraId, strerror(-res), res);
 return res;
 }
 }
 if (params.zslMode && !params.recordingHint) {
        res = updateProcessorStream(mZslProcessor, params);
 if (res != OK) {
            ALOGE("%s: Camera %d: Unable to update ZSL stream: %s (%d)",
                    __FUNCTION__, mCameraId, strerror(-res), res);
 return res;
 }
        outputStreams.push(getZslStreamId());
 }

    outputStreams.push(getPreviewStreamId());

 if (!params.recordingHint) {
 if (!restart) {
            res = mStreamingProcessor->updatePreviewRequest(params);
 if (res != OK) {
                ALOGE("%s: Camera %d: Can't set up preview request: "
 "%s (%d)", __FUNCTION__, mCameraId,
                        strerror(-res), res);
 return res;
 }
 }
        res = mStreamingProcessor->startStream(StreamingProcessor::PREVIEW,
                outputStreams);
 } else {
 if (!restart) {
            res = mStreamingProcessor->updateRecordingRequest(params);
 if (res != OK) {
                ALOGE("%s: Camera %d: Can't set up preview request with "
 "record hint: %s (%d)", __FUNCTION__, mCameraId,
                        strerror(-res), res);
 return res;
 }
 }
        res = mStreamingProcessor->startStream(StreamingProcessor::RECORD,
                outputStreams);
 }
 if (res != OK) {
        ALOGE("%s: Camera %d: Unable to start streaming preview: %s (%d)",
                __FUNCTION__, mCameraId, strerror(-res), res);
 return res;
 }

    params.state = Parameters::PREVIEW;
 return OK;
}

status_t ProCamera2Client::submitRequest(camera_metadata_t* request,
 bool streaming) {
    ATRACE_CALL();
    ALOGV("%s", __FUNCTION__);

 Mutex::Autolock icl(mBinderSerializationLock);

 if (!mDevice.get()) return DEAD_OBJECT;

 if (!mExclusiveLock) {
 return PERMISSION_DENIED;
 }

 CameraMetadata metadata(request);

 if (!enforceRequestPermissions(metadata)) {
 return PERMISSION_DENIED;
 }

 if (streaming) {
 return mDevice->setStreamingRequest(metadata);
 } else {
 return mDevice->capture(metadata);
 }

 return OK;
}

void CameraDeviceClient::notifyError() {
    sp<ICameraDeviceCallbacks> remoteCb = getRemoteCallback();

 if (remoteCb != 0) {
        remoteCb->onDeviceError(ICameraDeviceCallbacks::ERROR_CAMERA_DEVICE);
 }
}

void CameraService::setCameraBusy(int cameraId) {
    android_atomic_write(1, &mBusy[cameraId]);

    ALOGV("setCameraBusy cameraId=%d", cameraId);
}

bool CameraClient::previewEnabled() {
    LOG1("previewEnabled (pid %d)", getCallingPid());

 Mutex::Autolock lock(mLock);
 if (checkPidAndHardware() != NO_ERROR) return false;
 return mHardware->previewEnabled();
}

status_t Camera2Client::setPreviewTarget(
 const sp<IGraphicBufferProducer>& bufferProducer) {
    ATRACE_CALL();
    ALOGV("%s: E", __FUNCTION__);
 Mutex::Autolock icl(mBinderSerializationLock);
 status_t res;
 if ( (res = checkPid(__FUNCTION__) ) != OK) return res;

    sp<IBinder> binder;
    sp<ANativeWindow> window;
 if (bufferProducer != 0) {
        binder = bufferProducer->asBinder();
        window = new Surface(bufferProducer, /*controlledByApp*/ true);
 }
 return setPreviewWindowL(binder, window);
}

int CameraService::getDeviceVersion(int cameraId, int* facing) {
 struct camera_info info;
 if (mModule->get_camera_info(cameraId, &info) != OK) {
 return -1;
 }

 int deviceVersion;
 if (mModule->common.module_api_version >= CAMERA_MODULE_API_VERSION_2_0) {
        deviceVersion = info.device_version;
 } else {
        deviceVersion = CAMERA_DEVICE_API_VERSION_1_0;
 }

 if (facing) {
 *facing = info.facing;
 }

 return deviceVersion;
}

void Camera2Client::stopPreview() {
    ATRACE_CALL();
    ALOGV("%s: E", __FUNCTION__);
 Mutex::Autolock icl(mBinderSerializationLock);
 status_t res;
 if ( (res = checkPid(__FUNCTION__) ) != OK) return;
    stopPreviewL();
}

status_t CameraClient::takePicture(int msgType) {
    LOG1("takePicture (pid %d): 0x%x", getCallingPid(), msgType);

 Mutex::Autolock lock(mLock);
 status_t result = checkPidAndHardware();
 if (result != NO_ERROR) return result;

 if ((msgType & CAMERA_MSG_RAW_IMAGE) &&
 (msgType & CAMERA_MSG_RAW_IMAGE_NOTIFY)) {
        ALOGE("CAMERA_MSG_RAW_IMAGE and CAMERA_MSG_RAW_IMAGE_NOTIFY"
 " cannot be both enabled");
 return BAD_VALUE;
 }

 int picMsgType = msgType
 & (CAMERA_MSG_SHUTTER |
                           CAMERA_MSG_POSTVIEW_FRAME |
                           CAMERA_MSG_RAW_IMAGE |
                           CAMERA_MSG_RAW_IMAGE_NOTIFY |
                           CAMERA_MSG_COMPRESSED_IMAGE);

    enableMsgType(picMsgType);

 return mHardware->takePicture();
}

CameraService::Client::~Client() {
    ALOGV("~Client");
    mDestructionStarted = true;

    mCameraService->releaseSound();
 Client::disconnect();
}

bool CameraService::isValidCameraId(int cameraId) {
 int facing;
 int deviceVersion = getDeviceVersion(cameraId, &facing);

 switch(deviceVersion) {
 case CAMERA_DEVICE_API_VERSION_1_0:
 case CAMERA_DEVICE_API_VERSION_2_0:
 case CAMERA_DEVICE_API_VERSION_2_1:
 case CAMERA_DEVICE_API_VERSION_3_0:
 return true;
 default:
 return false;
 }

 return false;
}

status_t CameraDeviceClient::createDefaultRequest(int templateId,
 /*out*/
 CameraMetadata* request)
{
    ATRACE_CALL();
    ALOGV("%s (templateId = 0x%x)", __FUNCTION__, templateId);

 status_t res;
 if ( (res = checkPid(__FUNCTION__) ) != OK) return res;

 Mutex::Autolock icl(mBinderSerializationLock);

 if (!mDevice.get()) return DEAD_OBJECT;

 CameraMetadata metadata;
 if ( (res = mDevice->createDefaultRequest(templateId, &metadata) ) == OK &&
        request != NULL) {

        request->swap(metadata);
 }

 return res;
}

 status_t ProCamera2Client::dump(int fd, const Vector<String16>& args) {
     String8 result;
     result.appendFormat("ProCamera2Client[%d] (%p) PID: %d, dump:\n",
             mCameraId,
            getRemoteCallback()->asBinder().get(),
            mClientPid);
    result.append("  State: ");

    mFrameProcessor->dump(fd, args);

 return dumpDevice(fd, args);
}

status_t Camera2Client::commandStopFaceDetectionL(Parameters &params) {
 status_t res = OK;
    ALOGV("%s: Camera %d: Stopping face detection",
          __FUNCTION__, mCameraId);

 if (!params.enableFaceDetect) return OK;

    params.enableFaceDetect = false;

 if (params.state == Parameters::PREVIEW
 || params.state == Parameters::RECORD
 || params.state == Parameters::VIDEO_SNAPSHOT) {
        res = updateRequests(params);
 }

 return res;
}

status_t CameraService::connectDevice(
 const sp<ICameraDeviceCallbacks>& cameraCb,
 int cameraId,
 const String16& clientPackageName,
 int clientUid,
 /*out*/
        sp<ICameraDeviceUser>& device)
{

 String8 clientName8(clientPackageName);
 int callingPid = getCallingPid();

    LOG1("CameraService::connectDevice E (pid %d \"%s\", id %d)", callingPid,
            clientName8.string(), cameraId);

 status_t status = validateConnect(cameraId, /*inout*/clientUid);
 if (status != OK) {
 return status;
 }

    sp<CameraDeviceClient> client;
 {
 Mutex::Autolock lock(mServiceLock);
 {
            sp<BasicClient> client;
 if (!canConnectUnsafe(cameraId, clientPackageName,
                                  cameraCb->asBinder(),
 /*out*/client)) {
 return -EBUSY;
 }
 }

 int facing = -1;
 int deviceVersion = getDeviceVersion(cameraId, &facing);

 if (isValidCameraId(cameraId)) {
            updateStatus(ICameraServiceListener::STATUS_NOT_AVAILABLE,
                         cameraId);
 }

 switch(deviceVersion) {
 case CAMERA_DEVICE_API_VERSION_1_0:
            ALOGW("Camera using old HAL version: %d", deviceVersion);
 return -EOPNOTSUPP;
 case CAMERA_DEVICE_API_VERSION_2_0:
 case CAMERA_DEVICE_API_VERSION_2_1:
 case CAMERA_DEVICE_API_VERSION_3_0:
            client = new CameraDeviceClient(this, cameraCb, clientPackageName,
                    cameraId, facing, callingPid, clientUid, getpid());
 break;
 case -1:
            ALOGE("Invalid camera id %d", cameraId);
 return BAD_VALUE;
 default:
            ALOGE("Unknown camera device HAL version: %d", deviceVersion);
 return INVALID_OPERATION;
 }

 status_t status = connectFinishUnsafe(client, client->getRemote());
 if (status != OK) {
            updateStatus(ICameraServiceListener::STATUS_PRESENT, cameraId);
 return status;
 }

        LOG1("CameraService::connectDevice X (id %d, this pid is %d)", cameraId,
                getpid());

        mClient[cameraId] = client;
 }

    device = client;
 return OK;
}

status_t Camera2Client::lock() {
    ATRACE_CALL();
    ALOGV("%s: E", __FUNCTION__);
 Mutex::Autolock icl(mBinderSerializationLock);
    ALOGV("%s: Camera %d: Lock call from pid %d; current client pid %d",
            __FUNCTION__, mCameraId, getCallingPid(), mClientPid);

 if (mClientPid == 0) {
        mClientPid = getCallingPid();
 return OK;
 }

 if (mClientPid != getCallingPid()) {
        ALOGE("%s: Camera %d: Lock call from pid %d; currently locked to pid %d",
                __FUNCTION__, mCameraId, getCallingPid(), mClientPid);
 return EBUSY;
 }

 return OK;
}

void CameraClient::handleGenericNotify(int32_t msgType,
 int32_t ext1, int32_t ext2) {
    sp<ICameraClient> c = mRemoteCallback;
    mLock.unlock();
 if (c != 0) {
        c->notifyCallback(msgType, ext1, ext2);
 }
}

status_t Camera2Client::updateProcessorStream(sp<ProcessorT> processor,
 Parameters params) {
 status_t res;

 ProcessorT *processorPtr = processor.get();
    res = (processorPtr->*updateStreamF)(params);

 /**
     * Can't update the stream if it's busy?
     *
     * Then we need to stop the device (by temporarily clearing the request
     * queue) and then try again. Resume streaming once we're done.
     */
 if (res == -EBUSY) {
        ALOGV("%s: Camera %d: Pausing to update stream", __FUNCTION__,
                mCameraId);
        res = mStreamingProcessor->togglePauseStream(/*pause*/true);
 if (res != OK) {
            ALOGE("%s: Camera %d: Can't pause streaming: %s (%d)",
                    __FUNCTION__, mCameraId, strerror(-res), res);
 }

        res = mDevice->waitUntilDrained();
 if (res != OK) {
            ALOGE("%s: Camera %d: Waiting to stop streaming failed: %s (%d)",
                    __FUNCTION__, mCameraId, strerror(-res), res);
 }

        res = (processorPtr->*updateStreamF)(params);
 if (res != OK) {
            ALOGE("%s: Camera %d: Failed to update processing stream "
 " despite having halted streaming first: %s (%d)",
                  __FUNCTION__, mCameraId, strerror(-res), res);
 }

        res = mStreamingProcessor->togglePauseStream(/*pause*/false);
 if (res != OK) {
            ALOGE("%s: Camera %d: Can't unpause streaming: %s (%d)",
                    __FUNCTION__, mCameraId, strerror(-res), res);
 }
 }

 return res;
}

status_t CameraDeviceClient::cancelRequest(int requestId) {
    ATRACE_CALL();
    ALOGV("%s, requestId = %d", __FUNCTION__, requestId);

 status_t res;

 if ( (res = checkPid(__FUNCTION__) ) != OK) return res;

 Mutex::Autolock icl(mBinderSerializationLock);

 if (!mDevice.get()) return DEAD_OBJECT;

 Vector<int>::iterator it, end;
 for (it = mStreamingRequestList.begin(), end = mStreamingRequestList.end();
         it != end; ++it) {
 if (*it == requestId) {
 break;
 }
 }

 if (it == end) {
        ALOGE("%s: Camera%d: Did not find request id %d in list of streaming "
 "requests", __FUNCTION__, mCameraId, requestId);
 return BAD_VALUE;
 }

    res = mDevice->clearStreamingRequest();

 if (res == OK) {
        ALOGV("%s: Camera %d: Successfully cleared streaming request",
              __FUNCTION__, mCameraId);
        mStreamingRequestList.erase(it);
 }

 return res;
}

status_t Camera2Client::cancelAutoFocus() {
    ATRACE_CALL();
 Mutex::Autolock icl(mBinderSerializationLock);
    ALOGV("%s: Camera %d", __FUNCTION__, mCameraId);
 status_t res;
 if ( (res = checkPid(__FUNCTION__) ) != OK) return res;

 int triggerId;
 {
 SharedParameters::Lock l(mParameters);
 if (l.mParameters.focusMode == Parameters::FOCUS_MODE_FIXED ||
                l.mParameters.focusMode == Parameters::FOCUS_MODE_INFINITY) {
 return OK;
 }

 if (l.mParameters.afTriggerCounter == l.mParameters.currentAfTriggerId) {
            ATRACE_ASYNC_END(kAutofocusLabel, l.mParameters.currentAfTriggerId);
 }

        triggerId = ++l.mParameters.afTriggerCounter;

 if (l.mParameters.shadowFocusMode != Parameters::FOCUS_MODE_INVALID) {
            ALOGV("%s: Quirk: Restoring focus mode to %d", __FUNCTION__,
                    l.mParameters.shadowFocusMode);
            l.mParameters.focusMode = l.mParameters.shadowFocusMode;
            l.mParameters.shadowFocusMode = Parameters::FOCUS_MODE_INVALID;
            updateRequests(l.mParameters);

 return OK;
 }
 }
    syncWithDevice();

    mDevice->triggerCancelAutofocus(triggerId);

 return OK;
}

status_t CameraClient::checkPidAndHardware() const {
 status_t result = checkPid();
 if (result != NO_ERROR) return result;
 if (mHardware == 0) {
        ALOGE("attempt to use a camera after disconnect() (pid %d)", getCallingPid());
 return INVALID_OPERATION;
 }
 return NO_ERROR;
}

status_t Camera2Client::setPreviewCallbackTarget(
 const sp<IGraphicBufferProducer>& callbackProducer) {
    ATRACE_CALL();
    ALOGV("%s: E", __FUNCTION__);
 Mutex::Autolock icl(mBinderSerializationLock);
 status_t res;
 if ( (res = checkPid(__FUNCTION__) ) != OK) return res;

    sp<ANativeWindow> window;
 if (callbackProducer != 0) {
        window = new Surface(callbackProducer);
 }

    res = mCallbackProcessor->setCallbackWindow(window);
 if (res != OK) {
        ALOGE("%s: Camera %d: Unable to set preview callback surface: %s (%d)",
                __FUNCTION__, mCameraId, strerror(-res), res);
 return res;
 }

 SharedParameters::Lock l(mParameters);

 if (window != NULL) {
        l.mParameters.previewCallbackFlags = CAMERA_FRAME_CALLBACK_FLAG_NOOP;
        l.mParameters.previewCallbackOneShot = false;
        l.mParameters.previewCallbackSurface = true;
 } else {
        l.mParameters.previewCallbackSurface = false;
 }

 switch(l.mParameters.state) {
 case Parameters::PREVIEW:
            res = startPreviewL(l.mParameters, true);
 break;
 case Parameters::RECORD:
 case Parameters::VIDEO_SNAPSHOT:
            res = startRecordingL(l.mParameters, true);
 break;
 default:
 break;
 }
 if (res != OK) {
        ALOGE("%s: Camera %d: Unable to refresh request in state %s",
                __FUNCTION__, mCameraId,
 Parameters::getStateName(l.mParameters.state));
 }

 return OK;
}

static int getCallingPid() {
 return IPCThreadState::self()->getCallingPid();
}

int Camera2Client::getCallbackStreamId() const {
 return mCallbackProcessor->getStreamId();
}

status_t CameraDeviceClient::waitUntilIdle()
{
    ATRACE_CALL();
    ALOGV("%s", __FUNCTION__);

 status_t res = OK;
 if ( (res = checkPid(__FUNCTION__) ) != OK) return res;

 Mutex::Autolock icl(mBinderSerializationLock);

 if (!mDevice.get()) return DEAD_OBJECT;

 if (!mStreamingRequestList.isEmpty()) {
        ALOGE("%s: Camera %d: Try to waitUntilIdle when there are active streaming requests",
              __FUNCTION__, mCameraId);
 return INVALID_OPERATION;
 }
    res = mDevice->waitUntilDrained();
    ALOGV("%s Done", __FUNCTION__);

 return res;
}

status_t CameraClient::checkPid() const {
 int callingPid = getCallingPid();
 if (callingPid == mClientPid) return NO_ERROR;

    ALOGW("attempt to use a locked camera from a different process"
 " (old pid %d, new pid %d)", mClientPid, callingPid);
 return EBUSY;
}

status_t CameraClient::setPreviewTarget(
 const sp<IGraphicBufferProducer>& bufferProducer) {
    LOG1("setPreviewTarget(%p) (pid %d)", bufferProducer.get(),
            getCallingPid());

    sp<IBinder> binder;
    sp<ANativeWindow> window;
 if (bufferProducer != 0) {
        binder = bufferProducer->asBinder();
        window = new Surface(bufferProducer, /*controlledByApp*/ true);
 }
 return setPreviewWindow(binder, window);
}

sp<CameraService::BasicClient> CameraService::getClientByRemote(
 const wp<IBinder>& cameraClient) {

    sp<BasicClient> client;

 Mutex::Autolock lock(mServiceLock);

 int outIndex;
    client = findClientUnsafe(cameraClient, outIndex);

 return client;
}

CameraService::ProClient::~ProClient() {
}

status_t CameraClient::unlock() {
 int callingPid = getCallingPid();
    LOG1("unlock (pid %d)", callingPid);
 Mutex::Autolock lock(mLock);

 status_t result = checkPid();
 if (result == NO_ERROR) {
 if (mHardware->recordingEnabled()) {
            ALOGE("Not allowed to unlock camera during recording.");
 return INVALID_OPERATION;
 }
        mClientPid = 0;
        LOG1("clear mRemoteCallback (pid %d)", callingPid);
        mRemoteCallback.clear();
 }
 return result;
}

CameraClient::~CameraClient() {
 Mutex* lock = mCameraService->getClientLockById(mCameraId);
    lock->lock();
    mDestructionStarted = true;
    lock->unlock();
 int callingPid = getCallingPid();
    LOG1("CameraClient::~CameraClient E (pid %d, this %p)", callingPid, this);

    disconnect();
    LOG1("CameraClient::~CameraClient X (pid %d, this %p)", callingPid, this);

 }

status_t Camera2Client::startRecordingL(Parameters &params, bool restart) {
 status_t res;

    ALOGV("%s: state == %d, restart = %d", __FUNCTION__, params.state, restart);

 switch (params.state) {
 case Parameters::STOPPED:
            res = startPreviewL(params, false);
 if (res != OK) return res;
 break;
 case Parameters::PREVIEW:
 break;
 case Parameters::RECORD:
 case Parameters::VIDEO_SNAPSHOT:
 if (!restart) return OK;
 break;
 default:
            ALOGE("%s: Camera %d: Can't start recording in state %s",
                    __FUNCTION__, mCameraId,
 Parameters::getStateName(params.state));
 return INVALID_OPERATION;
 };

 if (!params.storeMetadataInBuffers) {
        ALOGE("%s: Camera %d: Recording only supported in metadata mode, but "
 "non-metadata recording mode requested!", __FUNCTION__,
                mCameraId);
 return INVALID_OPERATION;
 }

 if (!restart) {
        mCameraService->playSound(CameraService::SOUND_RECORDING);
        mStreamingProcessor->updateRecordingRequest(params);
 if (res != OK) {
            ALOGE("%s: Camera %d: Unable to update recording request: %s (%d)",
                    __FUNCTION__, mCameraId, strerror(-res), res);
 return res;
 }
 }

 if (mCallbackProcessor->getStreamId() != NO_STREAM) {
        ALOGV("%s: Camera %d: Clearing out callback stream before "
 "creating recording stream", __FUNCTION__, mCameraId);
        res = mStreamingProcessor->stopStream();
 if (res != OK) {
            ALOGE("%s: Camera %d: Can't stop streaming to delete callback stream",
                    __FUNCTION__, mCameraId);
 return res;
 }
        res = mCallbackProcessor->deleteStream();
 if (res != OK) {
            ALOGE("%s: Camera %d: Unable to delete callback stream before "
 "record: %s (%d)", __FUNCTION__, mCameraId,
                    strerror(-res), res);
 return res;
 }
 }
    params.previewCallbackFlags = 0;

    res = updateProcessorStream<
 StreamingProcessor,
 &StreamingProcessor::updateRecordingStream>(mStreamingProcessor,
                                                        params);
 if (res != OK) {
        ALOGE("%s: Camera %d: Unable to update recording stream: %s (%d)",
                __FUNCTION__, mCameraId, strerror(-res), res);
 return res;
 }

 Vector<int32_t> outputStreams;
    outputStreams.push(getPreviewStreamId());
    outputStreams.push(getRecordingStreamId());

    res = mStreamingProcessor->startStream(StreamingProcessor::RECORD,
            outputStreams);
 if (res != OK) {
        ALOGE("%s: Camera %d: Unable to start recording stream: %s (%d)",
                __FUNCTION__, mCameraId, strerror(-res), res);
 return res;
 }

 if (params.state < Parameters::RECORD) {
        params.state = Parameters::RECORD;
 }

 return OK;
}

CameraService::BasicClient::BasicClient(const sp<CameraService>& cameraService,
 const sp<IBinder>& remoteCallback,
 const String16& clientPackageName,
 int cameraId, int cameraFacing,
 int clientPid, uid_t clientUid,
 int servicePid):
        mClientPackageName(clientPackageName)
{
    mCameraService = cameraService;
    mRemoteBinder = remoteCallback;
    mCameraId = cameraId;
    mCameraFacing = cameraFacing;
    mClientPid = clientPid;
    mClientUid = clientUid;
    mServicePid = servicePid;
    mOpsActive = false;
    mDestructionStarted = false;
}

void CameraService::BasicClient::opChanged(int32_t op, const String16& packageName) {
 String8 name(packageName);
 String8 myName(mClientPackageName);

 if (op != AppOpsManager::OP_CAMERA) {
        ALOGW("Unexpected app ops notification received: %d", op);
 return;
 }

 int32_t res;
    res = mAppOpsManager.checkOp(AppOpsManager::OP_CAMERA,
            mClientUid, mClientPackageName);
    ALOGV("checkOp returns: %d, %s ", res,
            res == AppOpsManager::MODE_ALLOWED ? "ALLOWED" :
            res == AppOpsManager::MODE_IGNORED ? "IGNORED" :
            res == AppOpsManager::MODE_ERRORED ? "ERRORED" :
 "UNKNOWN");

 if (res != AppOpsManager::MODE_ALLOWED) {
        ALOGI("Camera %d: Access for \"%s\" revoked", mCameraId,
                myName.string());
        mClientPid = getCallingPid();
        notifyError();
        disconnect();
 }
}

String8 CameraClient::getParameters() const {
 Mutex::Autolock lock(mLock);
 if (checkPidAndHardware() != NO_ERROR) return String8();

 String8 params(mHardware->getParameters().flatten());
    LOG1("getParameters (pid %d) (%s)", getCallingPid(), params.string());
 return params;
}

static void camera_device_status_change(
 const struct camera_module_callbacks* callbacks,
 int camera_id,
 int new_status) {
    sp<CameraService> cs = const_cast<CameraService*>(
 static_cast<const CameraService*>(callbacks));

    cs->onDeviceStatusChanged(
        camera_id,
        new_status);
}

void CameraClient::copyFrameAndPostCopiedFrame(
 int32_t msgType, const sp<ICameraClient>& client,
 const sp<IMemoryHeap>& heap, size_t offset, size_t size,
 camera_frame_metadata_t *metadata) {
    LOG2("copyFrameAndPostCopiedFrame");
    sp<MemoryHeapBase> previewBuffer;

 if (mPreviewBuffer == 0) {
        mPreviewBuffer = new MemoryHeapBase(size, 0, NULL);
 } else if (size > mPreviewBuffer->virtualSize()) {
        mPreviewBuffer.clear();
        mPreviewBuffer = new MemoryHeapBase(size, 0, NULL);
 }
 if (mPreviewBuffer == 0) {
        ALOGE("failed to allocate space for preview buffer");
        mLock.unlock();
 return;
 }
    previewBuffer = mPreviewBuffer;

    memcpy(previewBuffer->base(), (uint8_t *)heap->base() + offset, size);

    sp<MemoryBase> frame = new MemoryBase(previewBuffer, 0, size);
 if (frame == 0) {
        ALOGE("failed to allocate space for frame callback");
        mLock.unlock();
 return;
 }

    mLock.unlock();
    client->dataCallback(msgType, frame, metadata);
}

status_t Camera2Client::initialize(camera_module_t *module)
{
    ATRACE_CALL();
    ALOGV("%s: Initializing client for camera %d", __FUNCTION__, mCameraId);
 status_t res;

    res = Camera2ClientBase::initialize(module);
 if (res != OK) {
 return res;
 }

 {
 SharedParameters::Lock l(mParameters);

        res = l.mParameters.initialize(&(mDevice->info()));
 if (res != OK) {
            ALOGE("%s: Camera %d: unable to build defaults: %s (%d)",
                    __FUNCTION__, mCameraId, strerror(-res), res);
 return NO_INIT;
 }
 }

 String8 threadName;

    mStreamingProcessor = new StreamingProcessor(this);
    threadName = String8::format("C2-%d-StreamProc",
            mCameraId);
    mStreamingProcessor->run(threadName.string());

    mFrameProcessor = new FrameProcessor(mDevice, this);
    threadName = String8::format("C2-%d-FrameProc",
            mCameraId);
    mFrameProcessor->run(threadName.string());

    mCaptureSequencer = new CaptureSequencer(this);
    threadName = String8::format("C2-%d-CaptureSeq",
            mCameraId);
    mCaptureSequencer->run(threadName.string());

    mJpegProcessor = new JpegProcessor(this, mCaptureSequencer);
    threadName = String8::format("C2-%d-JpegProc",
            mCameraId);
    mJpegProcessor->run(threadName.string());

 switch (mDeviceVersion) {
 case CAMERA_DEVICE_API_VERSION_2_0: {
            sp<ZslProcessor> zslProc =
 new ZslProcessor(this, mCaptureSequencer);
            mZslProcessor = zslProc;
            mZslProcessorThread = zslProc;
 break;
 }
 case CAMERA_DEVICE_API_VERSION_3_0:{
            sp<ZslProcessor3> zslProc =
 new ZslProcessor3(this, mCaptureSequencer);
            mZslProcessor = zslProc;
            mZslProcessorThread = zslProc;
 break;
 }
 default:
 break;
 }
    threadName = String8::format("C2-%d-ZslProc",
            mCameraId);
    mZslProcessorThread->run(threadName.string());

    mCallbackProcessor = new CallbackProcessor(this);
    threadName = String8::format("C2-%d-CallbkProc",
            mCameraId);
    mCallbackProcessor->run(threadName.string());

 if (gLogLevel >= 1) {
 SharedParameters::Lock l(mParameters);
        ALOGD("%s: Default parameters converted from camera %d:", __FUNCTION__,
              mCameraId);
        ALOGD("%s", l.mParameters.paramsFlattened.string());
 }

 return OK;
}

size_t Camera2Client::calculateBufferSize(int width, int height,
 int format, int stride) {
 switch (format) {
 case HAL_PIXEL_FORMAT_YCbCr_422_SP: // NV16
 return width * height * 2;
 case HAL_PIXEL_FORMAT_YCrCb_420_SP: // NV21
 return width * height * 3 / 2;
 case HAL_PIXEL_FORMAT_YCbCr_422_I: // YUY2
 return width * height * 2;
 case HAL_PIXEL_FORMAT_YV12: { // YV12
 size_t ySize = stride * height;
 size_t uvStride = (stride / 2 + 0xF) & ~0xF;
 size_t uvSize = uvStride * height / 2;
 return ySize + uvSize * 2;
 }
 case HAL_PIXEL_FORMAT_RGB_565:
 return width * height * 2;
 case HAL_PIXEL_FORMAT_RGBA_8888:
 return width * height * 4;
 case HAL_PIXEL_FORMAT_RAW_SENSOR:
 return width * height * 2;
 default:
            ALOGE("%s: Unknown preview format: %x",
                    __FUNCTION__,  format);
 return 0;
 }
}

void CameraClient::notifyCallback(int32_t msgType, int32_t ext1,
 int32_t ext2, void* user) {
    LOG2("notifyCallback(%d)", msgType);

 Mutex* lock = getClientLockFromCookie(user);
 if (lock == NULL) return;
 Mutex::Autolock alock(*lock);

 CameraClient* client =
 static_cast<CameraClient*>(getClientFromCookie(user));
 if (client == NULL) return;

 if (!client->lockIfMessageWanted(msgType)) return;

 switch (msgType) {
 case CAMERA_MSG_SHUTTER:
            client->handleShutter();
 break;
 default:
            client->handleGenericNotify(msgType, ext1, ext2);
 break;
 }
}

void CameraClient::enableMsgType(int32_t msgType) {
    android_atomic_or(msgType, &mMsgEnabled);
    mHardware->enableMsgType(msgType);
}

 status_t CameraService::BasicClient::startCameraOps() {
     int32_t res;
 
    mOpsCallback = new OpsCallback(this);

 {
        ALOGV("%s: Start camera ops, package name = %s, client UID = %d",
              __FUNCTION__, String8(mClientPackageName).string(), mClientUid);
 }

    mAppOpsManager.startWatchingMode(AppOpsManager::OP_CAMERA,
            mClientPackageName, mOpsCallback);
    res = mAppOpsManager.startOp(AppOpsManager::OP_CAMERA,
            mClientUid, mClientPackageName);

 if (res != AppOpsManager::MODE_ALLOWED) {
        ALOGI("Camera %d: Access for \"%s\" has been revoked",
                mCameraId, String8(mClientPackageName).string());
 return PERMISSION_DENIED;
 }
    mOpsActive = true;
 return OK;
}

void Camera2Client::notifyAutoExposure(uint8_t newState, int triggerId) {
    ALOGV("%s: Autoexposure state now %d, last trigger %d",
            __FUNCTION__, newState, triggerId);
    mCaptureSequencer->notifyAutoExposure(newState, triggerId);
}

void CameraClient::stopRecording() {
    LOG1("stopRecording (pid %d)", getCallingPid());
 Mutex::Autolock lock(mLock);
 if (checkPidAndHardware() != NO_ERROR) return;

    disableMsgType(CAMERA_MSG_VIDEO_FRAME);
    mHardware->stopRecording();
    mCameraService->playSound(CameraService::SOUND_RECORDING);

    mPreviewBuffer.clear();
}

CameraService::BasicClient::~BasicClient() {
    ALOGV("~BasicClient");
    mDestructionStarted = true;
}

Camera2Client::Camera2Client(const sp<CameraService>& cameraService,
 const sp<ICameraClient>& cameraClient,
 const String16& clientPackageName,
 int cameraId,
 int cameraFacing,
 int clientPid,
 uid_t clientUid,
 int servicePid,
 int deviceVersion):
 Camera2ClientBase(cameraService, cameraClient, clientPackageName,
                cameraId, cameraFacing, clientPid, clientUid, servicePid),
        mParameters(cameraId, cameraFacing),
        mDeviceVersion(deviceVersion)
{
    ATRACE_CALL();

 SharedParameters::Lock l(mParameters);
    l.mParameters.state = Parameters::DISCONNECTED;
}

void Camera2Client::setPreviewCallbackFlagL(Parameters &params, int flag) {
 status_t res = OK;

 switch(params.state) {
 case Parameters::STOPPED:
 case Parameters::WAITING_FOR_PREVIEW_WINDOW:
 case Parameters::PREVIEW:
 case Parameters::STILL_CAPTURE:
 break;
 default:
 if (flag & CAMERA_FRAME_CALLBACK_FLAG_ENABLE_MASK) {
                ALOGE("%s: Camera %d: Can't use preview callbacks "
 "in state %d", __FUNCTION__, mCameraId, params.state);
 return;
 }
 }

 if (flag & CAMERA_FRAME_CALLBACK_FLAG_ONE_SHOT_MASK) {
        ALOGV("%s: setting oneshot", __FUNCTION__);
        params.previewCallbackOneShot = true;
 }
 if (params.previewCallbackFlags != (uint32_t)flag) {

 if (params.previewCallbackSurface && flag != CAMERA_FRAME_CALLBACK_FLAG_NOOP) {
            res = mCallbackProcessor->setCallbackWindow(NULL);
 if (res != OK) {
                ALOGE("%s: Camera %d: Unable to clear preview callback surface:"
 " %s (%d)", __FUNCTION__, mCameraId, strerror(-res), res);
 return;
 }
            params.previewCallbackSurface = false;
 }

        params.previewCallbackFlags = flag;

 if (params.state == Parameters::PREVIEW) {
            res = startPreviewL(params, true);
 if (res != OK) {
                ALOGE("%s: Camera %d: Unable to refresh request in state %s",
                        __FUNCTION__, mCameraId,
 Parameters::getStateName(params.state));
 }
 }
 }
}

CameraService::Client* CameraService::Client::getClientFromCookie(void* user) {
 BasicClient *basicClient = gCameraService->getClientByIdUnsafe((int) user);
 Client* client = static_cast<Client*>(basicClient);

 if (client == NULL) return NULL;

 if (client->mDestructionStarted) return NULL;

 return client;
}

status_t Camera2Client::commandEnableShutterSoundL(bool enable) {
 SharedParameters::Lock l(mParameters);
 if (enable) {
        l.mParameters.playShutterSound = true;
 return OK;
 }

 char value[PROPERTY_VALUE_MAX];
    property_get("ro.camera.sound.forced", value, "0");
 if (strncmp(value, "0", 2) != 0) {
 if (getCallingPid() != getpid()) {
            ALOGE("Failed to disable shutter sound. Permission denied (pid %d)",
                    getCallingPid());
 return PERMISSION_DENIED;
 }
 }

    l.mParameters.playShutterSound = false;
 return OK;
}

 status_t CameraDeviceClient::dump(int fd, const Vector<String16>& args) {
     String8 result;
     result.appendFormat("CameraDeviceClient[%d] (%p) PID: %d, dump:\n",
             mCameraId,
            getRemoteCallback()->asBinder().get(),
            mClientPid);
    result.append("  State: ");

    mFrameProcessor->dump(fd, args);

 return dumpDevice(fd, args);
}

bool ProCamera2Client::hasExclusiveLock() {
 Mutex::Autolock icl(mBinderSerializationLock);
 return mExclusiveLock;
}

status_t CameraService::connectFinishUnsafe(const sp<BasicClient>& client,
 const sp<IBinder>& remoteCallback) {
 status_t status = client->initialize(mModule);
 if (status != OK) {
 return status;
 }

    remoteCallback->linkToDeath(this);

 return OK;
}

status_t Camera2Client::setPreviewWindowL(const sp<IBinder>& binder,
        sp<ANativeWindow> window) {
    ATRACE_CALL();
 status_t res;

 if (binder == mPreviewSurface) {
        ALOGV("%s: Camera %d: New window is same as old window",
                __FUNCTION__, mCameraId);
 return NO_ERROR;
 }

 Parameters::State state;
 {
 SharedParameters::Lock l(mParameters);
        state = l.mParameters.state;
 }
 switch (state) {
 case Parameters::DISCONNECTED:
 case Parameters::RECORD:
 case Parameters::STILL_CAPTURE:
 case Parameters::VIDEO_SNAPSHOT:
            ALOGE("%s: Camera %d: Cannot set preview display while in state %s",
                    __FUNCTION__, mCameraId,
 Parameters::getStateName(state));
 return INVALID_OPERATION;
 case Parameters::STOPPED:
 case Parameters::WAITING_FOR_PREVIEW_WINDOW:
 break;
 case Parameters::PREVIEW:
            res = stopStream();
 if (res != OK) {
                ALOGE("%s: Unable to stop preview to swap windows: %s (%d)",
                        __FUNCTION__, strerror(-res), res);
 return res;
 }
            state = Parameters::WAITING_FOR_PREVIEW_WINDOW;
 break;
 }

    mPreviewSurface = binder;
    res = mStreamingProcessor->setPreviewWindow(window);
 if (res != OK) {
        ALOGE("%s: Unable to set new preview window: %s (%d)",
                __FUNCTION__, strerror(-res), res);
 return res;
 }

 if (state == Parameters::WAITING_FOR_PREVIEW_WINDOW) {
 SharedParameters::Lock l(mParameters);
        l.mParameters.state = state;
 return startPreviewL(l.mParameters, false);
 }

 return OK;
}

void CameraService::Client::notifyError() {
    mRemoteCallback->notifyCallback(CAMERA_MSG_ERROR, CAMERA_ERROR_RELEASED, 0);
}

void CameraClient::releaseRecordingFrame(const sp<IMemory>& mem) {
 Mutex::Autolock lock(mLock);
 if (checkPidAndHardware() != NO_ERROR) return;
    mHardware->releaseRecordingFrame(mem);
}

static void disconnectWindow(const sp<ANativeWindow>& window) {
 if (window != 0) {
 status_t result = native_window_api_disconnect(window.get(),
                NATIVE_WINDOW_API_CAMERA);
 if (result != NO_ERROR) {
            ALOGW("native_window_api_disconnect failed: %s (%d)", strerror(-result),
                    result);
 }
 }
}

status_t Camera2Client::sendCommand(int32_t cmd, int32_t arg1, int32_t arg2) {
    ATRACE_CALL();
 Mutex::Autolock icl(mBinderSerializationLock);
 status_t res;
 if ( (res = checkPid(__FUNCTION__) ) != OK) return res;

    ALOGV("%s: Camera %d: Command %d (%d, %d)", __FUNCTION__, mCameraId,
            cmd, arg1, arg2);

 switch (cmd) {
 case CAMERA_CMD_START_SMOOTH_ZOOM:
 return commandStartSmoothZoomL();
 case CAMERA_CMD_STOP_SMOOTH_ZOOM:
 return commandStopSmoothZoomL();
 case CAMERA_CMD_SET_DISPLAY_ORIENTATION:
 return commandSetDisplayOrientationL(arg1);
 case CAMERA_CMD_ENABLE_SHUTTER_SOUND:
 return commandEnableShutterSoundL(arg1 == 1);
 case CAMERA_CMD_PLAY_RECORDING_SOUND:
 return commandPlayRecordingSoundL();
 case CAMERA_CMD_START_FACE_DETECTION:
 return commandStartFaceDetectionL(arg1);
 case CAMERA_CMD_STOP_FACE_DETECTION: {
 SharedParameters::Lock l(mParameters);
 return commandStopFaceDetectionL(l.mParameters);
 }
 case CAMERA_CMD_ENABLE_FOCUS_MOVE_MSG:
 return commandEnableFocusMoveMsgL(arg1 == 1);
 case CAMERA_CMD_PING:
 return commandPingL();
 case CAMERA_CMD_SET_VIDEO_BUFFER_COUNT:
 return commandSetVideoBufferCountL(arg1);
 default:
            ALOGE("%s: Unknown command %d (arguments %d, %d)",
                    __FUNCTION__, cmd, arg1, arg2);
 return BAD_VALUE;
 }
}

bool CameraDeviceClient::enforceRequestPermissions(CameraMetadata& metadata) {

 const int pid = IPCThreadState::self()->getCallingPid();
 const int selfPid = getpid();
 camera_metadata_entry_t entry;

 /**
     * Mixin default important security values
     * - android.led.transmit = defaulted ON
     */
 CameraMetadata staticInfo = mDevice->info();
    entry = staticInfo.find(ANDROID_LED_AVAILABLE_LEDS);
 for(size_t i = 0; i < entry.count; ++i) {
 uint8_t led = entry.data.u8[i];

 switch(led) {
 case ANDROID_LED_AVAILABLE_LEDS_TRANSMIT: {
 uint8_t transmitDefault = ANDROID_LED_TRANSMIT_ON;
 if (!metadata.exists(ANDROID_LED_TRANSMIT)) {
                    metadata.update(ANDROID_LED_TRANSMIT,
 &transmitDefault, 1);
 }
 break;
 }
 }
 }

 if (pid == selfPid) {
 return true;
 }

 /**
     * Permission check special fields in the request
     * - android.led.transmit = android.permission.CAMERA_DISABLE_TRANSMIT
     */
    entry = metadata.find(ANDROID_LED_TRANSMIT);
 if (entry.count > 0 && entry.data.u8[0] != ANDROID_LED_TRANSMIT_ON) {
 String16 permissionString =
 String16("android.permission.CAMERA_DISABLE_TRANSMIT_LED");
 if (!checkCallingPermission(permissionString)) {
 const int uid = IPCThreadState::self()->getCallingUid();
            ALOGE("Permission Denial: "
 "can't disable transmit LED pid=%d, uid=%d", pid, uid);
 return false;
 }
 }

 return true;
}

status_t Camera2Client::commandEnableFocusMoveMsgL(bool enable) {
 SharedParameters::Lock l(mParameters);
    l.mParameters.enableFocusMoveMessages = enable;

 return OK;
}

CameraService::Client::OpsCallback::OpsCallback(wp<BasicClient> client):
        mClient(client) {
}

status_t Camera2Client::stopStream() {
 return mStreamingProcessor->stopStream();
}

int Camera2Client::getRecordingStreamId() const {
 return mStreamingProcessor->getRecordingStreamId();
}

Mutex* CameraService::Client::getClientLockFromCookie(void* user) {
 return gCameraService->getClientLockById((int) user);
}

void ProCamera2Client::onFrameAvailable(int32_t requestId,
 const CameraMetadata& frame) {
    ATRACE_CALL();
    ALOGV("%s", __FUNCTION__);

 Mutex::Autolock icl(mBinderSerializationLock);
 SharedCameraCallbacks::Lock l(mSharedCameraCallbacks);

 if (mRemoteCallback != NULL) {
 CameraMetadata tmp(frame);
 camera_metadata_t* meta = tmp.release();
        ALOGV("%s: meta = %p ", __FUNCTION__, meta);
        mRemoteCallback->onResultReceived(requestId, meta);
        tmp.acquire(meta);
 }

}

status_t Camera2Client::unlock() {
    ATRACE_CALL();
    ALOGV("%s: E", __FUNCTION__);
 Mutex::Autolock icl(mBinderSerializationLock);
    ALOGV("%s: Camera %d: Unlock call from pid %d; current client pid %d",
            __FUNCTION__, mCameraId, getCallingPid(), mClientPid);

 if (mClientPid == getCallingPid()) {
 SharedParameters::Lock l(mParameters);
 if (l.mParameters.state == Parameters::RECORD ||
                l.mParameters.state == Parameters::VIDEO_SNAPSHOT) {
            ALOGD("Not allowed to unlock camera during recording.");
 return INVALID_OPERATION;
 }
        mClientPid = 0;
        mRemoteCallback.clear();
        mSharedCameraCallbacks.clear();
 return OK;
 }

    ALOGE("%s: Camera %d: Unlock call from pid %d; currently locked to pid %d",
            __FUNCTION__, mCameraId, getCallingPid(), mClientPid);
 return EBUSY;
}

CameraClient::CameraClient(const sp<CameraService>& cameraService,
 const sp<ICameraClient>& cameraClient,
 const String16& clientPackageName,
 int cameraId, int cameraFacing,
 int clientPid, int clientUid,
 int servicePid):
 Client(cameraService, cameraClient, clientPackageName,
                cameraId, cameraFacing, clientPid, clientUid, servicePid)
{
 int callingPid = getCallingPid();
    LOG1("CameraClient::CameraClient E (pid %d, id %d)", callingPid, cameraId);

    mHardware = NULL;
    mMsgEnabled = 0;
    mSurface = 0;
    mPreviewWindow = 0;
    mDestructionStarted = false;

    mPreviewCallbackFlag = CAMERA_FRAME_CALLBACK_FLAG_NOOP;
    mOrientation = getOrientation(0, mCameraFacing == CAMERA_FACING_FRONT);
    mPlayShutterSound = true;
    LOG1("CameraClient::CameraClient X (pid %d, id %d)", callingPid, cameraId);
}

status_t ProCamera2Client::createDefaultRequest(int templateId,
 /*out*/
                              camera_metadata** request)
{
    ATRACE_CALL();
    ALOGV("%s (templateId = 0x%x)", __FUNCTION__, templateId);

 if (request) {
 *request = NULL;
 }

 status_t res;
 if ( (res = checkPid(__FUNCTION__) ) != OK) return res;

 Mutex::Autolock icl(mBinderSerializationLock);

 if (!mDevice.get()) return DEAD_OBJECT;

 CameraMetadata metadata;
 if ( (res = mDevice->createDefaultRequest(templateId, &metadata) ) == OK) {
 *request = metadata.release();
 }

 return res;
}

static int getCallingUid() {
 return IPCThreadState::self()->getCallingUid();
}

CameraDeviceClient::CameraDeviceClient(const sp<CameraService>& cameraService,
 const sp<ICameraDeviceCallbacks>& remoteCallback,
 const String16& clientPackageName,
 int cameraId,
 int cameraFacing,
 int clientPid,
 uid_t clientUid,
 int servicePid) :
 Camera2ClientBase(cameraService, remoteCallback, clientPackageName,
                cameraId, cameraFacing, clientPid, clientUid, servicePid),
    mRequestIdCounter(0) {

    ATRACE_CALL();
    ALOGI("CameraDeviceClient %d: Opened", cameraId);
}

ProCamera2Client::ProCamera2Client(const sp<CameraService>& cameraService,
 const sp<IProCameraCallbacks>& remoteCallback,
 const String16& clientPackageName,
 int cameraId,
 int cameraFacing,
 int clientPid,
 uid_t clientUid,
 int servicePid) :
 Camera2ClientBase(cameraService, remoteCallback, clientPackageName,
                cameraId, cameraFacing, clientPid, clientUid, servicePid)
{
    ATRACE_CALL();
    ALOGI("ProCamera %d: Opened", cameraId);

    mExclusiveLock = false;
}

status_t CameraDeviceClient::initialize(camera_module_t *module)
{
    ATRACE_CALL();
 status_t res;

    res = Camera2ClientBase::initialize(module);
 if (res != OK) {
 return res;
 }

 String8 threadName;
    mFrameProcessor = new FrameProcessorBase(mDevice);
    threadName = String8::format("CDU-%d-FrameProc", mCameraId);
    mFrameProcessor->run(threadName.string());

    mFrameProcessor->registerListener(FRAME_PROCESSOR_LISTENER_MIN_ID,
                                      FRAME_PROCESSOR_LISTENER_MAX_ID,
 /*listener*/this,
 /*quirkSendPartials*/true);

 return OK;
}

status_t CameraService::BasicClient::finishCameraOps() {
 if (mOpsActive) {
        mAppOpsManager.finishOp(AppOpsManager::OP_CAMERA, mClientUid,
                mClientPackageName);
        mOpsActive = false;
 }
    mAppOpsManager.stopWatchingMode(mOpsCallback);
    mOpsCallback.clear();

 return OK;
}

status_t ProCamera2Client::exclusiveUnlock() {
    ATRACE_CALL();
    ALOGV("%s", __FUNCTION__);

 Mutex::Autolock icl(mBinderSerializationLock);
 SharedCameraCallbacks::Lock l(mSharedCameraCallbacks);

 if (!mExclusiveLock) {
        ALOGW("%s: cannot unlock, no lock was held in the first place",
              __FUNCTION__);
 return BAD_VALUE;
 }

    mExclusiveLock = false;
 if (mRemoteCallback != NULL ) {
        mRemoteCallback->onLockStatusChanged(
 IProCameraCallbacks::LOCK_RELEASED);
 }
    ALOGV("%s: exclusive lock released", __FUNCTION__);

 return OK;
}

bool ProCamera2Client::enforceRequestPermissions(CameraMetadata& metadata) {

 const int pid = IPCThreadState::self()->getCallingPid();
 const int selfPid = getpid();
 camera_metadata_entry_t entry;

 /**
     * Mixin default important security values
     * - android.led.transmit = defaulted ON
     */
 CameraMetadata staticInfo = mDevice->info();
    entry = staticInfo.find(ANDROID_LED_AVAILABLE_LEDS);
 for(size_t i = 0; i < entry.count; ++i) {
 uint8_t led = entry.data.u8[i];

 switch(led) {
 case ANDROID_LED_AVAILABLE_LEDS_TRANSMIT: {
 uint8_t transmitDefault = ANDROID_LED_TRANSMIT_ON;
 if (!metadata.exists(ANDROID_LED_TRANSMIT)) {
                    metadata.update(ANDROID_LED_TRANSMIT,
 &transmitDefault, 1);
 }
 break;
 }
 }
 }

 if (pid == selfPid) {
 return true;
 }

 /**
     * Permission check special fields in the request
     * - android.led.transmit = android.permission.CAMERA_DISABLE_TRANSMIT
     */
    entry = metadata.find(ANDROID_LED_TRANSMIT);
 if (entry.count > 0 && entry.data.u8[0] != ANDROID_LED_TRANSMIT_ON) {
 String16 permissionString =
 String16("android.permission.CAMERA_DISABLE_TRANSMIT_LED");
 if (!checkCallingPermission(permissionString)) {
 const int uid = IPCThreadState::self()->getCallingUid();
            ALOGE("Permission Denial: "
 "can't disable transmit LED pid=%d, uid=%d", pid, uid);
 return false;
 }
 }

 return true;
}

status_t Camera2Client::connect(const sp<ICameraClient>& client) {
    ATRACE_CALL();
    ALOGV("%s: E", __FUNCTION__);
 Mutex::Autolock icl(mBinderSerializationLock);

 if (mClientPid != 0 && getCallingPid() != mClientPid) {
        ALOGE("%s: Camera %d: Connection attempt from pid %d; "
 "current locked to pid %d", __FUNCTION__,
                mCameraId, getCallingPid(), mClientPid);
 return BAD_VALUE;
 }

    mClientPid = getCallingPid();

    mRemoteCallback = client;
    mSharedCameraCallbacks = client;

 return OK;
}

status_t CameraClient::lock() {
 int callingPid = getCallingPid();
    LOG1("lock (pid %d)", callingPid);
 Mutex::Autolock lock(mLock);

 if (mClientPid == 0) {
        mClientPid = callingPid;
 return NO_ERROR;
 }

 return checkPid();
}

void CameraClient::handleRawPicture(const sp<IMemory>& mem) {
    disableMsgType(CAMERA_MSG_RAW_IMAGE);

 ssize_t offset;
 size_t size;
    sp<IMemoryHeap> heap = mem->getMemory(&offset, &size);

    sp<ICameraClient> c = mRemoteCallback;
    mLock.unlock();
 if (c != 0) {
        c->dataCallback(CAMERA_MSG_RAW_IMAGE, mem, NULL);
 }
}

 status_t Camera2Client::dump(int fd, const Vector<String16>& args) {
     String8 result;
     result.appendFormat("Client2[%d] (%p) Client: %s PID: %d, dump:\n",
             mCameraId,
            getRemoteCallback()->asBinder().get(),
 String8(mClientPackageName).string(),
            mClientPid);
    result.append("  State: ");
#define CASE_APPEND_ENUM(x) case x: result.append(#x "\n"); break;

 const Parameters& p = mParameters.unsafeAccess();

    result.append(Parameters::getStateName(p.state));

    result.append("\n  Current parameters:\n");
    result.appendFormat("    Preview size: %d x %d\n",
            p.previewWidth, p.previewHeight);
    result.appendFormat("    Preview FPS range: %d - %d\n",
            p.previewFpsRange[0], p.previewFpsRange[1]);
    result.appendFormat("    Preview HAL pixel format: 0x%x\n",
            p.previewFormat);
    result.appendFormat("    Preview transform: %x\n",
            p.previewTransform);
    result.appendFormat("    Picture size: %d x %d\n",
            p.pictureWidth, p.pictureHeight);
    result.appendFormat("    Jpeg thumbnail size: %d x %d\n",
            p.jpegThumbSize[0], p.jpegThumbSize[1]);
    result.appendFormat("    Jpeg quality: %d, thumbnail quality: %d\n",
            p.jpegQuality, p.jpegThumbQuality);
    result.appendFormat("    Jpeg rotation: %d\n", p.jpegRotation);
    result.appendFormat("    GPS tags %s\n",
            p.gpsEnabled ? "enabled" : "disabled");
 if (p.gpsEnabled) {
        result.appendFormat("    GPS lat x long x alt: %f x %f x %f\n",
                p.gpsCoordinates[0], p.gpsCoordinates[1],
                p.gpsCoordinates[2]);
        result.appendFormat("    GPS timestamp: %lld\n",
                p.gpsTimestamp);
        result.appendFormat("    GPS processing method: %s\n",
                p.gpsProcessingMethod.string());
 }

    result.append("    White balance mode: ");
 switch (p.wbMode) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_AUTO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_INCANDESCENT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_FLUORESCENT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_WARM_FLUORESCENT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_DAYLIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_CLOUDY_DAYLIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_TWILIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_SHADE)
 default: result.append("UNKNOWN\n");
 }

    result.append("    Effect mode: ");
 switch (p.effectMode) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_OFF)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_MONO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_NEGATIVE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_SOLARIZE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_SEPIA)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_POSTERIZE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_WHITEBOARD)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_BLACKBOARD)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_AQUA)
 default: result.append("UNKNOWN\n");
 }

    result.append("    Antibanding mode: ");
 switch (p.antibandingMode) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_AUTO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_OFF)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_50HZ)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_60HZ)
 default: result.append("UNKNOWN\n");
 }

    result.append("    Scene mode: ");
 switch (p.sceneMode) {
 case ANDROID_CONTROL_SCENE_MODE_UNSUPPORTED:
            result.append("AUTO\n"); break;
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_ACTION)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_PORTRAIT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_LANDSCAPE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_NIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_NIGHT_PORTRAIT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_THEATRE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_BEACH)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_SNOW)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_SUNSET)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_STEADYPHOTO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_FIREWORKS)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_SPORTS)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_PARTY)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_CANDLELIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_BARCODE)
 default: result.append("UNKNOWN\n");
 }

    result.append("    Flash mode: ");
 switch (p.flashMode) {
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_OFF)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_AUTO)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_ON)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_TORCH)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_RED_EYE)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_INVALID)
 default: result.append("UNKNOWN\n");
 }

    result.append("    Focus mode: ");
 switch (p.focusMode) {
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_AUTO)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_MACRO)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_CONTINUOUS_VIDEO)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_CONTINUOUS_PICTURE)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_EDOF)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_INFINITY)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_FIXED)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_INVALID)
 default: result.append("UNKNOWN\n");
 }

    result.append("   Focus state: ");
 switch (p.focusState) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_INACTIVE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_PASSIVE_SCAN)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_PASSIVE_FOCUSED)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_PASSIVE_UNFOCUSED)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_ACTIVE_SCAN)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_FOCUSED_LOCKED)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_NOT_FOCUSED_LOCKED)
 default: result.append("UNKNOWN\n");
 }

    result.append("    Focusing areas:\n");
 for (size_t i = 0; i < p.focusingAreas.size(); i++) {
        result.appendFormat("      [ (%d, %d, %d, %d), weight %d ]\n",
                p.focusingAreas[i].left,
                p.focusingAreas[i].top,
                p.focusingAreas[i].right,
                p.focusingAreas[i].bottom,
                p.focusingAreas[i].weight);
 }

    result.appendFormat("    Exposure compensation index: %d\n",
            p.exposureCompensation);

    result.appendFormat("    AE lock %s, AWB lock %s\n",
            p.autoExposureLock ? "enabled" : "disabled",
            p.autoWhiteBalanceLock ? "enabled" : "disabled" );

    result.appendFormat("    Metering areas:\n");
 for (size_t i = 0; i < p.meteringAreas.size(); i++) {
        result.appendFormat("      [ (%d, %d, %d, %d), weight %d ]\n",
                p.meteringAreas[i].left,
                p.meteringAreas[i].top,
                p.meteringAreas[i].right,
                p.meteringAreas[i].bottom,
                p.meteringAreas[i].weight);
 }

    result.appendFormat("    Zoom index: %d\n", p.zoom);
    result.appendFormat("    Video size: %d x %d\n", p.videoWidth,
            p.videoHeight);

    result.appendFormat("    Recording hint is %s\n",
            p.recordingHint ? "set" : "not set");

    result.appendFormat("    Video stabilization is %s\n",
            p.videoStabilization ? "enabled" : "disabled");

    result.appendFormat("    Selected still capture FPS range: %d - %d\n",
            p.fastInfo.bestStillCaptureFpsRange[0],
            p.fastInfo.bestStillCaptureFpsRange[1]);

    result.append("  Current streams:\n");
    result.appendFormat("    Preview stream ID: %d\n",
            getPreviewStreamId());
    result.appendFormat("    Capture stream ID: %d\n",
            getCaptureStreamId());
    result.appendFormat("    Recording stream ID: %d\n",
            getRecordingStreamId());

    result.append("  Quirks for this camera:\n");
 bool haveQuirk = false;
 if (p.quirks.triggerAfWithAuto) {
        result.appendFormat("    triggerAfWithAuto\n");
        haveQuirk = true;
 }
 if (p.quirks.useZslFormat) {
        result.appendFormat("    useZslFormat\n");
        haveQuirk = true;
 }
 if (p.quirks.meteringCropRegion) {
        result.appendFormat("    meteringCropRegion\n");
        haveQuirk = true;
 }
 if (p.quirks.partialResults) {
        result.appendFormat("    usePartialResult\n");
        haveQuirk = true;
 }
 if (!haveQuirk) {
        result.appendFormat("    none\n");
 }

    write(fd, result.string(), result.size());

    mStreamingProcessor->dump(fd, args);

    mCaptureSequencer->dump(fd, args);

    mFrameProcessor->dump(fd, args);

    mZslProcessor->dump(fd, args);

 return dumpDevice(fd, args);
#undef CASE_APPEND_ENUM
}

status_t CameraClient::connect(const sp<ICameraClient>& client) {
 int callingPid = getCallingPid();
    LOG1("connect E (pid %d)", callingPid);
 Mutex::Autolock lock(mLock);

 if (mClientPid != 0 && checkPid() != NO_ERROR) {
        ALOGW("Tried to connect to a locked camera (old pid %d, new pid %d)",
                mClientPid, callingPid);
 return EBUSY;
 }

 if (mRemoteCallback != 0 &&
 (client->asBinder() == mRemoteCallback->asBinder())) {
        LOG1("Connect to the same client");
 return NO_ERROR;
 }

    mPreviewCallbackFlag = CAMERA_FRAME_CALLBACK_FLAG_NOOP;
    mClientPid = callingPid;
    mRemoteCallback = client;

    LOG1("connect X (pid %d)", callingPid);
 return NO_ERROR;
}

int Camera2Client::getCaptureStreamId() const {
 return mJpegProcessor->getStreamId();
}

void CameraService::playSound(sound_kind kind) {
    LOG1("playSound(%d)", kind);
 Mutex::Autolock lock(mSoundLock);
    sp<MediaPlayer> player = mSoundPlayer[kind];
 if (player != 0) {
        player->seekTo(0);
        player->start();
 }
}

CameraService::BasicClient* CameraService::getClientByIdUnsafe(int cameraId) {
 if (cameraId < 0 || cameraId >= mNumberOfCameras) return NULL;
 return mClient[cameraId].unsafe_get();
}

status_t CameraClient::startRecording() {
    LOG1("startRecording (pid %d)", getCallingPid());
 return startCameraMode(CAMERA_RECORDING_MODE);
}

void CameraService::Client::OpsCallback::opChanged(int32_t op,
 const String16& packageName) {
    sp<BasicClient> client = mClient.promote();
 if (client != NULL) {
        client->opChanged(op, packageName);
 }
}

status_t CameraService::connect(
 const sp<ICameraClient>& cameraClient,
 int cameraId,
 const String16& clientPackageName,
 int clientUid,
 /*out*/
        sp<ICamera>& device) {

 String8 clientName8(clientPackageName);
 int callingPid = getCallingPid();

    LOG1("CameraService::connect E (pid %d \"%s\", id %d)", callingPid,
            clientName8.string(), cameraId);

 status_t status = validateConnect(cameraId, /*inout*/clientUid);
 if (status != OK) {
 return status;
 }


    sp<Client> client;
 {
 Mutex::Autolock lock(mServiceLock);
        sp<BasicClient> clientTmp;
 if (!canConnectUnsafe(cameraId, clientPackageName,
                              cameraClient->asBinder(),
 /*out*/clientTmp)) {
 return -EBUSY;
 } else if (client.get() != NULL) {
            device = static_cast<Client*>(clientTmp.get());
 return OK;
 }

 int facing = -1;
 int deviceVersion = getDeviceVersion(cameraId, &facing);

 if (isValidCameraId(cameraId)) {
            updateStatus(ICameraServiceListener::STATUS_NOT_AVAILABLE,
                         cameraId);
 }

 switch(deviceVersion) {
 case CAMERA_DEVICE_API_VERSION_1_0:
            client = new CameraClient(this, cameraClient,
                    clientPackageName, cameraId,
                    facing, callingPid, clientUid, getpid());
 break;
 case CAMERA_DEVICE_API_VERSION_2_0:
 case CAMERA_DEVICE_API_VERSION_2_1:
 case CAMERA_DEVICE_API_VERSION_3_0:
            client = new Camera2Client(this, cameraClient,
                    clientPackageName, cameraId,
                    facing, callingPid, clientUid, getpid(),
                    deviceVersion);
 break;
 case -1:
            ALOGE("Invalid camera id %d", cameraId);
 return BAD_VALUE;
 default:
            ALOGE("Unknown camera device HAL version: %d", deviceVersion);
 return INVALID_OPERATION;
 }

 status_t status = connectFinishUnsafe(client, client->getRemote());
 if (status != OK) {
            updateStatus(ICameraServiceListener::STATUS_PRESENT, cameraId);
 return status;
 }

        mClient[cameraId] = client;
        LOG1("CameraService::connect X (id %d, this pid is %d)", cameraId,
             getpid());
 }

    device = client;
 return OK;
}

status_t CameraClient::storeMetaDataInBuffers(bool enabled)
{
    LOG1("storeMetaDataInBuffers: %s", enabled? "true": "false");
 Mutex::Autolock lock(mLock);
 if (checkPidAndHardware() != NO_ERROR) {
 return UNKNOWN_ERROR;
 }
 return mHardware->storeMetaDataInBuffers(enabled);
}

status_t Camera2Client::updateRequests(Parameters &params) {
 status_t res;

    ALOGV("%s: Camera %d: state = %d", __FUNCTION__, getCameraId(), params.state);

    res = mStreamingProcessor->incrementStreamingIds();
 if (res != OK) {
        ALOGE("%s: Camera %d: Unable to increment request IDs: %s (%d)",
                __FUNCTION__, mCameraId, strerror(-res), res);
 return res;
 }

    res = mStreamingProcessor->updatePreviewRequest(params);
 if (res != OK) {
        ALOGE("%s: Camera %d: Unable to update preview request: %s (%d)",
                __FUNCTION__, mCameraId, strerror(-res), res);
 return res;
 }
    res = mStreamingProcessor->updateRecordingRequest(params);
 if (res != OK) {
        ALOGE("%s: Camera %d: Unable to update recording request: %s (%d)",
                __FUNCTION__, mCameraId, strerror(-res), res);
 return res;
 }

 if (params.state == Parameters::PREVIEW) {
        res = startPreviewL(params, true);
 if (res != OK) {
            ALOGE("%s: Camera %d: Error streaming new preview request: %s (%d)",
                    __FUNCTION__, mCameraId, strerror(-res), res);
 return res;
 }
 } else if (params.state == Parameters::RECORD ||
            params.state == Parameters::VIDEO_SNAPSHOT) {
        res = startRecordingL(params, true);
 if (res != OK) {
            ALOGE("%s: Camera %d: Error streaming new record request: %s (%d)",
                    __FUNCTION__, mCameraId, strerror(-res), res);
 return res;
 }
 }
 return res;
}

void CameraClient::dataCallbackTimestamp(nsecs_t timestamp,
 int32_t msgType, const sp<IMemory>& dataPtr, void* user) {
    LOG2("dataCallbackTimestamp(%d)", msgType);

 Mutex* lock = getClientLockFromCookie(user);
 if (lock == NULL) return;
 Mutex::Autolock alock(*lock);

 CameraClient* client =
 static_cast<CameraClient*>(getClientFromCookie(user));
 if (client == NULL) return;

 if (!client->lockIfMessageWanted(msgType)) return;

 if (dataPtr == 0) {
        ALOGE("Null data returned in data with timestamp callback");
        client->handleGenericNotify(CAMERA_MSG_ERROR, UNKNOWN_ERROR, 0);
 return;
 }

    client->handleGenericDataTimestamp(timestamp, msgType, dataPtr);
}

status_t Camera2Client::commandPlayRecordingSoundL() {
    mCameraService->playSound(CameraService::SOUND_RECORDING);
 return OK;
}

sp<CameraService::BasicClient> CameraService::findClientUnsafe(
 const wp<IBinder>& cameraClient, int& outIndex) {
    sp<BasicClient> client;

 for (int i = 0; i < mNumberOfCameras; i++) {

 if (mClient[i] == 0) continue;

        client = mClient[i].promote();

 if (client == NULL) {
            mClient[i].clear();
 continue;
 }

 if (cameraClient == client->getRemote()) {
            outIndex = i;
 return client;
 }
 }

    outIndex = -1;
 return NULL;
}

bool CameraClient::lockIfMessageWanted(int32_t msgType) {
 int sleepCount = 0;
 while (mMsgEnabled & msgType) {
 if (mLock.tryLock() == NO_ERROR) {
 if (sleepCount > 0) {
                LOG1("lockIfMessageWanted(%d): waited for %d ms",
                    msgType, sleepCount * CHECK_MESSAGE_INTERVAL);
 }
 return true;
 }
 if (sleepCount++ == 0) {
            LOG1("lockIfMessageWanted(%d): enter sleep", msgType);
 }
        usleep(CHECK_MESSAGE_INTERVAL * 1000);
 }
    ALOGW("lockIfMessageWanted(%d): dropped unwanted message", msgType);
 return false;
}

ProCamera2Client::~ProCamera2Client() {
}

void CameraService::BasicClient::disconnect() {
    ALOGV("BasicClient::disconnect");
    mCameraService->removeClientByRemote(mRemoteBinder);

     mClientPid = 0;
 }

void CameraService::updateStatus(ICameraServiceListener::Status status,
 int32_t cameraId,
 const StatusVector *rejectSourceStates) {
 Mutex::Autolock lock(mStatusMutex);

 ICameraServiceListener::Status oldStatus = mStatusList[cameraId];

    mStatusList[cameraId] = status;

 if (oldStatus != status) {
        ALOGV("%s: Status has changed for camera ID %d from 0x%x to 0x%x",
              __FUNCTION__, cameraId, (uint32_t)oldStatus, (uint32_t)status);

 if (oldStatus == ICameraServiceListener::STATUS_NOT_PRESENT &&
 (status != ICameraServiceListener::STATUS_PRESENT &&
             status != ICameraServiceListener::STATUS_ENUMERATING)) {

            ALOGW("%s: From NOT_PRESENT can only transition into PRESENT"
 " or ENUMERATING", __FUNCTION__);
            mStatusList[cameraId] = oldStatus;
 return;
 }

 if (rejectSourceStates != NULL) {
 const StatusVector &rejectList = *rejectSourceStates;
 StatusVector::const_iterator it = rejectList.begin();

 /**
             * Sometimes we want to conditionally do a transition.
             * For example if a client disconnects, we want to go to PRESENT
             * only if we weren't already in NOT_PRESENT or ENUMERATING.
             */
 for (; it != rejectList.end(); ++it) {
 if (oldStatus == *it) {
                    ALOGV("%s: Rejecting status transition for Camera ID %d, "
 " since the source state was was in one of the bad "
 " states.", __FUNCTION__, cameraId);
                    mStatusList[cameraId] = oldStatus;
 return;
 }
 }
 }

 /**
          * ProClients lose their exclusive lock.
          * - Done before the CameraClient can initialize the HAL device,
          *   since we want to be able to close it before they get to initialize
          */
 if (status == ICameraServiceListener::STATUS_NOT_AVAILABLE) {
 Vector<wp<ProClient> > proClients(mProClientList[cameraId]);
 Vector<wp<ProClient> >::const_iterator it;

 for (it = proClients.begin(); it != proClients.end(); ++it) {
                sp<ProClient> proCl = it->promote();
 if (proCl.get() != NULL) {
                    proCl->onExclusiveLockStolen();
 }
 }
 }

 Vector<sp<ICameraServiceListener> >::const_iterator it;
 for (it = mListenerList.begin(); it != mListenerList.end(); ++it) {
 (*it)->onStatusChanged(status, cameraId);
 }
 }
}

int32_t CameraService::getNumberOfCameras() {
 return mNumberOfCameras;
}

status_t CameraClient::startCameraMode(camera_mode mode) {
    LOG1("startCameraMode(%d)", mode);
 Mutex::Autolock lock(mLock);
 status_t result = checkPidAndHardware();
 if (result != NO_ERROR) return result;

 switch(mode) {
 case CAMERA_PREVIEW_MODE:
 if (mSurface == 0 && mPreviewWindow == 0) {
                LOG1("mSurface is not set yet.");
 }
 return startPreviewMode();
 case CAMERA_RECORDING_MODE:
 if (mSurface == 0 && mPreviewWindow == 0) {
                ALOGE("mSurface or mPreviewWindow must be set before startRecordingMode.");
 return INVALID_OPERATION;
 }
 return startRecordingMode();
 default:
 return UNKNOWN_ERROR;
 }
}

void CameraService::removeClientByRemote(const wp<IBinder>& remoteBinder) {
 int callingPid = getCallingPid();
    LOG1("CameraService::removeClientByRemote E (pid %d)", callingPid);

 Mutex::Autolock lock(mServiceLock);

 int outIndex;
    sp<BasicClient> client = findClientUnsafe(remoteBinder, outIndex);

 if (client != 0) {
        LOG1("removeClient: clear camera %d", outIndex);
        mClient[outIndex].clear();

        client->getRemote()->unlinkToDeath(this);
 } else {

        sp<ProClient> clientPro = findProClientUnsafe(remoteBinder);

 if (clientPro != NULL) {
            LOG1("removeClient: clear pro %p", clientPro.get());

            clientPro->getRemoteCallback()->asBinder()->unlinkToDeath(this);
 }
 }

    LOG1("CameraService::removeClientByRemote X (pid %d)", callingPid);
}

void CameraService::setCameraFree(int cameraId) {
    android_atomic_write(0, &mBusy[cameraId]);

    ALOGV("setCameraFree cameraId=%d", cameraId);
}

status_t Camera2Client::setParameters(const String8& params) {
    ATRACE_CALL();
    ALOGV("%s: Camera %d", __FUNCTION__, mCameraId);
 Mutex::Autolock icl(mBinderSerializationLock);
 status_t res;
 if ( (res = checkPid(__FUNCTION__) ) != OK) return res;

 SharedParameters::Lock l(mParameters);

    res = l.mParameters.set(params);
 if (res != OK) return res;

    res = updateRequests(l.mParameters);

 return res;
}

sp<CameraService::ProClient> CameraService::findProClientUnsafe(
 const wp<IBinder>& cameraCallbacksRemote)
{
    sp<ProClient> clientPro;

 for (int i = 0; i < mNumberOfCameras; ++i) {
 Vector<size_t> removeIdx;

 for (size_t j = 0; j < mProClientList[i].size(); ++j) {
            wp<ProClient> cl = mProClientList[i][j];

            sp<ProClient> clStrong = cl.promote();
 if (clStrong != NULL && clStrong->getRemote() == cameraCallbacksRemote) {
                clientPro = clStrong;
 break;
 } else if (clStrong == NULL) {
                removeIdx.push(j);
 }
 }

 for (ssize_t j = (ssize_t)removeIdx.size() - 1; j >= 0; --j) {
            mProClientList[i].removeAt(removeIdx[j]);
 }

 }

 return clientPro;
}

status_t ProCamera2Client::initialize(camera_module_t *module)
{
    ATRACE_CALL();
 status_t res;

    res = Camera2ClientBase::initialize(module);
 if (res != OK) {
 return res;
 }

 String8 threadName;
    mFrameProcessor = new FrameProcessorBase(mDevice);
    threadName = String8::format("PC2-%d-FrameProc", mCameraId);
    mFrameProcessor->run(threadName.string());

    mFrameProcessor->registerListener(FRAME_PROCESSOR_LISTENER_MIN_ID,
                                      FRAME_PROCESSOR_LISTENER_MAX_ID,
 /*listener*/this);

 return OK;
}

void CameraService::ProClient::notifyError() {
    mRemoteCallback->notifyCallback(CAMERA_MSG_ERROR, CAMERA_ERROR_RELEASED, 0);
}

String8 Camera2Client::getParameters() const {
    ATRACE_CALL();
    ALOGV("%s: Camera %d", __FUNCTION__, mCameraId);
 Mutex::Autolock icl(mBinderSerializationLock);
 if ( checkPid(__FUNCTION__) != OK) return String8();

 SharedParameters::ReadLock l(mParameters);

 return l.mParameters.get();
}

CameraService::~CameraService() {
 for (int i = 0; i < mNumberOfCameras; i++) {
 if (mBusy[i]) {
            ALOGE("camera %d is still in use in destructor!", i);
 }
 }

    gCameraService = NULL;
}

void ProCamera2Client::onExclusiveLockStolen() {
    ALOGV("%s: ProClient lost exclusivity (id %d)",
          __FUNCTION__, mCameraId);

 Mutex::Autolock icl(mBinderSerializationLock);
 SharedCameraCallbacks::Lock l(mSharedCameraCallbacks);

 if (mExclusiveLock && mRemoteCallback.get() != NULL) {
        mRemoteCallback->onLockStatusChanged(
 IProCameraCallbacks::LOCK_STOLEN);
 }

    mExclusiveLock = false;

    detachDevice();
}

bool Camera2Client::recordingEnabledL() {
    ATRACE_CALL();
 SharedParameters::Lock l(mParameters);

 return (l.mParameters.state == Parameters::RECORD
 || l.mParameters.state == Parameters::VIDEO_SNAPSHOT);
}

CameraService::CameraService()
 :mSoundRef(0), mModule(0)
{
    ALOGI("CameraService started (pid=%d)", getpid());
    gCameraService = this;

 for (size_t i = 0; i < MAX_CAMERAS; ++i) {
        mStatusList[i] = ICameraServiceListener::STATUS_PRESENT;
 }

 this->camera_device_status_change = android::camera_device_status_change;
}

void CameraClient::handleGenericDataTimestamp(nsecs_t timestamp,
 int32_t msgType, const sp<IMemory>& dataPtr) {
    sp<ICameraClient> c = mRemoteCallback;
    mLock.unlock();
 if (c != 0) {
        c->dataCallbackTimestamp(timestamp, msgType, dataPtr);
 }
}

static void setLogLevel(int level) {
    android_atomic_write(level, &gLogLevel);
}

void Camera2Client::disconnect() {
    ATRACE_CALL();
 Mutex::Autolock icl(mBinderSerializationLock);

 int callingPid = getCallingPid();
 if (callingPid != mClientPid && callingPid != mServicePid) return;

 if (mDevice == 0) return;

    ALOGV("Camera %d: Shutting down", mCameraId);

 /**
     * disconnect() cannot call any methods that might need to promote a
     * wp<Camera2Client>, since disconnect can be called from the destructor, at
     * which point all such promotions will fail.
     */

    stopPreviewL();

 {
 SharedParameters::Lock l(mParameters);
 if (l.mParameters.state == Parameters::DISCONNECTED) return;
        l.mParameters.state = Parameters::DISCONNECTED;
 }

    mStreamingProcessor->requestExit();
    mFrameProcessor->requestExit();
    mCaptureSequencer->requestExit();
    mJpegProcessor->requestExit();
    mZslProcessorThread->requestExit();
    mCallbackProcessor->requestExit();

    ALOGV("Camera %d: Waiting for threads", mCameraId);

    mStreamingProcessor->join();
    mFrameProcessor->join();
    mCaptureSequencer->join();
    mJpegProcessor->join();
    mZslProcessorThread->join();
    mCallbackProcessor->join();

    ALOGV("Camera %d: Deleting streams", mCameraId);

    mStreamingProcessor->deletePreviewStream();
    mStreamingProcessor->deleteRecordingStream();
    mJpegProcessor->deleteStream();
    mCallbackProcessor->deleteStream();
    mZslProcessor->deleteStream();

    ALOGV("Camera %d: Disconnecting device", mCameraId);

    mDevice->disconnect();

    mDevice.clear();

 CameraService::Client::disconnect();
}

status_t ProCamera2Client::deleteStream(int streamId) {
    ATRACE_CALL();
    ALOGV("%s (streamId = 0x%x)", __FUNCTION__, streamId);

 status_t res;
 if ( (res = checkPid(__FUNCTION__) ) != OK) return res;

 Mutex::Autolock icl(mBinderSerializationLock);

 if (!mDevice.get()) return DEAD_OBJECT;
    mDevice->clearStreamingRequest();

 status_t code;
 if ((code = mDevice->waitUntilDrained()) != OK) {
        ALOGE("%s: waitUntilDrained failed with code 0x%x", __FUNCTION__, code);
 }

 return mDevice->deleteStream(streamId);
}

void CameraClient::handlePreviewData(int32_t msgType,
 const sp<IMemory>& mem,
 camera_frame_metadata_t *metadata) {
 ssize_t offset;
 size_t size;
    sp<IMemoryHeap> heap = mem->getMemory(&offset, &size);

 int flags = mPreviewCallbackFlag;

 if (!(flags & CAMERA_FRAME_CALLBACK_FLAG_ENABLE_MASK)) {
        LOG2("frame callback is disabled");
        mLock.unlock();
 return;
 }

    sp<ICameraClient> c = mRemoteCallback;

 if (c == 0 || (mPreviewCallbackFlag & CAMERA_FRAME_CALLBACK_FLAG_ONE_SHOT_MASK)) {
        LOG2("Disable preview callback");
        mPreviewCallbackFlag &= ~(CAMERA_FRAME_CALLBACK_FLAG_ONE_SHOT_MASK |
                                  CAMERA_FRAME_CALLBACK_FLAG_COPY_OUT_MASK |
                                  CAMERA_FRAME_CALLBACK_FLAG_ENABLE_MASK);
        disableMsgType(CAMERA_MSG_PREVIEW_FRAME);
 }

 if (c != 0) {
 if (flags & CAMERA_FRAME_CALLBACK_FLAG_COPY_OUT_MASK) {
            LOG2("frame is copied");
            copyFrameAndPostCopiedFrame(msgType, c, heap, offset, size, metadata);
 } else {
            LOG2("frame is forwarded");
            mLock.unlock();
            c->dataCallback(msgType, mem, metadata);
 }
 } else {
        mLock.unlock();
 }
}

void CameraService::Client::disconnect() {
    ALOGV("Client::disconnect");
 BasicClient::disconnect();
    mCameraService->setCameraFree(mCameraId);

 StatusVector rejectSourceStates;
    rejectSourceStates.push_back(ICameraServiceListener::STATUS_NOT_PRESENT);
    rejectSourceStates.push_back(ICameraServiceListener::STATUS_ENUMERATING);

    mCameraService->updateStatus(ICameraServiceListener::STATUS_PRESENT,
                                 mCameraId,
 &rejectSourceStates);
}

status_t CameraClient::startRecordingMode() {
    LOG1("startRecordingMode");
 status_t result = NO_ERROR;

 if (mHardware->recordingEnabled()) {
 return NO_ERROR;
 }

 if (!mHardware->previewEnabled()) {
        result = startPreviewMode();
 if (result != NO_ERROR) {
 return result;
 }
 }

    enableMsgType(CAMERA_MSG_VIDEO_FRAME);
    mCameraService->playSound(CameraService::SOUND_RECORDING);
    result = mHardware->startRecording();
 if (result != NO_ERROR) {
        ALOGE("mHardware->startRecording() failed with status %d", result);
 }
 return result;
}

void CameraDeviceClient::detachDevice() {
 if (mDevice == 0) return;

    ALOGV("Camera %d: Stopping processors", mCameraId);

    mFrameProcessor->removeListener(FRAME_PROCESSOR_LISTENER_MIN_ID,
                                    FRAME_PROCESSOR_LISTENER_MAX_ID,
 /*listener*/this);
    mFrameProcessor->requestExit();
    ALOGV("Camera %d: Waiting for threads", mCameraId);
    mFrameProcessor->join();
    ALOGV("Camera %d: Disconnecting device", mCameraId);

 {
        mDevice->clearStreamingRequest();

 status_t code;
 if ((code = mDevice->waitUntilDrained()) != OK) {
            ALOGE("%s: waitUntilDrained failed with code 0x%x", __FUNCTION__,
                  code);
 }
 }

 Camera2ClientBase::detachDevice();
}

status_t CameraClient::setPreviewWindow(const sp<IBinder>& binder,
 const sp<ANativeWindow>& window) {
 Mutex::Autolock lock(mLock);
 status_t result = checkPidAndHardware();
 if (result != NO_ERROR) return result;

 if (binder == mSurface) {
 return NO_ERROR;
 }

 if (window != 0) {
        result = native_window_api_connect(window.get(), NATIVE_WINDOW_API_CAMERA);
 if (result != NO_ERROR) {
            ALOGE("native_window_api_connect failed: %s (%d)", strerror(-result),
                    result);
 return result;
 }
 }

 if (mHardware->previewEnabled()) {
 if (window != 0) {
            native_window_set_scaling_mode(window.get(),
                    NATIVE_WINDOW_SCALING_MODE_SCALE_TO_WINDOW);
            native_window_set_buffers_transform(window.get(), mOrientation);
            result = mHardware->setPreviewWindow(window);
 }
 }

 if (result == NO_ERROR) {
        disconnectWindow(mPreviewWindow);
        mSurface = binder;
        mPreviewWindow = window;
 } else {
        disconnectWindow(window);
 }

 return result;
}

status_t CameraClient::enableShutterSound(bool enable) {
    LOG1("enableShutterSound (pid %d)", getCallingPid());

 status_t result = checkPidAndHardware();
 if (result != NO_ERROR) return result;

 if (enable) {
        mPlayShutterSound = true;
 return OK;
 }

 char value[PROPERTY_VALUE_MAX];
    property_get("ro.camera.sound.forced", value, "0");
 if (strcmp(value, "0") != 0) {
 if (getCallingPid() != getpid()) {
            ALOGE("Failed to disable shutter sound. Permission denied (pid %d)", getCallingPid());
 return PERMISSION_DENIED;
 }
 }

    mPlayShutterSound = false;
 return OK;
}

int CameraClient::getOrientation(int degrees, bool mirror) {
 if (!mirror) {
 if (degrees == 0) return 0;
 else if (degrees == 90) return HAL_TRANSFORM_ROT_90;
 else if (degrees == 180) return HAL_TRANSFORM_ROT_180;
 else if (degrees == 270) return HAL_TRANSFORM_ROT_270;
 } else { // Do mirror (horizontal flip)
 if (degrees == 0) { // FLIP_H and ROT_0
 return HAL_TRANSFORM_FLIP_H;
 } else if (degrees == 90) { // FLIP_H and ROT_90
 return HAL_TRANSFORM_FLIP_H | HAL_TRANSFORM_ROT_90;
 } else if (degrees == 180) { // FLIP_H and ROT_180
 return HAL_TRANSFORM_FLIP_V;
 } else if (degrees == 270) { // FLIP_H and ROT_270
 return HAL_TRANSFORM_FLIP_V | HAL_TRANSFORM_ROT_90;
 }
 }
    ALOGE("Invalid setDisplayOrientation degrees=%d", degrees);
 return -1;
}

status_t CameraService::getCameraInfo(int cameraId,
 struct CameraInfo* cameraInfo) {
 if (!mModule) {
 return -ENODEV;
 }

 if (cameraId < 0 || cameraId >= mNumberOfCameras) {
 return BAD_VALUE;
 }

 struct camera_info info;
 status_t rc = mModule->get_camera_info(cameraId, &info);
    cameraInfo->facing = info.facing;
    cameraInfo->orientation = info.orientation;
 return rc;
}

status_t CameraDeviceClient::createStream(int width, int height, int format,
 const sp<IGraphicBufferProducer>& bufferProducer)
{
    ATRACE_CALL();
    ALOGV("%s (w = %d, h = %d, f = 0x%x)", __FUNCTION__, width, height, format);

 status_t res;
 if ( (res = checkPid(__FUNCTION__) ) != OK) return res;

 Mutex::Autolock icl(mBinderSerializationLock);

 if (!mDevice.get()) return DEAD_OBJECT;

 {
 ssize_t index = mStreamMap.indexOfKey(bufferProducer->asBinder());
 if (index != NAME_NOT_FOUND) {
            ALOGW("%s: Camera %d: Buffer producer already has a stream for it "
 "(ID %d)",
                  __FUNCTION__, mCameraId, index);
 return ALREADY_EXISTS;
 }
 }

 bool useAsync = false;
 int32_t consumerUsage;
 if ((res = bufferProducer->query(NATIVE_WINDOW_CONSUMER_USAGE_BITS,
 &consumerUsage)) != OK) {
        ALOGE("%s: Camera %d: Failed to query consumer usage", __FUNCTION__,
              mCameraId);
 return res;
 }
 if (consumerUsage & GraphicBuffer::USAGE_HW_TEXTURE) {
        ALOGW("%s: Camera %d: Forcing asynchronous mode for stream",
                __FUNCTION__, mCameraId);
        useAsync = true;
 }

    sp<IBinder> binder;
    sp<ANativeWindow> anw;
 if (bufferProducer != 0) {
        binder = bufferProducer->asBinder();
        anw = new Surface(bufferProducer, useAsync);
 }


 if ((res = anw->query(anw.get(), NATIVE_WINDOW_WIDTH, &width)) != OK) {
        ALOGE("%s: Camera %d: Failed to query Surface width", __FUNCTION__,
              mCameraId);
 return res;
 }
 if ((res = anw->query(anw.get(), NATIVE_WINDOW_HEIGHT, &height)) != OK) {
        ALOGE("%s: Camera %d: Failed to query Surface height", __FUNCTION__,
              mCameraId);
 return res;
 }
 if ((res = anw->query(anw.get(), NATIVE_WINDOW_FORMAT, &format)) != OK) {
        ALOGE("%s: Camera %d: Failed to query Surface format", __FUNCTION__,
              mCameraId);
 return res;
 }

 if (format >= HAL_PIXEL_FORMAT_RGBA_8888 &&
        format <= HAL_PIXEL_FORMAT_BGRA_8888) {
        ALOGW("%s: Camera %d: Overriding format 0x%x to IMPLEMENTATION_DEFINED",
              __FUNCTION__, mCameraId, format);
        format = HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED;
 }


 int streamId = -1;
 if (format == HAL_PIXEL_FORMAT_BLOB) {
 CameraMetadata staticInfo = mDevice->info();
 camera_metadata_entry_t entry = staticInfo.find(ANDROID_JPEG_MAX_SIZE);
 if (entry.count == 0) {
            ALOGE("%s: Camera %d: Can't find maximum JPEG size in "
 "static metadata!", __FUNCTION__, mCameraId);
 return INVALID_OPERATION;
 }
 int32_t maxJpegSize = entry.data.i32[0];
        res = mDevice->createStream(anw, width, height, format, maxJpegSize,
 &streamId);
 } else {
        res = mDevice->createStream(anw, width, height, format, /*size*/0,
 &streamId);
 }

 if (res == OK) {
        mStreamMap.add(bufferProducer->asBinder(), streamId);

        ALOGV("%s: Camera %d: Successfully created a new stream ID %d",
              __FUNCTION__, mCameraId, streamId);

 /**
         * Set the stream transform flags to automatically
         * rotate the camera stream for preview use cases.
         */
 int32_t transform = 0;
        res = getRotationTransformLocked(&transform);

 if (res != OK) {
 return res;
 }

        res = mDevice->setStreamTransform(streamId, transform);
 if (res != OK) {
            ALOGE("%s: Failed to set stream transform (stream id %d)",
                  __FUNCTION__, streamId);
 return res;
 }

 return streamId;
 }

 return res;
}

status_t ProCamera2Client::exclusiveTryLock() {
    ATRACE_CALL();
    ALOGV("%s", __FUNCTION__);

 Mutex::Autolock icl(mBinderSerializationLock);
 SharedCameraCallbacks::Lock l(mSharedCameraCallbacks);

 if (!mDevice.get()) return PERMISSION_DENIED;

 if (!mExclusiveLock) {
        mExclusiveLock = true;

 if (mRemoteCallback != NULL) {
            mRemoteCallback->onLockStatusChanged(
 IProCameraCallbacks::LOCK_ACQUIRED);
 }

        ALOGV("%s: exclusive lock acquired", __FUNCTION__);

 return OK;
 }


    ALOGW("%s: exclusive lock already exists - recursive locking is not"
 "allowed", __FUNCTION__);

 return ALREADY_EXISTS;
}

int Camera2Client::getPreviewStreamId() const {
 return mStreamingProcessor->getPreviewStreamId();
}

status_t Camera2Client::startRecording() {
    ATRACE_CALL();
    ALOGV("%s: E", __FUNCTION__);
 Mutex::Autolock icl(mBinderSerializationLock);
 status_t res;
 if ( (res = checkPid(__FUNCTION__) ) != OK) return res;
 SharedParameters::Lock l(mParameters);

 return startRecordingL(l.mParameters, false);
}

status_t CameraService::dump(int fd, const Vector<String16>& args) {
String8 result;
if (checkCallingPermission(String16("android.permission.DUMP")) == false) {
result.appendFormat("Permission Denial: "
"can't dump CameraService from pid=%d, uid=%d\n",
getCallingPid(),
getCallingUid());
write(fd, result.string(), result.size());
} else {
bool locked = tryLock(mServiceLock);
// failed to lock - CameraService is probably deadlocked
if (!locked) {
result.append("CameraService may be deadlocked\n");
write(fd, result.string(), result.size());
}

bool hasClient = false;
if (!mModule) {
result = String8::format("No camera module available!\n");
write(fd, result.string(), result.size());
return NO_ERROR;
}

result = String8::format("Camera module HAL API version: 0x%x\n",
mModule->common.hal_api_version);
result.appendFormat("Camera module API version: 0x%x\n",
mModule->common.module_api_version);
result.appendFormat("Camera module name: %s\n",
mModule->common.name);
result.appendFormat("Camera module author: %s\n",
mModule->common.author);
result.appendFormat("Number of camera devices: %d\n\n", mNumberOfCameras);
write(fd, result.string(), result.size());
for (int i = 0; i < mNumberOfCameras; i++) {
result = String8::format("Camera %d static information:\n", i);
camera_info info;

status_t rc = mModule->get_camera_info(i, &info);
if (rc != OK) {
result.appendFormat("  Error reading static information!\n");
write(fd, result.string(), result.size());
} else {
result.appendFormat("  Facing: %s\n",
info.facing == CAMERA_FACING_BACK ? "BACK" : "FRONT");
result.appendFormat("  Orientation: %d\n", info.orientation);
int deviceVersion;
if (mModule->common.module_api_version <
CAMERA_MODULE_API_VERSION_2_0) {
deviceVersion = CAMERA_DEVICE_API_VERSION_1_0;
} else {
deviceVersion = info.device_version;
}
result.appendFormat("  Device version: 0x%x\n", deviceVersion);
if (deviceVersion >= CAMERA_DEVICE_API_VERSION_2_0) {
result.appendFormat("  Device static metadata:\n");
write(fd, result.string(), result.size());
dump_indented_camera_metadata(info.static_camera_characteristics,
fd, 2, 4);
} else {
write(fd, result.string(), result.size());
}
}

sp<BasicClient> client = mClient[i].promote();
if (client == 0) {
result = String8::format("  Device is closed, no client instance\n");
write(fd, result.string(), result.size());
continue;
}

hasClient = true;
result = String8::format("  Device is open. Client instance dump:\n");
write(fd, result.string(), result.size());
            client->dump(fd, args);
}
if (!hasClient) {
result = String8::format("\nNo active camera clients yet.\n");
write(fd, result.string(), result.size());
}

if (locked) mServiceLock.unlock();

// Dump camera traces if there were any
write(fd, "\n", 1);
camera3::CameraTraces::dump(fd, args);

// change logging level
int n = args.size();
for (int i = 0; i + 1 < n; i++) {
String16 verboseOption("-v");
if (args[i] == verboseOption) {
String8 levelStr(args[i+1]);
int level = atoi(levelStr.string());
result = String8::format("\nSetting log level to %d.\n", level);
setLogLevel(level);
write(fd, result.string(), result.size());
}
}

}
return NO_ERROR;
}

void Camera2Client::releaseRecordingFrame(const sp<IMemory>& mem) {
    ATRACE_CALL();
 Mutex::Autolock icl(mBinderSerializationLock);
 if ( checkPid(__FUNCTION__) != OK) return;

    mStreamingProcessor->releaseRecordingFrame(mem);
}

status_t Camera2Client::commandSetVideoBufferCountL(size_t count) {
 if (recordingEnabledL()) {
        ALOGE("%s: Camera %d: Error setting video buffer count after "
 "recording was started", __FUNCTION__, mCameraId);
 return INVALID_OPERATION;
 }

 return mStreamingProcessor->setRecordingBufferCount(count);
}

status_t Camera2Client::commandPingL() {
 SharedParameters::Lock l(mParameters);
 if (l.mParameters.state != Parameters::DISCONNECTED) {
 return OK;
 } else {
 return NO_INIT;
 }
}

bool Camera2Client::previewEnabled() {
    ATRACE_CALL();
 Mutex::Autolock icl(mBinderSerializationLock);
 status_t res;
 if ( (res = checkPid(__FUNCTION__) ) != OK) return false;

 SharedParameters::Lock l(mParameters);
 return l.mParameters.state == Parameters::PREVIEW;
}

status_t Camera2Client::commandStartFaceDetectionL(int /*type*/) {
    ALOGV("%s: Camera %d: Starting face detection",
          __FUNCTION__, mCameraId);
 status_t res;
 SharedParameters::Lock l(mParameters);
 switch (l.mParameters.state) {
 case Parameters::DISCONNECTED:
 case Parameters::STOPPED:
 case Parameters::WAITING_FOR_PREVIEW_WINDOW:
 case Parameters::STILL_CAPTURE:
            ALOGE("%s: Camera %d: Cannot start face detection without preview active",
                    __FUNCTION__, mCameraId);
 return INVALID_OPERATION;
 case Parameters::PREVIEW:
 case Parameters::RECORD:
 case Parameters::VIDEO_SNAPSHOT:
 break;
 }
 if (l.mParameters.fastInfo.bestFaceDetectMode ==
            ANDROID_STATISTICS_FACE_DETECT_MODE_OFF) {
        ALOGE("%s: Camera %d: Face detection not supported",
                __FUNCTION__, mCameraId);
 return BAD_VALUE;
 }
 if (l.mParameters.enableFaceDetect) return OK;

    l.mParameters.enableFaceDetect = true;

    res = updateRequests(l.mParameters);

 return res;
}

status_t CameraService::addListener(
 const sp<ICameraServiceListener>& listener) {
    ALOGV("%s: Add listener %p", __FUNCTION__, listener.get());

 if (listener == 0) {
        ALOGE("%s: Listener must not be null", __FUNCTION__);
 return BAD_VALUE;
 }

 Mutex::Autolock lock(mServiceLock);

 Vector<sp<ICameraServiceListener> >::iterator it, end;
 for (it = mListenerList.begin(); it != mListenerList.end(); ++it) {
 if ((*it)->asBinder() == listener->asBinder()) {
            ALOGW("%s: Tried to add listener %p which was already subscribed",
                  __FUNCTION__, listener.get());
 return ALREADY_EXISTS;
 }
 }

    mListenerList.push_back(listener);

 /* Immediately signal current status to this listener only */
 {
 Mutex::Autolock m(mStatusMutex) ;
 int numCams = getNumberOfCameras();
 for (int i = 0; i < numCams; ++i) {
            listener->onStatusChanged(mStatusList[i], i);
 }
 }

 return OK;
}

void CameraService::releaseSound() {
 Mutex::Autolock lock(mSoundLock);
    LOG1("CameraService::releaseSound ref=%d", mSoundRef);
 if (--mSoundRef) return;

 for (int i = 0; i < NUM_SOUNDS; i++) {
 if (mSoundPlayer[i] != 0) {
            mSoundPlayer[i]->disconnect();
            mSoundPlayer[i].clear();
 }
 }
}

MediaPlayer* CameraService::newMediaPlayer(const char *file) {
 MediaPlayer* mp = new MediaPlayer();
 if (mp->setDataSource(file, NULL) == NO_ERROR) {
        mp->setAudioStreamType(AUDIO_STREAM_ENFORCED_AUDIBLE);
        mp->prepare();
 } else {
        ALOGE("Failed to load CameraService sounds: %s", file);
 return NULL;
 }
 return mp;
}

status_t Camera2Client::autoFocus() {
    ATRACE_CALL();
 Mutex::Autolock icl(mBinderSerializationLock);
    ALOGV("%s: Camera %d", __FUNCTION__, mCameraId);
 status_t res;
 if ( (res = checkPid(__FUNCTION__) ) != OK) return res;

 int triggerId;
 bool notifyImmediately = false;
 bool notifySuccess = false;
 {
 SharedParameters::Lock l(mParameters);
 if (l.mParameters.state < Parameters::PREVIEW) {
 return INVALID_OPERATION;
 }

 /**
          * If the camera does not support auto-focus, it is a no-op and
          * onAutoFocus(boolean, Camera) callback will be called immediately
          * with a fake value of success set to true.
          *
          * Similarly, if focus mode is set to INFINITY, there's no reason to
          * bother the HAL.
          */
 if (l.mParameters.focusMode == Parameters::FOCUS_MODE_FIXED ||
                l.mParameters.focusMode == Parameters::FOCUS_MODE_INFINITY) {
            notifyImmediately = true;
            notifySuccess = true;
 }
 /**
         * If we're in CAF mode, and AF has already been locked, just fire back
         * the callback right away; the HAL would not send a notification since
         * no state change would happen on a AF trigger.
         */
 if ( (l.mParameters.focusMode == Parameters::FOCUS_MODE_CONTINUOUS_PICTURE ||
                l.mParameters.focusMode == Parameters::FOCUS_MODE_CONTINUOUS_VIDEO) &&
                l.mParameters.focusState == ANDROID_CONTROL_AF_STATE_FOCUSED_LOCKED ) {
            notifyImmediately = true;
            notifySuccess = true;
 }
 /**
         * Send immediate notification back to client
         */
 if (notifyImmediately) {
 SharedCameraCallbacks::Lock l(mSharedCameraCallbacks);
 if (l.mRemoteCallback != 0) {
                l.mRemoteCallback->notifyCallback(CAMERA_MSG_FOCUS,
                        notifySuccess ? 1 : 0, 0);
 }
 return OK;
 }
 /**
         * Handle quirk mode for AF in scene modes
         */
 if (l.mParameters.quirks.triggerAfWithAuto &&
                l.mParameters.sceneMode != ANDROID_CONTROL_SCENE_MODE_UNSUPPORTED &&
                l.mParameters.focusMode != Parameters::FOCUS_MODE_AUTO &&
 !l.mParameters.focusingAreas[0].isEmpty()) {
            ALOGV("%s: Quirk: Switching from focusMode %d to AUTO",
                    __FUNCTION__, l.mParameters.focusMode);
            l.mParameters.shadowFocusMode = l.mParameters.focusMode;
            l.mParameters.focusMode = Parameters::FOCUS_MODE_AUTO;
            updateRequests(l.mParameters);
 }

        l.mParameters.currentAfTriggerId = ++l.mParameters.afTriggerCounter;
        triggerId = l.mParameters.currentAfTriggerId;
 }
    ATRACE_ASYNC_BEGIN(kAutofocusLabel, triggerId);

    syncWithDevice();

    mDevice->triggerAutofocus(triggerId);

 return OK;
}

status_t CameraClient::setPreviewCallbackTarget(
 const sp<IGraphicBufferProducer>& callbackProducer) {
 (void)callbackProducer;
    ALOGE("%s: Unimplemented!", __FUNCTION__);
 return INVALID_OPERATION;
}

void ProCamera2Client::detachDevice() {
 if (mDevice == 0) return;

    ALOGV("Camera %d: Stopping processors", mCameraId);

    mFrameProcessor->removeListener(FRAME_PROCESSOR_LISTENER_MIN_ID,
                                    FRAME_PROCESSOR_LISTENER_MAX_ID,
 /*listener*/this);
    mFrameProcessor->requestExit();
    ALOGV("Camera %d: Waiting for threads", mCameraId);
    mFrameProcessor->join();
    ALOGV("Camera %d: Disconnecting device", mCameraId);

 {
        mDevice->clearStreamingRequest();

 status_t code;
 if ((code = mDevice->waitUntilDrained()) != OK) {
            ALOGE("%s: waitUntilDrained failed with code 0x%x", __FUNCTION__,
                  code);
 }
 }

 Camera2ClientBase::detachDevice();
}

void CameraDeviceClient::onFrameAvailable(int32_t requestId,
 const CameraMetadata& frame) {
    ATRACE_CALL();
    ALOGV("%s", __FUNCTION__);

    sp<ICameraDeviceCallbacks> remoteCb = mRemoteCallback;
 if (remoteCb != NULL) {
        ALOGV("%s: frame = %p ", __FUNCTION__, &frame);
        remoteCb->onResultReceived(requestId, frame);
 }
}

CameraService::ProClient::ProClient(const sp<CameraService>& cameraService,
 const sp<IProCameraCallbacks>& remoteCallback,
 const String16& clientPackageName,
 int cameraId,
 int cameraFacing,
 int clientPid,
 uid_t clientUid,
 int servicePid)
 : CameraService::BasicClient(cameraService, remoteCallback->asBinder(),
                clientPackageName, cameraId, cameraFacing,
                clientPid,  clientUid, servicePid)
{
    mRemoteCallback = remoteCallback;
}

void CameraClient::handlePostview(const sp<IMemory>& mem) {
    disableMsgType(CAMERA_MSG_POSTVIEW_FRAME);

    sp<ICameraClient> c = mRemoteCallback;
    mLock.unlock();
 if (c != 0) {
        c->dataCallback(CAMERA_MSG_POSTVIEW_FRAME, mem, NULL);
 }
}

void Camera2Client::notifyAutoFocus(uint8_t newState, int triggerId) {
    ALOGV("%s: Autofocus state now %d, last trigger %d",
            __FUNCTION__, newState, triggerId);
 bool sendCompletedMessage = false;
 bool sendMovingMessage = false;

 bool success = false;
 bool afInMotion = false;
 {
 SharedParameters::Lock l(mParameters);
 char tmp[32];
 if (l.mParameters.afStateCounter > 0) {
            camera_metadata_enum_snprint(
                ANDROID_CONTROL_AF_STATE, l.mParameters.focusState, tmp, sizeof(tmp));
            ATRACE_ASYNC_END(tmp, l.mParameters.afStateCounter);
 }

        l.mParameters.focusState = newState;
        l.mParameters.afStateCounter++;


        camera_metadata_enum_snprint(
            ANDROID_CONTROL_AF_STATE, l.mParameters.focusState, tmp, sizeof(tmp));
        ATRACE_ASYNC_BEGIN(tmp, l.mParameters.afStateCounter);

 switch (l.mParameters.focusMode) {
 case Parameters::FOCUS_MODE_AUTO:
 case Parameters::FOCUS_MODE_MACRO:
 if (triggerId != l.mParameters.currentAfTriggerId) break;
 switch (newState) {
 case ANDROID_CONTROL_AF_STATE_FOCUSED_LOCKED:
                        success = true;
 case ANDROID_CONTROL_AF_STATE_NOT_FOCUSED_LOCKED:
                        sendCompletedMessage = true;
                        l.mParameters.currentAfTriggerId = -1;
 break;
 case ANDROID_CONTROL_AF_STATE_ACTIVE_SCAN:
 break;
 case ANDROID_CONTROL_AF_STATE_INACTIVE:
 case ANDROID_CONTROL_AF_STATE_PASSIVE_SCAN:
 case ANDROID_CONTROL_AF_STATE_PASSIVE_FOCUSED:
 case ANDROID_CONTROL_AF_STATE_PASSIVE_UNFOCUSED:
 default:
                        ALOGE("%s: Unexpected AF state transition in AUTO/MACRO mode: %d",
                                __FUNCTION__, newState);
 break;
 }
 break;
 case Parameters::FOCUS_MODE_CONTINUOUS_VIDEO:
 case Parameters::FOCUS_MODE_CONTINUOUS_PICTURE:
 switch (newState) {
 case ANDROID_CONTROL_AF_STATE_FOCUSED_LOCKED:
                        success = true;
 case ANDROID_CONTROL_AF_STATE_NOT_FOCUSED_LOCKED:
 if (triggerId != l.mParameters.currentAfTriggerId) break;
                        sendCompletedMessage = true;
                        afInMotion = false;
 if (l.mParameters.enableFocusMoveMessages &&
                                l.mParameters.afInMotion) {
                            sendMovingMessage = true;
 }
                        l.mParameters.currentAfTriggerId = -1;
 break;
 case ANDROID_CONTROL_AF_STATE_INACTIVE:
                        afInMotion = false;
 if (l.mParameters.enableFocusMoveMessages &&
                                l.mParameters.afInMotion) {
                            sendMovingMessage = true;
 }
 break;
 case ANDROID_CONTROL_AF_STATE_PASSIVE_SCAN:
                        afInMotion = true;
 case ANDROID_CONTROL_AF_STATE_PASSIVE_FOCUSED:
 case ANDROID_CONTROL_AF_STATE_PASSIVE_UNFOCUSED:
 if (l.mParameters.enableFocusMoveMessages) {
                            sendMovingMessage = true;
 }
 break;
 }
                l.mParameters.afInMotion = afInMotion;
 break;
 case Parameters::FOCUS_MODE_EDOF:
 case Parameters::FOCUS_MODE_INFINITY:
 case Parameters::FOCUS_MODE_FIXED:
 default:
 if (newState != ANDROID_CONTROL_AF_STATE_INACTIVE) {
                    ALOGE("%s: Unexpected AF state change %d "
 "(ID %d) in focus mode %d",
                          __FUNCTION__, newState, triggerId,
                            l.mParameters.focusMode);
 }
 }
 }
 if (sendMovingMessage) {
 SharedCameraCallbacks::Lock l(mSharedCameraCallbacks);
 if (l.mRemoteCallback != 0) {
            l.mRemoteCallback->notifyCallback(CAMERA_MSG_FOCUS_MOVE,
                    afInMotion ? 1 : 0, 0);
 }
 }
 if (sendCompletedMessage) {
        ATRACE_ASYNC_END(kAutofocusLabel, triggerId);
 SharedCameraCallbacks::Lock l(mSharedCameraCallbacks);
 if (l.mRemoteCallback != 0) {
            l.mRemoteCallback->notifyCallback(CAMERA_MSG_FOCUS,
                    success ? 1 : 0, 0);
 }
 }
}

bool Camera2Client::recordingEnabled() {
    ATRACE_CALL();
 Mutex::Autolock icl(mBinderSerializationLock);

 if ( checkPid(__FUNCTION__) != OK) return false;

 return recordingEnabledL();
}

 status_t CameraClient::dump(int fd, const Vector<String16>& args) {
     const size_t SIZE = 256;
     char buffer[SIZE];
 
 size_t len = snprintf(buffer, SIZE, "Client[%d] (%p) PID: %d\n",
            mCameraId,
            getRemoteCallback()->asBinder().get(),
            mClientPid);
    len = (len > SIZE - 1) ? SIZE - 1 : len;
    write(fd, buffer, len);
 return mHardware->dump(fd, args);
}

void CameraService::loadSound() {
 Mutex::Autolock lock(mSoundLock);
    LOG1("CameraService::loadSound ref=%d", mSoundRef);
 if (mSoundRef++) return;

    mSoundPlayer[SOUND_SHUTTER] = newMediaPlayer("/system/media/audio/ui/camera_click.ogg");
    mSoundPlayer[SOUND_RECORDING] = newMediaPlayer("/system/media/audio/ui/VideoRecord.ogg");
}

status_t Camera2Client::commandStopSmoothZoomL() {
    ALOGE("%s: Unimplemented!", __FUNCTION__);
 return OK;
}

status_t CameraService::validateConnect(int cameraId,
 /*inout*/
 int& clientUid) const {

 int callingPid = getCallingPid();

 if (clientUid == USE_CALLING_UID) {
        clientUid = getCallingUid();
 } else {
 if (callingPid != getpid()) {
            ALOGE("CameraService::connect X (pid %d) rejected (don't trust clientUid)",
                    callingPid);
 return PERMISSION_DENIED;
 }
 }

 if (!mModule) {
        ALOGE("Camera HAL module not loaded");
 return -ENODEV;
 }

 if (cameraId < 0 || cameraId >= mNumberOfCameras) {
        ALOGE("CameraService::connect X (pid %d) rejected (invalid cameraId %d).",
            callingPid, cameraId);
 return -ENODEV;
 }

 char value[PROPERTY_VALUE_MAX];
    property_get("sys.secpolicy.camera.disabled", value, "0");
 if (strcmp(value, "1") == 0) {
        ALOGI("Camera is disabled. connect X (pid %d) rejected", callingPid);
 return -EACCES;
 }

 ICameraServiceListener::Status currentStatus = getStatus(cameraId);
 if (currentStatus == ICameraServiceListener::STATUS_NOT_PRESENT) {
        ALOGI("Camera is not plugged in,"
 " connect X (pid %d) rejected", callingPid);
 return -ENODEV;
 } else if (currentStatus == ICameraServiceListener::STATUS_ENUMERATING) {
        ALOGI("Camera is enumerating,"
 " connect X (pid %d) rejected", callingPid);
 return -EBUSY;
 }

 return OK;
}

ICameraServiceListener::Status CameraService::getStatus(int cameraId) const {
 if (cameraId < 0 || cameraId >= MAX_CAMERAS) {
        ALOGE("%s: Invalid camera ID %d", __FUNCTION__, cameraId);
 return ICameraServiceListener::STATUS_UNKNOWN;
 }

 Mutex::Autolock al(mStatusMutex);
 return mStatusList[cameraId];
}

status_t CameraClient::setParameters(const String8& params) {
    LOG1("setParameters (pid %d) (%s)", getCallingPid(), params.string());

 Mutex::Autolock lock(mLock);
 status_t result = checkPidAndHardware();
 if (result != NO_ERROR) return result;

 CameraParameters p(params);
 return mHardware->setParameters(p);
}

CameraDeviceClient::~CameraDeviceClient() {
}

status_t ProCamera2Client::createStream(int width, int height, int format,
 const sp<IGraphicBufferProducer>& bufferProducer,
 /*out*/
 int* streamId)
{
 if (streamId) {
 *streamId = -1;
 }

    ATRACE_CALL();
    ALOGV("%s (w = %d, h = %d, f = 0x%x)", __FUNCTION__, width, height, format);

 status_t res;
 if ( (res = checkPid(__FUNCTION__) ) != OK) return res;

 Mutex::Autolock icl(mBinderSerializationLock);

 if (!mDevice.get()) return DEAD_OBJECT;

    sp<IBinder> binder;
    sp<ANativeWindow> window;
 if (bufferProducer != 0) {
        binder = bufferProducer->asBinder();
        window = new Surface(bufferProducer);
 }

 return mDevice->createStream(window, width, height, format, /*size*/1,
                                 streamId);
}

status_t CameraDeviceClient::deleteStream(int streamId) {
    ATRACE_CALL();
    ALOGV("%s (streamId = 0x%x)", __FUNCTION__, streamId);

 status_t res;
 if ( (res = checkPid(__FUNCTION__) ) != OK) return res;

 Mutex::Autolock icl(mBinderSerializationLock);

 if (!mDevice.get()) return DEAD_OBJECT;

 ssize_t index = NAME_NOT_FOUND;
 for (size_t i = 0; i < mStreamMap.size(); ++i) {
 if (streamId == mStreamMap.valueAt(i)) {
            index = i;
 break;
 }
 }

 if (index == NAME_NOT_FOUND) {
        ALOGW("%s: Camera %d: Invalid stream ID (%d) specified, no stream "
 "created yet", __FUNCTION__, mCameraId, streamId);
 return BAD_VALUE;
 }

    res = mDevice->deleteStream(streamId);

 if (res == BAD_VALUE) {
        ALOGE("%s: Camera %d: Unexpected BAD_VALUE when deleting stream, but we"
 " already checked and the stream ID (%d) should be valid.",
              __FUNCTION__, mCameraId, streamId);
 } else if (res == OK) {
        mStreamMap.removeItemsAt(index);

        ALOGV("%s: Camera %d: Successfully deleted stream ID (%d)",
              __FUNCTION__, mCameraId, streamId);
 }

 return res;
}

bool CameraClient::recordingEnabled() {
    LOG1("recordingEnabled (pid %d)", getCallingPid());

 Mutex::Autolock lock(mLock);
 if (checkPidAndHardware() != NO_ERROR) return false;
 return mHardware->recordingEnabled();
}
