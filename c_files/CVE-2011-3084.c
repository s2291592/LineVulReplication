  TabContentsTestBrowserClient() {
  }

int ConvertMockKeyboardModifier(MockKeyboard::Modifiers modifiers) {
  static struct ModifierMap {
    MockKeyboard::Modifiers src;
    int dst;
  } kModifierMap[] = {
    { MockKeyboard::LEFT_SHIFT, ui::EF_SHIFT_DOWN },
    { MockKeyboard::RIGHT_SHIFT, ui::EF_SHIFT_DOWN },
    { MockKeyboard::LEFT_CONTROL, ui::EF_CONTROL_DOWN },
    { MockKeyboard::RIGHT_CONTROL, ui::EF_CONTROL_DOWN },
    { MockKeyboard::LEFT_ALT,  ui::EF_ALT_DOWN },
    { MockKeyboard::RIGHT_ALT, ui::EF_ALT_DOWN },
  };
  int flags = 0;
  for (size_t i = 0; i < ARRAYSIZE_UNSAFE(kModifierMap); ++i) {
    if (kModifierMap[i].src & modifiers) {
      flags |= kModifierMap[i].dst;
    }
  }
  return flags;
}

bool ChromeContentRendererClient::ShouldFork(WebFrame* frame,
const GURL& url,
bool is_initial_navigation,
bool* send_referrer) {
DCHECK(!frame->parent());

// If |url| matches one of the prerendered URLs, stop this navigation and try
// to swap in the prerendered page on the browser process. If the prerendered
// page no longer exists by the time the OpenURL IPC is handled, a normal
// navigation is attempted.
if (prerender_dispatcher_.get() && prerender_dispatcher_->IsPrerenderURL(url))
return true;

const ExtensionSet* extensions = extension_dispatcher_->extensions();

// Determine if the new URL is an extension (excluding bookmark apps).
const Extension* new_url_extension = extensions::GetNonBookmarkAppExtension(
*extensions, ExtensionURLInfo(url));
bool is_extension_url = !!new_url_extension;

// If the navigation would cross an app extent boundary, we also need
// to defer to the browser to ensure process isolation.
// TODO(erikkay) This is happening inside of a check to is_content_initiated
// which means that things like the back button won't trigger it.  Is that
// OK?
if (CrossesExtensionExtents(frame, url, *extensions, is_extension_url,
is_initial_navigation)) {
// Include the referrer in this case since we're going from a hosted web
// page. (the packaged case is handled previously by the extension
// navigation test)
*send_referrer = true;

const Extension* extension =
extension_dispatcher_->extensions()->GetExtensionOrAppByURL(
ExtensionURLInfo(url));
if (extension && extension->is_app()) {
UMA_HISTOGRAM_ENUMERATION(
extension_misc::kAppLaunchHistogram,
extension_misc::APP_LAUNCH_CONTENT_NAVIGATION,
extension_misc::APP_LAUNCH_BUCKET_BOUNDARY);
}
return true;
}

// If this is a reload, check whether it has the wrong process type.  We
// should send it to the browser if it's an extension URL (e.g., hosted app)
// in a normal process, or if it's a process for an extension that has been
// uninstalled.
if (frame->top()->document().url() == url) {
if (is_extension_url != extension_dispatcher_->is_extension_process())
return true;
}

  // Navigating to a new chrome:// scheme (in a new tab) from within a
  // chrome:// page must be a browser navigation so that the browser can
  // register the new associated data source.
  if (url.SchemeIs(kChromeUIScheme))
    return true;
return false;
}

bool RenderViewImpl::runModalPromptDialog(WebFrame* frame,
                                          const WebString& message,
                                          const WebString& default_value,
                                          WebString* actual_value) {
  string16 result;
  bool ok = RunJavaScriptMessage(ui::JAVASCRIPT_MESSAGE_TYPE_PROMPT,
                                 message,
                                 default_value,
                                 frame->document().url(),
                                 &result);
  if (ok)
    actual_value->assign(result);
  return ok;
}

int64 MockRenderThread::GetIdleNotificationDelayInMs() const {
  return 0;
}

  void WaitForIOThreadCompletion() {
    ChildProcess::current()->io_message_loop()->PostTask(
        FROM_HERE, base::Bind(&WaitCallback, base::Unretained(event_.get())));
    EXPECT_TRUE(event_->TimedWait(
        base::TimeDelta::FromMilliseconds(TestTimeouts::action_timeout_ms())));
  }

bool WebRTCAudioDeviceTest::Send(IPC::Message* message) {
  return channel_->Send(message);
}

  virtual ~RenderViewHostManagerTestBrowserClient() {}

uint32 RenderViewTest::GetNavigationIPCType() {
  return ViewHostMsg_FrameNavigate::ID;
}

base::SharedMemoryHandle MockRenderThread::HostAllocateSharedMemoryBuffer(
    uint32 buffer_size) {
  base::SharedMemory shared_buf;
  if (!shared_buf.CreateAndMapAnonymous(buffer_size)) {
    NOTREACHED() << "Cannot map shared memory buffer";
    return base::SharedMemory::NULLHandle();
  }
  base::SharedMemoryHandle handle;
  shared_buf.GiveToProcess(base::GetCurrentProcessHandle(), &handle);
  return handle;
}

void RenderViewImpl::enterFullscreen() {
  enterFullScreen();
}

   void set_privileged_process_id(int process_id) {
    browser_client_.set_privileged_process_id(process_id);
  }

base::StringPiece TestContentClient::GetDataResource(int resource_id) const {
  base::StringPiece resource;
  data_pack_.GetStringPiece(resource_id, &resource);
  return resource;
}

skia::PlatformCanvas* MockRenderProcess::GetDrawingCanvas(
    TransportDIB** memory,
    const gfx::Rect& rect) {
  size_t stride = skia::PlatformCanvas::StrideForWidth(rect.width());
  size_t size = stride * rect.height();

  *memory = TransportDIB::Create(size, transport_dib_next_sequence_number_++);
  if (!*memory)
    return NULL;
  return (*memory)->GetPlatformCanvas(rect.width(), rect.height());
}

void RenderProcessImpl::FreeTransportDIB(TransportDIB* dib) {
  if (!dib)
    return;

#if defined(OS_MACOSX)
  IPC::Message* msg = new ViewHostMsg_FreeTransportDIB(dib->id());
  main_thread()->Send(msg);
#endif

  delete dib;
}

DebuggerFunction::DebuggerFunction()
    : contents_(0),
      tab_id_(0),
      client_host_(0) {
}

RenderViewImpl::RenderViewImpl(
    gfx::NativeViewId parent_hwnd,
    int32 opener_id,
    const content::RendererPreferences& renderer_prefs,
    const WebPreferences& webkit_prefs,
    SharedRenderViewCounter* counter,
    int32 routing_id,
    int32 surface_id,
    int64 session_storage_namespace_id,
    const string16& frame_name,
    int32 next_page_id,
    const WebKit::WebScreenInfo& screen_info)
    : RenderWidget(WebKit::WebPopupTypeNone, screen_info),
      webkit_preferences_(webkit_prefs),
      send_content_state_immediately_(false),
      enabled_bindings_(0),
      send_preferred_size_changes_(false),
      is_loading_(false),
      navigation_gesture_(NavigationGestureUnknown),
      opened_by_user_gesture_(true),
      opener_suppressed_(false),
      page_id_(-1),
      last_page_id_sent_to_browser_(-1),
      next_page_id_(next_page_id),
      history_list_offset_(-1),
      history_list_length_(0),
      target_url_status_(TARGET_NONE),
      selection_text_offset_(0),
      cached_is_main_frame_pinned_to_left_(false),
      cached_is_main_frame_pinned_to_right_(false),
      cached_has_main_frame_horizontal_scrollbar_(false),
      cached_has_main_frame_vertical_scrollbar_(false),
      context_has_swapbuffers_complete_callback_(false),
      queried_for_swapbuffers_complete_callback_(false),
      context_is_web_graphics_context_3d_command_buffer_impl_(false),
      ALLOW_THIS_IN_INITIALIZER_LIST(cookie_jar_(this)),
      geolocation_dispatcher_(NULL),
      input_tag_speech_dispatcher_(NULL),
      device_orientation_dispatcher_(NULL),
      media_stream_dispatcher_(NULL),
      p2p_socket_dispatcher_(NULL),
      devtools_agent_(NULL),
      renderer_accessibility_(NULL),
      mouse_lock_dispatcher_(NULL),
      session_storage_namespace_id_(session_storage_namespace_id),
      handling_select_range_(false),
#if defined(OS_WIN)
      focused_plugin_id_(-1),
#endif
      ALLOW_THIS_IN_INITIALIZER_LIST(pepper_delegate_(this)) {
  routing_id_ = routing_id;
  surface_id_ = surface_id;
  if (opener_id != MSG_ROUTING_NONE)
    opener_id_ = opener_id;

  DCHECK_GE(next_page_id_, 0);

#if defined(ENABLE_NOTIFICATIONS)
  notification_provider_ = new NotificationProvider(this);
#else
  notification_provider_ = NULL;
#endif

  webwidget_ = WebView::create(this);
  webwidget_mouse_lock_target_.reset(new WebWidgetLockTarget(webwidget_));

  if (counter) {
    shared_popup_counter_ = counter;
    shared_popup_counter_->data++;
    decrement_shared_popup_at_destruction_ = true;
  } else {
    shared_popup_counter_ = new SharedRenderViewCounter(0);
    decrement_shared_popup_at_destruction_ = false;
  }

  RenderThread::Get()->AddRoute(routing_id_, this);
  AddRef();

  if (opener_id == MSG_ROUTING_NONE) {
    did_show_ = true;
    CompleteInit(parent_hwnd);
  }

  g_view_map.Get().insert(std::make_pair(webview(), this));
  webkit_preferences_.Apply(webview());
  webview()->initializeMainFrame(this);
  if (!frame_name.empty())
    webview()->mainFrame()->setName(frame_name);
  webview()->settings()->setMinimumTimerInterval(
      is_hidden() ? webkit_glue::kBackgroundTabTimerInterval :
          webkit_glue::kForegroundTabTimerInterval);

  OnSetRendererPrefs(renderer_prefs);

  host_window_ = parent_hwnd;

#if defined(ENABLE_P2P_APIS)
  if (!p2p_socket_dispatcher_)
    p2p_socket_dispatcher_ = new content::P2PSocketDispatcher(this);
#endif

#if defined(ENABLE_WEBRTC)
  if (!media_stream_dispatcher_)
    media_stream_dispatcher_ = new MediaStreamDispatcher(this);
#endif

  new MHTMLGenerator(this);
#if defined(OS_MACOSX)
  new TextInputClientObserver(this);
#endif  // defined(OS_MACOSX)

  devtools_agent_ = new DevToolsAgent(this);
  renderer_accessibility_ = new RendererAccessibility(this);
  mouse_lock_dispatcher_ = new MouseLockDispatcher(this);
  intents_host_ = new WebIntentsHost(this);

  new IdleUserDetector(this);

  const CommandLine& command_line = *CommandLine::ForCurrentProcess();
  if (command_line.HasSwitch(switches::kDomAutomationController))
    enabled_bindings_ |= content::BINDINGS_POLICY_DOM_AUTOMATION;

  bool enable_fixed_layout =
      command_line.HasSwitch(switches::kEnableFixedLayout);
  webview()->enableFixedLayoutMode(enable_fixed_layout);
  if (enable_fixed_layout)
      webview()->settings()->setFixedElementsLayoutRelativeToFrame(true);

  content::GetContentClient()->renderer()->RenderViewCreated(this);
}

void RenderViewImpl::dispatchIntent(
    WebFrame* frame, const WebIntentRequest& intentRequest) {
  webkit_glue::WebIntentData intent_data(intentRequest.intent());
  int id = intents_host_->RegisterWebIntent(intentRequest);
  Send(new IntentsHostMsg_WebIntentDispatch(
      routing_id_, intent_data, id));
}

void MockRenderThread::IdleHandler() {
}

void TestContentClient::SetActiveURL(const GURL& url) {
}

void MockRenderThread::ScheduleIdleHandler(int64 initial_delay_ms) {
}

void RenderViewImpl::PlayerGone(webkit_media::WebMediaPlayerImpl* player) {
  DidPause(player);
}

void RenderViewImpl::OnGetAllSavableResourceLinksForCurrentPage(
    const GURL& page_url) {
  std::vector<GURL> resources_list;
  std::vector<GURL> referrers_list;
  std::vector<GURL> frames_list;
  webkit_glue::SavableResourcesResult result(&resources_list,
                                             &referrers_list,
                                             &frames_list);

  if (!webkit_glue::GetAllSavableResourceLinksForCurrentPage(
          webview(),
          page_url,
          &result,
          content::GetSavableSchemes())) {
    referrers_list.clear();
    resources_list.clear();
    frames_list.clear();
  }

  Send(new ViewHostMsg_SendCurrentPageAllSavableResourceLinks(routing_id(),
                                                              resources_list,
                                                              referrers_list,
                                                              frames_list));
}

void MockRenderThread::OnMsgCreateWidget(int opener_id,
                                         WebKit::WebPopupType popup_type,
                                         int* route_id,
                                         int* surface_id) {
  opener_id_ = opener_id;
  *route_id = routing_id_;
   *surface_id = surface_id_;
 }

void WebRTCAudioDeviceTest::TearDown() {
  SetAudioUtilCallback(NULL);

  ChildProcess::current()->main_thread()->message_loop()->RunAllPending();

  ChildProcess::current()->io_message_loop()->PostTask(FROM_HERE,
      base::Bind(&WebRTCAudioDeviceTest::DestroyChannel,
                 base::Unretained(this)));
  WaitForIOThreadCompletion();

  WaitForAudioManagerCompletion();

  ChildProcess::current()->io_message_loop()->PostTask(FROM_HERE,
      base::Bind(&WebRTCAudioDeviceTest::UninitializeIOThread,
                 base::Unretained((this))));
  WaitForIOThreadCompletion();
  mock_process_.reset();
}

WebKit::WebView* RenderViewImpl::GetWebView()  {
  return webview();
}

  void TestDidNavigate(int page_id, const GURL& url) {
    ViewHostMsg_FrameNavigate_Params params;
    InitNavigateParams(&params, page_id, url, content::PAGE_TRANSITION_TYPED);
    DidNavigate(GetRenderViewHostForTesting(), params);
  }

 int MockRenderThread::GenerateRoutingID() {
  NOTREACHED();
  return MSG_ROUTING_NONE;
}

gfx::NativeViewId RenderViewImpl::GetHostWindow() {
  return host_window();
}

void ExtensionDevToolsInfoBarDelegate::ClearClientHost() {
    client_host_ = NULL;
}

gfx::PluginWindowHandle RenderViewImpl::AllocateFakePluginWindowHandle(
    bool opaque, bool root) {
  gfx::PluginWindowHandle window = NULL;
  Send(new ViewHostMsg_AllocateFakePluginWindowHandle(
      routing_id(), opaque, root, &window));
  if (window) {
    fake_plugin_window_handles_.insert(window);
  }
  return window;
}

void WebRTCAudioDeviceTest::InitializeIOThread(const char* thread_name) {
  initialize_com_.reset(new ScopedCOMInitializer());

  io_thread_.reset(new content::TestBrowserThread(content::BrowserThread::IO,
                                                  MessageLoop::current()));

  audio_manager_.reset(AudioManager::Create());

  test_request_context_ = new TestURLRequestContext();
  resource_context_->set_request_context(test_request_context_.get());
  media_observer_.reset(new MockMediaObserver());
  resource_context_->set_media_observer(media_observer_.get());

  CreateChannel(thread_name);
}

void RenderViewTest::DidNavigateWithinPage(WebKit::WebFrame* frame,
                                           bool is_new_navigation) {
  RenderViewImpl* impl = static_cast<RenderViewImpl*>(view_);
  impl->didNavigateWithinPage(frame, is_new_navigation);
}

std::string ShellContentClient::GetUserAgent(bool* overriding) const {
  *overriding = false;
  return std::string("Chrome/15.16.17.18");
}

void RenderViewImpl::OnWasHidden() {
  RenderWidget::OnWasHidden();

  if (webview()) {
    webview()->settings()->setMinimumTimerInterval(
        webkit_glue::kBackgroundTabTimerInterval);
    webview()->setVisibilityState(visibilityState(), false);
  }

  pepper_delegate_.PageVisibilityChanged(false);

#if defined(OS_MACOSX)
  std::set<WebPluginDelegateProxy*>::iterator plugin_it;
  for (plugin_it = plugin_delegates_.begin();
       plugin_it != plugin_delegates_.end(); ++plugin_it) {
    (*plugin_it)->SetContainerVisibility(false);
  }
#endif  // OS_MACOSX
}

void RenderViewImpl::numberOfTouchEventHandlersChanged(unsigned num_handlers) {
  Send(new ViewHostMsg_DidChangeNumTouchEvents(routing_id_, num_handlers));
}

RenderProcessImpl::RenderProcessImpl()
: ALLOW_THIS_IN_INITIALIZER_LIST(shared_mem_cache_cleaner_(
FROM_HERE, base::TimeDelta::FromSeconds(5),
this, &RenderProcessImpl::ClearTransportDIBCache)),
      transport_dib_next_sequence_number_(0) {
in_process_plugins_ = InProcessPlugins();
for (size_t i = 0; i < arraysize(shared_mem_cache_); ++i)
shared_mem_cache_[i] = NULL;

#if defined(OS_WIN)
// HACK:  See http://b/issue?id=1024307 for rationale.
if (GetModuleHandle(L"LPK.DLL") == NULL) {
// Makes sure lpk.dll is loaded by gdi32 to make sure ExtTextOut() works
// when buffering into a EMF buffer for printing.
typedef BOOL (__stdcall *GdiInitializeLanguagePack)(int LoadedShapingDLLs);
GdiInitializeLanguagePack gdi_init_lpk =
reinterpret_cast<GdiInitializeLanguagePack>(GetProcAddress(
GetModuleHandle(L"GDI32.DLL"),
"GdiInitializeLanguagePack"));
DCHECK(gdi_init_lpk);
if (gdi_init_lpk) {
gdi_init_lpk(0);
}
}
#endif

// Out of process dev tools rely upon auto break behavior.
webkit_glue::SetJavaScriptFlags(
"--debugger-auto-break"
// Enable on-demand profiling.
" --prof --prof-lazy");

const CommandLine& command_line = *CommandLine::ForCurrentProcess();
if (command_line.HasSwitch(switches::kJavaScriptFlags)) {
webkit_glue::SetJavaScriptFlags(
command_line.GetSwitchValueASCII(switches::kJavaScriptFlags));
}
}

  virtual ~MockRenderProcess() {}

void RenderViewImpl::SyncNavigationState() {
  if (!webview())
    return;

  const WebHistoryItem& item = webview()->mainFrame()->currentHistoryItem();
  if (item.isNull())
    return;

  Send(new ViewHostMsg_UpdateState(
      routing_id_, page_id_, webkit_glue::HistoryItemToString(item)));
}

void RenderViewImpl::showContextMenu(
    WebFrame* frame, const WebContextMenuData& data) {
  content::ContextMenuParams params(data);

  if (frame)
    params.frame_id = frame->identifier();

  if (params.src_url.spec().size() > content::kMaxURLChars)
    params.src_url = GURL();
  context_menu_node_ = data.node;
  Send(new ViewHostMsg_ContextMenu(routing_id_, params));
}

bool RenderViewImpl::SupportsAsynchronousSwapBuffers() {
  if (WebWidgetHandlesCompositorScheduling())
    return false;

  if (queried_for_swapbuffers_complete_callback_)
    return context_has_swapbuffers_complete_callback_;

  queried_for_swapbuffers_complete_callback_ = true;

  WebKit::WebGraphicsContext3D* context = webview()->graphicsContext3D();
  if (context && context->makeContextCurrent()) {
    std::string extensions(context->getRequestableExtensionsCHROMIUM().utf8());
    context_has_swapbuffers_complete_callback_ =
        extensions.find("GL_CHROMIUM_swapbuffers_complete_callback")
            != std::string::npos;
  }

  return context_has_swapbuffers_complete_callback_;
}

void RenderViewImpl::didFailProvisionalLoad(WebFrame* frame,
                                            const WebURLError& error) {
  WebDataSource* ds = frame->provisionalDataSource();
  DCHECK(ds);

  const WebURLRequest& failed_request = ds->request();

  FOR_EACH_OBSERVER(
      RenderViewObserver, observers_, DidFailProvisionalLoad(frame, error));

  bool show_repost_interstitial =
      (error.reason == net::ERR_CACHE_MISS &&
       EqualsASCII(failed_request.httpMethod(), "POST"));

  ViewHostMsg_DidFailProvisionalLoadWithError_Params params;
  params.frame_id = frame->identifier();
  params.is_main_frame = !frame->parent();
  params.error_code = error.reason;
  content::GetContentClient()->renderer()->GetNavigationErrorStrings(
      failed_request,
      error,
      NULL,
      &params.error_description);
  params.url = error.unreachableURL;
  params.showing_repost_interstitial = show_repost_interstitial;
  Send(new ViewHostMsg_DidFailProvisionalLoadWithError(
      routing_id_, params));

  if (error.reason == net::ERR_ABORTED)
    return;
  if (error.reason == net::ERR_UNKNOWN_URL_SCHEME)
    return;

  frame->enableViewSourceMode(false);

  DocumentState* document_state = DocumentState::FromDataSource(ds);
  NavigationState* navigation_state = document_state->navigation_state();

  bool replace =
      navigation_state->pending_page_id() != -1 ||
      navigation_state->transition_type() ==
          content::PAGE_TRANSITION_AUTO_SUBFRAME;

  if (!navigation_state->is_content_initiated()) {
    pending_navigation_params_.reset(new ViewMsg_Navigate_Params);
    pending_navigation_params_->page_id =
        navigation_state->pending_page_id();
    pending_navigation_params_->pending_history_list_offset =
        navigation_state->pending_history_list_offset();
    pending_navigation_params_->transition =
        navigation_state->transition_type();
    pending_navigation_params_->request_time =
        document_state->request_time();
  }

  if (MaybeLoadAlternateErrorPage(frame, error, replace))
    return;

  LoadNavigationErrorPage(frame, failed_request, error, std::string(), replace);
}

  WebRTCMockRenderProcess() {}

bool RenderViewImpl::GetContentStateImmediately() {
  return send_content_state_immediately_;
}

RenderWidgetFullscreenPepper* RenderViewImpl::CreatePepperFullscreenContainer(
    webkit::ppapi::PluginInstance* plugin) {
  GURL active_url;
  if (webview() && webview()->mainFrame())
    active_url = GURL(webview()->mainFrame()->document().url());
  RenderWidgetFullscreenPepper* widget = RenderWidgetFullscreenPepper::Create(
      routing_id_, plugin, active_url);
  widget->show(WebKit::WebNavigationPolicyIgnore);
  return widget;
}

void RenderViewImpl::PpapiPluginTextInputTypeChanged() {
  UpdateTextInputState();
}

  void OnAudioTimeCallback(
      base::TimeDelta current_time, base::TimeDelta max_time) {
    CHECK(current_time <= max_time);
  }

static WebReferrerPolicy GetReferrerPolicyFromRequest(
    const WebURLRequest& request) {
  return request.extraData() ?
      static_cast<RequestExtraData*>(request.extraData())->referrer_policy() :
      WebKit::WebReferrerPolicyDefault;
}

bool ChromeWebUIControllerFactory::UseWebUIBindingsForURL(
    content::BrowserContext* browser_context, const GURL& url) const {
  return !NeedsExtensionWebUI(NULL,
                              Profile::FromBrowserContext(browser_context),
                              url) &&
       UseWebUIForURL(browser_context, url);
 }

bool ChromeWebUIControllerFactory::UseWebUIForURL(
    content::BrowserContext* browser_context, const GURL& url) const {
  return GetWebUIType(browser_context, url) != WebUI::kNoWebUI;
}

void RenderViewTest::SendWebMouseEvent(
    const WebKit::WebMouseEvent& mouse_event) {
  scoped_ptr<IPC::Message> input_message(new ViewMsg_HandleInputEvent(0));
  input_message->WriteData(reinterpret_cast<const char*>(&mouse_event),
                           sizeof(WebKit::WebMouseEvent));
  RenderViewImpl* impl = static_cast<RenderViewImpl*>(view_);
  impl->OnMessageReceived(*input_message);
}

void RenderViewImpl::PpapiPluginCancelComposition() {
  Send(new ViewHostMsg_ImeCancelComposition(routing_id()));
  ui::Range range(ui::Range::InvalidRange());
  Send(new ViewHostMsg_ImeCompositionRangeChanged(routing_id(), range));
}

void RenderViewImpl::OnScriptEvalRequest(const string16& frame_xpath,
                                         const string16& jscript,
                                         int id,
                                         bool notify_result) {
  EvaluateScript(frame_xpath, jscript, id, notify_result);
}

void RenderViewImpl::OnWasRestored(bool needs_repainting) {
  RenderWidget::OnWasRestored(needs_repainting);

  if (webview()) {
    webview()->settings()->setMinimumTimerInterval(
        webkit_glue::kForegroundTabTimerInterval);
    webview()->setVisibilityState(visibilityState(), false);
  }

  pepper_delegate_.PageVisibilityChanged(true);

#if defined(OS_MACOSX)
  std::set<WebPluginDelegateProxy*>::iterator plugin_it;
  for (plugin_it = plugin_delegates_.begin();
       plugin_it != plugin_delegates_.end(); ++plugin_it) {
    (*plugin_it)->SetContainerVisibility(true);
  }
#endif  // OS_MACOSX
}

void ExtensionDevToolsClientHost::TabReplaced(
    WebContents* web_contents) {
  web_contents_ = web_contents;
}

WebKit::WebPageVisibilityState RenderViewImpl::GetVisibilityState() const  {
  return visibilityState();
}

ExtensionDevToolsInfoBarDelegate::ExtensionDevToolsInfoBarDelegate(
    InfoBarTabHelper* infobar_helper,
    const std::string& client_name,
    ExtensionDevToolsClientHost* client_host)
    : ConfirmInfoBarDelegate(infobar_helper),
      client_name_(client_name),
      client_host_(client_host) {
}

  void set_should_create_webui(bool should_create_webui) {
    should_create_webui_ = should_create_webui;
  }

void RenderViewImpl::startDragging(const WebDragData& data,
                                   WebDragOperationsMask mask,
                                   const WebImage& image,
                                   const WebPoint& imageOffset) {
#if WEBKIT_USING_SKIA
  SkBitmap bitmap(image.getSkBitmap());
#elif WEBKIT_USING_CG
  SkBitmap bitmap = gfx::CGImageToSkBitmap(image.getCGImageRef());
#endif

  Send(new DragHostMsg_StartDragging(routing_id_,
                                     WebDropData(data),
                                     mask,
                                     bitmap,
                                     imageOffset));
}

  void ClearStates() {
    state_ = NULL;
    deleted_ = NULL;
    delegate_ = NULL;
  }

void ExtensionDevToolsClientHost::Close() {
  DevToolsManager::GetInstance()->ClientHostClosing(this);
  delete this;
}

void MockRenderThread::RegisterExtension(v8::Extension* extension) {
}

bool NeedsExtensionWebUI(content::WebUI* web_ui,
                         Profile* profile,
                         const GURL& url) {
  ExtensionService* service = profile ? profile->GetExtensionService() : NULL;
  return service && service->ExtensionBindingsAllowed(url) &&
      (!web_ui ||
        TabContentsWrapper::GetCurrentWrapperForContents(
            web_ui->GetWebContents()));
}

bool RenderViewImpl::IsNonLocalTopLevelNavigation(
    const GURL& url, WebKit::WebFrame* frame, WebKit::WebNavigationType type) {
  if (frame->parent() != NULL)
    return false;

  if (!url.SchemeIs(chrome::kHttpScheme) && !url.SchemeIs(chrome::kHttpsScheme))
    return false;

  if (type != WebKit::WebNavigationTypeReload &&
      type != WebKit::WebNavigationTypeFormSubmitted &&
      type != WebKit::WebNavigationTypeFormResubmitted &&
      type != WebKit::WebNavigationTypeBackForward) {
    WebKit::WebFrame* opener = frame->opener();
    if (!opener) {
      return true;
    } else {
      if (url.GetOrigin() != GURL(opener->document().url()).GetOrigin())
        return true;
    }
  }
  return false;
}

bool RenderProcessImpl::PutSharedMemInCache(TransportDIB* mem) {
  const int slot = FindFreeCacheSlot(mem->size());
  if (slot == -1)
    return false;

  shared_mem_cache_[slot] = mem;
  return true;
}

 MockRenderProcess::~MockRenderProcess() {
}

void RenderViewImpl::DidPlay(webkit_media::WebMediaPlayerImpl* player) {
  Send(new ViewHostMsg_MediaNotification(routing_id_,
                                         reinterpret_cast<int64>(player),
                                         player->hasVideo(),
                                         player->hasAudio(),
                                         true));
}

void RenderViewImpl::OnNavigate(const ViewMsg_Navigate_Params& params) {
#if defined(OS_CHROMEOS)
  LOG(ERROR) << "OnNavigate: url=" << params.url
             << ", webview=" << webview()
             << ", reload=" << IsReload(params)
             << ", paerams.state.empty=" << params.state.empty();
#endif
  MaybeHandleDebugURL(params.url);
  if (!webview())
    return;

  FOR_EACH_OBSERVER(RenderViewObserver, observers_, Navigate(params.url));

  bool is_reload = IsReload(params);

  if (IsBackForwardToStaleEntry(params, is_reload))
    return;

  if (is_swapped_out_)
    SetSwappedOut(false);

  history_list_offset_ = params.current_history_list_offset;
  history_list_length_ = params.current_history_list_length;
  if (history_list_length_ >= 0)
    history_page_ids_.resize(history_list_length_, -1);
  if (params.pending_history_list_offset >= 0 &&
      params.pending_history_list_offset < history_list_length_)
    history_page_ids_[params.pending_history_list_offset] = params.page_id;

  content::GetContentClient()->SetActiveURL(params.url);

  WebFrame* main_frame = webview()->mainFrame();
  if (is_reload && main_frame->currentHistoryItem().isNull()) {
    is_reload = false;
  }

  pending_navigation_params_.reset(new ViewMsg_Navigate_Params);
  *pending_navigation_params_.get() = params;

  if (is_reload) {
    bool ignore_cache = (params.navigation_type ==
                             ViewMsg_Navigate_Type::RELOAD_IGNORING_CACHE);
    main_frame->reload(ignore_cache);
  } else if (!params.state.empty()) {
    DCHECK_NE(params.page_id, -1);
    main_frame->loadHistoryItem(
        webkit_glue::HistoryItemFromString(params.state));
  } else {
    WebURLRequest request(params.url);

    CHECK_EQ(params.page_id, -1);

    if (main_frame->isViewSourceModeEnabled())
      request.setCachePolicy(WebURLRequest::ReturnCacheDataElseLoad);

    if (params.referrer.url.is_valid()) {
      WebString referrer = WebSecurityPolicy::generateReferrerHeader(
          params.referrer.policy,
          params.url,
          WebString::fromUTF8(params.referrer.url.spec()));
      if (!referrer.isEmpty())
        request.setHTTPHeaderField(WebString::fromUTF8("Referer"), referrer);
    }

    if (!params.extra_headers.empty()) {
      for (net::HttpUtil::HeadersIterator i(params.extra_headers.begin(),
                                            params.extra_headers.end(), "\n");
           i.GetNext(); ) {
        request.addHTTPHeaderField(WebString::fromUTF8(i.name()),
                                   WebString::fromUTF8(i.values()));
      }
    }
#if defined(OS_CHROMEOS)
    LOG(ERROR) << " FrameLoader::loadRequest()";
#endif
    main_frame->loadRequest(request);
  }

  pending_navigation_params_.reset();
}

WebUIController* NewWebUI(content::WebUI* web_ui, const GURL& url) {
  return new T(web_ui);
}

string16 ExtensionDevToolsInfoBarDelegate::GetMessageText() const {
  return l10n_util::GetStringFUTF16(IDS_DEV_TOOLS_INFOBAR_LABEL,
                                    UTF8ToUTF16(client_name_));
}

void RenderViewImpl::OnThemeChanged() {
#if defined(USE_AURA)
#elif defined(OS_WIN)
  gfx::NativeThemeWin::instance()->CloseHandles();
  if (webview())
    webview()->themeChanged();
#else  // defined(OS_WIN)
  NOTIMPLEMENTED();
#endif
}

void TestInterstitialPageDelegate::CommandReceived(const std::string& command) {
  interstitial_page_->CommandReceived();
}

void WaitCallback(base::WaitableEvent* event) {
  event->Signal();
}

void RenderViewImpl::OnSetRendererPrefs(
    const content::RendererPreferences& renderer_prefs) {
  double old_zoom_level = renderer_preferences_.default_zoom_level;
  renderer_preferences_ = renderer_prefs;
  UpdateFontRenderingFromRendererPrefs();
#if defined(TOOLKIT_USES_GTK)
  WebColorName name = WebKit::WebColorWebkitFocusRingColor;
  WebKit::setNamedColors(&name, &renderer_prefs.focus_ring_color, 1);
  WebKit::setCaretBlinkInterval(renderer_prefs.caret_blink_interval);
  gfx::NativeTheme::instance()->SetScrollbarColors(
      renderer_prefs.thumb_inactive_color,
      renderer_prefs.thumb_active_color,
      renderer_prefs.track_color);

  if (webview()) {
    webview()->setScrollbarColors(
        renderer_prefs.thumb_inactive_color,
        renderer_prefs.thumb_active_color,
        renderer_prefs.track_color);
    webview()->setSelectionColors(
        renderer_prefs.active_selection_bg_color,
        renderer_prefs.active_selection_fg_color,
        renderer_prefs.inactive_selection_bg_color,
        renderer_prefs.inactive_selection_fg_color);
    webview()->themeChanged();
  }
#endif
  if (webview() && !webview()->mainFrame()->document().isPluginDocument() &&
      content::ZoomValuesEqual(webview()->zoomLevel(), old_zoom_level)) {
    webview()->setZoomLevel(false, renderer_preferences_.default_zoom_level);
    zoomLevelChanged();
  }
}

WebKit::WebUserMediaClient* RenderViewImpl::userMediaClient() {
  const CommandLine* cmd_line = CommandLine::ForCurrentProcess();
  if (!cmd_line->HasSwitch(switches::kEnableMediaStream))
    return NULL;
  EnsureMediaStreamImpl();
  return media_stream_impl_;
}

bool MockRenderThread::Send(IPC::Message* msg) {
  if (msg->is_reply()) {
    if (reply_deserializer_.get()) {
      reply_deserializer_->SerializeOutputParameters(*msg);
      reply_deserializer_.reset();
    }
  } else {
    if (msg->is_sync()) {
      reply_deserializer_.reset(
          static_cast<IPC::SyncMessage*>(msg)->GetReplyDeserializer());
    }
    OnMessageReceived(*msg);
  }
  delete msg;
  return true;
}

   virtual bool HasInitializedMediaLibrary() const { return false; }

void WebRTCAudioDeviceTest::WaitForIOThreadCompletion() {
  WaitForMessageLoopCompletion(
      ChildProcess::current()->io_message_loop()->message_loop_proxy());
}

float RenderViewImpl::GetFilteredTimePerFrame() {
  return filtered_time_per_frame();
}

void RenderViewImpl::OnSelectRange(const gfx::Point& start,
                                   const gfx::Point& end) {
  if (!webview())
    return;

  handling_select_range_ = true;
  webview()->focusedFrame()->selectRange(start, end);
  handling_select_range_ = false;
}

void RenderViewImpl::UpdateURL(WebFrame* frame) {
  WebDataSource* ds = frame->dataSource();
  DCHECK(ds);

  const WebURLRequest& request = ds->request();
  const WebURLRequest& original_request = ds->originalRequest();
  const WebURLResponse& response = ds->response();

  DocumentState* document_state = DocumentState::FromDataSource(ds);
  NavigationState* navigation_state = document_state->navigation_state();

  ViewHostMsg_FrameNavigate_Params params;
  params.http_status_code = response.httpStatusCode();
  params.is_post = false;
  params.post_id = -1;
  params.page_id = page_id_;
  params.frame_id = frame->identifier();
  params.socket_address.set_host(response.remoteIPAddress().utf8());
  params.socket_address.set_port(response.remotePort());
  params.was_fetched_via_proxy = response.wasFetchedViaProxy();
  params.was_within_same_page = navigation_state->was_within_same_page();
  if (!document_state->security_info().empty()) {
    DCHECK(response.securityInfo().isEmpty());
    params.security_info = document_state->security_info();
  } else {
    params.security_info = response.securityInfo();
  }

  params.url = GetLoadingUrl(frame);

  if (frame->document().baseURL() != params.url)
    params.base_url = frame->document().baseURL();

  GetRedirectChain(ds, &params.redirects);
  params.should_update_history = !ds->hasUnreachableURL() &&
      !response.isMultipartPayload() && (response.httpStatusCode() != 404);

  params.searchable_form_url = document_state->searchable_form_url();
  params.searchable_form_encoding =
      document_state->searchable_form_encoding();

  const PasswordForm* password_form_data =
      document_state->password_form_data();
  if (password_form_data)
    params.password_form = *password_form_data;

  params.gesture = navigation_gesture_;
  navigation_gesture_ = NavigationGestureUnknown;

  const WebHistoryItem& item = frame->currentHistoryItem();
  if (!item.isNull()) {
    params.content_state = webkit_glue::HistoryItemToString(item);
  } else {
    params.content_state =
        webkit_glue::CreateHistoryStateForURL(GURL(request.url()));
  }

  if (!frame->parent()) {

    HostZoomLevels::iterator host_zoom =
        host_zoom_levels_.find(GURL(request.url()));
    if (webview()->mainFrame()->document().isPluginDocument()) {
      webview()->setZoomLevel(false, 0);
    } else {
      if (host_zoom != host_zoom_levels_.end())
        webview()->setZoomLevel(false, host_zoom->second);
    }

    if (host_zoom != host_zoom_levels_.end()) {
      host_zoom_levels_.erase(host_zoom);
    }

    webview()->zoomLimitsChanged(
        WebView::zoomFactorToZoomLevel(content::kMinimumZoomFactor),
        WebView::zoomFactorToZoomLevel(content::kMaximumZoomFactor));

    params.contents_mime_type = ds->response().mimeType().utf8();

    params.transition = navigation_state->transition_type();
    if (!content::PageTransitionIsMainFrame(params.transition)) {
      params.transition = content::PAGE_TRANSITION_LINK;
    }

    if (completed_client_redirect_src_.url.is_valid()) {
      DCHECK(completed_client_redirect_src_.url == params.redirects[0]);
      params.referrer = completed_client_redirect_src_;
      params.transition = static_cast<content::PageTransition>(
          params.transition | content::PAGE_TRANSITION_CLIENT_REDIRECT);
    } else {
      params.referrer = Referrer(GURL(
          original_request.httpHeaderField(WebString::fromUTF8("Referer"))),
          GetReferrerPolicyFromRequest(original_request));
    }

    string16 method = request.httpMethod();
    if (EqualsASCII(method, "POST")) {
      params.is_post = true;
      params.post_id = ExtractPostId(item);
    }

    UMA_HISTOGRAM_COUNTS_10000("Memory.GlyphPagesPerLoad",
                               webkit_glue::GetGlyphPageCount());

    Send(new ViewHostMsg_FrameNavigate(routing_id_, params));
  } else {
    if (page_id_ > last_page_id_sent_to_browser_)
      params.transition = content::PAGE_TRANSITION_MANUAL_SUBFRAME;
    else
      params.transition = content::PAGE_TRANSITION_AUTO_SUBFRAME;

    Send(new ViewHostMsg_FrameNavigate(routing_id_, params));
  }

  last_page_id_sent_to_browser_ =
      std::max(last_page_id_sent_to_browser_, page_id_);

  navigation_state->set_transition_type(content::PAGE_TRANSITION_LINK);
}

bool RenderViewTest::ExecuteJavaScriptAndReturnIntValue(
    const string16& script,
    int* int_result) {
  v8::Handle<v8::Value> result =
      GetMainFrame()->executeScriptAndReturnValue(WebScriptSource(script));
  if (result.IsEmpty() || !result->IsInt32())
    return false;

  if (int_result)
    *int_result = result->Int32Value();

  return true;
}

WebKit::WebNode RenderViewImpl::GetContextMenuNode() const  {
  return context_menu_node_;
}

void RenderViewTest::SendWebKeyboardEvent(
    const WebKit::WebKeyboardEvent& key_event) {
  scoped_ptr<IPC::Message> input_message(new ViewMsg_HandleInputEvent(0));
  input_message->WriteData(reinterpret_cast<const char*>(&key_event),
                           sizeof(WebKit::WebKeyboardEvent));
  RenderViewImpl* impl = static_cast<RenderViewImpl*>(view_);
  impl->OnMessageReceived(*input_message);
}

WebMediaPlayer* RenderViewImpl::createMediaPlayer(
    WebFrame* frame, WebMediaPlayerClient* client) {
  FOR_EACH_OBSERVER(
      RenderViewObserver, observers_, WillCreateMediaPlayer(frame, client));

  media::MessageLoopFactory* message_loop_factory =
      new media::MessageLoopFactory();
  media::FilterCollection* collection = new media::FilterCollection();
  RenderMediaLog* render_media_log = new RenderMediaLog();

  RenderAudioSourceProvider* audio_source_provider = NULL;

  const CommandLine* cmd_line = CommandLine::ForCurrentProcess();
  if (!cmd_line->HasSwitch(switches::kDisableAudio)) {
    audio_source_provider = new RenderAudioSourceProvider();

    AudioRendererImpl* audio_renderer =
        new AudioRendererImpl(audio_source_provider);
    collection->AddAudioRenderer(audio_renderer);
  }

#if defined(OS_CHROMEOS) && defined(ARCH_CPU_ARMEL)
  WebGraphicsContext3DCommandBufferImpl* context3d =
      static_cast<WebGraphicsContext3DCommandBufferImpl*>(
          webview()->graphicsContext3D());
  if (context_is_web_graphics_context_3d_command_buffer_impl_ && context3d) {
    MessageLoop* factories_loop =
        RenderThreadImpl::current()->compositor_thread() ?
        RenderThreadImpl::current()->compositor_thread()->GetWebThread()
            ->message_loop() :
        MessageLoop::current();
    GpuChannelHost* gpu_channel_host =
        RenderThreadImpl::current()->EstablishGpuChannelSync(
            content::CAUSE_FOR_GPU_LAUNCH_VIDEODECODEACCELERATOR_INITIALIZE);
    collection->AddVideoDecoder(new media::GpuVideoDecoder(
        message_loop_factory->GetMessageLoop("GpuVideoDecoder"),
        factories_loop,
        new RendererGpuVideoDecoderFactories(
            gpu_channel_host, factories_loop, context3d)));
  }
#endif

  webkit_media::WebMediaPlayerImpl* media_player =
      content::GetContentClient()->renderer()->OverrideCreateWebMediaPlayer(
          this, frame, client, AsWeakPtr(), collection, audio_source_provider,
          message_loop_factory, media_stream_impl_.get(), render_media_log);
#if defined(OS_ANDROID)
#else
  if (!media_player) {
    media_player = new webkit_media::WebMediaPlayerImpl(
        frame, client, AsWeakPtr(), collection, audio_source_provider,
        message_loop_factory, media_stream_impl_.get(), render_media_log);
  }
#endif
  return media_player;
}

static bool IsReload(const ViewMsg_Navigate_Params& params) {
  return
      params.navigation_type == ViewMsg_Navigate_Type::RELOAD ||
      params.navigation_type == ViewMsg_Navigate_Type::RELOAD_IGNORING_CACHE;
}

void RenderViewImpl::didStopLoading() {
  if (!is_loading_) {
    DVLOG(1) << "DidStopLoading called while not loading";
    return;
  }

  is_loading_ = false;

  Send(new ViewHostMsg_DidStopLoading(routing_id_));

  if (load_progress_tracker_ != NULL)
    load_progress_tracker_->DidStopLoading();

  FOR_EACH_OBSERVER(RenderViewObserver, observers_, DidStopLoading());
}

void RenderViewImpl::PopulateStateFromPendingNavigationParams(
    DocumentState* document_state) {
  const ViewMsg_Navigate_Params& params = *pending_navigation_params_.get();

  if (document_state->request_time().is_null())
    document_state->set_request_time(params.request_time);

  if (!params.url.SchemeIs(chrome::kJavaScriptScheme)) {
    NavigationState* navigation_state = NavigationState::CreateBrowserInitiated(
        params.page_id,
        params.pending_history_list_offset,
        params.transition);
    navigation_state->set_transferred_request_child_id(
        params.transferred_request_child_id);
    navigation_state->set_transferred_request_request_id(
        params.transferred_request_request_id);
    if (params.navigation_type == ViewMsg_Navigate_Type::RESTORE) {
      document_state->set_cache_policy_override(
          WebURLRequest::UseProtocolCachePolicy);
    }
    document_state->set_navigation_state(navigation_state);
  } else {
    document_state->set_navigation_state(
        NavigationState::CreateContentInitiated());
  }

  if (IsReload(params))
    document_state->set_load_type(DocumentState::RELOAD);
  else if (!params.state.empty())
    document_state->set_load_type(DocumentState::HISTORY_LOAD);
  else
    document_state->set_load_type(DocumentState::NORMAL_LOAD);

  pending_navigation_params_.reset();
}

bool ShellContentClient::GetSandboxProfileForSandboxType(
    int sandbox_type,
    int* sandbox_profile_resource_id) const {
  return false;
}

bool RenderViewImpl::runFileChooser(
    const WebKit::WebFileChooserParams& params,
    WebFileChooserCompletion* chooser_completion) {
  if (is_hidden())
    return false;
  content::FileChooserParams ipc_params;
  if (params.directory)
    ipc_params.mode = content::FileChooserParams::OpenFolder;
  else if (params.multiSelect)
    ipc_params.mode = content::FileChooserParams::OpenMultiple;
  else if (params.saveAs)
    ipc_params.mode = content::FileChooserParams::Save;
  else
    ipc_params.mode = content::FileChooserParams::Open;
  ipc_params.title = params.title;
  ipc_params.default_file_name =
      webkit_glue::WebStringToFilePath(params.initialValue);
  ipc_params.accept_types.reserve(params.acceptMIMETypes.size());
  for (size_t i = 0; i < params.acceptMIMETypes.size(); ++i)
    ipc_params.accept_types.push_back(params.acceptMIMETypes[i]);

  return ScheduleFileChooser(ipc_params, chooser_completion);
}

  MockRenderProcess() {}

  virtual ~TestSiteInstance() {
    (*delete_counter_)++;
  }

  explicit TestInterstitialPageStateGuard(
      TestInterstitialPage* interstitial_page)
      : interstitial_page_(interstitial_page) {
    DCHECK(interstitial_page_);
    interstitial_page_->set_delegate(this);
  }

WebUIFactoryFunction GetWebUIFactoryFunction(content::WebUI* web_ui,
                                             Profile* profile,
                                             const GURL& url) {
  if (NeedsExtensionWebUI(web_ui, profile, url))
    return &NewWebUI<ExtensionWebUI>;

  if (!url.SchemeIs(chrome::kChromeDevToolsScheme) &&
      !url.SchemeIs(chrome::kChromeInternalScheme) &&
      !url.SchemeIs(chrome::kChromeUIScheme)) {
    return NULL;
  }

  if (url.host() == chrome::kChromeUINewTabHost ||
      url.SchemeIs(chrome::kChromeInternalScheme)) {
    return &NewWebUI<NewTabUI>;
  }

  /****************************************************************************
   * Please keep this in alphabetical order. If #ifs or special logics are
   * required, add it below in the appropriate section.
   ***************************************************************************/
  if (url.host() == chrome::kChromeUIBookmarksHost)
    return &NewWebUI<BookmarksUI>;
  if (url.host() == chrome::kChromeUICloudPrintResourcesHost)
    return &NewWebUI<ExternalHtmlDialogUI>;
  if (url.host() == chrome::kChromeUICloudPrintSetupHost)
    return &NewWebUI<HtmlDialogUI>;
  if (url.spec() == chrome::kChromeUIConstrainedHTMLTestURL)
    return &NewWebUI<ConstrainedHtmlUI>;
  if (url.host() == chrome::kChromeUICrashesHost)
    return &NewWebUI<CrashesUI>;
  if (url.host() == chrome::kChromeUIDevToolsHost)
    return &NewWebUI<DevToolsUI>;
  if (url.host() == chrome::kChromeUIDialogHost)
    return &NewWebUI<ConstrainedHtmlUI>;
  if (url.host() == chrome::kChromeUIExtensionsFrameHost)
    return &NewWebUI<ExtensionsUI>;
  if (url.host() == chrome::kChromeUIFeedbackHost)
    return &NewWebUI<FeedbackUI>;
  if (url.host() == chrome::kChromeUIFlagsHost)
    return &NewWebUI<FlagsUI>;
  if (url.host() == chrome::kChromeUIFlashHost)
    return &NewWebUI<FlashUI>;
  if (url.host() == chrome::kChromeUIGpuInternalsHost)
    return &NewWebUI<GpuInternalsUI>;
  if (url.host() == chrome::kChromeUIHelpFrameHost)
    return &NewWebUI<HelpUI>;
  if (url.host() == chrome::kChromeUIHistoryFrameHost)
    return &NewWebUI<HistoryUI>;
  if (url.host() == chrome::kChromeUIMediaInternalsHost)
    return &NewWebUI<MediaInternalsUI>;
  if (url.host() == chrome::kChromeUINetInternalsHost)
    return &NewWebUI<NetInternalsUI>;
  if (url.host() == chrome::kChromeUINetworkActionPredictorHost)
    return &NewWebUI<NetworkActionPredictorUI>;
  if (url.host() == chrome::kChromeUIOmniboxHost)
    return &NewWebUI<OmniboxUI>;
  if (url.host() == chrome::kChromeUIPluginsHost)
    return &NewWebUI<PluginsUI>;
  if (url.host() == chrome::kChromeUIProfilerHost)
    return &NewWebUI<ProfilerUI>;
  if (url.host() == chrome::kChromeUIQuotaInternalsHost)
    return &NewWebUI<QuotaInternalsUI>;
  if (url.host() == chrome::kChromeUISessionsHost)
    return &NewWebUI<SessionsUI>;
  if (url.host() == chrome::kChromeUISyncInternalsHost)
    return &NewWebUI<SyncInternalsUI>;
  if (url.host() == chrome::kChromeUISyncResourcesHost)
    return &NewWebUI<HtmlDialogUI>;
  if (url.host() == chrome::kChromeUITaskManagerHost)
    return &NewWebUI<TaskManagerUI>;
  if (url.host() == chrome::kChromeUITracingHost)
    return &NewWebUI<TracingUI>;
  if (url.host() == chrome::kChromeUIUberFrameHost)
    return &NewWebUI<UberFrameUI>;
  if (url.host() == chrome::kChromeUIUberHost)
    return &NewWebUI<UberUI>;
  if (url.host() == chrome::kChromeUIWorkersHost)
    return &NewWebUI<WorkersUI>;

  /****************************************************************************
   * OS Specific #defines
   ***************************************************************************/
#if !defined(OS_ANDROID)
  if (url.host() == chrome::kChromeUIDownloadsHost)
    return &NewWebUI<DownloadsUI>;
  if (url.host() == chrome::kChromeUISettingsFrameHost)
    return &NewWebUI<options2::OptionsUI>;
  if (url.host() == chrome::kChromeUISettingsHost)
    return &NewWebUI<OptionsUI>;
  if (url.host() == chrome::kChromeUIPrintHost &&
      !g_browser_process->local_state()->GetBoolean(
          prefs::kPrintPreviewDisabled)) {
    return &NewWebUI<PrintPreviewUI>;
  }
#endif
#if defined(OS_WIN)
  if (url.host() == chrome::kChromeUIConflictsHost)
    return &NewWebUI<ConflictsUI>;
#endif
#if (defined(USE_NSS) || defined(USE_OPENSSL)) && defined(USE_AURA)
  if (url.host() == chrome::kChromeUICertificateViewerHost)
    return &NewWebUI<CertificateViewerUI>;
#endif
#if defined(OS_CHROMEOS)
  if (url.host() == chrome::kChromeUIActiveDownloadsHost)
    return &NewWebUI<ActiveDownloadsUI>;
  if (url.host() == chrome::kChromeUIChooseMobileNetworkHost)
    return &NewWebUI<chromeos::ChooseMobileNetworkUI>;
  if (url.host() == chrome::kChromeUIImageBurnerHost)
    return &NewWebUI<ImageBurnUI>;
  if (url.host() == chrome::kChromeUIKeyboardOverlayHost)
    return &NewWebUI<KeyboardOverlayUI>;
  if (url.host() == chrome::kChromeUIMobileSetupHost)
    return &NewWebUI<MobileSetupUI>;
  if (url.host() == chrome::kChromeUIOobeHost)
    return &NewWebUI<chromeos::OobeUI>;
  if (url.host() == chrome::kChromeUIProxySettingsHost)
    return &NewWebUI<chromeos::ProxySettingsUI>;
  if (url.host() == chrome::kChromeUIRegisterPageHost)
    return &NewWebUI<RegisterPageUI>;
  if (url.host() == chrome::kChromeUISimUnlockHost)
    return &NewWebUI<chromeos::SimUnlockUI>;
  if (url.host() == chrome::kChromeUISystemInfoHost)
    return &NewWebUI<SystemInfoUI>;
#endif  // defined(OS_CHROMEOS)

  /****************************************************************************
   * Other #defines and special logics.
   ***************************************************************************/
#if defined(ENABLE_CONFIGURATION_POLICY)
  if (url.host() == chrome::kChromeUIPolicyHost)
    return &NewWebUI<PolicyUI>;
#endif
#if defined(USE_VIRTUAL_KEYBOARD)
  if (url.host() == chrome::kChromeUIKeyboardHost)
    return &NewWebUI<KeyboardUI>;
#endif

#if (defined(OS_LINUX) && defined(TOOLKIT_VIEWS)) || defined(USE_AURA)
  if (url.host() == chrome::kChromeUICollectedCookiesHost ||
      url.host() == chrome::kChromeUIHttpAuthHost ||
      url.host() == chrome::kChromeUITabModalConfirmDialogHost) {
    return &NewWebUI<ConstrainedHtmlUI>;
  }
#endif

#if !defined(OS_CHROMEOS) && !defined(OS_ANDROID)
  if (url.host() == chrome::kChromeUISyncPromoHost) {
    if (SyncPromoUI::ShouldShowSyncPromo(profile))
      return &NewWebUI<SyncPromoUI>;
    else
      return &NewWebUI<NewTabUI>;
  }
#endif

  if (url.host() == chrome::kChromeUIChromeURLsHost ||
      url.host() == chrome::kChromeUICreditsHost ||
      url.host() == chrome::kChromeUIDNSHost ||
      url.host() == chrome::kChromeUIHistogramsHost ||
      url.host() == chrome::kChromeUIMemoryHost ||
      url.host() == chrome::kChromeUIMemoryRedirectHost ||
      url.host() == chrome::kChromeUIStatsHost ||
      url.host() == chrome::kChromeUITaskManagerHost ||
      url.host() == chrome::kChromeUITermsHost ||
      url.host() == chrome::kChromeUIVersionHost
#if defined(USE_TCMALLOC)
      || url.host() == chrome::kChromeUITCMallocHost
#endif
#if defined(OS_LINUX) || defined(OS_OPENBSD)
      || url.host() == chrome::kChromeUILinuxProxyConfigHost
      || url.host() == chrome::kChromeUISandboxHost
#endif
#if defined(OS_CHROMEOS)
      || url.host() == chrome::kChromeUICryptohomeHost
      || url.host() == chrome::kChromeUIDiscardsHost
      || url.host() == chrome::kChromeUINetworkHost
      || url.host() == chrome::kChromeUIOSCreditsHost
#endif
      ) {
    return &NewWebUI<AboutUI>;
  }

  if (url.host() == chrome::kChromeUIExtensionActivityHost &&
      CommandLine::ForCurrentProcess()->HasSwitch(
          switches::kEnableExtensionActivityUI)) {
    return &NewWebUI<ExtensionActivityUI>;
  }

  DLOG(WARNING) << "Unknown WebUI:" << url;
  return NULL;
}

 MockRenderThread::~MockRenderThread() {
}

void RenderViewImpl::reportFindInPageSelection(int request_id,
                                               int active_match_ordinal,
                                               const WebRect& selection_rect) {
  Send(new ViewHostMsg_Find_Reply(routing_id_,
                                  request_id,
                                  -1,
                                  selection_rect,
                                  active_match_ordinal,
                                  false));
}

void RenderViewImpl::registerIntentService(
    WebFrame* frame, const WebIntentServiceInfo& service) {
  string16 title = service.title();
  if (title.empty())
    title = webview()->mainFrame()->document().title();

  Send(new IntentsHostMsg_RegisterIntentService(routing_id_,
                                                service.action(),
                                                service.type(),
                                                service.url().spec().utf16(),
                                                title,
                                                service.disposition()));
}

void RenderViewImpl::didChangeSelection(bool is_empty_selection) {
  if (!handling_input_event_ && !handling_select_range_)
      return;
  handling_select_range_ = false;

  SyncSelectionIfRequired();
}

  bool ShouldSwapProcesses(RenderViewHostManager* manager,
                           const NavigationEntryImpl* cur_entry,
                           const NavigationEntryImpl* new_entry) const {
    return manager->ShouldSwapProcessesForNavigation(cur_entry, new_entry);
   }

RefCountedMemory* ChromeWebUIControllerFactory::GetFaviconResourceBytes(
const GURL& page_url) const {
// The bookmark manager is a chrome extension, so we have to check for it
// before we check for extension scheme.
if (page_url.host() == extension_misc::kBookmarkManagerId)
return BookmarksUI::GetFaviconResourceBytes();

// The extension scheme is handled in GetFaviconForURL.
if (page_url.SchemeIs(chrome::kExtensionScheme)) {
NOTREACHED();
return NULL;
}

  if (!HasWebUIScheme(page_url))
return NULL;

#if defined(OS_WIN)
if (page_url.host() == chrome::kChromeUIConflictsHost)
return ConflictsUI::GetFaviconResourceBytes();
#endif

if (page_url.host() == chrome::kChromeUICrashesHost)
return CrashesUI::GetFaviconResourceBytes();

if (page_url.host() == chrome::kChromeUIHistoryHost)
return HistoryUI::GetFaviconResourceBytes();

if (page_url.host() == chrome::kChromeUIFlagsHost)
return FlagsUI::GetFaviconResourceBytes();

if (page_url.host() == chrome::kChromeUISessionsHost)
return SessionsUI::GetFaviconResourceBytes();

if (page_url.host() == chrome::kChromeUIFlashHost)
return FlashUI::GetFaviconResourceBytes();

#if !defined(OS_ANDROID)
// Android uses the native download manager
if (page_url.host() == chrome::kChromeUIDownloadsHost)
return DownloadsUI::GetFaviconResourceBytes();

// Android doesn't use the Options/Options2 pages
if (page_url.host() == chrome::kChromeUISettingsHost)
return OptionsUI::GetFaviconResourceBytes();

if (page_url.host() == chrome::kChromeUISettingsFrameHost)
return options2::OptionsUI::GetFaviconResourceBytes();
#endif

if (page_url.host() == chrome::kChromeUIPluginsHost)
return PluginsUI::GetFaviconResourceBytes();

return NULL;
}

   void set_should_create_webui(bool should_create_webui) {
    browser_client_.set_should_create_webui(should_create_webui);
  }

ChromeWebUIControllerFactory::~ChromeWebUIControllerFactory() {
}

void RenderViewImpl::reportFindInPageMatchCount(int request_id, int count,
                                                bool final_update) {
  int active_match_ordinal = -1;  // -1 = don't update active match ordinal
  if (!count)
    active_match_ordinal = 0;

  IPC::Message* msg = new ViewHostMsg_Find_Reply(
      routing_id_,
      request_id,
      count,
      gfx::Rect(),
      active_match_ordinal,
      final_update);

  if (queued_find_reply_message_.get()) {
    queued_find_reply_message_.reset(msg);
  } else {
    Send(msg);
  }
}

  static AttachedClientHosts* GetInstance() {
    return Singleton<AttachedClientHosts>::get();
  }

void ExtensionDevToolsClientHost::InfoBarDestroyed() {
  infobar_delegate_ = NULL;
  SendDetachedEvent();
  Close();
}

void RenderViewImpl::DidInitiatePaint() {
  pepper_delegate_.ViewInitiatedPaint();
}

WebUI::TypeID ChromeWebUIControllerFactory::GetWebUIType(
      content::BrowserContext* browser_context, const GURL& url) const {
  Profile* profile = Profile::FromBrowserContext(browser_context);
  WebUIFactoryFunction function = GetWebUIFactoryFunction(NULL, profile, url);
  return function ? reinterpret_cast<WebUI::TypeID>(function) : WebUI::kNoWebUI;
}

MockRenderThread::MockRenderThread()
    : routing_id_(0), surface_id_(0), opener_id_(0) {
}

bool DetachDebuggerFunction::RunImpl() {
  if (!InitClientHost())
    return false;

  client_host_->Close();
  SendResponse(true);
  return true;
}

   virtual void ReleaseTransportDIB(TransportDIB* memory) {}

void MockRenderThread::ReleaseCachedFonts() {
}

static SiteInstanceImpl* CreateSiteInstance(
    content::RenderProcessHostFactory* factory, const GURL& url) {
  SiteInstanceImpl* instance =
      reinterpret_cast<SiteInstanceImpl*>(
          SiteInstance::CreateForURL(NULL, url));
  instance->set_render_process_host_factory(factory);
  return instance;
}

void MockRenderThread::EnsureWebKitInitialized() {
}

WebStorageNamespace* RenderViewImpl::createSessionStorageNamespace(
    unsigned quota) {
  if (CommandLine::ForCurrentProcess()->HasSwitch(switches::kSingleProcess))
    return WebStorageNamespace::createSessionStorageNamespace(quota);
  CHECK(session_storage_namespace_id_ != kInvalidSessionStorageNamespaceId);
  return new RendererWebStorageNamespaceImpl(DOM_STORAGE_SESSION,
                                             session_storage_namespace_id_);
}

void ShellContentClient::SetGpuInfo(const GPUInfo& gpu_info) {
}

void RenderViewImpl::ShowContextMenu(WebKit::WebFrame* frame,
                                     const WebKit::WebContextMenuData& data)  {
  showContextMenu(frame, data);
}

void RenderViewImpl::didStartLoading() {
#if defined(OS_CHROMEOS)
  LOG(ERROR) << "didStartLoading is_loading=" << is_loading_;
#endif
  if (is_loading_) {
    DVLOG(1) << "didStartLoading called while loading";
    return;
  }

  is_loading_ = true;

  Send(new ViewHostMsg_DidStartLoading(routing_id_));

  FOR_EACH_OBSERVER(RenderViewObserver, observers_, DidStartLoading());
}

void RenderViewImpl::OnDragTargetDragOver(const gfx::Point& client_point,
                                          const gfx::Point& screen_point,
                                          WebDragOperationsMask ops) {
  WebDragOperation operation = webview()->dragTargetDragOver(
      client_point,
      screen_point,
      ops);

  Send(new DragHostMsg_UpdateDragCursor(routing_id_, operation));
}

std::string TestContentClient::GetUserAgent(bool* overriding) const {
  *overriding = false;
  return std::string("TestContentClient");
}

void RenderViewImpl::runModal() {
  DCHECK(did_show_) << "should already have shown the view";

  if (RenderThreadImpl::current())  // Will be NULL during unit tests.
    RenderThreadImpl::current()->DoNotSuspendWebKitSharedTimer();

  SendAndRunNestedMessageLoop(new ViewHostMsg_RunModal(routing_id_));
}

  ~ReplaceContentClientRenderer() {
    content::GetContentClient()->set_renderer(saved_renderer_);
  }

bool WebRTCAudioDeviceTest::OnMessageReceived(const IPC::Message& message) {
  if (render_thread_) {
    IPC::ChannelProxy::MessageFilter* filter =
        render_thread_->audio_input_message_filter();
    if (filter->OnMessageReceived(message))
      return true;

    filter = render_thread_->audio_message_filter();
    if (filter->OnMessageReceived(message))
      return true;
  }

  if (audio_render_host_.get()) {
    bool message_was_ok = false;
    if (audio_render_host_->OnMessageReceived(message, &message_was_ok))
      return true;
  }

  if (audio_input_renderer_host_.get()) {
    bool message_was_ok = false;
    if (audio_input_renderer_host_->OnMessageReceived(message, &message_was_ok))
      return true;
  }

  bool handled ALLOW_UNUSED = true;
  bool message_is_ok = true;
  IPC_BEGIN_MESSAGE_MAP_EX(WebRTCAudioDeviceTest, message, message_is_ok)
    IPC_MESSAGE_HANDLER(ViewHostMsg_GetHardwareSampleRate,
                        OnGetHardwareSampleRate)
    IPC_MESSAGE_HANDLER(ViewHostMsg_GetHardwareInputSampleRate,
                        OnGetHardwareInputSampleRate)
    IPC_MESSAGE_HANDLER(ViewHostMsg_GetHardwareInputChannelCount,
                        OnGetHardwareInputChannelCount)
    IPC_MESSAGE_UNHANDLED(handled = false)
  IPC_END_MESSAGE_MAP_EX()

  EXPECT_TRUE(message_is_ok);

  return true;
}

void WebRTCAudioDeviceTest::CreateChannel(const char* name) {
  DCHECK(content::BrowserThread::CurrentlyOn(content::BrowserThread::IO));
  audio_render_host_ = new AudioRendererHost(
      resource_context_.get(), audio_manager_.get());
  audio_render_host_->OnChannelConnected(base::GetCurrentProcId());

  audio_input_renderer_host_ = new AudioInputRendererHost(
      resource_context_.get(), audio_manager_.get());
  audio_input_renderer_host_->OnChannelConnected(base::GetCurrentProcId());

  channel_.reset(new IPC::Channel(name, IPC::Channel::MODE_SERVER, this));
  ASSERT_TRUE(channel_->Connect());

  audio_render_host_->OnFilterAdded(channel_.get());
  audio_input_renderer_host_->OnFilterAdded(channel_.get());
}

  virtual void SetUp() {
     url_util::AddStandardScheme("tabcontentstest");
 
     old_browser_client_ = content::GetContentClient()->browser();
     content::GetContentClient()->set_browser(&browser_client_);
     RenderViewHostTestHarness::SetUp();
   }

void WebRTCAudioDeviceTest::WaitForMessageLoopCompletion(
    base::MessageLoopProxy* loop) {
  base::WaitableEvent* event = new base::WaitableEvent(false, false);
  loop->PostTask(FROM_HERE, base::Bind(&base::WaitableEvent::Signal,
                 base::Unretained(event)));
  if (event->TimedWait(base::TimeDelta::FromMilliseconds(
          TestTimeouts::action_max_timeout_ms()))) {
    delete event;
  } else {
    ADD_FAILURE() << "Failed to wait for message loop";
  }
}

  RenderViewHostManagerTestWebUIControllerFactory()
    : should_create_webui_(false) {
  }

   virtual void SetUp() {
     old_browser_client_ = content::GetContentClient()->browser();
     content::GetContentClient()->set_browser(&browser_client_);
     url_util::AddStandardScheme(kPrivilegedScheme);
    url_util::AddStandardScheme(chrome::kChromeUIScheme);
  }

void MockRenderThread::RemoveObserver(
    content::RenderProcessObserver* observer) {
}

 bool ShellContentClient::CanHandleWhileSwappedOut(const IPC::Message& msg) {
   return false;
 }

void RenderViewImpl::frameDetached(WebFrame* frame) {
  FOR_EACH_OBSERVER(RenderViewObserver, observers_, FrameDetached(frame));
}

   TabContentsTest()
       : ui_thread_(BrowserThread::UI, &message_loop_),
         old_browser_client_(NULL) {
   }

void RenderViewTest::LoadHTML(const char* html) {
  std::string url_str = "data:text/html;charset=utf-8,";
  url_str.append(html);
  GURL url(url_str);

  GetMainFrame()->loadRequest(WebURLRequest(url));

  ProcessPendingMessages();
}

std::string WebRTCAudioDeviceTest::GetTestDataPath(
    const FilePath::StringType& file_name) {
  FilePath path;
  EXPECT_TRUE(PathService::Get(content::DIR_TEST_DATA, &path));
  path = path.Append(file_name);
  EXPECT_TRUE(file_util::PathExists(path));
#ifdef OS_WIN
  return WideToUTF8(path.value());
#else
  return path.value();
#endif
}

WebGraphicsContext3D* RenderViewImpl::createGraphicsContext3D(
    const WebGraphicsContext3D::Attributes& attributes,
    bool direct) {
  if (!webview())
    return NULL;
  if (CommandLine::ForCurrentProcess()->HasSwitch(switches::kInProcessWebGL)) {
    return webkit::gpu::WebGraphicsContext3DInProcessImpl::CreateForWebView(
        attributes, direct);
  } else {
    int surface = direct ? surface_id() : 0;

    GURL url;
    if (webview()->mainFrame())
      url = GURL(webview()->mainFrame()->document().url());

    base::WeakPtr<WebGraphicsContext3DSwapBuffersClient> swap_client;
    if (direct)
      swap_client = AsWeakPtr();

    scoped_ptr<WebGraphicsContext3DCommandBufferImpl> context(
        new WebGraphicsContext3DCommandBufferImpl(
            surface, url, RenderThreadImpl::current(), swap_client));

    if (!context->Initialize(attributes))
      return NULL;
    context_is_web_graphics_context_3d_command_buffer_impl_ = true;
    return context.release();
  }
}

 bool ChromeWebUIControllerFactory::IsURLAcceptableForWebUI(
     content::BrowserContext* browser_context,
     const GURL& url) const {
  return UseWebUIForURL(browser_context, url) ||
      url.SchemeIs(chrome::kJavaScriptScheme) ||
      url.spec() == chrome::kAboutBlankURL ||
      url == GURL(chrome::kChromeUICrashURL) ||
      url == GURL(chrome::kChromeUIKillURL) ||
      url == GURL(chrome::kChromeUIHangURL) ||
      url == GURL(chrome::kChromeUIShorthangURL);
}

InfoBarDelegate::Type ExtensionDevToolsInfoBarDelegate::GetInfoBarType() const {
  return WARNING_TYPE;
}

void MockRenderProcess::ReleaseTransportDIB(TransportDIB* memory) {
  delete memory;
}

WebRTCAudioDeviceTest::WebRTCAudioDeviceTest()
    : render_thread_(NULL), audio_util_callback_(NULL) {
}

bool RenderViewImpl::MaybeLoadAlternateErrorPage(WebFrame* frame,
                                                 const WebURLError& error,
                                                 bool replace) {
  if (frame->parent())
    return false;

  int ec = error.reason;
  if (ec != net::ERR_NAME_NOT_RESOLVED &&
      ec != net::ERR_CONNECTION_FAILED &&
      ec != net::ERR_CONNECTION_REFUSED &&
      ec != net::ERR_ADDRESS_UNREACHABLE &&
      ec != net::ERR_CONNECTION_TIMED_OUT)
    return false;

  const GURL& error_page_url = GetAlternateErrorPageURL(error.unreachableURL,
      ec == net::ERR_NAME_NOT_RESOLVED ? DNS_ERROR : CONNECTION_ERROR);
  if (!error_page_url.is_valid())
    return false;

  frame->loadHTMLString(std::string(),
                        GURL(chrome::kUnreachableWebDataURL),
                        error.unreachableURL,
                        replace);

  DocumentState* document_state =
      DocumentState::FromDataSource(frame->provisionalDataSource());
  document_state->set_alt_error_page_fetcher(
      new AltErrorPageResourceFetcher(
          error_page_url, frame, error,
          base::Bind(&RenderViewImpl::AltErrorPageFinished,
                     base::Unretained(this))));
  return true;
}

void RenderViewImpl::DidHandleMouseEvent(const WebKit::WebMouseEvent& event) {
  FOR_EACH_OBSERVER(RenderViewObserver, observers_, DidHandleMouseEvent(event));
}

bool ChromeContentClient::SandboxPlugin(CommandLine* command_line,
                                        sandbox::TargetPolicy* policy) {
  std::wstring plugin_dll = command_line->
      GetSwitchValueNative(switches::kPluginPath);

  FilePath builtin_flash;
  if (!PathService::Get(chrome::FILE_FLASH_PLUGIN, &builtin_flash))
    return false;

  FilePath plugin_path(plugin_dll);
  if (plugin_path.BaseName() != builtin_flash.BaseName())
    return false;

  if (base::win::GetVersion() <= base::win::VERSION_XP ||
      CommandLine::ForCurrentProcess()->HasSwitch(
          switches::kDisableFlashSandbox)) {
    return false;
  }

  if (policy->AddRule(sandbox::TargetPolicy::SUBSYS_NAMED_PIPES,
                      sandbox::TargetPolicy::NAMEDPIPES_ALLOW_ANY,
                      L"\\\\.\\pipe\\chrome.*") != sandbox::SBOX_ALL_OK) {
    NOTREACHED();
    return false;
  }

  base::win::RegKey talk_key(HKEY_CURRENT_USER,
                             L"Software\\Google\\Google Talk Plugin",
                             KEY_READ);
  if (talk_key.Valid()) {
    string16 install_dir;
    if (talk_key.ReadValue(L"install_dir", &install_dir) == ERROR_SUCCESS) {
      if (install_dir[install_dir.size() - 1] != '\\')
        install_dir.append(L"\\*");
      else
        install_dir.append(L"*");
      if (policy->AddRule(sandbox::TargetPolicy::SUBSYS_FILES,
                          sandbox::TargetPolicy::FILES_ALLOW_READONLY,
                          install_dir.c_str()) != sandbox::SBOX_ALL_OK) {
        DVLOG(ERROR) << "Failed adding sandbox rule for Talk plugin";
      }
    }
    talk_key.Close();
  }

  if (LoadFlashBroker(plugin_path, command_line)) {
    policy->SetJobLevel(sandbox::JOB_UNPROTECTED, 0);
    policy->SetTokenLevel(sandbox::USER_RESTRICTED_SAME_ACCESS,
                          sandbox::USER_INTERACTIVE);
    if (base::win::GetVersion() == base::win::VERSION_VISTA) {
      ::ChangeWindowMessageFilter(WM_MOUSEWHEEL, MSGFLT_ADD);
      ::ChangeWindowMessageFilter(WM_APPCOMMAND, MSGFLT_ADD);
    }
    policy->SetIntegrityLevel(sandbox::INTEGRITY_LEVEL_LOW);
  } else {
    DLOG(WARNING) << "Failed to start flash broker";
    policy->SetJobLevel(sandbox::JOB_UNPROTECTED, 0);
    policy->SetTokenLevel(
        sandbox::USER_UNPROTECTED, sandbox::USER_UNPROTECTED);
  }

  return true;
}

RenderViewImpl::~RenderViewImpl() {
  history_page_ids_.clear();

  if (decrement_shared_popup_at_destruction_)
    shared_popup_counter_->data--;

  while (!file_chooser_completions_.empty()) {
    if (file_chooser_completions_.front()->completion) {
      file_chooser_completions_.front()->completion->didChooseFile(
          WebVector<WebString>());
    }
    file_chooser_completions_.pop_front();
  }

#if defined(OS_MACOSX)
  while (!fake_plugin_window_handles_.empty()) {
    DCHECK(*fake_plugin_window_handles_.begin());
    DestroyFakePluginWindowHandle(*fake_plugin_window_handles_.begin());
  }
#endif

#ifndef NDEBUG
  ViewMap* views = g_view_map.Pointer();
  for (ViewMap::iterator it = views->begin(); it != views->end(); ++it)
    DCHECK_NE(this, it->second) << "Failed to call Close?";
#endif

  media_stream_impl_ = NULL;

  FOR_EACH_OBSERVER(RenderViewObserver, observers_, RenderViewGone());
  FOR_EACH_OBSERVER(RenderViewObserver, observers_, OnDestruct());
}

void RenderViewTest::ClearHistory() {
  RenderViewImpl* impl = static_cast<RenderViewImpl*>(view_);
  impl->page_id_ = -1;
  impl->history_list_offset_ = -1;
  impl->history_list_length_ = 0;
  impl->history_page_ids_.clear();
}

void RenderViewImpl::didLoadResourceFromMemoryCache(
    WebFrame* frame, const WebURLRequest& request,
    const WebURLResponse& response) {
  GURL url(request.url());
  if (url.SchemeIs("data"))
    return;

  Send(new ViewHostMsg_DidLoadResourceFromMemoryCache(
      routing_id_,
      url,
      response.securityInfo(),
      request.httpMethod().utf8(),
      ResourceType::FromTargetType(request.targetType())));
}

void RenderViewImpl::OnDragTargetDrop(const gfx::Point& client_point,
                                      const gfx::Point& screen_point) {
  webview()->dragTargetDrop(client_point, screen_point);

  Send(new DragHostMsg_TargetDrop_ACK(routing_id_));
}

RenderProcessImpl::~RenderProcessImpl() {
#ifndef NDEBUG
  webkit_glue::CheckForLeaks();
#endif

  GetShutDownEvent()->Signal();
  ClearTransportDIBCache();
}

TestContentClient::~TestContentClient() {
}

  base::Closure NewUnderflowClosure() {
    return base::Bind(&AudioRendererImplTest::OnUnderflow,
                      base::Unretained(this));
  }

void ShellContentClient::AddNPAPIPlugins(
     webkit::npapi::PluginList* plugin_list) {
 }

  virtual void FrameNavigating(const std::string& url) {}

webkit::ppapi::PluginInstance* RenderViewImpl::GetBitmapForOptimizedPluginPaint(
    const gfx::Rect& paint_bounds,
    TransportDIB** dib,
    gfx::Rect* location,
    gfx::Rect* clip) {
  return pepper_delegate_.GetBitmapForOptimizedPluginPaint(
      paint_bounds, dib, location, clip);
}

bool RenderViewTest::SimulateElementClick(const std::string& element_id) {
  gfx::Rect bounds = GetElementBounds(element_id);
  if (bounds.IsEmpty())
    return false;
  WebMouseEvent mouse_event;
  mouse_event.type = WebInputEvent::MouseDown;
  mouse_event.button = WebMouseEvent::ButtonLeft;
  mouse_event.x = bounds.CenterPoint().x();
  mouse_event.y = bounds.CenterPoint().y();
  mouse_event.clickCount = 1;
  ViewMsg_HandleInputEvent input_event(0);
  scoped_ptr<IPC::Message> input_message(new ViewMsg_HandleInputEvent(0));
  input_message->WriteData(reinterpret_cast<const char*>(&mouse_event),
                           sizeof(WebMouseEvent));
  RenderViewImpl* impl = static_cast<RenderViewImpl*>(view_);
  impl->OnMessageReceived(*input_message);
  return true;
}

void RenderViewTest::SendNativeKeyEvent(
    const NativeWebKeyboardEvent& key_event) {
  SendWebKeyboardEvent(key_event);
}

  RenderViewHostManagerTestBrowserClient() {}

bool ExtensionDevToolsClientHost::MatchesContentsAndExtensionId(
    WebContents* web_contents,
    const std::string& extension_id) {
  return web_contents == web_contents_ && extension_id_ == extension_id;
}

bool DebuggerFunction::InitClientHost() {
  if (!InitTabContents())
    return false;

  client_host_ = AttachedClientHosts::GetInstance()->Lookup(contents_);

  if (!client_host_ ||
      !client_host_->MatchesContentsAndExtensionId(contents_,
                                                   GetExtension()->id())) {
    error_ = ExtensionErrorUtils::FormatErrorMessage(
        keys::kNotAttachedError,
        base::IntToString(tab_id_));
    return false;
  }
  return true;
}

WebUIController* NewWebUI<ExtensionWebUI>(content::WebUI* web_ui,
                                          const GURL& url) {
  return new ExtensionWebUI(web_ui, url);
}

WebFrame* RenderViewTest::GetMainFrame() {
  return view_->GetWebView()->mainFrame();
}

    virtual ~Delegate() {}

ExtensionDevToolsInfoBarDelegate::~ExtensionDevToolsInfoBarDelegate() {
  if (client_host_)
      client_host_->InfoBarDestroyed();
}

void RenderViewImpl::OnDragTargetDragEnter(const WebDropData& drop_data,
                                           const gfx::Point& client_point,
                                           const gfx::Point& screen_point,
                                           WebDragOperationsMask ops) {
  WebDragOperation operation = webview()->dragTargetDragEnter(
      drop_data.ToDragData(),
      client_point,
      screen_point,
      ops);

  Send(new DragHostMsg_UpdateDragCursor(routing_id_, operation));
}

IPC::SyncChannel* MockRenderThread::GetChannel() {
  return NULL;
}

void RenderViewTest::TearDown() {
  GetMainFrame()->collectGarbage();
  GetMainFrame()->collectGarbage();

  ProcessPendingMessages();

  render_thread_->SendCloseMessage();
  view_ = NULL;
  mock_process_.reset();

  msg_loop_.RunAllPending();

  WebKit::shutdown();

  mock_keyboard_.reset();

  platform_->PlatformUninitialize();
  platform_.reset();
  params_.reset();
  command_line_.reset();
}

SendCommandDebuggerFunction::SendCommandDebuggerFunction() {}

void RenderViewTest::SetUp() {
  if (!GetContentClient()->renderer())
    GetContentClient()->set_renderer(&mock_content_renderer_client_);

  if (!render_thread_.get())
     render_thread_.reset(new MockRenderThread());
   render_thread_->set_routing_id(kRouteId);
   render_thread_->set_surface_id(kSurfaceId);
 
   command_line_.reset(new CommandLine(CommandLine::NO_PROGRAM));
   params_.reset(new content::MainFunctionParams(*command_line_));
  platform_.reset(new RendererMainPlatformDelegate(*params_));
  platform_->PlatformInitialize();

  webkit_glue::SetJavaScriptFlags(" --expose-gc");
  WebKit::initialize(&webkit_platform_support_);

  mock_process_.reset(new MockRenderProcess);

  RenderViewImpl* view = RenderViewImpl::Create(
      0,
      kOpenerId,
      content::RendererPreferences(),
      WebPreferences(),
      new SharedRenderViewCounter(0),
      kRouteId,
      kSurfaceId,
      kInvalidSessionStorageNamespaceId,
      string16(),
      1,
      WebKit::WebScreenInfo());
  view->AddRef();
  view_ = view;

  mock_keyboard_.reset(new MockKeyboard());
}

  virtual bool OnMessageReceived(const IPC::Message& message) {
      NOTIMPLEMENTED();
      return true;
  }

int WebRTCTransportImpl::SendRTCPPacket(int channel, const void* data,
                                        int len) {
  return network_->ReceivedRTCPPacket(channel, data, len);
}

RenderViewTest::RenderViewTest() : view_(NULL) {
}

 void RenderViewImpl::OnAllowBindings(int enabled_bindings_flags) {
   enabled_bindings_ |= enabled_bindings_flags;
 }

  void TestDomOperationResponse(const std::string& json_string) {
    if (enabled())
      CommandReceived();
  }

gfx::Size RenderViewImpl::GetSize() {
  return size();
}

   virtual void TearDown() {
     content::GetContentClient()->set_browser(old_browser_client_);
   }

skia::PlatformCanvas* RenderProcessImpl::GetDrawingCanvas(
    TransportDIB** memory, const gfx::Rect& rect) {
  int width = rect.width();
  int height = rect.height();
  const size_t stride = skia::PlatformCanvas::StrideForWidth(rect.width());
#if defined(OS_LINUX) || defined(OS_OPENBSD)
  const size_t max_size = base::SysInfo::MaxSharedMemorySize();
#else
  const size_t max_size = 0;
#endif

  if ((max_size != 0) && (height * stride > max_size))
    height = max_size / stride;

  const size_t size = height * stride;

  if (!GetTransportDIBFromCache(memory, size)) {
    *memory = CreateTransportDIB(size);
    if (!*memory)
      return NULL;
  }

  return (*memory)->GetPlatformCanvas(width, height);
}

void RenderViewImpl::runModalAlertDialog(WebFrame* frame,
                                         const WebString& message) {
  RunJavaScriptMessage(ui::JAVASCRIPT_MESSAGE_TYPE_ALERT,
                       message,
                       string16(),
                       frame->document().url(),
                       NULL);
}

   virtual bool UseInProcessPlugins() const { return false; }

WebRTCTransportImpl::~WebRTCTransportImpl() {}

void RenderViewImpl::SyncSelectionIfRequired() {
  WebFrame* frame = webview()->focusedFrame();
  if (!frame)
    return;

  string16 text;
  size_t offset;
  ui::Range range;

  if (pepper_delegate_.IsPluginFocused()) {
    pepper_delegate_.GetSurroundingText(&text, &range);
    offset = 0; // Pepper API does not support offset reporting.
  } else {
    size_t location, length;
    if (!webview()->caretOrSelectionRange(&location, &length))
      return;

    range = ui::Range(location, location + length);

    if (webview()->textInputType() != WebKit::WebTextInputTypeNone) {
      if (location > kExtraCharsBeforeAndAfterSelection)
        offset = location - kExtraCharsBeforeAndAfterSelection;
      else
        offset = 0;
      length = location + length - offset + kExtraCharsBeforeAndAfterSelection;
      WebRange webrange = WebRange::fromDocumentRange(frame, offset, length);
      if (!webrange.isNull())
        text = WebRange::fromDocumentRange(frame, offset, length).toPlainText();
    } else {
      offset = location;
      text = frame->selectionAsText();
      range.set_end(range.start() + text.length());
    }
  }

  if (selection_text_offset_ != offset ||
      selection_range_ != range ||
      selection_text_ != text) {
    selection_text_ = text;
    selection_text_offset_ = offset;
    selection_range_ = range;
    Send(new ViewHostMsg_SelectionChanged(routing_id_, text, offset, range));
  }
}

 void RenderViewImpl::OnSetWebUIProperty(const std::string& name,
                                        const std::string& value) {
  if (enabled_bindings_ & content::BINDINGS_POLICY_WEB_UI)
    GetWebUIBindings()->SetProperty(name, value);
  else
    NOTREACHED() << "WebUI bindings not enabled.";
}

void RenderViewTest::SetFocused(const WebKit::WebNode& node) {
  RenderViewImpl* impl = static_cast<RenderViewImpl*>(view_);
  impl->focusedNodeChanged(node);
}

SendCommandDebuggerFunction::~SendCommandDebuggerFunction() {}

void ExtensionDevToolsClientHost::Observe(
    int type,
    const content::NotificationSource& source,
    const content::NotificationDetails& details) {
  DCHECK(type == chrome::NOTIFICATION_EXTENSION_UNLOADED);
  std::string id =
      content::Details<UnloadedExtensionInfo>(details)->extension->id();
  if (id == extension_id_)
      Close();
}

void RenderViewImpl::OnSwapOut(const ViewMsg_SwapOut_Params& params) {
  OnStop();

  if (!is_swapped_out_) {

    SyncNavigationState();

    webview()->dispatchUnloadEvent();

    SetSwappedOut(true);

    WebURLRequest request(GURL("about:swappedout"));
    webview()->mainFrame()->loadRequest(request);
  }

  Send(new ViewHostMsg_SwapOut_ACK(routing_id_, params));
}

WebKit::WebPeerConnectionHandler* RenderViewImpl::CreatePeerConnectionHandler(
    WebKit::WebPeerConnectionHandlerClient* client) {
  const CommandLine* cmd_line = CommandLine::ForCurrentProcess();
  if (!cmd_line->HasSwitch(switches::kEnableMediaStream))
    return NULL;
  EnsureMediaStreamImpl();
  if (!media_stream_impl_.get())
    return NULL;
  return media_stream_impl_->CreatePeerConnectionHandler(client);
}

 bool TestContentClient::CanHandleWhileSwappedOut(const IPC::Message& msg) {
   return false;
}

WebPlugin* ChromeContentRendererClient::CreatePlugin(
    content::RenderView* render_view,
    WebFrame* frame,
    const WebPluginParams& original_params,
    const ChromeViewHostMsg_GetPluginInfo_Status& status,
    const webkit::WebPluginInfo& plugin,
    const std::string& actual_mime_type) {
  ChromeViewHostMsg_GetPluginInfo_Status::Value status_value = status.value;
  GURL url(original_params.url);
  std::string orig_mime_type = original_params.mimeType.utf8();
  PluginPlaceholder* placeholder = NULL;
  if (status_value == ChromeViewHostMsg_GetPluginInfo_Status::kNotFound) {
    MissingPluginReporter::GetInstance()->ReportPluginMissing(
        orig_mime_type, url);
    placeholder = PluginPlaceholder::CreateMissingPlugin(
        render_view, frame, original_params);
  } else {
    scoped_ptr<webkit::npapi::PluginGroup> group(
        webkit::npapi::PluginList::Singleton()->GetPluginGroup(plugin));
    string16 name = group->GetGroupName();

    WebPluginParams params(original_params);
    for (size_t i = 0; i < plugin.mime_types.size(); ++i) {
      if (plugin.mime_types[i].mime_type == actual_mime_type) {
        AppendParams(plugin.mime_types[i].additional_param_names,
                     plugin.mime_types[i].additional_param_values,
                     &params.attributeNames,
                     &params.attributeValues);
        break;
      }
    }
    if (params.mimeType.isNull() && (actual_mime_type.size() > 0)) {
      params.mimeType = WebString::fromUTF8(actual_mime_type.c_str());
    }

    ContentSettingsObserver* observer =
        ContentSettingsObserver::Get(render_view);

    bool is_nacl_plugin =
        plugin.name ==
            ASCIIToUTF16(chrome::ChromeContentClient::kNaClPluginName);
    ContentSettingsType content_type =
        is_nacl_plugin ? CONTENT_SETTINGS_TYPE_JAVASCRIPT :
                         CONTENT_SETTINGS_TYPE_PLUGINS;

    if ((status_value ==
             ChromeViewHostMsg_GetPluginInfo_Status::kUnauthorized ||
         status_value == ChromeViewHostMsg_GetPluginInfo_Status::kClickToPlay ||
         status_value == ChromeViewHostMsg_GetPluginInfo_Status::kBlocked) &&
        observer->plugins_temporarily_allowed()) {
      status_value = ChromeViewHostMsg_GetPluginInfo_Status::kAllowed;
    }

    switch (status_value) {
      case ChromeViewHostMsg_GetPluginInfo_Status::kNotFound: {
        NOTREACHED();
        break;
      }
      case ChromeViewHostMsg_GetPluginInfo_Status::kAllowed: {
        const char* kNaClMimeType = "application/x-nacl";
        bool is_nacl_mime_type = actual_mime_type == kNaClMimeType;
        bool is_nacl_unrestricted;
        if (is_nacl_plugin) {
          is_nacl_unrestricted = CommandLine::ForCurrentProcess()->HasSwitch(
              switches::kEnableNaCl);
        } else {
          is_nacl_unrestricted = true;
        }
        if (is_nacl_plugin || is_nacl_mime_type) {
          GURL manifest_url = is_nacl_mime_type ?
              url : GetNaClContentHandlerURL(actual_mime_type, plugin);
          const Extension* extension =
              extension_dispatcher_->extensions()->GetExtensionOrAppByURL(
                  ExtensionURLInfo(manifest_url));
          bool is_extension_from_webstore =
              extension && extension->from_webstore();
          bool is_extension_unrestricted = extension &&
              (extension->location() == Extension::COMPONENT ||
              extension->location() == Extension::LOAD);
          GURL top_url = frame->top()->document().url();
          if (!IsNaClAllowed(manifest_url,
                             top_url,
                             is_nacl_unrestricted,
                             is_extension_unrestricted,
                             is_extension_from_webstore,
                             &params)) {
            frame->addMessageToConsole(
                WebConsoleMessage(
                    WebConsoleMessage::LevelError,
                    "Only unpacked extensions and apps installed from the "
                    "Chrome Web Store can load NaCl modules without enabling "
                    "Native Client in about:flags."));
            placeholder = PluginPlaceholder::CreateBlockedPlugin(
                render_view, frame, params, plugin, name,
                IDR_BLOCKED_PLUGIN_HTML, IDS_PLUGIN_BLOCKED);
            break;
          }
        }

        if (prerender::PrerenderHelper::IsPrerendering(render_view)) {
          placeholder = PluginPlaceholder::CreateBlockedPlugin(
              render_view, frame, params, plugin, name,
              IDR_CLICK_TO_PLAY_PLUGIN_HTML, IDS_PLUGIN_LOAD);
          placeholder->set_blocked_for_prerendering(true);
          placeholder->set_allow_loading(true);
          break;
        }

        return render_view->CreatePlugin(frame, plugin, params);
      }
      case ChromeViewHostMsg_GetPluginInfo_Status::kDisabled: {
        placeholder = PluginPlaceholder::CreateBlockedPlugin(
            render_view, frame, params, plugin, name,
            IDR_DISABLED_PLUGIN_HTML, IDS_PLUGIN_DISABLED);
        break;
      }
      case ChromeViewHostMsg_GetPluginInfo_Status::kOutdatedBlocked: {
#if defined(ENABLE_PLUGIN_INSTALLATION)
        placeholder = PluginPlaceholder::CreateBlockedPlugin(
            render_view, frame, params, plugin, name,
            IDR_BLOCKED_PLUGIN_HTML, IDS_PLUGIN_OUTDATED);
        placeholder->set_allow_loading(true);
        render_view->Send(new ChromeViewHostMsg_BlockedOutdatedPlugin(
            render_view->GetRoutingID(), placeholder->CreateRoutingId(),
            group->identifier()));
#else
        NOTREACHED();
#endif
        break;
      }
      case ChromeViewHostMsg_GetPluginInfo_Status::kOutdatedDisallowed: {
        placeholder = PluginPlaceholder::CreateBlockedPlugin(
            render_view, frame, params, plugin, name,
            IDR_BLOCKED_PLUGIN_HTML, IDS_PLUGIN_OUTDATED);
        break;
      }
      case ChromeViewHostMsg_GetPluginInfo_Status::kUnauthorized: {
        placeholder = PluginPlaceholder::CreateBlockedPlugin(
            render_view, frame, params, plugin, name,
            IDR_BLOCKED_PLUGIN_HTML, IDS_PLUGIN_NOT_AUTHORIZED);
        placeholder->set_allow_loading(true);
        render_view->Send(new ChromeViewHostMsg_BlockedUnauthorizedPlugin(
            render_view->GetRoutingID(), group->GetGroupName()));
        break;
      }
      case ChromeViewHostMsg_GetPluginInfo_Status::kClickToPlay: {
        placeholder = PluginPlaceholder::CreateBlockedPlugin(
            render_view, frame, params, plugin, name,
            IDR_CLICK_TO_PLAY_PLUGIN_HTML, IDS_PLUGIN_LOAD);
        placeholder->set_allow_loading(true);
        RenderThread::Get()->RecordUserMetrics("Plugin_ClickToPlay");
        observer->DidBlockContentType(content_type, group->identifier());
        break;
      }
      case ChromeViewHostMsg_GetPluginInfo_Status::kBlocked: {
        placeholder = PluginPlaceholder::CreateBlockedPlugin(
            render_view, frame, params, plugin, name,
            IDR_BLOCKED_PLUGIN_HTML, IDS_PLUGIN_BLOCKED);
        placeholder->set_allow_loading(true);
        RenderThread::Get()->RecordUserMetrics("Plugin_Blocked");
        observer->DidBlockContentType(content_type, group->identifier());
        break;
      }
    }
  }
  placeholder->SetStatus(status);
  return placeholder->plugin();
}

void MockRenderThread::SendCloseMessage() {
  ViewMsg_Close msg(routing_id_);
  widget_->OnMessageReceived(msg);
}

void RenderViewImpl::willSendRequest(WebFrame* frame,
                                     unsigned identifier,
                                     WebURLRequest& request,
                                     const WebURLResponse& redirect_response) {
  WebFrame* top_frame = frame->top();
  if (!top_frame)
    top_frame = frame;
  WebDataSource* provisional_data_source = top_frame->provisionalDataSource();
  WebDataSource* top_data_source = top_frame->dataSource();
  WebDataSource* data_source =
      provisional_data_source ? provisional_data_source : top_data_source;

  GURL request_url(request.url());
  GURL new_url;
  if (content::GetContentClient()->renderer()->WillSendRequest(
          frame, request_url, &new_url)) {
    request.setURL(WebURL(new_url));
  }

  content::PageTransition transition_type = content::PAGE_TRANSITION_LINK;
  DocumentState* document_state = DocumentState::FromDataSource(data_source);
  NavigationState* navigation_state = document_state->navigation_state();
  if (document_state) {
    if (document_state->is_cache_policy_override_set())
      request.setCachePolicy(document_state->cache_policy_override());
    transition_type = navigation_state->transition_type();
  }

  request.setExtraData(
      new RequestExtraData(frame->referrerPolicy(),
                           (frame == top_frame),
                           frame->identifier(),
                           frame->parent() == top_frame,
                           frame->parent() ? frame->parent()->identifier() : -1,
                           transition_type,
                           navigation_state->transferred_request_child_id(),
                           navigation_state->transferred_request_request_id()));

  DocumentState* top_document_state =
      DocumentState::FromDataSource(top_data_source);
  if (top_document_state &&
      (request.targetType() == WebURLRequest::TargetIsPrefetch ||
       request.targetType() == WebURLRequest::TargetIsPrerender))
    top_document_state->set_was_prefetcher(true);

  request.setRequestorID(routing_id_);
  request.setHasUserGesture(frame->isProcessingUserGesture());

  if (!renderer_preferences_.enable_referrers)
    request.clearHTTPHeaderField("Referer");
}

   SiteInstanceTestBrowserClient()
      : privileged_process_id_(-1) {
  }

  TestSiteInstance(BrowsingInstance* browsing_instance, int* delete_counter)
    : SiteInstanceImpl(browsing_instance), delete_counter_(delete_counter) {}

void RenderViewTest::ExecuteJavaScript(const char* js) {
  GetMainFrame()->executeScript(WebScriptSource(WebString::fromUTF8(js)));
}

void MockRenderThread::AddObserver(content::RenderProcessObserver* observer) {
}

void RenderViewImpl::willSubmitForm(WebFrame* frame,
                                    const WebFormElement& form) {
  DocumentState* document_state =
      DocumentState::FromDataSource(frame->provisionalDataSource());
  NavigationState* navigation_state = document_state->navigation_state();

  if (navigation_state->transition_type() == content::PAGE_TRANSITION_LINK)
    navigation_state->set_transition_type(content::PAGE_TRANSITION_FORM_SUBMIT);

  WebSearchableFormData web_searchable_form_data(form);
  document_state->set_searchable_form_url(web_searchable_form_data.url());
  document_state->set_searchable_form_encoding(
      web_searchable_form_data.encoding().utf8());
  PasswordForm* password_form_data =
      PasswordFormDomManager::CreatePasswordForm(form);
  document_state->set_password_form_data(password_form_data);

  if (password_form_data) {
    DocumentState* old_document_state =
        DocumentState::FromDataSource(frame->dataSource());
    if (old_document_state) {
      PasswordForm* old_form_data = old_document_state->password_form_data();
      if (old_form_data && old_form_data->action == password_form_data->action)
        password_form_data->password_value = old_form_data->password_value;
    }
  }

  FOR_EACH_OBSERVER(
      RenderViewObserver, observers_, WillSubmitForm(frame, form));
}

void WebRTCAudioDeviceTest::UninitializeIOThread() {
  resource_context_.reset();

  audio_manager_.reset();
  test_request_context_ = NULL;
  initialize_com_.reset();
}

void RenderViewImpl::EvaluateScript(const string16& frame_xpath,
                                    const string16& jscript,
                                    int id,
                                    bool notify_result) {
  v8::Handle<v8::Value> result;
  WebFrame* web_frame = GetChildFrame(frame_xpath);
  if (web_frame)
    result = web_frame->executeScriptAndReturnValue(WebScriptSource(jscript));
  if (notify_result) {
    ListValue list;
    if (!result.IsEmpty() && web_frame) {
      v8::HandleScope handle_scope;
      v8::Local<v8::Context> context = web_frame->mainWorldScriptContext();
      v8::Context::Scope context_scope(context);
      V8ValueConverterImpl converter;
      converter.set_allow_date(true);
      converter.set_allow_regexp(true);
      list.Set(0, converter.FromV8Value(result, context));
    } else {
      list.Set(0, Value::CreateNullValue());
    }
    Send(new ViewHostMsg_ScriptEvalResponse(routing_id_, id, list));
  }
}

TransportDIB* RenderProcessImpl::CreateTransportDIB(size_t size) {
#if defined(OS_WIN) || defined(OS_LINUX) || \
    defined(OS_OPENBSD) || defined(OS_ANDROID)
  return TransportDIB::Create(size, transport_dib_next_sequence_number_++);
#elif defined(OS_MACOSX)
  TransportDIB::Handle handle;
  IPC::Message* msg = new ViewHostMsg_AllocTransportDIB(size, true, &handle);
  if (!main_thread()->Send(msg))
    return NULL;
  if (handle.fd < 0)
    return NULL;
  return TransportDIB::Map(handle);
#endif  // defined(OS_MACOSX)
}

ExtensionDevToolsClientHost::ExtensionDevToolsClientHost(
    WebContents* web_contents,
    const std::string& extension_id,
    const std::string& extension_name,
    int tab_id)
    : web_contents_(web_contents),
      extension_id_(extension_id),
      tab_id_(tab_id),
      last_request_id_(0),
      infobar_delegate_(NULL) {
  AttachedClientHosts::GetInstance()->Add(this);

  Profile* profile =
      Profile::FromBrowserContext(web_contents_->GetBrowserContext());
  registrar_.Add(this, chrome::NOTIFICATION_EXTENSION_UNLOADED,
                 content::Source<Profile>(profile));

  DevToolsAgentHost* agent = DevToolsAgentHostRegistry::GetDevToolsAgentHost(
      web_contents_->GetRenderViewHost());
  DevToolsManager::GetInstance()->RegisterDevToolsClientHostFor(agent, this);

  TabContentsWrapper* wrapper =
      TabContentsWrapper::GetCurrentWrapperForContents(web_contents_);
  infobar_delegate_ = new ExtensionDevToolsInfoBarDelegate(
      wrapper->infobar_tab_helper(), extension_name, this);
  wrapper->infobar_tab_helper()->AddInfoBar(infobar_delegate_);
}

  RenderViewImpl* view() {
    return static_cast<RenderViewImpl*>(view_);
  }

void MockRenderThread::OnDuplicateSection(
    base::SharedMemoryHandle renderer_handle,
    base::SharedMemoryHandle* browser_handle) {
  *browser_handle = renderer_handle;
}

bool ChromeContentRendererClient::WillSendRequest(WebKit::WebFrame* frame,
                                                  const GURL& url,
                                                  GURL* new_url) {
  if (url.SchemeIs(chrome::kExtensionScheme) &&
      !ExtensionResourceRequestPolicy::CanRequestResource(
          url,
          frame,
          extension_dispatcher_->extensions())) {
    *new_url = GURL("chrome-extension://invalid/");
    return true;
  }

  return false;
}

  virtual void TearDown() {
    mock_process_.reset();
  }

gfx::Rect RenderViewTest::GetElementBounds(const std::string& element_id) {
  std::vector<std::string> params;
  params.push_back(element_id);
  std::string script =
      ReplaceStringPlaceholders(kGetCoordinatesScript, params, NULL);

  v8::HandleScope handle_scope;
  v8::Handle<v8::Value>  value = GetMainFrame()->executeScriptAndReturnValue(
      WebScriptSource(WebString::fromUTF8(script)));
  if (value.IsEmpty() || !value->IsArray())
    return gfx::Rect();

  v8::Handle<v8::Array> array = value.As<v8::Array>();
  if (array->Length() != 4)
    return gfx::Rect();
  std::vector<int> coords;
  for (int i = 0; i < 4; ++i) {
    v8::Handle<v8::Number> index = v8::Number::New(i);
    v8::Local<v8::Value> value = array->Get(index);
    if (value.IsEmpty() || !value->IsInt32())
      return gfx::Rect();
    coords.push_back(value->Int32Value());
  }
  return gfx::Rect(coords[0], coords[1], coords[2], coords[3]);
}

  void OnProceed() {
    if (state_)
      *state_ = OKED;
  }

void RenderViewImpl::PluginFocusChanged(bool focused, int plugin_id) {
  IPC::Message* msg = new ViewHostMsg_PluginFocusChanged(routing_id(),
                                                         focused, plugin_id);
  Send(msg);
}

  void NavigateActiveAndCommit(const GURL& url) {
    controller().LoadURL(
        url, content::Referrer(), content::PAGE_TRANSITION_LINK, std::string());
    TestRenderViewHost* old_rvh = test_rvh();

    if (old_rvh != active_rvh())
      old_rvh->SendShouldCloseACK(true);

    int32 max_page_id = contents()->GetMaxPageIDForSiteInstance(
        active_rvh()->GetSiteInstance());
    active_test_rvh()->SendNavigate(max_page_id + 1, url);

    if (old_rvh != active_rvh())
      old_rvh->OnSwapOutACK();
  }

void TestContentClient::SetGpuInfo(const content::GPUInfo& gpu_info) {
}

string16 ShellContentClient::GetLocalizedString(int message_id) const {
  return string16();
}

  void TestRenderViewGone(base::TerminationStatus status, int error_code) {
    RenderViewGone(GetRenderViewHostForTesting(), status, error_code);
  }

void WebRTCAudioDeviceTest::OnGetHardwareInputChannelCount(uint32* channels) {
  EXPECT_TRUE(audio_util_callback_);
  *channels = audio_util_callback_ ?
      audio_util_callback_->GetAudioInputHardwareChannelCount(
          AudioManagerBase::kDefaultDeviceId) : 0;
}

MessageLoop* MockRenderThread::GetMessageLoop() {
  return NULL;
}

ShellContentClient::~ShellContentClient() {
}

void TestContentClient::AddPepperPlugins(
    std::vector<content::PepperPluginInfo>* plugins) {
}

void RenderViewImpl::UpdateSessionHistory(WebFrame* frame) {
  if (page_id_ == -1)
    return;

  const WebHistoryItem& item =
      webview()->mainFrame()->previousHistoryItem();
  if (item.isNull())
    return;

  Send(new ViewHostMsg_UpdateState(
      routing_id_, page_id_, webkit_glue::HistoryItemToString(item)));
}

  bool is_showing() const {
    return static_cast<content::TestRenderWidgetHostView*>(
        GetRenderViewHostForTesting()->GetView())->is_showing();
  }

AttachDebuggerFunction::AttachDebuggerFunction() {}

WebRTCTransportImpl::WebRTCTransportImpl(webrtc::VoENetwork* network)
    : network_(network) {
}

void MockRenderThread::SetIdleNotificationDelayInMs(
    int64 idle_notification_delay_in_ms) {
}

int RenderViewImpl::GetPageId()  {
  return page_id_;
}

void ExtensionDevToolsClientHost::SendDetachedEvent() {
  Profile* profile =
      Profile::FromBrowserContext(web_contents_->GetBrowserContext());
  if (profile != NULL && profile->GetExtensionEventRouter()) {
    ListValue args;
    args.Append(CreateDebuggeeId(tab_id_));

    std::string json_args;
    base::JSONWriter::Write(&args, false, &json_args);

    profile->GetExtensionEventRouter()->DispatchEventToExtension(
        extension_id_, keys::kOnDetach, json_args, profile, GURL());
  }
}

  void CommandReceived() {
    command_received_count_++;
  }

bool TestContentClient::SandboxPlugin(CommandLine* command_line,
                                      sandbox::TargetPolicy* policy) {
  return false;
}

RenderViewImpl* RenderViewImpl::Create(
    gfx::NativeViewId parent_hwnd,
    int32 opener_id,
    const content::RendererPreferences& renderer_prefs,
    const WebPreferences& webkit_prefs,
    SharedRenderViewCounter* counter,
    int32 routing_id,
    int32 surface_id,
    int64 session_storage_namespace_id,
    const string16& frame_name,
    int32 next_page_id,
    const WebKit::WebScreenInfo& screen_info) {
  DCHECK(routing_id != MSG_ROUTING_NONE);
  return new RenderViewImpl(
      parent_hwnd,
      opener_id,
      renderer_prefs,
      webkit_prefs,
      counter,
      routing_id,
      surface_id,
      session_storage_namespace_id,
      frame_name,
      next_page_id,
      screen_info);
}

WebUIController* NewWebUI<AboutUI>(content::WebUI* web_ui, const GURL& url) {
  return new AboutUI(web_ui, url.host());
}

void WebRTCAudioDeviceTest::WaitForAudioManagerCompletion() {
  if (audio_manager_.get())
    WaitForMessageLoopCompletion(audio_manager_->GetMessageLoop());
}

  ExtensionDevToolsClientHost* Lookup(WebContents* contents) {
    for (std::set<DevToolsClientHost*>::iterator it = client_hosts_.begin();
         it != client_hosts_.end(); ++it) {
      DevToolsAgentHost* agent_host =
          DevToolsManager::GetInstance()->GetDevToolsAgentHostFor(*it);
      if (!agent_host)
        continue;
      content::RenderViewHost* rvh =
          DevToolsAgentHostRegistry::GetRenderViewHost(agent_host);
      if (rvh && rvh->GetDelegate() &&
          rvh->GetDelegate()->GetAsWebContents() == contents)
        return static_cast<ExtensionDevToolsClientHost*>(*it);
    }
    return NULL;
  }

   virtual void TearDown() {
     content::GetContentClient()->set_browser(old_browser_client_);
     RenderViewHostTestHarness::TearDown();
   }

  void Add(ExtensionDevToolsClientHost* client_host) {
    client_hosts_.insert(client_host);
  }

GURL RenderViewImpl::GetAlternateErrorPageURL(const GURL& failed_url,
                                              ErrorPageType error_type) {
  if (failed_url.SchemeIsSecure()) {
    return GURL();
  }

  if (!alternate_error_page_url_.is_valid())
    return GURL();

  GURL::Replacements remove_params;
  remove_params.ClearUsername();
  remove_params.ClearPassword();
  remove_params.ClearQuery();
  remove_params.ClearRef();
  const GURL url_to_send = failed_url.ReplaceComponents(remove_params);
  std::string spec_to_send = url_to_send.spec();
  if (failed_url.has_query())
      spec_to_send.append("?");

  std::string params(alternate_error_page_url_.query());
  params.append("&url=");
  params.append(net::EscapeQueryParamValue(spec_to_send, true));
  params.append("&sourceid=chrome");
  params.append("&error=");
  switch (error_type) {
    case DNS_ERROR:
      params.append("dnserror");
      break;

    case HTTP_404:
      params.append("http404");
      break;

    case CONNECTION_ERROR:
      params.append("connectionfailure");
      break;

    default:
      NOTREACHED() << "unknown ErrorPageType";
  }

  GURL::Replacements link_doctor_params;
  link_doctor_params.SetQueryStr(params);
  GURL url = alternate_error_page_url_.ReplaceComponents(link_doctor_params);
  return url;
}

void MockRenderThread::WidgetHidden() {
}

void RenderViewImpl::didCommitProvisionalLoad(WebFrame* frame,
                                              bool is_new_navigation) {
  DocumentState* document_state =
      DocumentState::FromDataSource(frame->dataSource());
  NavigationState* navigation_state = document_state->navigation_state();

  if (document_state->commit_load_time().is_null())
    document_state->set_commit_load_time(Time::Now());

  if (is_new_navigation) {
    UpdateSessionHistory(frame);

    page_id_ = next_page_id_++;

    if (GetLoadingUrl(frame) != GURL("about:swappedout")) {
      history_list_offset_++;
      if (history_list_offset_ >= content::kMaxSessionHistoryEntries)
        history_list_offset_ = content::kMaxSessionHistoryEntries - 1;
      history_list_length_ = history_list_offset_ + 1;
      history_page_ids_.resize(history_list_length_, -1);
      history_page_ids_[history_list_offset_] = page_id_;
    }
  } else {
    if (navigation_state->pending_page_id() != -1 &&
        navigation_state->pending_page_id() != page_id_ &&
        !navigation_state->request_committed()) {
      UpdateSessionHistory(frame);
      page_id_ = navigation_state->pending_page_id();

      history_list_offset_ = navigation_state->pending_history_list_offset();

      DCHECK(history_list_length_ <= 0 ||
             history_list_offset_ < 0 ||
             history_list_offset_ >= history_list_length_ ||
             history_page_ids_[history_list_offset_] == page_id_);
    }
  }

  FOR_EACH_OBSERVER(RenderViewObserver, observers_,
                    DidCommitProvisionalLoad(frame, is_new_navigation));

  navigation_state->set_request_committed(true);

  UpdateURL(frame);

  completed_client_redirect_src_ = Referrer();

  UpdateEncoding(frame, frame->view()->pageEncoding().utf8());
}

void RenderViewImpl::didClearWindowObject(WebFrame* frame) {
  FOR_EACH_OBSERVER(RenderViewObserver, observers_,
                    DidClearWindowObject(frame));

  GURL frame_url = frame->document().url();
  if ((enabled_bindings_ & content::BINDINGS_POLICY_WEB_UI) &&
      (frame_url.SchemeIs(chrome::kChromeUIScheme) ||
      frame_url.SchemeIs(chrome::kDataScheme))) {
    GetWebUIBindings()->BindToJavascript(frame, "chrome");
  }

  if (enabled_bindings_ & content::BINDINGS_POLICY_DOM_AUTOMATION) {
    if (!dom_automation_controller_.get())
      dom_automation_controller_.reset(new DomAutomationController());
    dom_automation_controller_->set_message_sender(
        static_cast<content::RenderView*>(this));
    dom_automation_controller_->set_routing_id(routing_id());
    dom_automation_controller_->BindToJavascript(frame,
                                                 "domAutomationController");
  }
}

   SiteInstanceTest()
       : ui_thread_(BrowserThread::UI, &message_loop_),
         old_browser_client_(NULL) {
   }

  virtual ~WebRTCMockRenderProcess() {}

void ShellContentClient::SetActiveURL(const GURL& url) {
}

  virtual ~AudioRendererImplTest() {}

void MockRenderThread::SetOutgoingMessageFilter(
    IPC::ChannelProxy::OutgoingMessageFilter* filter) {
}

ExtensionDevToolsClientHost::~ExtensionDevToolsClientHost() {
  if (infobar_delegate_) {
    infobar_delegate_->ClearClientHost();
    TabContentsWrapper* wrapper =
        TabContentsWrapper::GetCurrentWrapperForContents(web_contents_);
    InfoBarTabHelper* helper = wrapper->infobar_tab_helper();
    if (helper)
      helper->RemoveInfoBar(infobar_delegate_);
  }
  AttachedClientHosts::GetInstance()->Remove(this);
}

void MockRenderThread::SetResourceDispatcherDelegate(
    content::ResourceDispatcherDelegate* delegate) {
}

  void Remove(ExtensionDevToolsClientHost* client_host) {
    client_hosts_.erase(client_host);
  }

std::string MockRenderThread::GetLocale() {
  return std::string();
}

base::StringPiece ShellContentClient::GetDataResource(int resource_id) const {
  return ResourceBundle::GetSharedInstance().GetRawDataResource(resource_id);
}

  bool ShouldUseProcessPerSite(const GURL& url) {
    return use_process_per_site_;
  }

void RenderProcessImpl::ReleaseTransportDIB(TransportDIB* mem) {
  if (PutSharedMemInCache(mem)) {
    shared_mem_cache_cleaner_.Reset();
    return;
  }

  FreeTransportDIB(mem);
}

  explicit ReplaceContentClientRenderer(
      content::ContentRendererClient* new_renderer) {
    saved_renderer_ = content::GetContentClient()->renderer();
    content::GetContentClient()->set_renderer(new_renderer);
  }

  virtual void SetUp() {
    content::GetContentClient()->set_renderer(&mock_content_renderer_client_);

    static const char kThreadName[] = "RenderThread";
    channel_.reset(new IPC::Channel(kThreadName,
        IPC::Channel::MODE_SERVER, this));
    ASSERT_TRUE(channel_->Connect());

    mock_process_.reset(new MockRenderProcess);
    render_thread_ = new RenderThreadImpl(kThreadName);

    decoder_ = new media::MockAudioDecoder();

    EXPECT_CALL(*decoder_, bits_per_channel())
        .WillRepeatedly(Return(16));
    EXPECT_CALL(*decoder_, channel_layout())
        .WillRepeatedly(Return(CHANNEL_LAYOUT_MONO));
    EXPECT_CALL(*decoder_, samples_per_second())
        .WillRepeatedly(Return(44100));

    scoped_refptr<media::AudioRendererSink> default_sink =
        new AudioDevice();

    renderer_ = new TestAudioRendererImpl(default_sink.get());
    renderer_->Initialize(decoder_,
                          media::NewExpectedStatusCB(media::PIPELINE_OK),
                          NewUnderflowClosure(), NewAudioTimeClosure());

    event_.reset(new base::WaitableEvent(false, false));
  }

  ~TestInterstitialPageStateGuard() {
    if (interstitial_page_)
      interstitial_page_->ClearStates();
  }

WebNavigationPolicy RenderViewImpl::decidePolicyForNavigation(
WebFrame* frame, const WebURLRequest& request, WebNavigationType type,
const WebNode&, WebNavigationPolicy default_policy, bool is_redirect) {
// TODO(creis): Remove this when we fix OnSwapOut to not need a navigation.
if (is_swapped_out_) {
// It is possible for in-progress navigations to arrive here just after we
// are swapped out, including iframes.  We should cancel them.
if (request.url() != GURL("about:swappedout"))
return WebKit::WebNavigationPolicyIgnore;

// Allow about:swappedout to complete.
return default_policy;
}

// Webkit is asking whether to navigate to a new URL.
// This is fine normally, except if we're showing UI from one security
// context and they're trying to navigate to a different context.
const GURL& url = request.url();

// A content initiated navigation may have originated from a link-click,
// script, drag-n-drop operation, etc.
bool is_content_initiated =
DocumentState::FromDataSource(frame->provisionalDataSource())->
navigation_state()->is_content_initiated();

// Experimental:
// If --enable-strict-site-isolation is enabled, send all top-level
// navigations to the browser to let it swap processes when crossing site
// boundaries.  This is currently expected to break some script calls and
// navigations, such as form submissions.
const CommandLine& command_line = *CommandLine::ForCurrentProcess();
if (command_line.HasSwitch(switches::kEnableStrictSiteIsolation) &&
!frame->parent() && (is_content_initiated || is_redirect)) {
WebString origin_str = frame->document().securityOrigin().toString();
GURL frame_url(origin_str.utf8().data());
// TODO(cevans): revisit whether this origin check is still necessary once
// crbug.com/101395 is fixed.
if (frame_url.GetOrigin() != url.GetOrigin()) {
Referrer referrer(
GURL(request.httpHeaderField(WebString::fromUTF8("Referer"))),
GetReferrerPolicyFromRequest(request));
OpenURL(frame, url, referrer, default_policy);
return WebKit::WebNavigationPolicyIgnore;
}
}

// If the browser is interested, then give it a chance to look at top level
// navigations.
if (is_content_initiated) {
bool browser_handles_top_level_requests =
renderer_preferences_.browser_handles_top_level_requests &&
IsNonLocalTopLevelNavigation(url, frame, type);
if (browser_handles_top_level_requests ||
renderer_preferences_.browser_handles_all_requests) {
Referrer referrer(
GURL(request.httpHeaderField(WebString::fromUTF8("Referer"))),
GetReferrerPolicyFromRequest(request));
// Reset these counters as the RenderView could be reused for the next
// navigation.
page_id_ = -1;
last_page_id_sent_to_browser_ = -1;
OpenURL(frame, url, referrer, default_policy);
return WebKit::WebNavigationPolicyIgnore;  // Suppress the load here.
}
}

// Detect when we're crossing a permission-based boundary (e.g. into or out of
// an extension or app origin, leaving a WebUI page, etc). We only care about
  // top-level navigations within the current tab (as opposed to, for example,
  // opening a new window). But we sometimes navigate to about:blank to clear a
  // tab, and we want to still allow that.
//
  // Note: we do this only for GET requests because our mechanism for switching
  // processes only issues GET requests. In particular, POST requests don't
  // work, because this mechanism does not preserve form POST data. If it
  // becomes necessary to support process switching for POST requests, we will
  // need to send the request's httpBody data up to the browser process, and
  // issue a special POST navigation in WebKit (via
// FrameLoader::loadFrameRequest). See ResourceDispatcher and WebURLLoaderImpl
// for examples of how to send the httpBody data.
if (!frame->parent() && is_content_initiated &&
      default_policy == WebKit::WebNavigationPolicyCurrentTab &&
      request.httpMethod() == "GET" && !url.SchemeIs(chrome::kAboutScheme)) {
bool send_referrer = false;
bool should_fork =
        (enabled_bindings_ & content::BINDINGS_POLICY_WEB_UI) ||
        frame->isViewSourceModeEnabled() ||
        url.SchemeIs(chrome::kViewSourceScheme);

if (!should_fork) {
// Give the embedder a chance.
      bool is_initial_navigation = page_id_ == -1;
      should_fork = content::GetContentClient()->renderer()->ShouldFork(
          frame, url, is_initial_navigation, &send_referrer);
}

if (should_fork) {
Referrer referrer(
GURL(request.httpHeaderField(WebString::fromUTF8("Referer"))),
GetReferrerPolicyFromRequest(request));
OpenURL(
frame, url, send_referrer ? referrer : Referrer(), default_policy);
return WebKit::WebNavigationPolicyIgnore;  // Suppress the load here.
}
}

// Use the frame's original request's URL rather than the document's URL for
// this check.  For a popup, the document's URL may become the opener window's
// URL if the opener has called document.write.  See http://crbug.com/93517.
GURL old_url(frame->dataSource()->request().url());

// Detect when a page is "forking" a new tab that can be safely rendered in
// its own process.  This is done by sites like Gmail that try to open links
// in new windows without script connections back to the original page.  We
// treat such cases as browser navigations (in which we will create a new
// renderer for a cross-site navigation), rather than WebKit navigations.
//
// We use the following heuristic to decide whether to fork a new page in its
// own process:
// The parent page must open a new tab to about:blank, set the new tab's
// window.opener to null, and then redirect the tab to a cross-site URL using
// JavaScript.
//
// TODO(creis): Deprecate this logic once we can rely on rel=noreferrer
// (see below).
bool is_fork =
// Must start from a tab showing about:blank, which is later redirected.
old_url == GURL(chrome::kAboutBlankURL) &&
// Must be the first real navigation of the tab.
historyBackListCount() < 1 &&
historyForwardListCount() < 1 &&
// The parent page must have set the child's window.opener to null before
// redirecting to the desired URL.
frame->opener() == NULL &&
// Must be a top-level frame.
frame->parent() == NULL &&
// Must not have issued the request from this page.
is_content_initiated &&
// Must be targeted at the current tab.
default_policy == WebKit::WebNavigationPolicyCurrentTab &&
// Must be a JavaScript navigation, which appears as "other".
type == WebKit::WebNavigationTypeOther;

if (is_fork) {
// Open the URL via the browser, not via WebKit.
OpenURL(frame, url, Referrer(), default_policy);
return WebKit::WebNavigationPolicyIgnore;
}

return default_policy;
}

void RenderViewImpl::OnImeConfirmComposition(
      const string16& text, const ui::Range& replacement_range) {
  if (pepper_delegate_.IsPluginFocused()) {
    pepper_delegate_.OnImeConfirmComposition(text);
  } else {
#if defined(OS_WIN)
    if (focused_plugin_id_ >= 0) {
      std::set<WebPluginDelegateProxy*>::iterator it;
      for (it = plugin_delegates_.begin();
           it != plugin_delegates_.end(); ++it) {
        (*it)->ImeCompositionCompleted(text, focused_plugin_id_);
      }
      return;
    }
#endif
    if (replacement_range.IsValid() && webview()) {
      if (WebFrame* frame = webview()->focusedFrame()) {
        WebRange webrange = WebRange::fromDocumentRange(
            frame, replacement_range.start(), replacement_range.length());
        if (!webrange.isNull())
          frame->setSelectionToRange(webrange);
      }
    }
    RenderWidget::OnImeConfirmComposition(text, replacement_range);
  }
}

void MockRenderThread::RecordUserMetrics(const std::string& action) {
}

AttachDebuggerFunction::~AttachDebuggerFunction() {}

void MockRenderThread::RemoveRoute(int32 routing_id) {
  EXPECT_EQ(routing_id_, routing_id);
  widget_ = NULL;
}

void RenderViewImpl::didCompleteClientRedirect(
    WebFrame* frame, const WebURL& from) {
  if (!frame->parent()) {
    WebDataSource* ds = frame->provisionalDataSource();
    completed_client_redirect_src_ = Referrer(
        from, ds ? GetReferrerPolicyFromRequest(ds->request()) :
        frame->referrerPolicy());
  }
  FOR_EACH_OBSERVER(
      RenderViewObserver, observers_, DidCompleteClientRedirect(frame, from));
}

std::string ChromeContentClient::GetUserAgent(bool* overriding) const {
  if (CommandLine::ForCurrentProcess()->HasSwitch(switches::kUserAgent)) {
    *overriding = true;
    return CommandLine::ForCurrentProcess()->GetSwitchValueASCII(
        switches::kUserAgent);
  } else {
    *overriding = false;
    chrome::VersionInfo version_info;
    std::string product("Chrome/");
    product += version_info.is_valid() ? version_info.Version() : "0.0.0.0";
    return webkit_glue::BuildUserAgentFromProduct(product);
  }
}

void MockRenderThread::VerifyRunJavaScriptMessageSend(
    const string16& expected_alert_message) {
  const IPC::Message* alert_msg =
      sink_.GetUniqueMessageMatching(ViewHostMsg_RunJavaScriptMessage::ID);
  ASSERT_TRUE(alert_msg);
  PickleIterator iter = IPC::SyncMessage::GetDataIterator(alert_msg);
  ViewHostMsg_RunJavaScriptMessage::SendParam alert_param;
  ASSERT_TRUE(IPC::ReadParam(alert_msg, &iter, &alert_param));
  EXPECT_EQ(expected_alert_message, alert_param.a);
}

void RenderViewImpl::DidPause(webkit_media::WebMediaPlayerImpl* player) {
  Send(new ViewHostMsg_MediaNotification(routing_id_,
                                         reinterpret_cast<int64>(player),
                                         player->hasVideo(),
                                         player->hasAudio(),
                                         false));
}

  TestInterstitialPageDelegate(TestInterstitialPage* interstitial_page)
      : interstitial_page_(interstitial_page) {}

  void set_privileged_process_id(int process_id) {
    privileged_process_id_ = process_id;
  }

RenderViewTest::~RenderViewTest() {
}

bool DebuggerFunction::InitTabContents() {
Value* debuggee;
EXTENSION_FUNCTION_VALIDATE(args_->Get(0, &debuggee));

DictionaryValue* dict = static_cast<DictionaryValue*>(debuggee);
EXTENSION_FUNCTION_VALIDATE(dict->GetInteger(keys::kTabIdKey, &tab_id_));

// Find the TabContents that contains this tab id.
contents_ = NULL;
TabContentsWrapper* wrapper = NULL;
bool result = ExtensionTabUtil::GetTabById(
tab_id_, profile(), include_incognito(), NULL, NULL, &wrapper, NULL);
if (!result || !wrapper) {
error_ = ExtensionErrorUtils::FormatErrorMessage(
keys::kNoTabError,
base::IntToString(tab_id_));
return false;
}
contents_ = wrapper->web_contents();

  if (ChromeWebUIControllerFactory::GetInstance()->HasWebUIScheme(
contents_->GetURL())) {
error_ = ExtensionErrorUtils::FormatErrorMessage(
keys::kAttachToWebUIError,
contents_->GetURL().scheme());
return false;
}

return true;
}

bool TestContentClient::GetSandboxProfileForSandboxType(
    int sandbox_type,
    int* sandbox_profile_resource_id) const {
  return false;
}

void RenderViewImpl::didChangeScrollOffset(WebFrame* frame) {
  StartNavStateSyncTimerIfNecessary();

  if (webview()->mainFrame() == frame)
    UpdateScrollState(frame);
}

WebView* RenderViewImpl::createView(
    WebFrame* creator,
    const WebURLRequest& request,
    const WebWindowFeatures& features,
    const WebString& frame_name,
    WebNavigationPolicy policy) {
  if (shared_popup_counter_->data > kMaximumNumberOfUnacknowledgedPopups)
    return NULL;

  ViewHostMsg_CreateWindow_Params params;
  params.opener_id = routing_id_;
  params.user_gesture = creator->isProcessingUserGesture();
  params.window_container_type = WindowFeaturesToContainerType(features);
  params.session_storage_namespace_id = session_storage_namespace_id_;
  params.frame_name = frame_name;
  params.opener_frame_id = creator->identifier();
  params.opener_url = creator->document().url();
  params.opener_security_origin =
      creator->document().securityOrigin().toString().utf8();
  params.opener_suppressed = creator->willSuppressOpenerInNewFrame();
  params.disposition = NavigationPolicyToDisposition(policy);
  if (!request.isNull())
    params.target_url = request.url();

  int32 routing_id = MSG_ROUTING_NONE;
  int32 surface_id = 0;
  int64 cloned_session_storage_namespace_id;

  RenderThread::Get()->Send(
      new ViewHostMsg_CreateWindow(params,
                                   &routing_id,
                                   &surface_id,
                                   &cloned_session_storage_namespace_id));
  if (routing_id == MSG_ROUTING_NONE)
    return NULL;

  RenderViewImpl* view = RenderViewImpl::Create(
      0,
      routing_id_,
      renderer_preferences_,
      webkit_preferences_,
      shared_popup_counter_,
      routing_id,
      surface_id,
      cloned_session_storage_namespace_id,
      frame_name,
      1,
      screen_info_);
  view->opened_by_user_gesture_ = params.user_gesture;

  view->opener_suppressed_ = params.opener_suppressed;

  GURL creator_url(creator->document().securityOrigin().toString().utf8());
  if (!creator_url.is_valid() || !creator_url.IsStandard())
    creator_url = GURL();
  view->creator_url_ = creator_url;

  view->alternate_error_page_url_ = alternate_error_page_url_;

  return view->webview();
}

  virtual ~RenderViewHostManagerTestWebUIControllerFactory() {}

void ChromeWebUIControllerFactory::GetFaviconForURL(
    Profile* profile,
    FaviconService::GetFaviconRequest* request,
    const GURL& page_url) const {
  if (page_url.SchemeIs(chrome::kExtensionScheme) &&
      page_url.host() != extension_misc::kBookmarkManagerId) {
    ExtensionWebUI::GetFaviconForURL(profile, request, page_url);
  } else {
    history::FaviconData favicon;
    favicon.image_data = scoped_refptr<RefCountedMemory>(
        GetFaviconResourceBytes(page_url));
    favicon.known_icon = favicon.image_data.get() != NULL &&
                             favicon.image_data->size() > 0;
    favicon.icon_type = history::FAVICON;
    request->ForwardResultAsync(request->handle(), favicon);
  }
}

void RenderViewImpl::didCreateDataSource(WebFrame* frame, WebDataSource* ds) {
  DocumentState* document_state = DocumentState::FromDataSource(ds);
  if (!document_state) {
    document_state = new DocumentState;
    ds->setExtraData(document_state);
  }

  bool content_initiated = !pending_navigation_params_.get();
  if (content_initiated)
    document_state->set_navigation_state(
        NavigationState::CreateContentInitiated());
  else
    PopulateStateFromPendingNavigationParams(document_state);

  if (webview()) {
    if (WebFrame* old_frame = webview()->mainFrame()) {
      const WebURLRequest& original_request = ds->originalRequest();
      const GURL referrer(
          original_request.httpHeaderField(WebString::fromUTF8("Referer")));
      if (!referrer.is_empty() &&
          DocumentState::FromDataSource(
              old_frame->dataSource())->was_prefetcher()) {
        for (;old_frame;old_frame = old_frame->traverseNext(false)) {
          WebDataSource* old_frame_ds = old_frame->dataSource();
          if (old_frame_ds && referrer == GURL(old_frame_ds->request().url())) {
            document_state->set_was_referred_by_prefetcher(true);
            break;
          }
        }
      }
    }
  }

  if (content_initiated) {
    const WebURLRequest& request = ds->request();
    switch (request.cachePolicy()) {
      case WebURLRequest::UseProtocolCachePolicy:  // normal load.
        document_state->set_load_type(DocumentState::LINK_LOAD_NORMAL);
        break;
      case WebURLRequest::ReloadIgnoringCacheData:  // reload.
        document_state->set_load_type(DocumentState::LINK_LOAD_RELOAD);
        break;
      case WebURLRequest::ReturnCacheDataElseLoad:  // allow stale data.
        document_state->set_load_type(
            DocumentState::LINK_LOAD_CACHE_STALE_OK);
        break;
      case WebURLRequest::ReturnCacheDataDontLoad:  // Don't re-post.
        document_state->set_load_type(DocumentState::LINK_LOAD_CACHE_ONLY);
        break;
    }
  }

  FOR_EACH_OBSERVER(
      RenderViewObserver, observers_, DidCreateDataSource(frame, ds));
}

bool MockRenderThread::IsRegisteredExtension(
    const std::string& v8_extension_name) const {
  return false;
}

  void set_should_create_webui(bool should_create_webui) {
    factory_.set_should_create_webui(should_create_webui);
  }

  TestBrowsingInstance(BrowserContext* browser_context, int* delete_counter)
      : BrowsingInstance(browser_context),
        use_process_per_site_(false),
        delete_counter_(delete_counter) {
  }

 bool MockRenderProcess::HasInitializedMediaLibrary() const {
   return false;
 }

  WebWidgetLockTarget (WebKit::WebWidget* webwidget)
      : webwidget_(webwidget) {}

 bool ChromeContentClient::CanHandleWhileSwappedOut(
     const IPC::Message& msg) {
  switch (msg.type()) {
    case ChromeViewHostMsg_Snapshot::ID:
      return true;
    default:
      break;
  }
  return false;
}

void RenderViewImpl::OnJavaBridgeInit() {
  DCHECK(!java_bridge_dispatcher_.get());
#if defined(ENABLE_JAVA_BRIDGE)
  java_bridge_dispatcher_.reset(new JavaBridgeDispatcher(this));
#endif
}

bool RenderViewTest::OnMessageReceived(const IPC::Message& msg) {
  RenderViewImpl* impl = static_cast<RenderViewImpl*>(view_);
  return impl->OnMessageReceived(msg);
}

void MockRenderThread::AddRoute(int32 routing_id,
IPC::Channel::Listener* listener) {
  EXPECT_EQ(routing_id_, routing_id);
  widget_ = listener;
}

WebKit::WebPlugin* RenderViewImpl::CreatePlugin(
    WebKit::WebFrame* frame,
    const webkit::WebPluginInfo& info,
    const WebKit::WebPluginParams& params)  {
  bool pepper_plugin_was_registered = false;
  scoped_refptr<webkit::ppapi::PluginModule> pepper_module(
      pepper_delegate_.CreatePepperPluginModule(info,
                                                &pepper_plugin_was_registered));
  if (pepper_plugin_was_registered) {
    if (!pepper_module)
      return NULL;
    return new webkit::ppapi::WebPluginImpl(
        pepper_module.get(), params, pepper_delegate_.AsWeakPtr());
  }

#if defined(USE_AURA)
  return NULL;
#else
  return new webkit::npapi::WebPluginImpl(
      frame, params, info.path, AsWeakPtr());
#endif
}

bool RenderViewImpl::RunJavaScriptMessage(ui::JavascriptMessageType type,
                                          const string16& message,
                                          const string16& default_value,
                                          const GURL& frame_url,
                                          string16* result) {
  bool success = false;
  string16 result_temp;
  if (!result)
    result = &result_temp;

  SendAndRunNestedMessageLoop(new ViewHostMsg_RunJavaScriptMessage(
      routing_id_, message, default_value, frame_url, type, &success, result));
  return success;
}

bool ChromeWebUIControllerFactory::HasWebUIScheme(const GURL& url) const {
  return url.SchemeIs(chrome::kChromeDevToolsScheme) ||
         url.SchemeIs(chrome::kChromeInternalScheme) ||
         url.SchemeIs(chrome::kChromeUIScheme);
}

ACTION_P(QuitMessageLoop, loop_or_proxy) {
  loop_or_proxy->PostTask(FROM_HERE, MessageLoop::QuitClosure());
}

void MockRenderThread::PreCacheFont(const LOGFONT& log_font) {
}

WebKit::WebWidget* RenderViewTest::GetWebWidget() {
  RenderViewImpl* impl = static_cast<RenderViewImpl*>(view_);
  return impl->webwidget();
}

void SendCommandDebuggerFunction::SendResponseBody(
    DictionaryValue* dictionary) {
  Value* error_body;
  if (dictionary->Get("error", &error_body)) {
    base::JSONWriter::Write(error_body, false, &error_);
    SendResponse(false);
    return;
  }

  Value* result_body;
  if (dictionary->Get("result", &result_body))
    result_.reset(result_body->DeepCopy());
  else
    result_.reset(new DictionaryValue());
  SendResponse(true);
}

virtual bool IsURLAcceptableForWebUI(
BrowserContext* browser_context, const GURL& url) const {
    return HasWebUIScheme(url);
}

WebKit::WebNode RenderViewImpl::GetFocusedNode() const  {
  if (!webview())
    return WebNode();
  WebFrame* focused_frame = webview()->focusedFrame();
  if (focused_frame) {
    WebDocument doc = focused_frame->document();
    if (!doc.isNull())
      return doc.focusedNode();
  }

  return WebNode();
}

DetachDebuggerFunction::~DetachDebuggerFunction() {}

void RenderProcessImpl::ClearTransportDIBCache() {
  for (size_t i = 0; i < arraysize(shared_mem_cache_); ++i) {
    if (shared_mem_cache_[i]) {
      FreeTransportDIB(shared_mem_cache_[i]);
      shared_mem_cache_[i] = NULL;
    }
  }
}

TestContentClient::TestContentClient() {
  FilePath content_resources_pack_path;
  PathService::Get(base::DIR_MODULE, &content_resources_pack_path);
  content_resources_pack_path = content_resources_pack_path.Append(
      FILE_PATH_LITERAL("content_resources.pak"));
  data_pack_.Load(content_resources_pack_path);
}

int ExtensionDevToolsInfoBarDelegate::GetButtons() const {
  return BUTTON_CANCEL;
}

  AudioRendererImplTest() {}

bool RenderProcessImpl::InProcessPlugins() {
  const CommandLine& command_line = *CommandLine::ForCurrentProcess();
#if defined(OS_LINUX) || defined(OS_OPENBSD)
  if (command_line.HasSwitch(switches::kInProcessPlugins))
    NOTIMPLEMENTED() << ": in process plugins not supported on Linux";
  return command_line.HasSwitch(switches::kInProcessPlugins);
#else
  return command_line.HasSwitch(switches::kInProcessPlugins) ||
         command_line.HasSwitch(switches::kSingleProcess);
 #endif
 }

void ExtensionDevToolsClientHost::DispatchOnInspectorFrontend(
    const std::string& message) {
  Profile* profile =
      Profile::FromBrowserContext(web_contents_->GetBrowserContext());
  if (profile == NULL || !profile->GetExtensionEventRouter())
    return;

  scoped_ptr<Value> result(base::JSONReader::Read(message, false));
  if (!result->IsType(Value::TYPE_DICTIONARY))
    return;
  DictionaryValue* dictionary = static_cast<DictionaryValue*>(result.get());

  int id;
  if (!dictionary->GetInteger("id", &id)) {
    std::string method_name;
    if (!dictionary->GetString("method", &method_name))
      return;

    ListValue args;
    args.Append(CreateDebuggeeId(tab_id_));
    args.Append(Value::CreateStringValue(method_name));
    Value* params_value;
    if (dictionary->Get("params", &params_value))
      args.Append(params_value->DeepCopy());

    std::string json_args;
    base::JSONWriter::Write(&args, false, &json_args);

    profile->GetExtensionEventRouter()->DispatchEventToExtension(
        extension_id_, keys::kOnEvent, json_args, profile, GURL());
  } else {
    SendCommandDebuggerFunction* function = pending_requests_[id];
    if (!function)
      return;

    function->SendResponseBody(dictionary);
    pending_requests_.erase(id);
  }
}

int RenderProcessImpl::FindFreeCacheSlot(size_t size) {
  for (size_t i = 0; i < arraysize(shared_mem_cache_); ++i) {
    if (shared_mem_cache_[i] == NULL)
      return i;
  }

  size_t smallest_size = size;
  int smallest_index = -1;

  for (size_t i = 1; i < arraysize(shared_mem_cache_); ++i) {
    const size_t entry_size = shared_mem_cache_[i]->size();
    if (entry_size < smallest_size) {
      smallest_size = entry_size;
      smallest_index = i;
    }
  }

  if (smallest_index != -1) {
    FreeTransportDIB(shared_mem_cache_[smallest_index]);
    shared_mem_cache_[smallest_index] = NULL;
  }

  return smallest_index;
}

string16 TestContentClient::GetLocalizedString(int message_id) const {
  return string16();
}

void RenderViewImpl::OnPpapiBrokerChannelCreated(
    int request_id,
    base::ProcessHandle broker_process_handle,
    const IPC::ChannelHandle& handle) {
  pepper_delegate_.OnPpapiBrokerChannelCreated(request_id,
                                               broker_process_handle,
                                               handle);
}

void RenderViewImpl::didAdoptURLLoader(WebKit::WebURLLoader* loader) {
  webkit_glue::WebURLLoaderImpl* loader_impl =
      static_cast<webkit_glue::WebURLLoaderImpl*>(loader);
  loader_impl->UpdateRoutingId(routing_id_);
}

void RenderViewImpl::OnResize(const gfx::Size& new_size,
                              const gfx::Rect& resizer_rect,
                              bool is_fullscreen) {
  if (webview()) {
    if (webkit_preferences_.default_device_scale_factor)
      webview()->settings()->setLayoutFallbackWidth(
          new_size.width() / webkit_preferences_.default_device_scale_factor);
    webview()->hidePopups();
    if (send_preferred_size_changes_) {
      webview()->mainFrame()->setCanHaveScrollbars(
          ShouldDisplayScrollbars(new_size.width(), new_size.height()));
    }
    UpdateScrollState(webview()->mainFrame());
  }

  RenderWidget::OnResize(new_size, resizer_rect, is_fullscreen);
}

ChromeWebUIControllerFactory* ChromeWebUIControllerFactory::GetInstance() {
  return Singleton< ChromeWebUIControllerFactory, PossibleTestSingletonTraits<
      ChromeWebUIControllerFactory, TestChromeWebUIControllerFactory> >::get();
}

  static TestSiteInstance* CreateTestSiteInstance(
      BrowserContext* browser_context,
      int* site_delete_counter,
      int* browsing_delete_counter) {
    TestBrowsingInstance* browsing_instance =
        new TestBrowsingInstance(browser_context, browsing_delete_counter);
    return new TestSiteInstance(browsing_instance, site_delete_counter);
  }

void ShellContentClient::AddPepperPlugins(
    std::vector<content::PepperPluginInfo>* plugins) {
}

DetachDebuggerFunction::DetachDebuggerFunction() {}

void RenderViewImpl::PpapiPluginFocusChanged() {
  UpdateTextInputState();
  UpdateSelectionBounds();
}

int RenderViewTest::SendKeyEvent(MockKeyboard::Layout layout,
                                 int key_code,
                                 MockKeyboard::Modifiers modifiers,
                                 string16* output) {
#if defined(OS_WIN)
  CHECK(mock_keyboard_.get());
  CHECK(output);
  int length = mock_keyboard_->GetCharacters(layout, key_code, modifiers,
                                             output);
  if (length != 1)
    return -1;

  MSG msg1 = { NULL, WM_KEYDOWN, key_code, 0 };
#if defined(USE_AURA)
  aura::KeyEvent evt1(msg1, false);
  NativeWebKeyboardEvent keydown_event(&evt1);
#else
  NativeWebKeyboardEvent keydown_event(msg1);
#endif
  SendNativeKeyEvent(keydown_event);

  MSG msg2 = { NULL, WM_CHAR, (*output)[0], 0 };
#if defined(USE_AURA)
  aura::KeyEvent evt2(msg2, true);
  NativeWebKeyboardEvent char_event(&evt2);
#else
  NativeWebKeyboardEvent char_event(msg2);
#endif
  SendNativeKeyEvent(char_event);

  MSG msg3 = { NULL, WM_KEYUP, key_code, 0 };
#if defined(USE_AURA)
  aura::KeyEvent evt3(msg3, false);
  NativeWebKeyboardEvent keyup_event(&evt3);
#else
  NativeWebKeyboardEvent keyup_event(msg3);
#endif
  SendNativeKeyEvent(keyup_event);

  return length;
#elif defined(USE_AURA) && defined(USE_X11)
  CHECK(output);
  const int flags = ConvertMockKeyboardModifier(modifiers);

  XEvent xevent1;
  InitXKeyEventForTesting(ui::ET_KEY_PRESSED,
                          static_cast<ui::KeyboardCode>(key_code),
                          flags,
                          &xevent1);
  aura::KeyEvent event1(&xevent1, false);
  NativeWebKeyboardEvent keydown_event(&event1);
  SendNativeKeyEvent(keydown_event);

  XEvent xevent2;
  InitXKeyEventForTesting(ui::ET_KEY_PRESSED,
                          static_cast<ui::KeyboardCode>(key_code),
                          flags,
                          &xevent2);
  aura::KeyEvent event2(&xevent2, true);
  NativeWebKeyboardEvent char_event(&event2);
  SendNativeKeyEvent(char_event);

  XEvent xevent3;
  InitXKeyEventForTesting(ui::ET_KEY_RELEASED,
                          static_cast<ui::KeyboardCode>(key_code),
                          flags,
                          &xevent3);
  aura::KeyEvent event3(&xevent3, false);
  NativeWebKeyboardEvent keyup_event(&event3);
  SendNativeKeyEvent(keyup_event);

  long c = GetCharacterFromKeyCode(static_cast<ui::KeyboardCode>(key_code),
                                   flags);
  output->assign(1, static_cast<char16>(c));
  return 1;
#elif defined(OS_LINUX)
  std::vector<GdkEvent*> events;
  ui::SynthesizeKeyPressEvents(
      NULL, static_cast<ui::KeyboardCode>(key_code),
      modifiers & (MockKeyboard::LEFT_CONTROL | MockKeyboard::RIGHT_CONTROL),
      modifiers & (MockKeyboard::LEFT_SHIFT | MockKeyboard::RIGHT_SHIFT),
      modifiers & (MockKeyboard::LEFT_ALT | MockKeyboard::RIGHT_ALT),
      &events);

  guint32 unicode_key = 0;
  for (size_t i = 0; i < events.size(); ++i) {
    if ((i + 1) == (events.size() / 2) || i == (events.size() / 2)) {
      unicode_key = gdk_keyval_to_unicode(events[i]->key.keyval);
      NativeWebKeyboardEvent webkit_event(events[i]);
      SendNativeKeyEvent(webkit_event);

      if (webkit_event.type == WebKit::WebInputEvent::RawKeyDown) {
        NativeWebKeyboardEvent char_event = webkit_event;
        char_event.type = WebKit::WebInputEvent::Char;
        char_event.skip_in_browser = true;
        SendNativeKeyEvent(char_event);
      }
    }
    gdk_event_free(events[i]);
  }

  output->assign(1, static_cast<char16>(unicode_key));
  return 1;
#else
  NOTIMPLEMENTED();
  return L'\0';
#endif
}
