bool AppCacheDatabase::FindNamespacesForOrigin(
    const url::Origin& origin,
    std::vector<NamespaceRecord>* intercepts,
    std::vector<NamespaceRecord>* fallbacks) {
  DCHECK(intercepts && intercepts->empty());
  DCHECK(fallbacks && fallbacks->empty());
  if (!LazyOpen(kDontCreate))
    return false;

  static const char kSql[] =
      "SELECT cache_id, origin, type, namespace_url, target_url, is_pattern"
      "  FROM Namespaces WHERE origin = ?";

  sql::Statement statement(db_->GetCachedStatement(SQL_FROM_HERE, kSql));
  statement.BindString(0, SerializeOrigin(origin));

  ReadNamespaceRecords(&statement, intercepts, fallbacks);

  return statement.Succeeded();
}

bool AppCacheDatabase::DeleteOnlineWhiteListForCache(int64_t cache_id) {
  if (!LazyOpen(kDontCreate))
    return false;

  static const char kSql[] = "DELETE FROM OnlineWhiteLists WHERE cache_id = ?";

  sql::Statement statement(db_->GetCachedStatement(SQL_FROM_HERE, kSql));
  statement.BindInt64(0, cache_id);

  return statement.Run();
}

AppCache::~AppCache() {
  DCHECK(associated_hosts_.empty());
  if (owning_group_.get()) {
    DCHECK(is_complete_);
    owning_group_->RemoveCache(this);
  }
  DCHECK(!owning_group_.get());
  storage_->working_set()->RemoveCache(this);
}

    void CallCallback(UsageAndQuotaCallback callback) {
      std::move(callback).Run(blink::mojom::QuotaStatusCode::kOk, 0,
                              kMockQuota);
    }

AppCacheDatabase::NamespaceRecord::NamespaceRecord()
    : cache_id(0) {
}

void AppCacheUpdateJob::FetchMasterEntries() {
  DCHECK(internal_state_ == NO_UPDATE || internal_state_ == DOWNLOADING);

  while (master_entry_fetches_.size() < kMaxConcurrentUrlFetches &&
         !master_entries_to_fetch_.empty()) {
    const GURL& url = *master_entries_to_fetch_.begin();

    if (AlreadyFetchedEntry(url, AppCacheEntry::MASTER)) {
      ++master_entries_completed_;  // saved a URL request

      if (internal_state_ == NO_UPDATE) {
        DCHECK(!inprogress_cache_.get());
        AppCache* cache = group_->newest_complete_cache();
        auto found = pending_master_entries_.find(url);
        DCHECK(found != pending_master_entries_.end());
        PendingHosts& hosts = found->second;
        for (AppCacheHost* host : hosts)
          host->AssociateCompleteCache(cache);
      }
    } else {
      URLFetcher* fetcher = new URLFetcher(url, URLFetcher::MASTER_ENTRY_FETCH,
                                           this, kAppCacheFetchBufferSize);
      fetcher->Start();
      master_entry_fetches_.insert(PendingUrlFetches::value_type(url, fetcher));
    }

    master_entries_to_fetch_.erase(master_entries_to_fetch_.begin());
  }
}

 void AppCacheDatabase::ReadNamespaceRecords(
      sql::Statement* statement,
      NamespaceRecordVector* intercepts,
      NamespaceRecordVector* fallbacks) {
  while (statement->Step()) {
    AppCacheNamespaceType type = static_cast<AppCacheNamespaceType>(
        statement->ColumnInt(2));
    NamespaceRecordVector* records =
        (type == APPCACHE_FALLBACK_NAMESPACE) ? fallbacks : intercepts;
    records->push_back(NamespaceRecord());
    ReadNamespaceRecord(statement, &records->back());
  }
}

  AppCacheStorageImplTest() {
    auto head = network::CreateResourceResponseHead(net::HTTP_OK);
    network::URLLoaderCompletionStatus status;

    head.mime_type = "text/cache-manifest";
    mock_url_loader_factory_.AddResponse(GetMockUrl("manifest"), head,
                                         "CACHE MANIFEST\n", status);

    head.mime_type = "text/html";
    mock_url_loader_factory_.AddResponse(GetMockUrl("empty.html"), head, "",
                                         status);
  }

  void TearDownTest() {
    DCHECK(io_runner->BelongsToCurrentThread());
    scoped_refptr<base::SequencedTaskRunner> db_runner =
        storage()->db_task_runner_;
    storage()->CancelDelegateCallbacks(delegate());
    group_ = nullptr;
    cache_ = nullptr;
    cache2_ = nullptr;
    mock_quota_manager_proxy_ = nullptr;
    delegate_.reset();
    service_.reset();
    FlushTasks(db_runner.get());
    FlushTasks(background_thread->task_runner().get());
    FlushTasks(db_runner.get());
  }

void AppCacheUpdateJob::OnManifestDataWriteComplete(int result) {
if (result > 0) {
AppCacheEntry entry(AppCacheEntry::MANIFEST,
        manifest_response_writer_->response_id(),
        manifest_response_writer_->amount_written());
if (!inprogress_cache_->AddOrModifyEntry(manifest_url_, entry))
duplicate_response_ids_.push_back(entry.response_id());
StoreGroupAndCache();
} else {
HandleCacheFailure(
blink::mojom::AppCacheErrorDetails(
"Failed to write the manifest data to storage",
blink::mojom::AppCacheErrorReason::APPCACHE_UNKNOWN_ERROR, GURL(),
0, false /*is_cross_origin*/),
DISKCACHE_ERROR, GURL());
}
}

  void LoadCache_NearHit() {

    int64_t cache_id = storage()->NewCacheId();
    scoped_refptr<AppCache> cache(new AppCache(storage(), cache_id));

    storage()->LoadCache(cache_id, delegate());
    EXPECT_EQ(cache_id, delegate()->loaded_cache_id_);
    EXPECT_EQ(cache.get(), delegate()->loaded_cache_.get());
    EXPECT_EQ(0, mock_quota_manager_proxy_->notify_storage_accessed_count_);
    EXPECT_EQ(0, mock_quota_manager_proxy_->notify_storage_modified_count_);
    TestFinished();
  }

  void Verify_ExclusionNotFound(GURL expected_url, int phase) {
    EXPECT_EQ(expected_url, delegate()->found_url_);
    EXPECT_TRUE(delegate()->found_manifest_url_.is_empty());
    EXPECT_EQ(blink::mojom::kAppCacheNoCacheId, delegate()->found_cache_id_);
    EXPECT_EQ(0, delegate()->found_group_id_);
    EXPECT_EQ(blink::mojom::kAppCacheNoResponseId,
              delegate()->found_entry_.response_id());
    EXPECT_EQ(blink::mojom::kAppCacheNoResponseId,
              delegate()->found_fallback_entry_.response_id());
    EXPECT_TRUE(delegate()->found_namespace_entry_url_.is_empty());
    EXPECT_EQ(0, delegate()->found_entry_.types());
    EXPECT_EQ(0, delegate()->found_fallback_entry_.types());

    if (phase == 1) {
      PushNextTask(
          base::BindOnce(&AppCacheStorageImplTest::Verify_ExclusionNotFound,
                         base::Unretained(this), kOnlineNamespace, 2));
      storage()->FindResponseForMainRequest(kOnlineNamespace, GURL(),
                                            delegate());
      return;
    }
    if (phase == 2) {
      PushNextTask(base::BindOnce(
          &AppCacheStorageImplTest::Verify_ExclusionNotFound,
          base::Unretained(this), kOnlineNamespaceWithinFallback, 3));
      storage()->FindResponseForMainRequest(kOnlineNamespaceWithinFallback,
                                            GURL(), delegate());
      return;
    }

    TestFinished();
  }

void AppCacheUpdateJob::Cancel() {
  internal_state_ = CANCELLED;

  LogHistogramStats(CANCELLED_ERROR, GURL());

  if (manifest_fetcher_) {
    delete manifest_fetcher_;
    manifest_fetcher_ = nullptr;
  }

  for (auto& pair : pending_url_fetches_)
    delete pair.second;
  pending_url_fetches_.clear();

  for (auto& pair : master_entry_fetches_)
    delete pair.second;
  master_entry_fetches_.clear();

  ClearPendingMasterEntries();
  DiscardInprogressCache();

  if (manifest_response_writer_)
    manifest_response_writer_.reset();

  storage_->CancelDelegateCallbacks(this);
}

AppCacheDatabase::GroupRecord::~GroupRecord() {
}

void AppCacheUpdateJob::OnGroupMadeObsolete(AppCacheGroup* group,
                                            bool success,
                                            int response_code) {
  DCHECK(master_entry_fetches_.empty());
  CancelAllMasterEntryFetches(blink::mojom::AppCacheErrorDetails(
      "The cache has been made obsolete, "
      "the manifest file returned 404 or 410",
      blink::mojom::AppCacheErrorReason::APPCACHE_MANIFEST_ERROR, GURL(),
      response_code, false /*is_cross_origin*/));
  if (success) {
    DCHECK(group->is_obsolete());
    NotifyAllAssociatedHosts(
        blink::mojom::AppCacheEventID::APPCACHE_OBSOLETE_EVENT);
    internal_state_ = COMPLETED;
    MaybeCompleteUpdate();
  } else {
    HandleCacheFailure(
        blink::mojom::AppCacheErrorDetails(
            "Failed to mark the cache as obsolete",
            blink::mojom::AppCacheErrorReason::APPCACHE_UNKNOWN_ERROR, GURL(),
            0, false /*is_cross_origin*/),
        DB_ERROR, GURL());
  }
}

  void RunTestOnIOThread(Method method) {
    test_finished_event_.reset(new base::WaitableEvent(
        base::WaitableEvent::ResetPolicy::AUTOMATIC,
        base::WaitableEvent::InitialState::NOT_SIGNALED));
    io_runner->PostTask(
        FROM_HERE,
        base::BindOnce(&AppCacheStorageImplTest::MethodWrapper<Method>,
                       base::Unretained(this), method));
    test_finished_event_->Wait();
  }

bool AppCacheDatabase::FindOriginsWithGroups(std::set<url::Origin>* origins) {
  DCHECK(origins && origins->empty());
  if (!LazyOpen(kDontCreate))
    return false;

  static const char kSql[] = "SELECT DISTINCT(origin) FROM Groups";

  sql::Statement statement(db_->GetUniqueStatement(kSql));

  while (statement.Step())
    origins->insert(url::Origin::Create(GURL(statement.ColumnString(0))));

  return statement.Succeeded();
}

  void Verify_BasicFindMainFallbackResponse() {
    EXPECT_EQ(kFallbackTestUrl, delegate()->found_url_);
    EXPECT_EQ(kManifestUrl, delegate()->found_manifest_url_);
    EXPECT_EQ(1, delegate()->found_cache_id_);
    EXPECT_EQ(2, delegate()->found_group_id_);
    EXPECT_FALSE(delegate()->found_entry_.has_response_id());
    EXPECT_EQ(2, delegate()->found_fallback_entry_.response_id());
    EXPECT_EQ(kEntryUrl2, delegate()->found_namespace_entry_url_);
    EXPECT_TRUE(delegate()->found_fallback_entry_.IsFallback());
    TestFinished();
  }

  AppCacheServiceImplTest()
      : kOriginURL("http://hello/"),
        kOrigin(url::Origin::Create(kOriginURL)),
        kManifestUrl(kOriginURL.Resolve("manifest")),
        service_(new AppCacheServiceImpl(nullptr)),
        delete_result_(net::OK),
        delete_completion_count_(0) {
    service_->storage_.reset(new MockAppCacheStorage(service_.get()));
  }

bool AppCacheDatabase::FindGroupForCache(int64_t cache_id,
                                         GroupRecord* record) {
  DCHECK(record);
  if (!LazyOpen(kDontCreate))
    return false;

  static const char kSql[] =
      "SELECT g.group_id, g.origin, g.manifest_url,"
      "       g.creation_time, g.last_access_time,"
      "       g.last_full_update_check_time,"
      "       g.first_evictable_error_time"
      "  FROM Groups g, Caches c"
      "  WHERE c.cache_id = ? AND c.group_id = g.group_id";

  sql::Statement statement(db_->GetCachedStatement(SQL_FROM_HERE, kSql));
  statement.BindInt64(0, cache_id);

  if (!statement.Step())
    return false;

  ReadGroupRecord(statement, record);
  return true;
}

bool AppCacheDatabase::UpdateLastAccessTime(int64_t group_id, base::Time time) {
  if (!LazyUpdateLastAccessTime(group_id, time))
    return false;
  return CommitLazyLastAccessTimes();
}

void Verify_MakeGroupObsolete() {
EXPECT_TRUE(delegate()->obsoleted_success_);
EXPECT_EQ(group_.get(), delegate()->obsoleted_group_.get());
EXPECT_TRUE(group_->is_obsolete());
EXPECT_TRUE(storage()->usage_map_.empty());

// The cache and group have been deleted from the database.
AppCacheDatabase::GroupRecord group_record;
AppCacheDatabase::CacheRecord cache_record;
EXPECT_FALSE(database()->FindGroup(1, &group_record));
EXPECT_FALSE(database()->FindCache(1, &cache_record));

// The related records should have been deleted too.
std::vector<AppCacheDatabase::EntryRecord> entry_records;
database()->FindEntriesForCache(1, &entry_records);
EXPECT_TRUE(entry_records.empty());
std::vector<AppCacheDatabase::NamespaceRecord> intercept_records;
std::vector<AppCacheDatabase::NamespaceRecord> fallback_records;
database()->FindNamespacesForCache(1, &intercept_records,
&fallback_records);
EXPECT_TRUE(fallback_records.empty());
std::vector<AppCacheDatabase::OnlineWhiteListRecord> whitelist_records;
database()->FindOnlineWhiteListForCache(1, &whitelist_records);
EXPECT_TRUE(whitelist_records.empty());

// Verify quota bookkeeping
EXPECT_TRUE(storage()->usage_map_.empty());
EXPECT_EQ(1, mock_quota_manager_proxy_->notify_storage_modified_count_);
EXPECT_EQ(kOrigin, mock_quota_manager_proxy_->last_origin_);
    EXPECT_EQ(-kDefaultEntrySize, mock_quota_manager_proxy_->last_delta_);

TestFinished();
}

void AppCacheUpdateJob::CancelAllMasterEntryFetches(
    const blink::mojom::AppCacheErrorDetails& error_details) {

  for (auto& pair : master_entry_fetches_) {
    delete pair.second;
    master_entries_to_fetch_.insert(pair.first);  // back in unfetched list
  }
  master_entry_fetches_.clear();

  master_entries_completed_ += master_entries_to_fetch_.size();

  HostNotifier host_notifier;
  while (!master_entries_to_fetch_.empty()) {
    const GURL& url = *master_entries_to_fetch_.begin();
    auto found = pending_master_entries_.find(url);
    DCHECK(found != pending_master_entries_.end());
    PendingHosts& hosts = found->second;
    for (AppCacheHost* host : hosts) {
      host->AssociateNoCache(GURL());
      host_notifier.AddHost(host);
      host->RemoveObserver(this);
    }
    hosts.clear();

    master_entries_to_fetch_.erase(master_entries_to_fetch_.begin());
  }
  host_notifier.SendErrorNotifications(error_details);
}

bool CreateIndex(sql::Database* db, const IndexInfo& info) {
  std::string sql;
  if (info.unique)
    sql += "CREATE UNIQUE INDEX ";
  else
    sql += "CREATE INDEX ";
  sql += info.index_name;
  sql += " ON ";
  sql += info.table_name;
  sql += info.columns;
  return db->Execute(sql.c_str());
}

  void FindMainResponseWithMultipleHits() {
    PushNextTask(base::BindOnce(
        &AppCacheStorageImplTest::Verify_FindMainResponseWithMultipleHits,
        base::Unretained(this)));

    MakeMultipleHitCacheAndGroup(kManifestUrl, 1);
    MakeMultipleHitCacheAndGroup(kManifestUrl2, 2);
    MakeMultipleHitCacheAndGroup(kManifestUrl3, 3);

    storage()->FindResponseForMainRequest(kEntryUrl, GURL(), delegate());
    EXPECT_NE(kEntryUrl, delegate()->found_url_);
  }

void AppCacheUpdateJob::BuildUrlFileList(const AppCacheManifest& manifest) {
  for (const std::string& explicit_url : manifest.explicit_urls)
    AddUrlToFileList(GURL(explicit_url), AppCacheEntry::EXPLICIT);

  for (const auto& intercept : manifest.intercept_namespaces)
    AddUrlToFileList(intercept.target_url, AppCacheEntry::INTERCEPT);

  for (const auto& fallback : manifest.fallback_namespaces)
    AddUrlToFileList(fallback.target_url, AppCacheEntry::FALLBACK);

  if (update_type_ == UPGRADE_ATTEMPT) {
    for (const auto& pair : group_->newest_complete_cache()->entries()) {
      const AppCacheEntry& entry = pair.second;
      if (entry.IsMaster())
        AddUrlToFileList(pair.first, AppCacheEntry::MASTER);
    }
  }
}

bool AppCacheDatabase::UpgradeSchema() {
  // The version on disk is deprecated.
  return DeleteExistingAndCreateNewDatabase();
}

 void EmptyCompletionCallback(int result) {}

bool AppCacheDatabase::InsertEntryRecords(
    const std::vector<EntryRecord>& records) {
  if (records.empty())
    return true;
  sql::Transaction transaction(db_.get());
  if (!transaction.Begin())
    return false;
  for (const auto& record : records) {
    if (!InsertEntry(&record))
      return false;
  }
  return transaction.Commit();
}

  void Verify_FindInterceptPatternMatchNegative() {
    EXPECT_EQ(kInterceptPatternTestNegativeUrl, delegate()->found_url_);
    EXPECT_TRUE(delegate()->found_manifest_url_.is_empty());
    EXPECT_EQ(blink::mojom::kAppCacheNoCacheId, delegate()->found_cache_id_);
    EXPECT_EQ(blink::mojom::kAppCacheNoResponseId,
              delegate()->found_entry_.response_id());
    EXPECT_EQ(blink::mojom::kAppCacheNoResponseId,
              delegate()->found_fallback_entry_.response_id());
    EXPECT_TRUE(delegate()->found_namespace_entry_url_.is_empty());
    EXPECT_EQ(0, delegate()->found_entry_.types());
    EXPECT_EQ(0, delegate()->found_fallback_entry_.types());

    PushNextTask(base::BindOnce(
        &AppCacheStorageImplTest::Verify_FindInterceptPatternMatchPositive,
        base::Unretained(this)));
    storage()->FindResponseForMainRequest(kInterceptPatternTestPositiveUrl,
                                          GURL(), delegate());
  }

bool SortNamespacesByLength(
    const AppCacheNamespace& lhs, const AppCacheNamespace& rhs) {
  return lhs.namespace_url.spec().length() > rhs.namespace_url.spec().length();
}

AppCacheUpdateJob::~AppCacheUpdateJob() {
  if (service_)
    service_->RemoveObserver(this);
  if (internal_state_ != COMPLETED)
    Cancel();

  DCHECK(!inprogress_cache_.get());
  DCHECK(pending_master_entries_.empty());

  CHECK(!manifest_fetcher_);
  CHECK(pending_url_fetches_.empty());
  CHECK(master_entry_fetches_.empty());

  if (group_)
    group_->SetUpdateAppCacheStatus(AppCacheGroup::IDLE);
}

void AppCacheDatabase::OnDatabaseError(int err, sql::Statement* stmt) {
  was_corruption_detected_ |= sql::IsErrorCatastrophic(err);
  if (!db_->IsExpectedSqliteError(err))
    DLOG(ERROR) << db_->GetErrorMessage();
}

  void FindFallbackPatternMatch(bool drop_from_working_set) {
    MakeCacheAndGroup(kManifestUrl, 2, 1, true);
    cache_->AddEntry(kEntryUrl, AppCacheEntry(AppCacheEntry::FALLBACK, 1));
    cache_->fallback_namespaces_.push_back(
        AppCacheNamespace(APPCACHE_FALLBACK_NAMESPACE,
                          kFallbackPatternNamespace, kEntryUrl, true));
    AppCacheDatabase::CacheRecord cache_record;
    std::vector<AppCacheDatabase::EntryRecord> entries;
    std::vector<AppCacheDatabase::NamespaceRecord> intercepts;
    std::vector<AppCacheDatabase::NamespaceRecord> fallbacks;
    std::vector<AppCacheDatabase::OnlineWhiteListRecord> whitelists;
    cache_->ToDatabaseRecords(group_.get(), &cache_record, &entries,
                              &intercepts, &fallbacks, &whitelists);

    for (const auto& entry : entries) {
      if (entry.url != kDefaultEntryUrl)
        EXPECT_TRUE(database()->InsertEntry(&entry));
    }

    EXPECT_TRUE(database()->InsertNamespaceRecords(fallbacks));
    if (drop_from_working_set) {
      EXPECT_TRUE(cache_->HasOneRef());
      cache_ = nullptr;
      EXPECT_TRUE(group_->HasOneRef());
      group_ = nullptr;
    }

    PushNextTask(base::BindOnce(
        &AppCacheStorageImplTest::Verify_FindFallbackPatternMatchNegative,
        base::Unretained(this)));
    storage()->FindResponseForMainRequest(kFallbackPatternTestNegativeUrl,
                                          GURL(), delegate());
    EXPECT_EQ(GURL(), delegate()->found_url_);  // Is always async.
  }

  void Verify_StoreNewGroup() {
    EXPECT_TRUE(delegate()->stored_group_success_);
    EXPECT_EQ(group_.get(), delegate()->stored_group_.get());
    EXPECT_EQ(cache_.get(), group_->newest_complete_cache());
    EXPECT_TRUE(cache_->is_complete());

    AppCacheDatabase::GroupRecord group_record;
    AppCacheDatabase::CacheRecord cache_record;
    EXPECT_TRUE(database()->FindGroup(group_->group_id(), &group_record));
    EXPECT_TRUE(database()->FindCache(cache_->cache_id(), &cache_record));

    EXPECT_EQ(kDefaultEntrySize, storage()->usage_map_[kOrigin]);
    EXPECT_EQ(1, mock_quota_manager_proxy_->notify_storage_modified_count_);
    EXPECT_EQ(kOrigin, mock_quota_manager_proxy_->last_origin_);
    EXPECT_EQ(kDefaultEntrySize, mock_quota_manager_proxy_->last_delta_);

    TestFinished();
  }

bool AppCache::AddOrModifyEntry(const GURL& url, const AppCacheEntry& entry) {
std::pair<EntryMap::iterator, bool> ret =
entries_.insert(EntryMap::value_type(url, entry));

// Entry already exists.  Merge the types of the new and existing entries.
  if (!ret.second)
ret.first->second.add_types(entry.types());
  else
cache_size_ += entry.response_size();  // New entry. Add to cache size.
return ret.second;
}

bool AppCacheDatabase::FindGroup(int64_t group_id, GroupRecord* record) {
  DCHECK(record);
  if (!LazyOpen(kDontCreate))
    return false;

  static const char kSql[] =
      "SELECT group_id, origin, manifest_url,"
      "       creation_time, last_access_time,"
      "       last_full_update_check_time,"
      "       first_evictable_error_time"
      "  FROM Groups WHERE group_id = ?";

  sql::Statement statement(db_->GetCachedStatement(SQL_FROM_HERE, kSql));

  statement.BindInt64(0, group_id);
  if (!statement.Step())
    return false;

  ReadGroupRecord(statement, record);
  DCHECK(record->group_id == group_id);
  return true;
}

  AppCacheServiceImpl* service() { return service_.get(); }

bool AppCacheUpdateJob::MaybeLoadFromNewestCache(const GURL& url,
                                                 AppCacheEntry& entry) {
  if (update_type_ != UPGRADE_ATTEMPT)
    return false;

  AppCache* newest = group_->newest_complete_cache();
  AppCacheEntry* copy_me = newest->GetEntry(url);
  if (!copy_me || !copy_me->has_response_id())
    return false;

  loading_responses_.insert(
      LoadingResponses::value_type(copy_me->response_id(), url));
  storage_->LoadResponseInfo(manifest_url_, copy_me->response_id(), this);
  return true;
}

  void Verify_LoadCache_Miss() {
    EXPECT_EQ(111, delegate()->loaded_cache_id_);
    EXPECT_FALSE(delegate()->loaded_cache_.get());
    EXPECT_EQ(0, mock_quota_manager_proxy_->notify_storage_accessed_count_);
    EXPECT_EQ(0, mock_quota_manager_proxy_->notify_storage_modified_count_);
    TestFinished();
  }

bool AppCache::FindResponseForRequest(const GURL& url,
    AppCacheEntry* found_entry, GURL* found_intercept_namespace,
    AppCacheEntry* found_fallback_entry, GURL* found_fallback_namespace,
    bool* found_network_namespace) {
  GURL url_no_ref;
  if (url.has_ref()) {
    GURL::Replacements replacements;
    replacements.ClearRef();
    url_no_ref = url.ReplaceComponents(replacements);
  } else {
    url_no_ref = url;
  }


  AppCacheEntry* entry = GetEntry(url_no_ref);
  if (entry) {
    *found_entry = *entry;
    return true;
  }

  *found_network_namespace = IsInNetworkNamespace(url_no_ref);
  if (*found_network_namespace)
    return true;

  const AppCacheNamespace* intercept_namespace =
      FindInterceptNamespace(url_no_ref);
  if (intercept_namespace) {
    entry = GetEntry(intercept_namespace->target_url);
    DCHECK(entry);
    *found_entry = *entry;
    *found_intercept_namespace = intercept_namespace->namespace_url;
    return true;
  }

  const AppCacheNamespace* fallback_namespace =
      FindFallbackNamespace(url_no_ref);
  if (fallback_namespace) {
    entry = GetEntry(fallback_namespace->target_url);
    DCHECK(entry);
    *found_fallback_entry = *entry;
    *found_fallback_namespace = fallback_namespace->namespace_url;
    return true;
  }

  *found_network_namespace = online_whitelist_all_;
  return *found_network_namespace;
}

  void CreateGroupInPopulatedOrigin() {
    PushNextTask(base::BindOnce(&AppCacheStorageImplTest::Verify_CreateGroup,
                                base::Unretained(this)));

    storage()->usage_map_[kOrigin] = kDefaultEntrySize;

    storage()->LoadOrCreateGroup(kManifestUrl, delegate());
    EXPECT_FALSE(delegate()->loaded_group_.get());
  }

void AppCacheUpdateJob::NotifyAllAssociatedHosts(
    blink::mojom::AppCacheEventID event_id) {
  HostNotifier host_notifier;
  AddAllAssociatedHostsToNotifier(&host_notifier);
  host_notifier.SendNotifications(event_id);
}

void AppCacheUpdateJob::DeleteSoon() {
  ClearPendingMasterEntries();
  manifest_response_writer_.reset();
  storage_->CancelDelegateCallbacks(this);
  service_->RemoveObserver(this);
  service_ = nullptr;

  if (group_) {
    group_->SetUpdateAppCacheStatus(AppCacheGroup::IDLE);
    group_ = nullptr;
  }

  base::ThreadTaskRunnerHandle::Get()->DeleteSoon(FROM_HERE, this);
}

AppCacheUpdateJob::CreateResponseWriter() {
  std::unique_ptr<AppCacheResponseWriter> writer =
      storage_->CreateResponseWriter(manifest_url_);
  stored_response_ids_.push_back(writer->response_id());
  return writer;
}

std::unique_ptr<SymmetricKey> CopyDefaultPaddingKey() {
  return SymmetricKey::Import(kPaddingKeyAlgorithm, (*GetPaddingKey())->key());
}

void AppCacheUpdateJob::HandleUrlFetchCompleted(URLFetcher* fetcher,
int net_error) {
DCHECK(internal_state_ == DOWNLOADING);

UpdateURLLoaderRequest* request = fetcher->request();
const GURL& url = request->GetURL();
pending_url_fetches_.erase(url);
NotifyAllProgress(url);
++url_fetches_completed_;

int response_code = net_error == net::OK ? request->GetResponseCode()
: fetcher->redirect_response_code();

AppCacheEntry& entry = url_file_list_.find(url)->second;

if (response_code / 100 == 2) {
// Associate storage with the new entry.
DCHECK(fetcher->response_writer());
entry.set_response_id(fetcher->response_writer()->response_id());
    entry.set_response_size(fetcher->response_writer()->amount_written());
if (!inprogress_cache_->AddOrModifyEntry(url, entry))
duplicate_response_ids_.push_back(entry.response_id());

// TODO(michaeln): Check for <html manifest=xxx>
// See http://code.google.com/p/chromium/issues/detail?id=97930
// if (entry.IsMaster() && !(entry.IsExplicit() || fallback || intercept))
//   if (!manifestAttribute) skip it

// Foreign entries will be detected during cache selection.
// Note: 6.9.4, step 17.9 possible optimization: if resource is HTML or XML
// file whose root element is an html element with a manifest attribute
// whose value doesn't match the manifest url of the application cache
// being processed, mark the entry as being foreign.
} else {
VLOG(1) << "Request error: " << net_error
<< " response code: " << response_code;
if (entry.IsExplicit() || entry.IsFallback() || entry.IsIntercept()) {
if (response_code == 304 && fetcher->existing_entry().has_response_id()) {
// Keep the existing response.
entry.set_response_id(fetcher->existing_entry().response_id());
        entry.set_response_size(fetcher->existing_entry().response_size());
inprogress_cache_->AddOrModifyEntry(url, entry);
} else {
const char kFormatString[] = "Resource fetch failed (%d) %s";
std::string message = FormatUrlErrorMessage(
kFormatString, url, fetcher->result(), response_code);
ResultType result = fetcher->result();
bool is_cross_origin = url.GetOrigin() != manifest_url_.GetOrigin();
switch (result) {
case DISKCACHE_ERROR:
HandleCacheFailure(
blink::mojom::AppCacheErrorDetails(
message,
blink::mojom::AppCacheErrorReason::APPCACHE_UNKNOWN_ERROR,
GURL(), 0, is_cross_origin),
result, url);
break;
case NETWORK_ERROR:
HandleCacheFailure(
blink::mojom::AppCacheErrorDetails(
message,
blink::mojom::AppCacheErrorReason::APPCACHE_RESOURCE_ERROR,
url, 0, is_cross_origin),
result, url);
break;
default:
HandleCacheFailure(
blink::mojom::AppCacheErrorDetails(
message,
blink::mojom::AppCacheErrorReason::APPCACHE_RESOURCE_ERROR,
url, response_code, is_cross_origin),
result, url);
break;
}
return;
}
} else if (response_code == 404 || response_code == 410) {
// Entry is skipped.  They are dropped from the cache.
} else if (update_type_ == UPGRADE_ATTEMPT &&
fetcher->existing_entry().has_response_id()) {
// Keep the existing response.
// TODO(michaeln): Not sure this is a good idea. This is spec compliant
// but the old resource may or may not be compatible with the new contents
// of the cache. Impossible to know one way or the other.
entry.set_response_id(fetcher->existing_entry().response_id());
      entry.set_response_size(fetcher->existing_entry().response_size());
inprogress_cache_->AddOrModifyEntry(url, entry);
}
}

// Fetch another URL now that one request has completed.
DCHECK(internal_state_ != CACHE_FAILURE);
FetchUrls();
MaybeCompleteUpdate();
}

  net::CompletionOnceCallback deletion_callback() {
    return base::BindOnce(&AppCacheServiceImplTest::OnDeleteAppCachesComplete,
                          base::Unretained(this));
  }

  void LoadGroupAndCache_FarHit() {
    PushNextTask(
        base::BindOnce(&AppCacheStorageImplTest::Verify_LoadCache_Far_Hit,
                       base::Unretained(this)));

    MakeCacheAndGroup(kManifestUrl, 1, 1, true);
    group_ = nullptr;
    cache_ = nullptr;

    storage()->LoadCache(1, delegate());
  }

  void FindInterceptPatternMatchInWorkingSet() {
    FindInterceptPatternMatch(false);
  }

void AppCacheUpdateJob::HandleMasterEntryFetchCompleted(URLFetcher* fetcher,
int net_error) {
DCHECK(internal_state_ == NO_UPDATE || internal_state_ == DOWNLOADING);

// TODO(jennb): Handle downloads completing during cache failure when update
// no longer fetches master entries directly. For now, we cancel all pending
// master entry fetches when entering cache failure state so this will never
// be called in CACHE_FAILURE state.

UpdateURLLoaderRequest* request = fetcher->request();
const GURL& url = request->GetURL();
master_entry_fetches_.erase(url);
++master_entries_completed_;

int response_code = net_error == net::OK ? request->GetResponseCode() : -1;

auto found = pending_master_entries_.find(url);
DCHECK(found != pending_master_entries_.end());
PendingHosts& hosts = found->second;

// Section 6.9.4. No update case: step 7.3, else step 22.
if (response_code / 100 == 2) {
// Add fetched master entry to the appropriate cache.
AppCache* cache = inprogress_cache_.get() ? inprogress_cache_.get()
: group_->newest_complete_cache();
DCHECK(fetcher->response_writer());
    AppCacheEntry master_entry(AppCacheEntry::MASTER,
                               fetcher->response_writer()->response_id(),
                               fetcher->response_writer()->amount_written());
if (cache->AddOrModifyEntry(url, master_entry))
added_master_entries_.push_back(url);
else
duplicate_response_ids_.push_back(master_entry.response_id());

// In no-update case, associate host with the newest cache.
if (!inprogress_cache_.get()) {
// TODO(michaeln): defer until the updated cache has been stored
DCHECK(cache == group_->newest_complete_cache());
for (AppCacheHost* host : hosts)
host->AssociateCompleteCache(cache);
}
} else {
HostNotifier host_notifier;
for (AppCacheHost* host : hosts) {
host_notifier.AddHost(host);

// In downloading case, disassociate host from inprogress cache.
if (inprogress_cache_.get())
host->AssociateNoCache(GURL());

host->RemoveObserver(this);
}
hosts.clear();

failed_master_entries_.insert(url);

const char kFormatString[] = "Manifest fetch failed (%d) %s";
std::string message = FormatUrlErrorMessage(
kFormatString, request->GetURL(), fetcher->result(), response_code);
host_notifier.SendErrorNotifications(blink::mojom::AppCacheErrorDetails(
message, blink::mojom::AppCacheErrorReason::APPCACHE_MANIFEST_ERROR,
request->GetURL(), response_code, false /*is_cross_origin*/));

// In downloading case, update result is different if all master entries
// failed vs. only some failing.
if (inprogress_cache_.get()) {
// Only count successful downloads to know if all master entries failed.
pending_master_entries_.erase(found);
--master_entries_completed_;

// Section 6.9.4, step 22.3.
if (update_type_ == CACHE_ATTEMPT && pending_master_entries_.empty()) {
HandleCacheFailure(
blink::mojom::AppCacheErrorDetails(
message,
blink::mojom::AppCacheErrorReason::APPCACHE_MANIFEST_ERROR,
request->GetURL(), response_code, false /*is_cross_origin*/),
fetcher->result(), GURL());
return;
}
}
}

DCHECK(internal_state_ != CACHE_FAILURE);
FetchMasterEntries();
MaybeCompleteUpdate();
}

void AppCache::InitializeWithDatabaseRecords(
const AppCacheDatabase::CacheRecord& cache_record,
const std::vector<AppCacheDatabase::EntryRecord>& entries,
const std::vector<AppCacheDatabase::NamespaceRecord>& intercepts,
const std::vector<AppCacheDatabase::NamespaceRecord>& fallbacks,
const std::vector<AppCacheDatabase::OnlineWhiteListRecord>& whitelists) {
  DCHECK(cache_id_ == cache_record.cache_id);
online_whitelist_all_ = cache_record.online_wildcard;
update_time_ = cache_record.update_time;

for (size_t i = 0; i < entries.size(); ++i) {
const AppCacheDatabase::EntryRecord& entry = entries.at(i);
AddEntry(entry.url, AppCacheEntry(entry.flags, entry.response_id,
                                      entry.response_size));
}
  DCHECK(cache_size_ == cache_record.cache_size);

for (size_t i = 0; i < intercepts.size(); ++i)
intercept_namespaces_.push_back(intercepts.at(i).namespace_);

for (size_t i = 0; i < fallbacks.size(); ++i)
fallback_namespaces_.push_back(fallbacks.at(i).namespace_);

// Sort the fallback namespaces by url string length, longest to shortest,
// since longer matches trump when matching a url to a namespace.
std::sort(intercept_namespaces_.begin(), intercept_namespaces_.end(),
SortNamespacesByLength);
std::sort(fallback_namespaces_.begin(), fallback_namespaces_.end(),
SortNamespacesByLength);

for (size_t i = 0; i < whitelists.size(); ++i) {
const AppCacheDatabase::OnlineWhiteListRecord& record = whitelists.at(i);
online_whitelist_namespaces_.push_back(
AppCacheNamespace(APPCACHE_NETWORK_NAMESPACE,
record.namespace_url,
GURL(),
record.is_pattern));
}
}

  void SendLogMessage(const std::string& message) {
    for (auto* frontend : hosts_to_notify_)
      frontend->LogMessage(blink::mojom::ConsoleMessageLevel::kWarning,
                           message);
  }

int64_t AppCacheDatabase::GetOriginUsage(const url::Origin& origin) {
  std::vector<CacheRecord> records;
  if (!FindCachesForOrigin(origin, &records))
return 0;

int64_t origin_usage = 0;
  for (const auto& record : records)
    origin_usage += record.cache_size;
return origin_usage;
}

  int GetResponseInfoSize(const net::HttpResponseInfo* info) {
    base::Pickle pickle;
    return PickleResponseInfo(&pickle, info);
  }

 int64_t ComputeResponsePadding(const std::string& response_url,
                               const crypto::SymmetricKey* padding_key,
                               bool has_metadata) {
  DCHECK(!response_url.empty());

  crypto::HMAC hmac(crypto::HMAC::SHA256);
  CHECK(hmac.Init(padding_key));

  std::string key = has_metadata ? response_url + "METADATA" : response_url;
  uint64_t digest_start;
  CHECK(hmac.Sign(key, reinterpret_cast<uint8_t*>(&digest_start),
                  sizeof(digest_start)));
  return digest_start % kPaddingRange;
}

  void SendNotifications(blink::mojom::AppCacheEventID event_id) {
    for (auto* frontend : hosts_to_notify_)
      frontend->EventRaised(event_id);
  }

  void SetUpTest() {
    DCHECK(io_runner->BelongsToCurrentThread());
    service_.reset(new AppCacheServiceImpl(nullptr));
    service_->Initialize(base::FilePath());
    mock_quota_manager_proxy_ = new MockQuotaManagerProxy();
    service_->quota_manager_proxy_ = mock_quota_manager_proxy_;
    delegate_.reset(new MockStorageDelegate(this));
  }

void AppCacheUpdateJob::MaybeCompleteUpdate() {
  DCHECK(internal_state_ != CACHE_FAILURE);

  if (master_entries_completed_ != pending_master_entries_.size() ||
      url_fetches_completed_ != url_file_list_.size()) {
    DCHECK(internal_state_ != COMPLETED);
    return;
  }

  switch (internal_state_) {
    case NO_UPDATE:
      if (master_entries_completed_ > 0) {
        switch (stored_state_) {
          case UNSTORED:
            StoreGroupAndCache();
            return;
          case STORING:
            return;
          case STORED:
            break;
        }
      } else {
        bool times_changed = false;
        if (!group_->first_evictable_error_time().is_null()) {
          group_->set_first_evictable_error_time(base::Time());
          times_changed = true;
        }
        if (doing_full_update_check_) {
          group_->set_last_full_update_check_time(base::Time::Now());
          times_changed = true;
        }
        if (times_changed)
          storage_->StoreEvictionTimes(group_);
      }
      group_->SetUpdateAppCacheStatus(AppCacheGroup::IDLE);
      NotifyAllAssociatedHosts(
          blink::mojom::AppCacheEventID::APPCACHE_NO_UPDATE_EVENT);
      DiscardDuplicateResponses();
      internal_state_ = COMPLETED;
      break;
    case DOWNLOADING:
      internal_state_ = REFETCH_MANIFEST;
      FetchManifest(false);
      break;
    case REFETCH_MANIFEST:
      DCHECK(stored_state_ == STORED);
      NotifyAllFinalProgress();
      group_->SetUpdateAppCacheStatus(AppCacheGroup::IDLE);
      if (update_type_ == CACHE_ATTEMPT)
        NotifyAllAssociatedHosts(
            blink::mojom::AppCacheEventID::APPCACHE_CACHED_EVENT);
      else
        NotifyAllAssociatedHosts(
            blink::mojom::AppCacheEventID::APPCACHE_UPDATE_READY_EVENT);
      DiscardDuplicateResponses();
      internal_state_ = COMPLETED;
      LogHistogramStats(UPDATE_OK, GURL());
      break;
    case CACHE_FAILURE:
      NOTREACHED();  // See HandleCacheFailure
      break;
    default:
      break;
  }

  if (internal_state_ == COMPLETED)
    DeleteSoon();
}

  void Reinitialize2() {
    Reinitialize(CORRUPT_CACHE_ON_LOAD_EXISTING);
  }

  void FindMainResponseExclusions(bool drop_from_working_set) {
    MakeCacheAndGroup(kManifestUrl, 1, 1, true);
    cache_->AddEntry(
        kEntryUrl,
        AppCacheEntry(AppCacheEntry::EXPLICIT | AppCacheEntry::FOREIGN, 1));
    cache_->AddEntry(kEntryUrl2, AppCacheEntry(AppCacheEntry::FALLBACK, 2));
    cache_->fallback_namespaces_.push_back(AppCacheNamespace(
        APPCACHE_FALLBACK_NAMESPACE, kFallbackNamespace, kEntryUrl2, false));
    cache_->online_whitelist_namespaces_.push_back(AppCacheNamespace(
        APPCACHE_NETWORK_NAMESPACE, kOnlineNamespace, GURL(), false));
    cache_->online_whitelist_namespaces_.push_back(
        AppCacheNamespace(APPCACHE_NETWORK_NAMESPACE,
                          kOnlineNamespaceWithinFallback, GURL(), false));

    AppCacheDatabase::EntryRecord entry_record;
    entry_record.cache_id = 1;
    entry_record.url = kEntryUrl;
    entry_record.flags = AppCacheEntry::EXPLICIT | AppCacheEntry::FOREIGN;
    entry_record.response_id = 1;
    EXPECT_TRUE(database()->InsertEntry(&entry_record));
    AppCacheDatabase::OnlineWhiteListRecord whitelist_record;
    whitelist_record.cache_id = 1;
    whitelist_record.namespace_url = kOnlineNamespace;
    EXPECT_TRUE(database()->InsertOnlineWhiteList(&whitelist_record));
    AppCacheDatabase::NamespaceRecord fallback_namespace_record;
    fallback_namespace_record.cache_id = 1;
    fallback_namespace_record.namespace_.target_url = kEntryUrl2;
    fallback_namespace_record.namespace_.namespace_url = kFallbackNamespace;
    fallback_namespace_record.origin = url::Origin::Create(kManifestUrl);
    EXPECT_TRUE(database()->InsertNamespace(&fallback_namespace_record));
    whitelist_record.cache_id = 1;
    whitelist_record.namespace_url = kOnlineNamespaceWithinFallback;
    EXPECT_TRUE(database()->InsertOnlineWhiteList(&whitelist_record));
    if (drop_from_working_set) {
      cache_ = nullptr;
      group_ = nullptr;
    }

    PushNextTask(
        base::BindOnce(&AppCacheStorageImplTest::Verify_ExclusionNotFound,
                       base::Unretained(this), kEntryUrl, 1));
    storage()->FindResponseForMainRequest(kEntryUrl, GURL(), delegate());
  }

  void BasicFindMainResponse(bool drop_from_working_set) {
    PushNextTask(
        base::BindOnce(&AppCacheStorageImplTest::Verify_BasicFindMainResponse,
                       base::Unretained(this)));

    MakeCacheAndGroup(kManifestUrl, 2, 1, true);
    cache_->AddEntry(kEntryUrl, AppCacheEntry(AppCacheEntry::EXPLICIT, 1));
    AppCacheDatabase::EntryRecord entry_record;
    entry_record.cache_id = 1;
    entry_record.url = kEntryUrl;
    entry_record.flags = AppCacheEntry::EXPLICIT;
    entry_record.response_id = 1;
    EXPECT_TRUE(database()->InsertEntry(&entry_record));

    if (drop_from_working_set) {
      EXPECT_TRUE(cache_->HasOneRef());
      cache_ = nullptr;
      EXPECT_TRUE(group_->HasOneRef());
      group_ = nullptr;
    }

    storage()->FindResponseForMainRequest(kEntryUrl, GURL(), delegate());
    EXPECT_NE(kEntryUrl, delegate()->found_url_);
  }

  static void TearDownTestCase() {
    io_runner.reset();
    background_thread.reset();
    scoped_task_environment.reset();
  }

  void FlushTasks(base::SequencedTaskRunner* runner) {
    base::WaitableEvent event(base::WaitableEvent::ResetPolicy::AUTOMATIC,
                              base::WaitableEvent::InitialState::NOT_SIGNALED);
    runner->PostTask(
        FROM_HERE,
        base::BindOnce(&AppCacheStorageImplTest::SignalEvent, &event));
    event.Wait();
  }

  void SendErrorNotifications(
      const blink::mojom::AppCacheErrorDetails& details) {
    DCHECK(!details.message.empty());
    for (auto* frontend : hosts_to_notify_)
      frontend->ErrorEventRaised(details.Clone());
  }

    explicit MockServiceObserver(AppCacheStorageImplTest* test) : test_(test) {}

void AppCacheUpdateJob::OnResponseInfoLoaded(
AppCacheResponseInfo* response_info,
int64_t response_id) {
const net::HttpResponseInfo* http_info =
response_info ? &response_info->http_response_info() : nullptr;

// Needed response info for a manifest fetch request.
if (internal_state_ == FETCH_MANIFEST) {
if (http_info)
manifest_fetcher_->set_existing_response_headers(
http_info->headers.get());
manifest_fetcher_->Start();
return;
}

auto found = loading_responses_.find(response_id);
DCHECK(found != loading_responses_.end());
const GURL& url = found->second;

if (!http_info) {
LoadFromNewestCacheFailed(url, nullptr);  // no response found
} else if (!CanUseExistingResource(http_info)) {
LoadFromNewestCacheFailed(url, response_info);
} else {
DCHECK(group_->newest_complete_cache());
AppCacheEntry* copy_me = group_->newest_complete_cache()->GetEntry(url);
DCHECK(copy_me);
DCHECK_EQ(copy_me->response_id(), response_id);

auto it = url_file_list_.find(url);
DCHECK(it != url_file_list_.end());
AppCacheEntry& entry = it->second;
entry.set_response_id(response_id);
    entry.set_response_size(copy_me->response_size());
inprogress_cache_->AddOrModifyEntry(url, entry);
NotifyAllProgress(url);
++url_fetches_completed_;
}

loading_responses_.erase(found);
MaybeCompleteUpdate();
}

bool AppCacheDatabase::DeleteDeletableResponseIds(
    const std::vector<int64_t>& response_ids) {
  static const char kSql[] =
      "DELETE FROM DeletableResponseIds WHERE response_id = ?";
  return RunCachedStatementWithIds(SQL_FROM_HERE, kSql, response_ids);
}

void AppCache::UnassociateHost(AppCacheHost* host) {
  associated_hosts_.erase(host);
}

bool AppCacheDatabase::GetDeletableResponseIds(
    std::vector<int64_t>* response_ids,
    int64_t max_rowid,
    int limit) {
  if (!LazyOpen(kDontCreate))
    return false;

  static const char kSql[] =
      "SELECT response_id FROM DeletableResponseIds "
      "  WHERE rowid <= ?"
      "  LIMIT ?";

  sql::Statement statement(db_->GetCachedStatement(SQL_FROM_HERE, kSql));
  statement.BindInt64(0, max_rowid);
  statement.BindInt64(1, limit);

  while (statement.Step())
    response_ids->push_back(statement.ColumnInt64(0));
  return statement.Succeeded();
}

AppCacheDatabase::AppCacheDatabase(const base::FilePath& path)
    : db_file_path_(path),
      is_disabled_(false),
      is_recreating_(false),
      was_corruption_detected_(false) {
}

  void MarkEntryAsForeignWithLoadInProgress() {
    PushNextTask(base::BindOnce(
        &AppCacheStorageImplTest::Verify_MarkEntryAsForeignWithLoadInProgress,
        base::Unretained(this)));

    MakeCacheAndGroup(kManifestUrl, 1, 1, true);
    cache_->AddEntry(kEntryUrl, AppCacheEntry(AppCacheEntry::EXPLICIT));
    AppCacheDatabase::EntryRecord entry_record;
    entry_record.cache_id = 1;
    entry_record.url = kEntryUrl;
    entry_record.flags = AppCacheEntry::EXPLICIT;
    entry_record.response_id = 0;
    EXPECT_TRUE(database()->InsertEntry(&entry_record));
    EXPECT_FALSE(cache_->GetEntry(kEntryUrl)->IsForeign());
    EXPECT_TRUE(cache_->HasOneRef());
    cache_ = nullptr;
    group_ = nullptr;

    storage()->LoadCache(1, delegate());
    storage()->MarkEntryAsForeign(kEntryUrl, 1);
  }

void AppCacheUpdateJob::OnGroupAndNewestCacheStored(AppCacheGroup* group,
                                                    AppCache* newest_cache,
                                                    bool success,
                                                    bool would_exceed_quota) {
  DCHECK(stored_state_ == STORING);
  if (success) {
    stored_state_ = STORED;
    MaybeCompleteUpdate();  // will definitely complete
    return;
  }

  stored_state_ = UNSTORED;

  if (newest_cache != group->newest_complete_cache())
    inprogress_cache_ = newest_cache;

  ResultType result = DB_ERROR;
  blink::mojom::AppCacheErrorReason reason =
      blink::mojom::AppCacheErrorReason::APPCACHE_UNKNOWN_ERROR;
  std::string message("Failed to commit new cache to storage");
  if (would_exceed_quota) {
    message.append(", would exceed quota");
    result = QUOTA_ERROR;
    reason = blink::mojom::AppCacheErrorReason::APPCACHE_QUOTA_ERROR;
  }
  HandleCacheFailure(blink::mojom::AppCacheErrorDetails(
                         message, reason, GURL(), 0, false /*is_cross_origin*/),
                     result, GURL());
}

void ResetPaddingKeyForTesting() {
  *GetPaddingKey() = SymmetricKey::GenerateRandomKey(kPaddingKeyAlgorithm, 128);
}

void Verify_StoreExistingGroup() {
EXPECT_TRUE(delegate()->stored_group_success_);
EXPECT_EQ(group_.get(), delegate()->stored_group_.get());
EXPECT_EQ(cache2_.get(), group_->newest_complete_cache());
EXPECT_TRUE(cache2_->is_complete());

// The new cache should have been stored in the database.
AppCacheDatabase::GroupRecord group_record;
AppCacheDatabase::CacheRecord cache_record;
EXPECT_TRUE(database()->FindGroup(1, &group_record));
EXPECT_TRUE(database()->FindCache(2, &cache_record));

// The old cache should have been deleted
EXPECT_FALSE(database()->FindCache(1, &cache_record));

// Verify quota bookkeeping
    EXPECT_EQ(kDefaultEntrySize + 100, storage()->usage_map_[kOrigin]);
EXPECT_EQ(1, mock_quota_manager_proxy_->notify_storage_modified_count_);
EXPECT_EQ(kOrigin, mock_quota_manager_proxy_->last_origin_);
    EXPECT_EQ(100, mock_quota_manager_proxy_->last_delta_);

TestFinished();
}

void AppCacheUpdateJob::DiscardInprogressCache() {
  if (stored_state_ == STORING) {
    inprogress_cache_ = nullptr;
    added_master_entries_.clear();
    return;
  }

  storage_->DoomResponses(manifest_url_, stored_response_ids_);

  if (!inprogress_cache_.get()) {
    if (group_ && group_->newest_complete_cache()) {
      for (auto& url : added_master_entries_)
        group_->newest_complete_cache()->RemoveEntry(url);
    }
    added_master_entries_.clear();
    return;
  }

  AppCache::AppCacheHosts& hosts = inprogress_cache_->associated_hosts();
  while (!hosts.empty())
    (*hosts.begin())->AssociateNoCache(GURL());

  inprogress_cache_ = nullptr;
  added_master_entries_.clear();
}

bool AppCacheDatabase::InsertNamespaceRecords(
    const std::vector<NamespaceRecord>& records) {
  if (records.empty())
    return true;
  sql::Transaction transaction(db_.get());
  if (!transaction.Begin())
    return false;
  for (const auto& record : records) {
    if (!InsertNamespace(&record))
      return false;
  }
  return transaction.Commit();
}

void SetupMockGroup() {
std::unique_ptr<net::HttpResponseInfo> info(MakeMockResponseInfo());
const int kMockInfoSize = GetResponseInfoSize(info.get());

// Create a mock group, cache, and entry and stuff them into mock storage.
scoped_refptr<AppCacheGroup> group(
new AppCacheGroup(service_->storage(), kManifestUrl, kMockGroupId));
scoped_refptr<AppCache> cache(
new AppCache(service_->storage(), kMockCacheId));
cache->AddEntry(
kManifestUrl,
AppCacheEntry(AppCacheEntry::MANIFEST, kMockResponseId,
                      kMockInfoSize + kMockBodySize));
cache->set_complete(true);
group->AddCache(cache.get());
mock_storage()->AddStoredGroup(group.get());
mock_storage()->AddStoredCache(cache.get());
}

bool AppCacheDatabase::DeleteNamespacesForCache(int64_t cache_id) {
  if (!LazyOpen(kDontCreate))
    return false;

  static const char kSql[] = "DELETE FROM Namespaces WHERE cache_id = ?";

  sql::Statement statement(db_->GetCachedStatement(SQL_FROM_HERE, kSql));
  statement.BindInt64(0, cache_id);

  return statement.Run();
}

bool AppCacheDatabase::FindCacheForGroup(int64_t group_id,
CacheRecord* record) {
DCHECK(record);
if (!LazyOpen(kDontCreate))
return false;

static const char kSql[] =
      "SELECT cache_id, group_id, online_wildcard, update_time, cache_size"
"  FROM Caches WHERE group_id = ?";

sql::Statement statement(db_->GetCachedStatement(SQL_FROM_HERE, kSql));
statement.BindInt64(0, group_id);

if (!statement.Step())
return false;

ReadCacheRecord(statement, record);
return true;
}

std::unique_ptr<SymmetricKey>* GetPaddingKey() {
   static base::NoDestructor<std::unique_ptr<SymmetricKey>> s_padding_key([] {
     return SymmetricKey::GenerateRandomKey(kPaddingKeyAlgorithm, 128);
   }());
  return s_padding_key.get();
}

  void OnDeleteAppCachesComplete(int result) {
    delete_result_ = result;
    ++delete_completion_count_;
  }

AppCacheEntry* AppCache::GetEntry(const GURL& url) {
  auto it = entries_.find(url);
  return (it != entries_.end()) ? &(it->second) : nullptr;
}

bool AppCacheDatabase::DeleteGroup(int64_t group_id) {
  if (!LazyOpen(kDontCreate))
    return false;

  static const char kSql[] = "DELETE FROM Groups WHERE group_id = ?";
  sql::Statement statement(db_->GetCachedStatement(SQL_FROM_HERE, kSql));
  statement.BindInt64(0, group_id);
  return statement.Run();
}

  MockAppCacheStorage* mock_storage() {
    return static_cast<MockAppCacheStorage*>(service_->storage());
  }

bool AppCacheDatabase::UpdateEvictionTimes(
    int64_t group_id,
    base::Time last_full_update_check_time,
    base::Time first_evictable_error_time) {
  if (!LazyOpen(kCreateIfNeeded))
    return false;

  static const char kSql[] =
      "UPDATE Groups"
      " SET last_full_update_check_time = ?, first_evictable_error_time = ?"
      " WHERE group_id = ?";
  sql::Statement statement(db_->GetCachedStatement(SQL_FROM_HERE, kSql));
  statement.BindInt64(0, last_full_update_check_time.ToInternalValue());
  statement.BindInt64(1, first_evictable_error_time.ToInternalValue());
  statement.BindInt64(2, group_id);
  return statement.Run();  // Will succeed even if group_id is invalid.
}

  void Verify_Reinitialized(ReinitTestCase test_case) {
    EXPECT_TRUE(observer_->observed_old_storage_.get());
    EXPECT_TRUE(observer_->observed_old_storage_->storage() != storage());
    EXPECT_FALSE(PathExists(
        temp_directory_.GetPath().AppendASCII("Cache").AppendASCII("index")));
    EXPECT_FALSE(PathExists(temp_directory_.GetPath().AppendASCII("Index")));

    if (test_case == CORRUPT_SQL_ON_INSTALL) {
      AppCacheStorageImpl* storage = static_cast<AppCacheStorageImpl*>(
          observer_->observed_old_storage_->storage());
      EXPECT_TRUE(storage->database_->was_corruption_detected());
    }

    if (test_case == CORRUPT_CACHE_ON_INSTALL ||
        test_case == CORRUPT_SQL_ON_INSTALL) {
      EXPECT_TRUE(frontend_.error_event_was_raised_);
      AppCacheHost* host1 = backend_->GetHost(1);
      EXPECT_FALSE(host1->associated_cache());
      EXPECT_FALSE(host1->group_being_updated_.get());
      EXPECT_TRUE(host1->disabled_storage_reference_.get());
    } else {
      ASSERT_EQ(CORRUPT_CACHE_ON_LOAD_EXISTING, test_case);
      AppCacheHost* host2 = backend_->GetHost(2);
      EXPECT_TRUE(host2->disabled_storage_reference_.get());
    }

    service_->RemoveObserver(observer_.get());
    handler_.reset();
    backend_.reset();
    observer_.reset();
    TestFinished();
  }

  void SendProgressNotifications(const GURL& url,
                                 int num_total,
                                 int num_complete) {
    for (auto* frontend : hosts_to_notify_)
      frontend->ProgressEventRaised(url, num_total, num_complete);
  }

void FailStoreGroup() {
// Store a group and its newest cache. Should complete asynchronously.
PushNextTask(base::BindOnce(&AppCacheStorageImplTest::Verify_FailStoreGroup,
base::Unretained(this)));

    // Setup some preconditions. Create a group and newest cache that
// appear to be "unstored" and big enough to exceed the 5M limit.
const int64_t kTooBig = 10 * 1024 * 1024;  // 10M
group_ =
new AppCacheGroup(storage(), kManifestUrl, storage()->NewGroupId());
cache_ = new AppCache(storage(), storage()->NewCacheId());
    cache_->AddEntry(kManifestUrl,
                     AppCacheEntry(AppCacheEntry::MANIFEST, 1, kTooBig));
    // Hold a ref to the cache simulate the UpdateJob holding that ref,
// and hold a ref to the group to simulate the CacheHost holding that ref.

// Conduct the store test.
storage()->StoreGroupAndNewestCache(group_.get(), cache_.get(), delegate());
EXPECT_FALSE(delegate()->stored_group_success_);  // Expected to be async.
}

void MakeGroupObsolete() {
// Make a group obsolete, should complete asynchronously.
PushNextTask(
base::BindOnce(&AppCacheStorageImplTest::Verify_MakeGroupObsolete,
base::Unretained(this)));

// Setup some preconditions. Create a group and newest cache that
// appears to be "stored" and "currently in use".
MakeCacheAndGroup(kManifestUrl, 1, 1, true);
    EXPECT_EQ(kDefaultEntrySize, storage()->usage_map_[kOrigin]);

// Also insert some related records.
AppCacheDatabase::EntryRecord entry_record;
entry_record.cache_id = 1;
entry_record.flags = AppCacheEntry::FALLBACK;
entry_record.response_id = 1;
entry_record.url = kEntryUrl;
EXPECT_TRUE(database()->InsertEntry(&entry_record));

AppCacheDatabase::NamespaceRecord fallback_namespace_record;
fallback_namespace_record.cache_id = 1;
fallback_namespace_record.namespace_.target_url = kEntryUrl;
fallback_namespace_record.namespace_.namespace_url = kFallbackNamespace;
fallback_namespace_record.origin = url::Origin::Create(kManifestUrl);
EXPECT_TRUE(database()->InsertNamespace(&fallback_namespace_record));

AppCacheDatabase::OnlineWhiteListRecord online_whitelist_record;
online_whitelist_record.cache_id = 1;
online_whitelist_record.namespace_url = kOnlineNamespace;
EXPECT_TRUE(database()->InsertOnlineWhiteList(&online_whitelist_record));

// Conduct the test.
storage()->MakeGroupObsolete(group_.get(), delegate(), 0);
EXPECT_FALSE(group_->is_obsolete());
}

void AppCacheUpdateJob::FetchManifest(bool is_first_fetch) {
  DCHECK(!manifest_fetcher_);
  manifest_fetcher_ =
      new URLFetcher(manifest_url_,
                     is_first_fetch ? URLFetcher::MANIFEST_FETCH
                                    : URLFetcher::MANIFEST_REFETCH,
                     this, kAppCacheFetchBufferSize);

  if (is_first_fetch) {
    AppCacheEntry* entry =
        (update_type_ == UPGRADE_ATTEMPT)
            ? group_->newest_complete_cache()->GetEntry(manifest_url_)
            : nullptr;
    if (entry && !doing_full_update_check_) {
      storage_->LoadResponseInfo(manifest_url_, entry->response_id(), this);
      return;
    }
    manifest_fetcher_->Start();
    return;
  }

  DCHECK(internal_state_ == REFETCH_MANIFEST);
  DCHECK(manifest_response_info_.get());
  manifest_fetcher_->set_existing_response_headers(
      manifest_response_info_->headers.get());
  manifest_fetcher_->Start();
}

    explicit MockStorageDelegate(AppCacheStorageImplTest* test)
        : loaded_cache_id_(0),
          stored_group_success_(false),
          would_exceed_quota_(false),
          obsoleted_success_(false),
          found_cache_id_(blink::mojom::kAppCacheNoCacheId),
          test_(test) {}

  void Verify_FindNoMainResponse() {
    EXPECT_EQ(kEntryUrl, delegate()->found_url_);
    EXPECT_TRUE(delegate()->found_manifest_url_.is_empty());
    EXPECT_EQ(blink::mojom::kAppCacheNoCacheId, delegate()->found_cache_id_);
    EXPECT_EQ(blink::mojom::kAppCacheNoResponseId,
              delegate()->found_entry_.response_id());
    EXPECT_EQ(blink::mojom::kAppCacheNoResponseId,
              delegate()->found_fallback_entry_.response_id());
    EXPECT_TRUE(delegate()->found_namespace_entry_url_.is_empty());
    EXPECT_EQ(0, delegate()->found_entry_.types());
    EXPECT_EQ(0, delegate()->found_fallback_entry_.types());
    TestFinished();
  }

  void MakeMultipleHitCacheAndGroup(const GURL& manifest_url, int id) {
    MakeCacheAndGroup(manifest_url, id, id, true);
    AppCacheDatabase::EntryRecord entry_record;

    entry_record.cache_id = id;
    entry_record.url = kEntryUrl;
    entry_record.flags = AppCacheEntry::EXPLICIT;
    entry_record.response_id = id;
    EXPECT_TRUE(database()->InsertEntry(&entry_record));
    cache_->AddEntry(entry_record.url, AppCacheEntry(entry_record.flags,
                                                     entry_record.response_id));

    entry_record.cache_id = id;
    entry_record.url = manifest_url;
    entry_record.flags = AppCacheEntry::MANIFEST;
    entry_record.response_id = id + kManifestEntryIdOffset;
    EXPECT_TRUE(database()->InsertEntry(&entry_record));
    cache_->AddEntry(entry_record.url, AppCacheEntry(entry_record.flags,
                                                     entry_record.response_id));

    entry_record.cache_id = id;
    entry_record.url = kEntryUrl2;
    entry_record.flags = AppCacheEntry::FALLBACK;
    entry_record.response_id = id + kFallbackEntryIdOffset;
    EXPECT_TRUE(database()->InsertEntry(&entry_record));
    cache_->AddEntry(entry_record.url, AppCacheEntry(entry_record.flags,
                                                     entry_record.response_id));
    AppCacheDatabase::NamespaceRecord fallback_namespace_record;
    fallback_namespace_record.cache_id = id;
    fallback_namespace_record.namespace_.target_url = entry_record.url;
    fallback_namespace_record.namespace_.namespace_url = kFallbackNamespace;
    fallback_namespace_record.origin = url::Origin::Create(manifest_url);
    EXPECT_TRUE(database()->InsertNamespace(&fallback_namespace_record));
    cache_->fallback_namespaces_.push_back(AppCacheNamespace(
        APPCACHE_FALLBACK_NAMESPACE, kFallbackNamespace, kEntryUrl2, false));
  }

void AppCache::ToDatabaseRecords(
    const AppCacheGroup* group,
    AppCacheDatabase::CacheRecord* cache_record,
    std::vector<AppCacheDatabase::EntryRecord>* entries,
    std::vector<AppCacheDatabase::NamespaceRecord>* intercepts,
    std::vector<AppCacheDatabase::NamespaceRecord>* fallbacks,
    std::vector<AppCacheDatabase::OnlineWhiteListRecord>* whitelists) {
  DCHECK(group && cache_record && entries && fallbacks && whitelists);
  DCHECK(entries->empty() && fallbacks->empty() && whitelists->empty());

  cache_record->cache_id = cache_id_;
  cache_record->group_id = group->group_id();
   cache_record->online_wildcard = online_whitelist_all_;
   cache_record->update_time = update_time_;
   cache_record->cache_size = cache_size_;
 
   for (const auto& pair : entries_) {
     entries->push_back(AppCacheDatabase::EntryRecord());
    AppCacheDatabase::EntryRecord& record = entries->back();
    record.url = pair.first;
    record.cache_id = cache_id_;
     record.flags = pair.second.types();
     record.response_id = pair.second.response_id();
     record.response_size = pair.second.response_size();
   }
 
   const url::Origin origin = url::Origin::Create(group->manifest_url());

  for (size_t i = 0; i < intercept_namespaces_.size(); ++i) {
    intercepts->push_back(AppCacheDatabase::NamespaceRecord());
    AppCacheDatabase::NamespaceRecord& record = intercepts->back();
    record.cache_id = cache_id_;
    record.origin = origin;
    record.namespace_ = intercept_namespaces_[i];
  }

  for (size_t i = 0; i < fallback_namespaces_.size(); ++i) {
    fallbacks->push_back(AppCacheDatabase::NamespaceRecord());
    AppCacheDatabase::NamespaceRecord& record = fallbacks->back();
    record.cache_id = cache_id_;
    record.origin = origin;
    record.namespace_ = fallback_namespaces_[i];
  }

  for (size_t i = 0; i < online_whitelist_namespaces_.size(); ++i) {
    whitelists->push_back(AppCacheDatabase::OnlineWhiteListRecord());
    AppCacheDatabase::OnlineWhiteListRecord& record = whitelists->back();
    record.cache_id = cache_id_;
    record.namespace_url = online_whitelist_namespaces_[i].namespace_url;
    record.is_pattern = online_whitelist_namespaces_[i].is_pattern;
  }
}

  void AddHosts(const std::set<AppCacheHost*>& hosts) {
    for (AppCacheHost* host : hosts)
      AddHost(host);
  }

 void AppCacheDatabase::ReadEntryRecord(
    const sql::Statement& statement, EntryRecord* record) {
  record->cache_id = statement.ColumnInt64(0);
  record->url = GURL(statement.ColumnString(1));
   record->flags = statement.ColumnInt(2);
   record->response_id = statement.ColumnInt64(3);
   record->response_size = statement.ColumnInt64(4);
 }

  void TestFinished() {
    DCHECK(io_runner->BelongsToCurrentThread());
    base::SequencedTaskRunnerHandle::Get()->PostTask(
        FROM_HERE, base::BindOnce(&AppCacheStorageImplTest::TestFinishedUnwound,
                                  base::Unretained(this)));
  }

void AppCacheUpdateJob::HandleManifestFetchCompleted(URLFetcher* fetcher,
                                                     int net_error) {
  DCHECK_EQ(internal_state_, FETCH_MANIFEST);
  DCHECK_EQ(manifest_fetcher_, fetcher);

  manifest_fetcher_ = nullptr;

  UpdateURLLoaderRequest* request = fetcher->request();
  int response_code = -1;
  bool is_valid_response_code = false;
  if (net_error == net::OK) {
    response_code = request->GetResponseCode();
    is_valid_response_code = (response_code / 100 == 2);

    std::string mime_type = request->GetMimeType();
    manifest_has_valid_mime_type_ = (mime_type == "text/cache-manifest");
  }

  if (is_valid_response_code) {
    manifest_data_ = fetcher->manifest_data();
    manifest_response_info_.reset(
        new net::HttpResponseInfo(request->GetResponseInfo()));
    if (update_type_ == UPGRADE_ATTEMPT)
      CheckIfManifestChanged();  // continues asynchronously
    else
      ContinueHandleManifestFetchCompleted(true);
  } else if (response_code == 304 && update_type_ == UPGRADE_ATTEMPT) {
    ContinueHandleManifestFetchCompleted(false);
  } else if ((response_code == 404 || response_code == 410) &&
             update_type_ == UPGRADE_ATTEMPT) {
    storage_->MakeGroupObsolete(group_, this, response_code);  // async
  } else {
    const char kFormatString[] = "Manifest fetch failed (%d) %s";
    std::string message = FormatUrlErrorMessage(
        kFormatString, manifest_url_, fetcher->result(), response_code);
    HandleCacheFailure(
        blink::mojom::AppCacheErrorDetails(
            message, blink::mojom::AppCacheErrorReason::APPCACHE_MANIFEST_ERROR,
            manifest_url_, response_code, false /*is_cross_origin*/),
        fetcher->result(), GURL());
  }
}

  void Verify_MarkEntryAsForeignWithLoadInProgress() {
    EXPECT_EQ(1, delegate()->loaded_cache_id_);
    EXPECT_TRUE(delegate()->loaded_cache_.get());

    EXPECT_TRUE(delegate()->loaded_cache_->GetEntry(kEntryUrl)->IsForeign());
    EXPECT_TRUE(delegate()->loaded_cache_->GetEntry(kEntryUrl)->IsExplicit());

    FlushAllTasks();
    AppCacheDatabase::EntryRecord entry_record;
    EXPECT_TRUE(database()->FindEntry(1, kEntryUrl, &entry_record));
    EXPECT_EQ(AppCacheEntry::EXPLICIT | AppCacheEntry::FOREIGN,
              entry_record.flags);
    TestFinished();
  }

  void TestFinishedUnwound() {
    TearDownTest();
    test_finished_event_->Signal();
  }

const AppCacheNamespace* AppCache::FindNamespace(
    const std::vector<AppCacheNamespace>& namespaces,
    const GURL& url) {
  size_t count = namespaces.size();
  for (size_t i = 0; i < count; ++i) {
    if (namespaces[i].IsMatch(url))
      return &namespaces[i];
  }
  return nullptr;
}

  void Verify_FindFallbackPatternMatchPositive() {
    EXPECT_EQ(kFallbackPatternTestPositiveUrl, delegate()->found_url_);
    EXPECT_EQ(kManifestUrl, delegate()->found_manifest_url_);
    EXPECT_EQ(1, delegate()->found_cache_id_);
    EXPECT_EQ(2, delegate()->found_group_id_);
    EXPECT_EQ(1, delegate()->found_fallback_entry_.response_id());
    EXPECT_TRUE(delegate()->found_fallback_entry_.IsFallback());
    EXPECT_EQ(kEntryUrl, delegate()->found_namespace_entry_url_);
    EXPECT_FALSE(delegate()->found_entry_.has_response_id());
    TestFinished();
  }

  void BasicFindMainInterceptResponseInDatabase() {
    BasicFindMainInterceptResponse(true);
  }

  void BasicFindMainInterceptResponse(bool drop_from_working_set) {
    PushNextTask(base::BindOnce(
        &AppCacheStorageImplTest::Verify_BasicFindMainInterceptResponse,
        base::Unretained(this)));

    MakeCacheAndGroup(kManifestUrl, 2, 1, true);
    cache_->AddEntry(kEntryUrl, AppCacheEntry(AppCacheEntry::INTERCEPT, 1));
    cache_->AddEntry(kEntryUrl2, AppCacheEntry(AppCacheEntry::INTERCEPT, 2));
    cache_->intercept_namespaces_.push_back(AppCacheNamespace(
        APPCACHE_INTERCEPT_NAMESPACE, kInterceptNamespace2, kEntryUrl2, false));
    cache_->intercept_namespaces_.push_back(AppCacheNamespace(
        APPCACHE_INTERCEPT_NAMESPACE, kInterceptNamespace, kEntryUrl, false));
    AppCacheDatabase::CacheRecord cache_record;
    std::vector<AppCacheDatabase::EntryRecord> entries;
    std::vector<AppCacheDatabase::NamespaceRecord> intercepts;
    std::vector<AppCacheDatabase::NamespaceRecord> fallbacks;
    std::vector<AppCacheDatabase::OnlineWhiteListRecord> whitelists;
    cache_->ToDatabaseRecords(group_.get(), &cache_record, &entries,
                              &intercepts, &fallbacks, &whitelists);

    for (const auto& entry : entries) {
      if (entry.url != kDefaultEntryUrl)
        EXPECT_TRUE(database()->InsertEntry(&entry));
    }

    EXPECT_TRUE(database()->InsertNamespaceRecords(intercepts));
    EXPECT_TRUE(database()->InsertOnlineWhiteListRecords(whitelists));
    if (drop_from_working_set) {
      EXPECT_TRUE(cache_->HasOneRef());
      cache_ = nullptr;
      EXPECT_TRUE(group_->HasOneRef());
      group_ = nullptr;
    }

    storage()->FindResponseForMainRequest(kInterceptTestUrl, GURL(),
                                          delegate());
    EXPECT_NE(kInterceptTestUrl, delegate()->found_url_);
  }

std::string SerializeDefaultPaddingKey() {
  return (*GetPaddingKey())->key();
}

  void Verify_FailStoreGroup() {
    EXPECT_FALSE(delegate()->stored_group_success_);
    EXPECT_TRUE(delegate()->would_exceed_quota_);

    AppCacheDatabase::GroupRecord group_record;
    AppCacheDatabase::CacheRecord cache_record;
    EXPECT_FALSE(database()->FindGroup(group_->group_id(), &group_record));
    EXPECT_FALSE(database()->FindCache(cache_->cache_id(), &cache_record));

    EXPECT_EQ(0, mock_quota_manager_proxy_->notify_storage_accessed_count_);
    EXPECT_EQ(0, mock_quota_manager_proxy_->notify_storage_modified_count_);

    TestFinished();
  }

 std::unique_ptr<SymmetricKey> DeserializePaddingKey(
    const std::string& raw_key) {
  return SymmetricKey::Import(kPaddingKeyAlgorithm, raw_key);
 }

  void LoadCache_Miss() {
    PushNextTask(base::BindOnce(&AppCacheStorageImplTest::Verify_LoadCache_Miss,
                                base::Unretained(this)));

    storage()->LoadCache(111, delegate());
    EXPECT_NE(111, delegate()->loaded_cache_id_);
  }

bool AppCacheDatabase::InsertNamespace(
    const NamespaceRecord* record) {
  if (!LazyOpen(kCreateIfNeeded))
    return false;

  static const char kSql[] =
      "INSERT INTO Namespaces"
      "  (cache_id, origin, type, namespace_url, target_url, is_pattern)"
      "  VALUES (?, ?, ?, ?, ?, ?)";

  sql::Statement statement(db_->GetCachedStatement(SQL_FROM_HERE, kSql));
  statement.BindInt64(0, record->cache_id);
  statement.BindString(1, SerializeOrigin(record->origin));
  statement.BindInt(2, record->namespace_.type);
  statement.BindString(3, record->namespace_.namespace_url.spec());
  statement.BindString(4, record->namespace_.target_url.spec());
  statement.BindBool(5, record->namespace_.is_pattern);
  return statement.Run();
}

  void PushNextTask(base::OnceClosure task) {
    task_stack_.push(std::move(task));
  }

  void FlushAllTasks() {
    FlushTasks(storage()->db_task_runner_.get());
    FlushTasks(background_thread->task_runner().get());
    FlushTasks(storage()->db_task_runner_.get());
  }

bool AppCacheDatabase::FindEntry(int64_t cache_id,
const GURL& url,
EntryRecord* record) {
DCHECK(record);
if (!LazyOpen(kDontCreate))
return false;

static const char kSql[] =
      "SELECT cache_id, url, flags, response_id, response_size FROM Entries"
"  WHERE cache_id = ? AND url = ?";

sql::Statement statement(db_->GetCachedStatement(SQL_FROM_HERE, kSql));
statement.BindInt64(0, cache_id);
statement.BindString(1, url.spec());

if (!statement.Step())
return false;

ReadEntryRecord(statement, record);
DCHECK(record->cache_id == cache_id);
DCHECK(record->url == url);
return true;
}

void MakeCacheAndGroup(const GURL& manifest_url,
int64_t group_id,
int64_t cache_id,
bool add_to_database) {
AppCacheEntry default_entry(AppCacheEntry::EXPLICIT,
cache_id + kDefaultEntryIdOffset,
                                kDefaultEntrySize);
group_ = new AppCacheGroup(storage(), manifest_url, group_id);
cache_ = new AppCache(storage(), cache_id);
cache_->AddEntry(kDefaultEntryUrl, default_entry);
cache_->set_complete(true);
group_->AddCache(cache_.get());
url::Origin manifest_origin(url::Origin::Create(manifest_url));
if (add_to_database) {
AppCacheDatabase::GroupRecord group_record;
group_record.group_id = group_id;
group_record.manifest_url = manifest_url;
group_record.origin = manifest_origin;
EXPECT_TRUE(database()->InsertGroup(&group_record));
AppCacheDatabase::CacheRecord cache_record;
cache_record.cache_id = cache_id;
cache_record.group_id = group_id;
cache_record.online_wildcard = false;
cache_record.update_time = kZeroTime;
cache_record.cache_size = kDefaultEntrySize;
EXPECT_TRUE(database()->InsertCache(&cache_record));
AppCacheDatabase::EntryRecord entry_record;
entry_record.cache_id = cache_id;
entry_record.url = kDefaultEntryUrl;
entry_record.flags = default_entry.types();
entry_record.response_id = default_entry.response_id();
entry_record.response_size = default_entry.response_size();
EXPECT_TRUE(database()->InsertEntry(&entry_record));

      storage()->usage_map_[manifest_origin] = default_entry.response_size();
}
}

void AppCacheUpdateJob::OnManifestDataReadComplete(int result) {
  if (result > 0) {
    loaded_manifest_data_.append(read_manifest_buffer_->data(), result);
    manifest_response_reader_->ReadData(
        read_manifest_buffer_.get(), kAppCacheFetchBufferSize,
        base::BindOnce(&AppCacheUpdateJob::OnManifestDataReadComplete,
                       base::Unretained(this)));  // read more
  } else {
    read_manifest_buffer_ = nullptr;
    manifest_response_reader_.reset();
    ContinueHandleManifestFetchCompleted(
        result < 0 || manifest_data_ != loaded_manifest_data_);
  }
}

void AppCacheUpdateJob::ClearPendingMasterEntries() {
  for (auto& pair : pending_master_entries_) {
    PendingHosts& hosts = pair.second;
    for (AppCacheHost* host : hosts)
      host->RemoveObserver(this);
  }

  pending_master_entries_.clear();
}

  void MethodWrapper(Method method) {
    SetUpTest();

    FlushAllTasks();

    base::SequencedTaskRunnerHandle::Get()->PostTask(
        FROM_HERE, base::BindOnce(&AppCacheStorageImplTest::RunMethod<Method>,
                                  base::Unretained(this), method));
  }

bool AppCacheDatabase::FindCachesForOrigin(const url::Origin& origin,
                                           std::vector<CacheRecord>* records) {
  DCHECK(records);
  std::vector<GroupRecord> group_records;
  if (!FindGroupsForOrigin(origin, &group_records))
    return false;

  CacheRecord cache_record;
  for (const auto& record : group_records) {
    if (FindCacheForGroup(record.group_id, &cache_record))
      records->push_back(cache_record);
  }
  return true;
}

void AppCacheUpdateJob::ContinueHandleManifestFetchCompleted(bool changed) {
  DCHECK(internal_state_ == FETCH_MANIFEST);

  if (!changed) {
    DCHECK(update_type_ == UPGRADE_ATTEMPT);
    internal_state_ = NO_UPDATE;

    FetchMasterEntries();
    MaybeCompleteUpdate();  // if not done, run async 6.9.4 step 7 substeps
    return;
  }

  AppCacheManifest manifest;
  if (!ParseManifest(manifest_url_, manifest_data_.data(),
                     manifest_data_.length(),
                     manifest_has_valid_mime_type_
                         ? PARSE_MANIFEST_ALLOWING_DANGEROUS_FEATURES
                         : PARSE_MANIFEST_PER_STANDARD,
                     manifest)) {
    const char kFormatString[] = "Failed to parse manifest %s";
    const std::string message = base::StringPrintf(kFormatString,
        manifest_url_.spec().c_str());
    HandleCacheFailure(
        blink::mojom::AppCacheErrorDetails(
            message,
            blink::mojom::AppCacheErrorReason::APPCACHE_SIGNATURE_ERROR, GURL(),
            0, false /*is_cross_origin*/),
        MANIFEST_ERROR, GURL());
    VLOG(1) << message;
    return;
  }

  internal_state_ = DOWNLOADING;
  inprogress_cache_ = new AppCache(storage_, storage_->NewCacheId());
  BuildUrlFileList(manifest);
  inprogress_cache_->InitializeWithManifest(&manifest);

  for (const auto& pair : pending_master_entries_) {
    const PendingHosts& hosts = pair.second;
    for (AppCacheHost* host : hosts) {
      host->AssociateIncompleteCache(inprogress_cache_.get(), manifest_url_);
    }
  }

  if (manifest.did_ignore_intercept_namespaces) {
    std::string message(
        "Ignoring the INTERCEPT section of the application cache manifest "
        "because the content type is not text/cache-manifest");
    LogConsoleMessageToAll(message);
  }
  if (manifest.did_ignore_fallback_namespaces) {
    std::string message(
        "Ignoring out of scope FALLBACK entries of the application cache "
        "manifest because the content-type is not text/cache-manifest");
    LogConsoleMessageToAll(message);
  }

  group_->SetUpdateAppCacheStatus(AppCacheGroup::DOWNLOADING);
  NotifyAllAssociatedHosts(
      blink::mojom::AppCacheEventID::APPCACHE_DOWNLOADING_EVENT);
  FetchUrls();
  FetchMasterEntries();
  MaybeCompleteUpdate();  // if not done, continues when async fetches complete
}

AppCache::AppCache(AppCacheStorage* storage, int64_t cache_id)
    : cache_id_(cache_id),
      owning_group_(nullptr),
       online_whitelist_all_(false),
       is_complete_(false),
       cache_size_(0),
       storage_(storage) {
   storage_->working_set()->AddCache(this);
 }

bool AppCacheDatabase::InsertEntry(const EntryRecord* record) {
if (!LazyOpen(kCreateIfNeeded))
return false;

static const char kSql[] =
      "INSERT INTO Entries (cache_id, url, flags, response_id, response_size)"
      "  VALUES(?, ?, ?, ?, ?)";

sql::Statement statement(db_->GetCachedStatement(SQL_FROM_HERE, kSql));
statement.BindInt64(0, record->cache_id);
statement.BindString(1, record->url.spec());
statement.BindInt(2, record->flags);
statement.BindInt64(3, record->response_id);
statement.BindInt64(4, record->response_size);

return statement.Run();
}

  void SetupMockReader(
      bool valid_info, bool valid_data, bool valid_size) {
    net::HttpResponseInfo* info = valid_info ? MakeMockResponseInfo() : nullptr;
    int info_size = info ? GetResponseInfoSize(info) : 0;
    const char* data = valid_data ? kMockBody : nullptr;
    int data_size = valid_size ? kMockBodySize : 3;
    mock_storage()->SimulateResponseReader(
        new MockResponseReader(kMockResponseId, info, info_size,
                               data, data_size));
  }

  void FindMainResponseExclusionsInWorkingSet() {
    FindMainResponseExclusions(false);
  }

  void MarkEntryAsForeign() {
    MakeCacheAndGroup(kManifestUrl, 1, 1, true);
    cache_->AddEntry(kEntryUrl, AppCacheEntry(AppCacheEntry::EXPLICIT));
    AppCacheDatabase::EntryRecord entry_record;
    entry_record.cache_id = 1;
    entry_record.url = kEntryUrl;
    entry_record.flags = AppCacheEntry::EXPLICIT;
    entry_record.response_id = 0;
    EXPECT_TRUE(database()->InsertEntry(&entry_record));
    EXPECT_FALSE(cache_->GetEntry(kEntryUrl)->IsForeign());

    storage()->MarkEntryAsForeign(kEntryUrl, 1);

    EXPECT_TRUE(cache_->GetEntry(kEntryUrl)->IsForeign());
    EXPECT_TRUE(cache_->GetEntry(kEntryUrl)->IsExplicit());

    FlushAllTasks();
    AppCacheDatabase::EntryRecord entry_record2;
    EXPECT_TRUE(database()->FindEntry(1, kEntryUrl, &entry_record2));
    EXPECT_EQ(AppCacheEntry::EXPLICIT | AppCacheEntry::FOREIGN,
              entry_record2.flags);
    TestFinished();
  }

AppCacheUpdateJob::AppCacheUpdateJob(AppCacheServiceImpl* service,
                                     AppCacheGroup* group)
    : service_(service),
      manifest_url_(group->manifest_url()),
      group_(group),
      update_type_(UNKNOWN_TYPE),
      internal_state_(FETCH_MANIFEST),
      doing_full_update_check_(false),
      master_entries_completed_(0),
      url_fetches_completed_(0),
      manifest_fetcher_(nullptr),
      manifest_has_valid_mime_type_(false),
      stored_state_(UNSTORED),
      storage_(service->storage()),
      weak_factory_(this) {
  service_->AddObserver(this);
}

void AppCacheDatabase::ReadCacheRecord(
    const sql::Statement& statement, CacheRecord* record) {
  record->cache_id = statement.ColumnInt64(0);
  record->group_id = statement.ColumnInt64(1);
  record->online_wildcard = statement.ColumnBool(2);
   record->update_time =
       base::Time::FromInternalValue(statement.ColumnInt64(3));
   record->cache_size = statement.ColumnInt64(4);
 }

  AppCacheStorageImpl* storage() {
    return static_cast<AppCacheStorageImpl*>(service()->storage());
  }

void AppCacheUpdateJob::CheckIfManifestChanged() {
  DCHECK(update_type_ == UPGRADE_ATTEMPT);
  AppCacheEntry* entry = nullptr;
  if (group_->newest_complete_cache())
    entry = group_->newest_complete_cache()->GetEntry(manifest_url_);
  if (!entry) {
    if (service_->storage() == storage_) {
      AppCacheServiceImpl* service = service_;
      HandleCacheFailure(
          blink::mojom::AppCacheErrorDetails(
              "Manifest entry not found in existing cache",
              blink::mojom::AppCacheErrorReason::APPCACHE_UNKNOWN_ERROR, GURL(),
              0, false /*is_cross_origin*/),
          DB_ERROR, GURL());
      AppCacheHistograms::AddMissingManifestEntrySample();
      service->DeleteAppCacheGroup(manifest_url_,
                                   net::CompletionOnceCallback());
    }
    return;
  }

  manifest_response_reader_ =
      storage_->CreateResponseReader(manifest_url_, entry->response_id());
  read_manifest_buffer_ =
      base::MakeRefCounted<net::IOBuffer>(kAppCacheFetchBufferSize);
  manifest_response_reader_->ReadData(
      read_manifest_buffer_.get(), kAppCacheFetchBufferSize,
      base::BindOnce(&AppCacheUpdateJob::OnManifestDataReadComplete,
                     base::Unretained(this)));  // async read
}

void StoreExistingGroupExistingCache() {
// Store a group with updates to its existing newest complete cache.
// Setup some preconditions. Create a group and a complete cache that
// appear to be "stored".

// Setup some preconditions. Create a group and old complete cache
// that appear to be "stored"
MakeCacheAndGroup(kManifestUrl, 1, 1, true);
    EXPECT_EQ(kDefaultEntrySize, storage()->usage_map_[kOrigin]);

// Change the cache.
base::Time now = base::Time::Now();
    cache_->AddEntry(kEntryUrl, AppCacheEntry(AppCacheEntry::MASTER, 1, 100));
cache_->set_update_time(now);

PushNextTask(base::BindOnce(
&AppCacheStorageImplTest::Verify_StoreExistingGroupExistingCache,
base::Unretained(this), now));

// Conduct the test.
EXPECT_EQ(cache_.get(), group_->newest_complete_cache());
storage()->StoreGroupAndNewestCache(group_.get(), cache_.get(), delegate());
EXPECT_FALSE(delegate()->stored_group_success_);
}

void AppCacheUpdateJob::HandleCacheFailure(
    const blink::mojom::AppCacheErrorDetails& error_details,
    ResultType result,
    const GURL& failed_resource_url) {
  DCHECK(internal_state_ != CACHE_FAILURE);
  DCHECK(!error_details.message.empty());
  DCHECK(result != UPDATE_OK);
  internal_state_ = CACHE_FAILURE;
  LogHistogramStats(result, failed_resource_url);
  CancelAllUrlFetches();
  CancelAllMasterEntryFetches(error_details);
  NotifyAllError(error_details);
  DiscardInprogressCache();
  internal_state_ = COMPLETED;

  if (update_type_ == CACHE_ATTEMPT ||
      !IsEvictableError(result, error_details) ||
      service_->storage() != storage_) {
    DeleteSoon();
    return;
  }

  if (group_->first_evictable_error_time().is_null()) {
    group_->set_first_evictable_error_time(base::Time::Now());
    storage_->StoreEvictionTimes(group_);
    DeleteSoon();
    return;
  }

  base::TimeDelta kMaxEvictableErrorDuration = base::TimeDelta::FromDays(14);
  base::TimeDelta error_duration =
      base::Time::Now() - group_->first_evictable_error_time();
  if (error_duration > kMaxEvictableErrorDuration) {
    group_->SetUpdateAppCacheStatus(AppCacheGroup::IDLE);
    group_ = nullptr;
    service_->DeleteAppCacheGroup(manifest_url_,
                                  base::BindOnce(EmptyCompletionCallback));
  }

  DeleteSoon();  // To unwind the stack prior to deletion.
}

  void Verify_BasicFindMainInterceptResponse() {
    EXPECT_EQ(kInterceptTestUrl, delegate()->found_url_);
    EXPECT_EQ(kManifestUrl, delegate()->found_manifest_url_);
    EXPECT_EQ(1, delegate()->found_cache_id_);
    EXPECT_EQ(2, delegate()->found_group_id_);
    EXPECT_EQ(2, delegate()->found_entry_.response_id());
    EXPECT_TRUE(delegate()->found_entry_.IsIntercept());
    EXPECT_EQ(kEntryUrl2, delegate()->found_namespace_entry_url_);
    EXPECT_FALSE(delegate()->found_fallback_entry_.has_response_id());
    TestFinished();
  }

bool AppCacheDatabase::InsertGroup(const GroupRecord* record) {
  if (!LazyOpen(kCreateIfNeeded))
    return false;

  static const char kSql[] =
      "INSERT INTO Groups"
      "  (group_id, origin, manifest_url, creation_time, last_access_time,"
      "   last_full_update_check_time, first_evictable_error_time)"
      "  VALUES(?, ?, ?, ?, ?, ?, ?)";
  sql::Statement statement(db_->GetCachedStatement(SQL_FROM_HERE, kSql));
  statement.BindInt64(0, record->group_id);
  statement.BindString(1, SerializeOrigin(record->origin));
  statement.BindString(2, record->manifest_url.spec());
  statement.BindInt64(3, record->creation_time.ToInternalValue());
  statement.BindInt64(4, record->last_access_time.ToInternalValue());
  statement.BindInt64(5, record->last_full_update_check_time.ToInternalValue());
  statement.BindInt64(6, record->first_evictable_error_time.ToInternalValue());
  return statement.Run();
}

void AppCacheDatabase::Disable() {
  VLOG(1) << "Disabling appcache database.";
  is_disabled_ = true;
  ResetConnectionAndTables();
 }

void StoreNewGroup() {
// Store a group and its newest cache. Should complete asynchronously.
PushNextTask(base::BindOnce(&AppCacheStorageImplTest::Verify_StoreNewGroup,
base::Unretained(this)));

// Setup some preconditions. Create a group and newest cache that
// appear to be "unstored".
group_ =
new AppCacheGroup(storage(), kManifestUrl, storage()->NewGroupId());
cache_ = new AppCache(storage(), storage()->NewCacheId());
    cache_->AddEntry(kEntryUrl, AppCacheEntry(AppCacheEntry::EXPLICIT, 1,
                                              kDefaultEntrySize));
// Hold a ref to the cache simulate the UpdateJob holding that ref,
// and hold a ref to the group to simulate the CacheHost holding that ref.

// Have the quota manager retrun asynchronously for this test.
mock_quota_manager_proxy_->mock_manager_->async_ = true;

// Conduct the store test.
storage()->StoreGroupAndNewestCache(group_.get(), cache_.get(), delegate());
EXPECT_FALSE(delegate()->stored_group_success_);
}

bool AppCacheDatabase::GetAllOriginUsage(
    std::map<url::Origin, int64_t>* usage_map) {
  std::set<url::Origin> origins;
  if (!FindOriginsWithGroups(&origins))
    return false;
  for (const auto& origin : origins)
    (*usage_map)[origin] = GetOriginUsage(origin);
  return true;
}

 void AppCache::RemoveEntry(const GURL& url) {
   auto found = entries_.find(url);
   DCHECK(found != entries_.end());
   cache_size_ -= found->second.response_size();
   entries_.erase(found);
 }

const AppCacheEntry* AppCache::GetEntryAndUrlWithResponseId(
    int64_t response_id,
    GURL* optional_url_out) {
  for (const auto& pair : entries_) {
    if (pair.second.response_id() == response_id) {
      if (optional_url_out)
        *optional_url_out = pair.first;
      return &pair.second;
    }
  }
  return nullptr;
}

bool AppCacheDatabase::InsertOnlineWhiteList(
    const OnlineWhiteListRecord* record) {
  if (!LazyOpen(kCreateIfNeeded))
    return false;

  static const char kSql[] =
      "INSERT INTO OnlineWhiteLists (cache_id, namespace_url, is_pattern)"
      "  VALUES (?, ?, ?)";

  sql::Statement statement(db_->GetCachedStatement(SQL_FROM_HERE, kSql));
  statement.BindInt64(0, record->cache_id);
  statement.BindString(1, record->namespace_url.spec());
  statement.BindBool(2, record->is_pattern);

  return statement.Run();
}

bool AppCacheDatabase::FindGroupForManifestUrl(
    const GURL& manifest_url, GroupRecord* record) {
  DCHECK(record);
  if (!LazyOpen(kDontCreate))
    return false;

  static const char kSql[] =
      "SELECT group_id, origin, manifest_url,"
      "       creation_time, last_access_time,"
      "       last_full_update_check_time,"
      "       first_evictable_error_time"
      "  FROM Groups WHERE manifest_url = ?";

  sql::Statement statement(db_->GetCachedStatement(SQL_FROM_HERE, kSql));
  statement.BindString(0, manifest_url.spec());

  if (!statement.Step())
    return false;

  ReadGroupRecord(statement, record);
  DCHECK(record->manifest_url == manifest_url);
  return true;
}

bool AppCacheDatabase::InsertDeletableResponseIds(
    const std::vector<int64_t>& response_ids) {
  static const char kSql[] =
      "INSERT INTO DeletableResponseIds (response_id) VALUES (?)";
  return RunCachedStatementWithIds(SQL_FROM_HERE, kSql, response_ids);
}

  void FindMainResponseExclusionsInDatabase() {
    FindMainResponseExclusions(true);
  }

bool AppCacheDatabase::AddEntryFlags(const GURL& entry_url,
                                     int64_t cache_id,
                                     int additional_flags) {
  if (!LazyOpen(kDontCreate))
    return false;

  static const char kSql[] =
      "UPDATE Entries SET flags = flags | ? WHERE cache_id = ? AND url = ?";

  sql::Statement statement(db_->GetCachedStatement(SQL_FROM_HERE, kSql));
  statement.BindInt(0, additional_flags);
  statement.BindInt64(1, cache_id);
  statement.BindString(2, entry_url.spec());

  return statement.Run() && db_->GetLastChangeCount();
}

  MockResponseReader(int64_t response_id,
                     net::HttpResponseInfo* info,
                     int info_size,
                     const char* data,
                     int data_size)
      : AppCacheResponseReader(response_id, /*disk_cache=*/nullptr),
        info_(info),
        info_size_(info_size),
        data_(data),
        data_size_(data_size) {}

void StoreExistingGroup() {
// Store a group and its newest cache. Should complete asynchronously.
PushNextTask(
base::BindOnce(&AppCacheStorageImplTest::Verify_StoreExistingGroup,
base::Unretained(this)));

// Setup some preconditions. Create a group and old complete cache
// that appear to be "stored"
MakeCacheAndGroup(kManifestUrl, 1, 1, true);
    EXPECT_EQ(kDefaultEntrySize, storage()->usage_map_[kOrigin]);

// And a newest unstored complete cache.
cache2_ = new AppCache(storage(), 2);
    cache2_->AddEntry(kEntryUrl, AppCacheEntry(AppCacheEntry::MASTER, 1,
                                               kDefaultEntrySize + 100));

// Conduct the test.
storage()->StoreGroupAndNewestCache(group_.get(), cache2_.get(),
delegate());
EXPECT_FALSE(delegate()->stored_group_success_);
}

  void Verify_CreateGroup() {
    EXPECT_EQ(kManifestUrl, delegate()->loaded_manifest_url_);
    EXPECT_TRUE(delegate()->loaded_group_.get());
    EXPECT_TRUE(delegate()->loaded_group_->HasOneRef());
    EXPECT_FALSE(delegate()->loaded_group_->newest_complete_cache());

    AppCacheDatabase::GroupRecord record;
    EXPECT_FALSE(
        database()->FindGroup(delegate()->loaded_group_->group_id(), &record));

    EXPECT_EQ(0, mock_quota_manager_proxy_->notify_storage_accessed_count_);
    EXPECT_EQ(0, mock_quota_manager_proxy_->notify_storage_modified_count_);

    TestFinished();
  }

  void FindInterceptPatternMatch(bool drop_from_working_set) {
    MakeCacheAndGroup(kManifestUrl, 2, 1, true);
    cache_->AddEntry(kEntryUrl, AppCacheEntry(AppCacheEntry::INTERCEPT, 1));
    cache_->intercept_namespaces_.push_back(
        AppCacheNamespace(APPCACHE_INTERCEPT_NAMESPACE,
                          kInterceptPatternNamespace, kEntryUrl, true));
    AppCacheDatabase::CacheRecord cache_record;
    std::vector<AppCacheDatabase::EntryRecord> entries;
    std::vector<AppCacheDatabase::NamespaceRecord> intercepts;
    std::vector<AppCacheDatabase::NamespaceRecord> fallbacks;
    std::vector<AppCacheDatabase::OnlineWhiteListRecord> whitelists;
    cache_->ToDatabaseRecords(group_.get(), &cache_record, &entries,
                              &intercepts, &fallbacks, &whitelists);

    for (const auto& entry : entries) {
      if (entry.url != kDefaultEntryUrl)
        EXPECT_TRUE(database()->InsertEntry(&entry));
    }

    EXPECT_TRUE(database()->InsertNamespaceRecords(intercepts));
    if (drop_from_working_set) {
      EXPECT_TRUE(cache_->HasOneRef());
      cache_ = nullptr;
      EXPECT_TRUE(group_->HasOneRef());
      group_ = nullptr;
    }

    PushNextTask(base::BindOnce(
        &AppCacheStorageImplTest::Verify_FindInterceptPatternMatchNegative,
        base::Unretained(this)));
    storage()->FindResponseForMainRequest(kInterceptPatternTestNegativeUrl,
                                          GURL(), delegate());
    EXPECT_EQ(GURL(), delegate()->found_url_);  // Is always async.
  }

 void AppCacheDatabase::ResetConnectionAndTables() {
  meta_table_.reset();
  db_.reset();
}

  void Verify_FindMainResponseWithMultipleHits() {
    EXPECT_EQ(kEntryUrl, delegate()->found_url_);
    EXPECT_EQ(kManifestUrl3, delegate()->found_manifest_url_);
    EXPECT_EQ(3, delegate()->found_cache_id_);
    EXPECT_EQ(3, delegate()->found_group_id_);
    EXPECT_EQ(3, delegate()->found_entry_.response_id());
    EXPECT_TRUE(delegate()->found_entry_.IsExplicit());
    EXPECT_FALSE(delegate()->found_fallback_entry_.has_response_id());

    delegate_.reset(new MockStorageDelegate(this));
    PushNextTask(base::BindOnce(
        &AppCacheStorageImplTest::Verify_FindMainResponseWithMultipleHits2,
        base::Unretained(this)));
    storage()->FindResponseForMainRequest(kEntryUrl, kManifestUrl, delegate());
    EXPECT_NE(kEntryUrl, delegate()->found_url_);
  }

  bool IsGroupStored(const GURL& manifest_url) {
    return mock_storage()->IsGroupForManifestStored(manifest_url);
  }

    MockQuotaManagerProxy()
        : QuotaManagerProxy(nullptr, nullptr),
          notify_storage_accessed_count_(0),
          notify_storage_modified_count_(0),
          last_delta_(0),
          mock_manager_(new MockQuotaManager) {
      manager_ = mock_manager_.get();
    }

void AppCacheUpdateJob::FetchUrls() {
  DCHECK(internal_state_ == DOWNLOADING);

  while (pending_url_fetches_.size() < kMaxConcurrentUrlFetches &&
         !urls_to_fetch_.empty()) {
    UrlToFetch url_to_fetch = urls_to_fetch_.front();
    urls_to_fetch_.pop_front();

    auto it = url_file_list_.find(url_to_fetch.url);
    DCHECK(it != url_file_list_.end());
    AppCacheEntry& entry = it->second;
    if (ShouldSkipUrlFetch(entry)) {
      NotifyAllProgress(url_to_fetch.url);
      ++url_fetches_completed_;
    } else if (AlreadyFetchedEntry(url_to_fetch.url, entry.types())) {
      NotifyAllProgress(url_to_fetch.url);
      ++url_fetches_completed_;  // saved a URL request
    } else if (!url_to_fetch.storage_checked &&
               MaybeLoadFromNewestCache(url_to_fetch.url, entry)) {
    } else {
      URLFetcher* fetcher =
          new URLFetcher(url_to_fetch.url, URLFetcher::URL_FETCH, this,
                         kAppCacheFetchBufferSize);
      if (url_to_fetch.existing_response_info.get() &&
          group_->newest_complete_cache()) {
        AppCacheEntry* existing_entry =
            group_->newest_complete_cache()->GetEntry(url_to_fetch.url);
        DCHECK(existing_entry);
        DCHECK(existing_entry->response_id() ==
               url_to_fetch.existing_response_info->response_id());
        fetcher->set_existing_response_headers(
            url_to_fetch.existing_response_info->http_response_info()
                .headers.get());
        fetcher->set_existing_entry(*existing_entry);
      }
      fetcher->Start();
      pending_url_fetches_.insert(
          PendingUrlFetches::value_type(url_to_fetch.url, fetcher));
    }
  }
}

  net::HttpResponseInfo* MakeMockResponseInfo() {
    net::HttpResponseInfo* info = new net::HttpResponseInfo;
    info->request_time = base::Time::Now();
    info->response_time = base::Time::Now();
    info->was_cached = false;
    info->headers = new net::HttpResponseHeaders(
        std::string(kMockHeaders, base::size(kMockHeaders)));
    return info;
  }

bool AppCacheDatabase::RunUniqueStatementWithInt64Result(const char* sql,
                                                         int64_t* result) {
  DCHECK(sql);
  sql::Statement statement(db_->GetUniqueStatement(sql));
  if (!statement.Step()) {
    return false;
  }
  *result = statement.ColumnInt64(0);
  return true;
}

bool AppCacheDatabase::FindEntriesForUrl(
const GURL& url, std::vector<EntryRecord>* records) {
DCHECK(records && records->empty());
if (!LazyOpen(kDontCreate))
return false;

static const char kSql[] =
      "SELECT cache_id, url, flags, response_id, response_size FROM Entries"
"  WHERE url = ?";

sql::Statement statement(db_->GetCachedStatement(SQL_FROM_HERE, kSql));
statement.BindString(0, url.spec());

while (statement.Step()) {
records->push_back(EntryRecord());
ReadEntryRecord(statement, &records->back());
DCHECK(records->back().url == url);
}

return statement.Succeeded();
}

  static void SetUpTestCase() {
    scoped_task_environment = std::make_unique<TestBrowserThreadBundle>(
        TestBrowserThreadBundle::REAL_IO_THREAD);

    io_runner =
        base::CreateSingleThreadTaskRunnerWithTraits({BrowserThread::IO});

    base::Thread::Options options(base::MessageLoop::TYPE_IO, 0);
    background_thread.reset(new base::Thread("AppCacheTest::BackgroundThread"));
    ASSERT_TRUE(background_thread->StartWithOptions(options));
  }

bool AppCacheDatabase::FindGroupsForOrigin(const url::Origin& origin,
                                           std::vector<GroupRecord>* records) {
  DCHECK(records && records->empty());
  if (!LazyOpen(kDontCreate))
    return false;

  static const char kSql[] =
      "SELECT group_id, origin, manifest_url,"
      "       creation_time, last_access_time,"
      "       last_full_update_check_time,"
      "       first_evictable_error_time"
      "   FROM Groups WHERE origin = ?";

  sql::Statement statement(db_->GetCachedStatement(SQL_FROM_HERE, kSql));
  statement.BindString(0, SerializeOrigin(origin));

  while (statement.Step()) {
    records->push_back(GroupRecord());
    ReadGroupRecord(statement, &records->back());
    DCHECK(records->back().origin == origin);
  }

  return statement.Succeeded();
}

void AppCacheUpdateJob::AddAllAssociatedHostsToNotifier(
    HostNotifier* host_notifier) {
  if (inprogress_cache_.get()) {
    DCHECK(internal_state_ == DOWNLOADING || internal_state_ == CACHE_FAILURE);
    host_notifier->AddHosts(inprogress_cache_->associated_hosts());
  }

  for (AppCache* cache : group_->old_caches())
    host_notifier->AddHosts(cache->associated_hosts());

  AppCache* newest_cache = group_->newest_complete_cache();
  if (newest_cache)
    host_notifier->AddHosts(newest_cache->associated_hosts());
}

  void AddHost(AppCacheHost* host) {
    hosts_to_notify_.insert(host->frontend());
  }

  void Reinitialize(ReinitTestCase test_case) {
    feature_list_.InitAndEnableFeature(network::features::kNetworkService);

    ASSERT_TRUE(temp_directory_.CreateUniqueTempDir());

    AppCacheDatabase db(temp_directory_.GetPath().AppendASCII("Index"));
    EXPECT_TRUE(db.LazyOpen(true));

    if (test_case == CORRUPT_CACHE_ON_INSTALL ||
        test_case == CORRUPT_CACHE_ON_LOAD_EXISTING) {
      const std::string kCorruptData("deadbeef");
      base::FilePath disk_cache_directory =
          temp_directory_.GetPath().AppendASCII("Cache");
      ASSERT_TRUE(base::CreateDirectory(disk_cache_directory));
      base::FilePath index_file = disk_cache_directory.AppendASCII("index");
      EXPECT_EQ(static_cast<int>(kCorruptData.length()),
                base::WriteFile(index_file, kCorruptData.data(),
                                kCorruptData.length()));

      base::FilePath entry_file =
          disk_cache_directory.AppendASCII("01234567_0");
      EXPECT_EQ(static_cast<int>(kCorruptData.length()),
                base::WriteFile(entry_file, kCorruptData.data(),
                                kCorruptData.length()));
    }

    if (test_case == CORRUPT_CACHE_ON_LOAD_EXISTING) {
      AppCacheDatabase db(temp_directory_.GetPath().AppendASCII("Index"));
      GURL manifest_url = GetMockUrl("manifest");

      AppCacheDatabase::GroupRecord group_record;
      group_record.group_id = 1;
      group_record.manifest_url = manifest_url;
      group_record.origin = url::Origin::Create(manifest_url);
      EXPECT_TRUE(db.InsertGroup(&group_record));
      AppCacheDatabase::CacheRecord cache_record;
      cache_record.cache_id = 1;
      cache_record.group_id = 1;
       cache_record.online_wildcard = false;
       cache_record.update_time = kZeroTime;
       cache_record.cache_size = kDefaultEntrySize;
       EXPECT_TRUE(db.InsertCache(&cache_record));
       AppCacheDatabase::EntryRecord entry_record;
       entry_record.cache_id = 1;
       entry_record.url = manifest_url;
       entry_record.flags = AppCacheEntry::MANIFEST;
       entry_record.response_id = 1;
       entry_record.response_size = kDefaultEntrySize;
       EXPECT_TRUE(db.InsertEntry(&entry_record));
     }
 
    service_.reset(new AppCacheServiceImpl(nullptr));
    auto loader_factory_getter = base::MakeRefCounted<URLLoaderFactoryGetter>();
    loader_factory_getter->SetNetworkFactoryForTesting(
        &mock_url_loader_factory_, /* is_corb_enabled = */ true);
    service_->set_url_loader_factory_getter(loader_factory_getter.get());

    service_->Initialize(temp_directory_.GetPath());
    mock_quota_manager_proxy_ = new MockQuotaManagerProxy();
    service_->quota_manager_proxy_ = mock_quota_manager_proxy_;
    delegate_.reset(new MockStorageDelegate(this));

    observer_.reset(new MockServiceObserver(this));
    service_->AddObserver(observer_.get());

    FlushAllTasks();
    base::SequencedTaskRunnerHandle::Get()->PostTask(
        FROM_HERE,
        base::BindOnce(&AppCacheStorageImplTest::Continue_Reinitialize,
                       base::Unretained(this), test_case));
  }

  void ResetStorage() {
    service_->storage_.reset(new MockAppCacheStorage(service_.get()));
  }

  void Verify_FindMainResponseWithMultipleHits3() {
    EXPECT_EQ(kEntryUrl, delegate()->found_url_);
    EXPECT_EQ(kManifestUrl2, delegate()->found_manifest_url_);
    EXPECT_EQ(2, delegate()->found_cache_id_);
    EXPECT_EQ(2, delegate()->found_group_id_);
    EXPECT_EQ(2, delegate()->found_entry_.response_id());
    EXPECT_TRUE(delegate()->found_entry_.IsExplicit());
    EXPECT_FALSE(delegate()->found_fallback_entry_.has_response_id());

    delegate_.reset(new MockStorageDelegate(this));
    PushNextTask(base::BindOnce(
        &AppCacheStorageImplTest::Verify_FindMainResponseWithMultipleHits4,
        base::Unretained(this)));
    storage()->FindResponseForMainRequest(kFallbackTestUrl, GURL(), delegate());
    EXPECT_NE(kFallbackTestUrl, delegate()->found_url_);
  }

bool AppCacheDatabase::CommitLazyLastAccessTimes() {
  if (lazy_last_access_times_.empty())
    return true;
  if (!LazyOpen(kDontCreate))
    return false;

  sql::Transaction transaction(db_.get());
  if (!transaction.Begin())
    return false;
  for (const auto& pair : lazy_last_access_times_) {
    static const char kSql[] =
        "UPDATE Groups SET last_access_time = ? WHERE group_id = ?";
    sql::Statement statement(db_->GetCachedStatement(SQL_FROM_HERE, kSql));
    statement.BindInt64(0, pair.second.ToInternalValue());  // time
    statement.BindInt64(1, pair.first);  // group_id
    statement.Run();
  }
  lazy_last_access_times_.clear();
  return transaction.Commit();
}

  void Verify_FindInterceptPatternMatchPositive() {
    EXPECT_EQ(kInterceptPatternTestPositiveUrl, delegate()->found_url_);
    EXPECT_EQ(kManifestUrl, delegate()->found_manifest_url_);
    EXPECT_EQ(1, delegate()->found_cache_id_);
    EXPECT_EQ(2, delegate()->found_group_id_);
    EXPECT_EQ(1, delegate()->found_entry_.response_id());
    EXPECT_TRUE(delegate()->found_entry_.IsIntercept());
    EXPECT_EQ(kEntryUrl, delegate()->found_namespace_entry_url_);
    EXPECT_FALSE(delegate()->found_fallback_entry_.has_response_id());
    TestFinished();
  }

bool AppCacheDatabase::InsertCache(const CacheRecord* record) {
if (!LazyOpen(kCreateIfNeeded))
return false;

static const char kSql[] =
"INSERT INTO Caches (cache_id, group_id, online_wildcard,"
      "                    update_time, cache_size)"
      "  VALUES(?, ?, ?, ?, ?)";

sql::Statement statement(db_->GetCachedStatement(SQL_FROM_HERE, kSql));
statement.BindInt64(0, record->cache_id);
statement.BindInt64(1, record->group_id);
statement.BindBool(2, record->online_wildcard);
statement.BindInt64(3, record->update_time.ToInternalValue());
statement.BindInt64(4, record->cache_size);

return statement.Run();
}

  void Verify_LoadGroup_Far_Hit() {
    EXPECT_TRUE(delegate()->loaded_group_.get());
    EXPECT_EQ(kManifestUrl, delegate()->loaded_manifest_url_);
    EXPECT_TRUE(delegate()->loaded_group_->newest_complete_cache());
    delegate()->loaded_groups_newest_cache_ = nullptr;
    EXPECT_TRUE(delegate()->loaded_group_->HasOneRef());
    EXPECT_EQ(2, mock_quota_manager_proxy_->notify_storage_accessed_count_);
    EXPECT_EQ(0, mock_quota_manager_proxy_->notify_storage_modified_count_);
    TestFinished();
  }

bool CreateTable(sql::Database* db, const TableInfo& info) {
  std::string sql("CREATE TABLE ");
  sql += info.table_name;
  sql += info.columns;
  return db->Execute(sql.c_str());
}

  void FindFallbackPatternMatchInDatabase() { FindFallbackPatternMatch(true); }

  void Verify_FindFallbackPatternMatchNegative() {
    EXPECT_EQ(kFallbackPatternTestNegativeUrl, delegate()->found_url_);
    EXPECT_TRUE(delegate()->found_manifest_url_.is_empty());
    EXPECT_EQ(blink::mojom::kAppCacheNoCacheId, delegate()->found_cache_id_);
    EXPECT_EQ(blink::mojom::kAppCacheNoResponseId,
              delegate()->found_entry_.response_id());
    EXPECT_EQ(blink::mojom::kAppCacheNoResponseId,
              delegate()->found_fallback_entry_.response_id());
    EXPECT_TRUE(delegate()->found_namespace_entry_url_.is_empty());
    EXPECT_EQ(0, delegate()->found_entry_.types());
    EXPECT_EQ(0, delegate()->found_fallback_entry_.types());

    PushNextTask(base::BindOnce(
        &AppCacheStorageImplTest::Verify_FindFallbackPatternMatchPositive,
        base::Unretained(this)));
    storage()->FindResponseForMainRequest(kFallbackPatternTestPositiveUrl,
                                          GURL(), delegate());
  }

  void BasicFindMainFallbackResponseInWorkingSet() {
    BasicFindMainFallbackResponse(false);
  }

  void Verify_FindMainResponseWithMultipleHits5() {
    EXPECT_EQ(kFallbackTestUrl, delegate()->found_url_);
    EXPECT_EQ(kManifestUrl2, delegate()->found_manifest_url_);
    EXPECT_EQ(2, delegate()->found_cache_id_);
    EXPECT_EQ(2, delegate()->found_group_id_);
    EXPECT_FALSE(delegate()->found_entry_.has_response_id());
    EXPECT_EQ(2 + kFallbackEntryIdOffset,
              delegate()->found_fallback_entry_.response_id());
    EXPECT_TRUE(delegate()->found_fallback_entry_.IsFallback());
    EXPECT_EQ(kEntryUrl2, delegate()->found_namespace_entry_url_);

    TestFinished();
  }

  void Continue_Reinitialize(ReinitTestCase test_case) {
    const int kMockProcessId = 1;
    const int kMockRenderFrameId = MSG_ROUTING_NONE;
    backend_ =
        std::make_unique<AppCacheBackendImpl>(service_.get(), kMockProcessId);

    if (test_case == CORRUPT_SQL_ON_INSTALL) {
      EXPECT_FALSE(database()->was_corruption_detected());
      ASSERT_TRUE(sql::test::CorruptSizeInHeader(
          temp_directory_.GetPath().AppendASCII("Index")));
    }

    if (test_case == CORRUPT_CACHE_ON_INSTALL ||
        test_case == CORRUPT_SQL_ON_INSTALL) {
      backend_->RegisterHost(blink::mojom::AppCacheHostRequest(),
                             BindFrontend(), 1, kMockRenderFrameId);
      AppCacheHost* host1 = backend_->GetHost(1);
      const GURL kEmptyPageUrl(GetMockUrl("empty.html"));
      host1->SetFirstPartyUrlForTesting(kEmptyPageUrl);
      host1->SelectCache(kEmptyPageUrl, blink::mojom::kAppCacheNoCacheId,
                         GetMockUrl("manifest"));
    } else {
      ASSERT_EQ(CORRUPT_CACHE_ON_LOAD_EXISTING, test_case);
      backend_->RegisterHost(blink::mojom::AppCacheHostRequest(),
                             BindFrontend(), 2, kMockRenderFrameId);
      AppCacheHost* host2 = backend_->GetHost(2);
      network::ResourceRequest request;
      request.url = GetMockUrl("manifest");
      handler_ =
          host2->CreateRequestHandler(AppCacheURLLoaderRequest::Create(request),
                                      RESOURCE_TYPE_MAIN_FRAME, false);
      handler_->MaybeCreateLoader(request, nullptr, base::DoNothing(),
                                  base::DoNothing());
    }

    PushNextTask(base::BindOnce(&AppCacheStorageImplTest::Verify_Reinitialized,
                                base::Unretained(this), test_case));
  }

  void FindInterceptPatternMatchInDatabase() {
    FindInterceptPatternMatch(true);
  }

  void BasicFindMainFallbackResponseInDatabase() {
    BasicFindMainFallbackResponse(true);
  }

bool AppCacheDatabase::FindResponseIdsForCacheHelper(
    int64_t cache_id,
    std::vector<int64_t>* ids_vector,
    std::set<int64_t>* ids_set) {
  DCHECK(ids_vector || ids_set);
  DCHECK(!(ids_vector && ids_set));
  if (!LazyOpen(kDontCreate))
    return false;

  static const char kSql[] =
      "SELECT response_id FROM Entries WHERE cache_id = ?";

  sql::Statement statement(db_->GetCachedStatement(SQL_FROM_HERE, kSql));

  statement.BindInt64(0, cache_id);
  while (statement.Step()) {
    int64_t id = statement.ColumnInt64(0);
    if (ids_set)
      ids_set->insert(id);
    else
      ids_vector->push_back(id);
  }

  return statement.Succeeded();
}

void AppCacheUpdateJob::LogHistogramStats(
      ResultType result, const GURL& failed_resource_url) {
  AppCacheHistograms::CountUpdateJobResult(result,
                                           url::Origin::Create(manifest_url_));
  if (result == UPDATE_OK)
    return;

  int percent_complete = 0;
  if (url_file_list_.size() > 0) {
    size_t actual_fetches_completed = url_fetches_completed_;
    if (!failed_resource_url.is_empty() && actual_fetches_completed)
      --actual_fetches_completed;
    percent_complete = (static_cast<double>(actual_fetches_completed) /
                            static_cast<double>(url_file_list_.size())) * 100.0;
    percent_complete = std::min(percent_complete, 99);
  }

  bool was_making_progress =
      base::Time::Now() - last_progress_time_ <
          base::TimeDelta::FromMinutes(5);

  bool off_origin_resource_failure =
      !failed_resource_url.is_empty() &&
          (failed_resource_url.GetOrigin() != manifest_url_.GetOrigin());

  AppCacheHistograms::LogUpdateFailureStats(
      url::Origin::Create(manifest_url_), percent_complete, was_making_progress,
      off_origin_resource_failure);
}

void AppCacheUpdateJob::NotifyAllError(
    const blink::mojom::AppCacheErrorDetails& details) {
  HostNotifier host_notifier;
  AddAllAssociatedHostsToNotifier(&host_notifier);
  host_notifier.SendErrorNotifications(details);
}

  int CountPendingHelpers() {
    return service_->pending_helpers_.size();
  }

void AppCacheUpdateJob::AddUrlToFileList(const GURL& url, int type) {
  std::pair<AppCache::EntryMap::iterator, bool> ret = url_file_list_.insert(
      AppCache::EntryMap::value_type(url, AppCacheEntry(type)));

  if (ret.second)
    urls_to_fetch_.push_back(UrlToFetch(url, false, nullptr));
  else
    ret.first->second.add_types(type);  // URL already exists. Merge types.
}

bool AppCacheDatabase::DeleteEntriesForCache(int64_t cache_id) {
  if (!LazyOpen(kDontCreate))
    return false;

  static const char kSql[] = "DELETE FROM Entries WHERE cache_id = ?";

  sql::Statement statement(db_->GetCachedStatement(SQL_FROM_HERE, kSql));
  statement.BindInt64(0, cache_id);

  return statement.Run();
}

  void Verify_FindMainResponseWithMultipleHits4() {
    EXPECT_EQ(kFallbackTestUrl, delegate()->found_url_);
    EXPECT_EQ(kManifestUrl3, delegate()->found_manifest_url_);
    EXPECT_EQ(3, delegate()->found_cache_id_);
    EXPECT_EQ(3, delegate()->found_group_id_);
    EXPECT_FALSE(delegate()->found_entry_.has_response_id());
    EXPECT_EQ(3 + kFallbackEntryIdOffset,
              delegate()->found_fallback_entry_.response_id());
    EXPECT_TRUE(delegate()->found_fallback_entry_.IsFallback());
    EXPECT_EQ(kEntryUrl2, delegate()->found_namespace_entry_url_);

    delegate_.reset(new MockStorageDelegate(this));
    PushNextTask(base::BindOnce(
        &AppCacheStorageImplTest::Verify_FindMainResponseWithMultipleHits5,
        base::Unretained(this)));
    storage()->FindResponseForMainRequest(kFallbackTestUrl, kManifestUrl2,
                                          delegate());
    EXPECT_NE(kFallbackTestUrl, delegate()->found_url_);
  }

  void Reinitialize1() {
    Reinitialize(CORRUPT_CACHE_ON_INSTALL);
  }

bool AppCacheDatabase::FindCache(int64_t cache_id, CacheRecord* record) {
DCHECK(record);
if (!LazyOpen(kDontCreate))
return false;

static const char kSql[] =
      "SELECT cache_id, group_id, online_wildcard, update_time, cache_size"
" FROM Caches WHERE cache_id = ?";

sql::Statement statement(db_->GetCachedStatement(SQL_FROM_HERE, kSql));
statement.BindInt64(0, cache_id);

if (!statement.Step())
return false;

ReadCacheRecord(statement, record);
return true;
}

std::string GetActiveExperimentFlags() {
  return std::string();
}

void AppCacheUpdateJob::CancelAllUrlFetches() {
  for (auto& pair : pending_url_fetches_)
    delete pair.second;

  url_fetches_completed_ +=
      pending_url_fetches_.size() + urls_to_fetch_.size();
  pending_url_fetches_.clear();
  urls_to_fetch_.clear();
}
