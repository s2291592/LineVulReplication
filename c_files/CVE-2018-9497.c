static WORD32 impeg2d_init_thread_dec_ctxt(dec_state_t *ps_dec,
 dec_state_t *ps_dec_thd,
                                           WORD32 i4_min_mb_y)
{
    UNUSED(i4_min_mb_y);
    ps_dec_thd->i4_start_mb_y = 0;
    ps_dec_thd->i4_end_mb_y = ps_dec->u2_num_vert_mb;
    ps_dec_thd->u2_mb_x = 0;
    ps_dec_thd->u2_mb_y = 0;
    ps_dec_thd->u2_is_mpeg2 = ps_dec->u2_is_mpeg2;
    ps_dec_thd->i4_pic_count = ps_dec->i4_pic_count;
    ps_dec_thd->u2_frame_width = ps_dec->u2_frame_width;
    ps_dec_thd->u2_frame_height = ps_dec->u2_frame_height;
    ps_dec_thd->u2_picture_width = ps_dec->u2_picture_width;
    ps_dec_thd->u2_horizontal_size = ps_dec->u2_horizontal_size;
    ps_dec_thd->u2_vertical_size = ps_dec->u2_vertical_size;
    ps_dec_thd->u2_create_max_width = ps_dec->u2_create_max_width;
    ps_dec_thd->u2_create_max_height = ps_dec->u2_create_max_height;
    ps_dec_thd->u2_header_done = ps_dec->u2_header_done;
    ps_dec_thd->u2_decode_header = ps_dec->u2_decode_header;

    ps_dec_thd->u2_num_horiz_mb = ps_dec->u2_num_horiz_mb;
    ps_dec_thd->u2_num_vert_mb = ps_dec->u2_num_vert_mb;
    ps_dec_thd->u2_num_flds_decoded = ps_dec->u2_num_flds_decoded;

    ps_dec_thd->u4_frm_buf_stride = ps_dec->u4_frm_buf_stride;

    ps_dec_thd->u2_field_dct = ps_dec->u2_field_dct;
    ps_dec_thd->u2_read_dct_type = ps_dec->u2_read_dct_type;

    ps_dec_thd->u2_read_motion_type = ps_dec->u2_read_motion_type;
    ps_dec_thd->u2_motion_type = ps_dec->u2_motion_type;

    ps_dec_thd->pu2_mb_type = ps_dec->pu2_mb_type;
    ps_dec_thd->u2_fld_pic = ps_dec->u2_fld_pic;
    ps_dec_thd->u2_frm_pic = ps_dec->u2_frm_pic;

    ps_dec_thd->u2_fld_parity = ps_dec->u2_fld_parity;

    ps_dec_thd->au2_fcode_data[0] = ps_dec->au2_fcode_data[0];
    ps_dec_thd->au2_fcode_data[1] = ps_dec->au2_fcode_data[1];

    ps_dec_thd->u1_quant_scale = ps_dec->u1_quant_scale;

    ps_dec_thd->u2_num_mbs_left = ps_dec->u2_num_mbs_left;
    ps_dec_thd->u2_first_mb = ps_dec->u2_first_mb;
    ps_dec_thd->u2_num_skipped_mbs = ps_dec->u2_num_skipped_mbs;

    memcpy(&ps_dec_thd->s_cur_frm_buf, &ps_dec->s_cur_frm_buf, sizeof(yuv_buf_t));
    memcpy(&ps_dec_thd->as_recent_fld[0][0], &ps_dec->as_recent_fld[0][0], sizeof(yuv_buf_t));
    memcpy(&ps_dec_thd->as_recent_fld[0][1], &ps_dec->as_recent_fld[0][1], sizeof(yuv_buf_t));
    memcpy(&ps_dec_thd->as_recent_fld[1][0], &ps_dec->as_recent_fld[1][0], sizeof(yuv_buf_t));
    memcpy(&ps_dec_thd->as_recent_fld[1][1], &ps_dec->as_recent_fld[1][1], sizeof(yuv_buf_t));
    memcpy(&ps_dec_thd->as_ref_buf, &ps_dec->as_ref_buf, sizeof(yuv_buf_t) * 2 * 2);


    ps_dec_thd->pf_decode_slice = ps_dec->pf_decode_slice;

    ps_dec_thd->pf_vld_inv_quant = ps_dec->pf_vld_inv_quant;

    memcpy(ps_dec_thd->pf_idct_recon, ps_dec->pf_idct_recon, sizeof(ps_dec->pf_idct_recon));

    memcpy(ps_dec_thd->pf_mc, ps_dec->pf_mc, sizeof(ps_dec->pf_mc));
    ps_dec_thd->pf_interpolate = ps_dec->pf_interpolate;
    ps_dec_thd->pf_copy_mb = ps_dec->pf_copy_mb;
    ps_dec_thd->pf_fullx_halfy_8x8              =  ps_dec->pf_fullx_halfy_8x8;
    ps_dec_thd->pf_halfx_fully_8x8              =  ps_dec->pf_halfx_fully_8x8;
    ps_dec_thd->pf_halfx_halfy_8x8              =  ps_dec->pf_halfx_halfy_8x8;
    ps_dec_thd->pf_fullx_fully_8x8              =  ps_dec->pf_fullx_fully_8x8;

    ps_dec_thd->pf_memset_8bit_8x8_block        =  ps_dec->pf_memset_8bit_8x8_block;
    ps_dec_thd->pf_memset_16bit_8x8_linear_block        =  ps_dec->pf_memset_16bit_8x8_linear_block;
    ps_dec_thd->pf_copy_yuv420p_buf             =   ps_dec->pf_copy_yuv420p_buf;
    ps_dec_thd->pf_fmt_conv_yuv420p_to_yuv422ile    =   ps_dec->pf_fmt_conv_yuv420p_to_yuv422ile;
    ps_dec_thd->pf_fmt_conv_yuv420p_to_yuv420sp_uv  =   ps_dec->pf_fmt_conv_yuv420p_to_yuv420sp_uv;
    ps_dec_thd->pf_fmt_conv_yuv420p_to_yuv420sp_vu  =   ps_dec->pf_fmt_conv_yuv420p_to_yuv420sp_vu;


    memcpy(ps_dec_thd->au1_intra_quant_matrix, ps_dec->au1_intra_quant_matrix, NUM_PELS_IN_BLOCK * sizeof(UWORD8));
    memcpy(ps_dec_thd->au1_inter_quant_matrix, ps_dec->au1_inter_quant_matrix, NUM_PELS_IN_BLOCK * sizeof(UWORD8));
    ps_dec_thd->pu1_inv_scan_matrix = ps_dec->pu1_inv_scan_matrix;


    ps_dec_thd->u2_progressive_sequence = ps_dec->u2_progressive_sequence;
    ps_dec_thd->e_pic_type =  ps_dec->e_pic_type;
    ps_dec_thd->u2_full_pel_forw_vector = ps_dec->u2_full_pel_forw_vector;
    ps_dec_thd->u2_forw_f_code =   ps_dec->u2_forw_f_code;
    ps_dec_thd->u2_full_pel_back_vector = ps_dec->u2_full_pel_back_vector;
    ps_dec_thd->u2_back_f_code = ps_dec->u2_back_f_code;

    memcpy(ps_dec_thd->ai2_mv, ps_dec->ai2_mv, (2*2*2)*sizeof(WORD16));
    memcpy(ps_dec_thd->au2_f_code, ps_dec->au2_f_code, (2*2)*sizeof(UWORD16));
    ps_dec_thd->u2_intra_dc_precision = ps_dec->u2_intra_dc_precision;
    ps_dec_thd->u2_picture_structure = ps_dec->u2_picture_structure;
    ps_dec_thd->u2_top_field_first = ps_dec->u2_top_field_first;
    ps_dec_thd->u2_frame_pred_frame_dct = ps_dec->u2_frame_pred_frame_dct;
    ps_dec_thd->u2_concealment_motion_vectors = ps_dec->u2_concealment_motion_vectors;
    ps_dec_thd->u2_q_scale_type =  ps_dec->u2_q_scale_type;
    ps_dec_thd->u2_intra_vlc_format = ps_dec->u2_intra_vlc_format;
    ps_dec_thd->u2_alternate_scan = ps_dec->u2_alternate_scan;
    ps_dec_thd->u2_repeat_first_field = ps_dec->u2_repeat_first_field;
    ps_dec_thd->u2_progressive_frame = ps_dec->u2_progressive_frame;
    ps_dec_thd->pu1_inp_bits_buf = ps_dec->pu1_inp_bits_buf;
    ps_dec_thd->u4_num_inp_bytes = ps_dec->u4_num_inp_bytes;
    ps_dec_thd->pv_jobq = ps_dec->pv_jobq;
    ps_dec_thd->pv_jobq_buf = ps_dec->pv_jobq_buf;
    ps_dec_thd->i4_jobq_buf_size = ps_dec->i4_jobq_buf_size;


    ps_dec_thd->u2_frame_rate_code = ps_dec->u2_frame_rate_code;
    ps_dec_thd->u2_frame_rate_extension_n = ps_dec->u2_frame_rate_extension_n;
    ps_dec_thd->u2_frame_rate_extension_d = ps_dec->u2_frame_rate_extension_d;
    ps_dec_thd->u2_framePeriod =   ps_dec->u2_framePeriod;
    ps_dec_thd->u2_display_horizontal_size = ps_dec->u2_display_horizontal_size;
    ps_dec_thd->u2_display_vertical_size = ps_dec->u2_display_vertical_size;
    ps_dec_thd->u2_aspect_ratio_info = ps_dec->u2_aspect_ratio_info;

    ps_dec_thd->ps_func_bi_direct = ps_dec->ps_func_bi_direct;
    ps_dec_thd->ps_func_forw_or_back = ps_dec->ps_func_forw_or_back;
    ps_dec_thd->pv_deinterlacer_ctxt = ps_dec->pv_deinterlacer_ctxt;
    ps_dec_thd->ps_deint_pic = ps_dec->ps_deint_pic;

 return 0;
}

void impeg2d_dec_pic_data(dec_state_t *ps_dec)
{

    WORD32 i;
 dec_state_multi_core_t *ps_dec_state_multi_core;

 dec_state_t *ps_dec_thd;
    WORD32 i4_status;
    WORD32 i4_min_mb_y;


 /* Resetting the MB address and MB coordinates at the start of the Frame */
    ps_dec->u2_mb_x = ps_dec->u2_mb_y = 0;

    ps_dec_state_multi_core = ps_dec->ps_dec_state_multi_core;
    impeg2d_get_slice_pos(ps_dec_state_multi_core);

    i4_min_mb_y = 1;
 for(i=0; i < ps_dec->i4_num_cores - 1; i++)
 {

        ps_dec_thd = ps_dec_state_multi_core->ps_dec_state[i+1];

        ps_dec_thd->ps_disp_pic = ps_dec->ps_disp_pic;
        ps_dec_thd->ps_disp_frm_buf = ps_dec->ps_disp_frm_buf;

        i4_status = impeg2d_init_thread_dec_ctxt(ps_dec, ps_dec_thd, i4_min_mb_y);

 if(i4_status == 0)
 {
            ithread_create(ps_dec_thd->pv_codec_thread_handle, NULL, (void *)impeg2d_dec_pic_data_thread, ps_dec_thd);
            ps_dec_state_multi_core->au4_thread_launched[i + 1] = 1;
            i4_min_mb_y = ps_dec_thd->u2_mb_y + 1;
 }
 else
 {
            ps_dec_state_multi_core->au4_thread_launched[i + 1] = 0;
 break;
 }
 }

    impeg2d_dec_pic_data_thread(ps_dec);

 for(i=0; i < (ps_dec->i4_num_cores - 1); i++)
 {
 if(ps_dec_state_multi_core->au4_thread_launched[i + 1] == 1)
 {
            ps_dec_thd = ps_dec_state_multi_core->ps_dec_state[i+1];
            ithread_join(ps_dec_thd->pv_codec_thread_handle, NULL);
 }
 }

}

WORD32 impeg2d_get_slice_pos(dec_state_multi_core_t *ps_dec_state_multi_core)
{
    WORD32 u4_bits;
    WORD32 i4_row;


 dec_state_t *ps_dec = ps_dec_state_multi_core->ps_dec_state[0];
    WORD32 i4_prev_row;
 stream_t s_bitstrm;
    WORD32 i4_start_row;
    WORD32 i4_slice_bistream_ofst;
    WORD32 i;
    s_bitstrm = ps_dec->s_bit_stream;
    i4_prev_row = -1;

    ps_dec_state_multi_core->ps_dec_state[0]->i4_start_mb_y = 0;
    ps_dec_state_multi_core->ps_dec_state[1]->i4_start_mb_y = -1;
    ps_dec_state_multi_core->ps_dec_state[2]->i4_start_mb_y = -1;
    ps_dec_state_multi_core->ps_dec_state[3]->i4_start_mb_y = -1;

    ps_dec_state_multi_core->ps_dec_state[0]->i4_end_mb_y = ps_dec->u2_num_vert_mb;
    ps_dec_state_multi_core->ps_dec_state[1]->i4_end_mb_y = -1;
    ps_dec_state_multi_core->ps_dec_state[2]->i4_end_mb_y = -1;
    ps_dec_state_multi_core->ps_dec_state[3]->i4_end_mb_y = -1;

 if(ps_dec->i4_num_cores == 1)
 return 0;
 /* Reset the jobq to start of the jobq buffer */
    impeg2_jobq_reset((jobq_t *)ps_dec->pv_jobq);

    i4_start_row = -1;
    i4_slice_bistream_ofst = 0;
 while(1)
 {
        WORD32 i4_is_slice;

 if(s_bitstrm.u4_offset + START_CODE_LEN >= s_bitstrm.u4_max_offset)
 {
 break;
 }
        u4_bits = impeg2d_bit_stream_nxt(&s_bitstrm,START_CODE_LEN);

        i4_row = u4_bits & 0xFF;

 /* Detect end of frame */
        i4_is_slice = (((u4_bits >> 8) == 0x01) && (i4_row) && (i4_row <= ps_dec->u2_num_vert_mb));
 if(!i4_is_slice)
 break;

        i4_row -= 1;


 if(i4_prev_row < i4_row)
 {
 /* Create a job for previous slice row */
 if(i4_start_row != -1)
 {
 job_t s_job;
                IV_API_CALL_STATUS_T ret;
                s_job.i2_start_mb_y = i4_start_row;
                s_job.i2_end_mb_y = i4_row;
                s_job.i4_cmd = CMD_PROCESS;
                s_job.i4_bistream_ofst = i4_slice_bistream_ofst;
                ret = impeg2_jobq_queue(ps_dec->pv_jobq, &s_job, sizeof(s_job), 1, 0);
 if(ret != IV_SUCCESS)
 return ret;

 }
 /* Store current slice's bitstream offset */
            i4_slice_bistream_ofst = s_bitstrm.u4_offset >> 3;
            i4_slice_bistream_ofst -= (size_t)s_bitstrm.pv_bs_buf & 3;
            i4_prev_row = i4_row;

 /* Store current slice's row position */
            i4_start_row = i4_row;

 }
#ifdef __ANDROID__
 else if (i4_prev_row > i4_row)
 {
            android_errorWriteLog(0x534e4554, "26070014");
 }
#endif

        impeg2d_bit_stream_flush(&s_bitstrm, START_CODE_LEN);

 /* Flush the bytes till a  start code is encountered  */
 while(impeg2d_bit_stream_nxt(&s_bitstrm, 24) != START_CODE_PREFIX)
 {
            impeg2d_bit_stream_get(&s_bitstrm, 8);

 if(s_bitstrm.u4_offset >= s_bitstrm.u4_max_offset)
 {
 break;
 }
 }
 }

 /* Create job for the last slice row */
 {
 job_t s_job;
        IV_API_CALL_STATUS_T e_ret;
        s_job.i2_start_mb_y = i4_start_row;
        s_job.i2_end_mb_y = ps_dec->u2_num_vert_mb;
        s_job.i4_cmd = CMD_PROCESS;
        s_job.i4_bistream_ofst = i4_slice_bistream_ofst;
        e_ret = impeg2_jobq_queue(ps_dec->pv_jobq, &s_job, sizeof(s_job), 1, 0);
 if(e_ret != IV_SUCCESS)
 return e_ret;

 }
 if((NULL != ps_dec->ps_disp_pic) && ((0 == ps_dec->u4_share_disp_buf) || (IV_YUV_420P != ps_dec->i4_chromaFormat)))
 {
 for(i = 0; i < ps_dec->u2_vertical_size; i+=64)
 {
 job_t s_job;
            IV_API_CALL_STATUS_T ret;
            s_job.i2_start_mb_y = i;
            s_job.i2_start_mb_y >>= 4;
            s_job.i2_end_mb_y = (i + 64);
            s_job.i2_end_mb_y >>= 4;
            s_job.i4_cmd = CMD_FMTCONV;
            s_job.i4_bistream_ofst = 0;
            ret = impeg2_jobq_queue(ps_dec->pv_jobq, &s_job, sizeof(s_job), 1, 0);
 if(ret != IV_SUCCESS)
 return ret;

 }
 }

    impeg2_jobq_terminate(ps_dec->pv_jobq);
    ps_dec->i4_bytes_consumed = s_bitstrm.u4_offset >> 3;
    ps_dec->i4_bytes_consumed -= ((size_t)s_bitstrm.pv_bs_buf & 3);

 return 0;
}

IMPEG2D_ERROR_CODES_T impeg2d_dec_pic_hdr(dec_state_t *ps_dec)
{
 stream_t *ps_stream;
    ps_stream = &ps_dec->s_bit_stream;

    impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);
 /* Flush temporal reference */
    impeg2d_bit_stream_get(ps_stream,10);

 /* Picture type */
    ps_dec->e_pic_type = (e_pic_type_t)impeg2d_bit_stream_get(ps_stream,3);
 if((ps_dec->e_pic_type < I_PIC) || (ps_dec->e_pic_type > D_PIC))
 {
        impeg2d_next_code(ps_dec, PICTURE_START_CODE);
 return IMPEG2D_INVALID_PIC_TYPE;
 }

 /* Flush vbv_delay */
    impeg2d_bit_stream_get(ps_stream,16);

 if(ps_dec->e_pic_type == P_PIC || ps_dec->e_pic_type == B_PIC)
 {
        ps_dec->u2_full_pel_forw_vector = impeg2d_bit_stream_get_bit(ps_stream);
        ps_dec->u2_forw_f_code          = impeg2d_bit_stream_get(ps_stream,3);
 }
 if(ps_dec->e_pic_type == B_PIC)
 {
        ps_dec->u2_full_pel_back_vector = impeg2d_bit_stream_get_bit(ps_stream);
        ps_dec->u2_back_f_code          = impeg2d_bit_stream_get(ps_stream,3);
 }

 if(ps_dec->u2_is_mpeg2 == 0)
 {
 if (ps_dec->u2_forw_f_code < 1 || ps_dec->u2_forw_f_code > 7 ||
                        ps_dec->u2_back_f_code < 1 || ps_dec->u2_back_f_code > 7)
 {
 return IMPEG2D_UNKNOWN_ERROR;
 }
        ps_dec->au2_f_code[0][0] = ps_dec->au2_f_code[0][1] = ps_dec->u2_forw_f_code;
        ps_dec->au2_f_code[1][0] = ps_dec->au2_f_code[1][1] = ps_dec->u2_back_f_code;
 }

 /*-----------------------------------------------------------------------*/
 /*  Flush the extra bit value                                            */
 /*                                                                       */
 /*  while(impeg2d_bit_stream_nxt() == '1')                                  */
 /*  {                                                                    */
 /*      extra_bit_picture         1                                      */
 /*      extra_information_picture 8                                      */
 /*  }                                                                    */
 /*  extra_bit_picture             1                                      */
 /*-----------------------------------------------------------------------*/
 while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&
           ps_stream->u4_offset < ps_stream->u4_max_offset)
 {
        impeg2d_bit_stream_get(ps_stream,9);
 }
    impeg2d_bit_stream_get_bit(ps_stream);
    impeg2d_next_start_code(ps_dec);

 return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;
}

void impeg2d_dec_frm(void *pv_dec,impeg2d_video_decode_ip_t *ps_ip,
 impeg2d_video_decode_op_t *ps_op)
{


 stream_t *ps_stream;
    UWORD32 u4_size = ps_ip->s_ivd_video_decode_ip_t.u4_num_Bytes;

 dec_state_t *ps_dec;

    ps_dec = (dec_state_t *)pv_dec;
    ps_op->s_ivd_video_decode_op_t.u4_error_code = 0;
    ps_dec->i4_bytes_consumed = 0;
    ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed = 0;

    IMPEG2D_FRM_NUM_SET();
 if (u4_size > MAX_BITSTREAM_BUFFER_SIZE)
 {
        u4_size = MAX_BITSTREAM_BUFFER_SIZE;
 }

    memcpy(ps_dec->pu1_input_buffer, ps_ip->s_ivd_video_decode_ip_t.pv_stream_buffer, u4_size);

    ps_dec->pu1_inp_bits_buf = ps_dec->pu1_input_buffer;

    ps_dec->u4_num_inp_bytes = u4_size;
    ps_stream  = &ps_dec->s_bit_stream;

    impeg2d_bit_stream_init(ps_stream, ps_dec->pu1_input_buffer, u4_size);

 /* @ */ /* Updating the bufferID */

    ps_dec->u4_xdmBufID     = ps_ip->s_ivd_video_decode_ip_t.u4_ts;

 {
        IMPEG2D_ERROR_CODES_T e_error;
 /* Process the Bitstream */
        e_error = impeg2d_process_video_bit_stream(ps_dec);
 if ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE != e_error)
 {
            ps_op->s_ivd_video_decode_op_t.u4_error_code    = e_error;

 if ((IMPEG2D_ERROR_CODES_T) IVD_RES_CHANGED == e_error)
 {
                ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed = ps_dec->i4_bytes_consumed;
                ps_dec->u2_header_done = 0;
 }
 else if (IMPEG2D_UNSUPPORTED_DIMENSIONS == e_error)
 {
                ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed = 0;
                ps_dec->u2_header_done = 0;

                ps_op->s_ivd_video_decode_op_t.u4_pic_ht = ps_dec->u2_reinit_max_height;
                ps_op->s_ivd_video_decode_op_t.u4_pic_wd = ps_dec->u2_reinit_max_width;
 }
 else
 {
 if(ps_dec->i4_num_cores > 1 && 0 != ps_dec->i4_bytes_consumed)
 {
 /* If the number of bytes consumed has been updated by
                     * get_slice_pos function, then use that. Else, the bytes consumed is
                     * calculated from the offset. The bytes consumed for multi-thread runs
                     * is updated only into ps_dec->i4_bytes_consumed if the get_slice_pos
                     * function has been called. If that function has not run, then we have
                     * encountered an error but still have to consume the bytes in header
                     * decode, etc.
                     */
                    ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed = ps_dec->i4_bytes_consumed;
 }
 else
 {
                    ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed = (ps_dec->s_bit_stream.u4_offset + 7) >> 3;
                    ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed -= ((size_t)ps_dec->s_bit_stream.pv_bs_buf & 3);
 }

 if(ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed
 > ps_ip->s_ivd_video_decode_ip_t.u4_num_Bytes)
 {
                    ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed =
                                    ps_ip->s_ivd_video_decode_ip_t.u4_num_Bytes;
 }

                impeg2d_next_start_code(ps_dec);
 }

 if(ps_op->s_ivd_video_decode_op_t.u4_error_code == 0)
 {
                ps_op->s_ivd_video_decode_op_t.u4_error_code = e_error;
 }

 return;
 }
 }
 /**************************************************************************/
 /* Remove the bytes left till next start code is encountered              */
 /**************************************************************************/
    ps_op->s_ivd_video_decode_op_t.u4_error_code  = IV_SUCCESS;

 if(ps_dec->i4_num_cores > 1 && 0 != ps_dec->i4_bytes_consumed)
 {
 /* If the number of bytes consumed has been updated by
         * get_slice_pos function, then use that. Else, the bytes consumed is
         * calculated from the offset. The bytes consumed for multi-thread runs
         * is updated only into ps_dec->i4_bytes_consumed if the get_slice_pos
         * function has been called. If that function has not run, then we have
         * encountered an error but still have to consume the bytes in header
         * decode, etc.
         */
        ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed = ps_dec->i4_bytes_consumed;
 }
 else
 {
        ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed = (ps_dec->s_bit_stream.u4_offset + 7) >> 3;
        ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed -= ((size_t)ps_dec->s_bit_stream.pv_bs_buf & 3);
 }
 if(ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed > ps_ip->s_ivd_video_decode_ip_t.u4_num_Bytes)
 {
        ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed = ps_ip->s_ivd_video_decode_ip_t.u4_num_Bytes;
 }
    ps_op->s_ivd_video_decode_op_t.u4_pic_ht = ps_dec->u2_vertical_size;
    ps_op->s_ivd_video_decode_op_t.u4_pic_wd = ps_dec->u2_horizontal_size;

 switch(ps_dec->e_pic_type)
 {
 case I_PIC :
            ps_op->s_ivd_video_decode_op_t.e_pic_type = IV_I_FRAME;
 break;

 case P_PIC:
            ps_op->s_ivd_video_decode_op_t.e_pic_type = IV_P_FRAME;
 break;

 case B_PIC:
            ps_op->s_ivd_video_decode_op_t.e_pic_type = IV_B_FRAME;
 break;

 case D_PIC:
            ps_op->s_ivd_video_decode_op_t.e_pic_type = IV_I_FRAME;
 break;

 default :
            ps_op->s_ivd_video_decode_op_t.e_pic_type = IV_FRAMETYPE_DEFAULT;
 break;
 }

        ps_op->s_ivd_video_decode_op_t.u4_frame_decoded_flag = ps_dec->i4_frame_decoded;
        ps_op->s_ivd_video_decode_op_t.u4_new_seq = 0;
        ps_op->s_ivd_video_decode_op_t.u4_error_code = ps_dec->u4_error_code;


}

IMPEG2D_ERROR_CODES_T impeg2d_dec_slice(dec_state_t *ps_dec)
{
 stream_t *ps_stream;
    UWORD32 u4_slice_vertical_position;
    UWORD32 u4_slice_vertical_position_extension;
    IMPEG2D_ERROR_CODES_T e_error;

    ps_stream = &ps_dec->s_bit_stream;

 /*------------------------------------------------------------------------*/
 /* All the profiles supported require restricted slice structure. Hence   */
 /* there is no need to store slice_vertical_position. Note that max       */
 /* height supported does not exceed 2800 and scalablity is not supported  */
 /*------------------------------------------------------------------------*/

 /* Remove the slice start code */
    impeg2d_bit_stream_flush(ps_stream,START_CODE_PREFIX_LEN);
    u4_slice_vertical_position = impeg2d_bit_stream_get(ps_stream, 8);
 if(u4_slice_vertical_position > 2800)
 {
        u4_slice_vertical_position_extension = impeg2d_bit_stream_get(ps_stream, 3);
        u4_slice_vertical_position += (u4_slice_vertical_position_extension << 7);
 }

 if((u4_slice_vertical_position > ps_dec->u2_num_vert_mb) ||
 (u4_slice_vertical_position == 0))
 {
 return IMPEG2D_INVALID_VERT_SIZE;
 }

    u4_slice_vertical_position--;
 if (ps_dec->u2_mb_y != u4_slice_vertical_position)
 {
        ps_dec->u2_mb_y    = u4_slice_vertical_position;
        ps_dec->u2_mb_x    = 0;

 /* Update the number of MBs left, since we have probably missed a slice
         * (that's why we see a mismatch between u2_mb_y and current position).
         */
        ps_dec->u2_num_mbs_left = (ps_dec->u2_num_vert_mb - ps_dec->u2_mb_y)
 * ps_dec->u2_num_horiz_mb;
 }
    ps_dec->u2_first_mb = 1;

 /*------------------------------------------------------------------------*/
 /* Quant scale code decoding                                              */
 /*------------------------------------------------------------------------*/
 {
        UWORD16 u2_quant_scale_code;
        u2_quant_scale_code = impeg2d_bit_stream_get(ps_stream,5);
        ps_dec->u1_quant_scale = (ps_dec->u2_q_scale_type) ?
            gau1_impeg2_non_linear_quant_scale[u2_quant_scale_code] : (u2_quant_scale_code << 1);
 }

 if (impeg2d_bit_stream_nxt(ps_stream,1) == 1)
 {
        impeg2d_bit_stream_flush(ps_stream,9);
 /* Flush extra bit information */
 while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&
               ps_stream->u4_offset < ps_stream->u4_max_offset)
 {
            impeg2d_bit_stream_flush(ps_stream,9);
 }
 }
    impeg2d_bit_stream_get_bit(ps_stream);

 /* Reset the DC predictors to reset values given in Table 7.2 at the start*/
 /* of slice data */
    ps_dec->u2_def_dc_pred[Y_LUMA] = 128 << ps_dec->u2_intra_dc_precision;
    ps_dec->u2_def_dc_pred[U_CHROMA] = 128 << ps_dec->u2_intra_dc_precision;
    ps_dec->u2_def_dc_pred[V_CHROMA] = 128 << ps_dec->u2_intra_dc_precision;
 /*------------------------------------------------------------------------*/
 /* dec->DecMBsinSlice() implements the following psuedo code from standard*/
 /* do                                                                     */
 /* {                                                                      */
 /*      macroblock()                                                      */
 /* } while (impeg2d_bit_stream_nxt() != '000 0000 0000 0000 0000 0000')      */
 /*------------------------------------------------------------------------*/

    e_error = ps_dec->pf_decode_slice(ps_dec);
 if ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE != e_error)
 {
 return e_error;
 }

 /* Check for the MBy index instead of number of MBs left, because the
     * number of MBs left in case of multi-thread decode is the number of MBs
     * in that row only
     */
 if(ps_dec->u2_mb_y < ps_dec->u2_num_vert_mb)
        impeg2d_next_start_code(ps_dec);

 return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;
}
