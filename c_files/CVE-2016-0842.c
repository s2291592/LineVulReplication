WORD32 ih264d_free_node_from_dpb(dpb_manager_t *ps_dpb_mgr,
                               UWORD32 u4_cur_pic_num,
                               UWORD8 u1_numRef_frames_for_seq)
{
    WORD32 i;
    UWORD8 u1_num_gaps = ps_dpb_mgr->u1_num_gaps;
 struct dpb_info_t *ps_next_dpb;
    UWORD8 u1_del_node = 1;
    WORD32 ret;

 if((ps_dpb_mgr->u1_num_st_ref_bufs + ps_dpb_mgr->u1_num_lt_ref_bufs
 + u1_num_gaps) == u1_numRef_frames_for_seq)
 {
        UWORD8 u1_new_node_flag = 1;
 if((0 == ps_dpb_mgr->u1_num_st_ref_bufs) && (0 == u1_num_gaps))
 {
 return ERROR_DBP_MANAGER_T;
 }

        ps_next_dpb = ps_dpb_mgr->ps_dpb_st_head;

 if(ps_dpb_mgr->u1_num_st_ref_bufs > 1)
 {
 if(ps_next_dpb->i4_frame_num == (WORD32)u4_cur_pic_num)
 {
 /* Incase of  filed pictures top_field has been allocated   */
 /* picture buffer and complementary bottom field pair comes */
 /* then the sliding window mechanism should not allocate a  */
 /* new node                                                 */
                u1_new_node_flag = 0;
 }

 for(i = 1; i < (ps_dpb_mgr->u1_num_st_ref_bufs - 1); i++)
 {
 if(ps_next_dpb == NULL)
 return ERROR_DBP_MANAGER_T;

 if(ps_next_dpb->i4_frame_num == (WORD32)u4_cur_pic_num)
 {
 /* Incase of  field pictures top_field has been allocated   */
 /* picture buffer and complementary bottom field pair comes */
 /* then the sliding window mechanism should not allocate a  */
 /* new node                                                 */
                    u1_new_node_flag = 0;
 }
                ps_next_dpb = ps_next_dpb->ps_prev_short;
 }

 if(ps_next_dpb->ps_prev_short->ps_prev_short != NULL)
 return ERROR_DBP_MANAGER_T;

 if(u1_new_node_flag)
 {
 if(u1_num_gaps)
 {
                    ret = ih264d_delete_gap_frm_sliding(ps_dpb_mgr,
                                                        ps_next_dpb->ps_prev_short->i4_frame_num,
 &u1_del_node);
 if(ret != OK)
 return ret;
 }

 if(u1_del_node)
 {
                    ps_dpb_mgr->u1_num_st_ref_bufs--;
                    ps_next_dpb->ps_prev_short->u1_used_as_ref = UNUSED_FOR_REF;
                    ps_next_dpb->ps_prev_short->s_top_field.u1_reference_info =
                                    UNUSED_FOR_REF;
                    ps_next_dpb->ps_prev_short->s_bot_field.u1_reference_info =
                                    UNUSED_FOR_REF;
                    ih264d_free_ref_pic_mv_bufs(ps_dpb_mgr->pv_codec_handle,
                                                ps_next_dpb->ps_prev_short->u1_buf_id);
                    ps_next_dpb->ps_prev_short->ps_pic_buf = NULL;
                    ps_next_dpb->ps_prev_short = NULL;
 }
 }
 }
 else
 {
 if(ps_dpb_mgr->u1_num_st_ref_bufs)
 {
                ret = ih264d_delete_gap_frm_sliding(ps_dpb_mgr,
                                                    ps_next_dpb->i4_frame_num,
 &u1_del_node);
 if(ret != OK)
 return ret;
 if((ps_next_dpb->i4_frame_num != (WORD32)u4_cur_pic_num)
 && u1_del_node)
 {
                    ps_dpb_mgr->u1_num_st_ref_bufs--;
                    ps_next_dpb->u1_used_as_ref = FALSE;
                    ps_next_dpb->s_top_field.u1_reference_info = UNUSED_FOR_REF;
                    ps_next_dpb->s_bot_field.u1_reference_info = UNUSED_FOR_REF;
                    ih264d_free_ref_pic_mv_bufs(ps_dpb_mgr->pv_codec_handle,
                                                ps_next_dpb->u1_buf_id);
                    ps_next_dpb->ps_pic_buf = NULL;
                    ps_next_dpb = NULL;
 }
 }
 else
 {
                ret = ih264d_delete_gap_frm_sliding(ps_dpb_mgr, INVALID_FRAME_NUM, &u1_del_node);
 if(ret != OK)
 return ret;
 if(u1_del_node)
 return ERROR_DBP_MANAGER_T;
 }
 }
 }
 return OK;
}

WORD32 ih264d_parse_bmb_cavlc(dec_struct_t * ps_dec,
 dec_mb_info_t * ps_cur_mb_info,
                              UWORD8 u1_mb_num,
                              UWORD8 u1_num_mbsNby2)
{
    UWORD32 u4_cbp;
 deblk_mb_t * ps_cur_deblk_mb = ps_dec->ps_deblk_mbn + u1_mb_num;
 dec_bit_stream_t * const ps_bitstrm = ps_dec->ps_bitstrm;
    UWORD32 * pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
    UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;
 const UWORD8 *puc_mb_mc_mode = (const UWORD8 *)gau1_ih264d_mb_mc_mode;
    UWORD8 u1_mb_type = ps_cur_mb_info->u1_mb_type;

    WORD32 ret;
    UWORD8 u1_Bdirect_tranform_read = 1;
    ps_dec->s_high_profile.u1_no_submb_part_size_lt8x8_flag = 1;
    ps_cur_mb_info->u1_tran_form8x8 = 0;
    ps_cur_mb_info->ps_curmb->u1_tran_form8x8 = 0;

    ps_cur_mb_info->u1_yuv_dc_block_flag = 0;

    ps_cur_mb_info->u1_mb_mc_mode = puc_mb_mc_mode[5 + u1_mb_type];

    ps_cur_deblk_mb->u1_mb_type |= D_B_SLICE;
 if(u1_mb_type != B_DIRECT)
 {
        ret = ih264d_parse_bmb_non_direct_cavlc(ps_dec, ps_cur_mb_info, u1_mb_num,
                                          u1_num_mbsNby2);
 if(ret != OK)
 return ret;
 }
 else
 {
 /************ STORING PARTITION INFO ***********/
 parse_part_params_t * ps_part_info;
        ps_part_info = ps_dec->ps_part;
        ps_part_info->u1_is_direct = PART_DIRECT_16x16;
        ps_part_info->u1_sub_mb_num = 0;
        ps_dec->ps_part++;
 /* check whether transform8x8 u4_flag to be read or not */
        u1_Bdirect_tranform_read =
                        ps_dec->s_high_profile.u1_direct_8x8_inference_flag;
 }

 /* Read the Coded block pattern */
 {
 const UWORD8 * puc_CbpInter = gau1_ih264d_cbp_inter;
        UWORD32 u4_bitstream_offset = *pu4_bitstrm_ofst;
        UWORD32 u4_word, u4_ldz;

 /***************************************************************/
 /* Find leading zeros in next 32 bits                          */
 /***************************************************************/
        NEXTBITS_32(u4_word, u4_bitstream_offset, pu4_bitstrm_buf);
        u4_ldz = CLZ(u4_word);
 /* Flush the ps_bitstrm */
        u4_bitstream_offset += (u4_ldz + 1);
 /* Read the suffix from the ps_bitstrm */
        u4_word = 0;
 if(u4_ldz)
            GETBITS(u4_word, u4_bitstream_offset, pu4_bitstrm_buf, u4_ldz);
 *pu4_bitstrm_ofst = u4_bitstream_offset;
        u4_cbp = ((1 << u4_ldz) + u4_word - 1);
 if(u4_cbp > 47)
 return ERROR_CBP;
        u4_cbp = puc_CbpInter[u4_cbp];

 if((ps_dec->s_high_profile.u1_transform8x8_present) && (u4_cbp & (0xf))
 && (ps_dec->s_high_profile.u1_no_submb_part_size_lt8x8_flag)
 && (u1_Bdirect_tranform_read))
 {
            ps_cur_mb_info->u1_tran_form8x8 = ih264d_get_bit_h264(ps_bitstrm);
            COPYTHECONTEXT("transform_size_8x8_flag", ps_cur_mb_info->u1_tran_form8x8);
            ps_cur_mb_info->ps_curmb->u1_tran_form8x8 = ps_cur_mb_info->u1_tran_form8x8;
 }

 }

    COPYTHECONTEXT("coded_block_pattern", u4_cbp);
    ps_cur_mb_info->u1_cbp = u4_cbp;

 /* Read mb_qp_delta */
 if(u4_cbp)
 {
        WORD32 i_temp;

        UWORD32 u4_bitstream_offset = *pu4_bitstrm_ofst;
        UWORD32 u4_word, u4_ldz, u4_abs_val;

 /***************************************************************/
 /* Find leading zeros in next 32 bits                          */
 /***************************************************************/
        NEXTBITS_32(u4_word, u4_bitstream_offset, pu4_bitstrm_buf);
        u4_ldz = CLZ(u4_word);

 /* Flush the ps_bitstrm */
        u4_bitstream_offset += (u4_ldz + 1);

 /* Read the suffix from the ps_bitstrm */
        u4_word = 0;
 if(u4_ldz)
            GETBITS(u4_word, u4_bitstream_offset, pu4_bitstrm_buf, u4_ldz);

 *pu4_bitstrm_ofst = u4_bitstream_offset;
        u4_abs_val = ((1 << u4_ldz) + u4_word) >> 1;

 if(u4_word & 0x1)
            i_temp = (-(WORD32)u4_abs_val);
 else
            i_temp = (u4_abs_val);

 if(i_temp < -26 || i_temp > 25)
 return ERROR_INV_RANGE_QP_T;
        COPYTHECONTEXT("mb_qp_delta", i_temp);
 if(i_temp)
 {
            ret = ih264d_update_qp(ps_dec, (WORD8)i_temp);
 if(ret != OK)
 return ret;
 }

        ret = ih264d_parse_residual4x4_cavlc(ps_dec, ps_cur_mb_info, 0);
 if(ret != OK)
 return ret;
 if(EXCEED_OFFSET(ps_bitstrm))
 return ERROR_EOB_TERMINATE_T;
 }
 else
 {
        ps_dec->i1_prev_mb_qp_delta = 0;
        ih264d_update_nnz_for_skipmb(ps_dec, ps_cur_mb_info, CAVLC);
 }

 return OK;
}

void ih264d_init_ref_bufs(dpb_manager_t *ps_dpb_mgr)
{
    UWORD32 i;
 struct dpb_info_t *ps_dpb_info = ps_dpb_mgr->as_dpb_info;
 for(i = 0; i < MAX_REF_BUFS; i++)
 {
        ps_dpb_info[i].u1_used_as_ref = UNUSED_FOR_REF;
        ps_dpb_info[i].u1_lt_idx = MAX_REF_BUFS + 1;
        ps_dpb_info[i].ps_prev_short = NULL;
        ps_dpb_info[i].ps_prev_long = NULL;
        ps_dpb_info[i].ps_pic_buf = NULL;
        ps_dpb_info[i].s_top_field.u1_reference_info = UNUSED_FOR_REF;
        ps_dpb_info[i].s_bot_field.u1_reference_info = UNUSED_FOR_REF;
        ps_dpb_info[i].s_top_field.u1_long_term_frame_idx = MAX_REF_BUFS + 1;
        ps_dpb_info[i].s_bot_field.u1_long_term_frame_idx = MAX_REF_BUFS + 1;

 }
    ps_dpb_mgr->u1_num_st_ref_bufs = ps_dpb_mgr->u1_num_lt_ref_bufs = 0;
    ps_dpb_mgr->ps_dpb_st_head = NULL;
    ps_dpb_mgr->ps_dpb_ht_head = NULL;
    ps_dpb_mgr->i1_gaps_deleted = 0;
    ps_dpb_mgr->i1_poc_buf_id_entries = 0;

    ps_dpb_mgr->u1_num_gaps = 0;
 for(i = 0; i < MAX_FRAMES; i++)
 {
        ps_dpb_mgr->ai4_gaps_start_frm_num[i] = INVALID_FRAME_NUM;
        ps_dpb_mgr->ai4_gaps_end_frm_num[i] = 0;
        ps_dpb_mgr->ai1_gaps_per_seq[i] = 0;
        ps_dpb_mgr->ai4_poc_buf_id_map[i][0] = -1;
        ps_dpb_mgr->ai4_poc_buf_id_map[i][1] = 0x7fffffff;
        ps_dpb_mgr->ai4_poc_buf_id_map[i][2] = 0;
 }

}

WORD32 ih264d_parse_inter_slice_data_cavlc(dec_struct_t * ps_dec,
 dec_slice_params_t * ps_slice,
                                           UWORD16 u2_first_mb_in_slice)
{
    UWORD32 uc_more_data_flag;
    WORD32 i2_cur_mb_addr;
    UWORD32 u1_num_mbs, u1_num_mbsNby2, u1_mb_idx;
    UWORD32 i2_mb_skip_run;
    UWORD32 u1_read_mb_type;

    UWORD32 u1_mbaff;
    UWORD32 u1_num_mbs_next, u1_end_of_row;
 const UWORD32 i2_pic_wdin_mbs = ps_dec->u2_frm_wd_in_mbs;
    UWORD32 u1_slice_end = 0;
    UWORD32 u1_tfr_n_mb = 0;
    UWORD32 u1_decode_nmb = 0;

 dec_bit_stream_t * const ps_bitstrm = ps_dec->ps_bitstrm;
    UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
    UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;
 deblk_mb_t *ps_cur_deblk_mb;
 dec_mb_info_t *ps_cur_mb_info;
 parse_pmbarams_t *ps_parse_mb_data = ps_dec->ps_parse_mb_data;
    UWORD32 u1_inter_mb_type;
    UWORD32 u1_deblk_mb_type;
    UWORD32 u1_mb_threshold;
    WORD32 ret = OK;

 /******************************************************/
 /* Initialisations specific to B or P slice           */
 /******************************************************/

 if(ps_slice->u1_slice_type == P_SLICE)
 {
        u1_inter_mb_type = P_MB;
        u1_deblk_mb_type = D_INTER_MB;
        u1_mb_threshold = 5;
 }
 else // B_SLICE
 {
        u1_inter_mb_type = B_MB;
        u1_deblk_mb_type = D_B_SLICE;
        u1_mb_threshold = 23;
 }
 /******************************************************/
 /* Slice Level Initialisations                        */
 /******************************************************/
    ps_dec->u1_qp = ps_slice->u1_slice_qp;
    ih264d_update_qp(ps_dec, 0);
    u1_mb_idx = ps_dec->u1_mb_idx;
    u1_num_mbs = u1_mb_idx;

    u1_num_mbsNby2 = 0;
    u1_mbaff = ps_slice->u1_mbaff_frame_flag;
    i2_cur_mb_addr = u2_first_mb_in_slice << u1_mbaff;
    i2_mb_skip_run = 0;
    uc_more_data_flag = 1;
    u1_read_mb_type = 0;

 while(!u1_slice_end)
 {
        UWORD8 u1_mb_type;

        ps_dec->pv_prev_mb_parse_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;

 if(i2_cur_mb_addr > ps_dec->ps_cur_sps->u2_max_mb_addr)
 {
            ret = ERROR_MB_ADDRESS_T;
 break;
 }


        ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs;
        ps_dec->u4_num_mbs_cur_nmb = u1_num_mbs;

        ps_cur_mb_info->u1_Mux = 0;
        ps_dec->u4_num_pmbair = (u1_num_mbs >> u1_mbaff);
        ps_cur_deblk_mb = ps_dec->ps_deblk_mbn + u1_num_mbs;

        ps_cur_mb_info->u1_end_of_slice = 0;

 /* Storing Default partition info */
        ps_parse_mb_data->u1_num_part = 1;
        ps_parse_mb_data->u1_isI_mb = 0;

 if((!i2_mb_skip_run) && (!u1_read_mb_type))
 {

            UWORD32 u4_bitstream_offset = *pu4_bitstrm_ofst;
            UWORD32 u4_word, u4_ldz;

 /***************************************************************/
 /* Find leading zeros in next 32 bits                          */
 /***************************************************************/
            NEXTBITS_32(u4_word, u4_bitstream_offset, pu4_bitstrm_buf);

            u4_ldz = CLZ(u4_word);

 /* Flush the ps_bitstrm */
            u4_bitstream_offset += (u4_ldz + 1);
 /* Read the suffix from the ps_bitstrm */
            u4_word = 0;
 if(u4_ldz)
 {
                GETBITS(u4_word, u4_bitstream_offset, pu4_bitstrm_buf,
                        u4_ldz);
 }
 *pu4_bitstrm_ofst = u4_bitstream_offset;
            i2_mb_skip_run = ((1 << u4_ldz) + u4_word - 1);
            COPYTHECONTEXT("mb_skip_run", i2_mb_skip_run);
            uc_more_data_flag = MORE_RBSP_DATA(ps_bitstrm);
            u1_read_mb_type = uc_more_data_flag;
 }

 /***************************************************************/
 /* Get the required information for decoding of MB                  */
 /* mb_x, mb_y , neighbour availablity,                              */
 /***************************************************************/
        ps_dec->pf_get_mb_info(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);

 /***************************************************************/
 /* Set the deblocking parameters for this MB                   */
 /***************************************************************/
 if(ps_dec->u4_app_disable_deblk_frm == 0)
            ih264d_set_deblocking_parameters(ps_cur_deblk_mb, ps_slice,
                                             ps_dec->u1_mb_ngbr_availablity,
                                             ps_dec->u1_cur_mb_fld_dec_flag);

 if(i2_mb_skip_run)
 {
 /* Set appropriate flags in ps_cur_mb_info and ps_dec */
            ps_dec->i1_prev_mb_qp_delta = 0;
            ps_dec->u1_sub_mb_num = 0;
            ps_cur_mb_info->u1_mb_type = MB_SKIP;
            ps_cur_mb_info->u1_mb_mc_mode = PRED_16x16;
            ps_cur_mb_info->u1_cbp = 0;

 {
 /* Storing Skip partition info */
 parse_part_params_t *ps_part_info = ps_dec->ps_part;
                ps_part_info->u1_is_direct = PART_DIRECT_16x16;
                ps_part_info->u1_sub_mb_num = 0;
                ps_dec->ps_part++;
 }

 /* Update Nnzs */
            ih264d_update_nnz_for_skipmb(ps_dec, ps_cur_mb_info, CAVLC);

            ps_cur_mb_info->ps_curmb->u1_mb_type = u1_inter_mb_type;
            ps_cur_deblk_mb->u1_mb_type |= u1_deblk_mb_type;

            i2_mb_skip_run--;
 }
 else
 {
            u1_read_mb_type = 0;
 /**************************************************************/
 /* Macroblock Layer Begins, Decode the u1_mb_type                */
 /**************************************************************/
 {
                UWORD32 u4_bitstream_offset = *pu4_bitstrm_ofst;
                UWORD32 u4_word, u4_ldz, u4_temp;


 /***************************************************************/
 /* Find leading zeros in next 32 bits                          */
 /***************************************************************/
                NEXTBITS_32(u4_word, u4_bitstream_offset, pu4_bitstrm_buf);
                u4_ldz = CLZ(u4_word);
 /* Flush the ps_bitstrm */
                u4_bitstream_offset += (u4_ldz + 1);
 /* Read the suffix from the ps_bitstrm */
                u4_word = 0;
 if(u4_ldz)
                    GETBITS(u4_word, u4_bitstream_offset, pu4_bitstrm_buf,
                            u4_ldz);
 *pu4_bitstrm_ofst = u4_bitstream_offset;
                u4_temp = ((1 << u4_ldz) + u4_word - 1);
 if(u4_temp > (UWORD32)(25 + u1_mb_threshold))
 return ERROR_MB_TYPE;
                u1_mb_type = u4_temp;
                COPYTHECONTEXT("u1_mb_type", u1_mb_type);
 }
            ps_cur_mb_info->u1_mb_type = u1_mb_type;

 /**************************************************************/
 /* Parse Macroblock data                                      */
 /**************************************************************/
 if(u1_mb_type < u1_mb_threshold)
 {
                ps_cur_mb_info->ps_curmb->u1_mb_type = u1_inter_mb_type;

                ret = ps_dec->pf_parse_inter_mb(ps_dec, ps_cur_mb_info, u1_num_mbs,
                                          u1_num_mbsNby2);
 if(ret != OK)
 return ret;
                ps_cur_deblk_mb->u1_mb_type |= u1_deblk_mb_type;
 }
 else
 {
 /* Storing Intra partition info */
                ps_parse_mb_data->u1_num_part = 0;
                ps_parse_mb_data->u1_isI_mb = 1;

 if((25 + u1_mb_threshold) == u1_mb_type)
 {
 /* I_PCM_MB */
                    ps_cur_mb_info->ps_curmb->u1_mb_type = I_PCM_MB;
                    ret = ih264d_parse_ipcm_mb(ps_dec, ps_cur_mb_info, u1_num_mbs);
 if(ret != OK)
 return ret;
                    ps_dec->u1_qp = 0;
 }
 else
 {
                    ret = ih264d_parse_imb_cavlc(
                                    ps_dec, ps_cur_mb_info, u1_num_mbs,
 (UWORD8)(u1_mb_type - u1_mb_threshold));
 if(ret != OK)
 return ret;
 }

                ps_cur_deblk_mb->u1_mb_type |= D_INTRA_MB;
 }
            uc_more_data_flag = MORE_RBSP_DATA(ps_bitstrm);
 }
        ps_cur_deblk_mb->u1_mb_qp = ps_dec->u1_qp;

 if(u1_mbaff)
 {
            ih264d_update_mbaff_left_nnz(ps_dec, ps_cur_mb_info);
 }
 /**************************************************************/
 /* Get next Macroblock address                                */
 /**************************************************************/
        i2_cur_mb_addr++;

        u1_num_mbs++;
        u1_num_mbsNby2++;
        ps_parse_mb_data++;

 /****************************************************************/
 /* Check for End Of Row and other flags that determine when to  */
 /* do DMA setup for N/2-Mb, Decode for N-Mb, and Transfer for   */
 /* N-Mb                                                         */
 /****************************************************************/
        u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;
        u1_end_of_row = (!u1_num_mbs_next) && (!(u1_mbaff && (u1_num_mbs & 0x01)));
        u1_slice_end = (!(uc_more_data_flag || i2_mb_skip_run));
        u1_tfr_n_mb = (u1_num_mbs == ps_dec->u1_recon_mb_grp) || u1_end_of_row
 || u1_slice_end;
        u1_decode_nmb = u1_tfr_n_mb || u1_slice_end;
        ps_cur_mb_info->u1_end_of_slice = u1_slice_end;

 /*u1_dma_nby2mb   = u1_decode_nmb ||
         (u1_num_mbsNby2 == ps_dec->u1_recon_mb_grp_pair);*/

 if(u1_decode_nmb)
 {
            ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx, u1_num_mbs);
            u1_num_mbsNby2 = 0;

 {
                ps_parse_mb_data = ps_dec->ps_parse_mb_data;
                ps_dec->ps_part = ps_dec->ps_parse_part_params;
 }
 }

 /*H264_DEC_DEBUG_PRINT("Pic: %d Mb_X=%d Mb_Y=%d",
         ps_slice->i4_poc >> ps_slice->u1_field_pic_flag,
         ps_dec->u2_mbx,ps_dec->u2_mby + (1 - ps_cur_mb_info->u1_topmb));
         H264_DEC_DEBUG_PRINT("u1_decode_nmb: %d", u1_decode_nmb);*/
 if(u1_decode_nmb)
 {



 if(ps_dec->u1_separate_parse)
 {
                ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,
                                     u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);
                ps_dec->ps_nmb_info +=  u1_num_mbs;
 }
 else
 {
                ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,
                                            u1_num_mbs_next, u1_tfr_n_mb,
                                            u1_end_of_row);
 }
            ps_dec->u2_total_mbs_coded += u1_num_mbs;
 if(u1_tfr_n_mb)
                u1_num_mbs = 0;
            u1_mb_idx = u1_num_mbs;
            ps_dec->u1_mb_idx = u1_num_mbs;

 }
 }

    ps_dec->u4_num_mbs_cur_nmb = 0;
    ps_dec->ps_cur_slice->u4_mbs_in_slice = i2_cur_mb_addr
 - (u2_first_mb_in_slice << u1_mbaff);


 return ret;
}

WORD32 ih264d_update_default_index_list(dpb_manager_t *ps_dpb_mgr)
{
    WORD32 i;
 struct dpb_info_t *ps_next_dpb = ps_dpb_mgr->ps_dpb_st_head;

 for(i = 0; i < ps_dpb_mgr->u1_num_st_ref_bufs; i++)
 {
        ps_dpb_mgr->ps_def_dpb[i] = ps_next_dpb->ps_pic_buf;
        ps_next_dpb = ps_next_dpb->ps_prev_short;
 }

    ps_next_dpb = ps_dpb_mgr->ps_dpb_ht_head;
 for(;i< ps_dpb_mgr->u1_num_st_ref_bufs + ps_dpb_mgr->u1_num_lt_ref_bufs; i++)
 {
        ps_dpb_mgr->ps_def_dpb[i] = ps_next_dpb->ps_pic_buf;
        ps_next_dpb = ps_next_dpb->ps_prev_long;
 }
 return 0;
}

WORD32 ih264d_parse_islice_data_cavlc(dec_struct_t * ps_dec,
 dec_slice_params_t * ps_slice,
                                      UWORD16 u2_first_mb_in_slice)
{
    UWORD8 uc_more_data_flag;
    UWORD8 u1_num_mbs, u1_mb_idx;
 dec_mb_info_t *ps_cur_mb_info;
 deblk_mb_t *ps_cur_deblk_mb;
 dec_bit_stream_t * const ps_bitstrm = ps_dec->ps_bitstrm;
    UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;
    UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
    UWORD16 i2_pic_wdin_mbs = ps_dec->u2_frm_wd_in_mbs;
    WORD16 i2_cur_mb_addr;
    UWORD8 u1_mbaff;
    UWORD8 u1_num_mbs_next, u1_end_of_row, u1_tfr_n_mb;
    WORD32 ret = OK;

    ps_dec->u1_qp = ps_slice->u1_slice_qp;
    ih264d_update_qp(ps_dec, 0);
    u1_mbaff = ps_slice->u1_mbaff_frame_flag;

 /* initializations */
    u1_mb_idx = ps_dec->u1_mb_idx;
    u1_num_mbs = u1_mb_idx;

    uc_more_data_flag = 1;
    i2_cur_mb_addr = u2_first_mb_in_slice << u1_mbaff;

 do
 {
        UWORD8 u1_mb_type;

        ps_dec->pv_prev_mb_parse_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;

 if(i2_cur_mb_addr > ps_dec->ps_cur_sps->u2_max_mb_addr)
 {
            ret = ERROR_MB_ADDRESS_T;
 break;
 }

        ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs;
        ps_dec->u4_num_mbs_cur_nmb = u1_num_mbs;
        ps_dec->u4_num_pmbair = (u1_num_mbs >> u1_mbaff);

        ps_cur_mb_info->u1_end_of_slice = 0;

 /***************************************************************/
 /* Get the required information for decoding of MB             */
 /* mb_x, mb_y , neighbour availablity,                         */
 /***************************************************************/
        ps_dec->pf_get_mb_info(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, 0);

 /***************************************************************/
 /* Set the deblocking parameters for this MB                   */
 /***************************************************************/
        ps_cur_deblk_mb = ps_dec->ps_deblk_mbn + u1_num_mbs;

 if(ps_dec->u4_app_disable_deblk_frm == 0)
            ih264d_set_deblocking_parameters(ps_cur_deblk_mb, ps_slice,
                                             ps_dec->u1_mb_ngbr_availablity,
                                             ps_dec->u1_cur_mb_fld_dec_flag);

        ps_cur_deblk_mb->u1_mb_type = ps_cur_deblk_mb->u1_mb_type | D_INTRA_MB;

 /**************************************************************/
 /* Macroblock Layer Begins, Decode the u1_mb_type                */
 /**************************************************************/
 {
            UWORD32 u4_bitstream_offset = *pu4_bitstrm_ofst;
            UWORD32 u4_word, u4_ldz, u4_temp;

 /***************************************************************/
 /* Find leading zeros in next 32 bits                          */
 /***************************************************************/
            NEXTBITS_32(u4_word, u4_bitstream_offset, pu4_bitstrm_buf);
            u4_ldz = CLZ(u4_word);
 /* Flush the ps_bitstrm */
            u4_bitstream_offset += (u4_ldz + 1);
 /* Read the suffix from the ps_bitstrm */
            u4_word = 0;
 if(u4_ldz)
                GETBITS(u4_word, u4_bitstream_offset, pu4_bitstrm_buf,
                        u4_ldz);
 *pu4_bitstrm_ofst = u4_bitstream_offset;
            u4_temp = ((1 << u4_ldz) + u4_word - 1);
 if(u4_temp > 25)
 return ERROR_MB_TYPE;
            u1_mb_type = u4_temp;

 }
        ps_cur_mb_info->u1_mb_type = u1_mb_type;
        COPYTHECONTEXT("u1_mb_type", u1_mb_type);

 /**************************************************************/
 /* Parse Macroblock data                                      */
 /**************************************************************/
 if(25 == u1_mb_type)
 {
 /* I_PCM_MB */
            ps_cur_mb_info->ps_curmb->u1_mb_type = I_PCM_MB;
            ret = ih264d_parse_ipcm_mb(ps_dec, ps_cur_mb_info, u1_num_mbs);
 if(ret != OK)
 return ret;
            ps_cur_deblk_mb->u1_mb_qp = 0;
 }
 else
 {
            ret = ih264d_parse_imb_cavlc(ps_dec, ps_cur_mb_info, u1_num_mbs, u1_mb_type);
 if(ret != OK)
 return ret;
            ps_cur_deblk_mb->u1_mb_qp = ps_dec->u1_qp;
 }

 if(u1_mbaff)
 {
            ih264d_update_mbaff_left_nnz(ps_dec, ps_cur_mb_info);
 }
 /**************************************************************/
 /* Get next Macroblock address                                */
 /**************************************************************/

        i2_cur_mb_addr++;
        uc_more_data_flag = MORE_RBSP_DATA(ps_bitstrm);

 /* Store the colocated information */
 {
 mv_pred_t *ps_mv_nmb_start = ps_dec->ps_mv_cur + (u1_num_mbs << 4);

 mv_pred_t s_mvPred =
 {
 { 0, 0, 0, 0 },
 { -1, -1 }, 0, 0};
            ih264d_rep_mv_colz(ps_dec, &s_mvPred, ps_mv_nmb_start, 0,
 (UWORD8)(ps_dec->u1_cur_mb_fld_dec_flag << 1), 4,
 4);
 }

 /*if num _cores is set to 3,compute bs will be done in another thread*/
 if(ps_dec->u4_num_cores < 3)
 {
 if(ps_dec->u4_app_disable_deblk_frm == 0)
                ps_dec->pf_compute_bs(ps_dec, ps_cur_mb_info,
 (UWORD16)(u1_num_mbs >> u1_mbaff));
 }
        u1_num_mbs++;

 /****************************************************************/
 /* Check for End Of Row                                         */
 /****************************************************************/
        u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;
        u1_end_of_row = (!u1_num_mbs_next) && (!(u1_mbaff && (u1_num_mbs & 0x01)));
        u1_tfr_n_mb = (u1_num_mbs == ps_dec->u1_recon_mb_grp) || u1_end_of_row
 || (!uc_more_data_flag);
        ps_cur_mb_info->u1_end_of_slice = (!uc_more_data_flag);

 /*H264_DEC_DEBUG_PRINT("Pic: %d Mb_X=%d Mb_Y=%d",
         ps_slice->i4_poc >> ps_slice->u1_field_pic_flag,
         ps_dec->u2_mbx,ps_dec->u2_mby + (1 - ps_cur_mb_info->u1_topmb));
         H264_DEC_DEBUG_PRINT("u1_tfr_n_mb || (!uc_more_data_flag): %d", u1_tfr_n_mb || (!uc_more_data_flag));*/
 if(u1_tfr_n_mb || (!uc_more_data_flag))
 {

 if(ps_dec->u1_separate_parse)
 {
                ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,
                                     u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);
                ps_dec->ps_nmb_info +=  u1_num_mbs;
 }
 else
 {
                ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,
                                            u1_num_mbs_next, u1_tfr_n_mb,
                                            u1_end_of_row);
 }
            ps_dec->u2_total_mbs_coded += u1_num_mbs;
 if(u1_tfr_n_mb)
                u1_num_mbs = 0;
            u1_mb_idx = u1_num_mbs;
            ps_dec->u1_mb_idx = u1_num_mbs;

 }
 }
 while(uc_more_data_flag);

    ps_dec->u4_num_mbs_cur_nmb = 0;
    ps_dec->ps_cur_slice->u4_mbs_in_slice = i2_cur_mb_addr

 - (u2_first_mb_in_slice << u1_mbaff);

 return ret;
}

void ih264d_release_pics_in_dpb(void *pv_dec,
                                UWORD8 u1_disp_bufs)
{
    WORD8 i;
 dec_struct_t *ps_dec = (dec_struct_t *)pv_dec;

 for(i = 0; i < u1_disp_bufs; i++)
 {
        ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,
                              i,
                              BUF_MGR_REF);
        ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,
                              ps_dec->au1_pic_buf_id_mv_buf_id_map[i],
                              BUF_MGR_REF);
 }
}

void ih264d_delete_nonref_nondisplay_pics(dpb_manager_t *ps_dpb_mgr)
{
    WORD8 i;
    WORD32 (*i4_poc_buf_id_map)[3] = ps_dpb_mgr->ai4_poc_buf_id_map;

 /* remove all gaps marked as unused for ref */
 for(i = 0; (i < MAX_FRAMES) && ps_dpb_mgr->i1_gaps_deleted; i++)
 {
 if(GAP_FRAME_NUM == i4_poc_buf_id_map[i][2])
 {
            ps_dpb_mgr->i1_gaps_deleted--;
            ps_dpb_mgr->i1_poc_buf_id_entries--;
            i4_poc_buf_id_map[i][0] = -1;
            i4_poc_buf_id_map[i][1] = 0x7fffffff;
            i4_poc_buf_id_map[i][2] = 0;
 }
 }
}

WORD32 ih264d_parse_bmb_non_direct_cavlc(dec_struct_t * ps_dec,
 dec_mb_info_t * ps_cur_mb_info,
                                       UWORD8 u1_mb_num,
                                       UWORD8 u1_num_mbsNby2)
{
 dec_bit_stream_t * ps_bitstrm = ps_dec->ps_bitstrm;
    UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
    UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;
    UWORD8 * pu1_sub_mb_pred_modes = (UWORD8 *)(gau1_ih264d_submb_pred_modes) + 4;
 const UWORD8 (*pu1_mb_pred_modes)[32] =
 (const UWORD8 (*)[32])gau1_ih264d_mb_pred_modes;
 const UWORD8 * pu1_num_mb_part = (const UWORD8 *)gau1_ih264d_num_mb_part;
 const UWORD8 * pu1_sub_mb_mc_mode = (const UWORD8 *)(gau1_ih264d_submb_mc_mode)
 + 4;

 parse_pmbarams_t * ps_parse_mb_data = ps_dec->ps_parse_mb_data
 + u1_num_mbsNby2;
    UWORD8 * pu1_col_info = ps_parse_mb_data->u1_col_info;
    WORD8 (*pi1_ref_idx)[MAX_REFIDX_INFO_PER_MB] = ps_parse_mb_data->i1_ref_idx;
    UWORD8 u1_mb_type = ps_cur_mb_info->u1_mb_type;
    UWORD8 u1_mb_mc_mode, u1_num_mb_part, u1_sub_mb = !(u1_mb_type ^ B_8x8);
    UWORD32 u4_mb_mc_mode = 0, u4_mb_pred_mode = 0;
    WORD32 ret;

 if(u1_sub_mb)
 {
        UWORD8 uc_i;
        u1_mb_mc_mode = 0;
        u1_num_mb_part = 4;
 /* Reading the subMB type */
 for(uc_i = 0; uc_i < 4; uc_i++)
 {

            UWORD32 ui_sub_mb_mode;

            UWORD32 u4_bitstream_offset = *pu4_bitstrm_ofst;
            UWORD32 u4_word, u4_ldz;

 /***************************************************************/
 /* Find leading zeros in next 32 bits                          */
 /***************************************************************/
            NEXTBITS_32(u4_word, u4_bitstream_offset, pu4_bitstrm_buf);
            u4_ldz = CLZ(u4_word);
 /* Flush the ps_bitstrm */
            u4_bitstream_offset += (u4_ldz + 1);
 /* Read the suffix from the ps_bitstrm */
            u4_word = 0;
 if(u4_ldz)
                GETBITS(u4_word, u4_bitstream_offset, pu4_bitstrm_buf,
                        u4_ldz);
 *pu4_bitstrm_ofst = u4_bitstream_offset;
            ui_sub_mb_mode = ((1 << u4_ldz) + u4_word - 1);

 if(ui_sub_mb_mode > 12)
 return ERROR_SUB_MB_TYPE;
 else
 {
                UWORD8 u1_subMbPredMode = pu1_sub_mb_pred_modes[ui_sub_mb_mode];
                u4_mb_mc_mode = (u4_mb_mc_mode << 8)
 | pu1_sub_mb_mc_mode[ui_sub_mb_mode];
                u4_mb_pred_mode = (u4_mb_pred_mode << 8) | u1_subMbPredMode;
                pi1_ref_idx[0][uc_i] = ((u1_subMbPredMode & PRED_L0) - 1) >> 1;
                pi1_ref_idx[1][uc_i] = ((u1_subMbPredMode & PRED_L1) - 1) >> 1;
                COPYTHECONTEXT("sub_mb_type", u1_subMbPredMode);
 }
 /* Storing collocated Mb and SubMb mode information */
 *pu1_col_info++ = ((PRED_8x8) << 6)
 | ((pu1_sub_mb_mc_mode[ui_sub_mb_mode] << 4));
 if(ui_sub_mb_mode != B_DIRECT_8x8)
 {
 if(ui_sub_mb_mode > B_BI_8x8)
 {
                    ps_dec->s_high_profile.u1_no_submb_part_size_lt8x8_flag = 0;
 }
 }
 else if(!ps_dec->s_high_profile.u1_direct_8x8_inference_flag)
 {
                ps_dec->s_high_profile.u1_no_submb_part_size_lt8x8_flag = 0;
 }
 }
 }
 else
 {
        UWORD8 u1_mb_pred_mode_idx = 5 + u1_mb_type;
        UWORD8 u1_mb_pred_mode_part0 = pu1_mb_pred_modes[0][u1_mb_pred_mode_idx];
        UWORD8 u1_mb_pred_mode_part1 = pu1_mb_pred_modes[1][u1_mb_pred_mode_idx];
        u1_mb_mc_mode = ps_cur_mb_info->u1_mb_mc_mode;
        u1_num_mb_part = pu1_num_mb_part[u1_mb_mc_mode];

        pi1_ref_idx[0][0] = ((u1_mb_pred_mode_part0 & PRED_L0) - 1) >> 1;
        pi1_ref_idx[1][0] = ((u1_mb_pred_mode_part0 & PRED_L1) - 1) >> 1;
        pi1_ref_idx[0][1] = ((u1_mb_pred_mode_part1 & PRED_L0) - 1) >> 1;
        pi1_ref_idx[1][1] = ((u1_mb_pred_mode_part1 & PRED_L1) - 1) >> 1;

        u4_mb_pred_mode = (u1_mb_pred_mode_part0 << 8) | u1_mb_pred_mode_part1;
        u4_mb_mc_mode = u1_mb_mc_mode | (u1_mb_mc_mode << 8);
        u4_mb_mc_mode <<= 16;
        u4_mb_pred_mode <<= 16;

 /* Storing collocated Mb and SubMb mode information */
 *pu1_col_info++ = (u1_mb_mc_mode << 6);
 if(u1_mb_mc_mode)
 *pu1_col_info++ = (u1_mb_mc_mode << 6);
 }

 {
        UWORD8 u1_mbaff = ps_dec->ps_cur_slice->u1_mbaff_frame_flag;
        UWORD8 uc_field = ps_cur_mb_info->u1_mb_field_decodingflag;
        UWORD8 *pu1_num_ref_idx_lx_active =
                        ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active;
 const UWORD8 u1_mbaff_field = (u1_mbaff & uc_field);
        UWORD8 u4_num_ref_idx_lx_active;

        u4_num_ref_idx_lx_active = (pu1_num_ref_idx_lx_active[0]
 << u1_mbaff_field) - 1;

 if(u4_num_ref_idx_lx_active)
 {
 if(1 == u4_num_ref_idx_lx_active)
                ih264d_parse_bmb_ref_index_cavlc_range1(
                                u1_num_mb_part, ps_bitstrm, pi1_ref_idx[0],
                                u4_num_ref_idx_lx_active);
 else
 {
                ret = ih264d_parse_bmb_ref_index_cavlc(u1_num_mb_part, ps_bitstrm,
                                                 pi1_ref_idx[0],
                                                 u4_num_ref_idx_lx_active);
 if(ret != OK)
 return ret;
 }
 }

        u4_num_ref_idx_lx_active = (pu1_num_ref_idx_lx_active[1]
 << u1_mbaff_field) - 1;

 if(u4_num_ref_idx_lx_active)
 {
 if(1 == u4_num_ref_idx_lx_active)
                ih264d_parse_bmb_ref_index_cavlc_range1(
                                u1_num_mb_part, ps_bitstrm, pi1_ref_idx[1],
                                u4_num_ref_idx_lx_active);
 else
 {
                ret = ih264d_parse_bmb_ref_index_cavlc(u1_num_mb_part, ps_bitstrm,
                                                 pi1_ref_idx[1],
                                                 u4_num_ref_idx_lx_active);
 if(ret != OK)
 return ret;
 }
 }
 }

 /* Read MotionVectors */
 {
 const UWORD8 * pu1_top_left_sub_mb_indx;

 const UWORD8 * pu1_sub_mb_indx_mod =
 (const UWORD8 *)(gau1_ih264d_submb_indx_mod)
 + (u1_sub_mb * 6);
 const UWORD8 * pu1_sub_mb_partw = (const UWORD8 *)gau1_ih264d_submb_partw;
 const UWORD8 * pu1_sub_mb_parth = (const UWORD8 *)gau1_ih264d_submb_parth;
 const UWORD8 * pu1_num_sub_mb_part =
 (const UWORD8 *)gau1_ih264d_num_submb_part;
 const UWORD8 * pu1_mb_partw = (const UWORD8 *)gau1_ih264d_mb_partw;
 const UWORD8 * pu1_mb_parth = (const UWORD8 *)gau1_ih264d_mb_parth;
        UWORD8 u1_p_idx = 0, u1_num_submb_part, uc_lx;
 parse_part_params_t * ps_part;
 mv_pred_t *ps_mv_start = ps_dec->ps_mv_cur + (u1_mb_num << 4);
        UWORD8 u1_mb_part_wd, u1_mb_part_ht;

 /* Initialisations */
        ps_part = ps_dec->ps_part;
 /* Default Initialization for Non subMb Case Mode */
        u1_mb_part_wd = pu1_mb_partw[u1_mb_mc_mode];
        u1_mb_part_ht = pu1_mb_parth[u1_mb_mc_mode];
        u1_num_submb_part = 1;

 /* Decoding the MV for the subMB */
 for(uc_lx = 0; uc_lx < 2; uc_lx++)
 {
            UWORD8 u1_sub_mb_num = 0, u1_pred_mode, uc_i;
            UWORD32 u4_mb_mc_mode_tmp = u4_mb_mc_mode;
            UWORD32 u4_mb_pred_mode_tmp = u4_mb_pred_mode;
            UWORD16 u2_sub_mb_num = 0x028A; // for sub mb case
            UWORD8 u1_b2 = uc_lx << 1;
            u1_pred_mode = (uc_lx) ? PRED_L1 : PRED_L0;
            pu1_top_left_sub_mb_indx = pu1_sub_mb_indx_mod + (u1_mb_mc_mode << 1);

 for(uc_i = 0; uc_i < u1_num_mb_part; uc_i++)
 {
                UWORD8 u1_mb_mc_mode, uc_j;
                UWORD8 i1_pred = u4_mb_pred_mode_tmp >> 24;
                u1_mb_mc_mode = u4_mb_mc_mode_tmp >> 24;
                u4_mb_pred_mode_tmp <<= 8;
                u4_mb_mc_mode_tmp <<= 8;
 /* subMb prediction mode */
 if(u1_sub_mb)
 {

                    u1_mb_part_wd = pu1_sub_mb_partw[u1_mb_mc_mode];
                    u1_mb_part_ht = pu1_sub_mb_parth[u1_mb_mc_mode];
                    u1_sub_mb_num = u2_sub_mb_num >> 12;
                    u1_num_submb_part = pu1_num_sub_mb_part[u1_mb_mc_mode];
                    pu1_top_left_sub_mb_indx = pu1_sub_mb_indx_mod
 + (u1_mb_mc_mode << 1);
                    u2_sub_mb_num <<= 4;
 }
 for(uc_j = 0; uc_j < u1_num_submb_part;
                                uc_j++, pu1_top_left_sub_mb_indx++)
 {
 mv_pred_t * ps_mv;
                    u1_sub_mb_num = u1_sub_mb_num + *pu1_top_left_sub_mb_indx;
                    ps_mv = ps_mv_start + u1_sub_mb_num;

 /* Storing Info for partitions, writing only once */
 if(uc_lx)
 {
                        ps_part->u1_is_direct = (!i1_pred);
                        ps_part->u1_pred_mode = i1_pred;
                        ps_part->u1_sub_mb_num = u1_sub_mb_num;
                        ps_part->u1_partheight = u1_mb_part_ht;
                        ps_part->u1_partwidth = u1_mb_part_wd;
 /* Increment partition Index */
                        u1_p_idx++;
                        ps_part++;
 }

 if(i1_pred & u1_pred_mode)
 {
                        WORD16 i2_mvx, i2_mvy;

 {
                            UWORD32 u4_bitstream_offset = *pu4_bitstrm_ofst;
                            UWORD32 u4_word, u4_ldz, u4_abs_val;

 /***************************************************************/
 /* Find leading zeros in next 32 bits                          */
 /***************************************************************/
                            NEXTBITS_32(u4_word, u4_bitstream_offset,
                                        pu4_bitstrm_buf);
                            u4_ldz = CLZ(u4_word);

 /* Flush the ps_bitstrm */
                            u4_bitstream_offset += (u4_ldz + 1);

 /* Read the suffix from the ps_bitstrm */
                            u4_word = 0;
 if(u4_ldz)
                                GETBITS(u4_word, u4_bitstream_offset,
                                        pu4_bitstrm_buf, u4_ldz);

 *pu4_bitstrm_ofst = u4_bitstream_offset;
                            u4_abs_val = ((1 << u4_ldz) + u4_word) >> 1;

 if(u4_word & 0x1)
                                i2_mvx = (-(WORD32)u4_abs_val);
 else
                                i2_mvx = (u4_abs_val);
 }

 {
                            UWORD32 u4_bitstream_offset = *pu4_bitstrm_ofst;
                            UWORD32 u4_word, u4_ldz, u4_abs_val;

 /***************************************************************/
 /* Find leading zeros in next 32 bits                          */
 /***************************************************************/
                            NEXTBITS_32(u4_word, u4_bitstream_offset,
                                        pu4_bitstrm_buf);
                            u4_ldz = CLZ(u4_word);

 /* Flush the ps_bitstrm */
                            u4_bitstream_offset += (u4_ldz + 1);

 /* Read the suffix from the ps_bitstrm */
                            u4_word = 0;
 if(u4_ldz)
                                GETBITS(u4_word, u4_bitstream_offset,
                                        pu4_bitstrm_buf, u4_ldz);

 *pu4_bitstrm_ofst = u4_bitstream_offset;
                            u4_abs_val = ((1 << u4_ldz) + u4_word) >> 1;

 if(u4_word & 0x1)
                                i2_mvy = (-(WORD32)u4_abs_val);
 else
                                i2_mvy = (u4_abs_val);
 }

 /* Storing Mv residuals */
                        ps_mv->i2_mv[u1_b2] = i2_mvx;
                        ps_mv->i2_mv[u1_b2 + 1] = i2_mvy;
 }
 }
 }
 }
 /* write back to the scratch partition info */
        ps_dec->ps_part = ps_part;
        ps_parse_mb_data->u1_num_part = u1_sub_mb ? u1_p_idx : u1_num_mb_part;

 }
 return OK;
}

WORD32 ih264d_insert_pic_in_display_list(dpb_manager_t *ps_dpb_mgr,
                                         UWORD8 u1_buf_id,
                                         WORD32 i4_display_poc,
                                         UWORD32 u4_frame_num)
{
    WORD8 i;
    WORD32 (*i4_poc_buf_id_map)[3] = ps_dpb_mgr->ai4_poc_buf_id_map;

 for(i = 0; i < MAX_FRAMES; i++)
 {
 /* Find an empty slot */
 if(i4_poc_buf_id_map[i][0] == -1)
 {
 if(GAP_FRAME_NUM == i4_poc_buf_id_map[i][2])
                ps_dpb_mgr->i1_gaps_deleted--;
 else
                ps_dpb_mgr->i1_poc_buf_id_entries++;

            i4_poc_buf_id_map[i][0] = u1_buf_id;
            i4_poc_buf_id_map[i][1] = i4_display_poc;
            i4_poc_buf_id_map[i][2] = u4_frame_num;

 break;
 }
 }

 if(MAX_FRAMES == i)
 {

        UWORD32 i4_error_code;
        i4_error_code = ERROR_GAPS_IN_FRM_NUM;
 return i4_error_code;
 }
 return OK;
}

WORD32 ih264d_delete_st_node_or_make_lt(dpb_manager_t *ps_dpb_mgr,
                                      WORD32 i4_pic_num,
                                      UWORD32 u4_lt_idx,
                                      UWORD8 u1_fld_pic_flag)
{
    WORD32 i;
 struct dpb_info_t *ps_next_dpb;
    WORD32 i4_frame_num = i4_pic_num;
 struct dpb_info_t *ps_unmark_node = NULL;
    UWORD8 u1_del_node = 0, u1_del_st = 0;
    UWORD8 u1_reference_type = UNUSED_FOR_REF;
    WORD32 ret;

 if(u1_fld_pic_flag)
 {
        i4_frame_num = i4_frame_num >> 1;

 if(u4_lt_idx == (MAX_REF_BUFS + 1))
            u1_reference_type = UNUSED_FOR_REF;
 else
            u1_reference_type = IS_LONG_TERM;
 }

    ps_next_dpb = ps_dpb_mgr->ps_dpb_st_head;
 if((WORD32)ps_next_dpb->i4_frame_num == i4_frame_num)
 {
        ps_unmark_node = ps_next_dpb;
 }
 else
 {
 for(i = 1; i < ps_dpb_mgr->u1_num_st_ref_bufs; i++)
 {
 if((WORD32)ps_next_dpb->ps_prev_short->i4_frame_num == i4_frame_num)
 break;
            ps_next_dpb = ps_next_dpb->ps_prev_short;
 }

 if(i == ps_dpb_mgr->u1_num_st_ref_bufs)
 {
 if(ps_dpb_mgr->u1_num_gaps)
 {
                ret = ih264d_delete_gap_frm_mmco(ps_dpb_mgr, i4_frame_num, &u1_del_st);
 if(ret != OK)
 return ret;
 }
 else
 {
                UWORD32 i4_error_code;
                i4_error_code = ERROR_DBP_MANAGER_T;

 return i4_error_code;
 }

 if(u1_del_st)
 {
                UWORD32 i4_error_code;
                i4_error_code = ERROR_DBP_MANAGER_T;
 return i4_error_code;
 }
 else
 {
 return 0;
 }
 }
 else
            ps_unmark_node = ps_next_dpb->ps_prev_short;
 }

 if(u1_fld_pic_flag)
 {
 /* Mark the corresponding field ( top or bot) as  */
 /* UNUSED_FOR_REF or IS_LONG_TERM depending on    */
 /* u1_reference_type.                             */
 if(ps_unmark_node->s_top_field.i4_pic_num == i4_pic_num)
 {
            ps_unmark_node->s_top_field.u1_reference_info = u1_reference_type;
            ps_unmark_node->s_top_field.u1_long_term_frame_idx = u4_lt_idx;
 {
                UWORD8 *pu1_src = ps_unmark_node->ps_pic_buf->pu1_col_zero_flag;
                WORD32 i4_size = ((ps_dpb_mgr->u2_pic_wd
 * ps_dpb_mgr->u2_pic_ht) >> 5);
 /* memset the colocated zero u4_flag buffer */
                memset(pu1_src, 0, i4_size);
 }
 }

 else if(ps_unmark_node->s_bot_field.i4_pic_num == i4_pic_num)
 {

            ps_unmark_node->s_bot_field.u1_reference_info = u1_reference_type;
            ps_unmark_node->s_bot_field.u1_long_term_frame_idx = u4_lt_idx;
 {
                UWORD8 *pu1_src =
                                ps_unmark_node->ps_pic_buf->pu1_col_zero_flag
 + ((ps_dpb_mgr->u2_pic_wd
 * ps_dpb_mgr->u2_pic_ht)
 >> 5);
                WORD32 i4_size = ((ps_dpb_mgr->u2_pic_wd
 * ps_dpb_mgr->u2_pic_ht) >> 5);
 /* memset the colocated zero u4_flag buffer */
                memset(pu1_src, 0, i4_size);
 }
 }
        ps_unmark_node->u1_used_as_ref =
                        ps_unmark_node->s_top_field.u1_reference_info
 | ps_unmark_node->s_bot_field.u1_reference_info;
 }
 else
 {
        ps_unmark_node->u1_used_as_ref = UNUSED_FOR_REF;
        ps_unmark_node->s_top_field.u1_reference_info = UNUSED_FOR_REF;
        ps_unmark_node->s_bot_field.u1_reference_info = UNUSED_FOR_REF;

 {
            UWORD8 *pu1_src = ps_unmark_node->ps_pic_buf->pu1_col_zero_flag;

            WORD32 i4_size = ((ps_dpb_mgr->u2_pic_wd
 * ps_dpb_mgr->u2_pic_ht) >> 4);
 /* memset the colocated zero u4_flag buffer */
            memset(pu1_src, 0, i4_size);
 }
 }

 if(!(ps_unmark_node->u1_used_as_ref & IS_SHORT_TERM))
 {
 if(ps_unmark_node == ps_dpb_mgr->ps_dpb_st_head)
            ps_dpb_mgr->ps_dpb_st_head = ps_next_dpb->ps_prev_short;
 else
            ps_next_dpb->ps_prev_short = ps_unmark_node->ps_prev_short; //update link
        ps_dpb_mgr->u1_num_st_ref_bufs--; //decrement ST buf count
        u1_del_node = 1;
 }

 if(u4_lt_idx == MAX_REF_BUFS + 1)
 {
 if(u1_del_node)
 {
            ih264d_free_ref_pic_mv_bufs(ps_dpb_mgr->pv_codec_handle,
                                        ps_unmark_node->u1_buf_id);
            ps_unmark_node->ps_prev_short = NULL;
 }
 }
 else
 {
        WORD32 i4_status;
        ret = ih264d_delete_lt_node(ps_dpb_mgr, u4_lt_idx,
                              u1_fld_pic_flag, ps_unmark_node, &i4_status);
 if(ret != OK)
 return ret;
        ret = ih264d_insert_lt_node(ps_dpb_mgr, ps_unmark_node, u4_lt_idx,
                              u1_fld_pic_flag);
 if(ret != OK)
 return ret;
 }
 return OK;
}

WORD32 ih264d_parse_inter_slice_data_cabac(dec_struct_t * ps_dec,
 dec_slice_params_t * ps_slice,
                                           UWORD16 u2_first_mb_in_slice)
{
    UWORD32 uc_more_data_flag;
    WORD32 i2_cur_mb_addr;
    UWORD32 u1_num_mbs, u1_num_mbsNby2, u1_mb_idx;
    UWORD32 u1_mbaff;
    UWORD32 u1_num_mbs_next, u1_end_of_row;
 const UWORD16 i2_pic_wdin_mbs = ps_dec->u2_frm_wd_in_mbs;
    UWORD32 u1_slice_end = 0;
    UWORD32 u1_tfr_n_mb = 0;
    UWORD32 u1_decode_nmb = 0;


 deblk_mb_t *ps_cur_deblk_mb;
 dec_mb_info_t *ps_cur_mb_info;

 parse_pmbarams_t *ps_parse_mb_data = ps_dec->ps_parse_mb_data;
    UWORD32 u1_inter_mb_skip_type;
    UWORD32 u1_inter_mb_type;
    UWORD32 u1_deblk_mb_type;
    UWORD32 u1_mb_threshold;
 dec_bit_stream_t * const ps_bitstrm = ps_dec->ps_bitstrm;
    WORD32 ret = OK;

 /******************************************************/
 /* Initialisations specific to B or P slice           */
 /******************************************************/
 if(ps_slice->u1_slice_type == P_SLICE)
 {
        u1_inter_mb_skip_type = CAB_P_SKIP;
        u1_inter_mb_type = P_MB;
        u1_deblk_mb_type = D_INTER_MB;
        u1_mb_threshold = 5;
 }
 else // B_SLICE
 {
        u1_inter_mb_skip_type = CAB_B_SKIP;
        u1_inter_mb_type = B_MB;
        u1_deblk_mb_type = D_B_SLICE;
        u1_mb_threshold = 23;
 }

 /******************************************************/
 /* Slice Level Initialisations                        */
 /******************************************************/
    i2_cur_mb_addr = u2_first_mb_in_slice;
    ps_dec->u1_qp = ps_slice->u1_slice_qp;
    ih264d_update_qp(ps_dec, 0);
    u1_mb_idx = ps_dec->u1_mb_idx;
    u1_num_mbs = u1_mb_idx;
    u1_num_mbsNby2 = 0;
    u1_mbaff = ps_slice->u1_mbaff_frame_flag;
    i2_cur_mb_addr = u2_first_mb_in_slice << u1_mbaff;
    uc_more_data_flag = 1;

 /* Initialisations specific to cabac */
 if(ps_bitstrm->u4_ofst & 0x07)
 {
        ps_bitstrm->u4_ofst += 8;
        ps_bitstrm->u4_ofst &= 0xFFFFFFF8;
 }

    ret = ih264d_init_cabac_dec_envirnoment(&(ps_dec->s_cab_dec_env), ps_bitstrm);
 if(ret != OK)
 return ret;

    ps_dec->i1_prev_mb_qp_delta = 0;

 while(!u1_slice_end)
 {
        UWORD8 u1_mb_type;
        UWORD32 u4_mb_skip;

        ps_dec->pv_prev_mb_parse_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;

 if(i2_cur_mb_addr > ps_dec->ps_cur_sps->u2_max_mb_addr)
 {
            ret = ERROR_MB_ADDRESS_T;
 break;
 }

        ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs;
        ps_dec->u4_num_mbs_cur_nmb = u1_num_mbs;

        ps_cur_mb_info->u1_Mux = 0;
        ps_dec->u4_num_pmbair = (u1_num_mbs >> u1_mbaff);
        ps_cur_deblk_mb = ps_dec->ps_deblk_mbn + u1_num_mbs;

        ps_cur_mb_info->u1_end_of_slice = 0;

 /* Storing Default partition info */
        ps_parse_mb_data->u1_num_part = 1;
        ps_parse_mb_data->u1_isI_mb = 0;

 /***************************************************************/
 /* Get the required information for decoding of MB             */
 /* mb_x, mb_y , neighbour availablity,                         */
 /***************************************************************/
        u4_mb_skip = ps_dec->pf_get_mb_info(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, 1);

 /*********************************************************************/
 /* initialize u1_tran_form8x8 to zero to aviod uninitialized accesses */
 /*********************************************************************/
        ps_cur_mb_info->u1_tran_form8x8 = 0;
        ps_cur_mb_info->ps_curmb->u1_tran_form8x8 = 0;

 /***************************************************************/
 /* Set the deblocking parameters for this MB                   */
 /***************************************************************/
 if(ps_dec->u4_app_disable_deblk_frm == 0)
            ih264d_set_deblocking_parameters(ps_cur_deblk_mb, ps_slice,
                                             ps_dec->u1_mb_ngbr_availablity,
                                             ps_dec->u1_cur_mb_fld_dec_flag);

 if(u4_mb_skip)
 {

 /* Set appropriate flags in ps_cur_mb_info and ps_dec */
            memset(ps_dec->ps_curr_ctxt_mb_info, 0, sizeof(ctxt_inc_mb_info_t));
            ps_dec->ps_curr_ctxt_mb_info->u1_mb_type = u1_inter_mb_skip_type;

            MEMSET_16BYTES(&ps_dec->pu1_left_mv_ctxt_inc[0][0], 0);

 *((UWORD32 *)ps_dec->pi1_left_ref_idx_ctxt_inc) = 0;
 *(ps_dec->pu1_left_yuv_dc_csbp) = 0;

            ps_dec->i1_prev_mb_qp_delta = 0;
            ps_cur_mb_info->u1_mb_type = MB_SKIP;
            ps_cur_mb_info->u1_cbp = 0;

 {
 /* Storing Skip partition info */
 parse_part_params_t *ps_part_info = ps_dec->ps_part;
                ps_part_info->u1_is_direct = PART_DIRECT_16x16;
                ps_part_info->u1_sub_mb_num = 0;
                ps_dec->ps_part++;
 }

 /* Update Nnzs */
            ih264d_update_nnz_for_skipmb(ps_dec, ps_cur_mb_info, CABAC);

            ps_cur_mb_info->ps_curmb->u1_mb_type = u1_inter_mb_type;
            ps_cur_deblk_mb->u1_mb_type |= u1_deblk_mb_type;
            ps_cur_deblk_mb->u1_mb_qp = ps_dec->u1_qp;

 }
 else
 {

 /* Macroblock Layer Begins */
 /* Decode the u1_mb_type */
            u1_mb_type = ih264d_parse_mb_type_cabac(ps_dec);
            ps_cur_mb_info->u1_mb_type = u1_mb_type;
 if(u1_mb_type > (25 + u1_mb_threshold))
 return ERROR_MB_TYPE;

 /* Parse Macroblock Data */
 if(u1_mb_type < u1_mb_threshold)
 {
                ps_cur_mb_info->ps_curmb->u1_mb_type = u1_inter_mb_type;
 *(ps_dec->pu1_left_yuv_dc_csbp) &= 0x6;

                ret = ps_dec->pf_parse_inter_mb(ps_dec, ps_cur_mb_info, u1_num_mbs,
                                          u1_num_mbsNby2);
 if(ret != OK)
 return ret;
                ps_cur_deblk_mb->u1_mb_qp = ps_dec->u1_qp;
                ps_cur_deblk_mb->u1_mb_type |= u1_deblk_mb_type;
 }
 else
 {
 /* Storing Intra partition info */
                ps_parse_mb_data->u1_num_part = 0;
                ps_parse_mb_data->u1_isI_mb = 1;

 if((25 + u1_mb_threshold) == u1_mb_type)
 {
 /* I_PCM_MB */
                    ps_cur_mb_info->ps_curmb->u1_mb_type = I_PCM_MB;
                    ret = ih264d_parse_ipcm_mb(ps_dec, ps_cur_mb_info, u1_num_mbs);
 if(ret != OK)
 return ret;
                    ps_cur_deblk_mb->u1_mb_qp = 0;
 }
 else
 {
 if(u1_mb_type == u1_mb_threshold)
                        ps_cur_mb_info->ps_curmb->u1_mb_type = I_4x4_MB;
 else
                        ps_cur_mb_info->ps_curmb->u1_mb_type = I_16x16_MB;

                    ret = ih264d_parse_imb_cabac(
                                    ps_dec, ps_cur_mb_info,
 (UWORD8)(u1_mb_type - u1_mb_threshold));
 if(ret != OK)
 return ret;
                    ps_cur_deblk_mb->u1_mb_qp = ps_dec->u1_qp;
 }
                ps_cur_deblk_mb->u1_mb_type |= D_INTRA_MB;

 }

 }

 if(u1_mbaff)
 {
            ih264d_update_mbaff_left_nnz(ps_dec, ps_cur_mb_info);
 }
 /* Next macroblock information */
        i2_cur_mb_addr++;

 if(ps_cur_mb_info->u1_topmb && u1_mbaff)
            uc_more_data_flag = 1;
 else
 {
            uc_more_data_flag = ih264d_decode_terminate(&ps_dec->s_cab_dec_env,
                                                      ps_bitstrm);
            uc_more_data_flag = !uc_more_data_flag;
            COPYTHECONTEXT("Decode Sliceterm",!uc_more_data_flag);
 }

        u1_num_mbs++;
        u1_num_mbsNby2++;
        ps_parse_mb_data++;

 /****************************************************************/
 /* Check for End Of Row and other flags that determine when to  */
 /* do DMA setup for N/2-Mb, Decode for N-Mb, and Transfer for   */
 /* N-Mb                                                         */
 /****************************************************************/
        u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;
        u1_end_of_row = (!u1_num_mbs_next) && (!(u1_mbaff && (u1_num_mbs & 0x01)));
        u1_slice_end = !uc_more_data_flag;
        u1_tfr_n_mb = (u1_num_mbs == ps_dec->u1_recon_mb_grp) || u1_end_of_row
 || u1_slice_end;
        u1_decode_nmb = u1_tfr_n_mb || u1_slice_end;
        ps_cur_mb_info->u1_end_of_slice = u1_slice_end;
 /*u1_dma_nby2mb   = u1_decode_nmb ||
         (u1_num_mbsNby2 == ps_dec->u1_recon_mb_grp_pair);*/

 if(u1_decode_nmb)
 {

            ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx, u1_num_mbs);
            u1_num_mbsNby2 = 0;

 {
                ps_parse_mb_data = ps_dec->ps_parse_mb_data;
                ps_dec->ps_part = ps_dec->ps_parse_part_params;
 }
 }

 /*H264_DEC_DEBUG_PRINT("Pic: %d Mb_X=%d Mb_Y=%d",
         ps_slice->i4_poc >> ps_slice->u1_field_pic_flag,
         ps_dec->u2_mbx,ps_dec->u2_mby + (1 - ps_cur_mb_info->u1_topmb));
         H264_DEC_DEBUG_PRINT("u1_decode_nmb: %d, u1_num_mbs: %d", u1_decode_nmb, u1_num_mbs);*/
 if(u1_decode_nmb)
 {

 if(ps_dec->u1_separate_parse)
 {
                ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,
                                     u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);
                ps_dec->ps_nmb_info +=  u1_num_mbs;
 }
 else
 {
                ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,
                                            u1_num_mbs_next, u1_tfr_n_mb,
                                            u1_end_of_row);
 }
            ps_dec->u2_total_mbs_coded += u1_num_mbs;
 if(u1_tfr_n_mb)
                u1_num_mbs = 0;
            u1_mb_idx = u1_num_mbs;
            ps_dec->u1_mb_idx = u1_num_mbs;

 }
 }


    ps_dec->u4_num_mbs_cur_nmb = 0;
    ps_dec->ps_cur_slice->u4_mbs_in_slice = i2_cur_mb_addr

 - (u2_first_mb_in_slice << u1_mbaff);

 return ret;
}

WORD32 ih264d_parse_pslice(dec_struct_t *ps_dec, UWORD16 u2_first_mb_in_slice)
{
dec_pic_params_t * ps_pps = ps_dec->ps_cur_pps;
dec_slice_params_t * ps_cur_slice = ps_dec->ps_cur_slice;
dec_bit_stream_t *ps_bitstrm = ps_dec->ps_bitstrm;
UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;
UWORD8 u1_mbaff = ps_dec->ps_cur_slice->u1_mbaff_frame_flag; //ps_dec->ps_cur_sps->u1_mb_aff_flag;
UWORD8 u1_field_pic_flag = ps_cur_slice->u1_field_pic_flag;

UWORD32 u4_temp;
WORD32 i_temp;
WORD32 ret;

/*--------------------------------------------------------------------*/
/* Read remaining contents of the slice header                        */
/*--------------------------------------------------------------------*/
{
WORD8 *pi1_buf;
WORD16 *pi2_mv = ps_dec->s_default_mv_pred.i2_mv;
WORD32 *pi4_mv = (WORD32*)pi2_mv;
WORD16 *pi16_refFrame;

pi1_buf = ps_dec->s_default_mv_pred.i1_ref_frame;
pi16_refFrame = (WORD16*)pi1_buf;
*pi4_mv = 0;
*(pi4_mv + 1) = 0;
*pi16_refFrame = OUT_OF_RANGE_REF;
ps_dec->s_default_mv_pred.u1_col_ref_pic_idx = (UWORD8)-1;
ps_dec->s_default_mv_pred.u1_pic_type = (UWORD8)-1;
}

ps_cur_slice->u1_num_ref_idx_active_override_flag = ih264d_get_bit_h264(
ps_bitstrm);

COPYTHECONTEXT("SH: num_ref_idx_override_flag",
ps_cur_slice->u1_num_ref_idx_active_override_flag);

u4_temp = ps_dec->ps_cur_pps->u1_num_ref_idx_lx_active[0];
if(ps_cur_slice->u1_num_ref_idx_active_override_flag)
{
u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf) + 1;
}

{



UWORD8 u1_max_ref_idx = MAX_FRAMES << u1_field_pic_flag;
if(u4_temp > u1_max_ref_idx)
{
return ERROR_NUM_REF;
}
ps_cur_slice->u1_num_ref_idx_lx_active[0] = u4_temp;
COPYTHECONTEXT("SH: num_ref_idx_l0_active_minus1",
ps_cur_slice->u1_num_ref_idx_lx_active[0] - 1);

}

{
UWORD8 uc_refIdxReFlagL0 = ih264d_get_bit_h264(ps_bitstrm);
COPYTHECONTEXT("SH: ref_pic_list_reordering_flag_l0",uc_refIdxReFlagL0);

/* Initialize the Reference list once in Picture if the slice type    */
/* of first slice is between 5 to 9 defined in table 7.3 of standard  */
/* If picture contains both P & B slices then Initialize the Reference*/
/* List only when it switches from P to B and B to P                     */
{
UWORD8 init_idx_flg = (ps_dec->u1_pr_sl_type
!= ps_dec->ps_cur_slice->u1_slice_type);
if(ps_dec->u1_first_pb_nal_in_pic
|| (init_idx_flg & !ps_dec->u1_sl_typ_5_9)
|| ps_dec->u1_num_ref_idx_lx_active_prev
!= ps_cur_slice->u1_num_ref_idx_lx_active[0])
{
ih264d_init_ref_idx_lx_p(ps_dec);
}
if(ps_dec->u1_first_pb_nal_in_pic & ps_dec->u1_sl_typ_5_9)
ps_dec->u1_first_pb_nal_in_pic = 0;
}
/* Store the value for future slices in the same picture */
ps_dec->u1_num_ref_idx_lx_active_prev =
ps_cur_slice->u1_num_ref_idx_lx_active[0];

/* Modified temporarily */
if(uc_refIdxReFlagL0)
{
WORD8 ret;
ps_dec->ps_ref_pic_buf_lx[0] = ps_dec->ps_dpb_mgr->ps_mod_dpb[0];
ret = ih264d_ref_idx_reordering(ps_dec, 0);
if(ret == -1)
return ERROR_REFIDX_ORDER_T;
ps_dec->ps_ref_pic_buf_lx[0] = ps_dec->ps_dpb_mgr->ps_mod_dpb[0];
}
else
ps_dec->ps_ref_pic_buf_lx[0] =
ps_dec->ps_dpb_mgr->ps_init_dpb[0];
}
/* Create refIdx to POC mapping */
{
void **pui_map_ref_idx_to_poc_lx0, **pui_map_ref_idx_to_poc_lx1;
WORD8 idx;
struct pic_buffer_t *ps_pic;

pui_map_ref_idx_to_poc_lx0 = ps_dec->ppv_map_ref_idx_to_poc + FRM_LIST_L0;
pui_map_ref_idx_to_poc_lx0[0] = 0; //For ref_idx = -1
pui_map_ref_idx_to_poc_lx0++;
for(idx = 0; idx < ps_cur_slice->u1_num_ref_idx_lx_active[0]; idx++)
{
ps_pic = ps_dec->ps_ref_pic_buf_lx[0][idx];
pui_map_ref_idx_to_poc_lx0[idx] = (ps_pic->pu1_buf1);
}

/* Bug Fix Deblocking */
pui_map_ref_idx_to_poc_lx1 = ps_dec->ppv_map_ref_idx_to_poc + FRM_LIST_L1;
pui_map_ref_idx_to_poc_lx1[0] = 0;

if(u1_mbaff)
{
void **ppv_map_ref_idx_to_poc_lx_t, **ppv_map_ref_idx_to_poc_lx_b;
void **ppv_map_ref_idx_to_poc_lx_t1, **ppv_map_ref_idx_to_poc_lx_b1;
ppv_map_ref_idx_to_poc_lx_t = ps_dec->ppv_map_ref_idx_to_poc
+ TOP_LIST_FLD_L0;
ppv_map_ref_idx_to_poc_lx_b = ps_dec->ppv_map_ref_idx_to_poc
+ BOT_LIST_FLD_L0;

ppv_map_ref_idx_to_poc_lx_t[0] = 0; //  For ref_idx = -1
ppv_map_ref_idx_to_poc_lx_t++;
ppv_map_ref_idx_to_poc_lx_b[0] = 0; // For ref_idx = -1
ppv_map_ref_idx_to_poc_lx_b++;

idx = 0;
for(idx = 0; idx < ps_cur_slice->u1_num_ref_idx_lx_active[0]; idx++)
{
ps_pic = ps_dec->ps_ref_pic_buf_lx[0][idx];
ppv_map_ref_idx_to_poc_lx_t[0] = (ps_pic->pu1_buf1);
ppv_map_ref_idx_to_poc_lx_b[1] = (ps_pic->pu1_buf1);

ppv_map_ref_idx_to_poc_lx_b[0] = (ps_pic->pu1_buf1) + 1;
ppv_map_ref_idx_to_poc_lx_t[1] = (ps_pic->pu1_buf1) + 1;

ppv_map_ref_idx_to_poc_lx_t += 2;
ppv_map_ref_idx_to_poc_lx_b += 2;
}
ppv_map_ref_idx_to_poc_lx_t1 = ps_dec->ppv_map_ref_idx_to_poc
+ TOP_LIST_FLD_L1;
ppv_map_ref_idx_to_poc_lx_t1[0] = 0;
ppv_map_ref_idx_to_poc_lx_b1 = ps_dec->ppv_map_ref_idx_to_poc
+ BOT_LIST_FLD_L1;
ppv_map_ref_idx_to_poc_lx_b1[0] = 0;

}

if(ps_dec->u4_num_cores >= 3)
{
WORD32 num_entries;
WORD32 size;

num_entries = MIN(MAX_FRAMES, ps_dec->u4_num_ref_frames_at_init);
num_entries = 2 * ((2 * num_entries) + 1);

size = num_entries * sizeof(void *);
size += PAD_MAP_IDX_POC * sizeof(void *);

memcpy((void *)ps_dec->ps_parse_cur_slice->ppv_map_ref_idx_to_poc,
ps_dec->ppv_map_ref_idx_to_poc,
size);
}


}
if(ps_pps->u1_wted_pred_flag)
{
ret = ih264d_parse_pred_weight_table(ps_cur_slice, ps_bitstrm);
if(ret != OK)
return ret;
ih264d_form_pred_weight_matrix(ps_dec);
ps_dec->pu4_wt_ofsts = ps_dec->pu4_wts_ofsts_mat;
}
else
{
ps_dec->ps_cur_slice->u2_log2Y_crwd = 0;
ps_dec->pu4_wt_ofsts = ps_dec->pu4_wts_ofsts_mat;
}

ps_dec->ps_parse_cur_slice->u2_log2Y_crwd =
ps_dec->ps_cur_slice->u2_log2Y_crwd;

if(u1_mbaff && (u1_field_pic_flag == 0))
{
ih264d_convert_frm_mbaff_list(ps_dec);
}

/* G050 */

if(ps_cur_slice->u1_nal_ref_idc != 0)
{
if(!ps_dec->ps_dpb_cmds->u1_dpb_commands_read)
            ps_dec->u4_bitoffset = ih264d_read_mmco_commands(ps_dec);
else
ps_bitstrm->u4_ofst += ps_dec->u4_bitoffset;

}
/* G050 */

if(ps_pps->u1_entropy_coding_mode == CABAC)
{
u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);

if(u4_temp > MAX_CABAC_INIT_IDC)
{
return ERROR_INV_SLICE_HDR_T;
}
ps_cur_slice->u1_cabac_init_idc = u4_temp;
COPYTHECONTEXT("SH: cabac_init_idc",ps_cur_slice->u1_cabac_init_idc);
}

/* Read slice_qp_delta */
i_temp = ps_pps->u1_pic_init_qp
+ ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
if((i_temp < 0) || (i_temp > 51))
{
return ERROR_INV_RANGE_QP_T;
}
ps_cur_slice->u1_slice_qp = i_temp;
COPYTHECONTEXT("SH: slice_qp_delta",
(WORD8)(ps_cur_slice->u1_slice_qp - ps_pps->u1_pic_init_qp));

if(ps_pps->u1_deblocking_filter_parameters_present_flag == 1)
{
u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
if(u4_temp > SLICE_BOUNDARY_DBLK_DISABLED)
{
return ERROR_INV_SLICE_HDR_T;
}

COPYTHECONTEXT("SH: disable_deblocking_filter_idc", u4_temp);
ps_cur_slice->u1_disable_dblk_filter_idc = u4_temp;
if(u4_temp != 1)
{
i_temp = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf)
<< 1;
if((MIN_DBLK_FIL_OFF > i_temp) || (i_temp > MAX_DBLK_FIL_OFF))
{
return ERROR_INV_SLICE_HDR_T;
}
ps_cur_slice->i1_slice_alpha_c0_offset = i_temp;
COPYTHECONTEXT("SH: slice_alpha_c0_offset_div2",
ps_cur_slice->i1_slice_alpha_c0_offset >> 1);

i_temp = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf)
<< 1;
if((MIN_DBLK_FIL_OFF > i_temp) || (i_temp > MAX_DBLK_FIL_OFF))
{
return ERROR_INV_SLICE_HDR_T;
}
ps_cur_slice->i1_slice_beta_offset = i_temp;
COPYTHECONTEXT("SH: slice_beta_offset_div2",
ps_cur_slice->i1_slice_beta_offset >> 1);
}
else
{
ps_cur_slice->i1_slice_alpha_c0_offset = 0;
ps_cur_slice->i1_slice_beta_offset = 0;
}
}
else
{
ps_cur_slice->u1_disable_dblk_filter_idc = 0;
ps_cur_slice->i1_slice_alpha_c0_offset = 0;
ps_cur_slice->i1_slice_beta_offset = 0;
}

ps_dec->u1_slice_header_done = 2;

if(ps_pps->u1_entropy_coding_mode)
{
SWITCHOFFTRACE; SWITCHONTRACECABAC;
ps_dec->pf_parse_inter_slice = ih264d_parse_inter_slice_data_cabac;
ps_dec->pf_parse_inter_mb = ih264d_parse_pmb_cabac;
ih264d_init_cabac_contexts(P_SLICE, ps_dec);

if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag)
ps_dec->pf_get_mb_info = ih264d_get_mb_info_cabac_mbaff;
else
ps_dec->pf_get_mb_info = ih264d_get_mb_info_cabac_nonmbaff;
}
else
{
SWITCHONTRACE; SWITCHOFFTRACECABAC;
ps_dec->pf_parse_inter_slice = ih264d_parse_inter_slice_data_cavlc;
ps_dec->pf_parse_inter_mb = ih264d_parse_pmb_cavlc;
if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag)
{
ps_dec->pf_get_mb_info = ih264d_get_mb_info_cavlc_mbaff;
}
else
ps_dec->pf_get_mb_info = ih264d_get_mb_info_cavlc_nonmbaff;
}

ps_dec->u1_B = 0;
ps_dec->pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb;
ret = ps_dec->pf_parse_inter_slice(ps_dec, ps_cur_slice, u2_first_mb_in_slice);
if(ret != OK)
return ret;
//    ps_dec->curr_slice_in_error = 0 ;
return OK;
}

WORD32 ih264d_delete_gap_frm_mmco(dpb_manager_t *ps_dpb_mgr,
                                  WORD32 i4_frame_num,
                                  UWORD8 *pu1_del_node)
{
    WORD8 i, j;
    WORD32 *pi4_start, *pi4_end;
    WORD32 i4_start_frm_num, i4_end_frm_num, i4_max_frm_num;

 /* find the least frame num from gaps and current DPB node    */
 /* Delete the gaps                                            */
 *pu1_del_node = 1;
    pi4_start = ps_dpb_mgr->ai4_gaps_start_frm_num;
    pi4_end = ps_dpb_mgr->ai4_gaps_end_frm_num;
    i4_max_frm_num = ps_dpb_mgr->i4_max_frm_num;

 if(0 == ps_dpb_mgr->u1_num_gaps)
 return OK;

 if(i4_frame_num < 0)
        i4_frame_num += i4_max_frm_num;
 for(i = 0; i < MAX_FRAMES; i++)
 {
        i4_start_frm_num = pi4_start[i];
 if(i4_start_frm_num < 0)
            i4_start_frm_num += i4_max_frm_num;
 if(INVALID_FRAME_NUM != i4_start_frm_num)
 {
            i4_end_frm_num = pi4_end[i];
 if(i4_end_frm_num < 0)
                i4_end_frm_num += i4_max_frm_num;

 if((i4_frame_num >= i4_start_frm_num)
 && (i4_frame_num <= i4_end_frm_num))
 {
 break;
 }
 else
 {
 if(((i4_frame_num + i4_max_frm_num) >= i4_start_frm_num)
 && ((i4_frame_num + i4_max_frm_num)
 <= i4_end_frm_num))
 {
                    UWORD32 i4_error_code;
                    i4_error_code = ERROR_DBP_MANAGER_T;
 return i4_error_code;
 }
 }
 }
 }

 /* find frame_num index, in the poc_map which needs to be deleted */
 for(j = 0; j < MAX_FRAMES; j++)
 {
 if(i4_frame_num == ps_dpb_mgr->ai4_poc_buf_id_map[j][2])
 break;
 }

 if(MAX_FRAMES != i)
 {
 if(j == MAX_FRAMES)
 {
            UWORD32 i4_error_code;
            i4_error_code = ERROR_DBP_MANAGER_T;
 return i4_error_code;
 }

        ps_dpb_mgr->ai4_poc_buf_id_map[j][0] = -1;
        ps_dpb_mgr->ai4_poc_buf_id_map[j][1] = 0x7fffffff;
        ps_dpb_mgr->ai4_poc_buf_id_map[j][2] = GAP_FRAME_NUM;
        ps_dpb_mgr->i1_gaps_deleted++;

        ps_dpb_mgr->ai1_gaps_per_seq[i]--;
        ps_dpb_mgr->u1_num_gaps--;
 *pu1_del_node = 0;
 if(0 == ps_dpb_mgr->ai1_gaps_per_seq[i])
 {
            ps_dpb_mgr->ai4_gaps_start_frm_num[i] = INVALID_FRAME_NUM;
            ps_dpb_mgr->ai4_gaps_end_frm_num[i] = 0;
 }
 }
 else
 {
        UWORD32 i4_error_code;
        i4_error_code = ERROR_DBP_MANAGER_T;
 return i4_error_code;
 }

 return OK;
}

WORD32 ih264d_parse_bslice(dec_struct_t * ps_dec, UWORD16 u2_first_mb_in_slice)
{
dec_pic_params_t * ps_pps = ps_dec->ps_cur_pps;
dec_slice_params_t * ps_slice = ps_dec->ps_cur_slice;
dec_bit_stream_t * ps_bitstrm = ps_dec->ps_bitstrm;
UWORD8 u1_ref_idx_re_flag_lx;
UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;

UWORD32 u4_temp, ui_temp1;
WORD32 i_temp;
WORD32 ret;

/*--------------------------------------------------------------------*/
/* Read remaining contents of the slice header                        */
/*--------------------------------------------------------------------*/
{
WORD8 *pi1_buf;
WORD16 *pi2_mv = ps_dec->s_default_mv_pred.i2_mv;
WORD32 *pi4_mv = (WORD32*)pi2_mv;
WORD16 *pi16_refFrame;
pi1_buf = ps_dec->s_default_mv_pred.i1_ref_frame;
pi16_refFrame = (WORD16*)pi1_buf;
*pi4_mv = 0;
*(pi4_mv + 1) = 0;
*pi16_refFrame = OUT_OF_RANGE_REF;
ps_dec->s_default_mv_pred.u1_col_ref_pic_idx = (UWORD8)-1;
ps_dec->s_default_mv_pred.u1_pic_type = (UWORD8)-1;
}

ps_slice->u1_num_ref_idx_active_override_flag = ih264d_get_bit_h264(
ps_bitstrm);
COPYTHECONTEXT("SH: num_ref_idx_override_flag",
ps_slice->u1_num_ref_idx_active_override_flag);

u4_temp = ps_dec->ps_cur_pps->u1_num_ref_idx_lx_active[0];
ui_temp1 = ps_dec->ps_cur_pps->u1_num_ref_idx_lx_active[1];
if(ps_slice->u1_num_ref_idx_active_override_flag)
{
u4_temp = 1 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
COPYTHECONTEXT("SH: num_ref_idx_l0_active_minus1",
u4_temp - 1);
ui_temp1 = 1 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
COPYTHECONTEXT("SH: num_ref_idx_l1_active_minus1",
ui_temp1 - 1);
}

{
UWORD8 u1_max_ref_idx = MAX_FRAMES;
if(ps_slice->u1_field_pic_flag)
{
u1_max_ref_idx = MAX_FRAMES << 1;
}
if((u4_temp > u1_max_ref_idx) || (ui_temp1 > u1_max_ref_idx))
{
return ERROR_NUM_REF;
}
ps_slice->u1_num_ref_idx_lx_active[0] = u4_temp;
ps_slice->u1_num_ref_idx_lx_active[1] = ui_temp1;
}
/* Initialize the Reference list once in Picture if the slice type    */
/* of first slice is between 5 to 9 defined in table 7.3 of standard  */
/* If picture contains both P & B slices then Initialize the Reference*/
/* List only when it switches from P to B and B to P                     */

{
UWORD8 init_idx_flg = (ps_dec->u1_pr_sl_type
!= ps_dec->ps_cur_slice->u1_slice_type);
if(ps_dec->u1_first_pb_nal_in_pic
|| (init_idx_flg & !ps_dec->u1_sl_typ_5_9)
|| ps_dec->u1_num_ref_idx_lx_active_prev
!= ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[0])
ih264d_init_ref_idx_lx_b(ps_dec);
if(ps_dec->u1_first_pb_nal_in_pic & ps_dec->u1_sl_typ_5_9)
ps_dec->u1_first_pb_nal_in_pic = 0;
}
/* Store the value for future slices in the same picture */
ps_dec->u1_num_ref_idx_lx_active_prev =
ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[0];

u1_ref_idx_re_flag_lx = ih264d_get_bit_h264(ps_bitstrm);
COPYTHECONTEXT("SH: ref_pic_list_reordering_flag_l0",u1_ref_idx_re_flag_lx);

/* Modified temporarily */
if(u1_ref_idx_re_flag_lx)
{
WORD8 ret;
ps_dec->ps_ref_pic_buf_lx[0] = ps_dec->ps_dpb_mgr->ps_mod_dpb[0];
ret = ih264d_ref_idx_reordering(ps_dec, 0);
if(ret == -1)
return ERROR_REFIDX_ORDER_T;
}
else
ps_dec->ps_ref_pic_buf_lx[0] = ps_dec->ps_dpb_mgr->ps_init_dpb[0];

u1_ref_idx_re_flag_lx = ih264d_get_bit_h264(ps_bitstrm);
COPYTHECONTEXT("SH: ref_pic_list_reordering_flag_l1",u1_ref_idx_re_flag_lx);

/* Modified temporarily */
if(u1_ref_idx_re_flag_lx)
{
WORD8 ret;
ps_dec->ps_ref_pic_buf_lx[1] = ps_dec->ps_dpb_mgr->ps_mod_dpb[1];
ret = ih264d_ref_idx_reordering(ps_dec, 1);
if(ret == -1)
return ERROR_REFIDX_ORDER_T;
}
else
ps_dec->ps_ref_pic_buf_lx[1] = ps_dec->ps_dpb_mgr->ps_init_dpb[1];

/* Create refIdx to POC mapping */
{
void **ppv_map_ref_idx_to_poc_lx;
WORD8 idx;
struct pic_buffer_t *ps_pic;

ppv_map_ref_idx_to_poc_lx = ps_dec->ppv_map_ref_idx_to_poc + FRM_LIST_L0;
ppv_map_ref_idx_to_poc_lx[0] = 0;
ppv_map_ref_idx_to_poc_lx++;
for(idx = 0; idx < ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[0];
idx++)
{
ps_pic = ps_dec->ps_ref_pic_buf_lx[0][idx];
ppv_map_ref_idx_to_poc_lx[idx] = (ps_pic->pu1_buf1);
}

ppv_map_ref_idx_to_poc_lx = ps_dec->ppv_map_ref_idx_to_poc + FRM_LIST_L1;

ppv_map_ref_idx_to_poc_lx[0] = 0;
ppv_map_ref_idx_to_poc_lx++;
for(idx = 0; idx < ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[1];
idx++)
{
ps_pic = ps_dec->ps_ref_pic_buf_lx[1][idx];
ppv_map_ref_idx_to_poc_lx[idx] = (ps_pic->pu1_buf1);
}

if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag)
{
void **ppv_map_ref_idx_to_poc_lx_t, **ppv_map_ref_idx_to_poc_lx_b;

ppv_map_ref_idx_to_poc_lx_t = ps_dec->ppv_map_ref_idx_to_poc
+ TOP_LIST_FLD_L0;
ppv_map_ref_idx_to_poc_lx_b = ps_dec->ppv_map_ref_idx_to_poc
+ BOT_LIST_FLD_L0;

ppv_map_ref_idx_to_poc_lx_t[0] = 0;
ppv_map_ref_idx_to_poc_lx_t++;
ppv_map_ref_idx_to_poc_lx_b[0] = 0;
ppv_map_ref_idx_to_poc_lx_b++;
for(idx = 0; idx < ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[0];
idx++)
{
ps_pic = ps_dec->ps_ref_pic_buf_lx[0][idx];
ppv_map_ref_idx_to_poc_lx_t[0] = (ps_pic->pu1_buf1);
ppv_map_ref_idx_to_poc_lx_b[1] = (ps_pic->pu1_buf1);

ppv_map_ref_idx_to_poc_lx_b[0] = (ps_pic->pu1_buf1) + 1;
ppv_map_ref_idx_to_poc_lx_t[1] = (ps_pic->pu1_buf1) + 1;

ppv_map_ref_idx_to_poc_lx_t += 2;
ppv_map_ref_idx_to_poc_lx_b += 2;
}

ppv_map_ref_idx_to_poc_lx_t = ps_dec->ppv_map_ref_idx_to_poc
+ TOP_LIST_FLD_L1;
ppv_map_ref_idx_to_poc_lx_b = ps_dec->ppv_map_ref_idx_to_poc
+ BOT_LIST_FLD_L1;

ppv_map_ref_idx_to_poc_lx_t[0] = 0;
ppv_map_ref_idx_to_poc_lx_t++;
ppv_map_ref_idx_to_poc_lx_b[0] = 0;
ppv_map_ref_idx_to_poc_lx_b++;
for(idx = 0; idx < ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[1];
idx++)
{
UWORD8 u1_tmp_idx = idx << 1;
ps_pic = ps_dec->ps_ref_pic_buf_lx[1][idx];
ppv_map_ref_idx_to_poc_lx_t[u1_tmp_idx] = (ps_pic->pu1_buf1);
ppv_map_ref_idx_to_poc_lx_b[u1_tmp_idx + 1] = (ps_pic->pu1_buf1);

ppv_map_ref_idx_to_poc_lx_b[u1_tmp_idx] = (ps_pic->pu1_buf1) + 1;
ppv_map_ref_idx_to_poc_lx_t[u1_tmp_idx + 1] = (ps_pic->pu1_buf1) + 1;

}
}

if(ps_dec->u4_num_cores >= 3)
{
WORD32 num_entries;
WORD32 size;

num_entries = MIN(MAX_FRAMES, ps_dec->u4_num_ref_frames_at_init);
num_entries = 2 * ((2 * num_entries) + 1);

size = num_entries * sizeof(void *);
size += PAD_MAP_IDX_POC * sizeof(void *);

memcpy((void *)ps_dec->ps_parse_cur_slice->ppv_map_ref_idx_to_poc,
ps_dec->ppv_map_ref_idx_to_poc,
size);
}

}

if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag
&& (ps_dec->ps_cur_slice->u1_field_pic_flag == 0))
{
ih264d_convert_frm_mbaff_list(ps_dec);
}

if(ps_pps->u1_wted_bipred_idc == 1)
{
ret = ih264d_parse_pred_weight_table(ps_slice, ps_bitstrm);
if(ret != OK)
return ret;
ih264d_form_pred_weight_matrix(ps_dec);
ps_dec->pu4_wt_ofsts = ps_dec->pu4_wts_ofsts_mat;
}
else if(ps_pps->u1_wted_bipred_idc == 2)
{
/* Implicit Weighted prediction */
ps_slice->u2_log2Y_crwd = 0x0505;
ps_dec->pu4_wt_ofsts = ps_dec->pu4_wts_ofsts_mat;
ih264d_get_implicit_weights(ps_dec);
}
else
ps_dec->ps_cur_slice->u2_log2Y_crwd = 0;

ps_dec->ps_parse_cur_slice->u2_log2Y_crwd =
ps_dec->ps_cur_slice->u2_log2Y_crwd;

/* G050 */

if(ps_slice->u1_nal_ref_idc != 0)
{
if(!ps_dec->ps_dpb_cmds->u1_dpb_commands_read)
            ps_dec->u4_bitoffset = ih264d_read_mmco_commands(ps_dec);
else
ps_bitstrm->u4_ofst += ps_dec->u4_bitoffset;
}
/* G050 */

if(ps_pps->u1_entropy_coding_mode == CABAC)
{
u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
if(u4_temp > MAX_CABAC_INIT_IDC)
{
return ERROR_INV_SLICE_HDR_T;
}
ps_slice->u1_cabac_init_idc = u4_temp;
COPYTHECONTEXT("SH: cabac_init_idc",ps_slice->u1_cabac_init_idc);
}

/* Read slice_qp_delta */
i_temp = ps_pps->u1_pic_init_qp
+ ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
if((i_temp < 0) || (i_temp > 51))
{
return ERROR_INV_RANGE_QP_T;
}
ps_slice->u1_slice_qp = i_temp;
COPYTHECONTEXT("SH: slice_qp_delta",
(WORD8)(ps_slice->u1_slice_qp - ps_pps->u1_pic_init_qp));

if(ps_pps->u1_deblocking_filter_parameters_present_flag == 1)
{
u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
if(u4_temp > SLICE_BOUNDARY_DBLK_DISABLED)
{
return ERROR_INV_SLICE_HDR_T;
} COPYTHECONTEXT("SH: disable_deblocking_filter_idc", u4_temp);
ps_slice->u1_disable_dblk_filter_idc = u4_temp;
if(u4_temp != 1)
{
i_temp = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf)
<< 1;
if((MIN_DBLK_FIL_OFF > i_temp) || (i_temp > MAX_DBLK_FIL_OFF))
{
return ERROR_INV_SLICE_HDR_T;
}
ps_slice->i1_slice_alpha_c0_offset = i_temp;
COPYTHECONTEXT("SH: slice_alpha_c0_offset_div2",
ps_slice->i1_slice_alpha_c0_offset >> 1);

i_temp = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf)
<< 1;
if((MIN_DBLK_FIL_OFF > i_temp) || (i_temp > MAX_DBLK_FIL_OFF))
{
return ERROR_INV_SLICE_HDR_T;
}
ps_slice->i1_slice_beta_offset = i_temp;
COPYTHECONTEXT("SH: slice_beta_offset_div2",
ps_slice->i1_slice_beta_offset >> 1);

}
else
{
ps_slice->i1_slice_alpha_c0_offset = 0;
ps_slice->i1_slice_beta_offset = 0;
}
}
else
{
ps_slice->u1_disable_dblk_filter_idc = 0;
ps_slice->i1_slice_alpha_c0_offset = 0;
ps_slice->i1_slice_beta_offset = 0;
}

ps_dec->u1_slice_header_done = 2;

if(ps_pps->u1_entropy_coding_mode)
{
SWITCHOFFTRACE; SWITCHONTRACECABAC;
ps_dec->pf_parse_inter_slice = ih264d_parse_inter_slice_data_cabac;
ps_dec->pf_parse_inter_mb = ih264d_parse_bmb_cabac;
ih264d_init_cabac_contexts(B_SLICE, ps_dec);

if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag)
ps_dec->pf_get_mb_info = ih264d_get_mb_info_cabac_mbaff;
else
ps_dec->pf_get_mb_info = ih264d_get_mb_info_cabac_nonmbaff;
}
else
{
SWITCHONTRACE; SWITCHOFFTRACECABAC;
ps_dec->pf_parse_inter_slice = ih264d_parse_inter_slice_data_cavlc;
ps_dec->pf_parse_inter_mb = ih264d_parse_bmb_cavlc;
if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag)
ps_dec->pf_get_mb_info = ih264d_get_mb_info_cavlc_mbaff;
else
ps_dec->pf_get_mb_info = ih264d_get_mb_info_cavlc_nonmbaff;
}

ret = ih264d_cal_col_pic(ps_dec);
if(ret != OK)
return ret;
ps_dec->u1_B = 1;
ps_dec->pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_bmb;
ret = ps_dec->pf_parse_inter_slice(ps_dec, ps_slice, u2_first_mb_in_slice);
if(ret != OK)
return ret;
return OK;
}

void ih264d_get_implicit_weights(dec_struct_t *ps_dec)
{
    UWORD32 *pu4_iwt_ofst;
    UWORD8 i, j;
 struct pic_buffer_t *ps_pic_buff0, *ps_pic_buff1;
    WORD16 i2_dist_scale_factor;
    WORD16 i16_tb, i16_td, i16_tx;
    UWORD32 u4_poc0, u4_poc1;
    UWORD32 ui_temp0, ui_temp1;
    UWORD8 uc_num_ref_idx_l0_active, uc_num_ref_idx_l1_active;

    pu4_iwt_ofst = ps_dec->pu4_wts_ofsts_mat;
    uc_num_ref_idx_l0_active =
                    ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[0];
    uc_num_ref_idx_l1_active =
                    ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[1];

 for(i = 0; i < uc_num_ref_idx_l0_active; i++)
 {
        ps_pic_buff0 = ps_dec->ps_ref_pic_buf_lx[0][i];
        u4_poc0 = ps_pic_buff0->i4_avg_poc;
 for(j = 0; j < uc_num_ref_idx_l1_active; j++)
 {
            ps_pic_buff1 = ps_dec->ps_ref_pic_buf_lx[1][j];
            u4_poc1 = ps_pic_buff1->i4_avg_poc;

 if(u4_poc1 != u4_poc0)
 {
                i16_tb = ps_dec->ps_cur_pic->i4_poc - u4_poc0;
                i16_tb = CLIP3(-128, 127, i16_tb);
                i16_td = u4_poc1 - u4_poc0;
                i16_td = CLIP3(-128, 127, i16_td);
                i16_tx = (16384 + ABS(SIGN_POW2_DIV(i16_td, 1))) / i16_td;
                i2_dist_scale_factor = CLIP3(-1024, 1023,
 (((i16_tb * i16_tx) + 32) >> 6));

 if(/*((u4_poc1 - u4_poc0) == 0) ||*/
 (!(ps_pic_buff1->u1_is_short && ps_pic_buff0->u1_is_short))
 || ((i2_dist_scale_factor >> 2) < -64)
 || ((i2_dist_scale_factor >> 2) > 128))
 {
 /* same for forward and backward, wt=32 and Offset = 0 */
                    ui_temp0 = 0x00000020;
                    ui_temp1 = 0x00000020;
 }
 else
 {
                    ui_temp0 = 64 - (i2_dist_scale_factor >> 2);
                    ui_temp1 = (i2_dist_scale_factor >> 2);
 }
 }
 else
 {
                ui_temp0 = 0x00000020;
                ui_temp1 = 0x00000020;
 }
            pu4_iwt_ofst[0] = pu4_iwt_ofst[2] = pu4_iwt_ofst[4] = ui_temp0;
            pu4_iwt_ofst[1] = pu4_iwt_ofst[3] = pu4_iwt_ofst[5] = ui_temp1;
            pu4_iwt_ofst += 6;
 }
 }
 if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag)
 {
        UWORD8 k;
        WORD32 i4_cur_poc = ps_dec->ps_cur_pic->i4_top_field_order_cnt;
        UWORD32* pu4_wt_mat = ps_dec->pu4_mbaff_wt_mat;
 /* Form the Implicit Weighted prediction matrix for field MBs also */
 for(k = 0; k < 2; k++)
 {
 for(i = 0; i < (uc_num_ref_idx_l0_active << 1); i++)
 {
                UWORD16 u2_l0_idx;

 /*u2_l0_idx = (i >= uc_num_ref_idx_l0_active)
                 ?(MAX_REF_BUFS + i - uc_num_ref_idx_l0_active) : (i) ;*/

                u2_l0_idx = i >> 1;
 if((i & 0x01) != k)
 {
                    u2_l0_idx += MAX_REF_BUFS;
 }
                ps_pic_buff0 = ps_dec->ps_ref_pic_buf_lx[0][u2_l0_idx];
                u4_poc0 = ps_pic_buff0->i4_poc;
 for(j = 0; j < (uc_num_ref_idx_l1_active << 1); j++)
 {
                    UWORD16 u2_l1_idx;
 /*u2_l1_idx = (j >= uc_num_ref_idx_l1_active)
                     ? (MAX_REF_BUFS + j - uc_num_ref_idx_l1_active ) : (j) ;*/

                    u2_l1_idx = j >> 1;
 if((j & 0x01) != k)
 {
                        u2_l1_idx += MAX_REF_BUFS;
 }
                    ps_pic_buff1 = ps_dec->ps_ref_pic_buf_lx[1][u2_l1_idx];
                    u4_poc1 = ps_pic_buff1->i4_poc;
 if(u4_poc1 != u4_poc0)
 {
                        i16_tb = i4_cur_poc - u4_poc0;
                        i16_tb = CLIP3(-128, 127, i16_tb);
                        i16_td = u4_poc1 - u4_poc0;
                        i16_td = CLIP3(-128, 127, i16_td);
                        i16_tx = (16384 + ABS(SIGN_POW2_DIV(i16_td, 1)))
 / i16_td;
                        i2_dist_scale_factor = CLIP3(
 -1024, 1023,
 (((i16_tb * i16_tx) + 32) >> 6));

 if(/*((u4_poc1 - u4_poc0) == 0) ||*/
 (!(ps_pic_buff1->u1_is_short && ps_pic_buff0->u1_is_short))
 || ((i2_dist_scale_factor >> 2) < -64)
 || ((i2_dist_scale_factor >> 2) > 128))
 {
 /* same for forward and backward, wt=32 and Offset = 0 */
                            ui_temp0 = 0x00000020;
                            ui_temp1 = 0x00000020;
 }
 else
 {
                            ui_temp0 = 64 - (i2_dist_scale_factor >> 2);
                            ui_temp1 = (i2_dist_scale_factor >> 2);
 }
 }
 else
 {
                        ui_temp0 = 0x00000020;
                        ui_temp1 = 0x00000020;
 }
 /* Store in the weight matrix */
 *pu4_wt_mat++ = ui_temp0;
 *pu4_wt_mat++ = ui_temp1;
 *pu4_wt_mat++ = ui_temp0;
 *pu4_wt_mat++ = ui_temp1;
 *pu4_wt_mat++ = ui_temp0;
 *pu4_wt_mat++ = ui_temp1;

 }
 }
            i4_cur_poc = ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;
 }
 }
}

WORD32 ih264d_delete_gap_frm_sliding(dpb_manager_t *ps_dpb_mgr,
                                    WORD32 i4_frame_num,
                                    UWORD8 *pu1_del_node)
{
    WORD8 i1_gap_idx, i, j, j_min;
    WORD32 *pi4_gaps_start_frm_num, *pi4_gaps_end_frm_num, i4_gap_frame_num;
    WORD32 i4_start_frm_num, i4_end_frm_num;
    WORD32 i4_max_frm_num;
    WORD32 i4_frm_num, i4_gap_frm_num_min;

 /* find the least frame num from gaps and current DPB node    */
 /* Delete the least one                                       */
 *pu1_del_node = 1;
 if(0 == ps_dpb_mgr->u1_num_gaps)
 return OK;
    pi4_gaps_start_frm_num = ps_dpb_mgr->ai4_gaps_start_frm_num;
    pi4_gaps_end_frm_num = ps_dpb_mgr->ai4_gaps_end_frm_num;
    i4_gap_frame_num = INVALID_FRAME_NUM;
    i4_max_frm_num = ps_dpb_mgr->i4_max_frm_num;

    i1_gap_idx = -1;
 if(INVALID_FRAME_NUM != i4_frame_num)
 {
        i4_gap_frame_num = i4_frame_num;
 for(i = 0; i < MAX_FRAMES; i++)
 {
            i4_start_frm_num = pi4_gaps_start_frm_num[i];
 if(INVALID_FRAME_NUM != i4_start_frm_num)
 {
                i4_end_frm_num = pi4_gaps_end_frm_num[i];
 if(i4_end_frm_num < i4_max_frm_num)
 {
 if(i4_start_frm_num <= i4_gap_frame_num)
 {
                        i4_gap_frame_num = i4_start_frm_num;
                        i1_gap_idx = i;
 }
 }
 else
 {
 if(((i4_start_frm_num <= i4_gap_frame_num)
 && (i4_gap_frame_num <= i4_max_frm_num))
 || ((i4_start_frm_num >= i4_gap_frame_num)
 && ((i4_gap_frame_num
 + i4_max_frm_num)
 >= i4_end_frm_num)))
 {
                        i4_gap_frame_num = i4_start_frm_num;
                        i1_gap_idx = i;
 }
 }
 }
 }
 }
 else
 {
 /* no valid short term buffers, delete one gap from the least start */
 /* of gap sequence                                                  */
        i4_gap_frame_num = pi4_gaps_start_frm_num[0];
        i1_gap_idx = 0;
 for(i = 1; i < MAX_FRAMES; i++)
 {
 if(INVALID_FRAME_NUM != pi4_gaps_start_frm_num[i])
 {
 if(pi4_gaps_start_frm_num[i] < i4_gap_frame_num)
 {
                    i4_gap_frame_num = pi4_gaps_start_frm_num[i];
                    i1_gap_idx = i;
 }
 }
 }
 if(INVALID_FRAME_NUM == i4_gap_frame_num)
 {
            UWORD32 i4_error_code;
            i4_error_code = ERROR_DBP_MANAGER_T;
 return i4_error_code;
 }
 }

 if(-1 != i1_gap_idx)
 {
 /* find least frame_num in the poc_map, which is in this range */
        i4_start_frm_num = pi4_gaps_start_frm_num[i1_gap_idx];
 if(i4_start_frm_num < 0)
            i4_start_frm_num += i4_max_frm_num;
        i4_end_frm_num = pi4_gaps_end_frm_num[i1_gap_idx];
 if(i4_end_frm_num < 0)
            i4_end_frm_num += i4_max_frm_num;

        i4_gap_frm_num_min = 0xfffffff;
        j_min = MAX_FRAMES;
 for(j = 0; j < MAX_FRAMES; j++)
 {
            i4_frm_num = ps_dpb_mgr->ai4_poc_buf_id_map[j][2];
 if((i4_start_frm_num <= i4_frm_num)
 && (i4_end_frm_num >= i4_frm_num))
 {
 if(i4_frm_num < i4_gap_frm_num_min)
 {
                    j_min = j;
                    i4_gap_frm_num_min = i4_frm_num;
 }
 }
 }

 if(j_min != MAX_FRAMES)
 {

            ps_dpb_mgr->ai4_poc_buf_id_map[j_min][0] = -1;
            ps_dpb_mgr->ai4_poc_buf_id_map[j_min][1] = 0x7fffffff;
            ps_dpb_mgr->ai4_poc_buf_id_map[j_min][2] = GAP_FRAME_NUM;
            ps_dpb_mgr->i1_gaps_deleted++;

            ps_dpb_mgr->ai1_gaps_per_seq[i1_gap_idx]--;
            ps_dpb_mgr->u1_num_gaps--;
 *pu1_del_node = 0;
 if(0 == ps_dpb_mgr->ai1_gaps_per_seq[i1_gap_idx])
 {
                ps_dpb_mgr->ai4_gaps_start_frm_num[i1_gap_idx] =
                INVALID_FRAME_NUM;
                ps_dpb_mgr->ai4_gaps_end_frm_num[i1_gap_idx] = 0;
 }
 }
 }

 return OK;
}

WORD32 ih264d_mark_err_slice_skip(dec_struct_t * ps_dec,
                                WORD32 num_mb_skip,
                                UWORD8 u1_is_idr_slice,
                                UWORD16 u2_frame_num,
 pocstruct_t *ps_cur_poc,
                                WORD32 prev_slice_err)
{
    WORD32 i2_cur_mb_addr;
    UWORD32 u1_num_mbs, u1_num_mbsNby2;
    UWORD32 u1_mb_idx = ps_dec->u1_mb_idx;
    UWORD32 i2_mb_skip_run;

    UWORD32 u1_num_mbs_next, u1_end_of_row;
 const UWORD32 i2_pic_wdin_mbs = ps_dec->u2_frm_wd_in_mbs;
    UWORD32 u1_slice_end;
    UWORD32 u1_tfr_n_mb;
    UWORD32 u1_decode_nmb;
 dec_bit_stream_t * const ps_bitstrm = ps_dec->ps_bitstrm;
 dec_slice_params_t * ps_slice = ps_dec->ps_cur_slice;
    UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
    UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;
 deblk_mb_t *ps_cur_deblk_mb;
 dec_mb_info_t *ps_cur_mb_info;
 parse_pmbarams_t *ps_parse_mb_data;
    UWORD32 u1_inter_mb_type;
    UWORD32 u1_deblk_mb_type;
    UWORD16 u2_total_mbs_coded;
    UWORD32 u1_mbaff = ps_slice->u1_mbaff_frame_flag;
 parse_part_params_t *ps_part_info;
    WORD32 ret;


 if(ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC)
 {
        ih264d_err_pic_dispbuf_mgr(ps_dec);
 return 0;
 }

 if(prev_slice_err == 1)
 {
 /* first slice - missing/header corruption */
        ps_dec->ps_cur_slice->u2_frame_num = u2_frame_num;


 if(!ps_dec->u1_first_slice_in_stream)
 {
            ih264d_end_of_pic(ps_dec, u1_is_idr_slice,
                ps_dec->ps_cur_slice->u2_frame_num);
            ps_dec->s_cur_pic_poc.u2_frame_num =
                ps_dec->ps_cur_slice->u2_frame_num;
 }

 {
            WORD32 i, j, poc = 0;

            ps_dec->ps_cur_slice->u2_first_mb_in_slice = 0;

            ps_dec->pf_mvpred = ih264d_mvpred_nonmbaff;
            ps_dec->p_form_mb_part_info = ih264d_form_mb_part_info_bp;
            ps_dec->p_motion_compensate = ih264d_motion_compensate_bp;

 if(ps_dec->ps_cur_pic != NULL)
                poc = ps_dec->ps_cur_pic->i4_poc + 2;

            j = 0;
 for(i = 0; i < MAX_NUM_PIC_PARAMS; i++)
 if(ps_dec->ps_pps[i].u1_is_valid == TRUE)
                       j = i;
 {
                ret = ih264d_start_of_pic(ps_dec, poc, ps_cur_poc,
                        ps_dec->ps_cur_slice->u2_frame_num,
 &ps_dec->ps_pps[j]);

 if(ret != OK)
 {
 return ret;
 }
 }

            ps_dec->ps_ref_pic_buf_lx[0][0]->u1_pic_buf_id = 0;

            ps_dec->u4_output_present = 0;

 {
                ih264d_get_next_display_field(ps_dec,
                                              ps_dec->ps_out_buffer,
 &(ps_dec->s_disp_op));
 /* If error code is non-zero then there is no buffer available for display,
                 hence avoid format conversion */

 if(0 != ps_dec->s_disp_op.u4_error_code)
 {
                    ps_dec->u4_fmt_conv_cur_row = ps_dec->s_disp_frame_info.u4_y_ht;
 }
 else
                    ps_dec->u4_output_present = 1;
 }

 if(ps_dec->u1_separate_parse == 1)
 {
 if(ps_dec->u4_dec_thread_created == 0)
 {
                    ithread_create(ps_dec->pv_dec_thread_handle, NULL,
 (void *)ih264d_decode_picture_thread,
 (void *)ps_dec);

                    ps_dec->u4_dec_thread_created = 1;
 }

 if((ps_dec->u4_num_cores == 3) &&
 ((ps_dec->u4_app_disable_deblk_frm == 0) || ps_dec->i1_recon_in_thread3_flag)
 && (ps_dec->u4_bs_deblk_thread_created == 0))
 {
                    ps_dec->u4_start_recon_deblk = 0;
                    ithread_create(ps_dec->pv_bs_deblk_thread_handle, NULL,
 (void *)ih264d_recon_deblk_thread,
 (void *)ps_dec);
                    ps_dec->u4_bs_deblk_thread_created = 1;
 }
 }
 }
 }
 else
 {

 dec_slice_struct_t *ps_parse_cur_slice;
        ps_parse_cur_slice = ps_dec->ps_dec_slice_buf + ps_dec->u2_cur_slice_num;

 if(ps_dec->u1_slice_header_done
 && ps_parse_cur_slice == ps_dec->ps_parse_cur_slice)
 {
            u1_num_mbs = ps_dec->u4_num_mbs_cur_nmb;

 if(u1_num_mbs)
 {
                ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs - 1;
 }
 else
 {
 if(ps_dec->u1_separate_parse)
 {
                    ps_cur_mb_info = ps_dec->ps_nmb_info - 1;
 }
 else
 {
                    ps_cur_mb_info = ps_dec->ps_nmb_info
 + ps_dec->u4_num_mbs_prev_nmb - 1;
 }
 }

            ps_dec->u2_mby = ps_cur_mb_info->u2_mby;
            ps_dec->u2_mbx = ps_cur_mb_info->u2_mbx;

            ps_dec->u1_mb_ngbr_availablity =
                    ps_cur_mb_info->u1_mb_ngbr_availablity;

            ps_dec->pv_parse_tu_coeff_data = ps_dec->pv_prev_mb_parse_tu_coeff_data;
            ps_dec->u2_cur_mb_addr--;
            ps_dec->i4_submb_ofst -= SUB_BLK_SIZE;

 if(u1_num_mbs)
 {
 if (ps_dec->u1_pr_sl_type == P_SLICE
 || ps_dec->u1_pr_sl_type == B_SLICE)
 {
                    ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx,    u1_num_mbs);
                    ps_dec->ps_part = ps_dec->ps_parse_part_params;
 }

                u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;
                u1_end_of_row = (!u1_num_mbs_next)
 && (!(u1_mbaff && (u1_num_mbs & 0x01)));
                u1_slice_end = 1;
                u1_tfr_n_mb = 1;
                ps_cur_mb_info->u1_end_of_slice = u1_slice_end;

 if(ps_dec->u1_separate_parse)
 {
                    ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,
                            u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);
                    ps_dec->ps_nmb_info += u1_num_mbs;
 }
 else
 {
                    ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,
                            u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);
 }
                ps_dec->u2_total_mbs_coded += u1_num_mbs;
                ps_dec->u1_mb_idx = 0;
                ps_dec->u4_num_mbs_cur_nmb = 0;
 }

 if(ps_dec->u2_total_mbs_coded
 >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)
 {
                ps_dec->u1_pic_decode_done = 1;
 return 0;
 }

            ps_dec->u2_cur_slice_num++;
             ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;
            ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;
            ps_dec->ps_parse_cur_slice++;

 }
 else
 {
            ps_dec->ps_parse_cur_slice = ps_dec->ps_dec_slice_buf
 + ps_dec->u2_cur_slice_num;
 }
 }

 /******************************************************/
 /* Initializations to new slice                       */
 /******************************************************/
 {
        WORD32 num_entries;
        WORD32 size;
        UWORD8 *pu1_buf;

        num_entries = MIN(MAX_FRAMES, ps_dec->u4_num_ref_frames_at_init);
        num_entries = 2 * ((2 * num_entries) + 1);

        size = num_entries * sizeof(void *);
        size += PAD_MAP_IDX_POC * sizeof(void *);

        pu1_buf = (UWORD8 *)ps_dec->pv_map_ref_idx_to_poc_buf;
        pu1_buf += size * ps_dec->u2_cur_slice_num;
        ps_dec->ps_parse_cur_slice->ppv_map_ref_idx_to_poc = (volatile void **)pu1_buf;
 }

    ps_dec->ps_cur_slice->u2_first_mb_in_slice = ps_dec->u2_total_mbs_coded << u1_mbaff;
 if(ps_dec->ps_cur_slice->u1_field_pic_flag)
        ps_dec->u2_prv_frame_num = ps_dec->ps_cur_slice->u2_frame_num;

    ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice = ps_dec->u2_total_mbs_coded << u1_mbaff;
    ps_dec->ps_parse_cur_slice->u2_log2Y_crwd =    ps_dec->ps_cur_slice->u2_log2Y_crwd;


 if(ps_dec->u1_separate_parse)
 {
        ps_dec->ps_parse_cur_slice->pv_tu_coeff_data_start = ps_dec->pv_parse_tu_coeff_data;
 }
 else
 {
        ps_dec->pv_proc_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;
 }

 /******************************************************/
 /* Initializations specific to P slice                */
 /******************************************************/
    u1_inter_mb_type = P_MB;
    u1_deblk_mb_type = D_INTER_MB;

    ps_dec->ps_cur_slice->u1_slice_type = P_SLICE;
    ps_dec->ps_parse_cur_slice->slice_type = P_SLICE;
    ps_dec->pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb;
    ps_dec->ps_part = ps_dec->ps_parse_part_params;

 /******************************************************/
 /* Parsing / decoding the slice                       */
 /******************************************************/
    ps_dec->u1_slice_header_done = 2;
    ps_dec->u1_qp = ps_slice->u1_slice_qp;
    ih264d_update_qp(ps_dec, 0);
    u1_mb_idx = ps_dec->u1_mb_idx;
    ps_parse_mb_data = ps_dec->ps_parse_mb_data;
    u1_num_mbs = u1_mb_idx;

    u1_slice_end = 0;
    u1_tfr_n_mb = 0;
    u1_decode_nmb = 0;
    u1_num_mbsNby2 = 0;
    i2_cur_mb_addr = ps_dec->u2_total_mbs_coded;
    i2_mb_skip_run = num_mb_skip;

 while(!u1_slice_end)
 {
        UWORD8 u1_mb_type;

 if(i2_cur_mb_addr > ps_dec->ps_cur_sps->u2_max_mb_addr)
 break;

        ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs;
        ps_dec->u4_num_mbs_cur_nmb = u1_num_mbs;

        ps_cur_mb_info->u1_Mux = 0;
        ps_dec->u4_num_pmbair = (u1_num_mbs >> u1_mbaff);
        ps_cur_deblk_mb = ps_dec->ps_deblk_mbn + u1_num_mbs;

        ps_cur_mb_info->u1_end_of_slice = 0;

 /* Storing Default partition info */
        ps_parse_mb_data->u1_num_part = 1;
        ps_parse_mb_data->u1_isI_mb = 0;

 /**************************************************************/
 /* Get the required information for decoding of MB            */
 /**************************************************************/
 /* mb_x, mb_y, neighbor availablity, */
 if (u1_mbaff)
            ih264d_get_mb_info_cavlc_mbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);
 else
            ih264d_get_mb_info_cavlc_nonmbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);

 /* Set the deblocking parameters for this MB */
 if(ps_dec->u4_app_disable_deblk_frm == 0)
 {
            ih264d_set_deblocking_parameters(ps_cur_deblk_mb, ps_slice,
                                             ps_dec->u1_mb_ngbr_availablity,
                                             ps_dec->u1_cur_mb_fld_dec_flag);
 }

 /* Set appropriate flags in ps_cur_mb_info and ps_dec */
        ps_dec->i1_prev_mb_qp_delta = 0;
        ps_dec->u1_sub_mb_num = 0;
        ps_cur_mb_info->u1_mb_type = MB_SKIP;
        ps_cur_mb_info->u1_mb_mc_mode = PRED_16x16;
        ps_cur_mb_info->u1_cbp = 0;

 /* Storing Skip partition info */
        ps_part_info = ps_dec->ps_part;
        ps_part_info->u1_is_direct = PART_DIRECT_16x16;
        ps_part_info->u1_sub_mb_num = 0;
        ps_dec->ps_part++;

 /* Update Nnzs */
        ih264d_update_nnz_for_skipmb(ps_dec, ps_cur_mb_info, CAVLC);

        ps_cur_mb_info->ps_curmb->u1_mb_type = u1_inter_mb_type;
        ps_cur_deblk_mb->u1_mb_type |= u1_deblk_mb_type;

        i2_mb_skip_run--;

        ps_cur_deblk_mb->u1_mb_qp = ps_dec->u1_qp;

 if (u1_mbaff)
 {
            ih264d_update_mbaff_left_nnz(ps_dec, ps_cur_mb_info);
 }

 /**************************************************************/
 /* Get next Macroblock address                                */
 /**************************************************************/
        i2_cur_mb_addr++;

        u1_num_mbs++;
        u1_num_mbsNby2++;
        ps_parse_mb_data++;

 /****************************************************************/
 /* Check for End Of Row and other flags that determine when to  */
 /* do DMA setup for N/2-Mb, Decode for N-Mb, and Transfer for   */
 /* N-Mb                                                         */
 /****************************************************************/
        u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;
        u1_end_of_row = (!u1_num_mbs_next) && (!(u1_mbaff && (u1_num_mbs & 0x01)));
        u1_slice_end = !i2_mb_skip_run;
        u1_tfr_n_mb = (u1_num_mbs == ps_dec->u1_recon_mb_grp) || u1_end_of_row
 || u1_slice_end;
        u1_decode_nmb = u1_tfr_n_mb || u1_slice_end;
        ps_cur_mb_info->u1_end_of_slice = u1_slice_end;

 if(u1_decode_nmb)
 {
            ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx, u1_num_mbs);
            u1_num_mbsNby2 = 0;

            ps_parse_mb_data = ps_dec->ps_parse_mb_data;
            ps_dec->ps_part = ps_dec->ps_parse_part_params;

 if(ps_dec->u1_separate_parse)
 {
                ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,
                                     u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);
                ps_dec->ps_nmb_info +=  u1_num_mbs;
 }
 else
 {
                ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs, u1_num_mbs_next,
                                            u1_tfr_n_mb, u1_end_of_row);
 }
            ps_dec->u2_total_mbs_coded += u1_num_mbs;
 if(u1_tfr_n_mb)
                u1_num_mbs = 0;
            u1_mb_idx = u1_num_mbs;
            ps_dec->u1_mb_idx = u1_num_mbs;
 }
 }

    ps_dec->u4_num_mbs_cur_nmb = 0;
    ps_dec->ps_cur_slice->u4_mbs_in_slice = i2_cur_mb_addr
 - ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice;

    H264_DEC_DEBUG_PRINT("Mbs in slice: %d\n", ps_dec->ps_cur_slice->u4_mbs_in_slice);

    ps_dec->u2_cur_slice_num++;

 /* incremented here only if first slice is inserted */
 if(ps_dec->u4_first_slice_in_pic != 0)
        ps_dec->ps_parse_cur_slice++;

    ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;
    ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;

 if(ps_dec->u2_total_mbs_coded
 >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)
 {
        ps_dec->u1_pic_decode_done = 1;
 }

 return 0;

}

WORD32 ih264d_parse_bmb_cabac(dec_struct_t * ps_dec,
 dec_mb_info_t * ps_cur_mb_info,
                              UWORD8 u1_mb_num,
                              UWORD8 u1_num_mbsNby2)
{
    UWORD8 u1_cbp;
 deblk_mb_t * ps_cur_deblk_mb = ps_dec->ps_deblk_mbn + u1_mb_num;
 const UWORD8 *puc_mb_mc_mode = (const UWORD8 *)gau1_ih264d_mb_mc_mode;
    UWORD8 u1_mb_type = ps_cur_mb_info->u1_mb_type;
 ctxt_inc_mb_info_t *p_curr_ctxt = ps_dec->ps_curr_ctxt_mb_info;

    WORD32 ret;
    UWORD8 u1_Bdirect_tranform_read = 1;
    ps_dec->s_high_profile.u1_no_submb_part_size_lt8x8_flag = 1;

    ps_cur_mb_info->u1_mb_mc_mode = puc_mb_mc_mode[5 + u1_mb_type];

    ps_cur_mb_info->u1_yuv_dc_block_flag = 0;

    ps_cur_deblk_mb->u1_mb_type |= D_B_SLICE;
 if(u1_mb_type != B_DIRECT)
 {
        ret = ih264d_parse_bmb_non_direct_cabac(ps_dec, ps_cur_mb_info, u1_mb_num,
                                          u1_num_mbsNby2);
 if(ret != OK)
 return ret;
 }
 else
 {

 /************ STORING PARTITION INFO ***********/
 parse_part_params_t * ps_part_info;
        ps_part_info = ps_dec->ps_part;
        ps_part_info->u1_is_direct = PART_DIRECT_16x16;
        ps_part_info->u1_sub_mb_num = 0;
        ps_dec->ps_part++;
        p_curr_ctxt->u1_mb_type = CAB_BD16x16;

        MEMSET_16BYTES(&ps_dec->pu1_left_mv_ctxt_inc[0][0], 0);
        memset(ps_dec->pi1_left_ref_idx_ctxt_inc, 0, 4);
        MEMSET_16BYTES(p_curr_ctxt->u1_mv, 0);
        memset(p_curr_ctxt->i1_ref_idx, 0, 4);

 /* check whether transform8x8 u4_flag to be read or not */
        u1_Bdirect_tranform_read =
                        ps_dec->s_high_profile.u1_direct_8x8_inference_flag;
 }

 /* Read the Coded block pattern */
    u1_cbp = (WORD8)ih264d_parse_ctx_cbp_cabac(ps_dec);
    p_curr_ctxt->u1_cbp = u1_cbp;
    ps_cur_mb_info->u1_cbp = u1_cbp;

 if(u1_cbp > 47)
 return ERROR_CBP;

    COPYTHECONTEXT("coded_block_pattern", u1_cbp);

    ps_cur_mb_info->u1_tran_form8x8 = 0;
    ps_cur_mb_info->ps_curmb->u1_tran_form8x8 = 0;

 if((ps_dec->s_high_profile.u1_transform8x8_present) && (u1_cbp & (0xf))
 && (ps_dec->s_high_profile.u1_no_submb_part_size_lt8x8_flag)
 && (u1_Bdirect_tranform_read))
 {
        ps_cur_mb_info->u1_tran_form8x8 = ih264d_parse_transform8x8flag_cabac(
                        ps_dec, ps_cur_mb_info);
        COPYTHECONTEXT("transform_size_8x8_flag", ps_cur_mb_info->u1_tran_form8x8);

        ps_cur_mb_info->ps_curmb->u1_tran_form8x8 = ps_cur_mb_info->u1_tran_form8x8;
        p_curr_ctxt->u1_transform8x8_ctxt = ps_cur_mb_info->u1_tran_form8x8;
 }
 else
 {
        p_curr_ctxt->u1_transform8x8_ctxt = 0;
 }

    p_curr_ctxt->u1_intra_chroma_pred_mode = 0;
    p_curr_ctxt->u1_yuv_dc_csbp &= 0xFE;
    ps_dec->pu1_left_yuv_dc_csbp[0] &= 0x6;

 /* Read mb_qp_delta */
 if(u1_cbp)
 {
        WORD8 c_temp;
        ret = ih264d_parse_mb_qp_delta_cabac(ps_dec, &c_temp);
 if(ret != OK)
 return ret;
        COPYTHECONTEXT("mb_qp_delta", c_temp);
 if(c_temp)
 {
            ret = ih264d_update_qp(ps_dec, c_temp);
 if(ret != OK)
 return ret;
 }
 }
 else
        ps_dec->i1_prev_mb_qp_delta = 0;

    ih264d_parse_residual4x4_cabac(ps_dec, ps_cur_mb_info, 0);
 if(EXCEED_OFFSET(ps_dec->ps_bitstrm))
 return ERROR_EOB_TERMINATE_T;
 return OK;
}

WORD32 ih264d_parse_islice_data_cabac(dec_struct_t * ps_dec,
 dec_slice_params_t * ps_slice,
                                      UWORD16 u2_first_mb_in_slice)
{
    UWORD8 uc_more_data_flag;
    UWORD8 u1_num_mbs, u1_mb_idx;
 dec_mb_info_t *ps_cur_mb_info;
 deblk_mb_t *ps_cur_deblk_mb;

 dec_bit_stream_t * const ps_bitstrm = ps_dec->ps_bitstrm;
    UWORD16 i2_pic_wdin_mbs = ps_dec->u2_frm_wd_in_mbs;
    WORD16 i2_cur_mb_addr;
    UWORD8 u1_mbaff;
    UWORD8 u1_num_mbs_next, u1_end_of_row, u1_tfr_n_mb;
    WORD32 ret = OK;

    ps_dec->u1_qp = ps_slice->u1_slice_qp;
    ih264d_update_qp(ps_dec, 0);
    u1_mbaff = ps_slice->u1_mbaff_frame_flag;

 if(ps_bitstrm->u4_ofst & 0x07)
 {
        ps_bitstrm->u4_ofst += 8;
        ps_bitstrm->u4_ofst &= 0xFFFFFFF8;
 }
    ret = ih264d_init_cabac_dec_envirnoment(&(ps_dec->s_cab_dec_env), ps_bitstrm);
 if(ret != OK)
 return ret;
    ih264d_init_cabac_contexts(I_SLICE, ps_dec);

    ps_dec->i1_prev_mb_qp_delta = 0;

 /* initializations */
    u1_mb_idx = ps_dec->u1_mb_idx;
    u1_num_mbs = u1_mb_idx;

    uc_more_data_flag = 1;
    i2_cur_mb_addr = u2_first_mb_in_slice << u1_mbaff;
 do
 {
        UWORD16 u2_mbx;

        ps_dec->pv_prev_mb_parse_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;

 if(i2_cur_mb_addr > ps_dec->ps_cur_sps->u2_max_mb_addr)
 {
            ret = ERROR_MB_ADDRESS_T;
 break;
 }

 {
            UWORD8 u1_mb_type;

            ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs;
            ps_dec->u4_num_mbs_cur_nmb = u1_num_mbs;
            ps_dec->u4_num_pmbair = (u1_num_mbs >> u1_mbaff);

            ps_cur_mb_info->u1_end_of_slice = 0;

 /***************************************************************/
 /* Get the required information for decoding of MB                  */
 /* mb_x, mb_y , neighbour availablity,                              */
 /***************************************************************/
            ps_dec->pf_get_mb_info(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, 0);
            u2_mbx = ps_dec->u2_mbx;

 /*********************************************************************/
 /* initialize u1_tran_form8x8 to zero to aviod uninitialized accesses */
 /*********************************************************************/
            ps_cur_mb_info->u1_tran_form8x8 = 0;
            ps_cur_mb_info->ps_curmb->u1_tran_form8x8 = 0;

 /***************************************************************/
 /* Set the deblocking parameters for this MB                   */
 /***************************************************************/
            ps_cur_deblk_mb = ps_dec->ps_deblk_mbn + u1_num_mbs;
 if(ps_dec->u4_app_disable_deblk_frm == 0)
                ih264d_set_deblocking_parameters(
                                ps_cur_deblk_mb, ps_slice,
                                ps_dec->u1_mb_ngbr_availablity,
                                ps_dec->u1_cur_mb_fld_dec_flag);

            ps_cur_deblk_mb->u1_mb_type = ps_cur_deblk_mb->u1_mb_type
 | D_INTRA_MB;

 /* Macroblock Layer Begins */
 /* Decode the u1_mb_type */
            u1_mb_type = ih264d_parse_mb_type_intra_cabac(0, ps_dec);
 if(u1_mb_type > 25)
 return ERROR_MB_TYPE;
            ps_cur_mb_info->u1_mb_type = u1_mb_type;
            COPYTHECONTEXT("u1_mb_type", u1_mb_type);

 /* Parse Macroblock Data */
 if(25 == u1_mb_type)
 {
 /* I_PCM_MB */
                ps_cur_mb_info->ps_curmb->u1_mb_type = I_PCM_MB;
                ret = ih264d_parse_ipcm_mb(ps_dec, ps_cur_mb_info, u1_num_mbs);
 if(ret != OK)
 return ret;
                ps_cur_deblk_mb->u1_mb_qp = 0;
 }
 else
 {
                ret = ih264d_parse_imb_cabac(ps_dec, ps_cur_mb_info, u1_mb_type);
 if(ret != OK)
 return ret;
                ps_cur_deblk_mb->u1_mb_qp = ps_dec->u1_qp;
 }

 if(u1_mbaff)
 {
                ih264d_update_mbaff_left_nnz(ps_dec, ps_cur_mb_info);
 }
 /* Next macroblock information */
            i2_cur_mb_addr++;

 if(ps_cur_mb_info->u1_topmb && u1_mbaff)
                uc_more_data_flag = 1;
 else
 {
                uc_more_data_flag = ih264d_decode_terminate(&ps_dec->s_cab_dec_env,
                                                          ps_bitstrm);
                uc_more_data_flag = !uc_more_data_flag;
                COPYTHECONTEXT("Decode Sliceterm",!uc_more_data_flag);
 }
 /* Store the colocated information */
 {

 mv_pred_t *ps_mv_nmb_start = ps_dec->ps_mv_cur + (u1_num_mbs << 4);
 mv_pred_t s_mvPred =
 {
 { 0, 0, 0, 0 },
 { -1, -1 }, 0, 0};
                ih264d_rep_mv_colz(
                                ps_dec, &s_mvPred, ps_mv_nmb_start, 0,
 (UWORD8)(ps_dec->u1_cur_mb_fld_dec_flag << 1),
 4, 4);
 }
 /*if num _cores is set to 3,compute bs will be done in another thread*/
 if(ps_dec->u4_num_cores < 3)
 {
 if(ps_dec->u4_app_disable_deblk_frm == 0)
                    ps_dec->pf_compute_bs(ps_dec, ps_cur_mb_info,
 (UWORD16)(u1_num_mbs >> u1_mbaff));
 }
            u1_num_mbs++;

 }

 /****************************************************************/
 /* Check for End Of Row                                         */
 /****************************************************************/
        u1_num_mbs_next = i2_pic_wdin_mbs - u2_mbx - 1;
        u1_end_of_row = (!u1_num_mbs_next) && (!(u1_mbaff && (u1_num_mbs & 0x01)));
        u1_tfr_n_mb = (u1_num_mbs == ps_dec->u1_recon_mb_grp) || u1_end_of_row
 || (!uc_more_data_flag);
        ps_cur_mb_info->u1_end_of_slice = (!uc_more_data_flag);

 if(u1_tfr_n_mb || (!uc_more_data_flag))
 {


 if(ps_dec->u1_separate_parse)
 {
                ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,
                                     u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);
                ps_dec->ps_nmb_info +=  u1_num_mbs;
 }
 else
 {
                ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,
                                            u1_num_mbs_next, u1_tfr_n_mb,
                                            u1_end_of_row);
 }
            ps_dec->u2_total_mbs_coded += u1_num_mbs;
 if(u1_tfr_n_mb)
                u1_num_mbs = 0;
            u1_mb_idx = u1_num_mbs;
            ps_dec->u1_mb_idx = u1_num_mbs;

 }
 }
 while(uc_more_data_flag);

    ps_dec->u4_num_mbs_cur_nmb = 0;
    ps_dec->ps_cur_slice->u4_mbs_in_slice = i2_cur_mb_addr

 - (u2_first_mb_in_slice << u1_mbaff);

 return ret;
}

WORD32 ih264d_insert_st_node(dpb_manager_t *ps_dpb_mgr,
 struct pic_buffer_t *ps_pic_buf,
                          UWORD8 u1_buf_id,
                          UWORD32 u4_cur_pic_num)
{
    WORD32 i;
 struct dpb_info_t *ps_dpb_info = ps_dpb_mgr->as_dpb_info;
    UWORD8 u1_picture_type = ps_pic_buf->u1_picturetype;
 /* Find an unused dpb location */
 for(i = 0; i < MAX_REF_BUFS; i++)
 {
 if((ps_dpb_info[i].ps_pic_buf == ps_pic_buf)
 && ps_dpb_info[i].u1_used_as_ref)
 {
 /* Can occur only for field bottom pictures */
            ps_dpb_info[i].s_bot_field.u1_reference_info = IS_SHORT_TERM;
 return 0;
 }

 if((ps_dpb_info[i].u1_used_as_ref == UNUSED_FOR_REF)
 && (ps_dpb_info[i].s_top_field.u1_reference_info
 == UNUSED_FOR_REF)
 && (ps_dpb_info[i].s_bot_field.u1_reference_info
 == UNUSED_FOR_REF))
 break;
 }
 if(i == MAX_REF_BUFS)
 {
        UWORD32 i4_error_code;
        i4_error_code = ERROR_DBP_MANAGER_T;
 return i4_error_code;
 }

 /* Create dpb info */
    ps_dpb_info[i].ps_pic_buf = ps_pic_buf;
    ps_dpb_info[i].ps_prev_short = ps_dpb_mgr->ps_dpb_st_head;
    ps_dpb_info[i].u1_buf_id = u1_buf_id;
    ps_dpb_info[i].u1_used_as_ref = TRUE;
    ps_dpb_info[i].u1_lt_idx = MAX_REF_BUFS + 1;
    ps_dpb_info[i].i4_frame_num = u4_cur_pic_num;
    ps_dpb_info[i].ps_pic_buf->i4_frame_num = u4_cur_pic_num;

 /* update the head node of linked list to point to the cur Pic */
    ps_dpb_mgr->ps_dpb_st_head = ps_dpb_info + i;

    ps_dpb_mgr->u1_num_st_ref_bufs++;
 /* Identify the picture as a short term picture buffer */
    ps_pic_buf->u1_is_short = IS_SHORT_TERM;

 if((u1_picture_type & 0x03) == FRM_PIC)
 {
        ps_dpb_info[i].u1_used_as_ref = IS_SHORT_TERM;
        ps_dpb_info[i].s_top_field.u1_reference_info = IS_SHORT_TERM;
        ps_dpb_info[i].s_bot_field.u1_reference_info = IS_SHORT_TERM;
 }

 if((u1_picture_type & 0x03) == TOP_FLD)
        ps_dpb_info[i].s_top_field.u1_reference_info = IS_SHORT_TERM;

 if((u1_picture_type & 0x03) == BOT_FLD)
        ps_dpb_info[i].s_bot_field.u1_reference_info = IS_SHORT_TERM;

 return OK;
}

WORD32 ih264d_parse_imb_cavlc(dec_struct_t * ps_dec,
 dec_mb_info_t * ps_cur_mb_info,
                              UWORD8 u1_mb_num,
                              UWORD8 u1_mb_type)
{
    WORD32 i4_delta_qp;
    UWORD32 u4_temp;
    UWORD32 ui_is_top_mb_available;
    UWORD32 ui_is_left_mb_available;
    UWORD32 u4_cbp;
    UWORD32 u4_offset;
    UWORD32 *pu4_bitstrm_buf;
    WORD32 ret;

 dec_bit_stream_t * const ps_bitstrm = ps_dec->ps_bitstrm;
    UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;
    UNUSED(u1_mb_num);
    ps_cur_mb_info->u1_tran_form8x8 = 0;
    ps_cur_mb_info->ps_curmb->u1_tran_form8x8 = 0;

    ps_cur_mb_info->u1_yuv_dc_block_flag = 0;

    u4_temp = ps_dec->u1_mb_ngbr_availablity;
    ui_is_top_mb_available = BOOLEAN(u4_temp & TOP_MB_AVAILABLE_MASK);
    ui_is_left_mb_available = BOOLEAN(u4_temp & LEFT_MB_AVAILABLE_MASK);

    pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;

 if(u1_mb_type == I_4x4_MB)
 {
        ps_cur_mb_info->ps_curmb->u1_mb_type = I_4x4_MB;
        u4_offset = 0;

 /*--------------------------------------------------------------------*/
 /* Read transform_size_8x8_flag if present                            */
 /*--------------------------------------------------------------------*/
 if(ps_dec->s_high_profile.u1_transform8x8_present)
 {
            ps_cur_mb_info->u1_tran_form8x8 = ih264d_get_bit_h264(ps_bitstrm);
            COPYTHECONTEXT("transform_size_8x8_flag", ps_cur_mb_info->u1_tran_form8x8);
            ps_cur_mb_info->ps_curmb->u1_tran_form8x8 = ps_cur_mb_info->u1_tran_form8x8;
 }

 /*--------------------------------------------------------------------*/
 /* Read the IntraPrediction modes for LUMA                            */
 /*--------------------------------------------------------------------*/
 if (!ps_cur_mb_info->u1_tran_form8x8)
 {
            UWORD8 *pu1_temp;
            ih264d_read_intra_pred_modes(ps_dec,
 ((UWORD8 *)ps_dec->pv_parse_tu_coeff_data),
 ((UWORD8 *)ps_dec->pv_parse_tu_coeff_data+16),
                                          ps_cur_mb_info->u1_tran_form8x8);
            pu1_temp = (UWORD8 *)ps_dec->pv_parse_tu_coeff_data;
            pu1_temp += 32;
            ps_dec->pv_parse_tu_coeff_data = (void *)pu1_temp;
 }
 else
 {
            UWORD8 *pu1_temp;
            ih264d_read_intra_pred_modes(ps_dec,
 ((UWORD8 *)ps_dec->pv_parse_tu_coeff_data),
 ((UWORD8 *)ps_dec->pv_parse_tu_coeff_data+4),
                                          ps_cur_mb_info->u1_tran_form8x8);
            pu1_temp = (UWORD8 *)ps_dec->pv_parse_tu_coeff_data;
            pu1_temp += 8;
            ps_dec->pv_parse_tu_coeff_data = (void *)pu1_temp;
 }
 /*--------------------------------------------------------------------*/
 /* Read the IntraPrediction mode for CHROMA                           */
 /*--------------------------------------------------------------------*/
 {
            UWORD32 u4_bitstream_offset = *pu4_bitstrm_ofst;
            UWORD32 u4_word, u4_ldz, u4_temp;

 /***************************************************************/
 /* Find leading zeros in next 32 bits                          */
 /***************************************************************/
            NEXTBITS_32(u4_word, u4_bitstream_offset, pu4_bitstrm_buf);
            u4_ldz = CLZ(u4_word);
 /* Flush the ps_bitstrm */
            u4_bitstream_offset += (u4_ldz + 1);
 /* Read the suffix from the ps_bitstrm */
            u4_word = 0;
 if(u4_ldz)
 {
                GETBITS(u4_word, u4_bitstream_offset, pu4_bitstrm_buf,
                        u4_ldz);
 }
 *pu4_bitstrm_ofst = u4_bitstream_offset;
            u4_temp = ((1 << u4_ldz) + u4_word - 1);
 if(u4_temp > 3)
 {
 return ERROR_CHROMA_PRED_MODE;
 }
            ps_cur_mb_info->u1_chroma_pred_mode = u4_temp;
            COPYTHECONTEXT("intra_chroma_pred_mode", ps_cur_mb_info->u1_chroma_pred_mode);
 }
 /*--------------------------------------------------------------------*/
 /* Read the Coded block pattern                                       */
 /*--------------------------------------------------------------------*/
 {
            UWORD32 u4_bitstream_offset = *pu4_bitstrm_ofst;
            UWORD32 u4_word, u4_ldz;

 /***************************************************************/
 /* Find leading zeros in next 32 bits                          */
 /***************************************************************/
            NEXTBITS_32(u4_word, u4_bitstream_offset, pu4_bitstrm_buf);
            u4_ldz = CLZ(u4_word);
 /* Flush the ps_bitstrm */
            u4_bitstream_offset += (u4_ldz + 1);
 /* Read the suffix from the ps_bitstrm */
            u4_word = 0;
 if(u4_ldz)
 {
                GETBITS(u4_word, u4_bitstream_offset, pu4_bitstrm_buf,
                        u4_ldz);
 }
 *pu4_bitstrm_ofst = u4_bitstream_offset;
            u4_cbp = ((1 << u4_ldz) + u4_word - 1);
 }
 if(u4_cbp > 47)
 {
 return ERROR_CBP;
 }

        u4_cbp = gau1_ih264d_cbp_table[u4_cbp][0];
        COPYTHECONTEXT("coded_block_pattern", u1_cbp);
        ps_cur_mb_info->u1_cbp = u4_cbp;

 /*--------------------------------------------------------------------*/
 /* Read mb_qp_delta                                                   */
 /*--------------------------------------------------------------------*/
 if(ps_cur_mb_info->u1_cbp)
 {
            UWORD32 u4_bitstream_offset = *pu4_bitstrm_ofst;
            UWORD32 u4_word, u4_ldz, u4_abs_val;

 /***************************************************************/
 /* Find leading zeros in next 32 bits                          */
 /***************************************************************/
            NEXTBITS_32(u4_word, u4_bitstream_offset, pu4_bitstrm_buf);
            u4_ldz = CLZ(u4_word);

 /* Flush the ps_bitstrm */
            u4_bitstream_offset += (u4_ldz + 1);

 /* Read the suffix from the ps_bitstrm */
            u4_word = 0;
 if(u4_ldz)
 {
                GETBITS(u4_word, u4_bitstream_offset, pu4_bitstrm_buf,
                        u4_ldz);
 }

 *pu4_bitstrm_ofst = u4_bitstream_offset;
            u4_abs_val = ((1 << u4_ldz) + u4_word) >> 1;

 if(u4_word & 0x1)
 {
                i4_delta_qp = (-(WORD32)u4_abs_val);
 }
 else
 {
                i4_delta_qp = (u4_abs_val);
 }

 if((i4_delta_qp < -26) || (i4_delta_qp > 25))
 {
 return ERROR_INV_RANGE_QP_T;
 }

            COPYTHECONTEXT("mb_qp_delta", i1_delta_qp);
 if(i4_delta_qp != 0)
 {
                ret = ih264d_update_qp(ps_dec, (WORD8)i4_delta_qp);
 if(ret != OK)
 return ret;
 }
 }

 }
 else
 {
        u4_offset = 1;
        ps_cur_mb_info->ps_curmb->u1_mb_type = I_16x16_MB;
 /*-------------------------------------------------------------------*/
 /* Read the IntraPrediction mode for CHROMA                          */
 /*-------------------------------------------------------------------*/
 {
            UWORD32 u4_bitstream_offset = *pu4_bitstrm_ofst;
            UWORD32 u4_word, u4_ldz;

 /***************************************************************/
 /* Find leading zeros in next 32 bits                          */
 /***************************************************************/
            NEXTBITS_32(u4_word, u4_bitstream_offset, pu4_bitstrm_buf);
            u4_ldz = CLZ(u4_word);
 /* Flush the ps_bitstrm */
            u4_bitstream_offset += (u4_ldz + 1);
 /* Read the suffix from the ps_bitstrm */
            u4_word = 0;
 if(u4_ldz)
 {
                GETBITS(u4_word, u4_bitstream_offset, pu4_bitstrm_buf,
                        u4_ldz);
 }
 *pu4_bitstrm_ofst = u4_bitstream_offset;
            u4_temp = ((1 << u4_ldz) + u4_word - 1);


 if(u4_temp > 3)
 {
 return ERROR_CHROMA_PRED_MODE;
 }
            ps_cur_mb_info->u1_chroma_pred_mode = u4_temp;
            COPYTHECONTEXT("intra_chroma_pred_mode", ps_cur_mb_info->u1_chroma_pred_mode);
 }
 /*-------------------------------------------------------------------*/
 /* Read the Coded block pattern                                      */
 /*-------------------------------------------------------------------*/
        u4_cbp = gau1_ih264d_cbp_tab[(u1_mb_type - 1) >> 2];
        ps_cur_mb_info->u1_cbp = u4_cbp;

 /*-------------------------------------------------------------------*/
 /* Read mb_qp_delta                                                  */
 /*-------------------------------------------------------------------*/
 {
            UWORD32 u4_bitstream_offset = *pu4_bitstrm_ofst;
            UWORD32 u4_word, u4_ldz, u4_abs_val;

 /***************************************************************/
 /* Find leading zeros in next 32 bits                          */
 /***************************************************************/
            NEXTBITS_32(u4_word, u4_bitstream_offset, pu4_bitstrm_buf);
            u4_ldz = CLZ(u4_word);

 /* Flush the ps_bitstrm */
            u4_bitstream_offset += (u4_ldz + 1);

 /* Read the suffix from the ps_bitstrm */
            u4_word = 0;
 if(u4_ldz)
                GETBITS(u4_word, u4_bitstream_offset, pu4_bitstrm_buf,
                        u4_ldz);

 *pu4_bitstrm_ofst = u4_bitstream_offset;
            u4_abs_val = ((1 << u4_ldz) + u4_word) >> 1;

 if(u4_word & 0x1)
                i4_delta_qp = (-(WORD32)u4_abs_val);
 else
                i4_delta_qp = (u4_abs_val);

 if((i4_delta_qp < -26) || (i4_delta_qp > 25))
 return ERROR_INV_RANGE_QP_T;

 }
        COPYTHECONTEXT("Delta quant", i1_delta_qp);

 if(i4_delta_qp != 0)
 {
            ret = ih264d_update_qp(ps_dec, (WORD8)i4_delta_qp);
 if(ret != OK)
 return ret;
 }

 {
            WORD16 i_scaleFactor;
            UWORD32 ui_N = 0;
            WORD16 *pi2_scale_matrix_ptr;
 /*******************************************************************/
 /* for luma DC coefficients the scaling is done during the parsing */
 /* to preserve the precision                                       */
 /*******************************************************************/
 if(ps_dec->s_high_profile.u1_scaling_present)
 {
                pi2_scale_matrix_ptr =
                                ps_dec->s_high_profile.i2_scalinglist4x4[0];
 }
 else
 {
                i_scaleFactor = 16;
                pi2_scale_matrix_ptr = &i_scaleFactor;
 }

 /*---------------------------------------------------------------*/
 /* Decode DC coefficients                                        */
 /*---------------------------------------------------------------*/
 /*---------------------------------------------------------------*/
 /* Calculation of N                                              */
 /*---------------------------------------------------------------*/
 if(ui_is_left_mb_available)
 {

 if(ui_is_top_mb_available)
 {
                    ui_N = ((ps_cur_mb_info->ps_top_mb->pu1_nnz_y[0]
 + ps_dec->pu1_left_nnz_y[0] + 1) >> 1);
 }
 else
 {
                    ui_N = ps_dec->pu1_left_nnz_y[0];
 }
 }
 else if(ui_is_top_mb_available)
 {
                ui_N = ps_cur_mb_info->ps_top_mb->pu1_nnz_y[0];
 }

 {
                WORD16 pi2_dc_coef[16];
                WORD32 pi4_tmp[16];
 tu_sblk4x4_coeff_data_t *ps_tu_4x4 =
 (tu_sblk4x4_coeff_data_t *)ps_dec->pv_parse_tu_coeff_data;
                WORD16 *pi2_coeff_block =
 (WORD16 *)ps_dec->pv_parse_tu_coeff_data;
                UWORD32 u4_num_coeff;
                ps_tu_4x4->u2_sig_coeff_map = 0;

                ret = ps_dec->pf_cavlc_parse4x4coeff[(ui_N > 7)](pi2_dc_coef, 0, ui_N,
                                                                 ps_dec, &u4_num_coeff);
 if(ret != OK)
 return ret;

 if(EXCEED_OFFSET(ps_bitstrm))
 return ERROR_EOB_TERMINATE_T;
 if(ps_tu_4x4->u2_sig_coeff_map)
 {
                    memset(pi2_dc_coef,0,sizeof(pi2_dc_coef));
                    ih264d_unpack_coeff4x4_dc_4x4blk(ps_tu_4x4,
                                                     pi2_dc_coef,
                                                     ps_dec->pu1_inv_scan);

                    PROFILE_DISABLE_IQ_IT_RECON()
                    ps_dec->pf_ihadamard_scaling_4x4(pi2_dc_coef,
                                                     pi2_coeff_block,
                                                     ps_dec->pu2_quant_scale_y,
 (UWORD16 *)pi2_scale_matrix_ptr,
                                                     ps_dec->u1_qp_y_div6,
                                                     pi4_tmp);
                    pi2_coeff_block += 16;
                    ps_dec->pv_parse_tu_coeff_data = (void *)pi2_coeff_block;
                    SET_BIT(ps_cur_mb_info->u1_yuv_dc_block_flag,0);
 }

 }
 }
 }


 if(u4_cbp)
 {

        ret = ih264d_parse_residual4x4_cavlc(ps_dec, ps_cur_mb_info,
 (UWORD8)u4_offset);
 if(ret != OK)
 return ret;
 if(EXCEED_OFFSET(ps_bitstrm))
 return ERROR_EOB_TERMINATE_T;

 /* Store Left Mb NNZ and TOP chroma NNZ */
 }
 else
 {
        ps_cur_mb_info->u1_qp_div6 = ps_dec->u1_qp_y_div6;
        ps_cur_mb_info->u1_qpc_div6 = ps_dec->u1_qp_u_div6;
        ps_cur_mb_info->u1_qpcr_div6 = ps_dec->u1_qp_v_div6;
        ps_cur_mb_info->u1_qp_rem6 = ps_dec->u1_qp_y_rem6;
        ps_cur_mb_info->u1_qpc_rem6 = ps_dec->u1_qp_u_rem6;
        ps_cur_mb_info->u1_qpcr_rem6 = ps_dec->u1_qp_v_rem6;
        ih264d_update_nnz_for_skipmb(ps_dec, ps_cur_mb_info, CAVLC);
 }

 return OK;
}

WORD32 ih264d_parse_bmb_non_direct_cabac(dec_struct_t * ps_dec,
 dec_mb_info_t * ps_cur_mb_info,
                                       UWORD8 u1_mb_num,
                                       UWORD8 u1_num_mbsNby2)
{
 /* Loads from ps_dec */
 decoding_envirnoment_t * ps_cab_env = &ps_dec->s_cab_dec_env;
 dec_bit_stream_t * ps_bitstrm = ps_dec->ps_bitstrm;
 ctxt_inc_mb_info_t *p_curr_ctxt = ps_dec->ps_curr_ctxt_mb_info;
 parse_pmbarams_t * ps_parse_mb_data = ps_dec->ps_parse_mb_data
 + u1_num_mbsNby2;

 /* table pointer loads */
 const UWORD8 * pu1_sub_mb_pred_modes = (UWORD8 *)(gau1_ih264d_submb_pred_modes)
 + 4;
 const UWORD8 (*pu1_mb_pred_modes)[32] =
 (const UWORD8 (*)[32])gau1_ih264d_mb_pred_modes;
 const UWORD8 *pu1_num_mb_part = (const UWORD8 *)gau1_ih264d_num_mb_part;
 const UWORD8 *pu1_sub_mb_mc_mode = (UWORD8 *)(gau1_ih264d_submb_mc_mode) + 4;

 const UWORD8 u1_mb_type = ps_cur_mb_info->u1_mb_type;
    UWORD8 * pu1_col_info = ps_parse_mb_data->u1_col_info;
    WORD8 *pi1_ref_idx_l0 = &ps_parse_mb_data->i1_ref_idx[0][0];
    WORD8 *pi1_ref_idx_l1 = &ps_parse_mb_data->i1_ref_idx[1][0];
    UWORD8 u1_dec_ref_l0, u1_dec_ref_l1;

    UWORD8 u1_num_mb_part, u1_mb_mc_mode, u1_sub_mb, u1_mbpred_mode = 5
 + u1_mb_type;
    UWORD32 u4_mb_mc_mode = 0, u4_mb_pred_mode = 0;
    WORD32 ret;

    p_curr_ctxt->u1_mb_type = CAB_NON_BD16x16;
    u1_sub_mb = !(u1_mb_type ^ B_8x8);

 {
        UWORD8 u1_mbaff = ps_dec->ps_cur_slice->u1_mbaff_frame_flag;
        UWORD8 *pu1_num_ref_idx_lx_active =
                        ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active;
        UWORD8 uc_field = ps_cur_mb_info->u1_mb_field_decodingflag;
        UWORD8 u1_mbaff_field = (u1_mbaff & uc_field);
        u1_dec_ref_l0 = (pu1_num_ref_idx_lx_active[0] << u1_mbaff_field) - 1;
        u1_dec_ref_l1 = (pu1_num_ref_idx_lx_active[1] << u1_mbaff_field) - 1;
 }

 if(u1_sub_mb)
 {
 const UWORD8 u1_colz = ((PRED_8x8) << 6);
        UWORD8 uc_i;
        u1_mb_mc_mode = 0;
        u1_num_mb_part = 4;
 /* Reading the subMB type */
 for(uc_i = 0; uc_i < 4; uc_i++)
 {
            UWORD8 u1_sub_mb_mode, u1_subMbPredModes;
            u1_sub_mb_mode = ih264d_parse_submb_type_cabac(
 1, ps_cab_env, ps_bitstrm,
                            ps_dec->p_sub_mb_type_t);

 if(u1_sub_mb_mode > 12)
 return ERROR_SUB_MB_TYPE;

            u1_subMbPredModes = pu1_sub_mb_pred_modes[u1_sub_mb_mode];
            u4_mb_mc_mode = (u4_mb_mc_mode << 8) | pu1_sub_mb_mc_mode[u1_sub_mb_mode];
            u4_mb_pred_mode = (u4_mb_pred_mode << 8) | u1_subMbPredModes;
 *pi1_ref_idx_l0++ =
 (u1_subMbPredModes & PRED_L0) ? u1_dec_ref_l0 : -1;
 *pi1_ref_idx_l1++ =
 (u1_subMbPredModes & PRED_L1) ? u1_dec_ref_l1 : -1;
            COPYTHECONTEXT("sub_mb_type", u1_sub_mb_mode);
 /* Storing collocated Mb and SubMb mode information */
 *pu1_col_info++ =
 (u1_colz | (pu1_sub_mb_mc_mode[u1_sub_mb_mode] << 4));
 if(u1_sub_mb_mode != B_DIRECT_8x8)
 {
 if(u1_sub_mb_mode > B_BI_8x8)
 {
                    ps_dec->s_high_profile.u1_no_submb_part_size_lt8x8_flag = 0;
 }
 }
 else if(!ps_dec->s_high_profile.u1_direct_8x8_inference_flag)
 {
                ps_dec->s_high_profile.u1_no_submb_part_size_lt8x8_flag = 0;
 }
 }
        pi1_ref_idx_l0 -= 4;
        pi1_ref_idx_l1 -= 4;
 }
 else
 {
        UWORD8 u1_mb_pred_mode_part0 = pu1_mb_pred_modes[0][u1_mbpred_mode];
        UWORD8 u1_mb_pred_mode_part1 = pu1_mb_pred_modes[1][u1_mbpred_mode];
        u1_mb_mc_mode = ps_cur_mb_info->u1_mb_mc_mode;
        u1_num_mb_part = pu1_num_mb_part[u1_mb_mc_mode];
 /* Storing collocated Mb and SubMb mode information */
 *pu1_col_info++ = (u1_mb_mc_mode << 6);
 if(u1_mb_mc_mode)
 *pu1_col_info++ = (u1_mb_mc_mode << 6);
        u4_mb_mc_mode = u1_mb_mc_mode | (u1_mb_mc_mode << 8);
        u4_mb_mc_mode <<= 16;
        u4_mb_pred_mode = ((u1_mb_pred_mode_part0 << 8) | u1_mb_pred_mode_part1) << 16;

 *pi1_ref_idx_l0++ = (u1_mb_pred_mode_part0 & PRED_L0) ? u1_dec_ref_l0 : -1;
 *pi1_ref_idx_l0-- = (u1_mb_pred_mode_part1 & PRED_L0) ? u1_dec_ref_l0 : -1;
 *pi1_ref_idx_l1++ = (u1_mb_pred_mode_part0 & PRED_L1) ? u1_dec_ref_l1 : -1;
 *pi1_ref_idx_l1-- = (u1_mb_pred_mode_part1 & PRED_L1) ? u1_dec_ref_l1 : -1;
 }
 {
        WORD8 *pi1_lft_cxt = ps_dec->pi1_left_ref_idx_ctxt_inc;
        WORD8 *pi1_top_cxt = p_curr_ctxt->i1_ref_idx;

        ret = ih264d_parse_ref_idx_cabac(u1_num_mb_part, 0, u1_dec_ref_l0,
                                   u1_mb_mc_mode, pi1_ref_idx_l0, pi1_lft_cxt,
                                   pi1_top_cxt, ps_cab_env, ps_bitstrm,
                                   ps_dec->p_ref_idx_t);
 if(ret != OK)
 return ret;

        ret = ih264d_parse_ref_idx_cabac(u1_num_mb_part, 2, u1_dec_ref_l1,
                                   u1_mb_mc_mode, pi1_ref_idx_l1, pi1_lft_cxt,
                                   pi1_top_cxt, ps_cab_env, ps_bitstrm,
                                   ps_dec->p_ref_idx_t);
 if(ret != OK)
 return ret;
 }
 /* Read MotionVectors */
 {
 const UWORD8 *pu1_top_left_sub_mb_indx;
        UWORD8 uc_j, uc_lx;
        UWORD8 u1_mb_part_wd, u1_mb_part_ht;

 const UWORD8 *pu1_sub_mb_indx_mod =
 (const UWORD8 *)gau1_ih264d_submb_indx_mod
 + (u1_sub_mb * 6);
 const UWORD8 *pu1_sub_mb_partw = (const UWORD8 *)gau1_ih264d_submb_partw;
 const UWORD8 *pu1_sub_mb_parth = (const UWORD8 *)gau1_ih264d_submb_parth;
 const UWORD8 *pu1_num_sub_mb_part =
 (const UWORD8 *)gau1_ih264d_num_submb_part;
 const UWORD8 *pu1_mb_partw = (const UWORD8 *)gau1_ih264d_mb_partw;
 const UWORD8 *pu1_mb_parth = (const UWORD8 *)gau1_ih264d_mb_parth;

        UWORD8 u1_p_idx = 0;
        UWORD8 u1_num_submb_part;
 parse_part_params_t *ps_part;
 /* Initialisations */
 mv_pred_t *ps_mv_start = ps_dec->ps_mv_cur + (u1_mb_num << 4);
        ps_part = ps_dec->ps_part;

 /* Default initialization for non subMb case */
        u1_mb_part_wd = pu1_mb_partw[u1_mb_mc_mode];
        u1_mb_part_ht = pu1_mb_parth[u1_mb_mc_mode];
        u1_num_submb_part = 1;

 /* Decoding the MV for the subMB */
 for(uc_lx = 0; uc_lx < 2; uc_lx++)
 {
            UWORD8 u1_sub_mb_num = 0;
            UWORD32 u4_mb_pred_mode_tmp = u4_mb_pred_mode;
            UWORD32 u4_mb_mc_mode_tmp = u4_mb_mc_mode;
            UWORD8 u1_mb_mc_mode_1, u1_pred_mode, uc_i;
            UWORD16 u2_sub_mb_num = 0x028A;
            UWORD8 u1_b2 = uc_lx << 1;
            u1_pred_mode = (uc_lx) ? PRED_L1 : PRED_L0;
 /* Default for Cabac */
            pu1_top_left_sub_mb_indx = pu1_sub_mb_indx_mod + (u1_mb_mc_mode << 1);
 for(uc_i = 0; uc_i < u1_num_mb_part; uc_i++)
 {

                WORD8 i1_pred = (UWORD8)(u4_mb_pred_mode_tmp >> 24);
                u1_mb_mc_mode_1 = (UWORD8)(u4_mb_mc_mode_tmp >> 24);
                u4_mb_pred_mode_tmp <<= 8;
                u4_mb_mc_mode_tmp <<= 8;

 /* subMb prediction mode */
 if(u1_sub_mb)
 {
                    u1_mb_part_wd = pu1_sub_mb_partw[u1_mb_mc_mode_1];
                    u1_mb_part_ht = pu1_sub_mb_parth[u1_mb_mc_mode_1];
                    u1_sub_mb_num = u2_sub_mb_num >> 12;
                    pu1_top_left_sub_mb_indx = pu1_sub_mb_indx_mod + (u1_mb_mc_mode_1 << 1);
                    u1_num_submb_part = pu1_num_sub_mb_part[u1_mb_mc_mode_1];
                    u2_sub_mb_num = u2_sub_mb_num << 4;
 }

 for(uc_j = 0; uc_j < u1_num_submb_part;
                                uc_j++, pu1_top_left_sub_mb_indx++)
 {
 mv_pred_t *ps_mv;
                    u1_sub_mb_num = u1_sub_mb_num + *pu1_top_left_sub_mb_indx;
                    ps_mv = ps_mv_start + u1_sub_mb_num;

 /* Storing Info for partitions, writing only once */
 if(uc_lx)
 {
                        ps_part->u1_is_direct = (!i1_pred);
                        ps_part->u1_pred_mode = i1_pred;
                        ps_part->u1_sub_mb_num = u1_sub_mb_num;
                        ps_part->u1_partheight = u1_mb_part_ht;
                        ps_part->u1_partwidth = u1_mb_part_wd;

 /* Increment partition Index */
                        u1_p_idx++;
                        ps_part++;
 }

                    ih264d_get_mvd_cabac(u1_sub_mb_num, u1_b2, u1_mb_part_wd,
                                         u1_mb_part_ht,
 (UWORD8)(i1_pred & u1_pred_mode), ps_dec,
                                         ps_mv);
 }
 }
 }
 /* write back to the scratch partition info */

        ps_dec->ps_part = ps_part;
        ps_parse_mb_data->u1_num_part = u1_sub_mb ? u1_p_idx : u1_num_mb_part;

 }

 return OK;
}

WORD32 ih264d_parse_islice(dec_struct_t *ps_dec,
UWORD16 u2_first_mb_in_slice)
{
dec_pic_params_t * ps_pps = ps_dec->ps_cur_pps;
dec_slice_params_t * ps_slice = ps_dec->ps_cur_slice;
UWORD32 *pu4_bitstrm_buf = ps_dec->ps_bitstrm->pu4_buffer;
UWORD32 *pu4_bitstrm_ofst = &ps_dec->ps_bitstrm->u4_ofst;
UWORD32 u4_temp;
WORD32 i_temp;
WORD32 ret;

/*--------------------------------------------------------------------*/
/* Read remaining contents of the slice header                        */
/*--------------------------------------------------------------------*/
/* dec_ref_pic_marking function */
/* G050 */

if(ps_slice->u1_nal_ref_idc != 0)
{
if(!ps_dec->ps_dpb_cmds->u1_dpb_commands_read)
            ps_dec->u4_bitoffset = ih264d_read_mmco_commands(
                            ps_dec);
else
ps_dec->ps_bitstrm->u4_ofst += ps_dec->u4_bitoffset;
}
/* G050 */

/* Read slice_qp_delta */
i_temp = ps_pps->u1_pic_init_qp
+ ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
if((i_temp < 0) || (i_temp > 51))
return ERROR_INV_RANGE_QP_T;
ps_slice->u1_slice_qp = i_temp;
COPYTHECONTEXT("SH: slice_qp_delta",
ps_slice->u1_slice_qp - ps_pps->u1_pic_init_qp);

if(ps_pps->u1_deblocking_filter_parameters_present_flag == 1)
{
u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
COPYTHECONTEXT("SH: disable_deblocking_filter_idc", u4_temp);

if(u4_temp > SLICE_BOUNDARY_DBLK_DISABLED)
{
return ERROR_INV_SLICE_HDR_T;
}
ps_slice->u1_disable_dblk_filter_idc = u4_temp;
if(u4_temp != 1)
{
i_temp = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf)
<< 1;
if((MIN_DBLK_FIL_OFF > i_temp) || (i_temp > MAX_DBLK_FIL_OFF))
{
return ERROR_INV_SLICE_HDR_T;
}
ps_slice->i1_slice_alpha_c0_offset = i_temp;
COPYTHECONTEXT("SH: slice_alpha_c0_offset_div2",
ps_slice->i1_slice_alpha_c0_offset >> 1);

i_temp = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf)
<< 1;
if((MIN_DBLK_FIL_OFF > i_temp) || (i_temp > MAX_DBLK_FIL_OFF))
{
return ERROR_INV_SLICE_HDR_T;
}
ps_slice->i1_slice_beta_offset = i_temp;
COPYTHECONTEXT("SH: slice_beta_offset_div2",
ps_slice->i1_slice_beta_offset >> 1);

}
else
{
ps_slice->i1_slice_alpha_c0_offset = 0;
ps_slice->i1_slice_beta_offset = 0;
}
}
else
{
ps_slice->u1_disable_dblk_filter_idc = 0;
ps_slice->i1_slice_alpha_c0_offset = 0;
ps_slice->i1_slice_beta_offset = 0;
}

/* Initialization to check if number of motion vector per 2 Mbs */
/* are exceeding the range or not */
ps_dec->u2_mv_2mb[0] = 0;
ps_dec->u2_mv_2mb[1] = 0;


/*set slice header cone to 2 ,to indicate  correct header*/
ps_dec->u1_slice_header_done = 2;

if(ps_pps->u1_entropy_coding_mode)
{
SWITCHOFFTRACE; SWITCHONTRACECABAC;
if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag)
{
ps_dec->pf_get_mb_info = ih264d_get_mb_info_cabac_mbaff;
}
else
ps_dec->pf_get_mb_info = ih264d_get_mb_info_cabac_nonmbaff;

ret = ih264d_parse_islice_data_cabac(ps_dec, ps_slice,
u2_first_mb_in_slice);
if(ret != OK)
return ret;
SWITCHONTRACE; SWITCHOFFTRACECABAC;
}
else
{
if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag)
{
ps_dec->pf_get_mb_info = ih264d_get_mb_info_cavlc_mbaff;
}
else
ps_dec->pf_get_mb_info = ih264d_get_mb_info_cavlc_nonmbaff;
ret = ih264d_parse_islice_data_cavlc(ps_dec, ps_slice,
u2_first_mb_in_slice);
if(ret != OK)
return ret;
}

return OK;
}

void ih264d_free_ref_pic_mv_bufs(void* pv_dec, UWORD8 pic_buf_id)
{
 dec_struct_t *ps_dec = (dec_struct_t *)pv_dec;

 if((pic_buf_id == ps_dec->u1_pic_buf_id) &&
                    ps_dec->ps_cur_slice->u1_field_pic_flag &&
 (ps_dec->u1_top_bottom_decoded == 0))
 {
 return;
 }

    ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,
                          pic_buf_id,
                          BUF_MGR_REF);
    ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,
                          ps_dec->au1_pic_buf_id_mv_buf_id_map[pic_buf_id],
                          BUF_MGR_REF);
}

WORD32 ih264d_parse_ipcm_mb(dec_struct_t * ps_dec,
 dec_mb_info_t *ps_cur_mb_info,
                          UWORD8 u1_mbNum)
{
 dec_bit_stream_t * const ps_bitstrm = ps_dec->ps_bitstrm;
    UWORD8 u1_mbaff = ps_dec->ps_cur_slice->u1_mbaff_frame_flag;
    UWORD8 *pu1_y, *pu1_u, *pu1_v;
    WORD32 ret;

    UWORD32 u4_rec_width_y, u4_rec_width_uv;
    UWORD32 u1_num_mb_pair;
    UWORD8 u1_x, u1_y;
 /* CHANGED CODE */
 tfr_ctxt_t *ps_frame_buf;
    UWORD8 u1_mb_field_decoding_flag;
    UWORD32 *pu4_buf;
    UWORD8 *pu1_buf;
 /* CHANGED CODE */

 if(ps_dec->u1_separate_parse)
 {
        ps_frame_buf = &ps_dec->s_tran_addrecon_parse;
 }
 else
 {
        ps_frame_buf = &ps_dec->s_tran_addrecon;
 }
 /* align bistream to byte boundary. */
 /* pcm_alignment_zero_bit discarded */
 /* For XX GotoByteBoundary */
 if(ps_bitstrm->u4_ofst & 0x07)
 {
        ps_bitstrm->u4_ofst += 8;
        ps_bitstrm->u4_ofst &= 0xFFFFFFF8;
 }

 /*  Store left Nnz as 16 for each 4x4 blk */

    pu1_buf = ps_dec->pu1_left_nnz_y;
    pu4_buf = (UWORD32 *)pu1_buf;
 *pu4_buf = 0x10101010;
    pu1_buf = ps_cur_mb_info->ps_curmb->pu1_nnz_y;
    pu4_buf = (UWORD32 *)pu1_buf;
 *pu4_buf = 0x10101010;
    pu1_buf = ps_cur_mb_info->ps_curmb->pu1_nnz_uv;
    pu4_buf = (UWORD32 *)pu1_buf;
 *pu4_buf = 0x10101010;
    pu1_buf = ps_dec->pu1_left_nnz_uv;
    pu4_buf = (UWORD32 *)pu1_buf;
 *pu4_buf = 0x10101010;
    ps_cur_mb_info->u1_cbp = 0xff;

    ps_dec->i1_prev_mb_qp_delta = 0;
 /* Get neighbour MB's */
    u1_num_mb_pair = (u1_mbNum >> u1_mbaff);

 /*****************************************************************************/
 /* calculate the RECON buffer YUV pointers for the PCM data                  */
 /*****************************************************************************/
 /* CHANGED CODE  */
    u1_mb_field_decoding_flag = ps_cur_mb_info->u1_mb_field_decodingflag;
    pu1_y = ps_frame_buf->pu1_dest_y + (u1_num_mb_pair << 4);
    pu1_u = ps_frame_buf->pu1_dest_u + (u1_num_mb_pair << 4);
    pu1_v = pu1_u + 1;

    u4_rec_width_y = ps_dec->u2_frm_wd_y << u1_mb_field_decoding_flag;
    u4_rec_width_uv = ps_dec->u2_frm_wd_uv << u1_mb_field_decoding_flag;
 /* CHANGED CODE  */

 if(u1_mbaff)
 {
        UWORD8 u1_top_mb;

        u1_top_mb = ps_cur_mb_info->u1_topmb;

 if(u1_top_mb == 0)
 {
            pu1_y += (u1_mb_field_decoding_flag ?
 (u4_rec_width_y >> 1) : (u4_rec_width_y << 4));
            pu1_u += (u1_mb_field_decoding_flag ?
 (u4_rec_width_uv) : (u4_rec_width_uv << 4));
            pu1_v = pu1_u + 1;
 }
 }

 /* Read Luma samples */
 for(u1_y = 0; u1_y < 16; u1_y++)
 {
 for(u1_x = 0; u1_x < 16; u1_x++)
            pu1_y[u1_x] = ih264d_get_bits_h264(ps_bitstrm, 8);

        pu1_y += u4_rec_width_y;
 }

 /* Read Chroma samples */
 for(u1_y = 0; u1_y < 8; u1_y++)
 {
 for(u1_x = 0; u1_x < 8; u1_x++)
            pu1_u[u1_x * YUV420SP_FACTOR] = ih264d_get_bits_h264(ps_bitstrm, 8);

        pu1_u += u4_rec_width_uv;
 }

 for(u1_y = 0; u1_y < 8; u1_y++)
 {
 for(u1_x = 0; u1_x < 8; u1_x++)
            pu1_v[u1_x * YUV420SP_FACTOR] = ih264d_get_bits_h264(ps_bitstrm, 8);

        pu1_v += u4_rec_width_uv;
 }

 if(CABAC == ps_dec->ps_cur_pps->u1_entropy_coding_mode)
 {
        UWORD32 *pu4_buf;
        UWORD8 *pu1_buf;
 ctxt_inc_mb_info_t *p_curr_ctxt = ps_dec->ps_curr_ctxt_mb_info;
 /* Re-initialize the cabac decoding engine. */
        ret = ih264d_init_cabac_dec_envirnoment(&(ps_dec->s_cab_dec_env), ps_bitstrm);
 if(ret != OK)
 return ret;
 /* update the cabac contetxs */
        p_curr_ctxt->u1_mb_type = CAB_I_PCM;
        p_curr_ctxt->u1_cbp = 47;
        p_curr_ctxt->u1_intra_chroma_pred_mode = 0;
        p_curr_ctxt->u1_transform8x8_ctxt = 0;
        ps_cur_mb_info->ps_curmb->u1_tran_form8x8 = 0;

        pu1_buf = ps_dec->pu1_left_nnz_y;
        pu4_buf = (UWORD32 *)pu1_buf;
 *pu4_buf = 0x01010101;

        pu1_buf = ps_cur_mb_info->ps_curmb->pu1_nnz_y;
        pu4_buf = (UWORD32 *)pu1_buf;
 *pu4_buf = 0x01010101;

        pu1_buf = ps_cur_mb_info->ps_curmb->pu1_nnz_uv;
        pu4_buf = (UWORD32 *)pu1_buf;
 *pu4_buf = 0x01010101;

        pu1_buf = ps_dec->pu1_left_nnz_uv;
        pu4_buf = (UWORD32 *)pu1_buf;
 *pu4_buf = 0x01010101;

        p_curr_ctxt->u1_yuv_dc_csbp = 0x7;
        ps_dec->pu1_left_yuv_dc_csbp[0] = 0x7;
 if(ps_dec->ps_cur_slice->u1_slice_type != I_SLICE)
 {

            MEMSET_16BYTES(&ps_dec->pu1_left_mv_ctxt_inc[0][0], 0);
            memset(ps_dec->pi1_left_ref_idx_ctxt_inc, 0, 4);
            MEMSET_16BYTES(p_curr_ctxt->u1_mv, 0);
            memset(p_curr_ctxt->i1_ref_idx, 0, 4);

 }
 }
 return OK;
}

WORD32 ih264d_mv_pred_ref_tfr_nby2_bmb(dec_struct_t * ps_dec,
                                     UWORD8 u1_mb_idx,
                                     UWORD8 u1_num_mbs)
{
 parse_pmbarams_t * ps_mb_part_info;
 parse_part_params_t * ps_part;
 mv_pred_t *ps_mv_nmb, *ps_mv_nmb_start, *ps_mv_ntop, *ps_mv_ntop_start;
 pic_buffer_t * ps_ref_frame;
    UWORD8 u1_direct_mode_width;
    UWORD8 i, j;
 dec_mb_info_t * ps_cur_mb_info;
 const UWORD8 u1_mbaff = ps_dec->ps_cur_slice->u1_mbaff_frame_flag;
    UWORD8 u1_field;
    WORD32 ret = 0;

    ps_dec->i4_submb_ofst -= (u1_num_mbs - u1_mb_idx) << 4;
    ps_mb_part_info = ps_dec->ps_parse_mb_data;
    ps_part = ps_dec->ps_parse_part_params;

 /* N/2 Mb MvPred and Transfer Setup Loop */
 for(i = u1_mb_idx; i < u1_num_mbs; i++, ps_mb_part_info++)
 {
        UWORD8 u1_colz = 0;
        ps_dec->i4_submb_ofst += SUB_BLK_SIZE;
 /* Restore the slice scratch MbX and MbY context */
        ps_cur_mb_info = ps_dec->ps_nmb_info + i;
        ps_dec->u2_wait_id = i;

        u1_field = ps_cur_mb_info->u1_mb_field_decodingflag;

        ps_mv_nmb_start = ps_dec->ps_mv_cur + (i << 4);
        ps_dec->u2_mbx = ps_cur_mb_info->u2_mbx;
        ps_dec->u2_mby = ps_cur_mb_info->u2_mby;
        ps_dec->u1_currB_type = 0;
        ps_dec->u2_mv_2mb[i & 0x1] = 0;

 /* Look for MV Prediction and Reference Transfer in Non-I Mbs */
 if(!ps_mb_part_info->u1_isI_mb)
 {
            UWORD8 u1_blk_no;
            WORD16 i1_ref_idx, i1_ref_idx1;
            UWORD8 u1_pred_mode;
            UWORD8 u1_sub_mb_x, u1_sub_mb_y, u1_sub_mb_num;
            UWORD8 u1_lx, u1_lx_start, u1_lxend, u1_tmp_lx;
            UWORD8 u1_num_part, u1_num_ref, u1_wd, u1_ht;
            UWORD32 *pu4_wt_offst;
            UWORD8 u1_scale_ref, u4_bot_mb;
 deblk_mb_t * ps_cur_deblk_mb = ps_dec->ps_deblk_mbn + i;
            WORD8 (*pi1_ref_idx)[MAX_REFIDX_INFO_PER_MB] =
                            ps_mb_part_info->i1_ref_idx;
            WORD8 *pi1_ref_idx0 = pi1_ref_idx[0],
 *pi1_ref_idx1 = pi1_ref_idx[1];
            UWORD32 **ppu4_wt_ofst = ps_mb_part_info->pu4_wt_offst;

 /* MB Level initialisations */
            ps_dec->u4_num_pmbair = i >> u1_mbaff;
            ps_dec->u1_mb_idx_mv = i;

 /* CHANGED CODE */
            ps_mv_ntop_start = ps_mv_nmb_start
 - (ps_dec->u2_frm_wd_in_mbs << (4 + u1_mbaff)) + 12;

            u1_num_part = ps_mb_part_info->u1_num_part;
            ps_cur_deblk_mb->u1_mb_type |= (u1_num_part > 1) << 1;
            u1_direct_mode_width = (1 == ps_mb_part_info->u1_num_part) ? 16 : 8;


            ps_cur_mb_info->u4_pred_info_pkd_idx = ps_dec->u4_pred_info_pkd_idx;
            ps_cur_mb_info->u1_num_pred_parts = 0;

 /****************************************************/
 /* weighted u4_ofst pointer calculations, this loop  */
 /* runs maximum 4 times, even in direct cases       */
 /****************************************************/
            u1_scale_ref = u1_mbaff & ps_cur_mb_info->u1_mb_field_decodingflag;
            u4_bot_mb = 1 - ps_cur_mb_info->u1_topmb;
 if(ps_dec->ps_cur_pps->u1_wted_bipred_idc)
 {
                u1_num_ref = MIN(u1_num_part, 4);
 if(PART_DIRECT_16x16 != ps_part->u1_is_direct)
 {
 for(u1_blk_no = 0; u1_blk_no < u1_num_ref; u1_blk_no++)
 {
                        i1_ref_idx = MAX(pi1_ref_idx0[u1_blk_no], 0);
 if(u1_scale_ref)
                            i1_ref_idx >>= 1;
                        i1_ref_idx *=
                                        ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[1];
 if(u1_scale_ref)
                            i1_ref_idx +=
 (MAX(pi1_ref_idx1[u1_blk_no], 0)
 >> 1);
 else
                            i1_ref_idx += MAX(pi1_ref_idx1[u1_blk_no], 0);
                        pu4_wt_offst = (UWORD32*)&ps_dec->pu4_wt_ofsts[2
 * X3(i1_ref_idx)];

 if(pi1_ref_idx0[u1_blk_no] < 0)
                            pu4_wt_offst += 1;

                        ppu4_wt_ofst[u1_blk_no] = pu4_wt_offst;
 if(u1_scale_ref
 && (ps_dec->ps_cur_pps->u1_wted_bipred_idc
 == 2))
 {
                            i1_ref_idx = MAX(pi1_ref_idx0[u1_blk_no], 0);
                            i1_ref_idx *=
 (ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[1]
 << 1);
                            i1_ref_idx += MAX(pi1_ref_idx1[u1_blk_no], 0);
 if(u4_bot_mb)
 {
                                i1_ref_idx +=
 (ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[0]
 << 1)
 * (ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[1]
 << 1);
 }
                            pu4_wt_offst = (UWORD32*)&ps_dec->pu4_mbaff_wt_mat[2
 * X3(i1_ref_idx)];
                            ppu4_wt_ofst[u1_blk_no] = pu4_wt_offst;
 }
 }
 }
 }

 /**************************************************/
 /* Loop on Partitions                             */
 /* direct mode is reflected as a single partition */
 /**************************************************/
 for(j = 0; j < u1_num_part; j++, ps_part++)
 {
                u1_sub_mb_num = ps_part->u1_sub_mb_num;
                ps_dec->u1_sub_mb_num = u1_sub_mb_num;

 if(PART_NOT_DIRECT != ps_part->u1_is_direct)
 {
 /**************************************************/
 /* Direct Mode, Call DecodeSpatial/TemporalDirect */
 /* only (those will in turn call FormMbPartInfo)  */
 /**************************************************/
                    ret = ps_dec->ps_cur_slice->pf_decodeDirect(ps_dec,
                                                                u1_direct_mode_width,
                                                                ps_cur_mb_info, i);
 if(ret != OK)
 return ret;
                    ps_cur_deblk_mb->u1_mb_type |= (ps_dec->u1_currB_type << 1);

 }
 else
 {
 mv_pred_t s_mvPred;
 /**************************************************/
 /* Non Direct Mode, Call Motion Vector Predictor  */
 /* and FormMbpartInfo                             */
 /**************************************************/
                    u1_sub_mb_x = u1_sub_mb_num & 0x03;
                    u1_sub_mb_y = u1_sub_mb_num >> 2;
                    u1_blk_no =
 (u1_num_part < 4) ?
                                                    j :
 (((u1_sub_mb_y >> 1) << 1)
 + (u1_sub_mb_x
 >> 1));

                    ps_mv_ntop = ps_mv_ntop_start + u1_sub_mb_x;
                    ps_mv_nmb = ps_mv_nmb_start + u1_sub_mb_num;

                    u1_pred_mode = ps_part->u1_pred_mode;
                    u1_wd = ps_part->u1_partwidth;
                    u1_ht = ps_part->u1_partheight;

                    u1_lx_start = 0;
                    u1_lxend = 2;
 if( PRED_L0 == u1_pred_mode)
 {
                        s_mvPred.i2_mv[2] = 0;
                        s_mvPred.i2_mv[3] = 0;
                        u1_lxend = 1;
 }
 if( PRED_L1 == u1_pred_mode)
 {
                        s_mvPred.i2_mv[0] = 0;
                        s_mvPred.i2_mv[1] = 0;
                        u1_lx_start = 1;
 }

 /* Populate the colpic info and reference frames */
                    s_mvPred.i1_ref_frame[0] = pi1_ref_idx0[u1_blk_no];
                    s_mvPred.i1_ref_frame[1] = pi1_ref_idx1[u1_blk_no];

                    ps_dec->pf_mvpred(ps_dec, ps_cur_mb_info, ps_mv_nmb, ps_mv_ntop,
 &s_mvPred, u1_sub_mb_num, u1_wd,
                                      u1_lx_start, u1_lxend,
                                      ps_cur_mb_info->u1_mb_mc_mode);

 /**********************************************************/
 /* Loop on number of predictors, 1 Each for Forw Backw    */
 /* Loop 2 times for BiDirect mode                         */
 /**********************************************************/
 for(u1_lx = u1_lx_start; u1_lx < u1_lxend; u1_lx++)
 {
                        WORD16 i2_mv_x, i2_mv_y;

 /********************************************************/
 /* Predict Mv                                           */
 /* Add Mv Residuals and store back                      */
 /********************************************************/
                        i1_ref_idx = s_mvPred.i1_ref_frame[u1_lx];
                        u1_tmp_lx = (u1_lx << 1);

                        i2_mv_x = ps_mv_nmb->i2_mv[u1_tmp_lx];
                        i2_mv_y = ps_mv_nmb->i2_mv[u1_tmp_lx + 1];

                        i2_mv_x += s_mvPred.i2_mv[u1_tmp_lx];
                        i2_mv_y += s_mvPred.i2_mv[u1_tmp_lx + 1];
                        s_mvPred.i2_mv[u1_tmp_lx] = i2_mv_x;
                        s_mvPred.i2_mv[u1_tmp_lx + 1] = i2_mv_y;

 /********************************************************/
 /* Transfer setup call                                  */
 /* convert RefIdx if it is MbAff                        */
 /* Pass Weight Offset and refFrame                      */
 /********************************************************/
                        i1_ref_idx1 = i1_ref_idx >> u1_scale_ref;
 if(u1_scale_ref && ((i1_ref_idx & 0x01) != u4_bot_mb))
                            i1_ref_idx1 += MAX_REF_BUFS;
                        ps_ref_frame =
                                        ps_dec->ps_ref_pic_buf_lx[u1_lx][i1_ref_idx1];

 /* Storing Colocated-Zero u4_flag */
 if(u1_lx == u1_lx_start)
 {
 /* Fill colocated info in MvPred structure */
                            s_mvPred.u1_col_ref_pic_idx =
                                            ps_ref_frame->u1_mv_buf_id;
                            s_mvPred.u1_pic_type = ps_ref_frame->u1_pic_type;

 /* Calculating colocated zero information */
                            u1_colz =
 (u1_field << 1)
 | ((i1_ref_idx == 0)
 && (ABS(i2_mv_x)
 <= 1)
 && (ABS(i2_mv_y)
 <= 1));
                            u1_colz |= ps_mb_part_info->u1_col_info[u1_blk_no];
 }

                        pu4_wt_offst = ppu4_wt_ofst[u1_blk_no];
 {
 pred_info_pkd_t *ps_pred_pkd;
                           WORD16 i2_mv[2];

                           i2_mv[0] = i2_mv_x;
                           i2_mv[1] = i2_mv_y;

                           ps_pred_pkd = ps_dec->ps_pred_pkd + ps_dec->u4_pred_info_pkd_idx;
                        ih264d_fill_pred_info(i2_mv,u1_wd,u1_ht,u1_sub_mb_num,u1_pred_mode,
                                        ps_pred_pkd,ps_ref_frame->u1_pic_buf_id,i1_ref_idx,pu4_wt_offst,
                                        ps_ref_frame->u1_pic_type);
                        ps_dec->u4_pred_info_pkd_idx++;
                        ps_cur_mb_info->u1_num_pred_parts++;


 }

 }
                    ih264d_rep_mv_colz(ps_dec, &s_mvPred, ps_mv_nmb,
                                       u1_sub_mb_num, u1_colz, u1_ht,
                                       u1_wd);
 }
 }

 }
 else
 {
 /* Set zero values in case of Intra Mbs */
 mv_pred_t s_mvPred =
 {
 { 0, 0, 0, 0 },
 { -1, -1 }, 0, 0};
 /* Storing colocated zero information */
            ih264d_rep_mv_colz(ps_dec, &s_mvPred, ps_mv_nmb_start, 0,
 (UWORD8)(u1_field << 1), 4, 4);
 }

 /*if num _cores is set to 3 ,compute bs will be done in another thread*/
 if(ps_dec->u4_num_cores < 3)
 {
 if(ps_dec->u4_app_disable_deblk_frm == 0)
                ps_dec->pf_compute_bs(ps_dec, ps_cur_mb_info,
 (UWORD16)(i >> u1_mbaff));
 }
 }
 return OK;
}
