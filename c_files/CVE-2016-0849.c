static int getFileStartAndLength(int fd, off_t *start_, size_t *length_)
{
 off_t start, end;
 size_t length;

    assert(start_ != NULL);
    assert(length_ != NULL);

    start = lseek(fd, 0L, SEEK_CUR);
    end = lseek(fd, 0L, SEEK_END);
 (void) lseek(fd, start, SEEK_SET);

 if (start == (off_t) -1 || end == (off_t) -1) {
        LOGE("could not determine length of file\n");
 return -1;
 }

    length = end - start;
 if (length == 0) {
        LOGE("file is empty\n");
 return -1;
 }

 *start_ = start;
 *length_ = length;

 return 0;
}

int sysMapFile(const char* fn, MemMapping* pMap)
{
    memset(pMap, 0, sizeof(*pMap));

 if (fn && fn[0] == '@') {
 FILE* mapf = fopen(fn+1, "r");
 if (mapf == NULL) {
            LOGV("Unable to open '%s': %s\n", fn+1, strerror(errno));
 return -1;
 }

 
         if (sysMapBlockFile(mapf, pMap) != 0) {
             LOGW("Map of '%s' failed\n", fn);
             return -1;
         }
 
        fclose(mapf);
 } else {
 int fd = open(fn, O_RDONLY, 0);
 if (fd < 0) {
            LOGE("Unable to open '%s': %s\n", fn, strerror(errno));
 return -1;
 }

 if (sysMapFD(fd, pMap) != 0) {
            LOGE("Map of '%s' failed\n", fn);
            close(fd);
 return -1;
 }

        close(fd);
 }
 return 0;
}

void sysReleaseMap(MemMapping* pMap)
{
 int i;
 for (i = 0; i < pMap->range_count; ++i) {
 if (munmap(pMap->ranges[i].addr, pMap->ranges[i].length) < 0) {
            LOGW("munmap(%p, %d) failed: %s\n",
                 pMap->ranges[i].addr, (int)pMap->ranges[i].length, strerror(errno));
 }
 }
    free(pMap->ranges);
    pMap->ranges = NULL;
    pMap->range_count = 0;
}
