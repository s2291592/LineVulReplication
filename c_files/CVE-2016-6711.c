static vpx_codec_err_t vp8_set_dbg_color_b_modes(vpx_codec_alg_priv_t *ctx,
                                                 va_list args) {
#if CONFIG_POSTPROC_VISUALIZER && CONFIG_POSTPROC
  ctx->dbg_color_b_modes_flag = va_arg(args, int);
 return VPX_CODEC_OK;
#else
 (void)ctx;
 (void)args;
 return VPX_CODEC_INCAPABLE;
#endif
}

static vpx_codec_err_t vp8_peek_si(const uint8_t *data,
 unsigned int data_sz,
 vpx_codec_stream_info_t *si) {
 return vp8_peek_si_internal(data, data_sz, si, NULL, NULL);
}

static vpx_codec_err_t vp8_set_dbg_color_mb_modes(vpx_codec_alg_priv_t *ctx,
                                                  va_list args) {
#if CONFIG_POSTPROC_VISUALIZER && CONFIG_POSTPROC
  ctx->dbg_color_mb_modes_flag = va_arg(args, int);
 return VPX_CODEC_OK;
#else
 (void)ctx;
 (void)args;
 return VPX_CODEC_INCAPABLE;
#endif
}

update_error_state(vpx_codec_alg_priv_t *ctx,
 const struct vpx_internal_error_info *error)
{
 vpx_codec_err_t res;

 if ((res = error->error_code))
        ctx->base.err_detail = error->has_detail
 ? error->detail
 : NULL;

 return res;
}

static vpx_codec_err_t vp8_destroy(vpx_codec_alg_priv_t *ctx)
{
    vp8_remove_decoder_instances(&ctx->yv12_frame_buffers);

    vpx_free(ctx);

 return VPX_CODEC_OK;
}

static vpx_codec_err_t vp8_set_decryptor(vpx_codec_alg_priv_t *ctx,
                                         va_list args)
{
    vpx_decrypt_init *init = va_arg(args, vpx_decrypt_init *);

 if (init)
 {
        ctx->decrypt_cb = init->decrypt_cb;
        ctx->decrypt_state = init->decrypt_state;
 }
 else
 {
        ctx->decrypt_cb = NULL;
        ctx->decrypt_state = NULL;
 }
 return VPX_CODEC_OK;
}

static vpx_codec_err_t image2yuvconfig(const vpx_image_t *img,
                                       YV12_BUFFER_CONFIG  *yv12)
{
 const int y_w = img->d_w;
 const int y_h = img->d_h;
 const int uv_w = (img->d_w + 1) / 2;
 const int uv_h = (img->d_h + 1) / 2;
 vpx_codec_err_t        res = VPX_CODEC_OK;
    yv12->y_buffer = img->planes[VPX_PLANE_Y];
    yv12->u_buffer = img->planes[VPX_PLANE_U];
    yv12->v_buffer = img->planes[VPX_PLANE_V];

    yv12->y_crop_width  = y_w;
    yv12->y_crop_height = y_h;
    yv12->y_width  = y_w;
    yv12->y_height = y_h;
    yv12->uv_crop_width = uv_w;
    yv12->uv_crop_height = uv_h;
    yv12->uv_width = uv_w;
    yv12->uv_height = uv_h;

    yv12->y_stride = img->stride[VPX_PLANE_Y];
    yv12->uv_stride = img->stride[VPX_PLANE_U];

    yv12->border  = (img->stride[VPX_PLANE_Y] - img->d_w) / 2;
 return res;
}

static void yuvconfig2image(vpx_image_t *img,
 const YV12_BUFFER_CONFIG  *yv12,
 void *user_priv)
{
 /** vpx_img_wrap() doesn't allow specifying independent strides for
      * the Y, U, and V planes, nor other alignment adjustments that
      * might be representable by a YV12_BUFFER_CONFIG, so we just
      * initialize all the fields.*/
    img->fmt = VPX_IMG_FMT_I420;
    img->w = yv12->y_stride;
    img->h = (yv12->y_height + 2 * VP8BORDERINPIXELS + 15) & ~15;
    img->d_w = yv12->y_width;
    img->d_h = yv12->y_height;
    img->x_chroma_shift = 1;
    img->y_chroma_shift = 1;
    img->planes[VPX_PLANE_Y] = yv12->y_buffer;
    img->planes[VPX_PLANE_U] = yv12->u_buffer;
    img->planes[VPX_PLANE_V] = yv12->v_buffer;
    img->planes[VPX_PLANE_ALPHA] = NULL;
    img->stride[VPX_PLANE_Y] = yv12->y_stride;
    img->stride[VPX_PLANE_U] = yv12->uv_stride;
    img->stride[VPX_PLANE_V] = yv12->uv_stride;
    img->stride[VPX_PLANE_ALPHA] = yv12->y_stride;
    img->bit_depth = 8;
    img->bps = 12;
    img->user_priv = user_priv;
    img->img_data = yv12->buffer_alloc;
    img->img_data_owner = 0;
    img->self_allocd = 0;
}

static unsigned long vp8_priv_sz(const vpx_codec_dec_cfg_t *si, vpx_codec_flags_t flags)
{
 /* Although this declaration is constant, we can't use it in the requested
     * segments list because we want to define the requested segments list
     * before defining the private type (so that the number of memory maps is
     * known)
     */
 (void)si;
 (void)flags;
 return sizeof(vpx_codec_alg_priv_t);
}

static vpx_codec_err_t vp8_set_postproc(vpx_codec_alg_priv_t *ctx,
                                        va_list args)
{
#if CONFIG_POSTPROC
 vp8_postproc_cfg_t *data = va_arg(args, vp8_postproc_cfg_t *);

 if (data)
 {
        ctx->postproc_cfg_set = 1;
        ctx->postproc_cfg = *((vp8_postproc_cfg_t *)data);
 return VPX_CODEC_OK;
 }
 else
 return VPX_CODEC_INVALID_PARAM;

#else
 (void)ctx;
 (void)args;
 return VPX_CODEC_INCAPABLE;
#endif
}

static vpx_codec_err_t vp8_get_si(vpx_codec_alg_priv_t *ctx,
 vpx_codec_stream_info_t *si)
{

 unsigned int sz;

 if (si->sz >= sizeof(vp8_stream_info_t))
        sz = sizeof(vp8_stream_info_t);
 else
        sz = sizeof(vpx_codec_stream_info_t);

    memcpy(si, &ctx->si, sz);
    si->sz = sz;

 return VPX_CODEC_OK;
}

static vpx_image_t *vp8_get_frame(vpx_codec_alg_priv_t *ctx,
 vpx_codec_iter_t *iter)
{
 vpx_image_t *img = NULL;

 /* iter acts as a flip flop, so an image is only returned on the first
     * call to get_frame.
     */
 if (!(*iter) && ctx->yv12_frame_buffers.pbi[0])
 {
        YV12_BUFFER_CONFIG sd;
 int64_t time_stamp = 0, time_end_stamp = 0;
 vp8_ppflags_t flags = {0};

 if (ctx->base.init_flags & VPX_CODEC_USE_POSTPROC)
 {
            flags.post_proc_flag= ctx->postproc_cfg.post_proc_flag
#if CONFIG_POSTPROC_VISUALIZER

 | ((ctx->dbg_color_ref_frame_flag != 0) ? VP8D_DEBUG_CLR_FRM_REF_BLKS : 0)
 | ((ctx->dbg_color_mb_modes_flag != 0) ? VP8D_DEBUG_CLR_BLK_MODES : 0)
 | ((ctx->dbg_color_b_modes_flag != 0) ? VP8D_DEBUG_CLR_BLK_MODES : 0)
 | ((ctx->dbg_display_mv_flag != 0) ? VP8D_DEBUG_DRAW_MV : 0)
#endif
 ;
            flags.deblocking_level      = ctx->postproc_cfg.deblocking_level;
            flags.noise_level           = ctx->postproc_cfg.noise_level;
#if CONFIG_POSTPROC_VISUALIZER
            flags.display_ref_frame_flag= ctx->dbg_color_ref_frame_flag;
            flags.display_mb_modes_flag = ctx->dbg_color_mb_modes_flag;
            flags.display_b_modes_flag  = ctx->dbg_color_b_modes_flag;
            flags.display_mv_flag       = ctx->dbg_display_mv_flag;
#endif
 }

 if (0 == vp8dx_get_raw_frame(ctx->yv12_frame_buffers.pbi[0], &sd,
 &time_stamp, &time_end_stamp, &flags))
 {
            yuvconfig2image(&ctx->img, &sd, ctx->user_priv);

            img = &ctx->img;
 *iter = img;
 }
 }

 return img;
}

static vpx_codec_err_t vp8_get_reference(vpx_codec_alg_priv_t *ctx,
                                         va_list args)
{

 vpx_ref_frame_t *data = va_arg(args, vpx_ref_frame_t *);

 if (data && !ctx->yv12_frame_buffers.use_frame_threads)
 {
 vpx_ref_frame_t *frame = (vpx_ref_frame_t *)data;
        YV12_BUFFER_CONFIG sd;

        image2yuvconfig(&frame->img, &sd);

 return vp8dx_get_reference(ctx->yv12_frame_buffers.pbi[0],
                                   frame->frame_type, &sd);
 }
 else
 return VPX_CODEC_INVALID_PARAM;

}

static vpx_codec_err_t vp8_set_dbg_color_ref_frame(vpx_codec_alg_priv_t *ctx,
                                                   va_list args) {
#if CONFIG_POSTPROC_VISUALIZER && CONFIG_POSTPROC
  ctx->dbg_color_ref_frame_flag = va_arg(args, int);
 return VPX_CODEC_OK;
#else
 (void)ctx;
 (void)args;
 return VPX_CODEC_INCAPABLE;
#endif
}
