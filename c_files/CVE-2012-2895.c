GDataCacheMetadataMap::GDataCacheMetadataMap(
    base::SequencedWorkerPool* pool,
    const base::SequencedWorkerPool::SequenceToken& sequence_token)
    : GDataCacheMetadata(pool, sequence_token) {
  AssertOnSequencedWorkerPool();
}

void DownloadItemImpl::OnDownloadRenamedToFinalName(
DownloadFileManager* file_manager,
const FilePath& full_path) {
DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

VLOG(20) << __FUNCTION__ << "()"
<< " full_path = \"" << full_path.value() << "\""
<< " needed rename = " << NeedsRename()
<< " " << DebugString(false);
DCHECK(NeedsRename());

  if (!full_path.empty()) {
    // full_path is now the current and target file path.
    target_path_ = full_path;
    SetFullPath(full_path);
    delegate_->DownloadRenamedToFinalName(this);

    if (delegate_->ShouldOpenDownload(this))
      Completed();
    else
      delegate_delayed_complete_ = true;

    BrowserThread::PostTask(
        BrowserThread::FILE, FROM_HERE,
        base::Bind(&DownloadFileManager::CompleteDownload,
                   file_manager, GetGlobalId()));
  }
}

void ChromeDownloadManagerDelegate::RemoveItemFromPersistentStore(
    DownloadItem* item) {
  download_history_->RemoveEntry(item);
}

  FadeOutAnimationDelegate(LauncherView* host, views::View* view)
      : launcher_view_(host),
        view_(view) {}

int64 DownloadItemImpl::CurrentSpeed() const {
  if (is_paused_)
    return 0;
  return bytes_per_sec_;
}

  DownloadItem* CreateDownloadItem(DownloadItem::DownloadState state) {
    scoped_ptr<DownloadCreateInfo> info_;

    info_.reset(new DownloadCreateInfo());
    static int next_id;
    info_->download_id =
        content::DownloadId(kValidDownloadItemIdDomain, ++next_id);
    info_->prompt_user_for_save_location = false;
    info_->url_chain.push_back(GURL());
    info_->state = state;

    scoped_ptr<DownloadRequestHandleInterface> request_handle(
        new testing::NiceMock<MockRequestHandle>);
    DownloadItem* download =
        new DownloadItemImpl(&delegate_, *(info_.get()),
                             request_handle.Pass(), false, net::BoundNetLog());
    allocated_downloads_.insert(download);
    return download;
  }

void GDataCache::Pin(const std::string& resource_id,
const std::string& md5,
FileOperationType file_operation_type,
base::PlatformFileError* error) {
AssertOnSequencedWorkerPool();
DCHECK(error);

FilePath source_path;
FilePath dest_path;
FilePath symlink_path;
bool create_symlink = true;
int cache_state = CACHE_STATE_PINNED;
CacheSubDirectoryType sub_dir_type = CACHE_TYPE_PERSISTENT;

scoped_ptr<CacheEntry> cache_entry = GetCacheEntry(resource_id, md5);

if (!cache_entry.get()) {  // Entry does not exist in cache.
// Set both |dest_path| and |source_path| to /dev/null, so that:
// 1) ModifyCacheState won't move files when |source_path| and |dest_path|
//    are the same.
// 2) symlinks to /dev/null will be picked up by GDataSyncClient to download
//    pinned files that don't exist in cache.
    dest_path = FilePath::FromUTF8Unsafe(util::kSymLinkToDevNull);
source_path = dest_path;

// Set sub_dir_type to PINNED to indicate that the file doesn't exist.
// When the file is finally downloaded and StoreToCache called, it will be
// moved to persistent directory.
sub_dir_type = CACHE_TYPE_PINNED;
} else {  // File exists in cache, determines destination path.
cache_state |= cache_entry->cache_state;

// Determine source and destination paths.

// If file is dirty or mounted, don't move it, so determine |dest_path| and
// set |source_path| the same, because ModifyCacheState only moves files if
// source and destination are different.
if (cache_entry->IsDirty() || cache_entry->IsMounted()) {
DCHECK_EQ(CACHE_TYPE_PERSISTENT, cache_entry->sub_dir_type);
dest_path = GetCacheFilePath(resource_id,
md5,
cache_entry->sub_dir_type,
CACHED_FILE_LOCALLY_MODIFIED);
source_path = dest_path;
} else {
// Gets the current path of the file in cache.
source_path = GetCacheFilePath(resource_id,
md5,
cache_entry->sub_dir_type,
CACHED_FILE_FROM_SERVER);

// If file was pinned before but actual file blob doesn't exist in cache:
// - don't need to move the file, so set |dest_path| to |source_path|,
//   because ModifyCacheState only moves files if source and destination
//   are different
// - don't create symlink since it already exists.
if (cache_entry->sub_dir_type == CACHE_TYPE_PINNED) {
dest_path = source_path;
create_symlink = false;
} else {  // File exists, move it to persistent dir.
dest_path = GetCacheFilePath(resource_id,
md5,
CACHE_TYPE_PERSISTENT,
CACHED_FILE_FROM_SERVER);
}
}
}

// Create symlink in pinned dir.
if (create_symlink) {
symlink_path = GetCacheFilePath(resource_id,
std::string(),
CACHE_TYPE_PINNED,
CACHED_FILE_FROM_SERVER);
}

*error = ModifyCacheState(source_path,
dest_path,
file_operation_type,
symlink_path,
create_symlink);

if (*error == base::PLATFORM_FILE_OK) {
// Now that file operations have completed, update cache map.
metadata_->UpdateCache(resource_id, md5, sub_dir_type, cache_state);
}
}

  DownloadProtectionService::DownloadCheckResult verdict() const {
    return verdict_;
  }

void DownloadItemImpl::ProgressComplete(int64 bytes_so_far,
                                        const std::string& final_hash) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  hash_ = final_hash;
  hash_state_ = "";

  received_bytes_ = bytes_so_far;

  if (received_bytes_ > total_bytes_)
     total_bytes_ = 0;
 }

void ChromeDownloadManagerDelegate::CheckIfSuggestedPathExists(
    int32 download_id,
    const FilePath& unverified_path,
    bool should_prompt,
    bool is_forced_path,
    content::DownloadDangerType danger_type,
    const FilePath& default_path) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::FILE));

  FilePath target_path(unverified_path);

  file_util::CreateDirectory(default_path);

  FilePath dir = target_path.DirName();
  FilePath filename = target_path.BaseName();
  if (!file_util::PathIsWritable(dir)) {
    VLOG(1) << "Unable to write to directory \"" << dir.value() << "\"";
    should_prompt = true;
    PathService::Get(chrome::DIR_USER_DOCUMENTS, &dir);
    target_path = dir.Append(filename);
  }


  bool should_uniquify =
      (!is_forced_path &&
       (danger_type == content::DOWNLOAD_DANGER_TYPE_NOT_DANGEROUS ||
        should_prompt));
  bool should_overwrite =
      (should_uniquify || is_forced_path);
  bool should_create_marker = (should_uniquify && !should_prompt);

  if (should_uniquify) {
     int uniquifier =
        download_util::GetUniquePathNumberWithCrDownload(target_path);

    if (uniquifier > 0) {
      target_path = target_path.InsertBeforeExtensionASCII(
          StringPrintf(" (%d)", uniquifier));
    } else if (uniquifier == -1) {
      VLOG(1) << "Unable to find a unique path for suggested path \""
              << target_path.value() << "\"";
      should_prompt = true;
    }
  }

  if (should_create_marker)
    file_util::WriteFile(download_util::GetCrDownloadPath(target_path), "", 0);

  DownloadItem::TargetDisposition disposition;
  if (should_prompt)
    disposition = DownloadItem::TARGET_DISPOSITION_PROMPT;
  else if (should_overwrite)
    disposition = DownloadItem::TARGET_DISPOSITION_OVERWRITE;
  else
    disposition = DownloadItem::TARGET_DISPOSITION_UNIQUIFY;

  BrowserThread::PostTask(
      BrowserThread::UI, FROM_HERE,
      base::Bind(&ChromeDownloadManagerDelegate::OnPathExistenceAvailable,
                 this, download_id, target_path, disposition, danger_type));
}

bool DownloadItemImpl::IsOtr() const { return is_otr_; }

  int activated_command_id() const { return activated_command_id_; }

MockDownloadManagerDelegate::MockDownloadManagerDelegate() { }

void GDataCache::GetCacheEntryOnUIThread(
    const std::string& resource_id,
    const std::string& md5,
    const GetCacheEntryCallback& callback) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  bool* success = new bool(false);
  GDataCache::CacheEntry* cache_entry = new GDataCache::CacheEntry;
  pool_->GetSequencedTaskRunner(sequence_token_)->PostTaskAndReply(
      FROM_HERE,
      base::Bind(&GDataCache::GetCacheEntryHelper,
                 base::Unretained(this),
                 resource_id,
                 md5,
                 success,
                 cache_entry),
      base::Bind(&RunGetCacheEntryCallback,
                 callback,
                 base::Owned(success),
                 base::Owned(cache_entry)));
}

  MockDownloadFileManager& GetMockDownloadFileManager() {
    return *mock_download_file_manager_;
  }

gfx::Size Launcher::DelegateView::GetPreferredSize() {
  return child_count() > 0 ? child_at(0)->GetPreferredSize() : gfx::Size();
}

void CollectExistingPinnedFile(std::vector<std::string>* resource_ids,
                               const std::string& resource_id,
                               const GDataCache::CacheEntry& cache_entry) {
  DCHECK(resource_ids);

  if (cache_entry.IsPinned() && cache_entry.IsPresent())
    resource_ids->push_back(resource_id);
}

bool DownloadItemImpl::GetOpened() const { return opened_; }

void GDataCache::UnpinOnUIThread(const std::string& resource_id,
                                 const std::string& md5,
                                 const CacheOperationCallback& callback) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  base::PlatformFileError* error =
      new base::PlatformFileError(base::PLATFORM_FILE_OK);
  pool_->GetSequencedTaskRunner(sequence_token_)->PostTaskAndReply(
      FROM_HERE,
      base::Bind(&GDataCache::Unpin,
                 base::Unretained(this),
                 resource_id,
                 md5,
                 GDataCache::FILE_OPERATION_MOVE,
                 error),
      base::Bind(&GDataCache::OnUnpinned,
                 ui_weak_ptr_,
                 base::Owned(error),
                 resource_id,
                 md5,
                 callback));
}

    ChromeDownloadManagerDelegate::GetDownloadProtectionService() {
#if defined(ENABLE_SAFE_BROWSING)
  SafeBrowsingService* sb_service = g_browser_process->safe_browsing_service();
  if (sb_service && sb_service->download_protection_service() &&
      profile_->GetPrefs()->GetBoolean(prefs::kSafeBrowsingEnabled)) {
    return sb_service->download_protection_service();
  }
#endif
  return NULL;
}

ui::TouchStatus ShelfLayoutManager::AutoHideEventFilter::PreHandleTouchEvent(
    aura::Window* target,
    aura::TouchEvent* event) {
  return ui::TOUCH_STATUS_UNKNOWN;  // Not handled.
}

  SafeBrowsingState()
    : verdict_(DownloadProtectionService::SAFE) {
  }

void Launcher::RemoveIconObserver(LauncherIconObserver* observer) {
  launcher_view_->RemoveIconObserver(observer);
}

void DownloadItemImpl::MockDownloadOpenForTesting() { open_enabled_ = false; }

  ~TestDownloadManager() {}

void ShelfLayoutManager::OnLockStateChanged(bool locked) {
  UpdateVisibilityState();
}

void ShelfLayoutManager::UpdateHitTestBounds() {
  gfx::Insets insets;
  if (state_.visibility_state == VISIBLE) {
    switch (alignment_) {
      case SHELF_ALIGNMENT_BOTTOM:
        insets.Set(kWorkspaceAreaBottomInset, 0, 0, 0);
        break;
      case SHELF_ALIGNMENT_LEFT:
        insets.Set(0, 0, 0, kWorkspaceAreaBottomInset);
        break;
      case SHELF_ALIGNMENT_RIGHT:
        insets.Set(0, kWorkspaceAreaBottomInset, 0, 0);
        break;
    }
  }
  if (launcher_widget() && launcher_widget()->GetNativeWindow())
    launcher_widget()->GetNativeWindow()->set_hit_test_bounds_override_outer(
        insets);
  status_->GetNativeWindow()->set_hit_test_bounds_override_outer(insets);
}

  virtual void SetUp() {
    download_manager_ = new TestDownloadManager();
    request_handle_.reset(new MockDownloadRequestHandle(download_manager_));
    download_file_factory_ = new MockDownloadFileFactory;
    download_file_manager_ = new DownloadFileManager(download_file_factory_);
  }

DownloadItemImpl::GetExternalData(const void* key) const {
  std::map<const void*, ExternalData*>::const_iterator it =
      external_data_map_.find(key);
  return (it == external_data_map_.end()) ? NULL : it->second;
}

void GDataCacheMetadataMap::RemoveFromCache(const std::string& resource_id) {
  AssertOnSequencedWorkerPool();

  CacheMap::iterator iter = cache_map_.find(resource_id);
  if (iter != cache_map_.end()) {
    cache_map_.erase(iter);
  }
}

 void LauncherView::OnBoundsAnimatorDone(views::BoundsAnimator* animator) {
}

void DownloadItemImpl::OnAllDataSaved(
    int64 size, const std::string& final_hash) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  DCHECK(!all_data_saved_);
  all_data_saved_ = true;
  ProgressComplete(size, final_hash);
  UpdateObservers();
}

GDataCache* GDataCache::CreateGDataCacheOnUIThread(
    const FilePath& cache_root_path,
    base::SequencedWorkerPool* pool,
    const base::SequencedWorkerPool::SequenceToken& sequence_token) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  return new GDataCache(cache_root_path, pool, sequence_token);
}

DownloadFile* DownloadFileManager::GetDownloadFile(
    DownloadId global_id) {
  DownloadFileMap::iterator it = downloads_.find(global_id);
  return it == downloads_.end() ? NULL : it->second;
}

bool HasEnoughSpaceFor(int64 num_bytes) {
  int64 free_space = GetAmountOfFreeDiskSpace();
  free_space -= kMinFreeSpace;
  return (free_space >= num_bytes);
}

  MockDownloadFileFactory() {}

void DownloadItemImpl::OnContentCheckCompleted(
    content::DownloadDangerType danger_type) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  DCHECK(AllDataSaved());
  SetDangerType(danger_type);
}

void GDataCache::MarkDirty(const std::string& resource_id,
                           const std::string& md5,
                           FileOperationType file_operation_type,
                           base::PlatformFileError* error,
                           FilePath* cache_file_path) {
  AssertOnSequencedWorkerPool();
  DCHECK(error);
  DCHECK(cache_file_path);

  scoped_ptr<CacheEntry> cache_entry =
      GetCacheEntry(resource_id, std::string());

  if (!cache_entry.get() ||
      cache_entry->sub_dir_type == CACHE_TYPE_PINNED) {
    LOG(WARNING) << "Can't mark dirty a file that wasn't cached: res_id="
                 << resource_id
                 << ", md5=" << md5;
    *error = base::PLATFORM_FILE_ERROR_NOT_FOUND;
    return;
  }

  if (cache_entry->IsDirty()) {
    DCHECK_EQ(CACHE_TYPE_PERSISTENT, cache_entry->sub_dir_type);

    FilePath symlink_path = GetCacheFilePath(
        resource_id,
        std::string(),
        CACHE_TYPE_OUTGOING,
        CACHED_FILE_FROM_SERVER);

    *error = ModifyCacheState(
        FilePath(),  // non-applicable source path
        FilePath(),  // non-applicable dest path
        file_operation_type,
        symlink_path,
        false /* don't create symlink */);

    if (*error == base::PLATFORM_FILE_OK) {
      *cache_file_path = GetCacheFilePath(
          resource_id,
          md5,
          CACHE_TYPE_PERSISTENT,
          CACHED_FILE_LOCALLY_MODIFIED);
    }
    return;
  }


  FilePath source_path = GetCacheFilePath(
      resource_id,
      md5,
      cache_entry->sub_dir_type,
      CACHED_FILE_FROM_SERVER);

  CacheSubDirectoryType sub_dir_type = CACHE_TYPE_PERSISTENT;
  *cache_file_path = GetCacheFilePath(resource_id,
                                      md5,
                                      sub_dir_type,
                                      CACHED_FILE_LOCALLY_MODIFIED);

  FilePath symlink_path;
  if (cache_entry->IsPinned()) {
    symlink_path = GetCacheFilePath(resource_id,
                                    std::string(),
                                    CACHE_TYPE_PINNED,
                                    CACHED_FILE_FROM_SERVER);
  }

  *error = ModifyCacheState(
      source_path,
      *cache_file_path,
      file_operation_type,
      symlink_path,
      !symlink_path.empty() /* create symlink */);

  if (*error == base::PLATFORM_FILE_OK) {
    int cache_state = SetCacheDirty(cache_entry->cache_state);
    metadata_->UpdateCache(resource_id, md5, sub_dir_type, cache_state);
  }
}

views::FocusTraversable* LauncherView::GetFocusTraversableParent() {
  return parent()->GetFocusTraversable();
}

const std::vector<GURL>& DownloadItemImpl::GetUrlChain() const {
  return url_chain_;
}

void ShelfLayoutManager::SetChildBounds(aura::Window* child,
                                        const gfx::Rect& requested_bounds) {
  SetChildBoundsDirect(child, requested_bounds);
  if (!in_layout_)
    LayoutShelf();
}

GDataCacheMetadata::~GDataCacheMetadata() {
  AssertOnSequencedWorkerPool();
}

MockDownloadItemFactory::MockDownloadItemFactory() {}

DownloadItem::TargetDisposition DownloadItemImpl::GetTargetDisposition() const {
  return target_disposition_;
}

void SetUpCacheMetadata() {
metadata_.reset(new GDataCacheMetadataMap(
NULL, base::SequencedWorkerPool::SequenceToken()));
    metadata_->Initialize(cache_paths_);
  }

bool ShelfLayoutManager::IsShelfWindow(aura::Window* window) {
  if (!window)
    return false;
  return (launcher_widget() &&
          launcher_widget()->GetNativeWindow()->Contains(window)) ||
      (status_ && status_->GetNativeWindow()->Contains(window));
}

void ChromeDownloadManagerDelegate::OnItemAddedToPersistentStore(
    int32 download_id, int64 db_handle) {
  if (db_handle == DownloadItem::kUninitializedHandle)
    db_handle = download_history_->GetNextFakeDbHandle();
  download_manager_->OnItemAddedToPersistentStore(download_id, db_handle);
}

void DownloadItemImpl::MaybeCompleteDownload() {
  delegate_->MaybeCompleteDownload(this);
}

void DownloadItemImpl::OnTargetPathDetermined(
    const FilePath& target_path,
    TargetDisposition disposition,
    content::DownloadDangerType danger_type) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  target_path_ = target_path;
  target_disposition_ = disposition;
  SetDangerType(danger_type);
}

void DownloadItemImpl::DangerousDownloadValidated() {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  DCHECK_EQ(DANGEROUS, GetSafetyState());

  UMA_HISTOGRAM_ENUMERATION("Download.DangerousDownloadValidated",
                            GetDangerType(),
                            content::DOWNLOAD_DANGER_TYPE_MAX);

  safety_state_ = DANGEROUS_BUT_VALIDATED;

  bound_net_log_.AddEvent(
      net::NetLog::TYPE_DOWNLOAD_ITEM_SAFETY_STATE_UPDATED,
      base::Bind(&download_net_logs::ItemCheckedCallback,
                 GetDangerType(), GetSafetyState()));

  UpdateObservers();

  delegate_->MaybeCompleteDownload(this);
}

void DownloadItemImpl::SetTotalBytes(int64 total_bytes) {
  total_bytes_ = total_bytes;
}

bool ChromeDownloadManagerDelegate::ShouldStartDownload(int32 download_id) {
  DownloadItem* download =
      download_manager_->GetActiveDownloadItem(download_id);
  if (!download)
    return false;

#if defined(ENABLE_SAFE_BROWSING)
  DownloadProtectionService* service = GetDownloadProtectionService();
  if (service) {
    VLOG(2) << __FUNCTION__ << "() Start SB URL check for download = "
            << download->DebugString(false);
    service->CheckDownloadUrl(
        DownloadProtectionService::DownloadInfo::FromDownloadItem(*download),
        base::Bind(
            &ChromeDownloadManagerDelegate::CheckDownloadUrlDone,
            this,
            download->GetId()));
    return false;
  }
#endif
  CheckDownloadUrlDone(download_id, DownloadProtectionService::SAFE);
  return false;
}

 void DownloadItemImpl::OnDownloadRenamedToIntermediateName(
    const FilePath& full_path) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  if (!full_path.empty()) {
    SetFullPath(full_path);
    UpdateObservers();
  }
  delegate_->DownloadRenamedToIntermediateName(this);
}

void ChromeDownloadManagerDelegate::ChooseSavePath(
    WebContents* web_contents,
    const FilePath& suggested_path,
    const FilePath::StringType& default_extension,
    bool can_save_as_complete,
    const content::SavePackagePathPickedCallback& callback) {
#if defined(OS_CHROMEOS)
  new SavePackageFilePickerChromeOS(web_contents, suggested_path, callback);
#else
  new SavePackageFilePicker(web_contents, suggested_path, default_extension,
      can_save_as_complete, download_prefs_.get(), callback);
#endif
}

static void DeleteDownloadedFile(const FilePath& path) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::FILE));

  if (!file_util::DirectoryExists(path))
    file_util::Delete(path, false);
}

void RenameFile(const DownloadId& id,
const FilePath& new_path,
const FilePath& unique_path,
net::Error rename_error,
RenameFileState state,
RenameFileOverwrite should_overwrite) {
MockDownloadFile* file = download_file_factory_->GetExistingFile(id);
ASSERT_TRUE(file != NULL);

EXPECT_CALL(*file, Rename(unique_path))
.Times(1)
.WillOnce(Return(rename_error));

if (rename_error != net::OK) {
EXPECT_CALL(*file, BytesSoFar())
.Times(AtLeast(1))
.WillRepeatedly(Return(byte_count_[id]));
EXPECT_CALL(*file, GetHashState())
.Times(AtLeast(1));
EXPECT_CALL(*file, GetDownloadManager())
.Times(AtLeast(1));
    } else if (state == COMPLETE) {
#if defined(OS_MACOSX)
      EXPECT_CALL(*file, AnnotateWithSourceInformation());
#endif
}

    if (state == IN_PROGRESS) {
      download_file_manager_->RenameInProgressDownloadFile(
          id, new_path, (should_overwrite == OVERWRITE),
          base::Bind(&TestDownloadManager::OnDownloadRenamed,
                     download_manager_, id.local()));
    } else {  // state == COMPLETE
      download_file_manager_->RenameCompletingDownloadFile(
          id, new_path, (should_overwrite == OVERWRITE),
          base::Bind(&TestDownloadManager::OnDownloadRenamed,
                     download_manager_, id.local()));
    }

if (rename_error != net::OK) {
EXPECT_CALL(*download_manager_,
OnDownloadInterrupted(
id.local(),
byte_count_[id],
"",
content::ConvertNetErrorToInterruptReason(
rename_error,
content::DOWNLOAD_INTERRUPT_FROM_DISK)));
EXPECT_CALL(*download_manager_,
OnDownloadRenamed(id.local(), FilePath()));
ProcessAllPendingMessages();
++error_count_[id];
} else {
EXPECT_CALL(*download_manager_,
OnDownloadRenamed(id.local(), unique_path));
ProcessAllPendingMessages();
}
}

void ChromeDownloadManagerDelegate::UpdateItemInPersistentStore(
    DownloadItem* item) {
  download_history_->UpdateEntry(item);
}

void RunGetFileFromCacheCallback(const GetFileFromCacheCallback& callback,
                                 base::PlatformFileError* error,
                                 const std::string& resource_id,
                                 const std::string& md5,
                                 FilePath* cache_file_path) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  DCHECK(error);
  DCHECK(cache_file_path);

  if (!callback.is_null())
    callback.Run(*error, resource_id, md5, *cache_file_path);
}

    virtual void OnDownloadOpened(DownloadItem* download) { }

content::DownloadItem* MockDownloadItemFactory::CreatePersistedItem(
    DownloadItemImpl::Delegate* delegate,
    content::DownloadId download_id,
    const content::DownloadPersistentStoreInfo& info,
    const net::BoundNetLog& bound_net_log) {
  int local_id = download_id.local();
  DCHECK(items_.find(local_id) == items_.end());

  content::MockDownloadItem* result =
      new StrictMock<content::MockDownloadItem>;
  EXPECT_CALL(*result, GetId())
      .WillRepeatedly(Return(local_id));
  items_[local_id] = result;

  return result;
}

scoped_ptr<GDataCache::CacheEntry> GDataCacheMetadataMap::GetCacheEntry(
    const std::string& resource_id,
    const std::string& md5) {
  AssertOnSequencedWorkerPool();

  CacheMap::iterator iter = cache_map_.find(resource_id);
  if (iter == cache_map_.end()) {
    DVLOG(1) << "Can't find " << resource_id << " in cache map";
    return scoped_ptr<GDataCache::CacheEntry>();
  }

  scoped_ptr<GDataCache::CacheEntry> cache_entry(
      new GDataCache::CacheEntry(iter->second));

  if (!CheckIfMd5Matches(md5, *cache_entry)) {
    DVLOG(1) << "Non-matching md5: want=" << md5
             << ", found=[res_id=" << resource_id
             << ", " << cache_entry->ToString()
             << "]";
    return scoped_ptr<GDataCache::CacheEntry>();
  }

  DVLOG(1) << "Found entry for res_id=" << resource_id
           << ", " << cache_entry->ToString();

  return cache_entry.Pass();
}

void DownloadItemImpl::UpdateProgress(int64 bytes_so_far,
const std::string& hash_state) {
  hash_state_ = hash_state;

received_bytes_ = bytes_so_far;

// If we've received more data than we were expecting (bad server info?),
// revert to 'unknown size mode'.
if (received_bytes_ > total_bytes_)
total_bytes_ = 0;

if (bound_net_log_.IsLoggingAllEvents()) {
bound_net_log_.AddEvent(
net::NetLog::TYPE_DOWNLOAD_ITEM_UPDATED,
net::NetLog::Int64Callback("bytes_so_far", received_bytes_));
}
}

MockDownloadFile* MockDownloadFileFactory::GetExistingFile(
    const DownloadId& id) {
  DCHECK(files_.find(id) != files_.end());
  return files_[id];
}

bool DownloadItemImpl::IsPaused() const { return is_paused_; }

 ACTION_P(ScheduleRenameCallback, new_path) {
   BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,
                           base::Bind(arg3, new_path));
 }

void GDataCache::GetResourceIdsOfBacklogOnUIThread(
    const GetResourceIdsOfBacklogCallback& callback) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  std::vector<std::string>* to_fetch = new std::vector<std::string>;
  std::vector<std::string>* to_upload = new std::vector<std::string>;
  pool_->GetSequencedTaskRunner(sequence_token_)->PostTaskAndReply(
      FROM_HERE,
      base::Bind(&GDataCache::GetResourceIdsOfBacklog,
                 base::Unretained(this),
                 to_fetch,
                 to_upload),
      base::Bind(&RunGetResourceIdsOfBacklogCallback,
                 callback,
                 base::Owned(to_fetch),
                 base::Owned(to_upload)));
}

void ShelfLayoutManager::UpdateShelfBackground(
    BackgroundAnimator::ChangeType type) {
  bool launcher_paints = GetLauncherPaintsBackground();
  if (launcher_)
    launcher_->SetPaintsBackground(launcher_paints, type);
  StatusAreaWidget* status_area_widget =
      Shell::GetInstance()->status_area_widget();
  if (status_area_widget)
    status_area_widget->SetPaintsBackground(!launcher_paints, type);
}

void CleanUp(DownloadId id) {
// Expected calls:
//  DownloadFileManager::CancelDownload
//    DownloadFile::Cancel
//    DownloadFileManager::EraseDownload
//      if no more downloads:
//        DownloadFileManager::StopUpdateTimer
MockDownloadFile* file = download_file_factory_->GetExistingFile(id);
ASSERT_TRUE(file != NULL);

EXPECT_CALL(*file, Cancel());

download_file_manager_->CancelDownload(id);

    EXPECT_TRUE(NULL == download_file_manager_->GetDownloadFile(id));
}

void GDataCache::OnCommitDirty(base::PlatformFileError* error,
                               const std::string& resource_id,
                               const std::string& md5,
                               const CacheOperationCallback& callback) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  DCHECK(error);

  if (!callback.is_null())
    callback.Run(*error, resource_id, md5);

  if (*error == base::PLATFORM_FILE_OK)
    FOR_EACH_OBSERVER(Observer, observers_, OnCacheCommitted(resource_id));
}

int64 DownloadItemImpl::GetTotalBytes() const { return total_bytes_; }

void LauncherView::AnimateToIdealBounds() {
  IdealBounds ideal_bounds;
  CalculateIdealBounds(&ideal_bounds);
  for (int i = 0; i < view_model_->view_size(); ++i) {
    bounds_animator_->AnimateViewTo(view_model_->view_at(i),
                                    view_model_->ideal_bounds(i));
  }
  overflow_button_->SetBoundsRect(ideal_bounds.overflow_bounds);
}

  void RunAllPendingInMessageLoops() {
    loop_.RunAllPending();
  }

ShelfLayoutManager::AutoHideEventFilter::PreHandleGestureEvent(
    aura::Window* target,
    aura::GestureEvent* event) {
  return ui::GESTURE_STATUS_UNKNOWN;  // Not handled.
}

void DownloadItemImpl::Delegate::Attach() {
  ++count_;
}

LauncherView::~LauncherView() {
  bounds_animator_->RemoveObserver(this);
  model_->RemoveObserver(this);
}

ShelfLayoutManager::AutoHideState ShelfLayoutManager::CalculateAutoHideState(
    VisibilityState visibility_state) const {
  if (visibility_state != AUTO_HIDE || !launcher_widget())
    return AUTO_HIDE_HIDDEN;

  Shell* shell = Shell::GetInstance();
  if (shell->GetAppListTargetVisibility())
    return AUTO_HIDE_SHOWN;

  if (shell->system_tray() && shell->system_tray()->should_show_launcher())
    return AUTO_HIDE_SHOWN;

   if (launcher_ && launcher_->IsShowingMenu())
     return AUTO_HIDE_SHOWN;
 
   if (launcher_widget()->IsActive() || status_->IsActive())
     return AUTO_HIDE_SHOWN;
 
  if (event_filter_.get() && event_filter_->in_mouse_drag())
    return AUTO_HIDE_HIDDEN;

  aura::RootWindow* root = launcher_widget()->GetNativeView()->GetRootWindow();
  bool mouse_over_launcher =
      launcher_widget()->GetWindowScreenBounds().Contains(
          root->last_mouse_location());
  return mouse_over_launcher ? AUTO_HIDE_SHOWN : AUTO_HIDE_HIDDEN;
}

  ~DownloadItemTest() {
  }

void DownloadItemImpl::OnDownloadedFileRemoved() {
  file_externally_removed_ = true;
  UpdateObservers();
}

const std::string& DownloadItemImpl::GetETag() const { return etag_; }

void ChromeDownloadManagerDelegate::GetSaveDir(WebContents* web_contents,
                                               FilePath* website_save_dir,
                                               FilePath* download_save_dir,
                                               bool* skip_dir_check) {
  Profile* profile =
      Profile::FromBrowserContext(web_contents->GetBrowserContext());
  PrefService* prefs = profile->GetPrefs();

  if (!prefs->FindPreference(prefs::kSaveFileDefaultDirectory)) {
    DCHECK(prefs->FindPreference(prefs::kDownloadDefaultDirectory));
    FilePath default_save_path = prefs->GetFilePath(
        prefs::kDownloadDefaultDirectory);
    prefs->RegisterFilePathPref(prefs::kSaveFileDefaultDirectory,
                                default_save_path,
                                PrefService::UNSYNCABLE_PREF);
  }

  *website_save_dir = prefs->GetFilePath(prefs::kSaveFileDefaultDirectory);
  DCHECK(!website_save_dir->empty());

  *download_save_dir = prefs->GetFilePath(prefs::kDownloadDefaultDirectory);

  *skip_dir_check = false;
#if defined(OS_CHROMEOS)
  *skip_dir_check = gdata::util::IsUnderGDataMountPoint(*website_save_dir);
#endif
}

const FilePath& GetGDataMountPointPath() {
  CR_DEFINE_STATIC_LOCAL(FilePath, gdata_mount_path,
      (FilePath::FromUTF8Unsafe(kGDataMountPointPath)));
  return gdata_mount_path;
}

int LauncherView::CancelDrag(int modified_index) {
  if (!drag_view_)
    return modified_index;
  bool was_dragging = dragging_;
  int drag_view_index = view_model_->GetIndexOfView(drag_view_);
  dragging_ = false;
  drag_view_ = NULL;
  if (drag_view_index == modified_index) {
    return modified_index;
  }
  if (!was_dragging)
    return modified_index;

  views::View* removed_view =
      (modified_index >= 0) ? view_model_->view_at(modified_index) : NULL;
  model_->Move(drag_view_index, start_drag_index_);
  return removed_view ? view_model_->GetIndexOfView(removed_view) : -1;
}

void Launcher::SetStatusSize(const gfx::Size& size) {
  if (status_size_ == size)
    return;

  status_size_ = size;
  delegate_view_->Layout();
}

Launcher::DelegateView::DelegateView(Launcher* launcher)
    : launcher_(launcher),
      focus_cycler_(NULL) {
}

void ChromeDownloadManagerDelegate::SubstituteGDataDownloadPathCallback(
    int32 download_id,
    bool should_prompt,
    bool is_forced_path,
    content::DownloadDangerType danger_type,
    const FilePath& suggested_path) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  DownloadItem* download =
      download_manager_->GetActiveDownloadItem(download_id);
  if (!download)
    return;

  BrowserThread::PostTask(
      BrowserThread::FILE, FROM_HERE,
      base::Bind(&ChromeDownloadManagerDelegate::CheckIfSuggestedPathExists,
                 this, download->GetId(), suggested_path, should_prompt,
                 is_forced_path, danger_type,
                 download_prefs_->download_path()));
}

void ChromeDownloadManagerDelegate::SetDownloadManager(DownloadManager* dm) {
  download_manager_ = dm;
  download_history_.reset(new DownloadHistory(profile_));
  download_history_->Load(
      base::Bind(&DownloadManager::OnPersistentStoreQueryComplete,
                 base::Unretained(dm)));
  extension_event_router_.reset(new ExtensionDownloadsEventRouter(
      profile_, download_manager_));
}

void CollectBacklog(std::vector<std::string>* to_fetch,
                    std::vector<std::string>* to_upload,
                    const std::string& resource_id,
                    const GDataCache::CacheEntry& cache_entry) {
  DCHECK(to_fetch);
  DCHECK(to_upload);

  if (cache_entry.IsPinned() && !cache_entry.IsPresent())
    to_fetch->push_back(resource_id);

  if (cache_entry.IsDirty())
    to_upload->push_back(resource_id);
}

content::DownloadInterruptReason DownloadItemImpl::GetLastReason() const {
  return last_reason_;
}

void DownloadItemImpl::Cancel(bool user_cancel) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  last_reason_ = user_cancel ?
      content::DOWNLOAD_INTERRUPT_REASON_USER_CANCELED :
      content::DOWNLOAD_INTERRUPT_REASON_USER_SHUTDOWN;

  VLOG(20) << __FUNCTION__ << "() download = " << DebugString(true);
  if (!IsPartialDownload()) {
    return;
  }

  download_stats::RecordDownloadCount(download_stats::CANCELLED_COUNT);

  TransitionTo(CANCELLED);
  if (user_cancel)
    delegate_->DownloadStopped(this);
}

  void RemoveMockDownloadItem(int id) {
    mock_download_item_factory_->RemoveItem(id);
  }

bool ShelfLayoutManager::SetAlignment(ShelfAlignment alignment) {
  if (alignment_ == alignment)
    return false;

  alignment_ = alignment;
  if (launcher_)
    launcher_->SetAlignment(alignment);
  StatusAreaWidget* status_area_widget =
      Shell::GetInstance()->status_area_widget();
  if (status_area_widget)
    Shell::GetInstance()->status_area_widget()->SetShelfAlignment(alignment);
  LayoutShelf();
  return true;
}

void RemoveAllFiles(const FilePath& directory) {
  using file_util::FileEnumerator;

  FileEnumerator enumerator(directory, false /* recursive */,
                            FileEnumerator::FILES);
  for (FilePath file_path = enumerator.Next(); !file_path.empty();
       file_path = enumerator.Next()) {
    DVLOG(1) << "Removing " << file_path.value();
    if (!file_util::Delete(file_path, false /* recursive */))
      LOG(WARNING) << "Failed to delete " << file_path.value();
  }
}

void ShelfLayoutManager::RemoveObserver(Observer* observer) {
  observers_.RemoveObserver(observer);
}

  StartFadeAnimationDelegate(LauncherView* host,
                             views::View* view)
      : launcher_view_(host),
        view_(view) {}

  virtual void SetUp() {
    DCHECK(!download_manager_.get());

    mock_download_item_factory_ = (new MockDownloadItemFactory())->AsWeakPtr();
    mock_download_manager_delegate_.reset(
        new StrictMock<MockDownloadManagerDelegate>);
    EXPECT_CALL(*mock_download_manager_delegate_.get(), Shutdown())
        .WillOnce(Return());
    mock_download_file_manager_ = new StrictMock<MockDownloadFileManager>;
    EXPECT_CALL(*mock_download_file_manager_.get(),
                OnDownloadManagerShutdown(_));
    mock_browser_context_.reset(new StrictMock<MockBrowserContext>);
    EXPECT_CALL(*mock_browser_context_.get(), IsOffTheRecord())
        .WillRepeatedly(Return(false));

    download_manager_ = new DownloadManagerImpl(
        mock_download_file_manager_.get(),
        scoped_ptr<content::DownloadItemFactory>(
            mock_download_item_factory_.get()).Pass(), NULL);
    download_manager_->SetDelegate(mock_download_manager_delegate_.get());
    download_manager_->Init(mock_browser_context_.get());
  }

void GDataCache::GetResourceIdsOfExistingPinnedFilesOnUIThread(
    const GetResourceIdsCallback& callback) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  std::vector<std::string>* resource_ids = new std::vector<std::string>;
  pool_->GetSequencedTaskRunner(sequence_token_)->PostTaskAndReply(
      FROM_HERE,
      base::Bind(&GDataCache::GetResourceIdsOfExistingPinnedFiles,
                 base::Unretained(this),
                 resource_ids),
      base::Bind(&RunGetResourceIdsCallback,
                 callback,
                 base::Owned(resource_ids)));
}

void DownloadItemImpl::SetDisplayName(const FilePath& name) {
  display_name_ = name;
}

GDataCache::~GDataCache() {
  AssertOnSequencedWorkerPool();
}

bool IsUnderGDataMountPoint(const FilePath& path) {
  return GetGDataMountPointPath() == path ||
         GetGDataMountPointPath().IsParent(path);
}

GURL GetFileResourceUrl(const std::string& resource_id,
                        const std::string& file_name) {
  std::string url(base::StringPrintf(
      "%s:%s",
      chrome::kDriveScheme,
      net::EscapePath(resource_id).c_str()));
  return GURL(url);
}

   ~MockDownloadFileManager() {}

const char* DebugSafetyStateString(DownloadItem::SafetyState state) {
  switch (state) {
    case DownloadItem::SAFE:
      return "SAFE";
    case DownloadItem::DANGEROUS:
      return "DANGEROUS";
    case DownloadItem::DANGEROUS_BUT_VALIDATED:
      return "DANGEROUS_BUT_VALIDATED";
    default:
      NOTREACHED() << "Unknown safety state " << state;
      return "unknown";
  };
}

bool Launcher::IsShowingMenu() const {
   return launcher_view_->IsShowingMenu();
 }

content::MockDownloadItem* MockDownloadItemFactory::PopItem() {
  if (items_.empty())
    return NULL;

  std::map<int32, content::MockDownloadItem*>::iterator first_item
      = items_.begin();
  content::MockDownloadItem* result = first_item->second;
  items_.erase(first_item);
  return result;
}

void GDataCacheMetadataMap::RemoveTemporaryFiles() {
  AssertOnSequencedWorkerPool();

  CacheMap::iterator iter = cache_map_.begin();
  while (iter != cache_map_.end()) {
    if (iter->second.sub_dir_type == GDataCache::CACHE_TYPE_TMP) {
      cache_map_.erase(iter++);
    } else {
      ++iter;
    }
  }
}

DownloadItem::DownloadState DownloadItemImpl::GetState() const {
  return state_;
}

void LauncherView::ShowOverflowMenu() {
#if !defined(OS_MACOSX)
  if (!delegate_)
    return;

  std::vector<LauncherItem> items;
  GetOverflowItems(&items);
  if (items.empty())
    return;

  MenuDelegateImpl menu_delegate;
  ui::SimpleMenuModel menu_model(&menu_delegate);
  for (size_t i = 0; i < items.size(); ++i)
    menu_model.AddItem(static_cast<int>(i), delegate_->GetTitle(items[i]));
  views::MenuModelAdapter menu_adapter(&menu_model);
  overflow_menu_runner_.reset(new views::MenuRunner(menu_adapter.CreateMenu()));
  gfx::Rect bounds(overflow_button_->size());
  gfx::Point origin;
  ConvertPointToScreen(overflow_button_, &origin);
  if (overflow_menu_runner_->RunMenuAt(GetWidget(), NULL,
          gfx::Rect(origin, size()), views::MenuItemView::TOPLEFT, 0) ==
      views::MenuRunner::MENU_DELETED)
    return;

Shell::GetInstance()->UpdateShelfVisibility();
  if (menu_delegate.activated_command_id() == -1)
    return;
  LauncherID activated_id = items[menu_delegate.activated_command_id()].id;
  LauncherItems::const_iterator window_iter = model_->ItemByID(activated_id);
  if (window_iter == model_->items().end())
    return;  // Window was deleted while menu was up.
  delegate_->ItemClicked(*window_iter, ui::EF_NONE);
#endif  // !defined(OS_MACOSX)
}

void ReflectItemStatus(const ash::LauncherItem& item,
                       LauncherButton* button) {
  switch (item.status) {
    case STATUS_CLOSED:
      button->ClearState(LauncherButton::STATE_ACTIVE);
      button->ClearState(LauncherButton::STATE_RUNNING);
      button->ClearState(LauncherButton::STATE_ATTENTION);
      button->ClearState(LauncherButton::STATE_PENDING);
      break;
    case STATUS_RUNNING:
      button->ClearState(LauncherButton::STATE_ACTIVE);
      button->AddState(LauncherButton::STATE_RUNNING);
      button->ClearState(LauncherButton::STATE_ATTENTION);
      button->ClearState(LauncherButton::STATE_PENDING);
      break;
    case STATUS_ACTIVE:
      button->AddState(LauncherButton::STATE_ACTIVE);
      button->ClearState(LauncherButton::STATE_RUNNING);
      button->ClearState(LauncherButton::STATE_ATTENTION);
      button->ClearState(LauncherButton::STATE_PENDING);
      break;
    case STATUS_ATTENTION:
      button->ClearState(LauncherButton::STATE_ACTIVE);
      button->ClearState(LauncherButton::STATE_RUNNING);
      button->AddState(LauncherButton::STATE_ATTENTION);
      button->ClearState(LauncherButton::STATE_PENDING);
      break;
    case STATUS_IS_PENDING:
      button->ClearState(LauncherButton::STATE_ACTIVE);
      button->ClearState(LauncherButton::STATE_RUNNING);
      button->ClearState(LauncherButton::STATE_ATTENTION);
      button->AddState(LauncherButton::STATE_PENDING);
      break;
  }
}

gfx::Size LauncherView::GetPreferredSize() {
IdealBounds ideal_bounds;
CalculateIdealBounds(&ideal_bounds);
if (is_horizontal_alignment()) {
    if (view_model_->view_size() >= 2) {
      // Should always have two items.
      return gfx::Size(view_model_->ideal_bounds(1).right() + kLeadingInset,
                       kLauncherPreferredSize);
    }
    return gfx::Size(kLauncherPreferredSize * 2 + kLeadingInset * 2,
kLauncherPreferredSize);
}
  if (view_model_->view_size() >= 2) {
    // Should always have two items.
    return gfx::Size(kLauncherPreferredSize,
                     view_model_->ideal_bounds(1).bottom() + kLeadingInset);
  }
return gfx::Size(kLauncherPreferredSize,
                   kLauncherPreferredSize * 2 + kLeadingInset * 2);
}

void RunCacheOperationCallback(const CacheOperationCallback& callback,
                               base::PlatformFileError* error,
                               const std::string& resource_id,
                               const std::string& md5) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  DCHECK(error);

  if (!callback.is_null())
    callback.Run(*error, resource_id, md5);
}

void OpenEditURLUIThread(Profile* profile, const GURL* edit_url) {
  Browser* browser = browser::FindLastActiveWithProfile(profile);
  if (browser) {
    browser->OpenURL(content::OpenURLParams(*edit_url, content::Referrer(),
        CURRENT_TAB, content::PAGE_TRANSITION_TYPED, false));
  }
}

void ShelfLayoutManager::UpdateAutoHideStateNow() {
  SetState(state_.visibility_state);
}

bool DownloadItemImpl::AllDataSaved() const { return all_data_saved_; }

  virtual ~FadeOutAnimationDelegate() {}

std::string UnescapeCacheFileName(const std::string& filename) {
  std::string unescaped;
  for (size_t i = 0; i < filename.size(); ++i) {
    char c = filename[i];
    if (c == '%' && i + 2 < filename.length()) {
      c = (HexDigitToInt(filename[i + 1]) << 4) +
           HexDigitToInt(filename[i + 2]);
      i += 2;
    }
    unescaped.push_back(c);
  }
  return unescaped;
}

bool ShelfLayoutManager::GetLauncherPaintsBackground() const {
  return (!state_.is_screen_locked && window_overlaps_shelf_) ||
      state_.visibility_state == AUTO_HIDE;
}

int DownloadFileManager::NumberOfActiveDownloads() const {
   return downloads_.size();
 }

void ShelfLayoutManager::GetShelfSize(int* width, int* height) {
  *width = *height = 0;
  gfx::Rect status_bounds(status_->GetWindowScreenBounds());
  gfx::Size launcher_size = launcher_ ?
      launcher_widget()->GetContentsView()->GetPreferredSize() : gfx::Size();
  if (alignment_ == SHELF_ALIGNMENT_BOTTOM)
    *height = std::max(launcher_size.height(), status_bounds.height());
  else
    *width = std::max(launcher_size.width(), status_bounds.width());
}

void ShelfLayoutManager::LayoutShelf() {
  AutoReset<bool> auto_reset_in_layout(&in_layout_, true);
  StopAnimating();
  TargetBounds target_bounds;
  CalculateTargetBounds(state_, &target_bounds);
  if (launcher_widget()) {
    GetLayer(launcher_widget())->SetOpacity(target_bounds.opacity);

    launcher_widget()->SetBounds(target_bounds.launcher_bounds);
    launcher_->SetStatusSize(target_bounds.status_bounds.size());
  }
  GetLayer(status_)->SetOpacity(target_bounds.opacity);
  status_->SetBounds(target_bounds.status_bounds);
  Shell::GetInstance()->SetDisplayWorkAreaInsets(
      Shell::GetPrimaryRootWindow(),
      target_bounds.work_area_insets);
  UpdateHitTestBounds();
}

  DownloadFileFactoryImpl() {}

void ShelfLayoutManager::OnWindowRemovedFromLayout(aura::Window* child) {
}

bool ChromeDownloadManagerDelegate::ShouldOpenFileBasedOnExtension(
    const FilePath& path) {
  FilePath::StringType extension = path.Extension();
  if (extension.empty())
    return false;
  if (extensions::Extension::IsExtension(path))
    return false;
  DCHECK(extension[0] == FilePath::kExtensionSeparator);
  extension.erase(0, 1);
  return download_prefs_->IsAutoOpenEnabledForExtension(extension);
}

void ShelfLayoutManager::OnWindowActivated(aura::Window* active,
                                           aura::Window* old_active) {
  UpdateAutoHideStateNow();
}

bool ChromeDownloadManagerDelegate::GenerateFileHash() {
#if defined(ENABLE_SAFE_BROWSING)
  return profile_->GetPrefs()->GetBoolean(prefs::kSafeBrowsingEnabled) &&
      g_browser_process->safe_browsing_service()->DownloadBinHashNeeded();
#else
  return false;
#endif
}

void LauncherView::RemoveIconObserver(LauncherIconObserver* observer) {
  observers_.RemoveObserver(observer);
}

    virtual void OnDownloadUpdated(DownloadItem* download) {
      updated_ = true;
    }

FilePath GDataCache::GetCacheDirectoryPath(
    CacheSubDirectoryType sub_dir_type) const {
  DCHECK_LE(0, sub_dir_type);
  DCHECK_GT(NUM_CACHE_TYPES, sub_dir_type);
  return cache_paths_[sub_dir_type];
}

void LauncherView::ButtonPressed(views::Button* sender,
const views::Event& event) {
// Do not handle mouse release during drag.
if (dragging_)
return;

  if (sender == overflow_button_)
    ShowOverflowMenu();

if (!delegate_)
return;
int view_index = view_model_->GetIndexOfView(sender);
// May be -1 while in the process of animating closed.
if (view_index == -1)
return;

switch (model_->items()[view_index].type) {
case TYPE_TABBED:
case TYPE_APP_PANEL:
case TYPE_APP_SHORTCUT:
case TYPE_PLATFORM_APP:
delegate_->ItemClicked(model_->items()[view_index], event.flags());
break;

case TYPE_APP_LIST:
Shell::GetInstance()->ToggleAppList();
break;

case TYPE_BROWSER_SHORTCUT:
if (event.flags() & ui::EF_CONTROL_DOWN)
delegate_->CreateNewWindow();
else
delegate_->CreateNewTab();
break;
}
}

  content::MockDownloadItem& AddItemToManager() {
    DownloadCreateInfo info;

    static const char* kDownloadIdDomain = "Test download id domain";

    int id = next_download_id_;
    ++next_download_id_;
    info.download_id = content::DownloadId(kDownloadIdDomain, id);
    info.request_handle = DownloadRequestHandle();
    download_manager_->CreateDownloadItem(&info);

    DCHECK(mock_download_item_factory_->GetItem(id));
    content::MockDownloadItem& item(*mock_download_item_factory_->GetItem(id));
    ON_CALL(item, GetId())
        .WillByDefault(Return(id));

    return item;
  }

FilePath GDataCache::GetCacheFilePath(const std::string& resource_id,
                                      const std::string& md5,
                                      CacheSubDirectoryType sub_dir_type,
                                      CachedFileOrigin file_origin) const {
  DCHECK(sub_dir_type != CACHE_TYPE_META);

  std::string base_name = util::EscapeCacheFileName(resource_id);
  if (file_origin == CACHED_FILE_LOCALLY_MODIFIED) {
    DCHECK(sub_dir_type == CACHE_TYPE_PERSISTENT);
    base_name += FilePath::kExtensionSeparator;
    base_name += util::kLocallyModifiedFileExtension;
  } else if (!md5.empty()) {
    base_name += FilePath::kExtensionSeparator;
    base_name += util::EscapeCacheFileName(md5);
  }
  if (file_origin == CACHED_FILE_MOUNTED) {
    DCHECK(sub_dir_type == CACHE_TYPE_PERSISTENT);
    base_name += FilePath::kExtensionSeparator;
    base_name += util::kMountedArchiveFileExtension;
  }
  return GetCacheDirectoryPath(sub_dir_type).Append(base_name);
}

void ChromeDownloadManagerDelegate::UpdatePathForItemInPersistentStore(
    DownloadItem* item,
    const FilePath& new_path) {
  download_history_->UpdateDownloadPath(item, new_path);
}

gfx::Rect Launcher::GetScreenBoundsOfItemIconForWindow(aura::Window* window) {
  if (!delegate_.get())
    return gfx::Rect();

  LauncherID id = delegate_->GetIDByWindow(window);
  gfx::Rect bounds(launcher_view_->GetIdealBoundsOfItemIcon(id));
  if (bounds.IsEmpty())
    return bounds;

  gfx::Point screen_origin;
  views::View::ConvertPointToScreen(launcher_view_, &screen_origin);
  return gfx::Rect(screen_origin.x() + bounds.x(),
                   screen_origin.y() + bounds.y(),
                   bounds.width(),
                   bounds.height());
}

void GDataCache::OnUnpinned(base::PlatformFileError* error,
                            const std::string& resource_id,
                            const std::string& md5,
                            const CacheOperationCallback& callback) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  DCHECK(error);

  if (!callback.is_null())
    callback.Run(*error, resource_id, md5);

  if (*error == base::PLATFORM_FILE_OK)
    FOR_EACH_OBSERVER(Observer, observers_, OnCacheUnpinned(resource_id, md5));

  bool* has_enough_space = new bool(false);
  pool_->GetSequencedTaskRunner(sequence_token_)->PostTask(
      FROM_HERE,
      base::Bind(&GDataCache::FreeDiskSpaceIfNeededFor,
                 base::Unretained(this),
                 0,
                 base::Owned(has_enough_space)));
}

void DownloadItemImpl::DelayedDownloadOpened(bool auto_opened) {
  auto_opened_ = auto_opened;
  Completed();
}

void GDataCache::MarkDirtyOnUIThread(const std::string& resource_id,
                                     const std::string& md5,
                                     const GetFileFromCacheCallback& callback) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  base::PlatformFileError* error =
      new base::PlatformFileError(base::PLATFORM_FILE_OK);
  FilePath* cache_file_path = new FilePath;
  pool_->GetSequencedTaskRunner(sequence_token_)->PostTaskAndReply(
      FROM_HERE,
      base::Bind(&GDataCache::MarkDirty,
                 base::Unretained(this),
                 resource_id,
                 md5,
                 GDataCache::FILE_OPERATION_MOVE,
                 error,
                 cache_file_path),
      base::Bind(&RunGetFileFromCacheCallback,
                 callback,
                 base::Owned(error),
                 resource_id,
                 md5,
                 base::Owned(cache_file_path)));
}

void CreateSymbolicLink(const FilePath& target, const FilePath& symlink) {
    ASSERT_TRUE(file_util::CreateSymbolicLink(target, symlink))
        << ": " << target.value() << ": " << symlink.value();
}

  void SetVerdict(DownloadProtectionService::DownloadCheckResult result) {
    verdict_ = result;
    CompleteDownload();
  }

void GDataCache::CommitDirtyOnUIThread(const std::string& resource_id,
                                       const std::string& md5,
                                       const CacheOperationCallback& callback) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  base::PlatformFileError* error =
      new base::PlatformFileError(base::PLATFORM_FILE_OK);
  pool_->GetSequencedTaskRunner(sequence_token_)->PostTaskAndReply(
      FROM_HERE,
      base::Bind(&GDataCache::CommitDirty,
                 base::Unretained(this),
                 resource_id,
                 md5,
                 GDataCache::FILE_OPERATION_MOVE,
                 error),
      base::Bind(&GDataCache::OnCommitDirty,
                 ui_weak_ptr_,
                 base::Owned(error),
                 resource_id,
                 md5,
                 callback));
}

void DownloadItemImpl::OpenDownload() {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  if (IsPartialDownload()) {
    if (!IsTemporary())
      open_when_complete_ = !open_when_complete_;
    return;
  }

  if (!IsComplete() || file_externally_removed_)
    return;

  delegate_->CheckForFileRemoval(this);
  download_stats::RecordOpen(GetEndTime(), !GetOpened());
  opened_ = true;
  FOR_EACH_OBSERVER(Observer, observers_, OnDownloadOpened(this));
  delegate_->DownloadOpened(this);

  if (!open_enabled_)
    return;

  content::GetContentClient()->browser()->OpenItem(GetFullPath());
}

void DownloadItemImpl::Delete(DeleteReason reason) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  switch (reason) {
    case DELETE_DUE_TO_USER_DISCARD:
      UMA_HISTOGRAM_ENUMERATION(
          "Download.UserDiscard", GetDangerType(),
          content::DOWNLOAD_DANGER_TYPE_MAX);
      break;
    case DELETE_DUE_TO_BROWSER_SHUTDOWN:
      UMA_HISTOGRAM_ENUMERATION(
          "Download.Discard", GetDangerType(),
          content::DOWNLOAD_DANGER_TYPE_MAX);
      break;
    default:
      NOTREACHED();
  }

  if (!current_path_.empty())
    BrowserThread::PostTask(BrowserThread::FILE, FROM_HERE,
                            base::Bind(&DeleteDownloadedFile, current_path_));
  Remove();
}

DownloadItemImpl::DownloadItemImpl(Delegate* delegate,
                                   const FilePath& path,
                                   const GURL& url,
                                   bool is_otr,
                                   DownloadId download_id,
                                   const std::string& mime_type,
                                   const net::BoundNetLog& bound_net_log)
    : request_handle_(new NullDownloadRequestHandle()),
      download_id_(download_id),
      current_path_(path),
      target_path_(path),
      target_disposition_(TARGET_DISPOSITION_OVERWRITE),
      url_chain_(1, url),
      referrer_url_(GURL()),
      transition_type_(content::PAGE_TRANSITION_LINK),
      has_user_gesture_(false),
      mime_type_(mime_type),
      original_mime_type_(mime_type),
      total_bytes_(0),
      received_bytes_(0),
      bytes_per_sec_(0),
      last_reason_(content::DOWNLOAD_INTERRUPT_REASON_NONE),
      start_tick_(base::TimeTicks::Now()),
      state_(IN_PROGRESS),
      danger_type_(content::DOWNLOAD_DANGER_TYPE_NOT_DANGEROUS),
      start_time_(base::Time::Now()),
      db_handle_(DownloadItem::kUninitializedHandle),
      delegate_(delegate),
      is_paused_(false),
      open_when_complete_(false),
      file_externally_removed_(false),
      safety_state_(SAFE),
      auto_opened_(false),
      is_persisted_(false),
      is_otr_(is_otr),
      is_temporary_(false),
      all_data_saved_(false),
      opened_(false),
      open_enabled_(true),
      delegate_delayed_complete_(false),
      bound_net_log_(bound_net_log),
      ALLOW_THIS_IN_INITIALIZER_LIST(weak_ptr_factory_(this)) {
  delegate_->Attach();
  Init(true /* actively downloading */,
       download_net_logs::SRC_SAVE_PAGE_AS);
}

Launcher::Launcher(aura::Window* window_container,
                   internal::ShelfLayoutManager* shelf_layout_manager)
    : widget_(NULL),
      window_container_(window_container),
      delegate_view_(NULL),
      launcher_view_(NULL),
      alignment_(SHELF_ALIGNMENT_BOTTOM),
      ALLOW_THIS_IN_INITIALIZER_LIST(
          background_animator_(this, 0, kBackgroundAlpha)) {
  model_.reset(new LauncherModel);
  if (Shell::GetInstance()->delegate()) {
    delegate_.reset(
        Shell::GetInstance()->delegate()->CreateLauncherDelegate(model_.get()));
  }

  widget_.reset(new views::Widget);
  views::Widget::InitParams params(
      views::Widget::InitParams::TYPE_WINDOW_FRAMELESS);
  params.layer_type = ui::LAYER_SOLID_COLOR;
  params.transparent = true;
  params.ownership = views::Widget::InitParams::WIDGET_OWNS_NATIVE_WIDGET;
  params.parent = Shell::GetContainer(
      window_container_->GetRootWindow(),
      ash::internal::kShellWindowId_LauncherContainer);
  launcher_view_ = new internal::LauncherView(
      model_.get(), delegate_.get(), shelf_layout_manager);
  launcher_view_->Init();
  delegate_view_ = new DelegateView(this);
  delegate_view_->AddChildView(launcher_view_);
  params.delegate = delegate_view_;
  widget_->Init(params);
  widget_->GetNativeWindow()->SetName("LauncherWindow");
  gfx::Size pref =
      static_cast<views::View*>(launcher_view_)->GetPreferredSize();
  widget_->SetBounds(gfx::Rect(pref));
  widget_->set_focus_on_creation(false);
  widget_->SetContentsView(delegate_view_);
  widget_->Show();
  widget_->GetNativeView()->SetName("LauncherView");
}

bool ChromeDownloadManagerDelegate::IsDangerousFile(
    const DownloadItem& download,
    const FilePath& suggested_path,
    bool visited_referrer_before) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  if (download.GetTransitionType() & content::PAGE_TRANSITION_FROM_ADDRESS_BAR)
    return false;

  if (extensions::switch_utils::IsEasyOffStoreInstallEnabled() &&
      download_crx_util::IsExtensionDownload(download) &&
      !WebstoreInstaller::GetAssociatedApproval(download)) {
    return true;
  }

  if (ShouldOpenFileBasedOnExtension(suggested_path) &&
      download.HasUserGesture())
    return false;

  download_util::DownloadDangerLevel danger_level =
      download_util::GetFileDangerLevel(suggested_path.BaseName());
  if (danger_level == download_util::AllowOnUserGesture)
    return !download.HasUserGesture() || !visited_referrer_before;

  return danger_level == download_util::Dangerous;
}

void GDataCache::Unpin(const std::string& resource_id,
                       const std::string& md5,
                       FileOperationType file_operation_type,
                       base::PlatformFileError* error) {
  AssertOnSequencedWorkerPool();
  DCHECK(error);

  scoped_ptr<CacheEntry> cache_entry = GetCacheEntry(resource_id, md5);

  if (!cache_entry.get()) {
    LOG(WARNING) << "Can't unpin a file that wasn't pinned or cached: res_id="
                 << resource_id
                 << ", md5=" << md5;
    *error = base::PLATFORM_FILE_ERROR_NOT_FOUND;
    return;
  }


  FilePath source_path;
  FilePath dest_path;
  CacheSubDirectoryType sub_dir_type = CACHE_TYPE_TMP;

  if (cache_entry->IsDirty() || cache_entry->IsMounted()) {
    sub_dir_type = CACHE_TYPE_PERSISTENT;
    DCHECK_EQ(sub_dir_type, cache_entry->sub_dir_type);
    dest_path = GetCacheFilePath(resource_id,
                                 md5,
                                 cache_entry->sub_dir_type,
                                 CACHED_FILE_LOCALLY_MODIFIED);
    source_path = dest_path;
  } else {
    source_path = GetCacheFilePath(resource_id,
                                   md5,
                                   cache_entry->sub_dir_type,
                                   CACHED_FILE_FROM_SERVER);

    if (cache_entry->sub_dir_type == CACHE_TYPE_PINNED) {
      dest_path = source_path;
    } else {  // File exists, move it to tmp dir.
      dest_path = GetCacheFilePath(resource_id, md5,
                                   CACHE_TYPE_TMP,
                                   CACHED_FILE_FROM_SERVER);
    }
  }

  FilePath symlink_path;
  if (cache_entry->IsPinned()) {
    symlink_path = GetCacheFilePath(resource_id,
                                    std::string(),
                                    CACHE_TYPE_PINNED,
                                    CACHED_FILE_FROM_SERVER);
  }

  *error = ModifyCacheState(
      source_path,
      dest_path,
      file_operation_type,
      symlink_path,  // This will be deleted if it exists.
      false /* don't create symlink*/);

  if (*error == base::PLATFORM_FILE_OK) {
    int cache_state = ClearCachePinned(cache_entry->cache_state);
    metadata_->UpdateCache(resource_id, md5, sub_dir_type, cache_state);
  }
}

  explicit LauncherFocusSearch(views::ViewModel* view_model)
      : FocusSearch(NULL, true, true),
        view_model_(view_model) {}

base::Time DownloadItemImpl::GetEndTime() const { return end_time_; }

ChromeDownloadManagerDelegate::~ChromeDownloadManagerDelegate() {
}

  DownloadItem* GetActiveDownloadItem(int32 id) {
    return download_manager_->GetActiveDownload(id);
  }

void GDataCache::Remove(const std::string& resource_id,
                        base::PlatformFileError* error) {
  AssertOnSequencedWorkerPool();
  DCHECK(error);

  scoped_ptr<CacheEntry> cache_entry =
      GetCacheEntry(resource_id, std::string());

  if (!cache_entry.get() ||
      cache_entry->IsDirty() ||
      cache_entry->IsMounted()) {
    DVLOG(1) << "Entry is "
             << (cache_entry.get() ?
                 (cache_entry->IsDirty() ? "dirty" : "mounted") :
                 "non-existent")
             << " in cache, not removing";
    *error = base::PLATFORM_FILE_OK;
    return;
  }

  std::vector<FilePath> paths_to_delete;

  paths_to_delete.push_back(GetCacheFilePath(resource_id,
                                             util::kWildCard,
                                             CACHE_TYPE_PERSISTENT,
                                             CACHED_FILE_FROM_SERVER));
  paths_to_delete.push_back(GetCacheFilePath(resource_id,
                                             util::kWildCard,
                                             CACHE_TYPE_TMP,
                                             CACHED_FILE_FROM_SERVER));

  paths_to_delete.push_back(GetCacheFilePath(resource_id,
                                             std::string(),
                                             CACHE_TYPE_PINNED,
                                             CACHED_FILE_FROM_SERVER));

  FilePath path_to_keep = GetCacheFilePath(resource_id,
                                           std::string(),
                                           CACHE_TYPE_PERSISTENT,
                                           CACHED_FILE_LOCALLY_MODIFIED);

  for (size_t i = 0; i < paths_to_delete.size(); ++i) {
    DeleteFilesSelectively(paths_to_delete[i], path_to_keep);
  }

  metadata_->RemoveFromCache(resource_id);

  *error = base::PLATFORM_FILE_OK;
}

bool DownloadItemImpl::IsPartialDownload() const {
  return (state_ == IN_PROGRESS);
}

std::string EscapeCacheFileName(const std::string& filename) {
  std::string escaped;
  for (size_t i = 0; i < filename.size(); ++i) {
    char c = filename[i];
    if (c == '%' || c == '.' || c == '/') {
      base::StringAppendF(&escaped, "%%%02X", c);
    } else {
      escaped.push_back(c);
    }
  }
  return escaped;
}

  virtual ~DeleteViewAnimationDelegate() {}

void GDataCacheMetadataMap::UpdateCache(const std::string& resource_id,
                                    const std::string& md5,
                                    GDataCache::CacheSubDirectoryType subdir,
                                    int cache_state) {
  AssertOnSequencedWorkerPool();

  CacheMap::iterator iter = cache_map_.find(resource_id);
  if (iter == cache_map_.end()) {  // New resource, create new entry.
    DCHECK(cache_state != GDataCache::CACHE_STATE_NONE);
    if (cache_state != GDataCache::CACHE_STATE_NONE) {
      GDataCache::CacheEntry cache_entry(md5, subdir, cache_state);
      cache_map_.insert(std::make_pair(resource_id, cache_entry));
      DVLOG(1) << "Added res_id=" << resource_id
               << ", " << cache_entry.ToString();
    }
  } else {  // Resource exists.
    if (cache_state == GDataCache::CACHE_STATE_NONE) {
      DVLOG(1) << "Deleting res_id=" << resource_id
               << ", " << iter->second.ToString();
      cache_map_.erase(iter);
    } else {  // Otherwise, update entry in cache map.
      iter->second.md5 = md5;
      iter->second.sub_dir_type = subdir;
      iter->second.cache_state = cache_state;
      DVLOG(1) << "Updated res_id=" << resource_id
               << ", " << iter->second.ToString();
    }
  }
}

void SetUpCacheWithVariousFiles() {
    // Create some files in persistent directory.
    
    CreateFile(persistent_directory_.AppendASCII("id_foo.md5foo"));
    CreateFile(persistent_directory_.AppendASCII("id_bar.local"));
    // "id_baz" is dirty but does not have a symlink in outgoing
    // directory. This file should be removed.
    CreateFile(persistent_directory_.AppendASCII("id_baz.local"));
    // "id_bad" is in persistent directory, but does not have a link in
    // pinned directory. This file should be removed.
    CreateFile(persistent_directory_.AppendASCII("id_bad.md5bad"));
    // "id_symlink" is invalid, as symlink is not allowed here. This should
    // be moreved.
    CreateSymbolicLink(FilePath::FromUTF8Unsafe(util::kSymLinkToDevNull),
                       persistent_directory_.AppendASCII("id_symlink"));
    // Create some files in tmp directory.
    
    CreateFile(tmp_directory_.AppendASCII("id_qux.md5qux"));
    // "id_quux" is invalid as we shouldn't have a dirty file in "tmp".
    CreateFile(tmp_directory_.AppendASCII("id_quux.local"));
    // "id_symlink_tmp" is invalid, as symlink is not allowed here. This
    // should be moreved.
    CreateSymbolicLink(FilePath::FromUTF8Unsafe(util::kSymLinkToDevNull),
                       tmp_directory_.AppendASCII("id_symlink_tmp"));
    // Create symbolic links in pinned directory.
    
    // "id_foo" is pinned, and present locally.
    CreateSymbolicLink(persistent_directory_.AppendASCII("id_foo.md5foo"),
                       pinned_directory_.AppendASCII("id_foo"));
    // "id_corge" is pinned, but not present locally. It's properly pointing
    // to /dev/null.
    CreateSymbolicLink(FilePath::FromUTF8Unsafe(util::kSymLinkToDevNull),
                       pinned_directory_.AppendASCII("id_corge"));
    // "id_dangling" is pointing to a non-existent file. The symlink should
    // be removed.
    CreateSymbolicLink(persistent_directory_.AppendASCII("id_dangling.md5foo"),
                       pinned_directory_.AppendASCII("id_dangling"));
    // "id_outside" is pointing to a file outside of persistent
    // directory. The symlink should be removed.
    CreateSymbolicLink(tmp_directory_.AppendASCII("id_qux.md5qux"),
                       pinned_directory_.AppendASCII("id_outside"));
    // "id_not_symlink" is not a symlink. This should be removed.
    CreateFile(pinned_directory_.AppendASCII("id_not_symlink"));
    // Create symbolic links in outgoing directory.
    
    // "id_bar" is dirty and committed.
    CreateSymbolicLink(persistent_directory_.AppendASCII("id_bar.local"),
                       outgoing_directory_.AppendASCII("id_bar"));
    // "id_foo" is not dirty. This symlink should be removed.
    CreateSymbolicLink(persistent_directory_.AppendASCII("id_foo.md5foo"),
                       outgoing_directory_.AppendASCII("id_foo"));
}

DownloadItemImpl::DownloadItemImpl(Delegate* delegate,
                                   DownloadId download_id,
                                   const DownloadPersistentStoreInfo& info,
                                   const net::BoundNetLog& bound_net_log)
    : download_id_(download_id),
      current_path_(info.path),
      target_path_(info.path),
      target_disposition_(TARGET_DISPOSITION_OVERWRITE),
      url_chain_(1, info.url),
      referrer_url_(info.referrer_url),
      transition_type_(content::PAGE_TRANSITION_LINK),
      has_user_gesture_(false),
      total_bytes_(info.total_bytes),
      received_bytes_(info.received_bytes),
      bytes_per_sec_(0),
      last_reason_(content::DOWNLOAD_INTERRUPT_REASON_NONE),
      start_tick_(base::TimeTicks()),
      state_(static_cast<DownloadState>(info.state)),
      danger_type_(content::DOWNLOAD_DANGER_TYPE_NOT_DANGEROUS),
      start_time_(info.start_time),
      end_time_(info.end_time),
      db_handle_(info.db_handle),
      delegate_(delegate),
      is_paused_(false),
      open_when_complete_(false),
      file_externally_removed_(false),
      safety_state_(SAFE),
      auto_opened_(false),
      is_persisted_(true),
      is_otr_(false),
      is_temporary_(false),
      all_data_saved_(false),
      opened_(info.opened),
      open_enabled_(true),
      delegate_delayed_complete_(false),
      bound_net_log_(bound_net_log),
      ALLOW_THIS_IN_INITIALIZER_LIST(weak_ptr_factory_(this)) {
  delegate_->Attach();
  if (IsInProgress())
    state_ = CANCELLED;
  if (IsComplete())
    all_data_saved_ = true;
  Init(false /* not actively downloading */,
       download_net_logs::SRC_HISTORY_IMPORT);
}

  DownloadFileManagerTest()
      : last_reason_(content::DOWNLOAD_INTERRUPT_REASON_NONE),
        ui_thread_(BrowserThread::UI, &loop_),
        file_thread_(BrowserThread::FILE, &loop_) {
  }

bool LauncherView::ShouldHideTooltip(const gfx::Point& cursor_location) {
  gfx::Rect active_bounds;

  for (int i = 0; i < child_count(); ++i) {
    views::View* child = child_at(i);
    if (child == overflow_button_)
      continue;

    gfx::Rect child_bounds = child->GetMirroredBounds();
    active_bounds = active_bounds.Union(child_bounds);
  }

  return !active_bounds.Contains(cursor_location);
}

scoped_ptr<GDataCache::CacheEntry> GDataCache::GetCacheEntry(
    const std::string& resource_id,
    const std::string& md5) {
  AssertOnSequencedWorkerPool();
  return metadata_->GetCacheEntry(resource_id, md5);
}

bool DownloadItemImpl::IsInterrupted() const {
  return (state_ == INTERRUPTED);
}

void ChromeDownloadManagerDelegate::ShouldCompleteDownloadInternal(
    int download_id,
    const base::Closure& user_complete_callback) {
  DownloadItem* item = download_manager_->GetDownload(download_id);
  if (!item)
    return;
  if (IsDownloadReadyForCompletion(item, base::Bind(
        &ChromeDownloadManagerDelegate::ShouldCompleteDownloadInternal, this,
        download_id, user_complete_callback)))
    user_complete_callback.Run();
}

void ShelfLayoutManager::SetAutoHideBehavior(ShelfAutoHideBehavior behavior) {
  if (auto_hide_behavior_ == behavior)
    return;
  auto_hide_behavior_ = behavior;
  UpdateVisibilityState();
  FOR_EACH_OBSERVER(Observer, observers_,
                    OnAutoHideStateChanged(state_.auto_hide_state));
}

void Launcher::SetFocusCycler(internal::FocusCycler* focus_cycler) {
  delegate_view_->set_focus_cycler(focus_cycler);
  focus_cycler->AddWidget(widget_.get());
}

  virtual ~FadeInAnimationDelegate() {}

 void DownloadFileManager::OnDownloadManagerShutdown(DownloadManager* manager) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::FILE));
  DCHECK(manager);

  std::set<DownloadFile*> to_remove;

  for (DownloadFileMap::iterator i = downloads_.begin();
       i != downloads_.end(); ++i) {
    DownloadFile* download_file = i->second;
    if (download_file->GetDownloadManager() == manager) {
      download_file->CancelDownloadRequest();
      to_remove.insert(download_file);
    }
  }

  for (std::set<DownloadFile*>::iterator i = to_remove.begin();
       i != to_remove.end(); ++i) {
    downloads_.erase((*i)->GlobalId());
    delete *i;
  }
}

const FilePath& DownloadItemImpl::GetTargetFilePath() const {
  return target_path_;
}

void DownloadFileManager::CompleteDownload(DownloadId global_id) {
   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::FILE));
 
   if (!ContainsKey(downloads_, global_id))
    return;

  DownloadFile* download_file = downloads_[global_id];

  VLOG(20) << " " << __FUNCTION__ << "()"
            << " id = " << global_id
            << " download_file = " << download_file->DebugString();
 
   download_file->Detach();
 
   EraseDownload(global_id);
 }

   GDataCacheMetadataMapTest() {}

View* LauncherView::GetFocusTraversableParentView() {
  return this;
}

void DownloadItemImpl::MarkAsComplete() {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  DCHECK(all_data_saved_);
  end_time_ = base::Time::Now();
  TransitionTo(COMPLETE);
}

ChromeDownloadManagerDelegate::ChromeDownloadManagerDelegate(Profile* profile)
    : profile_(profile),
      next_download_id_(0),
      download_prefs_(new DownloadPrefs(profile->GetPrefs())) {
}

  MockBrowserContext() { }

 MockDownloadFileManager::MockDownloadFileManager()
     : DownloadFileManager(new MockDownloadFileFactory) {
 }

void Launcher::UpdateBackground(int alpha) {
  ui::Layer* layer = widget_->GetNativeView()->layer();
  layer->SetColor(SkColorSetARGB(alpha, 0, 0, 0));
}

void GDataCache::SetMountedState(const FilePath& file_path,
                                 bool to_mount,
                                 base::PlatformFileError *error,
                                 FilePath* cache_file_path) {
  AssertOnSequencedWorkerPool();
  DCHECK(error);
  DCHECK(cache_file_path);

  std::string resource_id;
  std::string md5;
  std::string extra_extension;
  util::ParseCacheFilePath(file_path, &resource_id, &md5, &extra_extension);
  DCHECK(!to_mount == (extra_extension == util::kMountedArchiveFileExtension));

  scoped_ptr<CacheEntry> cache_entry = GetCacheEntry(
      resource_id, md5);
  if (!cache_entry.get()) {
    *error = base::PLATFORM_FILE_ERROR_NOT_FOUND;
    return;
  }
  if (to_mount == cache_entry->IsMounted()) {
    *error = base::PLATFORM_FILE_ERROR_INVALID_OPERATION;
    return;
  }

  CacheSubDirectoryType unmounted_subdir =
      cache_entry->IsPinned() ? CACHE_TYPE_PERSISTENT : CACHE_TYPE_TMP;
  FilePath unmounted_path = GetCacheFilePath(
      resource_id, md5, unmounted_subdir, CACHED_FILE_FROM_SERVER);

  CacheSubDirectoryType mounted_subdir = CACHE_TYPE_PERSISTENT;
  FilePath mounted_path = GetCacheFilePath(
      resource_id, md5, mounted_subdir, CACHED_FILE_MOUNTED);

  FilePath source_path;
  CacheSubDirectoryType dest_subdir;
  int cache_state = cache_entry->cache_state;
  if (to_mount) {
    source_path = unmounted_path;
    *cache_file_path = mounted_path;
    dest_subdir = mounted_subdir;
    cache_state = SetCacheMounted(cache_state);
  } else {
    source_path = mounted_path;
    *cache_file_path = unmounted_path;
    dest_subdir = unmounted_subdir;
    cache_state = ClearCacheMounted(cache_state);
  }

  *error = ModifyCacheState(source_path, *cache_file_path,
                            FILE_OPERATION_MOVE, FilePath(), false);
  if (*error == base::PLATFORM_FILE_OK) {
    metadata_->UpdateCache(resource_id, md5, dest_subdir, cache_state);
  }
}

void LauncherView::CalculateIdealBounds(IdealBounds* bounds) {
int available_size = primary_axis_coordinate(width(), height());
if (!available_size)
return;

  int x = primary_axis_coordinate(kLeadingInset, 0);
  int y = primary_axis_coordinate(0, kLeadingInset);
for (int i = 0; i < view_model_->view_size(); ++i) {
view_model_->set_ideal_bounds(i, gfx::Rect(
x, y, kLauncherPreferredSize, kLauncherPreferredSize));
x = primary_axis_coordinate(x + kLauncherPreferredSize + kButtonSpacing, 0);
y = primary_axis_coordinate(0, y + kLauncherPreferredSize + kButtonSpacing);
}

if (view_model_->view_size() > 0) {
// Makes the first launcher button include the leading inset.
view_model_->set_ideal_bounds(0, gfx::Rect(gfx::Size(
        primary_axis_coordinate(kLeadingInset + kLauncherPreferredSize,
kLauncherPreferredSize),
primary_axis_coordinate(kLauncherPreferredSize,
                                kLeadingInset + kLauncherPreferredSize))));
}

bounds->overflow_bounds.set_size(
gfx::Size(kLauncherPreferredSize, kLauncherPreferredSize));
last_visible_index_ = DetermineLastVisibleIndex(
      available_size - kLeadingInset - kLauncherPreferredSize -
kButtonSpacing - kLauncherPreferredSize);
  int app_list_index = view_model_->view_size() - 1;
bool show_overflow = (last_visible_index_ + 1 < app_list_index);

for (int i = 0; i < view_model_->view_size(); ++i) {
view_model_->view_at(i)->SetVisible(
i == app_list_index || i <= last_visible_index_);
}

overflow_button_->SetVisible(show_overflow);
if (show_overflow) {
DCHECK_NE(0, view_model_->view_size());
if (last_visible_index_ == -1) {
      x = primary_axis_coordinate(kLeadingInset, 0);
      y = primary_axis_coordinate(0, kLeadingInset);
} else {
x = primary_axis_coordinate(
view_model_->ideal_bounds(last_visible_index_).right(), 0);
y = primary_axis_coordinate(0,
view_model_->ideal_bounds(last_visible_index_).bottom());
}
gfx::Rect app_list_bounds = view_model_->ideal_bounds(app_list_index);
app_list_bounds.set_x(x);
app_list_bounds.set_y(y);
view_model_->set_ideal_bounds(app_list_index, app_list_bounds);
    x = primary_axis_coordinate(x + kLauncherPreferredSize + kButtonSpacing, 0);
    y = primary_axis_coordinate(0, y + kLauncherPreferredSize + kButtonSpacing);
    bounds->overflow_bounds.set_x(x);
    bounds->overflow_bounds.set_y(y);
}
}

void LauncherView::ConfigureChildView(views::View* view) {
  view->SetPaintToLayer(true);
  view->layer()->SetFillsBoundsOpaquely(false);
}

void GDataCache::OnPinned(base::PlatformFileError* error,
                          const std::string& resource_id,
                          const std::string& md5,
                          const CacheOperationCallback& callback) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  DCHECK(error);

  if (!callback.is_null())
    callback.Run(*error, resource_id, md5);

  if (*error == base::PLATFORM_FILE_OK)
    FOR_EACH_OBSERVER(Observer, observers_, OnCachePinned(resource_id, md5));
}

bool GDataCache::CreateCacheDirectories(
    const std::vector<FilePath>& paths_to_create) {
  bool success = true;
  for (size_t i = 0; i < paths_to_create.size(); ++i) {
    if (file_util::DirectoryExists(paths_to_create[i]))
      continue;
    if (!file_util::CreateDirectory(paths_to_create[i])) {
      // Error creating this directory, record error and proceed with next one.
      success = false;
      PLOG(ERROR) << "Error creating directory " << paths_to_create[i].value();
    } else {
      DVLOG(1) << "Created directory " << paths_to_create[i].value();
    }
  }
  return success;
}

void LauncherView::UpdateFirstButtonPadding() {
// Creates an empty border for first launcher button to make included leading
// inset act as the button's padding. This is only needed on button creation
// and when shelf alignment changes.
if (view_model_->view_size() > 0) {
view_model_->view_at(0)->set_border(views::Border::CreateEmptyBorder(
        primary_axis_coordinate(0, kLeadingInset),
        primary_axis_coordinate(kLeadingInset, 0),
0,
0));
}
}

DownloadId ChromeDownloadManagerDelegate::GetNextId() {
  if (!profile_->IsOffTheRecord())
    return DownloadId(this, next_download_id_++);

  return BrowserContext::GetDownloadManager(profile_->GetOriginalProfile())->
      GetDelegate()->GetNextId();
}

gfx::Rect ShelfLayoutManager::GetMaximizedWindowBounds(
    aura::Window* window) {
  gfx::Rect bounds(gfx::Screen::GetDisplayNearestWindow(window).bounds());
  if (auto_hide_behavior_ == SHELF_AUTO_HIDE_BEHAVIOR_DEFAULT ||
      auto_hide_behavior_ == SHELF_AUTO_HIDE_BEHAVIOR_ALWAYS) {
    AdjustBoundsBasedOnAlignment(kAutoHideSize, &bounds);
    return bounds;
  }
  return GetUnmaximizedWorkAreaBounds(window);
}

void DownloadFileManager::Shutdown() {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  BrowserThread::PostTask(
      BrowserThread::FILE, FROM_HERE,
      base::Bind(&DownloadFileManager::OnShutdown, this));
}

void GDataCache::GetResourceIdsOfBacklog(
    std::vector<std::string>* to_fetch,
    std::vector<std::string>* to_upload) {
  AssertOnSequencedWorkerPool();
  DCHECK(to_fetch);
  DCHECK(to_upload);

  metadata_->Iterate(base::Bind(&CollectBacklog, to_fetch, to_upload));
}

void DownloadItemImpl::UpdateObservers() {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  FOR_EACH_OBSERVER(Observer, observers_, OnDownloadUpdated(this));
}

 void SetFreeDiskSpaceGetterForTesting(FreeDiskSpaceGetterInterface* getter) {
   delete global_free_disk_getter_for_testing;  // Safe to delete NULL;
   global_free_disk_getter_for_testing = getter;
}

FilePath ExtractGDataPath(const FilePath& path) {
  if (!IsUnderGDataMountPoint(path))
    return FilePath();

  std::vector<FilePath::StringType> components;
  path.GetComponents(&components);

  FilePath extracted;
  for (size_t i = arraysize(kGDataMountPointPathComponents) - 1;
       i < components.size(); ++i) {
    extracted = extracted.Append(components[i]);
  }
  return extracted;
}

DownloadFileManager::~DownloadFileManager() {
  DCHECK(downloads_.empty());
}

void ShelfLayoutManager::OnWindowResized() {
  LayoutShelf();
}

void ChromeDownloadManagerDelegate::DisableSafeBrowsing(DownloadItem* item) {
#if defined(ENABLE_SAFE_BROWSING)
  SafeBrowsingState* state = static_cast<SafeBrowsingState*>(
      item->GetExternalData(&safe_browsing_id));
  DCHECK(!state);
  if (!state)
    state = new SafeBrowsingState();
  state->SetVerdict(DownloadProtectionService::SAFE);
  item->SetExternalData(&safe_browsing_id, state);
#endif
}

  void ClearExpectations(DownloadId id) {
    MockDownloadFile* file = download_file_factory_->GetExistingFile(id);
    Mock::VerifyAndClearExpectations(file);
    Mock::VerifyAndClearExpectations(download_manager_);
  }

int DownloadItemImpl::PercentComplete() const {
  if (delegate_delayed_complete_ || total_bytes_ <= 0)
    return -1;

  return static_cast<int>(received_bytes_ * 100.0 / total_bytes_);
}

content::DownloadDangerType DownloadItemImpl::GetDangerType() const {
  return danger_type_;
}

void ShelfLayoutManager::OnChildWindowVisibilityChanged(aura::Window* child,
                                                        bool visible) {
}

DownloadItemImpl::GetExternalData(const void* key) {
  return const_cast<DownloadItem::ExternalData*>(
      static_cast<const DownloadItemImpl&>(*this).GetExternalData(key));
}

  void ProcessAllPendingMessages() {
    loop_.RunAllPending();
  }

void ChromeDownloadManagerDelegate::CheckDownloadUrlDone(
    int32 download_id,
    DownloadProtectionService::DownloadCheckResult result) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  DownloadItem* download =
      download_manager_->GetActiveDownloadItem(download_id);
  if (!download)
    return;

  VLOG(2) << __FUNCTION__ << "() download = " << download->DebugString(false)
          << " verdict = " << result;
  content::DownloadDangerType danger_type = download->GetDangerType();
  if (result != DownloadProtectionService::SAFE)
    danger_type = content::DOWNLOAD_DANGER_TYPE_DANGEROUS_URL;

  download_history_->CheckVisitedReferrerBefore(
      download_id, download->GetReferrerUrl(),
      base::Bind(&ChromeDownloadManagerDelegate::CheckVisitedReferrerBeforeDone,
                 base::Unretained(this), download_id, danger_type));
}

bool DownloadItemImpl::CanOpenDownload() {
  return !file_externally_removed_;
}

void GDataCache::StoreOnUIThread(const std::string& resource_id,
                                 const std::string& md5,
                                 const FilePath& source_path,
                                 FileOperationType file_operation_type,
                                 const CacheOperationCallback& callback) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  base::PlatformFileError* error =
      new base::PlatformFileError(base::PLATFORM_FILE_OK);
  pool_->GetSequencedTaskRunner(sequence_token_)->PostTaskAndReply(
      FROM_HERE,
      base::Bind(&GDataCache::Store,
                 base::Unretained(this),
                 resource_id,
                 md5,
                 source_path,
                 file_operation_type,
                 error),
      base::Bind(&RunCacheOperationCallback,
                 callback,
                 base::Owned(error),
                 resource_id,
                 md5));
}

void GDataCache::GetFileOnUIThread(const std::string& resource_id,
                                   const std::string& md5,
                                   const GetFileFromCacheCallback& callback) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  base::PlatformFileError* error =
      new base::PlatformFileError(base::PLATFORM_FILE_OK);
  FilePath* cache_file_path = new FilePath;
  pool_->GetSequencedTaskRunner(sequence_token_)->PostTaskAndReply(
      FROM_HERE,
      base::Bind(&GDataCache::GetFile,
                 base::Unretained(this),
                 resource_id,
                 md5,
                 error,
                 cache_file_path),
      base::Bind(&RunGetFileFromCacheCallback,
                 callback,
                 base::Owned(error),
                 resource_id,
                 md5,
                 base::Owned(cache_file_path)));
}

    explicit MockObserver(DownloadItem* item) : item_(item), updated_(false) {
      item_->AddObserver(this);
    }

    GetAlternativeWebContentsToNotifyForDownload() {
#if defined(OS_ANDROID)
  return NULL;
#else
  Browser* last_active = browser::FindLastActiveWithProfile(profile_);
  return last_active ? chrome::GetActiveWebContents(last_active) : NULL;
#endif
}

void LauncherView::MouseMovedOverButton(views::View* view) {
  if (!tooltip_->IsVisible())
    tooltip_->ResetTimer();
}

void ShelfLayoutManager::CalculateTargetBounds(
    const State& state,
    TargetBounds* target_bounds) {
  const gfx::Rect& available_bounds(
      status_->GetNativeView()->GetRootWindow()->bounds());
  gfx::Rect status_bounds(status_->GetWindowScreenBounds());
  gfx::Size launcher_size = launcher_ ?
      launcher_widget()->GetContentsView()->GetPreferredSize() : gfx::Size();
  int shelf_size = 0;
  int shelf_width = 0, shelf_height = 0;
  GetShelfSize(&shelf_width, &shelf_height);
  if (state.visibility_state == VISIBLE ||
      (state.visibility_state == AUTO_HIDE &&
       state.auto_hide_state == AUTO_HIDE_SHOWN)) {
    shelf_size = std::max(shelf_width, shelf_height);
  } else if (state.visibility_state == AUTO_HIDE &&
             state.auto_hide_state == AUTO_HIDE_HIDDEN) {
    shelf_size = kAutoHideSize;
  }
  if (alignment_ == SHELF_ALIGNMENT_BOTTOM) {
    int y = available_bounds.bottom();
    y -= shelf_size;
    target_bounds->status_bounds = gfx::Rect(
        base::i18n::IsRTL() ? available_bounds.x() :
        available_bounds.right() - status_bounds.width(),
        y + shelf_height - status_bounds.height(),
        status_bounds.width(), status_bounds.height());
    if (launcher_widget()) {
      target_bounds->launcher_bounds = gfx::Rect(
          available_bounds.x(),
          y + (shelf_height - launcher_size.height()) / 2,
          available_bounds.width(),
          launcher_size.height());
    }
    target_bounds->work_area_insets.Set(
        0, 0, GetWorkAreaSize(state, shelf_height), 0);
  } else {
    int x = (alignment_ == SHELF_ALIGNMENT_LEFT) ?
        available_bounds.x() + shelf_size - shelf_width :
        available_bounds.right() - shelf_size;
    target_bounds->status_bounds = gfx::Rect(
        x, available_bounds.bottom() - status_bounds.height(),
        shelf_width, status_bounds.height());
    if (launcher_widget()) {
      target_bounds->launcher_bounds = gfx::Rect(
          x,
          available_bounds.y(),
          launcher_size.width(),
          available_bounds.height());
    }
    if (alignment_ == SHELF_ALIGNMENT_LEFT) {
      target_bounds->work_area_insets.Set(
          0, GetWorkAreaSize(state, shelf_width), 0, 0);
    } else {
      target_bounds->work_area_insets.Set(
          0, 0, 0, GetWorkAreaSize(state, shelf_width));
    }
  }
  target_bounds->opacity =
      (state.visibility_state == VISIBLE ||
       state.visibility_state == AUTO_HIDE) ? 1.0f : 0.0f;
}

void GDataCache::RemoveObserver(Observer* observer) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  observers_.RemoveObserver(observer);
}

WebContents* DownloadItemImpl::GetWebContents() const {
  if (request_handle_.get())
    return request_handle_->GetWebContents();
  return NULL;
}

void GDataCacheMetadataMap::ScanCacheDirectory(
const std::vector<FilePath>& cache_paths,
GDataCache::CacheSubDirectoryType sub_dir_type,
    CacheMap* cache_map,
    ResourceIdToFilePathMap* processed_file_map) {
  DCHECK(cache_map);
  DCHECK(processed_file_map);
file_util::FileEnumerator enumerator(
cache_paths[sub_dir_type],
false,  // not recursive
static_cast<file_util::FileEnumerator::FileType>(
file_util::FileEnumerator::FILES |
file_util::FileEnumerator::SHOW_SYM_LINKS),
util::kWildCard);
for (FilePath current = enumerator.Next(); !current.empty();
current = enumerator.Next()) {
// Extract resource_id and md5 from filename.
std::string resource_id;
std::string md5;
std::string extra_extension;
util::ParseCacheFilePath(current, &resource_id, &md5, &extra_extension);

// Determine cache state.
int cache_state = GDataCache::CACHE_STATE_NONE;
// If we're scanning pinned directory and if entry already exists, just
// update its pinned state.
if (sub_dir_type == GDataCache::CACHE_TYPE_PINNED) {
      std::string reason;
      if (!IsValidSymbolicLink(current, sub_dir_type, cache_paths, &reason)) {
        LOG(WARNING) << "Removing an invalid symlink: " << current.value()
                     << ": " << reason;
        util::DeleteSymlink(current);
        continue;
      }
CacheMap::iterator iter = cache_map->find(resource_id);
if (iter != cache_map->end()) {  // Entry exists, update pinned state.
iter->second.cache_state =
GDataCache::SetCachePinned(iter->second.cache_state);
        processed_file_map->insert(std::make_pair(resource_id, current));
continue;
}
// Entry doesn't exist, this is a special symlink that refers to
// /dev/null; follow through to create an entry with the PINNED but not
// PRESENT state.
cache_state = GDataCache::SetCachePinned(cache_state);
} else if (sub_dir_type == GDataCache::CACHE_TYPE_OUTGOING) {
      std::string reason;
      if (!IsValidSymbolicLink(current, sub_dir_type, cache_paths, &reason)) {
        LOG(WARNING) << "Removing an invalid symlink: " << current.value()
                     << ": " << reason;
        util::DeleteSymlink(current);
        continue;
      }
      // If we're scanning outgoing directory, entry must exist and be dirty.
      // Otherwise, it's a logic error from previous execution, remove this
      // outgoing symlink and move on.
CacheMap::iterator iter = cache_map->find(resource_id);
      if (iter == cache_map->end() || !iter->second.IsDirty()) {
        LOG(WARNING) << "Removing an symlink to a non-dirty file: "
                     << current.value();
        util::DeleteSymlink(current);
        continue;
      }
      processed_file_map->insert(std::make_pair(resource_id, current));
      continue;
    } else if (sub_dir_type == GDataCache::CACHE_TYPE_PERSISTENT ||
               sub_dir_type == GDataCache::CACHE_TYPE_TMP) {
      FilePath unused;
      if (file_util::ReadSymbolicLink(current, &unused)) {
        LOG(WARNING) << "Removing a symlink in persistent/tmp directory"
                     << current.value();
        util::DeleteSymlink(current);
        continue;
      }
      if (extra_extension == util::kMountedArchiveFileExtension) {
        // Mounted archives in cache should be unmounted upon logout/shutdown.
        // But if we encounter a mounted file at start, delete it and create an
        // entry with not PRESENT state.
        DCHECK(sub_dir_type == GDataCache::CACHE_TYPE_PERSISTENT);
        file_util::Delete(current, false);
} else {
        // The cache file is present.
        cache_state = GDataCache::SetCachePresent(cache_state);
        // Adds the dirty bit if |md5| indicates that the file is dirty, and
        // the file is in the persistent directory.
        if (md5 == util::kLocallyModifiedFileExtension) {
          if (sub_dir_type == GDataCache::CACHE_TYPE_PERSISTENT) {
            cache_state |= GDataCache::SetCacheDirty(cache_state);
          } else {
            LOG(WARNING) << "Removing a dirty file in tmp directory: "
                         << current.value();
            file_util::Delete(current, false);
            continue;
          }
        }
}
} else {
      NOTREACHED() << "Unexpected sub directory type: " << sub_dir_type;
}

// Create and insert new entry into cache map.
cache_map->insert(std::make_pair(
resource_id, GDataCache::CacheEntry(md5, sub_dir_type, cache_state)));
    processed_file_map->insert(std::make_pair(resource_id, current));
}
}

void GDataCache::GetFile(const std::string& resource_id,
                         const std::string& md5,
                         base::PlatformFileError* error,
                         FilePath* cache_file_path) {
  AssertOnSequencedWorkerPool();
  DCHECK(error);
  DCHECK(cache_file_path);

  scoped_ptr<CacheEntry> cache_entry = GetCacheEntry(
      resource_id, md5);
  if (cache_entry.get() && cache_entry->IsPresent()) {
    CachedFileOrigin file_origin;
    if (cache_entry->IsMounted()) {
      file_origin = CACHED_FILE_MOUNTED;
    } else if (cache_entry->IsDirty()) {
      file_origin = CACHED_FILE_LOCALLY_MODIFIED;
    } else {
      file_origin = CACHED_FILE_FROM_SERVER;
    }
    *cache_file_path = GetCacheFilePath(
        resource_id,
        md5,
        cache_entry->sub_dir_type,
        file_origin);
    *error = base::PLATFORM_FILE_OK;
  } else {
    *error = base::PLATFORM_FILE_ERROR_NOT_FOUND;
  }
}

void ChromeDownloadManagerDelegate::OnPathExistenceAvailable(
    int32 download_id,
    const FilePath& target_path,
    DownloadItem::TargetDisposition disposition,
    content::DownloadDangerType danger_type) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  DownloadItem* download =
      download_manager_->GetActiveDownloadItem(download_id);
  if (!download)
    return;
  download->OnTargetPathDetermined(target_path, disposition, danger_type);
  download_manager_->RestartDownload(download_id);
}

const std::string& DownloadItemImpl::GetHashState() const {
  return hash_state_;
}

  MockDownloadManagerDelegate& GetMockDownloadManagerDelegate() {
    return *mock_download_manager_delegate_;
  }

void DownloadFileManager::CreateDownloadFile(
    scoped_ptr<DownloadCreateInfo> info,
    scoped_ptr<content::ByteStreamReader> stream,
    scoped_refptr<DownloadManager> download_manager, bool get_hash,
    const net::BoundNetLog& bound_net_log,
    const CreateDownloadFileCallback& callback) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::FILE));
  DCHECK(info.get());
  VLOG(20) << __FUNCTION__ << "()" << " info = " << info->DebugString();

  scoped_ptr<DownloadFile> download_file(download_file_factory_->CreateFile(
      info.get(), stream.Pass(), download_manager, get_hash, bound_net_log));

  content::DownloadInterruptReason interrupt_reason(
      content::ConvertNetErrorToInterruptReason(
          download_file->Initialize(), content::DOWNLOAD_INTERRUPT_FROM_DISK));
  if (interrupt_reason == content::DOWNLOAD_INTERRUPT_REASON_NONE) {
    DCHECK(GetDownloadFile(info->download_id) == NULL);
    downloads_[info->download_id] = download_file.release();
  }

  BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,
                          base::Bind(callback, interrupt_reason));
}

  ~DownloadFileManagerTest() {
  }

void DownloadItemImpl::Remove() {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  delegate_->AssertStateConsistent(this);
  Cancel(true);
  delegate_->AssertStateConsistent(this);

  TransitionTo(REMOVING);
  delegate_->DownloadRemoved(this);
}

void ShelfLayoutManager::SetLauncher(Launcher* launcher) {
  if (launcher == launcher_)
    return;

  launcher_ = launcher;
  LayoutShelf();
}

  virtual void TearDown() {
    ui_thread_.DeprecatedGetThreadObject()->message_loop()->RunAllPending();
    STLDeleteElements(&allocated_downloads_);
    allocated_downloads_.clear();
  }

bool DownloadItemImpl::IsTemporary() const { return is_temporary_; }

std::string DownloadItemImpl::GetReferrerCharset() const {
  return referrer_charset_;
}

const std::string& DownloadItemImpl::GetHash() const { return hash_; }

  virtual ~StartFadeAnimationDelegate() {}

void RemoveInvalidFilesFromPersistentDirectory(
    const GDataCacheMetadataMap::ResourceIdToFilePathMap& persistent_file_map,
    const GDataCacheMetadataMap::ResourceIdToFilePathMap& outgoing_file_map,
    GDataCacheMetadataMap::CacheMap* cache_map) {
  for (GDataCacheMetadataMap::ResourceIdToFilePathMap::const_iterator iter =
           persistent_file_map.begin();
       iter != persistent_file_map.end(); ++iter) {
    const std::string& resource_id = iter->first;
    const FilePath& file_path = iter->second;
    GDataCacheMetadataMap::CacheMap::iterator cache_map_iter =
        cache_map->find(resource_id);
    if (cache_map_iter != cache_map->end()) {
      const GDataCache::CacheEntry& cache_entry = cache_map_iter->second;
      // If the file is dirty but not committed, remove it.
      if (cache_entry.IsDirty() && outgoing_file_map.count(resource_id) == 0) {
        LOG(WARNING) << "Removing dirty-but-not-committed file: "
                     << file_path.value();
        file_util::Delete(file_path, false);
        cache_map->erase(cache_map_iter);
      }
      // If the file is neither dirty nor pinned, remove it.
      if (!cache_entry.IsDirty() && !cache_entry.IsPinned()) {
        LOG(WARNING) << "Removing persistent-but-dangling file: "
                     << file_path.value();
        file_util::Delete(file_path, false);
        cache_map->erase(cache_map_iter);
      }
    }
  }
}

 void LauncherView::OnBoundsAnimatorProgressed(views::BoundsAnimator* animator) {
   FOR_EACH_OBSERVER(LauncherIconObserver, observers_,
                     OnLauncherIconPositionsChanged());
 }

GDataCacheMetadataMap::~GDataCacheMetadataMap() {
  AssertOnSequencedWorkerPool();
}

base::PlatformFileError ModifyCacheState(
const FilePath& source_path,
const FilePath& dest_path,
GDataCache::FileOperationType file_operation_type,
const FilePath& symlink_path,
bool create_symlink) {
// Move or copy |source_path| to |dest_path| if they are different.
if (source_path != dest_path) {
bool success = false;
if (file_operation_type == GDataCache::FILE_OPERATION_MOVE)
success = file_util::Move(source_path, dest_path);
else if (file_operation_type == GDataCache::FILE_OPERATION_COPY)
success = file_util::CopyFile(source_path, dest_path);
if (!success) {
base::PlatformFileError error = SystemToPlatformError(errno);
PLOG(ERROR) << "Error "
<< (file_operation_type == GDataCache::FILE_OPERATION_MOVE ?
"moving " : "copying ")
<< source_path.value()
<< " to " << dest_path.value();
return error;
} else {
DVLOG(1) << (file_operation_type == GDataCache::FILE_OPERATION_MOVE ?
"Moved " : "Copied ")
<< source_path.value()
<< " to " << dest_path.value();
}
} else {
DVLOG(1) << "No need to move file: source = destination";
}

if (symlink_path.empty())
return base::PLATFORM_FILE_OK;

// Remove symlink regardless of |create_symlink| because creating a link will
// not overwrite an existing one.
// We try to save one file operation by not checking if link exists before
// deleting it, so unlink may return error if link doesn't exist, but it
// doesn't really matter to us.
  bool deleted = util::DeleteSymlink(symlink_path);
if (deleted) {
DVLOG(1) << "Deleted symlink " << symlink_path.value();
} else {
// Since we didn't check if symlink exists before deleting it, don't log
// if symlink doesn't exist.
if (errno != ENOENT)
PLOG(WARNING) << "Error deleting symlink " << symlink_path.value();
}

if (!create_symlink)
return base::PLATFORM_FILE_OK;

// Create new symlink to |dest_path|.
if (!file_util::CreateSymbolicLink(dest_path, symlink_path)) {
base::PlatformFileError error = SystemToPlatformError(errno);
PLOG(ERROR) << "Error creating symlink " << symlink_path.value()
<< " for " << dest_path.value();
return error;
} else {
DVLOG(1) << "Created symlink " << symlink_path.value()
<< " to " << dest_path.value();
}

return base::PLATFORM_FILE_OK;
}

void ShelfLayoutManager::OnWillRemoveWindowFromLayout(aura::Window* child) {
}

void RunGetCacheEntryCallback(
    const GDataCache::GetCacheEntryCallback& callback,
    bool* success,
    GDataCache::CacheEntry* cache_entry) {
  DCHECK(success);
  DCHECK(cache_entry);

  if (!callback.is_null())
    callback.Run(*success, *cache_entry);
}

void Launcher::SetPaintsBackground(
      bool value,
      internal::BackgroundAnimator::ChangeType change_type) {
  background_animator_.SetPaintsBackground(value, change_type);
}

content::PageTransition DownloadItemImpl::GetTransitionType() const {
  return transition_type_;
};

void OnGetFileInfoForInsertGDataCachePathsPermissions(
    Profile* profile,
    std::vector<std::pair<FilePath, int> >* cache_paths,
    const base::Closure& callback,
    base::PlatformFileError error,
    scoped_ptr<GDataFileProto> file_info) {
  DCHECK(profile);
  DCHECK(cache_paths);
  DCHECK(!callback.is_null());

  GDataCache* cache = GetGDataCache(profile);
  if (!cache || error != base::PLATFORM_FILE_OK) {
    callback.Run();
    return;
  }

  DCHECK(file_info.get());
  std::string resource_id = file_info->gdata_entry().resource_id();
  std::string file_md5 = file_info->file_md5();

  cache_paths->push_back(std::make_pair(
      cache->GetCacheFilePath(resource_id, file_md5,
          GDataCache::CACHE_TYPE_PERSISTENT,
          GDataCache::CACHED_FILE_FROM_SERVER),
      kReadOnlyFilePermissions));
  cache_paths->push_back(std::make_pair(
      cache->GetCacheFilePath(resource_id, file_md5,
          GDataCache::CACHE_TYPE_PERSISTENT,
          GDataCache::CACHED_FILE_LOCALLY_MODIFIED),
     kReadOnlyFilePermissions));
  cache_paths->push_back(std::make_pair(
      cache->GetCacheFilePath(resource_id, file_md5,
          GDataCache::CACHE_TYPE_PERSISTENT,
          GDataCache::CACHED_FILE_MOUNTED),
     kReadOnlyFilePermissions));
  cache_paths->push_back(std::make_pair(
      cache->GetCacheFilePath(resource_id, file_md5,
          GDataCache::CACHE_TYPE_TMP,
          GDataCache::CACHED_FILE_FROM_SERVER),
      kReadOnlyFilePermissions));

  callback.Run();
}

DownloadItemImpl::~DownloadItemImpl() {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  TransitionTo(REMOVING);
  STLDeleteContainerPairSecondPointers(
      external_data_map_.begin(), external_data_map_.end());
  delegate_->AssertStateConsistent(this);
  delegate_->Detach();
}

  void OnDownloadFileCreated(content::DownloadInterruptReason reason) {
    last_reason_ = reason;
  }

void DeleteFilesSelectively(const FilePath& path_to_delete_pattern,
                            const FilePath& path_to_keep) {
  bool success = true;
  file_util::FileEnumerator enumerator(
      path_to_delete_pattern.DirName(),
      false,  // not recursive
      static_cast<file_util::FileEnumerator::FileType>(
          file_util::FileEnumerator::FILES |
          file_util::FileEnumerator::SHOW_SYM_LINKS),
      path_to_delete_pattern.BaseName().value());
  for (FilePath current = enumerator.Next(); !current.empty();
       current = enumerator.Next()) {
    if (!path_to_keep.empty() && current == path_to_keep)
      continue;

    success = HANDLE_EINTR(unlink(current.value().c_str())) == 0;
    if (!success)
      DVLOG(1) << "Error deleting " << current.value();
    else
      DVLOG(1) << "Deleted " << current.value();
  }
}

void ChromeDownloadManagerDelegate::Observe(
    int type,
    const content::NotificationSource& source,
    const content::NotificationDetails& details) {
  DCHECK(type == chrome::NOTIFICATION_CRX_INSTALLER_DONE);

  registrar_.Remove(this,
                    chrome::NOTIFICATION_CRX_INSTALLER_DONE,
                    source);

  scoped_refptr<CrxInstaller> installer =
      content::Source<CrxInstaller>(source).ptr();
  int download_id = crx_installers_[installer];
  crx_installers_.erase(installer.get());

  DownloadItem* item = download_manager_->GetActiveDownloadItem(download_id);
  if (item)
    item->DelayedDownloadOpened(installer->did_handle_successfully());
}

std::vector<FilePath> GDataCache::GetCachePaths(
    const FilePath& cache_root_path) {
  std::vector<FilePath> cache_paths;
  // The order should match GDataCache::CacheSubDirectoryType enum.
  cache_paths.push_back(cache_root_path.Append(kGDataCacheMetaDir));
  cache_paths.push_back(cache_root_path.Append(kGDataCachePinnedDir));
  cache_paths.push_back(cache_root_path.Append(kGDataCacheOutgoingDir));
  cache_paths.push_back(cache_root_path.Append(kGDataCachePersistentDir));
  cache_paths.push_back(cache_root_path.Append(kGDataCacheTmpDir));
  cache_paths.push_back(cache_root_path.Append(kGDataCacheTmpDownloadsDir));
  cache_paths.push_back(cache_root_path.Append(kGDataCacheTmpDocumentsDir));
  return cache_paths;
}

void ParseCacheFilePath(const FilePath& path,
                        std::string* resource_id,
                        std::string* md5,
                        std::string* extra_extension) {
  DCHECK(resource_id);
  DCHECK(md5);
  DCHECK(extra_extension);

  FilePath base_name = path.BaseName();
  const int kNumExtensionsToExtract = 2;
  std::vector<FilePath::StringType> extensions;
  for (int i = 0; i < kNumExtensionsToExtract; ++i) {
    FilePath::StringType extension = base_name.Extension();
    if (!extension.empty()) {
      extension = UnescapeCacheFileName(extension.substr(1));
      base_name = base_name.RemoveExtension();
      extensions.push_back(extension);
    } else {
      break;
    }
  }

  *resource_id = UnescapeCacheFileName(base_name.value());

  int extension_count = extensions.size();
  *md5 = (extension_count > 0) ? extensions[extension_count - 1] :
                                 std::string();
  *extra_extension = (extension_count > 1) ? extensions[extension_count - 2] :
                                              std::string();
 }

 bool ChangeFilePermissions(const FilePath& file_path, mode_t permissions) {
   if (HANDLE_EINTR(chmod(file_path.value().c_str(), permissions)) != 0) {
    PLOG(ERROR) << "Error changing permissions of " << file_path.value();
    return false;
  }
  DVLOG(1) << "Changed permissions of " << file_path.value();
   return true;
 }

void GDataCache::Store(const std::string& resource_id,
                       const std::string& md5,
                       const FilePath& source_path,
                       FileOperationType file_operation_type,
                       base::PlatformFileError* error) {
  AssertOnSequencedWorkerPool();
  DCHECK(error);

  FilePath dest_path;
  FilePath symlink_path;
  int cache_state = CACHE_STATE_PRESENT;
  CacheSubDirectoryType sub_dir_type = CACHE_TYPE_TMP;

  scoped_ptr<CacheEntry> cache_entry = GetCacheEntry(resource_id, md5);

  if (cache_entry.get()) {  // File exists in cache.
    if (cache_entry->IsDirty() || cache_entry->IsMounted()) {
      LOG(WARNING) << "Can't store a file to replace a "
                   << (cache_entry->IsDirty() ? "dirty" : "mounted")
                   << " file: res_id=" << resource_id
                   << ", md5=" << md5;
      *error = base::PLATFORM_FILE_ERROR_IN_USE;
      return;
    }

    cache_state |= cache_entry->cache_state;

    if (cache_entry->IsPinned()) {
      sub_dir_type = CACHE_TYPE_PERSISTENT;
      dest_path = GetCacheFilePath(resource_id, md5, sub_dir_type,
                                   CACHED_FILE_FROM_SERVER);
      symlink_path = GetCacheFilePath(
          resource_id, std::string(), CACHE_TYPE_PINNED,
          CACHED_FILE_FROM_SERVER);
    }
  }

  if (dest_path.empty()) {
    DCHECK_EQ(CACHE_TYPE_TMP, sub_dir_type);
    dest_path = GetCacheFilePath(resource_id, md5, sub_dir_type,
                                 CACHED_FILE_FROM_SERVER);
  }

  *error = ModifyCacheState(
      source_path,
      dest_path,
      file_operation_type,
      symlink_path,
      !symlink_path.empty());  // create symlink

  FilePath stale_filenames_pattern;
  if (md5.empty()) {
    stale_filenames_pattern = FilePath(dest_path.value() + util::kWildCard);
  } else {
    stale_filenames_pattern = dest_path.ReplaceExtension(util::kWildCard);
  }

  DeleteFilesSelectively(stale_filenames_pattern, dest_path);

  if (*error == base::PLATFORM_FILE_OK) {
    metadata_->UpdateCache(resource_id, md5, sub_dir_type, cache_state);
  }
}

void LauncherView::MousePressedOnButton(views::View* view,
                                        const views::MouseEvent& event) {
  tooltip_->Close();
  int index = view_model_->GetIndexOfView(view);
  if (index == -1 ||
      view_model_->view_size() <= 1 ||
      !delegate_->IsDraggable(model_->items()[index]))
    return;  // View is being deleted or not draggable, ignore request.

  drag_view_ = view;
  drag_offset_ = primary_axis_coordinate(event.x(), event.y());
}

void LauncherView::PrepareForDrag(const views::MouseEvent& event) {
  DCHECK(drag_view_);
  dragging_ = true;
  start_drag_index_ = view_model_->GetIndexOfView(drag_view_);

  if (start_drag_index_ == -1 ||
      !delegate_->IsDraggable(model_->items()[start_drag_index_])) {
    CancelDrag(-1);
    return;
  }

  ReorderChildView(drag_view_, -1);
  bounds_animator_->StopAnimatingView(drag_view_);
}

bool DownloadItemImpl::IsCancelled() const {
  return (state_ == CANCELLED) ||
         (state_ == INTERRUPTED);
}

base::Time DownloadItemImpl::GetStartTime() const { return start_time_; }

void DownloadItemImpl::SetOpened(bool opened) { opened_ = opened; }

int32 DownloadItemImpl::GetId() const { return download_id_.local(); }

int ShelfLayoutManager::GetWorkAreaSize(const State& state, int size) const {
  if (state.visibility_state == VISIBLE)
    return size;
  if (state.visibility_state == AUTO_HIDE)
    return kAutoHideSize;
  return 0;
}

bool DownloadItemImpl::GetAutoOpened() { return auto_opened_; }

void LauncherView::FadeIn(views::View* view) {
  view->SetVisible(true);
  view->layer()->SetOpacity(0);
  AnimateToIdealBounds();
  bounds_animator_->SetAnimationDelegate(
      view, new FadeInAnimationDelegate(view), true);
}

  void AddItemToHistory(content::MockDownloadItem& item, int64 db_handle) {
    if (DCHECK_IS_ON())
      EXPECT_CALL(item, IsPersisted())
          .WillOnce(Return(false));

    EXPECT_CALL(item, SetDbHandle(db_handle));
    EXPECT_CALL(item, SetIsPersisted());
    EXPECT_CALL(item, GetDbHandle())
        .WillRepeatedly(Return(db_handle));

    EXPECT_CALL(item, GetWebContents())
        .WillOnce(Return(static_cast<WebContents*>(NULL)));
    EXPECT_CALL(GetMockDownloadManagerDelegate(),
                GetAlternativeWebContentsToNotifyForDownload())
        .WillOnce(Return(static_cast<WebContents*>(NULL)));

    EXPECT_CALL(item, IsInProgress())
        .WillOnce(Return(true));

    EXPECT_CALL(item, AllDataSaved())
        .WillOnce(Return(false));

    download_manager_->OnItemAddedToPersistentStore(item.GetId(), db_handle);
  }

void ChromeDownloadManagerDelegate::RemoveItemsFromPersistentStoreBetween(
    base::Time remove_begin,
    base::Time remove_end) {
  download_history_->RemoveEntriesBetween(remove_begin, remove_end);
}

void LauncherView::ShowContextMenuForView(views::View* source,
                                          const gfx::Point& point) {
  if (!delegate_)
    return;

  int view_index = view_model_->GetIndexOfView(source);
  if (view_index != -1 &&
      model_->items()[view_index].type == TYPE_APP_LIST) {
    view_index = -1;
  }
#if !defined(OS_MACOSX)
  scoped_ptr<ui::MenuModel> menu_model(
      view_index == -1 ?
          delegate_->CreateContextMenuForLauncher() :
          delegate_->CreateContextMenu(model_->items()[view_index]));
  if (!menu_model.get())
    return;
  AutoReset<LauncherID> reseter(
      &context_menu_id_,
      view_index == -1 ? 0 : model_->items()[view_index].id);
  views::MenuModelAdapter menu_model_adapter(menu_model.get());
  launcher_menu_runner_.reset(
      new views::MenuRunner(menu_model_adapter.CreateMenu()));
  if (launcher_menu_runner_->RunMenuAt(
          source->GetWidget(), NULL, gfx::Rect(point, gfx::Size()),
          views::MenuItemView::TOPLEFT, 0) == views::MenuRunner::MENU_DELETED)
    return;

  Shell::GetInstance()->UpdateShelfVisibility();
#endif
}

bool ChromeDownloadManagerDelegate::ShouldOpenWithWebIntents(
    const DownloadItem* item) {
  if (!item->GetWebContents() || !item->GetWebContents()->GetDelegate())
    return false;

  std::string mime_type = item->GetMimeType();
  if (mime_type == "application/rss+xml" ||
      mime_type == "application/atom+xml") {
    return true;
  }

#if defined(OS_CHROMEOS)
  if (mime_type == "application/msword" ||
      mime_type == "application/vnd.ms-powerpoint" ||
      mime_type == "application/vnd.ms-excel" ||
      mime_type == "application/vnd.openxmlformats-officedocument."
                   "wordprocessingml.document" ||
      mime_type == "application/vnd.openxmlformats-officedocument."
                   "presentationml.presentation" ||
      mime_type == "application/vnd.openxmlformats-officedocument."
                   "spreadsheetml.sheet") {
    return true;
  }
#endif  // defined(OS_CHROMEOS)

  return false;
}

bool DownloadItemImpl::CanShowInFolder() {
  return !IsCancelled() && !file_externally_removed_;
}

views::View* LauncherView::CreateViewForItem(const LauncherItem& item) {
  views::View* view = NULL;
  switch (item.type) {
    case TYPE_TABBED: {
      TabbedLauncherButton* button =
          TabbedLauncherButton::Create(
              this,
              this,
              item.is_incognito ?
                  TabbedLauncherButton::STATE_INCOGNITO :
                  TabbedLauncherButton::STATE_NOT_INCOGNITO);
      button->SetTabImage(item.image);
      ReflectItemStatus(item, button);
      view = button;
      break;
    }

    case TYPE_APP_SHORTCUT:
    case TYPE_PLATFORM_APP:
    case TYPE_APP_PANEL: {
      LauncherButton* button = LauncherButton::Create(this, this);
      button->SetImage(item.image);
      ReflectItemStatus(item, button);
      view = button;
      break;
    }

    case TYPE_APP_LIST: {
      ResourceBundle& rb = ResourceBundle::GetSharedInstance();
      AppListButton* button = new AppListButton(this, this);
      button->SetImage(
          views::CustomButton::BS_NORMAL,
          rb.GetImageNamed(IDR_AURA_LAUNCHER_ICON_APPLIST).ToImageSkia());
      button->SetImage(
          views::CustomButton::BS_HOT,
          rb.GetImageNamed(IDR_AURA_LAUNCHER_ICON_APPLIST_HOT).
              ToImageSkia());
      button->SetImage(
          views::CustomButton::BS_PUSHED,
          rb.GetImageNamed(IDR_AURA_LAUNCHER_ICON_APPLIST_PUSHED).
              ToImageSkia());
      button->SetAccessibleName(
          l10n_util::GetStringUTF16(IDS_AURA_APP_LIST_TITLE));
      view = button;
      break;
    }

    case TYPE_BROWSER_SHORTCUT: {
      ResourceBundle& rb = ResourceBundle::GetSharedInstance();
      LauncherButton* button = LauncherButton::Create(this, this);
      int image_id = delegate_ ?
          delegate_->GetBrowserShortcutResourceId() :
          IDR_AURA_LAUNCHER_BROWSER_SHORTCUT;
      button->SetImage(*rb.GetImageNamed(image_id).ToImageSkia());
      view = button;
      break;
    }

    default:
      break;
  }
  view->set_context_menu_controller(this);

  DCHECK(view);
  ConfigureChildView(view);
  return view;
}

 views::View* Launcher::GetAppListButtonView() const {
   return launcher_view_->GetAppListButtonView();
 }

  explicit DeleteViewAnimationDelegate(views::View* view) : view_(view) {}

std::string DownloadItemImpl::GetMimeType() const { return mime_type_; }

void GDataCacheMetadataMap::Initialize(
const std::vector<FilePath>& cache_paths) {
AssertOnSequencedWorkerPool();

if (cache_paths.size() < GDataCache::NUM_CACHE_TYPES) {
    LOG(ERROR) << "Size of cache_paths is invalid.";
return;
}

  if (!GDataCache::CreateCacheDirectories(cache_paths))
return;

// Change permissions of cache persistent directory to u+rwx,og+x in order to
// allow archive files in that directory to be mounted by cros-disks.
if (!ChangeFilePermissions(cache_paths[GDataCache::CACHE_TYPE_PERSISTENT],
S_IRWXU | S_IXGRP | S_IXOTH))
return;

DVLOG(1) << "Scanning directories";

// Scan cache persistent and tmp directories to enumerate all files and create
// corresponding entries for cache map.
  ResourceIdToFilePathMap persistent_file_map;
  ScanCacheDirectory(cache_paths,
                     GDataCache::CACHE_TYPE_PERSISTENT,
                     &cache_map_,
                     &persistent_file_map);
  ResourceIdToFilePathMap tmp_file_map;
  ScanCacheDirectory(cache_paths,
                     GDataCache::CACHE_TYPE_TMP,
                     &cache_map_,
                     &tmp_file_map);
  // Then scan pinned directory to update existing entries in cache map, or
  // create new ones for pinned symlinks to /dev/null which target nothing.
  
  // Pinned directory should be scanned after the persistent directory as
  // we'll add PINNED states to the existing files in the persistent
  // directory per the contents of the pinned directory.
  ResourceIdToFilePathMap pinned_file_map;
  ScanCacheDirectory(cache_paths,
                     GDataCache::CACHE_TYPE_PINNED,
                     &cache_map_,
                     &pinned_file_map);
  // Then scan outgoing directory to check if dirty-files are committed
  // properly (i.e. symlinks created in outgoing directory).
  ResourceIdToFilePathMap outgoing_file_map;
  ScanCacheDirectory(cache_paths,
                     GDataCache::CACHE_TYPE_OUTGOING,
                     &cache_map_,
                     &outgoing_file_map);
  RemoveInvalidFilesFromPersistentDirectory(persistent_file_map,
                                            outgoing_file_map,
                                            &cache_map_);
DVLOG(1) << "Directory scan finished";
}

FilePath DownloadItemImpl::GetTargetName() const {
  return target_path_.BaseName();
}

bool DeleteSymlink(const FilePath& file_path) {
  const bool deleted = HANDLE_EINTR(unlink(file_path.value().c_str())) == 0;
  return deleted;
}

void ShelfLayoutManager::UpdateAutoHideState() {
  AutoHideState auto_hide_state =
      CalculateAutoHideState(state_.visibility_state);
  if (auto_hide_state != state_.auto_hide_state) {
    if (auto_hide_state == AUTO_HIDE_HIDDEN) {
      SetState(state_.visibility_state);
      FOR_EACH_OBSERVER(Observer, observers_,
                        OnAutoHideStateChanged(auto_hide_state));
    } else {
      auto_hide_timer_.Stop();
      auto_hide_timer_.Start(
          FROM_HERE,
          base::TimeDelta::FromMilliseconds(kAutoHideDelayMS),
          this, &ShelfLayoutManager::UpdateAutoHideStateNow);
      FOR_EACH_OBSERVER(Observer, observers_, OnAutoHideStateChanged(
          CalculateAutoHideState(state_.visibility_state)));
    }
  } else {
    auto_hide_timer_.Stop();
  }
}

std::pair<int, int> LauncherView::GetDragRange(int index) {
  int min_index = -1;
  int max_index = -1;
  LauncherItemType type = model_->items()[index].type;
  for (int i = 0; i < model_->item_count(); ++i) {
    if (SameDragType(model_->items()[i].type, type)) {
      if (min_index == -1)
        min_index = i;
      max_index = i;
    }
  }
  return std::pair<int, int>(min_index, max_index);
}

std::string DownloadItemImpl::GetContentDisposition() const {
  return content_disposition_;
}

void DownloadFileManager::OnShutdown() {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::FILE));
  STLDeleteValues(&downloads_);
}

void InsertGDataCachePathsPermissions(
    Profile* profile,
    scoped_ptr<std::vector<FilePath> > gdata_paths,
    std::vector<std::pair<FilePath, int> >* cache_paths,
    const base::Closure& callback) {
  DCHECK(profile);
  DCHECK(gdata_paths.get());
  DCHECK(cache_paths);
  DCHECK(!callback.is_null());

  GDataFileSystem* file_system = GetGDataFileSystem(profile);
  if (!file_system || gdata_paths->empty()) {
    callback.Run();
    return;
  }

  FilePath gdata_path = gdata_paths->back();
  gdata_paths->pop_back();

  file_system->GetFileInfoByPath(
      gdata_path,
      base::Bind(&OnGetFileInfoForInsertGDataCachePathsPermissions,
                 profile,
                 cache_paths,
                 base::Bind(&InsertGDataCachePathsPermissions,
                             profile,
                             base::Passed(&gdata_paths),
                             cache_paths,
                             callback)));
}

void MockDownloadItemFactory::RemoveItem(int id) {
  DCHECK(items_.find(id) != items_.end());
  items_.erase(id);
}

void ChromeDownloadManagerDelegate::CheckVisitedReferrerBeforeDone(
    int32 download_id,
    content::DownloadDangerType danger_type,
    bool visited_referrer_before) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  DownloadItem* download =
      download_manager_->GetActiveDownloadItem(download_id);
  if (!download)
    return;

  bool should_prompt = (download->GetTargetDisposition() ==
                        DownloadItem::TARGET_DISPOSITION_PROMPT);
  bool is_forced_path = !download->GetForcedFilePath().empty();
  FilePath suggested_path;

  if (!is_forced_path) {
    FilePath generated_name;
    download_util::GenerateFileNameFromRequest(*download, &generated_name);

    if (download_prefs_->PromptForDownload()) {
      if (!download_crx_util::IsExtensionDownload(*download) &&
          !ShouldOpenFileBasedOnExtension(generated_name))
        should_prompt = true;
    }
    if (download_prefs_->IsDownloadPathManaged())
      should_prompt = false;

    FilePath target_directory;
    if (should_prompt && !download_manager_->LastDownloadPath().empty())
      target_directory = download_manager_->LastDownloadPath();
    else
      target_directory = download_prefs_->download_path();
    suggested_path = target_directory.Append(generated_name);
  } else {
    DCHECK(!should_prompt);
    suggested_path = download->GetForcedFilePath();
  }

  if (danger_type == content::DOWNLOAD_DANGER_TYPE_NOT_DANGEROUS) {
    if (!should_prompt && !is_forced_path &&
        IsDangerousFile(*download, suggested_path, visited_referrer_before)) {
      danger_type = content::DOWNLOAD_DANGER_TYPE_DANGEROUS_FILE;
    }

#if defined(ENABLE_SAFE_BROWSING)
    DownloadProtectionService* service = GetDownloadProtectionService();
    if (service && service->enabled()) {
      DownloadProtectionService::DownloadInfo info =
          DownloadProtectionService::DownloadInfo::FromDownloadItem(*download);
      info.target_file = suggested_path;
      if (service->IsSupportedDownload(info))
        danger_type = content::DOWNLOAD_DANGER_TYPE_MAYBE_DANGEROUS_CONTENT;
    }
#endif
  } else {
    DCHECK_EQ(content::DOWNLOAD_DANGER_TYPE_DANGEROUS_URL, danger_type);
  }

#if defined (OS_CHROMEOS)
  gdata::GDataDownloadObserver::SubstituteGDataDownloadPath(
      profile_, suggested_path, download,
      base::Bind(
          &ChromeDownloadManagerDelegate::SubstituteGDataDownloadPathCallback,
          this, download->GetId(), should_prompt, is_forced_path, danger_type));
#else
  BrowserThread::PostTask(
      BrowserThread::FILE, FROM_HERE,
      base::Bind(&ChromeDownloadManagerDelegate::CheckIfSuggestedPathExists,
                 this, download->GetId(), suggested_path, should_prompt,
                 is_forced_path, danger_type,
                 download_prefs_->download_path()));
#endif
}

void ChromeDownloadManagerDelegate::AddItemToPersistentStore(
    DownloadItem* item) {
  download_history_->AddEntry(item,
      base::Bind(&ChromeDownloadManagerDelegate::OnItemAddedToPersistentStore,
                 base::Unretained(this)));
}

DownloadPersistentStoreInfo DownloadItemImpl::GetPersistentStoreInfo() const {
  return DownloadPersistentStoreInfo(GetFullPath(),
                                     GetURL(),
                                     GetReferrerUrl(),
                                     GetStartTime(),
                                     GetEndTime(),
                                     GetReceivedBytes(),
                                     GetTotalBytes(),
                                     GetState(),
                                     GetDbHandle(),
                                     GetOpened());
}

ShelfAlignment LauncherView::GetShelfAlignment() const {
  return alignment_;
}

void DownloadItemImpl::AddObserver(Observer* observer) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  observers_.AddObserver(observer);
}

void ShelfLayoutManager::SetWindowOverlapsShelf(bool value) {
  window_overlaps_shelf_ = value;
  UpdateShelfBackground(internal::BackgroundAnimator::CHANGE_ANIMATE);
}

void DownloadItemImpl::SetDbHandle(int64 handle) {
  db_handle_ = handle;

  bound_net_log_.AddEvent(
      net::NetLog::TYPE_DOWNLOAD_ITEM_IN_HISTORY,
      net::NetLog::Int64Callback("db_handle", db_handle_));
}

void GDataCache::RequestInitializeOnUIThread() {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  pool_->GetSequencedTaskRunner(sequence_token_)->PostTask(
      FROM_HERE,
      base::Bind(&GDataCache::Initialize, base::Unretained(this)));
}

  virtual void TearDown() {
    download_manager_ = NULL;
    ui_thread_.message_loop()->RunAllPending();
  }

content::BrowserContext* DownloadItemImpl::GetBrowserContext() const {
  return delegate_->GetBrowserContext();
}

bool DownloadItemImpl::IsPersisted() const {
  return is_persisted_;
}

void LauncherView::Init() {
  ResourceBundle& rb = ResourceBundle::GetSharedInstance();
  model_->AddObserver(this);

  const LauncherItems& items(model_->items());
  for (LauncherItems::const_iterator i = items.begin(); i != items.end(); ++i) {
    views::View* child = CreateViewForItem(*i);
    child->SetPaintToLayer(true);
    view_model_->Add(child, static_cast<int>(i - items.begin()));
    AddChildView(child);
  }
  UpdateFirstButtonPadding();
 
   overflow_button_ = new views::ImageButton(this);
   overflow_button_->set_accessibility_focusable(true);
   overflow_button_->SetImage(
       views::CustomButton::BS_NORMAL,
       rb.GetImageNamed(IDR_AURA_LAUNCHER_OVERFLOW).ToImageSkia());
  overflow_button_->SetImage(
      views::CustomButton::BS_HOT,
      rb.GetImageNamed(IDR_AURA_LAUNCHER_OVERFLOW_HOT).ToImageSkia());
  overflow_button_->SetImage(
      views::CustomButton::BS_PUSHED,
      rb.GetImageNamed(IDR_AURA_LAUNCHER_OVERFLOW_PUSHED).ToImageSkia());
  overflow_button_->SetAccessibleName(
      l10n_util::GetStringUTF16(IDS_AURA_LAUNCHER_OVERFLOW_NAME));
  overflow_button_->set_context_menu_controller(this);
  ConfigureChildView(overflow_button_);
  AddChildView(overflow_button_);

}

bool ChromeDownloadManagerDelegate::ShouldOpenDownload(DownloadItem* item) {
  if (download_crx_util::IsExtensionDownload(*item)) {
    scoped_refptr<CrxInstaller> crx_installer =
        download_crx_util::OpenChromeExtension(profile_, *item);

    registrar_.Add(this,
                   chrome::NOTIFICATION_CRX_INSTALLER_DONE,
                   content::Source<CrxInstaller>(crx_installer.get()));

    crx_installers_[crx_installer.get()] = item->GetId();
    item->UpdateObservers();
    return false;
  }

  if (ShouldOpenWithWebIntents(item)) {
    OpenWithWebIntent(item);
    item->DelayedDownloadOpened(true /* did_open */);
    return false;
  }

  return true;
}

  bool in_mouse_drag() const { return in_mouse_drag_; }

LauncherView::LauncherView(LauncherModel* model,
LauncherDelegate* delegate,
ShelfLayoutManager* shelf_layout_manager)
: model_(model),
delegate_(delegate),
view_model_(new views::ViewModel),
last_visible_index_(-1),
overflow_button_(NULL),
dragging_(false),
drag_view_(NULL),
drag_offset_(0),
start_drag_index_(-1),
context_menu_id_(0),
      alignment_(SHELF_ALIGNMENT_BOTTOM) {
DCHECK(model_);
bounds_animator_.reset(new views::BoundsAnimator(this));
bounds_animator_->AddObserver(this);
set_context_menu_controller(this);
focus_search_.reset(new LauncherFocusSearch(view_model_.get()));
tooltip_.reset(new LauncherTooltipManager(alignment_, shelf_layout_manager));
}

void Launcher::SetAlignment(ShelfAlignment alignment) {
  alignment_ = alignment;
  launcher_view_->SetAlignment(alignment);
}

void DownloadItemImpl::OnDownloadCompleting(DownloadFileManager* file_manager) {
DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

VLOG(20) << __FUNCTION__ << "()"
<< " needs rename = " << NeedsRename()
<< " " << DebugString(true);
DCHECK(!GetTargetName().empty());
DCHECK_NE(DANGEROUS, GetSafetyState());
DCHECK(file_manager);

  // TODO(asanka): Reduce code duplication across the NeedsRename() and
  //               !NeedsRename() completion pathways.
if (NeedsRename()) {
bool should_overwrite =
(GetTargetDisposition() != DownloadItem::TARGET_DISPOSITION_UNIQUIFY);
DownloadFileManager::RenameCompletionCallback callback =
base::Bind(&DownloadItemImpl::OnDownloadRenamedToFinalName,
weak_ptr_factory_.GetWeakPtr(),
base::Unretained(file_manager));
BrowserThread::PostTask(
BrowserThread::FILE, FROM_HERE,
        base::Bind(&DownloadFileManager::RenameCompletingDownloadFile,
file_manager, GetGlobalId(), GetTargetFilePath(),
should_overwrite, callback));
} else {
    Completed();
BrowserThread::PostTask(
BrowserThread::FILE, FROM_HERE,
base::Bind(&DownloadFileManager::CompleteDownload,
                   file_manager, download_id_));
}
}

void ChromeDownloadManagerDelegate::ChooseDownloadPath(DownloadItem* item) {
  DownloadFilePicker* file_picker =
#if defined(OS_CHROMEOS)
      new DownloadFilePickerChromeOS();
#else
      new DownloadFilePicker();
#endif
  file_picker->Init(download_manager_, item);
}

  virtual ~MockDownloadFileFactory() {}

void Launcher::ActivateLauncherItem(int index) {
  DCHECK(delegate_.get());
  const ash::LauncherItems& items = model_->items();
  delegate_->ItemClicked(items[index], ui::EF_NONE);
}

void DownloadItemImpl::TransitionTo(DownloadState new_state) {
  if (state_ == new_state)
    return;

  DownloadState old_state = state_;
  state_ = new_state;

  switch (state_) {
    case COMPLETE:
      bound_net_log_.AddEvent(
          net::NetLog::TYPE_DOWNLOAD_ITEM_FINISHED,
          base::Bind(&download_net_logs::ItemFinishedCallback,
                     received_bytes_, &hash_));
      break;
    case INTERRUPTED:
      bound_net_log_.AddEvent(
          net::NetLog::TYPE_DOWNLOAD_ITEM_INTERRUPTED,
          base::Bind(&download_net_logs::ItemInterruptedCallback,
                     last_reason_, received_bytes_, &hash_state_));
      break;
    case CANCELLED:
      bound_net_log_.AddEvent(
          net::NetLog::TYPE_DOWNLOAD_ITEM_CANCELED,
          base::Bind(&download_net_logs::ItemCanceledCallback,
                     received_bytes_, &hash_state_));
      break;
    default:
      break;
  }

  VLOG(20) << " " << __FUNCTION__ << "()" << " this = " << DebugString(true);

  UpdateObservers();

  bool is_done = (state_ != IN_PROGRESS);
  bool was_done = (old_state != IN_PROGRESS);
  if (is_done && !was_done)
    bound_net_log_.EndEvent(net::NetLog::TYPE_DOWNLOAD_ITEM_ACTIVE);
}

void GDataCache::Initialize() {
  AssertOnSequencedWorkerPool();

  GDataCacheMetadataMap* cache_data =
      new GDataCacheMetadataMap(pool_, sequence_token_);
  cache_data->Initialize(cache_paths_);
  metadata_.reset(cache_data);
}

void LauncherView::ContinueDrag(const views::MouseEvent& event) {
  gfx::Point drag_point(event.location());
  views::View::ConvertPointToView(drag_view_, this, &drag_point);
  int current_index = view_model_->GetIndexOfView(drag_view_);
  DCHECK_NE(-1, current_index);

  if (current_index == -1 ||
      !delegate_->IsDraggable(model_->items()[current_index])) {
    CancelDrag(-1);
    return;
  }

  std::pair<int, int> indices(GetDragRange(current_index));
  int last_drag_index = indices.second;
  if (last_drag_index > last_visible_index_)
    last_drag_index = last_visible_index_;
  int x = 0, y = 0;
  if (is_horizontal_alignment()) {
    x = std::max(view_model_->ideal_bounds(indices.first).x(),
                     drag_point.x() - drag_offset_);
    x = std::min(view_model_->ideal_bounds(last_drag_index).right() -
                 view_model_->ideal_bounds(current_index).width(),
                 x);
    if (drag_view_->x() == x)
      return;
    drag_view_->SetX(x);
  } else {
    y = std::max(view_model_->ideal_bounds(indices.first).y(),
                     drag_point.y() - drag_offset_);
    y = std::min(view_model_->ideal_bounds(last_drag_index).bottom() -
                 view_model_->ideal_bounds(current_index).height(),
                 y);
    if (drag_view_->y() == y)
      return;
    drag_view_->SetY(y);
  }

  int target_index =
      views::ViewModelUtils::DetermineMoveIndex(
          *view_model_, drag_view_,
          is_horizontal_alignment() ?
              views::ViewModelUtils::HORIZONTAL :
              views::ViewModelUtils::VERTICAL,
          x, y);
  target_index =
      std::min(indices.second, std::max(target_index, indices.first));
  if (target_index == current_index)
    return;

  model_->Move(current_index, target_index);
  bounds_animator_->StopAnimatingView(drag_view_);
}

  MockDownloadRequestHandle(content::DownloadManager* manager)
      : manager_(manager) {}

void DownloadItemImpl::Init(bool active,
                            download_net_logs::DownloadType download_type) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  if (active)
    download_stats::RecordDownloadCount(download_stats::START_COUNT);

  if (target_path_.empty())
    target_path_ = current_path_;
  std::string file_name;
  if (download_type == download_net_logs::SRC_HISTORY_IMPORT) {
    file_name = target_path_.AsUTF8Unsafe();
  } else {
    file_name = forced_file_path_.AsUTF8Unsafe();
    if (file_name.empty())
      file_name = suggested_filename_;
    if (file_name.empty())
      file_name = GetURL().ExtractFileName();
  }

  bound_net_log_.BeginEvent(
      net::NetLog::TYPE_DOWNLOAD_ITEM_ACTIVE,
      base::Bind(&download_net_logs::ItemActivatedCallback,
                 this, download_type, &file_name));

  if (!active) {
    bound_net_log_.AddEvent(
        net::NetLog::TYPE_DOWNLOAD_ITEM_IN_HISTORY,
        net::NetLog::Int64Callback("db_handle", db_handle_));

    bound_net_log_.EndEvent(net::NetLog::TYPE_DOWNLOAD_ITEM_ACTIVE);
  }

  VLOG(20) << __FUNCTION__ << "() " << DebugString(true);
}

void DownloadItemImpl::SetOpenWhenComplete(bool open) {
  open_when_complete_ = open;
}

void LauncherView::OnMouseExited(const views::MouseEvent& event) {
  gfx::Point point = event.location();
  views::View::ConvertPointToView(parent(), this, &point);
  if (ShouldHideTooltip(point) && tooltip_->IsVisible())
    tooltip_->Close();
}

bool ShelfLayoutManager::IsVisible() const {
  return status_->IsVisible() && (state_.visibility_state == VISIBLE ||
      (state_.visibility_state == AUTO_HIDE &&
       state_.auto_hide_state == AUTO_HIDE_SHOWN));
}

void DownloadItemImpl::Delegate::Detach() {
  DCHECK_LT(0, count_);
  --count_;
}

ShelfLayoutManager::AutoHideEventFilter::~AutoHideEventFilter() {
  Shell::GetInstance()->RemoveEnvEventFilter(this);
}

bool ShelfLayoutManager::AutoHideEventFilter::PreHandleMouseEvent(
    aura::Window* target,
    aura::MouseEvent* event) {
  in_mouse_drag_ = (event->type() == ui::ET_MOUSE_DRAGGED ||
                    (in_mouse_drag_ && event->type() != ui::ET_MOUSE_RELEASED &&
                     event->type() != ui::ET_MOUSE_CAPTURE_CHANGED)) &&
      !shelf_->IsShelfWindow(target);
  if (event->type() == ui::ET_MOUSE_MOVED)
    shelf_->UpdateAutoHideState();
  return false;  // Not handled.
}

void Launcher::DelegateView::Layout() {
  if (child_count() == 0)
    return;
  if (launcher_->alignment_ == SHELF_ALIGNMENT_BOTTOM) {
    int w = std::max(0, width() - launcher_->status_size_.width());
    child_at(0)->SetBounds(0, 0, w, height());
  } else {
    int h = std::max(0, height() - launcher_->status_size_.height());
    child_at(0)->SetBounds(0, 0, width(), h);
  }
}

void ShelfLayoutManager::StopAnimating() {
  if (launcher_widget())
    GetLayer(launcher_widget())->GetAnimator()->StopAnimating();
  GetLayer(status_)->GetAnimator()->StopAnimating();
}

  virtual ~TestExternalData() {
    destructor_called++;
  }

void LauncherView::MouseDraggedOnButton(views::View* view,
                                        const views::MouseEvent& event) {
  if (!dragging_ && drag_view_ &&
      primary_axis_coordinate(abs(event.x() - drag_offset_),
                              abs(event.y() - drag_offset_)) >=
      kMinimumDragDistance) {
    PrepareForDrag(event);
  }
  if (dragging_)
    ContinueDrag(event);
}

void LauncherView::MouseEnteredButton(views::View* view) {
  if (tooltip_->IsVisible()) {
    tooltip_->Close();
    tooltip_->ShowImmediately(view, GetAccessibleName(view));
  } else {
    tooltip_->ShowDelayed(view, GetAccessibleName(view));
  }
}

bool DownloadItemImpl::IsDangerous() const {
#ifdef OS_WIN
  return (danger_type_ == content::DOWNLOAD_DANGER_TYPE_DANGEROUS_FILE ||
          danger_type_ == content::DOWNLOAD_DANGER_TYPE_DANGEROUS_URL ||
          danger_type_ == content::DOWNLOAD_DANGER_TYPE_DANGEROUS_CONTENT ||
          danger_type_ == content::DOWNLOAD_DANGER_TYPE_UNCOMMON_CONTENT);
#else
  return (danger_type_ == content::DOWNLOAD_DANGER_TYPE_DANGEROUS_FILE ||
          danger_type_ == content::DOWNLOAD_DANGER_TYPE_DANGEROUS_URL);
#endif
}

GDataFileSystem* GetGDataFileSystem(Profile* profile) {
  GDataSystemService* system_service =
      GDataSystemServiceFactory::GetForProfile(profile);
  return system_service ? system_service->file_system() : NULL;
}

bool LauncherView::IsShowingMenu() const {
#if !defined(OS_MACOSX)
  return (overflow_menu_runner_.get() &&
          overflow_menu_runner_->IsRunning()) ||
      (launcher_menu_runner_.get() &&
launcher_menu_runner_->IsRunning());
#endif
return false;
}

    ~MockObserver() { item_->RemoveObserver(this); }

bool DownloadItemImpl::NeedsRename() const {
  DCHECK(target_path_.DirName() == current_path_.DirName());
  return target_path_ != current_path_;
}

 void LauncherView::OnBoundsChanged(const gfx::Rect& previous_bounds) {
   LayoutToIdealBounds();
   FOR_EACH_OBSERVER(LauncherIconObserver, observers_,
                     OnLauncherIconPositionsChanged());
 }

const FilePath& GetSpecialRemoteRootPath() {
  CR_DEFINE_STATIC_LOCAL(FilePath, gdata_mount_path,
      (FilePath::FromUTF8Unsafe(kGDataSpecialRootPath)));
  return gdata_mount_path;
}

  void DestroyDownloadItem(DownloadItem* item) {
    allocated_downloads_.erase(item);
    delete item;
  }

gfx::Rect ShelfLayoutManager::GetUnmaximizedWorkAreaBounds(
    aura::Window* window) {
  gfx::Rect bounds(gfx::Screen::GetDisplayNearestWindow(window).bounds());
  int size;
  if (auto_hide_behavior_ == SHELF_AUTO_HIDE_BEHAVIOR_ALWAYS) {
    size = kAutoHideSize;
  } else {
    int width, height;
    GetShelfSize(&width, &height);
    size = std::max(width, height);
  }
  AdjustBoundsBasedOnAlignment(size, &bounds);
  return bounds;
}

ShelfLayoutManager::~ShelfLayoutManager() {
  FOR_EACH_OBSERVER(Observer, observers_, WillDeleteShelf());
  Shell::GetInstance()->RemoveShellObserver(this);
  aura::client::GetActivationClient(root_window_)->RemoveObserver(this);
}

  content::MockDownloadItem& GetMockDownloadItem(int id) {
    content::MockDownloadItem* itemp = mock_download_item_factory_->GetItem(id);

    DCHECK(itemp);
    return *itemp;
  }

 GDataCacheMetadata::GDataCacheMetadata(
    base::SequencedWorkerPool* pool,
    const base::SequencedWorkerPool::SequenceToken& sequence_token)
    : pool_(pool),
      sequence_token_(sequence_token) {
  AssertOnSequencedWorkerPool();
}

const GURL& DownloadItemImpl::GetOriginalUrl() const {
  return url_chain_.front();
}

gfx::Rect ShelfLayoutManager::GetIdealBounds() {
  gfx::Rect bounds(
      gfx::Screen::GetDisplayNearestWindow(status_->GetNativeView()).bounds());
  int width = 0, height = 0;
  GetShelfSize(&width, &height);
  switch (alignment_) {
    case SHELF_ALIGNMENT_BOTTOM:
      return gfx::Rect(bounds.x(), bounds.bottom() - height,
                       bounds.width(), height);
    case SHELF_ALIGNMENT_LEFT:
      return gfx::Rect(bounds.x(), bounds.y(), width, bounds.height());
    case SHELF_ALIGNMENT_RIGHT:
      return gfx::Rect(bounds.right() - width, bounds.y(), width,
                       bounds.height());
  }
  NOTREACHED();
  return gfx::Rect();
}

void ShelfLayoutManager::OnWindowAddedToLayout(aura::Window* child) {
}

void LauncherView::SetAlignment(ShelfAlignment alignment) {
  if (alignment_ == alignment)
    return;
  alignment_ = alignment;
   UpdateFirstButtonPadding();
   LayoutToIdealBounds();
   tooltip_->SetArrowLocation(alignment_);
 }

void LauncherView::LauncherItemMoved(int start_index, int target_index) {
  view_model_->Move(start_index, target_index);
  AnimateToIdealBounds();
}

void ChromeDownloadManagerDelegate::OpenWithWebIntent(
    const DownloadItem* item) {
  webkit_glue::WebIntentData intent_data(
      ASCIIToUTF16("http://webintents.org/view"),
      ASCIIToUTF16(item->GetMimeType()),
      item->GetFullPath(),
      item->GetReceivedBytes());

  intent_data.extra_data.insert(make_pair(
      ASCIIToUTF16("url"), ASCIIToUTF16(item->GetURL().spec())));

  string16 filename = UTF8ToUTF16(item->GetSuggestedFilename());
  if (filename.empty())
    filename = item->GetFileNameToReportUser().LossyDisplayName();
  intent_data.extra_data.insert(make_pair(ASCIIToUTF16("filename"), filename));

  content::WebIntentsDispatcher* dispatcher =
      content::WebIntentsDispatcher::Create(intent_data);
  item->GetWebContents()->GetDelegate()->WebIntentDispatch(
      item->GetWebContents(), dispatcher);
}

bool ShelfLayoutManager::AutoHideEventFilter::PreHandleKeyEvent(
    aura::Window* target,
    aura::KeyEvent* event) {
  return false;  // Always let the event propagate.
}

bool DownloadItemImpl::HasUserGesture() const {
  return has_user_gesture_;
};

void ShelfLayoutManager::UpdateVisibilityState() {
  ShellDelegate* delegate = Shell::GetInstance()->delegate();
  if (delegate && delegate->IsScreenLocked()) {
    SetState(VISIBLE);
  } else {
    WorkspaceManager::WindowState window_state(
        workspace_manager_->GetWindowState());
    switch (window_state) {
      case WorkspaceManager::WINDOW_STATE_FULL_SCREEN:
        SetState(HIDDEN);
        break;

      case WorkspaceManager::WINDOW_STATE_MAXIMIZED:
        SetState(auto_hide_behavior_ != SHELF_AUTO_HIDE_BEHAVIOR_NEVER ?
                 AUTO_HIDE : VISIBLE);
        break;

      case WorkspaceManager::WINDOW_STATE_WINDOW_OVERLAPS_SHELF:
      case WorkspaceManager::WINDOW_STATE_DEFAULT:
        SetState(auto_hide_behavior_ == SHELF_AUTO_HIDE_BEHAVIOR_ALWAYS ?
                 AUTO_HIDE : VISIBLE);
        SetWindowOverlapsShelf(window_state ==
            WorkspaceManager::WINDOW_STATE_WINDOW_OVERLAPS_SHELF);
    }
  }
}

std::string CacheSubDirectoryTypeToString(
    GDataCache::CacheSubDirectoryType subdir) {
  switch (subdir) {
    case GDataCache::CACHE_TYPE_META:
      return "meta";
    case GDataCache::CACHE_TYPE_PINNED:
      return "pinned";
    case GDataCache::CACHE_TYPE_OUTGOING:
      return "outgoing";
    case GDataCache::CACHE_TYPE_PERSISTENT:
      return "persistent";
    case GDataCache::CACHE_TYPE_TMP:
      return "tmp";
    case GDataCache::CACHE_TYPE_TMP_DOWNLOADS:
      return "tmp_downloads";
    case GDataCache::CACHE_TYPE_TMP_DOCUMENTS:
      return "tmp_documents";
    case GDataCache::NUM_CACHE_TYPES:
      NOTREACHED();
  }
  NOTREACHED();
   return "unknown subdir";
 }

void DownloadItemImpl::UpdateProgress(int64 bytes_so_far,
                                      int64 bytes_per_sec,
                                      const std::string& hash_state) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  if (!IsInProgress()) {
    NOTREACHED();
    return;
  }
  bytes_per_sec_ = bytes_per_sec;
  UpdateProgress(bytes_so_far, hash_state);
UpdateObservers();
}

void DownloadItemImpl::Interrupt(content::DownloadInterruptReason reason) {
  DCHECK(IsInProgress());
  last_reason_ = reason;
  TransitionTo(INTERRUPTED);
  download_stats::RecordDownloadInterrupted(
      reason, received_bytes_, total_bytes_);
  delegate_->DownloadStopped(this);
}

std::string DownloadItemImpl::GetOriginalMimeType() const {
  return original_mime_type_;
}

void ShelfLayoutManager::AddObserver(Observer* observer) {
  observers_.AddObserver(observer);
}

const std::string& DownloadItemImpl::GetLastModifiedTime() const {
  return last_modified_time_;
}

void ChromeDownloadManagerDelegate::Shutdown() {
  download_history_.reset();
  download_prefs_.reset();
}

bool LauncherView::SameDragType(LauncherItemType typea,
                                LauncherItemType typeb) const {
  switch (typea) {
    case TYPE_TABBED:
    case TYPE_APP_PANEL:
    case TYPE_PLATFORM_APP:
      return (typeb == TYPE_TABBED ||
          typeb == TYPE_APP_PANEL ||
          typeb == TYPE_PLATFORM_APP);
    case TYPE_APP_SHORTCUT:
    case TYPE_APP_LIST:
    case TYPE_BROWSER_SHORTCUT:
      return typeb == typea;
  }
  NOTREACHED();
  return false;
}

Launcher::DelegateView::~DelegateView() {
}

void LauncherView::AddIconObserver(LauncherIconObserver* observer) {
  observers_.AddObserver(observer);
}

DownloadFile* DownloadFileFactoryImpl::CreateFile(
    DownloadCreateInfo* info,
    scoped_ptr<content::ByteStreamReader> stream,
    DownloadManager* download_manager,
    bool calculate_hash,
    const net::BoundNetLog& bound_net_log) {
  return new DownloadFileImpl(
      info, stream.Pass(), new DownloadRequestHandle(info->request_handle),
      download_manager, calculate_hash,
      scoped_ptr<content::PowerSaveBlocker>(
          new content::PowerSaveBlocker(
              content::PowerSaveBlocker::kPowerSaveBlockPreventAppSuspension,
              "Download in progress")).Pass(),
      bound_net_log);
}

void DownloadItemImpl::SetExternalData(
    const void* key, DownloadItem::ExternalData* data) {
  std::map<const void*, ExternalData*>::iterator it =
      external_data_map_.find(key);

  if (it == external_data_map_.end()) {
    external_data_map_[key] = data;
  } else if (it->second != data) {
    delete it->second;
    it->second = data;
  }
}

SafeBrowsingState::~SafeBrowsingState() {}

bool GDataCacheMetadataMap::CheckIfMd5Matches(
    const std::string& md5,
    const GDataCache::CacheEntry& cache_entry) {
  if (cache_entry.IsDirty()) {
    return true;
  } else if (cache_entry.IsPinned() && cache_entry.md5.empty()) {
    return true;
  } else if (md5.empty()) {
    return true;
  } else if (md5 == cache_entry.md5) {
    return true;
  }
  return false;
}

std::string GDataCache::CacheEntry::ToString() const {
  std::vector<std::string> cache_states;
  if (GDataCache::IsCachePresent(cache_state))
    cache_states.push_back("present");
  if (GDataCache::IsCachePinned(cache_state))
    cache_states.push_back("pinned");
  if (GDataCache::IsCacheDirty(cache_state))
    cache_states.push_back("dirty");

  return base::StringPrintf("md5=%s, subdir=%s, cache_state=%s",
                            md5.c_str(),
                            CacheSubDirectoryTypeToString(sub_dir_type).c_str(),
                            JoinString(cache_states, ',').c_str());
}

  DownloadItemTest()
      : ui_thread_(BrowserThread::UI, &loop_),
        file_thread_(BrowserThread::FILE, &loop_) {
  }

void LauncherView::LauncherItemChanged(int model_index,
                                       const ash::LauncherItem& old_item) {
  const LauncherItem& item(model_->items()[model_index]);
  if (old_item.type != item.type) {
    model_index = CancelDrag(model_index);
    scoped_ptr<views::View> old_view(view_model_->view_at(model_index));
    bounds_animator_->StopAnimatingView(old_view.get());
    view_model_->Remove(model_index);
    views::View* new_view = CreateViewForItem(item);
    AddChildView(new_view);
    view_model_->Add(new_view, model_index);
    new_view->SetBoundsRect(old_view->bounds());
    return;
  }

  views::View* view = view_model_->view_at(model_index);
  switch (item.type) {
    case TYPE_TABBED: {
      TabbedLauncherButton* button = static_cast<TabbedLauncherButton*>(view);
      gfx::Size pref = button->GetPreferredSize();
      button->SetTabImage(item.image);
      if (pref != button->GetPreferredSize())
        AnimateToIdealBounds();
      else
        button->SchedulePaint();
      ReflectItemStatus(item, button);
      break;
    }

    case TYPE_APP_SHORTCUT:
    case TYPE_PLATFORM_APP:
    case TYPE_APP_PANEL: {
      LauncherButton* button = static_cast<LauncherButton*>(view);
      ReflectItemStatus(item, button);
      button->SetImage(item.image);
      button->SchedulePaint();
      break;
    }

    default:
      break;
  }
}

GDataCache::GDataCache(
    const FilePath& cache_root_path,
    base::SequencedWorkerPool* pool,
    const base::SequencedWorkerPool::SequenceToken& sequence_token)
    : cache_root_path_(cache_root_path),
      cache_paths_(GetCachePaths(cache_root_path_)),
      pool_(pool),
      sequence_token_(sequence_token),
      ui_weak_ptr_factory_(this),
      ui_weak_ptr_(ui_weak_ptr_factory_.GetWeakPtr()) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
}

void DownloadItemImpl::Completed() {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  VLOG(20) << __FUNCTION__ << "() " << DebugString(false);

  DCHECK(all_data_saved_);
  end_time_ = base::Time::Now();
  TransitionTo(COMPLETE);
  delegate_->DownloadCompleted(this);
  download_stats::RecordDownloadCompleted(start_tick_, received_bytes_);

  if (auto_opened_) {
  } else if (GetOpenWhenComplete() ||
             ShouldOpenFileBasedOnExtension() ||
             IsTemporary()) {
    if (!IsTemporary())
      OpenDownload();

    auto_opened_ = true;
    UpdateObservers();
  }
}

void LauncherView::LayoutToIdealBounds() {
  IdealBounds ideal_bounds;
  CalculateIdealBounds(&ideal_bounds);

  if (bounds_animator_->IsAnimating())
    AnimateToIdealBounds();
  else
    views::ViewModelUtils::SetViewBoundsToIdealBounds(*view_model_);

  overflow_button_->SetBoundsRect(ideal_bounds.overflow_bounds);
}

void ModifyGDataFileResourceUrl(Profile* profile,
                                const FilePath& gdata_cache_path,
                                GURL* url) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  GDataFileSystem* file_system = GetGDataFileSystem(profile);
  if (!file_system)
    return;
  GDataCache* cache = GetGDataCache(profile);
  if (!cache)
    return;

  if (cache->GetCacheDirectoryPath(
          GDataCache::CACHE_TYPE_TMP_DOCUMENTS).IsParent(
      gdata_cache_path)) {
    GURL* edit_url = new GURL();
    content::BrowserThread::GetBlockingPool()->PostTaskAndReply(FROM_HERE,
        base::Bind(&GetHostedDocumentURLBlockingThread,
                   gdata_cache_path, edit_url),
        base::Bind(&OpenEditURLUIThread, profile, base::Owned(edit_url)));
    *url = GURL();
  } else if (cache->GetCacheDirectoryPath(
      GDataCache::CACHE_TYPE_TMP).IsParent(gdata_cache_path)) {
    const std::string resource_id =
        gdata_cache_path.BaseName().RemoveExtension().AsUTF8Unsafe();
    file_system->GetFileInfoByResourceId(
        resource_id,
        base::Bind(&OnGetFileInfoByResourceId,
                   profile,
                   resource_id));
    *url = GURL();
  }
}

void DownloadFileManager::CancelDownloadOnRename(
    DownloadId global_id, net::Error rename_error) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::FILE));
  DownloadFile* download_file = GetDownloadFile(global_id);
  if (!download_file)
    return;
  DownloadManager* download_manager = download_file->GetDownloadManager();
  DCHECK(download_manager);
  BrowserThread::PostTask(
      BrowserThread::UI, FROM_HERE,
      base::Bind(&DownloadManager::OnDownloadInterrupted,
                 download_manager,
                 global_id.local(),
                 download_file->BytesSoFar(),
                 download_file->GetHashState(),
                 content::ConvertNetErrorToInterruptReason(
                     rename_error,
                     content::DOWNLOAD_INTERRUPT_FROM_DISK)));
}

void GDataCacheMetadataMap::Iterate(const IterateCallback& callback) {
  AssertOnSequencedWorkerPool();

  for (CacheMap::const_iterator iter = cache_map_.begin();
       iter != cache_map_.end(); ++iter) {
    callback.Run(iter->first, iter->second);
   }
 }

GDataCache* GetGDataCache(Profile* profile) {
  GDataSystemService* system_service =
      GDataSystemServiceFactory::GetForProfile(profile);
  return system_service ? system_service->cache() : NULL;
}

 gfx::Rect LauncherView::GetIdealBoundsOfItemIcon(LauncherID id) {
  int index = model_->ItemIndexByID(id);
  if (index == -1 || index > last_visible_index_)
    return gfx::Rect();
  const gfx::Rect& ideal_bounds(view_model_->ideal_bounds(index));
  DCHECK_NE(TYPE_APP_LIST, model_->items()[index].type);
  LauncherButton* button =
      static_cast<LauncherButton*>(view_model_->view_at(index));
  gfx::Rect icon_bounds = button->GetIconBounds();
  return gfx::Rect(ideal_bounds.x() + icon_bounds.x(),
                   ideal_bounds.y() + icon_bounds.y(),
                   icon_bounds.width(), icon_bounds.height());
}

void GDataCache::GetResourceIdsOfExistingPinnedFiles(
    std::vector<std::string>* resource_ids) {
  AssertOnSequencedWorkerPool();
  DCHECK(resource_ids);

  metadata_->Iterate(base::Bind(&CollectExistingPinnedFile, resource_ids));
}

  MockDelegate* mock_delegate() {
    return &delegate_;
  }

void LauncherView::MouseExitedButton(views::View* view) {
  if (!tooltip_->IsVisible())
    tooltip_->StopTimer();
}
