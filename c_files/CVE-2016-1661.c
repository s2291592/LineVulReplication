void Compositor::DidFailToInitializeLayerTreeFrameSink() {
  NOTREACHED();
}

void Compositor::SetLocalSurfaceId(
    const viz::LocalSurfaceId& local_surface_id) {
  host_->SetLocalSurfaceIdFromParent(local_surface_id);
}

 void Compositor::OnFirstSurfaceActivation(
     const viz::SurfaceInfo& surface_info) {
 }

void Compositor::SetExternalBeginFrameClient(ExternalBeginFrameClient* client) {
  DCHECK(external_begin_frames_enabled_);
  external_begin_frame_client_ = client;
  if (needs_external_begin_frames_ && external_begin_frame_client_)
    external_begin_frame_client_->OnNeedsExternalBeginFrames(true);
}

void Compositor::OnNeedsExternalBeginFrames(bool needs_begin_frames) {
  DCHECK(external_begin_frames_enabled_);
  if (external_begin_frame_client_) {
    external_begin_frame_client_->OnNeedsExternalBeginFrames(
        needs_begin_frames);
  }
  needs_external_begin_frames_ = needs_begin_frames;
}

void Compositor::SetBackgroundColor(SkColor color) {
  host_->set_background_color(color);
  ScheduleDraw();
}

void Compositor::SetDisplayVSyncParameters(base::TimeTicks timebase,
                                           base::TimeDelta interval) {
  static bool is_frame_rate_limit_disabled =
      base::CommandLine::ForCurrentProcess()->HasSwitch(
          switches::kDisableFrameRateLimit);
  if (is_frame_rate_limit_disabled)
    return;

  if (forced_refresh_rate_) {
    timebase = base::TimeTicks();
    interval = base::TimeDelta::FromSeconds(1) / forced_refresh_rate_;
  }
  if (interval.is_zero()) {
    interval = viz::BeginFrameArgs::DefaultInterval();
  }
  DCHECK_GT(interval.InMillisecondsF(), 0);

  if (vsync_timebase_ == timebase && vsync_interval_ == interval)
    return;

  vsync_timebase_ = timebase;
  vsync_interval_ = interval;
  refresh_rate_ =
      base::Time::kMillisecondsPerSecond / interval.InMillisecondsF();
  if (context_factory_private_) {
    context_factory_private_->SetDisplayVSyncParameters(this, timebase,
                                                        interval);
  }
  vsync_manager_->UpdateVSyncParameters(timebase, interval);
}

void Compositor::SetScaleAndSize(float scale,
                                 const gfx::Size& size_in_pixel,
                                 const viz::LocalSurfaceId& local_surface_id) {
  DCHECK_GT(scale, 0);
  bool device_scale_factor_changed = device_scale_factor_ != scale;
  device_scale_factor_ = scale;

  if (size_ != size_in_pixel && local_surface_id.is_valid()) {
    DCHECK_NE(local_surface_id, host_->local_surface_id_from_parent());
  }

  if (!size_in_pixel.IsEmpty()) {
    bool size_changed = size_ != size_in_pixel;
    size_ = size_in_pixel;
    host_->SetViewportSizeAndScale(size_in_pixel, scale, local_surface_id);
    root_web_layer_->SetBounds(size_in_pixel);
    if (context_factory_private_ &&
        (size_changed || disabled_swap_until_resize_)) {
      context_factory_private_->ResizeDisplay(this, size_in_pixel);
      disabled_swap_until_resize_ = false;
    }
  }
  if (device_scale_factor_changed) {
    if (is_pixel_canvas())
      host_->SetRecordingScaleFactor(scale);
    if (root_layer_)
      root_layer_->OnDeviceScaleFactorChanged(scale);
  }
}

void Compositor::SetDisplayColorSpace(const gfx::ColorSpace& color_space) {
  if (output_color_space_ == color_space)
    return;
  output_color_space_ = color_space;
  blending_color_space_ = output_color_space_.GetBlendingColorSpace();
  host_->SetRasterColorSpace(gfx::ColorSpace::CreateSRGB());
  host_->SetNeedsDisplayOnAllLayers();

  if (context_factory_private_) {
    context_factory_private_->SetDisplayColorSpace(this, blending_color_space_,
                                                   output_color_space_);
  }
}

void Compositor::OnDisplayDidFinishFrame(const viz::BeginFrameAck& ack) {
  DCHECK(external_begin_frames_enabled_);
  if (external_begin_frame_client_)
    external_begin_frame_client_->OnDisplayDidFinishFrame(ack);
}
