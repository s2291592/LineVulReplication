size_t get_camera_metadata_entry_capacity(const camera_metadata_t *metadata) {
 return metadata->entry_capacity;
}

int find_camera_metadata_entry(camera_metadata_t *src,
 uint32_t tag,
 camera_metadata_entry_t *entry) {
 if (src == NULL) return ERROR;

 uint32_t index;
 if (src->flags & FLAG_SORTED) {
 camera_metadata_buffer_entry_t *search_entry = NULL;
 camera_metadata_buffer_entry_t key;
        key.tag = tag;
        search_entry = bsearch(&key,
                get_entries(src),
                src->entry_count,
 sizeof(camera_metadata_buffer_entry_t),
                compare_entry_tags);
 if (search_entry == NULL) return NOT_FOUND;
        index = search_entry - get_entries(src);
 } else {
 camera_metadata_buffer_entry_t *search_entry = get_entries(src);
 for (index = 0; index < src->entry_count; index++, search_entry++) {
 if (search_entry->tag == tag) {
 break;
 }
 }
 if (index == src->entry_count) return NOT_FOUND;
 }

 return get_camera_metadata_entry(src, index,
            entry);
}

int get_camera_metadata_tag_type(uint32_t tag) {
 uint32_t tag_section = tag >> 16;
 if (tag_section >= VENDOR_SECTION && vendor_tag_ops != NULL) {
 return vendor_tag_ops->get_tag_type(
            vendor_tag_ops,
            tag);
 }
 if (tag_section >= ANDROID_SECTION_COUNT ||
            tag >= camera_metadata_section_bounds[tag_section][1] ) {
 return -1;
 }
 uint32_t tag_index = tag & 0xFFFF;
 return tag_info[tag_section][tag_index].tag_type;
}

int delete_camera_metadata_entry(camera_metadata_t *dst,
 size_t index) {
 if (dst == NULL) return ERROR;
 if (index >= dst->entry_count) return ERROR;

 camera_metadata_buffer_entry_t *entry = get_entries(dst) + index;
 size_t data_bytes = calculate_camera_metadata_entry_data_size(entry->type,
            entry->count);

 if (data_bytes > 0) {
 uint8_t *start = get_data(dst) + entry->data.offset;
 uint8_t *end = start + data_bytes;
 size_t length = dst->data_count - entry->data.offset - data_bytes;
        memmove(start, end, length);

 camera_metadata_buffer_entry_t *e = get_entries(dst);
 size_t i;
 for (i = 0; i < dst->entry_count; i++) {
 if (calculate_camera_metadata_entry_data_size(
                    e->type, e->count) > 0 &&
                    e->data.offset > entry->data.offset) {
                e->data.offset -= data_bytes;
 }
 ++e;
 }
        dst->data_count -= data_bytes;
 }
    memmove(entry, entry + 1,
 sizeof(camera_metadata_buffer_entry_t) *
 (dst->entry_count - index - 1) );
    dst->entry_count -= 1;

    assert(validate_camera_metadata_structure(dst, NULL) == OK);
 return OK;
}

static int compare_entry_tags(const void *p1, const void *p2) {
 uint32_t tag1 = ((camera_metadata_buffer_entry_t*)p1)->tag;
 uint32_t tag2 = ((camera_metadata_buffer_entry_t*)p2)->tag;
 return  tag1 < tag2 ? -1 :
            tag1 == tag2 ? 0 :
 1;
}

size_t get_camera_metadata_compact_size(const camera_metadata_t *metadata) {
 if (metadata == NULL) return ERROR;

 return calculate_camera_metadata_size(metadata->entry_count,
                                          metadata->data_count);
}

static camera_metadata_buffer_entry_t *get_entries(
 const camera_metadata_t *metadata) {
 return (camera_metadata_buffer_entry_t*)
 ((uint8_t*)metadata + metadata->entries_start);
}

size_t get_camera_metadata_size(const camera_metadata_t *metadata) {
 if (metadata == NULL) return ERROR;

 return metadata->size;
}

camera_metadata_t* copy_camera_metadata(void *dst, size_t dst_size,
 const camera_metadata_t *src) {
 size_t memory_needed = get_camera_metadata_compact_size(src);

 if (dst == NULL) return NULL;
 if (dst_size < memory_needed) return NULL;

 camera_metadata_t *metadata =
        place_camera_metadata(dst, dst_size, src->entry_count, src->data_count);

    metadata->flags = src->flags;
    metadata->entry_count = src->entry_count;
    metadata->data_count = src->data_count;

    memcpy(get_entries(metadata), get_entries(src),
 sizeof(camera_metadata_buffer_entry_t[metadata->entry_count]));
    memcpy(get_data(metadata), get_data(src),
 sizeof(uint8_t[metadata->data_count]));

    assert(validate_camera_metadata_structure(metadata, NULL) == OK);

     return metadata;
 }

size_t calculate_camera_metadata_size(size_t entry_count,
 size_t data_count) {
 size_t memory_needed = sizeof(camera_metadata_t);
    memory_needed = ALIGN_TO(memory_needed, ENTRY_ALIGNMENT);
    memory_needed += sizeof(camera_metadata_buffer_entry_t[entry_count]);
    memory_needed = ALIGN_TO(memory_needed, DATA_ALIGNMENT);
    memory_needed += sizeof(uint8_t[data_count]);
 return memory_needed;
}

camera_metadata_t *allocate_copy_camera_metadata_checked(
 const camera_metadata_t *src,
 size_t src_size) {

 if (src == NULL) {
 return NULL;
 }

 void *buffer = malloc(src_size);
    memcpy(buffer, src, src_size);

 camera_metadata_t *metadata = (camera_metadata_t*) buffer;
 if (validate_camera_metadata_structure(metadata, &src_size) != OK) {
        free(buffer);
 return NULL;
 }

 return metadata;
}

void dump_camera_metadata(const camera_metadata_t *metadata,
 int fd,
 int verbosity) {
    dump_indented_camera_metadata(metadata, fd, verbosity, 0);
}

int get_camera_metadata_ro_entry(const camera_metadata_t *src,
 size_t index,
 camera_metadata_ro_entry_t *entry) {
 return get_camera_metadata_entry((camera_metadata_t*)src, index,
 (camera_metadata_entry_t*)entry);
}

const char *get_camera_metadata_section_name(uint32_t tag) {
 uint32_t tag_section = tag >> 16;
 if (tag_section >= VENDOR_SECTION && vendor_tag_ops != NULL) {
 return vendor_tag_ops->get_section_name(
            vendor_tag_ops,
            tag);
 }
 if (tag_section >= ANDROID_SECTION_COUNT) {
 return NULL;
 }
 return camera_metadata_section_names[tag_section];
}

int find_camera_metadata_ro_entry(const camera_metadata_t *src,
 uint32_t tag,
 camera_metadata_ro_entry_t *entry) {
 return find_camera_metadata_entry((camera_metadata_t*)src, tag,
 (camera_metadata_entry_t*)entry);
}

int append_camera_metadata(camera_metadata_t *dst,
 const camera_metadata_t *src) {
 if (dst == NULL || src == NULL ) return ERROR;

 if (dst->entry_capacity < src->entry_count + dst->entry_count) return ERROR;
 if (dst->data_capacity < src->data_count + dst->data_count) return ERROR;

    memcpy(get_entries(dst) + dst->entry_count, get_entries(src),
 sizeof(camera_metadata_buffer_entry_t[src->entry_count]));
    memcpy(get_data(dst) + dst->data_count, get_data(src),
 sizeof(uint8_t[src->data_count]));
 if (dst->data_count != 0) {
 camera_metadata_buffer_entry_t *entry = get_entries(dst) + dst->entry_count;
 for (size_t i = 0; i < src->entry_count; i++, entry++) {
 if ( calculate_camera_metadata_entry_data_size(entry->type,
                            entry->count) > 0 ) {
                entry->data.offset += dst->data_count;
 }
 }
 }
 if (dst->entry_count == 0) {
        dst->flags |= src->flags & FLAG_SORTED;
 } else if (src->entry_count != 0) {
        dst->flags &= ~FLAG_SORTED;
 } else {
 }
    dst->entry_count += src->entry_count;
    dst->data_count += src->data_count;

    assert(validate_camera_metadata_structure(dst, NULL) == OK);
 return OK;
}

static void print_data(int fd, const uint8_t *data_ptr, uint32_t tag,
 int type, int count, int indentation) {
 static int values_per_line[NUM_TYPES] = {
 [TYPE_BYTE] = 16,
 [TYPE_INT32] = 4,
 [TYPE_FLOAT] = 8,
 [TYPE_INT64] = 2,
 [TYPE_DOUBLE] = 4,
 [TYPE_RATIONAL] = 2,
 };
 size_t type_size = camera_metadata_type_size[type];
 char value_string_tmp[CAMERA_METADATA_ENUM_STRING_MAX_SIZE];
 uint32_t value;

 int lines = count / values_per_line[type];
 if (count % values_per_line[type] != 0) lines++;

 int index = 0;
 int j, k;
 for (j = 0; j < lines; j++) {
        dprintf(fd, "%*s[", indentation + 4, "");
 for (k = 0;
             k < values_per_line[type] && count > 0;
             k++, count--, index += type_size) {

 switch (type) {
 case TYPE_BYTE:
                    value = *(data_ptr + index);
 if (camera_metadata_enum_snprint(tag,
                                                     value,
                                                     value_string_tmp,
 sizeof(value_string_tmp))
 == OK) {
                        dprintf(fd, "%s ", value_string_tmp);
 } else {
                        dprintf(fd, "%hhu ",
 *(data_ptr + index));
 }
 break;
 case TYPE_INT32:
                    value =
 *(int32_t*)(data_ptr + index);
 if (camera_metadata_enum_snprint(tag,
                                                     value,
                                                     value_string_tmp,
 sizeof(value_string_tmp))
 == OK) {
                        dprintf(fd, "%s ", value_string_tmp);
 } else {
                        dprintf(fd, "%" PRId32 " ",
 *(int32_t*)(data_ptr + index));
 }
 break;
 case TYPE_FLOAT:
                    dprintf(fd, "%0.8f ",
 *(float*)(data_ptr + index));
 break;
 case TYPE_INT64:
                    dprintf(fd, "%" PRId64 " ",
 *(int64_t*)(data_ptr + index));
 break;
 case TYPE_DOUBLE:
                    dprintf(fd, "%0.8f ",
 *(double*)(data_ptr + index));
 break;
 case TYPE_RATIONAL: {
 int32_t numerator = *(int32_t*)(data_ptr + index);
 int32_t denominator = *(int32_t*)(data_ptr + index + 4);
                    dprintf(fd, "(%d / %d) ",
                            numerator, denominator);
 break;
 }
 default:
                    dprintf(fd, "??? ");
 }
 }
        dprintf(fd, "]\n");
 }
}

size_t get_camera_metadata_alignment() {
 return METADATA_PACKET_ALIGNMENT;
}

 static int add_camera_metadata_entry_raw(camera_metadata_t *dst,
         uint32_t tag,
         uint8_t  type,
 const void *data,
 size_t data_count) {

 if (dst == NULL) return ERROR;
 if (dst->entry_count == dst->entry_capacity) return ERROR;
 if (data_count && data == NULL) return ERROR;

 size_t data_bytes =
            calculate_camera_metadata_entry_data_size(type, data_count);
 if (data_bytes + dst->data_count > dst->data_capacity) return ERROR;

 size_t data_payload_bytes =
            data_count * camera_metadata_type_size[type];
 camera_metadata_buffer_entry_t *entry = get_entries(dst) + dst->entry_count;
    memset(entry, 0, sizeof(camera_metadata_buffer_entry_t));
    entry->tag = tag;
    entry->type = type;
    entry->count = data_count;

 if (data_bytes == 0) {
        memcpy(entry->data.value, data,
                data_payload_bytes);
 } else {
        entry->data.offset = dst->data_count;
        memcpy(get_data(dst) + entry->data.offset, data,
                data_payload_bytes);
        dst->data_count += data_bytes;
 }
    dst->entry_count++;
    dst->flags &= ~FLAG_SORTED;
    assert(validate_camera_metadata_structure(dst, NULL) == OK);
 return OK;
}

int set_camera_metadata_vendor_ops(const vendor_tag_ops_t* ops) {
    vendor_tag_ops = ops;
 return OK;
}

size_t get_camera_metadata_data_count(const camera_metadata_t *metadata) {
 return metadata->data_count;
}

camera_metadata_t *place_camera_metadata(void *dst,
 size_t dst_size,
 size_t entry_capacity,
 size_t data_capacity) {
 if (dst == NULL) return NULL;

 size_t memory_needed = calculate_camera_metadata_size(entry_capacity,
                                                          data_capacity);
 if (memory_needed > dst_size) return NULL;

 camera_metadata_t *metadata = (camera_metadata_t*)dst;
    metadata->version = CURRENT_METADATA_VERSION;
    metadata->flags = 0;
    metadata->entry_count = 0;
    metadata->entry_capacity = entry_capacity;
    metadata->entries_start =
            ALIGN_TO(sizeof(camera_metadata_t), ENTRY_ALIGNMENT);
    metadata->data_count = 0;
    metadata->data_capacity = data_capacity;
    metadata->size = memory_needed;
 size_t data_unaligned = (uint8_t*)(get_entries(metadata) +
            metadata->entry_capacity) - (uint8_t*)metadata;
    metadata->data_start = ALIGN_TO(data_unaligned, DATA_ALIGNMENT);

    assert(validate_camera_metadata_structure(metadata, NULL) == OK);
 return metadata;
}

size_t calculate_camera_metadata_entry_data_size(uint8_t type,
        size_t data_count) {
    if (type >= NUM_TYPES) return 0;
    size_t data_bytes = data_count *
            camera_metadata_type_size[type];
    return data_bytes <= 4 ? 0 : ALIGN_TO(data_bytes, DATA_ALIGNMENT);
}

size_t get_camera_metadata_entry_count(const camera_metadata_t *metadata) {
 return metadata->entry_count;
}

int set_camera_metadata_vendor_tag_ops(const vendor_tag_query_ops_t* ops) {
 (void) ops;
    ALOGE("%s: This function has been deprecated", __FUNCTION__);
 return ERROR;
}

camera_metadata_t *allocate_camera_metadata(size_t entry_capacity,
 size_t data_capacity) {

 size_t memory_needed = calculate_camera_metadata_size(entry_capacity,
                                                          data_capacity);
 void *buffer = malloc(memory_needed);
 return place_camera_metadata(buffer, memory_needed,
                                 entry_capacity,
                                 data_capacity);
}
