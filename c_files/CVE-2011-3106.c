void ResourceDispatcherHostImpl::OnShutdown() {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));
  is_shutdown_ = true;
  for (PendingRequestList::const_iterator i = pending_requests_.begin();
       i != pending_requests_.end(); ++i) {
    transferred_navigations_.erase(i->first);
  }
  STLDeleteValues(&pending_requests_);
  update_load_states_timer_.reset();

  std::set<ProcessRouteIDs> ids;
  for (BlockedRequestMap::const_iterator iter = blocked_requests_map_.begin();
       iter != blocked_requests_map_.end(); ++iter) {
    std::pair<std::set<ProcessRouteIDs>::iterator, bool> result =
        ids.insert(iter->first);
    DCHECK(result.second);
  }
  for (std::set<ProcessRouteIDs>::const_iterator iter = ids.begin();
       iter != ids.end(); ++iter) {
    CancelBlockedRequestsForRoute(iter->first, iter->second);
  }
}

void ResourceDispatcherHostImpl::UpdateLoadStates() {
  LoadInfoMap info_map;

  PendingRequestList::const_iterator i;

  std::map<std::pair<int, int>, uint64> largest_upload_size;
  for (i = pending_requests_.begin(); i != pending_requests_.end(); ++i) {
    net::URLRequest* request = i->second;
    ResourceRequestInfoImpl* info =
        ResourceRequestInfoImpl::ForRequest(request);
    uint64 upload_size = info->GetUploadSize();
    if (request->GetLoadState().state != net::LOAD_STATE_SENDING_REQUEST)
      upload_size = 0;
    std::pair<int, int> key(info->GetChildID(), info->GetRouteID());
    if (upload_size && largest_upload_size[key] < upload_size)
      largest_upload_size[key] = upload_size;
  }

  for (i = pending_requests_.begin(); i != pending_requests_.end(); ++i) {
    net::URLRequest* request = i->second;
    net::LoadStateWithParam load_state = request->GetLoadState();
    ResourceRequestInfoImpl* info =
        ResourceRequestInfoImpl::ForRequest(request);
    std::pair<int, int> key(info->GetChildID(), info->GetRouteID());

    MaybeUpdateUploadProgress(info, request);

    if (largest_upload_size.find(key) != largest_upload_size.end() &&
        info->GetUploadSize() < largest_upload_size[key])
      continue;

    net::LoadStateWithParam to_insert = load_state;
    LoadInfoMap::iterator existing = info_map.find(key);
    if (existing != info_map.end()) {
      to_insert =
          MoreInterestingLoadState(existing->second.load_state, load_state);
      if (to_insert.state == existing->second.load_state.state)
        continue;
    }
    LoadInfo& load_info = info_map[key];
    load_info.url = request->url();
    load_info.load_state = to_insert;
    load_info.upload_size = info->GetUploadSize();
    load_info.upload_position = request->GetUploadProgress();
  }

  if (info_map.empty())
    return;

  BrowserThread::PostTask(
      BrowserThread::UI, FROM_HERE,
      base::Bind(&LoadInfoUpdateCallback, info_map));
}

void ResourceDispatcherHostImpl::OnReceivedRedirect(net::URLRequest* request,
                                                    const GURL& new_url,
                                                    bool* defer_redirect) {
  VLOG(1) << "OnReceivedRedirect: " << request->url().spec();
  ResourceRequestInfoImpl* info = ResourceRequestInfoImpl::ForRequest(request);

  DCHECK(request->status().is_success());

  if (info->process_type() != PROCESS_TYPE_PLUGIN &&
      !ChildProcessSecurityPolicyImpl::GetInstance()->
          CanRequestURL(info->GetChildID(), new_url)) {
    VLOG(1) << "Denied unauthorized request for "
            << new_url.possibly_invalid_spec();

    CancelRequestInternal(request, false);
    return;
  }

  NotifyReceivedRedirect(request, info->GetChildID(), new_url);

  if (HandleExternalProtocol(info->GetRequestID(), info->GetChildID(),
                             info->GetRouteID(), new_url,
                             info->GetResourceType(),
                             *request->context()->job_factory(),
                             info->resource_handler())) {
    RemovePendingRequest(info->GetChildID(), info->GetRequestID());
    return;
  }

  scoped_refptr<ResourceResponse> response(new ResourceResponse);
  PopulateResourceResponse(request, response);
  if (!info->resource_handler()->OnRequestRedirected(info->GetRequestID(),
                                                     new_url,
                                                     response, defer_redirect))
    CancelRequestInternal(request, false);
}

void SocketStreamDispatcherHost::DeleteSocketStreamHost(int socket_id) {
  SocketStreamHost* socket_stream_host = hosts_.Lookup(socket_id);
  DCHECK(socket_stream_host);
  delete socket_stream_host;
  hosts_.Remove(socket_id);
  if (!Send(new SocketStreamMsg_Closed(socket_id))) {
    LOG(ERROR) << "SocketStreamMsg_Closed failed.";
  }
}

void SocketStreamDispatcherHost::OnSentData(net::SocketStream* socket,
                                            int amount_sent) {
  int socket_id = SocketStreamHost::SocketIdFromSocketStream(socket);
  DVLOG(1) << "SocketStreamDispatcherHost::OnSentData socket_id=" << socket_id
           << " amount_sent=" << amount_sent;
  if (socket_id == content::kNoSocketId) {
    LOG(ERROR) << "NoSocketId in OnSentData";
    return;
  }
  if (!Send(new SocketStreamMsg_SentData(socket_id, amount_sent))) {
    LOG(ERROR) << "SocketStreamMsg_SentData failed.";
    DeleteSocketStreamHost(socket_id);
  }
}

bool ResourceDispatcherHostImpl::CompleteRead(net::URLRequest* request,
                                              int* bytes_read) {
  if (!request || !request->status().is_success()) {
    NOTREACHED();
    return false;
  }

  ResourceRequestInfoImpl* info = ResourceRequestInfoImpl::ForRequest(request);

  bool defer = false;
  if (!info->resource_handler()->OnReadCompleted(info->GetRequestID(),
                                                 bytes_read, &defer)) {
    CancelRequestInternal(request, false);
    return false;
  }

  if (defer)
    PauseRequest(info->GetChildID(), info->GetRequestID(), true);

  return *bytes_read != 0;
}

void ResourceDispatcherHostImpl::OnDataReceivedACK(int request_id) {
  DataReceivedACK(filter_->child_id(), request_id);
}

void ResourceDispatcherHostImpl::PauseRequest(int child_id,
int request_id,
bool pause) {
GlobalRequestID global_id(child_id, request_id);
PendingRequestList::iterator i = pending_requests_.find(global_id);
if (i == pending_requests_.end()) {
DVLOG(1) << "Pausing a request that wasn't found";
return;
}

ResourceRequestInfoImpl* info =
ResourceRequestInfoImpl::ForRequest(i->second);
int pause_count = info->pause_count() + (pause ? 1 : -1);
if (pause_count < 0) {
NOTREACHED();  // Unbalanced call to pause.
return;
}
info->set_pause_count(pause_count);

VLOG(1) << "To pause (" << pause << "): " << i->second->url().spec();

// If we're resuming, kick the request to start reading again. Run the read
// asynchronously to avoid recursion problems.
if (info->pause_count() == 0) {
MessageLoop::current()->PostTask(FROM_HERE,
        base::Bind(
            &ResourceDispatcherHostImpl::ResumeRequest,
            weak_factory_.GetWeakPtr(),
            global_id));
}
}

void SSLErrorHandler::Dispatch() {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  WebContents* web_contents = NULL;
  RenderViewHostImpl* render_view_host =
      RenderViewHostImpl::FromID(render_process_id_, render_view_id_);
  if (render_view_host)
    web_contents = render_view_host->GetDelegate()->GetAsWebContents();

  if (!web_contents) {
    OnDispatchFailed();
    return;
  }

  manager_ =
      static_cast<NavigationControllerImpl*>(&web_contents->GetController())->
          ssl_manager();
  OnDispatched();
}

void ResourceDispatcherHostImpl::OnReleaseDownloadedFile(int request_id) {
  DCHECK(pending_requests_.end() ==
         pending_requests_.find(
             GlobalRequestID(filter_->child_id(), request_id)));
  UnregisterDownloadedTempFile(filter_->child_id(), request_id);
}

bool ResourceDispatcherHostImpl::IsValidRequest(net::URLRequest* request) {
  if (!request)
    return false;
  ResourceRequestInfoImpl* info = ResourceRequestInfoImpl::ForRequest(request);
  return pending_requests_.find(
      GlobalRequestID(info->GetChildID(), info->GetRequestID())) !=
      pending_requests_.end();
}

void SSLErrorHandler::DenyRequest() {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  BrowserThread::PostTask(
      BrowserThread::IO, FROM_HERE,
      base::Bind(
          &SSLErrorHandler::CompleteCancelRequest, this,
          net::ERR_INSECURE_RESPONSE));
}

void ResourceDispatcherHostImpl::OnFollowRedirect(
    int request_id,
    bool has_new_first_party_for_cookies,
    const GURL& new_first_party_for_cookies) {
  FollowDeferredRedirect(filter_->child_id(), request_id,
                         has_new_first_party_for_cookies,
                         new_first_party_for_cookies);
}

void SSLManager::DidLoadFromMemoryCache(LoadFromMemoryCacheDetails* details) {
  scoped_refptr<SSLRequestInfo> info(new SSLRequestInfo(
      details->url(),
      ResourceType::SUB_RESOURCE,
      details->pid(),
      details->ssl_cert_id(),
      details->ssl_cert_status()));

  policy()->OnRequestStarted(info.get());
}

net::Error CallbackAndReturn(
    const DownloadResourceHandler::OnStartedCallback& started_cb,
    net::Error net_error) {
  if (started_cb.is_null())
    return net_error;
  BrowserThread::PostTask(
      BrowserThread::UI, FROM_HERE,
      base::Bind(started_cb, content::DownloadId::Invalid(), net_error));

  return net_error;
}

void ResourceDispatcherHostImpl::ProcessBlockedRequestsForRoute(
    int child_id,
    int route_id,
    bool cancel_requests) {
  BlockedRequestMap::iterator iter = blocked_requests_map_.find(
      std::pair<int, int>(child_id, route_id));
  if (iter == blocked_requests_map_.end()) {
    return;
  }

  BlockedRequestsList* requests = iter->second;

  blocked_requests_map_.erase(iter);

  for (BlockedRequestsList::iterator req_iter = requests->begin();
       req_iter != requests->end(); ++req_iter) {
    net::URLRequest* request = *req_iter;
    ResourceRequestInfoImpl* info =
        ResourceRequestInfoImpl::ForRequest(request);
    IncrementOutstandingRequestsMemoryCost(-1 * info->memory_cost(),
                                           info->GetChildID());
    if (cancel_requests)
      delete request;
    else
      BeginRequestInternal(request);
  }

  delete requests;
}

void SSLCertErrorHandler::OnDispatched() {
  manager_->policy()->OnCertError(this);
}

void SocketStreamDispatcherHost::OnSSLCertificateError(
net::SocketStream* socket, const net::SSLInfo& ssl_info, bool fatal) {
int socket_id = SocketStreamHost::SocketIdFromSocketStream(socket);
DVLOG(1) << "SocketStreamDispatcherHost::OnSSLCertificateError socket_id="
<< socket_id;
if (socket_id == content::kNoSocketId) {
LOG(ERROR) << "NoSocketId in OnSSLCertificateError";
return;
}
SocketStreamHost* socket_stream_host = hosts_.Lookup(socket_id);
DCHECK(socket_stream_host);
content::GlobalRequestID request_id(-1, socket_id);
  SSLManager::OnSSLCertificateError(ssl_delegate_weak_factory_.GetWeakPtr(),
      request_id, ResourceType::SUB_RESOURCE, socket->url(),
render_process_id_, socket_stream_host->render_view_id(), ssl_info,
fatal);
}

void ResourceDispatcherHostImpl::ClearLoginDelegateForRequest(
    net::URLRequest* request) {
  ResourceRequestInfoImpl* info = ResourceRequestInfoImpl::ForRequest(request);
  if (info)
    info->set_login_delegate(NULL);
}

bool ResourceDispatcherHostImpl::PauseRequestIfNeeded(
    ResourceRequestInfoImpl* info) {
  if (info->pause_count() > 0)
    info->set_is_paused(true);
  return info->is_paused();
}

void SSLManager::DidRunInsecureContent(const std::string& security_origin) {
  policy()->DidRunInsecureContent(
      NavigationEntryImpl::FromNavigationEntry(controller_->GetActiveEntry()),
      security_origin);
}

void ResourceDispatcherHostImpl::OnSwapOutACK(
    const ViewMsg_SwapOut_Params& params) {
  GlobalRequestID global_id(params.new_render_process_host_id,
                            params.new_request_id);
  PendingRequestList::iterator i = pending_requests_.find(global_id);
  if (i != pending_requests_.end()) {
    ResourceRequestInfoImpl* info =
        ResourceRequestInfoImpl::ForRequest(i->second);
    if (info->cross_site_handler())
      info->cross_site_handler()->ResumeResponse();
  }
  BrowserThread::PostTask(
      BrowserThread::UI,
      FROM_HERE,
      base::Bind(&OnSwapOutACKHelper,
                 params.closing_process_id,
                 params.closing_route_id));
}

void SocketStreamDispatcherHost::OnClose(net::SocketStream* socket) {
  int socket_id = SocketStreamHost::SocketIdFromSocketStream(socket);
  DVLOG(1) << "SocketStreamDispatcherHost::OnClosed socket_id=" << socket_id;
  if (socket_id == content::kNoSocketId) {
    LOG(ERROR) << "NoSocketId in OnClose";
    return;
  }
  DeleteSocketStreamHost(socket_id);
}

ResourceDispatcherHostImpl::CreateResourceHandlerForDownload(
    net::URLRequest* request,
    ResourceContext* context,
    int child_id,
    int route_id,
    int request_id,
    bool is_content_initiated,
    const DownloadSaveInfo& save_info,
    const DownloadResourceHandler::OnStartedCallback& started_cb) {
  scoped_refptr<ResourceHandler> handler(
      new DownloadResourceHandler(child_id, route_id, request_id,
                                  request->url(), download_file_manager_.get(),
                                  request, started_cb, save_info));
  if (delegate_) {
    ScopedVector<ResourceThrottle> throttles;
    delegate_->DownloadStarting(request, context, child_id, route_id,
                                request_id, is_content_initiated, &throttles);
    if (!throttles.empty()) {
      handler = new ThrottlingResourceHandler(this, handler, child_id,
                                              request_id, throttles.Pass());
    }
  }
  return handler;
}

void SSLManager::Observe(int type,
                         const content::NotificationSource& source,
                         const content::NotificationDetails& details) {
  switch (type) {
    case content::NOTIFICATION_RESOURCE_RESPONSE_STARTED:
      DidStartResourceResponse(
          content::Details<ResourceRequestDetails>(details).ptr());
      break;
    case content::NOTIFICATION_RESOURCE_RECEIVED_REDIRECT:
      DidReceiveResourceRedirect(
          content::Details<ResourceRedirectDetails>(details).ptr());
      break;
    case content::NOTIFICATION_LOAD_FROM_MEMORY_CACHE:
      DidLoadFromMemoryCache(
          content::Details<LoadFromMemoryCacheDetails>(details).ptr());
      break;
    case content::NOTIFICATION_SSL_INTERNAL_STATE_CHANGED:
      DidChangeSSLInternalState();
      break;
    default:
      NOTREACHED() << "The SSLManager received an unexpected notification.";
  }
}

bool ResourceDispatcherHostImpl::Read(net::URLRequest* request,
                                      int* bytes_read) {
  ResourceRequestInfoImpl* info = ResourceRequestInfoImpl::ForRequest(request);
  DCHECK(!info->is_paused());

  net::IOBuffer* buf;
  int buf_size;
  if (!info->resource_handler()->OnWillRead(info->GetRequestID(),
                                            &buf, &buf_size, -1)) {
    return false;
  }

  DCHECK(buf);
  DCHECK(buf_size > 0);

  info->set_has_started_reading(true);
  return request->Read(buf, buf_size, bytes_read);
}

SSLCertErrorHandler::SSLCertErrorHandler(
    base::WeakPtr<Delegate> delegate,
const content::GlobalRequestID& id,
ResourceType::Type resource_type,
const GURL& url,
int render_process_id,
int render_view_id,
const net::SSLInfo& ssl_info,
bool fatal)
: SSLErrorHandler(delegate, id, resource_type, url, render_process_id,
render_view_id),
ssl_info_(ssl_info),
cert_error_(net::MapCertStatusToNetError(ssl_info.cert_status)),
fatal_(fatal) {
}

SSLCertErrorHandler::~SSLCertErrorHandler() {}

bool ResourceDispatcherHostImpl::CancelRequestInternal(net::URLRequest* request,
                                                       bool from_renderer) {
  VLOG(1) << "CancelRequest: " << request->url().spec();

  ResourceRequestInfoImpl* info = ResourceRequestInfoImpl::ForRequest(request);
  if (!from_renderer || !info->is_download()) {
    if (info->login_delegate()) {
      info->login_delegate()->OnRequestCancelled();
      info->set_login_delegate(NULL);
    }
    if (info->ssl_client_auth_handler()) {
      info->ssl_client_auth_handler()->OnRequestCancelled();
      info->set_ssl_client_auth_handler(NULL);
    }
    request->Cancel();
    DCHECK(IsValidRequest(request));
    return true;
  }

  return false;
}

SSLErrorHandler::SSLErrorHandler(base::WeakPtr<Delegate> delegate,
                                  const content::GlobalRequestID& id,
                                  ResourceType::Type resource_type,
                                  const GURL& url,
                                 int render_process_id,
                                 int render_view_id)
    : manager_(NULL),
      request_id_(id),
      delegate_(delegate),
      render_process_id_(render_process_id),
      render_view_id_(render_view_id),
      request_url_(url),
      resource_type_(resource_type),
      request_has_been_notified_(false) {
  DCHECK(!BrowserThread::CurrentlyOn(BrowserThread::UI));
  DCHECK(delegate);

  AddRef();
}

void SSLErrorHandler::CancelRequest() {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  BrowserThread::PostTask(
      BrowserThread::IO, FROM_HERE,
      base::Bind(
          &SSLErrorHandler::CompleteCancelRequest, this, net::ERR_ABORTED));
}

void SSLManager::DidChangeSSLInternalState() {
  UpdateEntry(
      NavigationEntryImpl::FromNavigationEntry(controller_->GetActiveEntry()));
}

void ResourceDispatcherHostImpl::BeginRequestInternal(
    net::URLRequest* request) {
  DCHECK(!request->is_pending());
  ResourceRequestInfoImpl* info = ResourceRequestInfoImpl::ForRequest(request);

  if ((TimeTicks::Now() - last_user_gesture_time_) <
      TimeDelta::FromMilliseconds(kUserGestureWindowMs)) {
    request->set_load_flags(
        request->load_flags() | net::LOAD_MAYBE_USER_GESTURE);
  }

  info->set_memory_cost(CalculateApproximateMemoryCost(request));
  int memory_cost = IncrementOutstandingRequestsMemoryCost(info->memory_cost(),
                                                           info->GetChildID());

  if (memory_cost > max_outstanding_requests_cost_per_process_) {
    request->CancelWithError(net::ERR_INSUFFICIENT_RESOURCES);

    GlobalRequestID global_id(info->GetChildID(), info->GetRequestID());
    pending_requests_[global_id] = request;
    ResponseCompleted(request);
    return;
  }

  std::pair<int, int> pair_id(info->GetChildID(), info->GetRouteID());
  BlockedRequestMap::const_iterator iter = blocked_requests_map_.find(pair_id);
  if (iter != blocked_requests_map_.end()) {
    iter->second->push_back(request);
    return;
  }

  GlobalRequestID global_id(info->GetChildID(), info->GetRequestID());
  pending_requests_[global_id] = request;

  bool defer_start = false;
  if (!info->resource_handler()->OnWillStart(
          info->GetRequestID(), request->url(),
          &defer_start)) {
    CancelRequestInternal(request, false);
    return;
  }

  if (!defer_start)
    StartRequest(request);
}

void ResourceDispatcherHostImpl::RemovePendingRequest(int child_id,
                                                      int request_id) {
  PendingRequestList::iterator i = pending_requests_.find(
      GlobalRequestID(child_id, request_id));
  if (i == pending_requests_.end()) {
    NOTREACHED() << "Trying to remove a request that's not here";
    return;
  }
  RemovePendingRequest(i);
}

void ResourceDispatcherHostImpl::OnTransferRequestToNewPage(int new_routing_id,
                                                            int request_id) {
  PendingRequestList::iterator i = pending_requests_.find(
      GlobalRequestID(filter_->child_id(), request_id));
  if (i == pending_requests_.end()) {
    DVLOG(1) << "Updating a request that wasn't found";
    return;
  }
  net::URLRequest* request = i->second;
  ResourceRequestInfoImpl* info = ResourceRequestInfoImpl::ForRequest(request);
  info->set_route_id(new_routing_id);
}

void ResourceDispatcherHostImpl::CallResponseCompleted(int child_id,
                                                       int request_id) {
  PendingRequestList::iterator i = pending_requests_.find(
      GlobalRequestID(child_id, request_id));
  if (i != pending_requests_.end())
    ResponseCompleted(i->second);
}

void ResourceDispatcherHostImpl::OnAuthRequired(
    net::URLRequest* request,
    net::AuthChallengeInfo* auth_info) {
  if (request->load_flags() & net::LOAD_DO_NOT_PROMPT_FOR_LOGIN) {
    request->CancelAuth();
    return;
  }

  if (delegate_ && !delegate_->AcceptAuthRequest(request, auth_info)) {
    request->CancelAuth();
    return;
  }

  if (!auth_info->is_proxy) {
    HttpAuthResourceType resource_type = HttpAuthResourceTypeOf(request);
    UMA_HISTOGRAM_ENUMERATION("Net.HttpAuthResource",
                              resource_type,
                              HTTP_AUTH_RESOURCE_LAST);

    if (resource_type == HTTP_AUTH_RESOURCE_BLOCKED_CROSS) {
      request->CancelAuth();
      return;
    }
  }


  ResourceRequestInfoImpl* info = ResourceRequestInfoImpl::ForRequest(request);
  DCHECK(!info->login_delegate()) <<
      "OnAuthRequired called with login_delegate pending";
  if (delegate_) {
    info->set_login_delegate(delegate_->CreateLoginDelegate(
        auth_info, request));
  }
  if (!info->login_delegate())
    request->CancelAuth();
}

void ResourceDispatcherHostImpl::FollowDeferredRedirect(
    int child_id,
    int request_id,
    bool has_new_first_party_for_cookies,
    const GURL& new_first_party_for_cookies) {
  PendingRequestList::iterator i = pending_requests_.find(
      GlobalRequestID(child_id, request_id));
  if (i == pending_requests_.end() || !i->second->status().is_success()) {
    DVLOG(1) << "FollowDeferredRedirect for invalid request";
    return;
  }

  if (has_new_first_party_for_cookies)
    i->second->set_first_party_for_cookies(new_first_party_for_cookies);
  i->second->FollowDeferredRedirect();
}

net::Error ResourceDispatcherHostImpl::BeginDownload(
    scoped_ptr<net::URLRequest> request,
    bool is_content_initiated,
    ResourceContext* context,
    int child_id,
    int route_id,
    bool prefer_cache,
    const DownloadSaveInfo& save_info,
    const DownloadStartedCallback& started_callback) {
  if (is_shutdown_)
    return CallbackAndReturn(started_callback, net::ERR_INSUFFICIENT_RESOURCES);

  const GURL& url = request->original_url();

  char url_buf[128];
  base::strlcpy(url_buf, url.spec().c_str(), arraysize(url_buf));
  base::debug::Alias(url_buf);
  CHECK(ContainsKey(active_resource_contexts_, context));

  const net::URLRequestContext* request_context = context->GetRequestContext();
  request->set_referrer(MaybeStripReferrer(GURL(request->referrer())).spec());
  request->set_context(request_context);
  int extra_load_flags = net::LOAD_IS_DOWNLOAD;
  if (prefer_cache) {
    if (request->get_upload() != NULL)
      extra_load_flags |= net::LOAD_ONLY_FROM_CACHE;
    else
      extra_load_flags |= net::LOAD_PREFERRING_CACHE;
  } else {
    extra_load_flags |= net::LOAD_DISABLE_CACHE;
  }
  request->set_load_flags(request->load_flags() | extra_load_flags);
  if (!ChildProcessSecurityPolicyImpl::GetInstance()->
          CanRequestURL(child_id, url)) {
    VLOG(1) << "Denied unauthorized download request for "
            << url.possibly_invalid_spec();
    return CallbackAndReturn(started_callback, net::ERR_ACCESS_DENIED);
  }

  request_id_--;

  scoped_refptr<ResourceHandler> handler(
      CreateResourceHandlerForDownload(request.get(), context, child_id,
                                       route_id, request_id_,
                                       is_content_initiated, save_info,
                                       started_callback));

  if (!request_context->job_factory()->IsHandledURL(url)) {
    VLOG(1) << "Download request for unsupported protocol: "
            << url.possibly_invalid_spec();
    return net::ERR_ACCESS_DENIED;
  }

  ResourceRequestInfoImpl* extra_info =
      CreateRequestInfo(handler, child_id, route_id, true, context);
  extra_info->AssociateWithRequest(request.get());  // Request takes ownership.

  request->set_delegate(this);
  BeginRequestInternal(request.release());

  return net::OK;
}

void ResourceDispatcherHostImpl::NotifyResponseStarted(net::URLRequest* request,
                                                       int child_id) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));

  int render_process_id, render_view_id;
  if (!RenderViewForRequest(request, &render_process_id, &render_view_id))
    return;

  ResourceRequestDetails* detail = new ResourceRequestDetails(
      request, GetCertID(request, child_id));
  BrowserThread::PostTask(
      BrowserThread::UI, FROM_HERE,
      base::Bind(
          &ResourceDispatcherHostImpl::NotifyOnUI<ResourceRequestDetails>,
          static_cast<int>(NOTIFICATION_RESOURCE_RESPONSE_STARTED),
          render_process_id, render_view_id, detail));
}

void SSLErrorHandler::TakeNoAction() {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  BrowserThread::PostTask(
      BrowserThread::IO, FROM_HERE,
      base::Bind(&SSLErrorHandler::CompleteTakeNoAction, this));
}

SocketStreamDispatcherHost::~SocketStreamDispatcherHost() {
  for (IDMap<SocketStreamHost>::const_iterator iter(&hosts_);
       !iter.IsAtEnd();
       iter.Advance()) {
    int socket_id = iter.GetCurrentKey();
    const SocketStreamHost* socket_stream_host = iter.GetCurrentValue();
    delete socket_stream_host;
    hosts_.Remove(socket_id);
  }
}

ResourceDispatcherHostImpl::ResourceDispatcherHostImpl()
: download_file_manager_(new DownloadFileManager(NULL)),
save_file_manager_(new SaveFileManager()),
request_id_(-1),
      ALLOW_THIS_IN_INITIALIZER_LIST(weak_factory_(this)),
      ALLOW_THIS_IN_INITIALIZER_LIST(ssl_delegate_weak_factory_(this)),
is_shutdown_(false),
max_outstanding_requests_cost_per_process_(
kMaxOutstandingRequestsCostPerProcess),
filter_(NULL),
delegate_(NULL),
allow_cross_origin_auth_prompt_(false) {
DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
DCHECK(!g_resource_dispatcher_host);
g_resource_dispatcher_host = this;

GetContentClient()->browser()->ResourceDispatcherHostCreated();

ANNOTATE_BENIGN_RACE(
&last_user_gesture_time_,
"We don't care about the precise value, see http://crbug.com/92889");

BrowserThread::PostTask(
BrowserThread::IO, FROM_HERE,
base::Bind(&appcache::AppCacheInterceptor::EnsureRegistered));

update_load_states_timer_.reset(
new base::RepeatingTimer<ResourceDispatcherHostImpl>());
}

void ResourceDispatcherHostImpl::CancelRequestsForContext(
    ResourceContext* context) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));
  DCHECK(context);

  CHECK(ContainsKey(active_resource_contexts_, context));

  std::vector<net::URLRequest*> requests_to_cancel;
  for (PendingRequestList::iterator i = pending_requests_.begin();
       i != pending_requests_.end();) {
    ResourceRequestInfoImpl* info =
        ResourceRequestInfoImpl::ForRequest(i->second);
    if (info->GetContext() == context) {
      requests_to_cancel.push_back(i->second);
      pending_requests_.erase(i++);
    } else {
      ++i;
    }
  }

  for (BlockedRequestMap::iterator i = blocked_requests_map_.begin();
       i != blocked_requests_map_.end();) {
    BlockedRequestsList* requests = i->second;
    if (requests->empty()) {
      ++i;
      continue;
    }
    ResourceRequestInfoImpl* info =
        ResourceRequestInfoImpl::ForRequest(requests->front());
    if (info->GetContext() == context) {
      blocked_requests_map_.erase(i++);
      for (BlockedRequestsList::const_iterator it = requests->begin();
           it != requests->end(); ++it) {
        net::URLRequest* request = *it;
        info = ResourceRequestInfoImpl::ForRequest(request);
        DCHECK_EQ(context, info->GetContext());
        IncrementOutstandingRequestsMemoryCost(-1 * info->memory_cost(),
                                               info->GetChildID());
        requests_to_cancel.push_back(request);
      }
      delete requests;
    } else {
      ++i;
    }
  }

  for (std::vector<net::URLRequest*>::iterator i = requests_to_cancel.begin();
       i != requests_to_cancel.end(); ++i) {
    net::URLRequest* request = *i;
    ResourceRequestInfoImpl* info =
        ResourceRequestInfoImpl::ForRequest(request);
    GlobalRequestID request_id(info->GetChildID(), info->GetRequestID());
    bool is_transferred = IsTransferredNavigation(request_id);
    DCHECK(info->is_download() || is_transferred);
    if (is_transferred)
      transferred_navigations_.erase(request_id);
    delete request;
  }

  for (PendingRequestList::const_iterator i = pending_requests_.begin();
       i != pending_requests_.end(); ++i) {
    ResourceRequestInfoImpl* info =
        ResourceRequestInfoImpl::ForRequest(i->second);
    CHECK_NE(info->GetContext(), context);
  }

  for (BlockedRequestMap::const_iterator i = blocked_requests_map_.begin();
       i != blocked_requests_map_.end(); ++i) {
    BlockedRequestsList* requests = i->second;
    if (!requests->empty()) {
      ResourceRequestInfoImpl* info =
          ResourceRequestInfoImpl::ForRequest(requests->front());
      CHECK_NE(info->GetContext(), context);
    }
  }
}

SSLCertErrorHandler* SSLCertErrorHandler::AsSSLCertErrorHandler() {
  return this;
}

bool SocketStreamDispatcherHost::CanSetCookie(net::SocketStream* request,
                                              const GURL& url,
                                              const std::string& cookie_line,
                                              net::CookieOptions* options) {
  return content::GetContentClient()->browser()->AllowSetCookie(
      url, url, cookie_line, resource_context_, 0, MSG_ROUTING_NONE, options);
}

 void ResourceDispatcherHostImpl::OnResponseStarted(net::URLRequest* request) {
  VLOG(1) << "OnResponseStarted: " << request->url().spec();
  ResourceRequestInfoImpl* info = ResourceRequestInfoImpl::ForRequest(request);

  if (request->status().is_success()) {
    if (PauseRequestIfNeeded(info)) {
      VLOG(1) << "OnResponseStarted pausing: " << request->url().spec();
      return;
    }

    info->set_waiting_for_upload_progress_ack(false);
    MaybeUpdateUploadProgress(info, request);

    if (!CompleteResponseStarted(request)) {
      CancelRequestInternal(request, false);
    } else {
      if (PauseRequestIfNeeded(info)) {
        VLOG(1) << "OnResponseStarted pausing2: " << request->url().spec();
        return;
      }

      StartReading(request);
    }
  } else {
    ResponseCompleted(request);
  }
}

SSLManager::SSLManager(NavigationControllerImpl* controller)
    : backend_(controller),
      policy_(new SSLPolicy(&backend_)),
      controller_(controller) {
  DCHECK(controller_);

  registrar_.Add(
      this, content::NOTIFICATION_RESOURCE_RESPONSE_STARTED,
      content::Source<WebContents>(controller_->web_contents()));
  registrar_.Add(
      this, content::NOTIFICATION_RESOURCE_RECEIVED_REDIRECT,
      content::Source<WebContents>(controller_->web_contents()));
  registrar_.Add(
      this, content::NOTIFICATION_LOAD_FROM_MEMORY_CACHE,
      content::Source<NavigationController>(controller_));
  registrar_.Add(
      this, content::NOTIFICATION_SSL_INTERNAL_STATE_CHANGED,
      content::Source<content::BrowserContext>(
          controller_->GetBrowserContext()));
}

void SocketStreamDispatcherHost::CancelSSLRequest(
    const content::GlobalRequestID& id,
    int error,
    const net::SSLInfo* ssl_info) {
  int socket_id = id.request_id;
  DVLOG(1) << "SocketStreamDispatcherHost::CancelSSLRequest socket_id="
           << socket_id;
  DCHECK_NE(content::kNoSocketId, socket_id);
  SocketStreamHost* socket_stream_host = hosts_.Lookup(socket_id);
  DCHECK(socket_stream_host);
  if (ssl_info)
    socket_stream_host->CancelWithSSLError(*ssl_info);
  else
    socket_stream_host->CancelWithError(error);
}

void SSLErrorHandler::OnDispatched() {
  TakeNoAction();
}

void ResourceDispatcherHostImpl::NotifyReceivedRedirect(
    net::URLRequest* request,
    int child_id,
    const GURL& new_url) {
  int render_process_id, render_view_id;
  if (!RenderViewForRequest(request, &render_process_id, &render_view_id))
    return;

  ResourceRedirectDetails* detail = new ResourceRedirectDetails(
      request, GetCertID(request, child_id), new_url);
  BrowserThread::PostTask(
      BrowserThread::UI, FROM_HERE,
      base::Bind(
          &ResourceDispatcherHostImpl::NotifyOnUI<ResourceRedirectDetails>,
          static_cast<int>(NOTIFICATION_RESOURCE_RECEIVED_REDIRECT),
          render_process_id, render_view_id, detail));
}

SSLErrorHandler::~SSLErrorHandler() {}

void ResourceDispatcherHostImpl::ResumeDeferredRequest(int child_id,
                                                       int request_id) {
  PauseRequest(child_id, request_id, false);
}

void ResourceDispatcherHostImpl::ResponseCompleted(net::URLRequest* request) {
  VLOG(1) << "ResponseCompleted: " << request->url().spec();
  ResourceRequestInfoImpl* info = ResourceRequestInfoImpl::ForRequest(request);

  if (info->GetResourceType() == ResourceType::MAIN_FRAME) {
    UMA_HISTOGRAM_CUSTOM_ENUMERATION(
        "Net.ErrorCodesForMainFrame3",
        -request->status().error(),
        base::CustomHistogram::ArrayToCustomRanges(
            kAllNetErrorCodes, arraysize(kAllNetErrorCodes)));

    if (request->url().SchemeIsSecure() &&
        request->url().host() == "www.google.com") {
      UMA_HISTOGRAM_CUSTOM_ENUMERATION(
          "Net.ErrorCodesForHTTPSGoogleMainFrame2",
          -request->status().error(),
          base::CustomHistogram::ArrayToCustomRanges(
              kAllNetErrorCodes, arraysize(kAllNetErrorCodes)));
    }
  } else {
    UMA_HISTOGRAM_CUSTOM_ENUMERATION(
        "Net.ErrorCodesForSubresources2",
        -request->status().error(),
        base::CustomHistogram::ArrayToCustomRanges(
            kAllNetErrorCodes, arraysize(kAllNetErrorCodes)));
  }

  std::string security_info;
  const net::SSLInfo& ssl_info = request->ssl_info();
  if (ssl_info.cert != NULL) {
    int cert_id = CertStore::GetInstance()->StoreCert(ssl_info.cert,
                                                      info->GetChildID());
    security_info = SerializeSecurityInfo(
        cert_id, ssl_info.cert_status, ssl_info.security_bits,
        ssl_info.connection_status);
  }

  if (info->resource_handler()->OnResponseCompleted(info->GetRequestID(),
                                                    request->status(),
                                                    security_info)) {

    RemovePendingRequest(info->GetChildID(), info->GetRequestID());
  }
}

void SSLManager::DidStartResourceResponse(ResourceRequestDetails* details) {
  scoped_refptr<SSLRequestInfo> info(new SSLRequestInfo(
      details->url,
      details->resource_type,
      details->origin_child_id,
      details->ssl_cert_id,
      details->ssl_cert_status));

  policy()->OnRequestStarted(info.get());
}

static int GetCertID(net::URLRequest* request, int child_id) {
  if (request->ssl_info().cert) {
    return CertStore::GetInstance()->StoreCert(request->ssl_info().cert,
                                               child_id);
  }
  return 0;
}

net::URLRequest* ResourceDispatcherHostImpl::GetURLRequest(
    const GlobalRequestID& request_id) const {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));

  PendingRequestList::const_iterator i = pending_requests_.find(request_id);
  if (i == pending_requests_.end())
    return NULL;

  return i->second;
}

void ResourceDispatcherHostImpl::BlockRequestsForRoute(int child_id,
                                                       int route_id) {
  std::pair<int, int> key(child_id, route_id);
  DCHECK(blocked_requests_map_.find(key) == blocked_requests_map_.end()) <<
      "BlockRequestsForRoute called  multiple time for the same RVH";
  blocked_requests_map_[key] = new BlockedRequestsList();
}

bool ResourceDispatcherHostImpl::HandleExternalProtocol(
    int request_id,
    int child_id,
    int route_id,
    const GURL& url,
    ResourceType::Type type,
    const net::URLRequestJobFactory& job_factory,
    ResourceHandler* handler) {
  if (!ResourceType::IsFrame(type) ||
      job_factory.IsHandledURL(url)) {
    return false;
  }

  if (delegate_)
    delegate_->HandleExternalProtocol(url, child_id, route_id);

  handler->OnResponseCompleted(
      request_id,
      net::URLRequestStatus(net::URLRequestStatus::FAILED,
                            net::ERR_UNKNOWN_URL_SCHEME),
      std::string());  // No security info necessary.
  return true;
}

void ResourceDispatcherHostImpl::ContinueSSLRequest(
    const GlobalRequestID& id) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));
  net::URLRequest* request = GetURLRequest(id);
  if (!request)
    return;
  DVLOG(1) << "ContinueSSLRequest() url: " << request->url().spec();
  request->ContinueDespiteLastError();
}

void ResourceDispatcherHostImpl::MaybeUpdateUploadProgress(
    ResourceRequestInfoImpl *info,
    net::URLRequest *request) {

  if (!info->GetUploadSize() || info->waiting_for_upload_progress_ack())
    return;

  uint64 size = info->GetUploadSize();
  uint64 position = request->GetUploadProgress();
  if (position == info->last_upload_position())
    return;  // no progress made since last time

  const uint64 kHalfPercentIncrements = 200;
  const TimeDelta kOneSecond = TimeDelta::FromMilliseconds(1000);

  uint64 amt_since_last = position - info->last_upload_position();
  TimeDelta time_since_last = TimeTicks::Now() - info->last_upload_ticks();

  bool is_finished = (size == position);
  bool enough_new_progress = (amt_since_last > (size / kHalfPercentIncrements));
  bool too_much_time_passed = time_since_last > kOneSecond;

  if (is_finished || enough_new_progress || too_much_time_passed) {
    if (request->load_flags() & net::LOAD_ENABLE_UPLOAD_PROGRESS) {
      info->resource_handler()->OnUploadProgress(info->GetRequestID(),
                                                 position, size);
      info->set_waiting_for_upload_progress_ack(true);
    }
    info->set_last_upload_ticks(TimeTicks::Now());
    info->set_last_upload_position(position);
  }
}

void ResourceDispatcherHostImpl::OnReadCompleted(net::URLRequest* request,
int bytes_read) {
DCHECK(request);
VLOG(1) << "OnReadCompleted: \"" << request->url().spec() << "\""
<< " bytes_read = " << bytes_read;
ResourceRequestInfoImpl* info = ResourceRequestInfoImpl::ForRequest(request);

// bytes_read == -1 always implies an error, so we want to skip the pause
// checks and just call ResponseCompleted.
if (bytes_read == -1) {
DCHECK(!request->status().is_success());

ResponseCompleted(request);
return;
}

// OnReadCompleted can be called without Read (e.g., for chrome:// URLs).
// Make sure we know that a read has begun.
info->set_has_started_reading(true);

if (PauseRequestIfNeeded(info)) {
info->set_paused_read_bytes(bytes_read);
VLOG(1) << "OnReadCompleted pausing: \"" << request->url().spec() << "\""
<< " bytes_read = " << bytes_read;
return;
}

if (request->status().is_success() && CompleteRead(request, &bytes_read)) {
// The request can be paused if we realize that the renderer is not
// servicing messages fast enough.
if (info->pause_count() == 0 &&
Read(request, &bytes_read) &&
request->status().is_success()) {
if (bytes_read == 0) {
CompleteRead(request, &bytes_read);
} else {
// Force the next CompleteRead / Read pair to run as a separate task.
// This avoids a fast, large network request from monopolizing the IO
// thread and starving other IO operations from running.
VLOG(1) << "OnReadCompleted postponing: \""
<< request->url().spec() << "\""
<< " bytes_read = " << bytes_read;
info->set_paused_read_bytes(bytes_read);
info->set_is_paused(true);
GlobalRequestID id(info->GetChildID(), info->GetRequestID());
MessageLoop::current()->PostTask(
FROM_HERE,
            base::Bind(
                &ResourceDispatcherHostImpl::ResumeRequest,
                weak_factory_.GetWeakPtr(), id));
return;
}
}
}

if (PauseRequestIfNeeded(info)) {
info->set_paused_read_bytes(bytes_read);
VLOG(1) << "OnReadCompleted (CompleteRead) pausing: \""
<< request->url().spec() << "\""
<< " bytes_read = " << bytes_read;
return;
}

// If the status is not IO pending then we've either finished (success) or we
// had an error.  Either way, we're done!
if (!request->status().is_io_pending())
ResponseCompleted(request);
}

void ResourceDispatcherHostImpl::StartReading(net::URLRequest* request) {
  int bytes_read = 0;
  if (Read(request, &bytes_read)) {
    OnReadCompleted(request, bytes_read);
  } else if (!request->status().is_io_pending()) {
    DCHECK(!ResourceRequestInfoImpl::ForRequest(request)->is_paused());
    ResponseCompleted(request);
  }
}

void ResourceDispatcherHostImpl::NotifyOnUI(int type,
                                            int render_process_id,
                                            int render_view_id,
                                            T* detail) {
  RenderViewHostImpl* rvh =
      RenderViewHostImpl::FromID(render_process_id, render_view_id);
  if (rvh) {
    RenderViewHostDelegate* rvhd = rvh->GetDelegate();
    NotificationService::current()->Notify(
        type, Source<WebContents>(rvhd->GetAsWebContents()),
        Details<T>(detail));
  }
  delete detail;
}

void ResourceDispatcherHostImpl::CancelRequestsForRoute(int child_id,
                                                        int route_id) {

  std::vector<GlobalRequestID> matching_requests;
  for (PendingRequestList::const_iterator i = pending_requests_.begin();
       i != pending_requests_.end(); ++i) {
    if (i->first.child_id == child_id) {
      ResourceRequestInfoImpl* info =
          ResourceRequestInfoImpl::ForRequest(i->second);
      GlobalRequestID id(child_id, i->first.request_id);
      DCHECK(id == i->first);
      if (!info->is_download() &&
          (transferred_navigations_.find(id) ==
               transferred_navigations_.end()) &&
          (route_id == -1 || route_id == info->GetRouteID())) {
        matching_requests.push_back(
            GlobalRequestID(child_id, i->first.request_id));
      }
    }
  }

  for (size_t i = 0; i < matching_requests.size(); ++i) {
    PendingRequestList::iterator iter =
        pending_requests_.find(matching_requests[i]);
    if (iter != pending_requests_.end())
      RemovePendingRequest(iter);
  }

  if (route_id != -1) {
    if (blocked_requests_map_.find(std::pair<int, int>(child_id, route_id)) !=
        blocked_requests_map_.end()) {
      CancelBlockedRequestsForRoute(child_id, route_id);
    }
  } else {
    std::set<int> route_ids;
    for (BlockedRequestMap::const_iterator iter = blocked_requests_map_.begin();
         iter != blocked_requests_map_.end(); ++iter) {
      if (iter->first.first == child_id)
        route_ids.insert(iter->first.second);
    }
    for (std::set<int>::const_iterator iter = route_ids.begin();
        iter != route_ids.end(); ++iter) {
      CancelBlockedRequestsForRoute(child_id, *iter);
    }
  }
}

void SSLErrorHandler::CompleteCancelRequest(int error) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));

  DCHECK(!request_has_been_notified_);
  if (request_has_been_notified_)
    return;

  SSLCertErrorHandler* cert_error = AsSSLCertErrorHandler();
  const SSLInfo* ssl_info = NULL;
  if (cert_error)
    ssl_info = &cert_error->ssl_info();
  if (delegate_)
    delegate_->CancelSSLRequest(request_id_, error, ssl_info);
  request_has_been_notified_ = true;

  Release();
}

void SocketStreamDispatcherHost::OnConnected(net::SocketStream* socket,
                                             int max_pending_send_allowed) {
  int socket_id = SocketStreamHost::SocketIdFromSocketStream(socket);
  DVLOG(1) << "SocketStreamDispatcherHost::OnConnected socket_id=" << socket_id
           << " max_pending_send_allowed=" << max_pending_send_allowed;
  if (socket_id == content::kNoSocketId) {
    LOG(ERROR) << "NoSocketId in OnConnected";
    return;
  }
  if (!Send(new SocketStreamMsg_Connected(
          socket_id, max_pending_send_allowed))) {
    LOG(ERROR) << "SocketStreamMsg_Connected failed.";
    DeleteSocketStreamHost(socket_id);
  }
}

void ResourceDispatcherHostImpl::CancelSSLRequest(
    const GlobalRequestID& id,
    int error,
    const net::SSLInfo* ssl_info) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));
  net::URLRequest* request = GetURLRequest(id);
  if (!request || !request->is_pending())
    return;
  DVLOG(1) << "CancelSSLRequest() url: " << request->url().spec();
  if (ssl_info)
    request->CancelWithSSLError(error, *ssl_info);
  else
    request->CancelWithError(error);
}

void ResourceDispatcherHostImpl::BeginSaveFile(
    const GURL& url,
    const content::Referrer& referrer,
    int child_id,
    int route_id,
    ResourceContext* context) {
  if (is_shutdown_)
    return;

  char url_buf[128];
  base::strlcpy(url_buf, url.spec().c_str(), arraysize(url_buf));
  base::debug::Alias(url_buf);
  CHECK(ContainsKey(active_resource_contexts_, context));

  scoped_refptr<ResourceHandler> handler(
      new SaveFileResourceHandler(child_id,
                                  route_id,
                                  url,
                                  save_file_manager_.get()));
  request_id_--;

  const net::URLRequestContext* request_context = context->GetRequestContext();
  bool known_proto =
      request_context->job_factory()->IsHandledURL(url);
  if (!known_proto) {
    NOTREACHED();
    return;
  }

  net::URLRequest* request = new net::URLRequest(url, this);
  request->set_method("GET");
  request->set_referrer(MaybeStripReferrer(referrer.url).spec());
  webkit_glue::ConfigureURLRequestForReferrerPolicy(request, referrer.policy);
  request->set_load_flags(net::LOAD_PREFERRING_CACHE);
  request->set_context(context->GetRequestContext());

  ResourceRequestInfoImpl* extra_info =
      CreateRequestInfo(handler, child_id, route_id, false, context);
  extra_info->AssociateWithRequest(request);  // Request takes ownership.

  BeginRequestInternal(request);
}

bool ResourceDispatcherHostImpl::OnMessageReceived(
    const IPC::Message& message,
    ResourceMessageFilter* filter,
    bool* message_was_ok) {
  filter_ = filter;
  bool handled = true;
  IPC_BEGIN_MESSAGE_MAP_EX(ResourceDispatcherHostImpl, message, *message_was_ok)
    IPC_MESSAGE_HANDLER(ResourceHostMsg_RequestResource, OnRequestResource)
    IPC_MESSAGE_HANDLER_DELAY_REPLY(ResourceHostMsg_SyncLoad, OnSyncLoad)
    IPC_MESSAGE_HANDLER(ResourceHostMsg_ReleaseDownloadedFile,
                        OnReleaseDownloadedFile)
    IPC_MESSAGE_HANDLER(ResourceHostMsg_DataReceived_ACK, OnDataReceivedACK)
    IPC_MESSAGE_HANDLER(ResourceHostMsg_DataDownloaded_ACK, OnDataDownloadedACK)
    IPC_MESSAGE_HANDLER(ResourceHostMsg_UploadProgress_ACK, OnUploadProgressACK)
    IPC_MESSAGE_HANDLER(ResourceHostMsg_CancelRequest, OnCancelRequest)
    IPC_MESSAGE_HANDLER(ResourceHostMsg_TransferRequestToNewPage,
                        OnTransferRequestToNewPage)
    IPC_MESSAGE_HANDLER(ResourceHostMsg_FollowRedirect, OnFollowRedirect)
    IPC_MESSAGE_HANDLER(ViewHostMsg_SwapOut_ACK, OnSwapOutACK)
    IPC_MESSAGE_HANDLER(ViewHostMsg_DidLoadResourceFromMemoryCache,
                        OnDidLoadResourceFromMemoryCache)
    IPC_MESSAGE_UNHANDLED(handled = false)
  IPC_END_MESSAGE_MAP_EX()

  if (message.type() == ViewHostMsg_DidLoadResourceFromMemoryCache::ID) {
    handled = false;
  }

  filter_ = NULL;
  return handled;
}

void SSLManager::DidReceiveResourceRedirect(ResourceRedirectDetails* details) {
}

bool ResourceDispatcherHostImpl::WillSendData(int child_id,
                                              int request_id) {
  PendingRequestList::iterator i = pending_requests_.find(
      GlobalRequestID(child_id, request_id));
  if (i == pending_requests_.end()) {
    NOTREACHED() << "WillSendData for invalid request";
    return false;
  }

  ResourceRequestInfoImpl* info =
      ResourceRequestInfoImpl::ForRequest(i->second);

  info->IncrementPendingDataCount();
  if (info->pending_data_count() > kMaxPendingDataMessages) {
    PauseRequest(child_id, request_id, true);
    return false;
  }

  return true;
}

void SSLErrorHandler::OnDispatchFailed() {
  TakeNoAction();
}

void ResourceDispatcherHostImpl::ResumeRequest(
    const GlobalRequestID& request_id) {
  PendingRequestList::iterator i = pending_requests_.find(request_id);
  if (i == pending_requests_.end())  // The request may have been destroyed
    return;

  net::URLRequest* request = i->second;
  ResourceRequestInfoImpl* info = ResourceRequestInfoImpl::ForRequest(request);

  if (!info->is_paused())
    return;
  info->set_is_paused(false);
  if (PauseRequestIfNeeded(info))
    return;

  VLOG(1) << "Resuming: \"" << i->second->url().spec() << "\""
          << " paused_read_bytes = " << info->paused_read_bytes()
          << " called response started = " << info->called_on_response_started()
          << " started reading = " << info->has_started_reading();

  if (info->called_on_response_started()) {
    if (info->has_started_reading()) {
      OnReadCompleted(i->second, info->paused_read_bytes());
    } else {
      StartReading(request);
    }
  } else {
    OnResponseStarted(i->second);
  }
}

void SSLErrorHandler::ContinueRequest() {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  BrowserThread::PostTask(
      BrowserThread::IO, FROM_HERE,
      base::Bind(&SSLErrorHandler::CompleteContinueRequest, this));
}

void SSLCertErrorHandler::OnDispatchFailed() {
  if (net::IsCertStatusMinorError(ssl_info().cert_status)) {
    ContinueRequest();
  } else {
    CancelRequest();
  }
}

void SSLErrorHandler::CompleteContinueRequest() {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));

  DCHECK(!request_has_been_notified_);
  if (request_has_been_notified_)
    return;

  if (delegate_)
    delegate_->ContinueSSLRequest(request_id_);
  request_has_been_notified_ = true;

  Release();
}

ResourceDispatcherHostImpl::~ResourceDispatcherHostImpl() {
  DCHECK(g_resource_dispatcher_host);
  g_resource_dispatcher_host = NULL;
  AsyncResourceHandler::GlobalCleanup();
  for (PendingRequestList::const_iterator i = pending_requests_.begin();
       i != pending_requests_.end(); ++i) {
    transferred_navigations_.erase(i->first);
  }
  STLDeleteValues(&pending_requests_);
  DCHECK(transferred_navigations_.empty());
}

void PopulateResourceResponse(net::URLRequest* request,
                              ResourceResponse* response) {
  response->status = request->status();
  response->request_time = request->request_time();
  response->response_time = request->response_time();
  response->headers = request->response_headers();
  request->GetCharset(&response->charset);
  response->content_length = request->GetExpectedContentSize();
  request->GetMimeType(&response->mime_type);
  net::HttpResponseInfo response_info = request->response_info();
  response->was_fetched_via_spdy = response_info.was_fetched_via_spdy;
  response->was_npn_negotiated = response_info.was_npn_negotiated;
  response->npn_negotiated_protocol = response_info.npn_negotiated_protocol;
  response->was_fetched_via_proxy = request->was_fetched_via_proxy();
  response->socket_address = request->GetSocketAddress();
  appcache::AppCacheInterceptor::GetExtraResponseInfo(
      request,
      &response->appcache_id,
      &response->appcache_manifest_url);
}

SSLManager::~SSLManager() {
}

void ResourceDispatcherHostImpl::BeginRequest(
    int request_id,
    const ResourceHostMsg_Request& request_data,
    IPC::Message* sync_result,  // only valid for sync
    int route_id) {
  ProcessType process_type = filter_->process_type();
  int child_id = filter_->child_id();

  char url_buf[128];
  base::strlcpy(url_buf, request_data.url.spec().c_str(), arraysize(url_buf));
  base::debug::Alias(url_buf);

  net::URLRequest* deferred_request = NULL;

  GlobalRequestID old_request_id(request_data.transferred_request_child_id,
                                 request_data.transferred_request_request_id);
  TransferredNavigations::iterator iter =
      transferred_navigations_.find(old_request_id);
  if (iter != transferred_navigations_.end()) {
    deferred_request = iter->second;
    pending_requests_.erase(old_request_id);
    transferred_navigations_.erase(iter);
  }

  ResourceContext* resource_context = filter_->resource_context();
  CHECK(ContainsKey(active_resource_contexts_, resource_context));

  if (request_data.upload_data) {
    GetBlobStorageControllerForResourceContext(resource_context)->
        ResolveBlobReferencesInUploadData(request_data.upload_data.get());
  }

  if (is_shutdown_ ||
      !ShouldServiceRequest(process_type, child_id, request_data)) {
    AbortRequestBeforeItStarts(filter_, sync_result, route_id, request_id);
    return;
  }

  const Referrer referrer(MaybeStripReferrer(request_data.referrer),
                          request_data.referrer_policy);

  if (delegate_ && !delegate_->ShouldBeginRequest(child_id,
                                                  route_id,
                                                  request_data.method,
                                                  request_data.url,
                                                  request_data.resource_type,
                                                  resource_context,
                                                  referrer)) {
    AbortRequestBeforeItStarts(filter_, sync_result, route_id, request_id);
    return;
  }

  scoped_refptr<ResourceHandler> handler;
  if (sync_result) {
    handler = new SyncResourceHandler(
        filter_, request_data.url, sync_result, this);
  } else {
    handler = new AsyncResourceHandler(
        filter_, route_id, request_data.url, this);
  }

  if (request_data.download_to_file)
    handler = new RedirectToFileResourceHandler(handler, child_id, this);

  if (HandleExternalProtocol(
      request_id, child_id, route_id, request_data.url,
      request_data.resource_type,
      *resource_context->GetRequestContext()->job_factory(), handler)) {
    return;
  }

  net::URLRequest* request;
  if (deferred_request) {
    request = deferred_request;
  } else {
    request = new net::URLRequest(request_data.url, this);
    request->set_method(request_data.method);
    request->set_first_party_for_cookies(request_data.first_party_for_cookies);
    request->set_referrer(referrer.url.spec());
    webkit_glue::ConfigureURLRequestForReferrerPolicy(request, referrer.policy);
    net::HttpRequestHeaders headers;
    headers.AddHeadersFromString(request_data.headers);
    request->SetExtraRequestHeaders(headers);
  }

  int load_flags = request_data.load_flags;
  load_flags |= net::LOAD_VERIFY_EV_CERT;
  if (request_data.resource_type == ResourceType::MAIN_FRAME) {
    load_flags |= net::LOAD_MAIN_FRAME;
  } else if (request_data.resource_type == ResourceType::SUB_FRAME) {
    load_flags |= net::LOAD_SUB_FRAME;
  } else if (request_data.resource_type == ResourceType::PREFETCH) {
    load_flags |= (net::LOAD_PREFETCH | net::LOAD_DO_NOT_PROMPT_FOR_LOGIN);
  } else if (request_data.resource_type == ResourceType::FAVICON) {
    load_flags |= net::LOAD_DO_NOT_PROMPT_FOR_LOGIN;
  }

  if (sync_result)
    load_flags |= net::LOAD_IGNORE_LIMITS;

  ChildProcessSecurityPolicyImpl* policy =
      ChildProcessSecurityPolicyImpl::GetInstance();
  if (!policy->CanUseCookiesForOrigin(child_id, request_data.url)) {
    load_flags |= (net::LOAD_DO_NOT_SEND_COOKIES |
                   net::LOAD_DO_NOT_SEND_AUTH_DATA |
                   net::LOAD_DO_NOT_SAVE_COOKIES);
  }

  if ((load_flags & net::LOAD_REPORT_RAW_HEADERS)
      && !policy->CanReadRawCookies(child_id)) {
    VLOG(1) << "Denied unauthorized request for raw headers";
    load_flags &= ~net::LOAD_REPORT_RAW_HEADERS;
  }

  request->set_load_flags(load_flags);

  request->set_context(
      filter_->GetURLRequestContext(request_data.resource_type));
  request->set_priority(DetermineRequestPriority(request_data.resource_type));

  uint64 upload_size = 0;
  if (request_data.upload_data) {
    request->set_upload(request_data.upload_data);
    base::ThreadRestrictions::ScopedAllowIO allow_io;
    upload_size = request_data.upload_data->GetContentLengthSync();
  }

  if (request_data.resource_type == ResourceType::MAIN_FRAME &&
      process_type == PROCESS_TYPE_RENDERER &&
      CrossSiteRequestManager::GetInstance()->
          HasPendingCrossSiteRequest(child_id, route_id)) {
    handler = new CrossSiteResourceHandler(handler, child_id, route_id, this);
  }

  handler = new BufferedResourceHandler(handler, this, request);

  ScopedVector<ResourceThrottle> throttles;
  if (delegate_) {
    bool is_continuation_of_transferred_request =
        (deferred_request != NULL);

    delegate_->RequestBeginning(request,
                                resource_context,
                                request_data.resource_type,
                                child_id,
                                route_id,
                                is_continuation_of_transferred_request,
                                &throttles);
  }

  if (request_data.resource_type == ResourceType::MAIN_FRAME) {
    throttles.insert(
        throttles.begin(), new TransferNavigationResourceThrottle(request));
  }

  if (!throttles.empty()) {
    handler = new ThrottlingResourceHandler(this, handler, child_id, request_id,
                                            throttles.Pass());
  }

  bool allow_download = request_data.allow_download &&
      ResourceType::IsFrame(request_data.resource_type);
  ResourceRequestInfoImpl* extra_info =
      new ResourceRequestInfoImpl(
          handler,
          process_type,
          child_id,
          route_id,
          request_data.origin_pid,
          request_id,
          request_data.is_main_frame,
          request_data.frame_id,
          request_data.parent_is_main_frame,
          request_data.parent_frame_id,
          request_data.resource_type,
          request_data.transition_type,
          upload_size,
          false,  // is download
          allow_download,
          request_data.has_user_gesture,
          request_data.referrer_policy,
          resource_context);
  extra_info->AssociateWithRequest(request);  // Request takes ownership.

  if (request->url().SchemeIs(chrome::kBlobScheme)) {
    webkit_blob::BlobStorageController* controller =
        GetBlobStorageControllerForResourceContext(resource_context);
    extra_info->set_requested_blob_data(
        controller->GetBlobDataFromUrl(request->url()));
  }

  appcache::AppCacheInterceptor::SetExtraRequestInfo(
      request, ResourceContext::GetAppCacheService(resource_context), child_id,
      request_data.appcache_host_id, request_data.resource_type);

  if (deferred_request) {
    GlobalRequestID global_id(extra_info->GetChildID(),
                              extra_info->GetRequestID());
    pending_requests_[global_id] = request;
    request->FollowDeferredRedirect();
  } else {
    BeginRequestInternal(request);
  }
}

void SSLManager::DidCommitProvisionalLoad(
    const content::NotificationDetails& in_details) {
  content::LoadCommittedDetails* details =
      content::Details<content::LoadCommittedDetails>(in_details).ptr();

  NavigationEntryImpl* entry =
      NavigationEntryImpl::FromNavigationEntry(controller_->GetActiveEntry());

  if (details->is_main_frame) {
    if (entry) {
      int ssl_cert_id;
      net::CertStatus ssl_cert_status;
      int ssl_security_bits;
      int ssl_connection_status;
      content::DeserializeSecurityInfo(details->serialized_security_info,
                                       &ssl_cert_id,
                                       &ssl_cert_status,
                                       &ssl_security_bits,
                                       &ssl_connection_status);

      entry->GetSSL() = SSLStatus();
      entry->GetSSL().cert_id = ssl_cert_id;
      entry->GetSSL().cert_status = ssl_cert_status;
      entry->GetSSL().security_bits = ssl_security_bits;
      entry->GetSSL().connection_status = ssl_connection_status;
    }
  }

  UpdateEntry(entry);
}

void ResourceDispatcherHostImpl::StartRequest(net::URLRequest* request) {
  request->Start();

  if (!update_load_states_timer_->IsRunning()) {
    update_load_states_timer_->Start(FROM_HERE,
        TimeDelta::FromMilliseconds(kUpdateLoadStatesIntervalMsec),
        this, &ResourceDispatcherHostImpl::UpdateLoadStates);
  }
}

void ResourceDispatcherHostImpl::CancelRequest(int child_id,
                                               int request_id,
                                               bool from_renderer) {
  GlobalRequestID id(child_id, request_id);
  if (from_renderer) {
    if (transferred_navigations_.find(id) != transferred_navigations_.end())
      return;
  }

  PendingRequestList::iterator i = pending_requests_.find(id);
  if (i == pending_requests_.end()) {
    DVLOG(1) << "Canceling a request that wasn't found";
    return;
  }
  net::URLRequest* request = i->second;

  bool started_before_cancel = request->is_pending();
  if (CancelRequestInternal(request, from_renderer) &&
      !started_before_cancel) {
    MessageLoop::current()->PostTask(
        FROM_HERE,
        base::Bind(&ResourceDispatcherHostImpl::CallResponseCompleted,
                   base::Unretained(this),
                   child_id,
                   request_id));
  }
}
