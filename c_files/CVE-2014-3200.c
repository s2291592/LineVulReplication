TemplateURLRef::SearchTermsArgs::SearchTermsArgs(
    const base::string16& search_terms)
    : search_terms(search_terms),
      input_type(metrics::OmniboxInputType::INVALID),
      accepted_suggestion(NO_SUGGESTIONS_AVAILABLE),
      cursor_position(base::string16::npos),
      page_classification(metrics::OmniboxEventProto::INVALID_SPEC),
      append_extra_query_params(false),
      force_instant_results(false),
      from_app_list(false),
      contextual_search_params(ContextualSearchParams()) {}

void TemplateURL::SetURL(const std::string& url) {
  data_.SetURL(url);
  engine_type_ = SEARCH_ENGINE_UNKNOWN;
  url_ref_->InvalidateCachedValues();
}

  void recordSurroundingText(const std::string& after_text) {
    after_text_ = after_text;
  }

 bool ContextualSearchFieldTrial::GetBooleanParam(const std::string& name,
                                                 bool* is_value_cached,
                                                 bool* cached_value) {
  if (!*is_value_cached) {
    *is_value_cached = true;
    std::string string_value = GetSwitch(name);
    bool has_switch = HasSwitch(name);
    if (has_switch && string_value.empty())
      string_value = kAnyNonEmptyValue;
    if (!has_switch)
      string_value = GetParam(name);
    *cached_value = !string_value.empty() && string_value != kFalseValue;
  }
  return *cached_value;
}

bool TryEncoding(const base::string16& terms,
                 const base::string16& original_query,
                 const char* encoding,
                 bool is_in_query,
                 base::string16* escaped_terms,
                 base::string16* escaped_original_query) {
  DCHECK(escaped_terms);
  DCHECK(escaped_original_query);
  std::string encoded_terms;
  if (!base::UTF16ToCodepage(terms, encoding,
      base::OnStringConversionError::SKIP, &encoded_terms))
    return false;
  *escaped_terms = base::UTF8ToUTF16(is_in_query ?
      net::EscapeQueryParamValue(encoded_terms, true) :
      net::EscapePath(encoded_terms));
  if (original_query.empty())
    return true;
  std::string encoded_original_query;
  if (!base::UTF16ToCodepage(original_query, encoding,
      base::OnStringConversionError::SKIP, &encoded_original_query))
    return false;
  *escaped_original_query = base::UTF8ToUTF16(
      net::EscapeQueryParamValue(encoded_original_query, true));
  return true;
}

void ContextualSearchDelegate::DecodeSearchTermFromJsonResponse(
const std::string& response,
std::string* search_term,
std::string* display_text,
std::string* alternate_term,
std::string* mid,
std::string* prevent_preload,
int* mention_start,
int* mention_end,
std::string* lang,
std::string* thumbnail_url,
std::string* caption) {
bool contains_xssi_escape =
base::StartsWith(response, kXssiEscape, base::CompareCase::SENSITIVE);
const std::string& proper_json =
contains_xssi_escape ? response.substr(sizeof(kXssiEscape) - 1)
: response;
JSONStringValueDeserializer deserializer(proper_json);
std::unique_ptr<base::Value> root =
deserializer.Deserialize(nullptr, nullptr);
const std::unique_ptr<base::DictionaryValue> dict =
base::DictionaryValue::From(std::move(root));
if (!dict)
return;

dict->GetString(kContextualSearchPreventPreload, prevent_preload);
dict->GetString(kContextualSearchResponseSearchTermParam, search_term);
dict->GetString(kContextualSearchResponseLanguageParam, lang);

// For the display_text, if not present fall back to the "search_term".
if (!dict->GetString(kContextualSearchResponseDisplayTextParam,
display_text)) {
*display_text = *search_term;
}
dict->GetString(kContextualSearchResponseMidParam, mid);

// Extract mentions for selection expansion.
if (!field_trial_->IsDecodeMentionsDisabled()) {
base::ListValue* mentions_list = nullptr;
dict->GetList(kContextualSearchMentions, &mentions_list);
if (mentions_list && mentions_list->GetSize() >= 2)
ExtractMentionsStartEnd(*mentions_list, mention_start, mention_end);
}

// If either the selected text or the resolved term is not the search term,
// use it as the alternate term.
std::string selected_text;
dict->GetString(kContextualSearchResponseSelectedTextParam, &selected_text);
if (selected_text != *search_term) {
*alternate_term = selected_text;
} else {
std::string resolved_term;
dict->GetString(kContextualSearchResponseResolvedTermParam, &resolved_term);
if (resolved_term != *search_term) {
*alternate_term = resolved_term;
}
}

  if (field_trial_->IsNowOnTapBarIntegrationEnabled()) {
    // Get the basic Bar data for Now on Tap integration directly from the root.
dict->GetString(kContextualSearchCaption, caption);
dict->GetString(kContextualSearchThumbnail, thumbnail_url);
}
}

const FeatureEntry* GetFeatureEntries(size_t* count) {
  *count = arraysize(kFeatureEntries);
  return kFeatureEntries;
}

void GetFlagFeatureEntries(flags_ui::FlagsStorage* flags_storage,
                           flags_ui::FlagAccess access,
                           base::ListValue* supported_entries,
                           base::ListValue* unsupported_entries) {
  FlagsStateSingleton::GetFlagsState()->GetFlagFeatureEntries(
      flags_storage, access, supported_entries, unsupported_entries,
      base::Bind(&SkipConditionalFeatureEntry));
}

  int response_code() { return response_code_; }

base::string16 TemplateURLRef::SearchTermToString16(
    const std::string& term) const {
  const std::vector<std::string>& encodings = owner_->input_encodings();
  base::string16 result;

  net::UnescapeRule::Type unescape_rules =
      net::UnescapeRule::SPACES | net::UnescapeRule::PATH_SEPARATORS |
      net::UnescapeRule::URL_SPECIAL_CHARS_EXCEPT_PATH_SEPARATORS;
  if (search_term_key_location_ != url::Parsed::PATH)
    unescape_rules |= net::UnescapeRule::REPLACE_PLUS_WITH_SPACE;

  std::string unescaped = net::UnescapeURLComponent(term, unescape_rules);
  for (size_t i = 0; i < encodings.size(); ++i) {
    if (base::CodepageToUTF16(unescaped, encodings[i].c_str(),
                              base::OnStringConversionError::FAIL, &result))
      return result;
  }

  if (base::CodepageToUTF16(unescaped, base::kCodepageUTF8,
                            base::OnStringConversionError::FAIL, &result))
    return result;

  result = base::UTF8ToUTF16(term);
  if (unescape_rules & net::UnescapeRule::REPLACE_PLUS_WITH_SPACE)
    std::replace(result.begin(), result.end(), '+', ' ');
  return result;
}

bool TryMatchSearchParam(base::StringPiece text,
                         base::StringPiece pattern,
                         std::string* prefix,
                         std::string* suffix) {
  auto pos = text.find(pattern);
  if (pos == base::StringPiece::npos)
    return false;
  text.substr(0, pos).CopyToString(prefix);
  text.substr(pos + pattern.length()).CopyToString(suffix);
  return true;
}

    ~ContextualSearchParams() {
}

void ContextualSearchDelegate::StartSearchTermRequestFromSelection(
    const base::string16& surrounding_text,
    int start_offset,
    int end_offset) {
  if (context_.get()) {
    SaveSurroundingText(surrounding_text, start_offset, end_offset);
    SendSurroundingText(kSurroundingSizeForUI);
    ContinueSearchTermResolutionRequest();
  } else {
    DVLOG(1) << "ctxs: Null context, ignored!";
  }
}

  void CreateDefaultSearchContextAndRequestSearchTerm() {
    base::string16 surrounding = base::UTF8ToUTF16("Barack Obama just spoke.");
    CreateSearchContextAndRequestSearchTerm("Barack Obama", surrounding, 0, 6);
  }

TemplateURLRef::SearchTermsArgs::ContextualSearchParams::ContextualSearchParams(
int version,
size_t start,
size_t end,
const std::string& selection,
const std::string& content,
const std::string& base_page_url,
const std::string& encoding,
    int now_on_tap_version)
: version(version),
start(start),
end(end),
selection(selection),
content(content),
base_page_url(base_page_url),
encoding(encoding),
      now_on_tap_version(now_on_tap_version) {}

bool AreSwitchesIdenticalToCurrentCommandLine(
    const base::CommandLine& new_cmdline,
    const base::CommandLine& active_cmdline,
    std::set<base::CommandLine::StringType>* out_difference) {
  const char* extra_flag_sentinel_begin_flag_name = nullptr;
  const char* extra_flag_sentinel_end_flag_name = nullptr;
#if defined(OS_CHROMEOS)
  extra_flag_sentinel_begin_flag_name =
      chromeos::switches::kPolicySwitchesBegin;
  extra_flag_sentinel_end_flag_name = chromeos::switches::kPolicySwitchesEnd;
#endif
  return flags_ui::FlagsState::AreSwitchesIdenticalToCurrentCommandLine(
      new_cmdline, active_cmdline, out_difference,
      extra_flag_sentinel_begin_flag_name, extra_flag_sentinel_end_flag_name);
}

std::string ContextualSearchFieldTrial::GetParam(const std::string& name) {
  return variations::GetVariationParamValue(kContextualSearchFieldTrialName,
                                            name);
}

const std::string& TemplateURLRef::GetPath(
    const SearchTermsData& search_terms_data) const {
  ParseIfNecessary(search_terms_data);
  return path_;
}

bool TemplateURL::FindSearchTermsInURL(
    const GURL& url,
    const SearchTermsData& search_terms_data,
    base::string16* search_terms,
    url::Parsed::ComponentType* search_term_component,
    url::Component* search_terms_position) const {
  DCHECK(search_terms);
  search_terms->clear();

  for (const TemplateURLRef& ref : url_refs_) {
    if (ref.ExtractSearchTermsFromURL(url, search_terms, search_terms_data,
        search_term_component, search_terms_position)) {
      return !search_terms->empty();
    }
  }
  return false;
}

std::string ContextualSearchDelegate::BuildRequestUrl(std::string selection) {
// TODO(donnd): Confirm this is the right way to handle TemplateURL fails.
if (!template_url_service_ ||
!template_url_service_->GetDefaultSearchProvider()) {
return std::string();
}

std::string selected_text(net::EscapeQueryParamValue(selection, true));
TemplateURL* template_url = template_url_service_->GetDefaultSearchProvider();

TemplateURLRef::SearchTermsArgs search_terms_args =
TemplateURLRef::SearchTermsArgs(base::string16());

  int now_on_tap_version =
      field_trial_->IsNowOnTapBarIntegrationEnabled() ? kNowOnTapVersion : 0;

TemplateURLRef::SearchTermsArgs::ContextualSearchParams params(
kContextualSearchRequestVersion, selected_text, std::string(),
      now_on_tap_version);

search_terms_args.contextual_search_params = params;

std::string request(
template_url->contextual_search_url_ref().ReplaceSearchTerms(
search_terms_args,
template_url_service_->search_terms_data(),
NULL));

// The switch/param should be the URL up to and including the endpoint.
std::string replacement_url = field_trial_->GetResolverURLPrefix();

// If a replacement URL was specified above, do the substitution.
if (!replacement_url.empty()) {
size_t pos = request.find(kContextualSearchServerEndpoint);
if (pos != std::string::npos) {
request.replace(0, pos + strlen(kContextualSearchServerEndpoint),
replacement_url);
}
}
return request;
}

  TemplateURLService* CreateTemplateURLService() {
    TemplateURLData data;
    data.SetURL("https://foobar.com/url?bar={searchTerms}");
    data.contextual_search_url = "https://foobar.com/_/contextualsearch?"
        "{google:contextualSearchVersion}{google:contextualSearchContextData}";
    TemplateURLService* template_url_service = new TemplateURLService(NULL, 0);
    TemplateURL* template_url =
        template_url_service->Add(base::MakeUnique<TemplateURL>(data));
    template_url_service->SetUserSelectedDefaultSearchProvider(template_url);
    return template_url_service;
  }

bool AboutInSettingsEnabled() {
  return SettingsWindowEnabled() &&
         !base::CommandLine::ForCurrentProcess()->HasSwitch(
             ::switches::kDisableAboutInSettings);
}

  std::string escapeBarQuoted(std::string bar_quoted) {
    std::replace(bar_quoted.begin(), bar_quoted.end(), '|', '\"');
    return bar_quoted;
  }

  int start_adjust() { return start_adjust_; }

bool ContextualSearchFieldTrial::IsNowOnTapBarIntegrationEnabled() {
return GetBooleanParam(
      switches::kEnableContextualSearchNowOnTapBarIntegration,
      &is_now_on_tap_bar_integration_enabled_cached_,
      &is_now_on_tap_bar_integration_enabled_);
}

bool IsTemplateParameterString(const std::string& param) {
  return (param.length() > 2) && (*(param.begin()) == kStartParameter) &&
      (*(param.rbegin()) == kEndParameter);
}

std::string ContextualSearchDelegate::GetAcceptLanguages() {
  Profile* profile = ProfileManager::GetActiveUserProfile();
  PrefService* pref_service = profile->GetPrefs();
  return pref_service->GetString(prefs::kAcceptLanguages);
}

bool TemplateURL::IsSearchURL(const GURL& url,
                              const SearchTermsData& search_terms_data) const {
  base::string16 search_terms;
  return ExtractSearchTermsFromURL(url, search_terms_data, &search_terms) &&
      !search_terms.empty();
}

  std::string alternate_term() { return alternate_term_; }

int ContextualSearchFieldTrial::GetIntParamValueOrDefault(
    const std::string& name,
    const int default_value,
    bool* is_value_cached,
    int* cached_value) {
  if (!*is_value_cached) {
    *is_value_cached = true;
    std::string param_string = GetSwitch(name);
    if (param_string.empty())
      param_string = GetParam(name);

    int param_int;
    if (!param_string.empty() && base::StringToInt(param_string, &param_int))
      *cached_value = param_int;
    else
      *cached_value = default_value;
  }
  return *cached_value;
}

  ContextualSearchDelegateTest() {}

ContextualSearchDelegate::~ContextualSearchDelegate() {
}

void ResetAllFlags(flags_ui::FlagsStorage* flags_storage) {
  FlagsStateSingleton::GetFlagsState()->ResetAllFlags(flags_storage);
}

base::string16 ContextualSearchDelegate::SurroundingTextForIcing(
    const base::string16& surrounding_text,
    int padding_each_side,
    size_t* start,
    size_t* end) {
  base::string16 result_text = surrounding_text;
  size_t start_offset = *start;
  size_t end_offset = *end;
  size_t padding_each_side_pinned =
      padding_each_side >= 0 ? padding_each_side : 0;
  if (start_offset > padding_each_side_pinned) {
    int trim = start_offset - padding_each_side_pinned;
    result_text = result_text.substr(trim);
    start_offset -= trim;
    end_offset -= trim;
  }
  if (result_text.length() > end_offset + padding_each_side_pinned) {
    result_text = result_text.substr(0, end_offset + padding_each_side_pinned);
  }
  *start = start_offset;
  *end = end_offset;
  return result_text;
}

void TemplateURLRef::ParseIfNecessary(
    const SearchTermsData& search_terms_data) const {
  if (!parsed_) {
    InvalidateCachedValues();
    parsed_ = true;
    parsed_url_ = ParseURL(GetURL(), &replacements_, &post_params_, &valid_);
    supports_replacements_ = false;
    if (valid_) {
      bool has_only_one_search_term = false;
      for (Replacements::const_iterator i = replacements_.begin();
           i != replacements_.end(); ++i) {
        if ((i->type == SEARCH_TERMS) ||
            (i->type == GOOGLE_UNESCAPED_SEARCH_TERMS)) {
          if (has_only_one_search_term) {
            has_only_one_search_term = false;
            break;
          }
          has_only_one_search_term = true;
          supports_replacements_ = true;
        }
      }
      if (has_only_one_search_term)
        ParseHostAndSearchTermKey(search_terms_data);
    }
  }
}

std::string ContextualSearchFieldTrial::GetSwitch(const std::string& name) {
  if (!HasSwitch(name))
    return std::string();
  else
    return base::CommandLine::ForCurrentProcess()->GetSwitchValueASCII(name);
}

  void recordIcingSelectionAvailable(const std::string& encoding,
                                     const base::string16& surrounding_text,
                                     size_t start_offset,
                                     size_t end_offset) {
  }

ContextualSearchDelegate::GetResolvedSearchTermFromJson(
    int response_code,
    const std::string& json_string) {
  std::string search_term;
  std::string display_text;
  std::string alternate_term;
  std::string mid;
  std::string prevent_preload;
  int mention_start = 0;
  int mention_end = 0;
  int start_adjust = 0;
  int end_adjust = 0;
  std::string context_language;
  std::string thumbnail_url = "";
  std::string caption = "";

  DecodeSearchTermFromJsonResponse(
      json_string, &search_term, &display_text, &alternate_term, &mid,
      &prevent_preload, &mention_start, &mention_end, &context_language,
      &thumbnail_url, &caption);
  if (mention_start != 0 || mention_end != 0) {
    if (mention_start >= mention_end ||
        (mention_end - mention_start) > kContextualSearchMaxSelection ||
        mention_end <= context_->start_offset ||
        mention_start >= context_->end_offset) {
      start_adjust = 0;
      end_adjust = 0;
    } else {
      start_adjust = mention_start - context_->start_offset;
      end_adjust = mention_end - context_->end_offset;
    }
  }
  bool is_invalid = response_code == net::URLFetcher::RESPONSE_CODE_INVALID;
  return std::unique_ptr<ResolvedSearchTerm>(new ResolvedSearchTerm(
      is_invalid, response_code, search_term, display_text, alternate_term, mid,
      prevent_preload == kDoPreventPreloadValue, start_adjust, end_adjust,
      context_language, thumbnail_url, caption));
}

bool TemplateURL::MatchesData(const TemplateURL* t_url,
                              const TemplateURLData* data,
                              const SearchTermsData& search_terms_data) {
  if (!t_url || !data)
    return !t_url && !data;

  return (t_url->short_name() == data->short_name()) &&
      t_url->HasSameKeywordAs(*data, search_terms_data) &&
      (t_url->url() == data->url()) &&
      (t_url->suggestions_url() == data->suggestions_url) &&
      (t_url->instant_url() == data->instant_url) &&
      (t_url->image_url() == data->image_url) &&
      (t_url->new_tab_url() == data->new_tab_url) &&
      (t_url->search_url_post_params() == data->search_url_post_params) &&
      (t_url->suggestions_url_post_params() ==
          data->suggestions_url_post_params) &&
      (t_url->instant_url_post_params() == data->instant_url_post_params) &&
      (t_url->image_url_post_params() == data->image_url_post_params) &&
      (t_url->favicon_url() == data->favicon_url) &&
      (t_url->safe_for_autoreplace() == data->safe_for_autoreplace) &&
      (t_url->show_in_default_list() == data->show_in_default_list) &&
      (t_url->input_encodings() == data->input_encodings) &&
      (t_url->alternate_urls() == data->alternate_urls) &&
      (t_url->search_terms_replacement_key() ==
          data->search_terms_replacement_key);
}

GURL TemplateURL::GenerateSearchURL(
    const SearchTermsData& search_terms_data) const {
  if (!url_ref_->IsValid(search_terms_data))
    return GURL();

  if (!url_ref_->SupportsReplacement(search_terms_data))
    return GURL(url());

  return GURL(url_ref_->ReplaceSearchTerms(
      TemplateURLRef::SearchTermsArgs(
          base::ASCIIToUTF16("blah.blah.blah.blah.blah")),
      search_terms_data, NULL));
}

void ContextualSearchDelegate::StartSearchTermResolutionRequest(
    const std::string& selection,
    bool use_resolved_search_term,
    content::WebContents* web_contents,
    bool may_send_base_page_url) {
  GatherSurroundingTextWithCallback(
      selection, use_resolved_search_term, web_contents, may_send_base_page_url,
      base::Bind(&ContextualSearchDelegate::StartSearchTermRequestFromSelection,
                 AsWeakPtr()));
}

  net::TestURLFetcher* fetcher() { return fetcher_; }

bool TemplateURLRef::ParseParameter(size_t start,
                                    size_t end,
                                    std::string* url,
                                    Replacements* replacements) const {
  DCHECK(start != std::string::npos &&
         end != std::string::npos && end > start);
  size_t length = end - start - 1;
  bool optional = false;
  const std::string original_url(*url);
  if (original_url[end - 1] == kOptional) {
    optional = true;
    length--;
  }

  const base::StringPiece parameter(original_url.begin() + start + 1,
                                    original_url.begin() + start + 1 + length);
  const base::StringPiece full_parameter(original_url.begin() + start,
                                         original_url.begin() + end + 1);
  url->erase(start, end - start + 1);
  if (parameter == kSearchTermsParameter) {
    replacements->push_back(Replacement(SEARCH_TERMS, start));
  } else if (parameter == "count") {
    if (!optional)
      url->insert(start, kDefaultCount);
  } else if (parameter == "google:assistedQueryStats") {
    replacements->push_back(Replacement(GOOGLE_ASSISTED_QUERY_STATS, start));
  } else if (parameter == "google:baseURL") {
    replacements->push_back(Replacement(GOOGLE_BASE_URL, start));
  } else if (parameter == "google:baseSuggestURL") {
    replacements->push_back(Replacement(GOOGLE_BASE_SUGGEST_URL, start));
  } else if (parameter == "google:currentPageUrl") {
    replacements->push_back(Replacement(GOOGLE_CURRENT_PAGE_URL, start));
  } else if (parameter == "google:cursorPosition") {
    replacements->push_back(Replacement(GOOGLE_CURSOR_POSITION, start));
  } else if (parameter == "google:forceInstantResults") {
    replacements->push_back(Replacement(GOOGLE_FORCE_INSTANT_RESULTS, start));
  } else if (parameter == "google:imageOriginalHeight") {
    replacements->push_back(
        Replacement(TemplateURLRef::GOOGLE_IMAGE_ORIGINAL_HEIGHT, start));
  } else if (parameter == "google:imageOriginalWidth") {
    replacements->push_back(
        Replacement(TemplateURLRef::GOOGLE_IMAGE_ORIGINAL_WIDTH, start));
  } else if (parameter == "google:imageSearchSource") {
    replacements->push_back(
        Replacement(TemplateURLRef::GOOGLE_IMAGE_SEARCH_SOURCE, start));
  } else if (parameter == "google:imageThumbnail") {
    replacements->push_back(
        Replacement(TemplateURLRef::GOOGLE_IMAGE_THUMBNAIL, start));
  } else if (parameter == "google:imageURL") {
    replacements->push_back(Replacement(TemplateURLRef::GOOGLE_IMAGE_URL,
                                        start));
  } else if (parameter == "google:inputType") {
    replacements->push_back(Replacement(TemplateURLRef::GOOGLE_INPUT_TYPE,
                                        start));
  } else if (parameter == "google:instantExtendedEnabledParameter") {
    replacements->push_back(Replacement(GOOGLE_INSTANT_EXTENDED_ENABLED,
                                        start));
  } else if (parameter == "google:instantExtendedEnabledKey") {
    url->insert(start, google_util::kInstantExtendedAPIParam);
  } else if (parameter == "google:iOSSearchLanguage") {
    replacements->push_back(Replacement(GOOGLE_IOS_SEARCH_LANGUAGE, start));
  } else if (parameter == "google:contextualSearchVersion") {
    replacements->push_back(
        Replacement(GOOGLE_CONTEXTUAL_SEARCH_VERSION, start));
  } else if (parameter == "google:contextualSearchContextData") {
    replacements->push_back(
        Replacement(GOOGLE_CONTEXTUAL_SEARCH_CONTEXT_DATA, start));
  } else if (parameter == "google:originalQueryForSuggestion") {
    replacements->push_back(Replacement(GOOGLE_ORIGINAL_QUERY_FOR_SUGGESTION,
                                        start));
  } else if (parameter == "google:pageClassification") {
    replacements->push_back(Replacement(GOOGLE_PAGE_CLASSIFICATION, start));
  } else if (parameter == "google:prefetchQuery") {
    replacements->push_back(Replacement(GOOGLE_PREFETCH_QUERY, start));
  } else if (parameter == "google:RLZ") {
    replacements->push_back(Replacement(GOOGLE_RLZ, start));
  } else if (parameter == "google:searchClient") {
    replacements->push_back(Replacement(GOOGLE_SEARCH_CLIENT, start));
  } else if (parameter == "google:searchFieldtrialParameter") {
    replacements->push_back(Replacement(GOOGLE_SEARCH_FIELDTRIAL_GROUP, start));
  } else if (parameter == "google:searchVersion") {
    replacements->push_back(Replacement(GOOGLE_SEARCH_VERSION, start));
  } else if (parameter == "google:sessionToken") {
    replacements->push_back(Replacement(GOOGLE_SESSION_TOKEN, start));
  } else if (parameter == "google:sourceId") {
#if defined(OS_ANDROID) || defined(OS_IOS)
    url->insert(start, "sourceid=chrome-mobile&");
#else
    url->insert(start, "sourceid=chrome&");
#endif
  } else if (parameter == "google:suggestAPIKeyParameter") {
    url->insert(start,
                net::EscapeQueryParamValue(google_apis::GetAPIKey(), false));
  } else if (parameter == "google:suggestClient") {
    replacements->push_back(Replacement(GOOGLE_SUGGEST_CLIENT, start));
  } else if (parameter == "google:suggestRid") {
    replacements->push_back(Replacement(GOOGLE_SUGGEST_REQUEST_ID, start));
  } else if (parameter == kGoogleUnescapedSearchTermsParameter) {
    replacements->push_back(Replacement(GOOGLE_UNESCAPED_SEARCH_TERMS, start));
  } else if (parameter == "yandex:searchPath") {
    switch (ui::GetDeviceFormFactor()) {
      case ui::DEVICE_FORM_FACTOR_DESKTOP:
        url->insert(start, "search/");
        break;
      case ui::DEVICE_FORM_FACTOR_PHONE:
        url->insert(start, "search/touch/");
        break;
      case ui::DEVICE_FORM_FACTOR_TABLET:
        url->insert(start, "search/pad/");
        break;
    }
  } else if (parameter == "inputEncoding") {
    replacements->push_back(Replacement(ENCODING, start));
  } else if (parameter == "language") {
    replacements->push_back(Replacement(LANGUAGE, start));
  } else if (parameter == "outputEncoding") {
    if (!optional)
      url->insert(start, kOutputEncodingType);
  } else if ((parameter == "startIndex") || (parameter == "startPage")) {
    if (!optional)
      url->insert(start, "1");
  } else if (!prepopulated_) {
    url->insert(start, full_parameter.data(), full_parameter.size());
    return false;
  }
  return true;
}

const std::string& TemplateURLRef::GetHost(
    const SearchTermsData& search_terms_data) const {
  ParseIfNecessary(search_terms_data);
  return host_;
}

void SetFeatureEntryEnabled(flags_ui::FlagsStorage* flags_storage,
                            const std::string& internal_name,
                            bool enable) {
  FlagsStateSingleton::GetFlagsState()->SetFeatureEntryEnabled(
      flags_storage, internal_name, enable);
}

void TemplateURL::ResetKeywordIfNecessary(
    const SearchTermsData& search_terms_data,
    bool force) {
  if (IsGoogleSearchURLWithReplaceableKeyword(search_terms_data) || force) {
    DCHECK_NE(OMNIBOX_API_EXTENSION, type_);
    GURL url(GenerateSearchURL(search_terms_data));
    if (url.is_valid())
      data_.SetKeyword(GenerateKeyword(url));
  }
}

GURL TemplateURL::GenerateFaviconURL(const GURL& url) {
  DCHECK(url.is_valid());
  GURL::Replacements rep;

  const char favicon_path[] = "/favicon.ico";
  int favicon_path_len = arraysize(favicon_path) - 1;

  rep.SetPath(favicon_path, url::Component(0, favicon_path_len));
  rep.ClearUsername();
  rep.ClearPassword();
  rep.ClearQuery();
  rep.ClearRef();
  return url.ReplaceComponents(rep);
}

void TemplateURL::InvalidateCachedValues() const {
  for (const TemplateURLRef& ref : url_refs_)
    ref.InvalidateCachedValues();
  suggestions_url_ref_.InvalidateCachedValues();
  instant_url_ref_.InvalidateCachedValues();
  image_url_ref_.InvalidateCachedValues();
  new_tab_url_ref_.InvalidateCachedValues();
  contextual_search_url_ref_.InvalidateCachedValues();
}

bool TemplateURLRef::SupportsReplacement(
    const SearchTermsData& search_terms_data) const {
  ParseIfNecessary(search_terms_data);
  return valid_ && supports_replacements_;
}

void ReportAboutFlagsHistogramFeatures(const std::string& uma_histogram_name,
                                       const std::set<std::string>&features) {
  for (const std::string& feature : features) {
    int uma_id = GetSwitchUMAId(feature);
    DVLOG(1) << "ReportAboutFlagsHistogram(): histogram='" << uma_histogram_name
             << "' '" << feature << "', uma_id=" << uma_id;

    UMA_HISTOGRAM_SPARSE_SLOWLY(uma_histogram_name, uma_id);
  }
}

TemplateURLRef::SearchTermsArgs::~SearchTermsArgs() {
}

  std::string caption() { return caption_; }

TemplateURL::~TemplateURL() {
}

std::string TemplateURLRef::DisplayURLToURLRef(
    const base::string16& display_url) {
  std::string result = base::UTF16ToUTF8(display_url);
  base::ReplaceSubstringsAfterOffset(&result, 0,
                                     kDisplaySearchTerms,
                                     kSearchTermsParameterFull);
  base::ReplaceSubstringsAfterOffset(&result, 0,
                                     kDisplayUnescapedSearchTerms,
                                     kGoogleUnescapedSearchTermsParameterFull);
  return result;
}

bool ContextualSearchFieldTrial::IsSendBasePageURLDisabled() {
  return GetBooleanParam(kContextualSearchSendURLDisabledParamName,
                         &is_send_base_page_url_disabled_cached_,
                         &is_send_base_page_url_disabled_);
}

void TemplateURLRef::ParseHostAndSearchTermKey(
    const SearchTermsData& search_terms_data) const {
  std::string url_string(GetURL());
  base::ReplaceSubstringsAfterOffset(
      &url_string, 0, "{google:baseURL}",
      search_terms_data.GoogleBaseURLValue());
  base::ReplaceSubstringsAfterOffset(
      &url_string, 0, "{google:baseSuggestURL}",
      search_terms_data.GoogleBaseSuggestURLValue());

  GURL url(url_string);
  if (!url.is_valid())
    return;

  auto query_result = FindSearchTermsKey(url.query());
  auto ref_result = FindSearchTermsKey(url.ref());
  url::Component parameter_position;
  const bool in_query = query_result.found();
  const bool in_ref = ref_result.found();
  const bool in_path = FindSearchTermsInPath(url.path(), &parameter_position);
  if (in_query ? (in_ref || in_path) : (in_ref == in_path))
    return;  // No key or multiple keys found.  We only handle having one key.

  host_ = url.host();
  port_ = url.port();
  path_ = url.path();
  if (in_query) {
    search_term_key_ = query_result.key;
    search_term_key_location_ = url::Parsed::QUERY;
    search_term_value_prefix_ = query_result.value_prefix;
    search_term_value_suffix_ = query_result.value_suffix;
  } else if (in_ref) {
    search_term_key_ = ref_result.key;
    search_term_key_location_ = url::Parsed::REF;
    search_term_value_prefix_ = ref_result.value_prefix;
    search_term_value_suffix_ = ref_result.value_suffix;
  } else {
    DCHECK(in_path);
    DCHECK_GE(parameter_position.begin, 1);  // Path must start with '/'.
    search_term_key_location_ = url::Parsed::PATH;
    search_term_position_in_path_ = parameter_position.begin;
    path_.erase(parameter_position.begin, parameter_position.len);
  }
}

void RemoveFlagsSwitches(
    std::map<std::string, base::CommandLine::StringType>* switch_list) {
  FlagsStateSingleton::GetFlagsState()->RemoveFlagsSwitches(switch_list);
}

size_t TemplateURLRef::GetSearchTermPositionInPath(
    const SearchTermsData& search_terms_data) const {
  ParseIfNecessary(search_terms_data);
  return search_term_position_in_path_;
}

  std::string display_text() { return display_text_; }

TemplateURLRef::TemplateURLRef(const TemplateURL* owner, Type type)
    : owner_(owner),
      type_(type),
      index_in_owner_(0),
      parsed_(false),
      valid_(false),
      supports_replacements_(false),
      search_term_position_in_path_(std::string::npos),
      search_term_key_location_(url::Parsed::QUERY),
      prepopulated_(false) {
  DCHECK(owner_);
  DCHECK_NE(INDEXED, type_);
}

void TemplateURL::CopyFrom(const TemplateURL& other) {
  if (this == &other)
    return;

  data_ = other.data_;
  ResizeURLRefVector();
  InvalidateCachedValues();
  SetPrepopulateId(other.data_.prepopulate_id);
}

void ReportAboutFlagsHistogram(
    const std::string& uma_histogram_name,
    const std::set<std::string>& switches,
    const std::set<std::string>& features) {
  ReportAboutFlagsHistogramSwitches(uma_histogram_name, switches);
  ReportAboutFlagsHistogramFeatures(uma_histogram_name, features);
}

base::string16 TemplateURL::GenerateKeyword(const GURL& url) {
  DCHECK(url.is_valid());
  base::string16 keyword = url_formatter::StripWWW(
      url_formatter::IDNToUnicode(url.host()));
  return keyword.empty() ? base::ASCIIToUTF16("www") : keyword;
}

  bool is_invalid() { return is_invalid_; }

bool TemplateURL::HasSameKeywordAs(
    const TemplateURLData& other,
    const SearchTermsData& search_terms_data) const {
  return (data_.keyword() == other.keyword()) ||
      (IsGoogleSearchURLWithReplaceableKeyword(search_terms_data) &&
       TemplateURL(other).IsGoogleSearchURLWithReplaceableKeyword(
           search_terms_data));
}

bool ContextualSearchFieldTrial::IsDecodeMentionsDisabled() {
  return GetBooleanParam(kContextualSearchDecodeMentionsDisabledParamName,
                         &is_decode_mentions_disabled_cached_,
                          &is_decode_mentions_disabled_);
 }

  FlagsStateSingleton()
      : flags_state_(kFeatureEntries, arraysize(kFeatureEntries)) {}

TemplateURLRef::TemplateURLRef(const TemplateURL* owner, size_t index_in_owner)
    : owner_(owner),
      type_(INDEXED),
      index_in_owner_(index_in_owner),
      parsed_(false),
      valid_(false),
      supports_replacements_(false),
      search_term_position_in_path_(std::string::npos),
      search_term_key_location_(url::Parsed::QUERY),
      prepopulated_(false) {
  DCHECK(owner_);
  DCHECK_LT(index_in_owner_, owner_->alternate_urls().size());
}

void ContextualSearchDelegate::ExtractMentionsStartEnd(
    const base::ListValue& mentions_list,
    int* startResult,
    int* endResult) {
  int int_value;
  if (mentions_list.GetInteger(0, &int_value))
    *startResult = std::max(0, int_value);
  if (mentions_list.GetInteger(1, &int_value))
    *endResult = std::max(0, int_value);
}

base::string16 TemplateURL::AdjustedShortNameForLocaleDirection() const {
  base::string16 bidi_safe_short_name = data_.short_name();
  base::i18n::AdjustStringForLocaleDirection(&bidi_safe_short_name);
  return bidi_safe_short_name;
}

TemplateURLRef::~TemplateURLRef() {
}

std::string TemplateURL::GetExtensionId() const {
  DCHECK(extension_info_);
  return extension_info_->extension_id;
}

SearchTermsKeyResult FindSearchTermsKey(const std::string& params) {
  SearchTermsKeyResult result;
  if (params.empty())
    return result;
  url::Component query, key, value;
  query.len = static_cast<int>(params.size());
  while (url::ExtractQueryKeyValue(params.c_str(), &query, &key, &value)) {
    if (key.is_nonempty() && value.is_nonempty()) {
      const base::StringPiece value_string(params.c_str() + value.begin,
                                           value.len);
      if (TryMatchSearchParam(value_string, kSearchTermsParameterFull,
                              &result.value_prefix, &result.value_suffix) ||
          TryMatchSearchParam(value_string,
                              kGoogleUnescapedSearchTermsParameterFull,
                              &result.value_prefix, &result.value_suffix)) {
        result.key = params.substr(key.begin, key.len);
        break;
      }
    }
  }
  return result;
}

  std::string getBasePageUrlFromRequest() {
    std::string result;
    discourse_context::ClientDiscourseContext cdc =
        GetDiscourseContextFromRequest();
    if (cdc.display_size() > 0) {
      const discourse_context::Display& first_display = cdc.display(0);
      result = first_display.uri();
    }
    return result;
  }

  void SetResponseStringAndFetch(const std::string& selected_text,
                                 const std::string& mentions_start,
                                 const std::string& mentions_end) {
    fetcher()->set_response_code(200);
      fetcher()->SetResponseString(
          ")]}'\n"

bool TemplateURLRef::EncodeFormData(const PostParams& post_params,
                                    PostContent* post_content) const {
  if (post_params.empty())
    return true;
  if (!post_content)
    return false;

  const char kUploadDataMIMEType[] = "multipart/form-data; boundary=";
  std::string boundary = net::GenerateMimeMultipartBoundary();
  post_content->first = kUploadDataMIMEType;
  post_content->first += boundary;
  std::string* post_data = &post_content->second;
  post_data->clear();
  for (const auto& param : post_params) {
    DCHECK(!param.name.empty());
    net::AddMultipartValueForUpload(param.name, param.value, boundary,
                                    param.content_type, post_data);
  }
  net::AddMultipartFinalDelimiterForUpload(boundary, post_data);
  return true;
}

bool TemplateURLRef::ExtractSearchTermsFromURL(
    const GURL& url,
    base::string16* search_terms,
    const SearchTermsData& search_terms_data,
    url::Parsed::ComponentType* search_terms_component,
    url::Component* search_terms_position) const {
  DCHECK(search_terms);
  search_terms->clear();

  ParseIfNecessary(search_terms_data);

  if (search_term_key_.empty() &&
      (search_term_key_location_ != url::Parsed::PATH))
    return false;

  if ((url.host() != host_) ||
      (url.port() != port_) ||
      ((url.path() != path_) &&
          (search_term_key_location_ != url::Parsed::PATH))) {
    return false;
  }

  std::string source;
  url::Component position;

  if (search_term_key_location_ == url::Parsed::PATH) {
    source = url.path();

    if (source.length() < path_.length())
      return false;
    position.begin = search_term_position_in_path_;
    position.len = source.length() - path_.length();
    if (source.substr(0, position.begin) + source.substr(position.end()) !=
        path_)
      return false;
  } else {
    DCHECK(search_term_key_location_ == url::Parsed::QUERY ||
           search_term_key_location_ == url::Parsed::REF);
    source = (search_term_key_location_ == url::Parsed::QUERY) ?
        url.query() : url.ref();

    url::Component query, key, value;
    query.len = static_cast<int>(source.size());
    bool key_found = false;
    while (url::ExtractQueryKeyValue(source.c_str(), &query, &key, &value)) {
      if (key.is_nonempty()) {
        if (source.substr(key.begin, key.len) == search_term_key_) {
          if (key_found)
            return false;

          base::StringPiece search_term =
              base::StringPiece(source).substr(value.begin, value.len);
          if (!search_term.starts_with(search_term_value_prefix_) ||
              !search_term.ends_with(search_term_value_suffix_))
            continue;

          key_found = true;
          position =
              url::MakeRange(value.begin + search_term_value_prefix_.size(),
                             value.end() - search_term_value_suffix_.size());
        }
      }
    }
    if (!key_found)
      return false;
  }

  *search_terms =
      SearchTermToString16(source.substr(position.begin, position.len));
  if (search_terms_component)
    *search_terms_component = search_term_key_location_;
  if (search_terms_position)
    *search_terms_position = position;
  return true;
}

int ContextualSearchFieldTrial::GetIcingSurroundingSize() {
  return GetIntParamValueOrDefault(
      kContextualSearchIcingSurroundingSizeParamName,
      kContextualSearchDefaultIcingSurroundingSize,
      &is_icing_surrounding_size_cached_, &icing_surrounding_size_);
}

  bool do_prevent_preload() { return prevent_preload_; }

void TemplateURL::SetPrepopulateId(int id) {
  data_.prepopulate_id = id;
  const bool prepopulated = id > 0;
  for (TemplateURLRef& ref : url_refs_)
    ref.prepopulated_ = prepopulated;
  suggestions_url_ref_.prepopulated_ = prepopulated;
  instant_url_ref_.prepopulated_ = prepopulated;
  image_url_ref_.prepopulated_ = prepopulated;
  new_tab_url_ref_.prepopulated_ = prepopulated;
  contextual_search_url_ref_.prepopulated_ = prepopulated;
}

void TemplateURL::EncodeSearchTerms(
    const TemplateURLRef::SearchTermsArgs& search_terms_args,
    bool is_in_query,
    std::string* input_encoding,
    base::string16* encoded_terms,
    base::string16* encoded_original_query) const {

  std::vector<std::string> encodings(input_encodings());
  if (std::find(encodings.begin(), encodings.end(), "UTF-8") == encodings.end())
    encodings.push_back("UTF-8");
  for (std::vector<std::string>::const_iterator i(encodings.begin());
       i != encodings.end(); ++i) {
    if (TryEncoding(search_terms_args.search_terms,
                    search_terms_args.original_query, i->c_str(),
                    is_in_query, encoded_terms, encoded_original_query)) {
      *input_encoding = *i;
      return;
    }
  }
  NOTREACHED();
}

ContextualSearchParams()
: version(-1),
start(base::string16::npos),
end(base::string16::npos),
      now_on_tap_version(0) {}

  int end_adjust() { return end_adjust_; }

void ContextualSearchDelegate::OnURLFetchComplete(
    const net::URLFetcher* source) {
  DCHECK(source == search_term_fetcher_.get());
  int response_code = source->GetResponseCode();

  std::unique_ptr<ResolvedSearchTerm> resolved_search_term(
      new ResolvedSearchTerm(response_code));
  if (source->GetStatus().is_success() && response_code == net::HTTP_OK) {
    std::string response;
    bool has_string_response = source->GetResponseAsString(&response);
    DCHECK(has_string_response);
    if (has_string_response) {
      resolved_search_term =
          GetResolvedSearchTermFromJson(response_code, response);
    }
  }
  search_term_callback_.Run(*resolved_search_term);

  context_.reset();
}

void ContextualSearchDelegate::ContinueSearchTermResolutionRequest() {
  DCHECK(context_.get());
  if (!context_.get())
    return;
  GURL request_url(BuildRequestUrl(context_->selected_text));
  DCHECK(request_url.is_valid());

  search_term_fetcher_.reset(
      net::URLFetcher::Create(kContextualSearchURLFetcherID, request_url,
                              net::URLFetcher::GET, this).release());
  search_term_fetcher_->SetRequestContext(url_request_context_);

  net::HttpRequestHeaders headers;
  variations::AppendVariationHeaders(
      search_term_fetcher_->GetOriginalURL(),
      false,  // Impossible to be incognito at this point.
      false, &headers);
  search_term_fetcher_->SetExtraRequestHeaders(headers.ToString());

  SetDiscourseContextAndAddToHeader(*context_);

  search_term_fetcher_->Start();
}

std::string TemplateURLRef::ParseURL(const std::string& url,
                                     Replacements* replacements,
                                     PostParams* post_params,
                                     bool* valid) const {
  *valid = false;
  std::string parsed_url = url;
  for (size_t last = 0; last != std::string::npos; ) {
    last = parsed_url.find(kStartParameter, last);
    if (last != std::string::npos) {
      size_t template_end = parsed_url.find(kEndParameter, last);
      if (template_end != std::string::npos) {
        size_t next_template_start = parsed_url.find(kStartParameter, last + 1);
        if (next_template_start == std::string::npos ||
            next_template_start > template_end) {
          if (!ParseParameter(last, template_end, &parsed_url, replacements)) {
            last = template_end;
          }
        } else {
          last = next_template_start;
        }
      } else {
        return std::string();
      }
    }
  }

  const std::string& post_params_string = GetPostParamsString();
  if (!post_params_string.empty()) {
    for (const base::StringPiece& cur : base::SplitStringPiece(
             post_params_string, ",",
             base::TRIM_WHITESPACE, base::SPLIT_WANT_ALL)) {
      std::vector<std::string> parts = base::SplitString(
          cur, "=", base::TRIM_WHITESPACE, base::SPLIT_WANT_ALL);
      if ((parts.size() != 2U) || parts[0].empty())
        return std::string();

      std::string& value = parts[1];
      size_t replacements_size = replacements->size();
      if (IsTemplateParameterString(value))
        ParseParameter(0, value.length() - 1, &value, replacements);
      PostParam param = { parts[0], value };
      post_params->push_back(param);
      if (replacements->size() > replacements_size) {
        DCHECK_EQ(replacements_size + 1, replacements->size());
        Replacement* r = &replacements->back();
        r->is_post_param = true;
        r->index = post_params->size() - 1;
      }
    }
    DCHECK(!post_params->empty());
  }

  *valid = true;
  return parsed_url;
}

  void SetSurroundingContext(const base::string16& surrounding_text,
                             int start_offset,
                             int end_offset) {
    test_context_ = new ContextualSearchContext(
        "Bogus", true, GURL(kSomeSpecificBasePage), "utf-8");
    test_context_->surrounding_text = surrounding_text;
    test_context_->start_offset = start_offset;
    test_context_->end_offset = end_offset;
    delegate_->set_context_for_testing(test_context_);
  }

 ContextualSearchFieldTrial::~ContextualSearchFieldTrial() {}

bool ContextualSearchDelegate::CanSendPageURL(
    const GURL& current_page_url,
    Profile* profile,
    TemplateURLService* template_url_service) {
  if (field_trial_->IsSendBasePageURLDisabled())
    return false;

  TemplateURL* default_search_provider =
      template_url_service->GetDefaultSearchProvider();
  bool is_default_search_provider_google =
      default_search_provider &&
      default_search_provider->url_ref().HasGoogleBaseURLs(
          template_url_service->search_terms_data());
  if (!is_default_search_provider_google)
    return false;

  if (current_page_url.scheme() != url::kHttpScheme &&
      (current_page_url.scheme() != url::kHttpsScheme))
    return false;

  browser_sync::ProfileSyncService* service =
      ProfileSyncServiceFactory::GetInstance()->GetForProfile(profile);
  sync_driver::SyncPrefs sync_prefs(profile->GetPrefs());
  if (service == NULL || !service->CanSyncStart() ||
      !sync_prefs.GetPreferredDataTypes(syncer::UserTypes())
           .Has(syncer::PROXY_TABS) ||
      !service->GetActiveDataTypes().Has(syncer::HISTORY_DELETE_DIRECTIVES)) {
    return false;
  }

  return true;
}

  void recordSearchTermResolutionResponse(
      const ResolvedSearchTerm& resolved_search_term) {
    is_invalid_ = resolved_search_term.is_invalid;
    response_code_ = resolved_search_term.response_code;
    search_term_ = resolved_search_term.search_term;
    display_text_ = resolved_search_term.display_text;
    alternate_term_ = resolved_search_term.alternate_term;
    mid_ = resolved_search_term.mid;
    thumbnail_url_ = resolved_search_term.thumbnail_url;
    caption_ = resolved_search_term.caption;
    prevent_preload_ = resolved_search_term.prevent_preload;
    start_adjust_ = resolved_search_term.selection_start_adjust;
    end_adjust_ = resolved_search_term.selection_end_adjust;
    context_language_ = resolved_search_term.context_language;
  }

bool TemplateURLRef::HasGoogleBaseURLs(
    const SearchTermsData& search_terms_data) const {
  ParseIfNecessary(search_terms_data);
  for (size_t i = 0; i < replacements_.size(); ++i) {
    if ((replacements_[i].type == GOOGLE_BASE_URL) ||
        (replacements_[i].type == GOOGLE_BASE_SUGGEST_URL))
      return true;
  }
  return false;
}

  std::string mid() { return mid_; }

void RecordUMAStatistics(flags_ui::FlagsStorage* flags_storage) {
  const std::set<std::string> switches =
      FlagsStateSingleton::GetFlagsState()->GetSwitchesFromFlags(flags_storage);
  const std::set<std::string> features =
      FlagsStateSingleton::GetFlagsState()->GetFeaturesFromFlags(flags_storage);
  ReportAboutFlagsHistogram("Launch.FlagsAtStartup", switches, features);
}

void ContextualSearchDelegate::SendSurroundingText(int max_surrounding_chars) {
  const base::string16& surrounding = context_->surrounding_text;

  int surrounding_length = surrounding.length();  // Cast to int.
  int num_after_characters = std::min(
      surrounding_length - context_->end_offset, max_surrounding_chars);
  base::string16 after_text = surrounding.substr(
      context_->end_offset, num_after_characters);

  base::TrimWhitespace(after_text, base::TRIM_ALL, &after_text);
  surrounding_callback_.Run(UTF16ToUTF8(after_text));
}

std::string ContextualSearchFieldTrial::GetResolverURLPrefix() {
  if (!is_resolver_url_prefix_cached_) {
    is_resolver_url_prefix_cached_ = true;
    resolver_url_prefix_ = GetSwitch(kContextualSearchResolverUrl);
    if (resolver_url_prefix_.empty())
      resolver_url_prefix_ = GetParam(kContextualSearchResolverUrl);
  }
  return resolver_url_prefix_;
}

void ContextualSearchDelegate::BuildContext(
    const std::string& selection,
    bool use_resolved_search_term,
    content::WebContents* web_contents,
    bool may_send_base_page_url) {
  GURL page_url(web_contents->GetURL());
  GURL url_to_send;
  if (may_send_base_page_url &&
      CanSendPageURL(page_url, ProfileManager::GetActiveUserProfile(),
                     template_url_service_)) {
    url_to_send = page_url;
  }
  std::string encoding(web_contents->GetEncoding());
  context_.reset(new ContextualSearchContext(
      selection, use_resolved_search_term, url_to_send, encoding));
}

bool TemplateURLRef::UsesPOSTMethod(
    const SearchTermsData& search_terms_data) const {
  ParseIfNecessary(search_terms_data);
  return !post_params_.empty();
}

  discourse_context::ClientDiscourseContext GetDiscourseContextFromRequest() {
    discourse_context::ClientDiscourseContext cdc;
    net::HttpRequestHeaders fetch_headers;
    fetcher()->GetExtraRequestHeaders(&fetch_headers);
    if (fetch_headers.HasHeader(kDiscourseContextHeaderName)) {
      std::string actual_header_value;
      fetch_headers.GetHeader(kDiscourseContextHeaderName,
                              &actual_header_value);

      std::string unescaped_header = actual_header_value;
      std::replace(unescaped_header.begin(), unescaped_header.end(), '-', '+');
      std::replace(unescaped_header.begin(), unescaped_header.end(), '_', '/');

      std::string decoded_header;
      if (base::Base64Decode(unescaped_header, &decoded_header)) {
        cdc.ParseFromString(decoded_header);
      }
    }
    return cdc;
  }

  static flags_ui::FlagsState* GetFlagsState() {
    return &GetInstance()->flags_state_;
  }

bool TemplateURL::HasGoogleBaseURLs(
    const SearchTermsData& search_terms_data) const {
  for (const TemplateURLRef& ref : url_refs_) {
    if (ref.HasGoogleBaseURLs(search_terms_data))
      return true;
  }
  return suggestions_url_ref_.HasGoogleBaseURLs(search_terms_data) ||
      instant_url_ref_.HasGoogleBaseURLs(search_terms_data) ||
      image_url_ref_.HasGoogleBaseURLs(search_terms_data) ||
      new_tab_url_ref_.HasGoogleBaseURLs(search_terms_data) ||
      contextual_search_url_ref_.HasGoogleBaseURLs(search_terms_data);
}

void ContextualSearchDelegate::SetDiscourseContextAndAddToHeader(
    const ContextualSearchContext& context) {
  search_term_fetcher_->AddExtraRequestHeader(GetDiscourseContext(context));
}

bool TemplateURLRef::IsValid(const SearchTermsData& search_terms_data) const {
  ParseIfNecessary(search_terms_data);
  return valid_;
}

bool ContextualSearchFieldTrial::HasSwitch(const std::string& name) {
  return base::CommandLine::ForCurrentProcess()->HasSwitch(name);
}

SearchEngineType TemplateURL::GetEngineType(
    const SearchTermsData& search_terms_data) const {
  if (engine_type_ == SEARCH_ENGINE_UNKNOWN) {
    const GURL url = GenerateSearchURL(search_terms_data);
    engine_type_ = url.is_valid() ?
        TemplateURLPrepopulateData::GetEngineType(url) : SEARCH_ENGINE_OTHER;
    DCHECK_NE(SEARCH_ENGINE_UNKNOWN, engine_type_);
  }
  return engine_type_;
}

bool TemplateURL::IsGoogleSearchURLWithReplaceableKeyword(
    const SearchTermsData& search_terms_data) const {
  return (type_ == NORMAL) &&
      url_ref_->HasGoogleBaseURLs(search_terms_data) &&
      google_util::IsGoogleHostname(base::UTF16ToUTF8(data_.keyword()),
                                    google_util::DISALLOW_SUBDOMAIN);
}

  void CreateSearchContextAndRequestSearchTerm(
      const std::string& selected_text,
      const base::string16& surrounding_text,
      int start_offset,
      int end_offset) {
    test_context_ = new ContextualSearchContext(
        selected_text, true, GURL(kSomeSpecificBasePage), "utf-8");
    delegate_->set_context_for_testing(test_context_);

    test_context_->start_offset = start_offset;
    test_context_->end_offset = end_offset;
    test_context_->surrounding_text = surrounding_text;
    delegate_->ContinueSearchTermResolutionRequest();
    fetcher_ = test_factory_.GetFetcherByID(
        ContextualSearchDelegate::kContextualSearchURLFetcherID);
    ASSERT_TRUE(fetcher_);
    ASSERT_TRUE(fetcher());
  }

void ReportAboutFlagsHistogramSwitches(const std::string& uma_histogram_name,
                                       const std::set<std::string>& switches) {
  for (const std::string& flag : switches) {
    int uma_id = about_flags::testing::kBadSwitchFormatHistogramId;
    if (base::StartsWith(flag, "--", base::CompareCase::SENSITIVE)) {
      std::string switch_name(flag.substr(2));

      const size_t value_pos = switch_name.find('=');
      if (value_pos != std::string::npos)
        switch_name.resize(value_pos);

      uma_id = GetSwitchUMAId(switch_name);
    } else {
      NOTREACHED() << "ReportAboutFlagsHistogram(): flag '" << flag
                   << "' has incorrect format.";
    }
    DVLOG(1) << "ReportAboutFlagsHistogram(): histogram='" << uma_histogram_name
             << "' '" << flag << "', uma_id=" << uma_id;

    UMA_HISTOGRAM_SPARSE_SLOWLY(uma_histogram_name, uma_id);
  }
}

  bool found() const { return !key.empty(); }

ContextualSearchFieldTrial::ContextualSearchFieldTrial()
: is_resolver_url_prefix_cached_(false),
is_surrounding_size_cached_(false),
surrounding_size_(0),
is_icing_surrounding_size_cached_(false),
icing_surrounding_size_(0),
is_send_base_page_url_disabled_cached_(false),
is_send_base_page_url_disabled_(false),
is_decode_mentions_disabled_cached_(false),
is_decode_mentions_disabled_(false),
      is_now_on_tap_bar_integration_enabled_cached_(false),
      is_now_on_tap_bar_integration_enabled_(false) {}

void ContextualSearchDelegate::GatherAndSaveSurroundingText(
    const std::string& selection,
    bool use_resolved_search_term,
    content::WebContents* web_contents,
    bool may_send_base_page_url) {
  GatherSurroundingTextWithCallback(
      selection, use_resolved_search_term, web_contents, may_send_base_page_url,
      base::Bind(&ContextualSearchDelegate::SaveSurroundingText, AsWeakPtr()));
}

void ConvertFlagsToSwitches(flags_ui::FlagsStorage* flags_storage,
                            base::CommandLine* command_line,
                            flags_ui::SentinelsMode sentinels) {
  if (command_line->HasSwitch(switches::kNoExperiments))
    return;

  FlagsStateSingleton::GetFlagsState()->ConvertFlagsToSwitches(
      flags_storage, command_line, sentinels, switches::kEnableFeatures,
      switches::kDisableFeatures);
}

bool ExtensionsDisabled(const base::CommandLine& command_line) {
  return command_line.HasSwitch(switches::kDisableExtensions) ||
         command_line.HasSwitch(switches::kDisableExtensionsExcept);
}

base::string16 TemplateURLRef::DisplayURL(
    const SearchTermsData& search_terms_data) const {
  ParseIfNecessary(search_terms_data);
  std::string result(GetURL());
  if (valid_ && !replacements_.empty()) {
    base::ReplaceSubstringsAfterOffset(&result, 0,
                                       kSearchTermsParameterFull,
                                       kDisplaySearchTerms);
    base::ReplaceSubstringsAfterOffset(&result, 0,
                                       kGoogleUnescapedSearchTermsParameterFull,
                                       kDisplayUnescapedSearchTerms);
  }
  return base::UTF8ToUTF16(result);
}

bool FindSearchTermsInPath(const std::string& path,
                           url::Component* parameter_position) {
  DCHECK(parameter_position);
  parameter_position->reset();
  const size_t begin = path.find(kSearchTermsParameterFullEscaped);
  if (begin == std::string::npos)
    return false;
  parameter_position->begin = begin;
  parameter_position->len = arraysize(kSearchTermsParameterFullEscaped) - 1;
  return true;
}

std::string ContextualSearchDelegate::GetTargetLanguage() {
  Profile* profile = ProfileManager::GetActiveUserProfile();
  PrefService* pref_service = profile->GetPrefs();
  std::string result = TranslateService::GetTargetLanguage(pref_service);
  DCHECK(!result.empty());
  return result;
}

std::vector<std::string> RegisterAllFeatureVariationParameters(
    flags_ui::FlagsStorage* flags_storage,
    base::FeatureList* feature_list) {
  return FlagsStateSingleton::GetFlagsState()
      ->RegisterAllFeatureVariationParameters(flags_storage, feature_list);
}

TemplateURL::TemplateURL(const TemplateURLData& data, Type type)
    : data_(data),
      url_ref_(nullptr),
      suggestions_url_ref_(this, TemplateURLRef::SUGGEST),
      instant_url_ref_(this, TemplateURLRef::INSTANT),
      image_url_ref_(this, TemplateURLRef::IMAGE),
      new_tab_url_ref_(this, TemplateURLRef::NEW_TAB),
      contextual_search_url_ref_(this, TemplateURLRef::CONTEXTUAL_SEARCH),
      type_(type),
      engine_type_(SEARCH_ENGINE_UNKNOWN) {
  ResizeURLRefVector();
  SetPrepopulateId(data_.prepopulate_id);

  if (data_.search_terms_replacement_key ==
      "{google:instantExtendedEnabledKey}") {
    data_.search_terms_replacement_key = google_util::kInstantExtendedAPIParam;
  }
}

std::string ContextualSearchDelegate::GetDiscourseContext(
    const ContextualSearchContext& context) {
  discourse_context::ClientDiscourseContext proto;
  discourse_context::Display* display = proto.add_display();
  display->set_uri(context.page_url.spec());

  discourse_context::Media* media = display->mutable_media();
  media->set_mime_type(context.encoding);

  discourse_context::Selection* selection = display->mutable_selection();
  selection->set_content(UTF16ToUTF8(context.surrounding_text));
  selection->set_start(context.start_offset);
  selection->set_end(context.end_offset);
  selection->set_is_uri_encoded(false);

  std::string serialized;
  proto.SerializeToString(&serialized);

  std::string encoded_context;
  base::Base64Encode(serialized, &encoded_context);
  std::replace(encoded_context.begin(), encoded_context.end(), '+', '-');
  std::replace(encoded_context.begin(), encoded_context.end(), '/', '_');
  return kDiscourseContextHeaderPrefix + encoded_context;
}

bool TemplateURL::ShowInDefaultList(
    const SearchTermsData& search_terms_data) const {
  return data_.show_in_default_list &&
      url_ref_->SupportsReplacement(search_terms_data);
}

void ContextualSearchDelegate::GatherSurroundingTextWithCallback(
    const std::string& selection,
    bool use_resolved_search_term,
    content::WebContents* web_contents,
    bool may_send_base_page_url,
    HandleSurroundingsCallback callback) {
  DCHECK(web_contents);
  DCHECK(!callback.is_null());
  DCHECK(!selection.empty());
  RenderFrameHost* focused_frame = web_contents->GetFocusedFrame();
  if (!focused_frame) {
    callback.Run(base::string16(), 0, 0);
    return;
  }
  search_term_fetcher_.reset();
  BuildContext(selection, use_resolved_search_term, web_contents,
               may_send_base_page_url);
  focused_frame->RequestTextSurroundingSelection(
      callback, field_trial_->GetSurroundingSize());
}

std::string TemplateURLRef::HandleReplacements(
const SearchTermsArgs& search_terms_args,
const SearchTermsData& search_terms_data,
PostContent* post_content) const {
if (replacements_.empty()) {
if (!post_params_.empty())
EncodeFormData(post_params_, post_content);
return parsed_url_;
}

// Determine if the search terms are in the query or before. We're escaping
// space as '+' in the former case and as '%20' in the latter case.
bool is_in_query = true;
for (Replacements::iterator i = replacements_.begin();
i != replacements_.end(); ++i) {
if (i->type == SEARCH_TERMS) {
base::string16::size_type query_start = parsed_url_.find('?');
is_in_query = query_start != base::string16::npos &&
(static_cast<base::string16::size_type>(i->index) > query_start);
break;
}
}

std::string input_encoding;
base::string16 encoded_terms;
base::string16 encoded_original_query;
owner_->EncodeSearchTerms(search_terms_args, is_in_query, &input_encoding,
&encoded_terms, &encoded_original_query);

std::string url = parsed_url_;

// replacements_ is ordered in ascending order, as such we need to iterate
// from the back.
for (Replacements::reverse_iterator i = replacements_.rbegin();
i != replacements_.rend(); ++i) {
switch (i->type) {
case ENCODING:
HandleReplacement(std::string(), input_encoding, *i, &url);
break;

case GOOGLE_ASSISTED_QUERY_STATS:
DCHECK(!i->is_post_param);
if (!search_terms_args.assisted_query_stats.empty()) {
// Get the base URL without substituting AQS to avoid infinite
// recursion.  We need the URL to find out if it meets all
// AQS requirements (e.g. HTTPS protocol check).
// See TemplateURLRef::SearchTermsArgs for more details.
SearchTermsArgs search_terms_args_without_aqs(search_terms_args);
search_terms_args_without_aqs.assisted_query_stats.clear();
GURL base_url(ReplaceSearchTerms(
search_terms_args_without_aqs, search_terms_data, NULL));
if (base_url.SchemeIsCryptographic()) {
HandleReplacement(
"aqs", search_terms_args.assisted_query_stats, *i, &url);
}
}
break;

case GOOGLE_BASE_URL:
DCHECK(!i->is_post_param);
HandleReplacement(
std::string(), search_terms_data.GoogleBaseURLValue(), *i, &url);
break;

case GOOGLE_BASE_SUGGEST_URL:
DCHECK(!i->is_post_param);
HandleReplacement(
std::string(), search_terms_data.GoogleBaseSuggestURLValue(), *i,
&url);
break;

case GOOGLE_CURRENT_PAGE_URL:
DCHECK(!i->is_post_param);
if (!search_terms_args.current_page_url.empty()) {
const std::string& escaped_current_page_url =
net::EscapeQueryParamValue(search_terms_args.current_page_url,
true);
HandleReplacement("url", escaped_current_page_url, *i, &url);
}
break;

case GOOGLE_CURSOR_POSITION:
DCHECK(!i->is_post_param);
if (search_terms_args.cursor_position != base::string16::npos)
HandleReplacement(
"cp",
base::StringPrintf("%" PRIuS, search_terms_args.cursor_position),
*i,
&url);
break;

case GOOGLE_FORCE_INSTANT_RESULTS:
DCHECK(!i->is_post_param);
HandleReplacement(std::string(),
search_terms_data.ForceInstantResultsParam(
search_terms_args.force_instant_results),
*i,
&url);
break;

case GOOGLE_INPUT_TYPE:
DCHECK(!i->is_post_param);
HandleReplacement(
"oit", base::IntToString(search_terms_args.input_type), *i, &url);
break;

case GOOGLE_INSTANT_EXTENDED_ENABLED:
DCHECK(!i->is_post_param);
HandleReplacement(std::string(),
search_terms_data.InstantExtendedEnabledParam(
type_ == SEARCH),
*i,
&url);
break;

case GOOGLE_CONTEXTUAL_SEARCH_VERSION:
if (search_terms_args.contextual_search_params.version >= 0) {
HandleReplacement(
"ctxs",
base::IntToString(
search_terms_args.contextual_search_params.version),
*i,
&url);
}
break;

case GOOGLE_CONTEXTUAL_SEARCH_CONTEXT_DATA: {
DCHECK(!i->is_post_param);
std::string context_data;

const SearchTermsArgs::ContextualSearchParams& params =
search_terms_args.contextual_search_params;

if (params.start != std::string::npos) {
context_data.append("ctxs_start=" +
base::SizeTToString(params.start) + "&");
}

if (params.end != std::string::npos) {
context_data.append("ctxs_end=" +
base::SizeTToString(params.end) + "&");
}

if (!params.selection.empty())
context_data.append("q=" + params.selection + "&");

if (!params.content.empty())
context_data.append("ctxs_content=" + params.content + "&");

if (!params.base_page_url.empty())
context_data.append("ctxsl_url=" + params.base_page_url + "&");

if (!params.encoding.empty()) {
context_data.append("ctxs_encoding=" + params.encoding + "&");
}

// The above parameters all add a trailing "&" so there must be one last
// parameter that's always added at the end.
context_data.append("ctxsl_coca=" +
                            base::IntToString(params.now_on_tap_version));

HandleReplacement(std::string(), context_data, *i, &url);
break;
}

case GOOGLE_ORIGINAL_QUERY_FOR_SUGGESTION:
DCHECK(!i->is_post_param);
if (search_terms_args.accepted_suggestion >= 0 ||
!search_terms_args.assisted_query_stats.empty()) {
HandleReplacement(
"oq", base::UTF16ToUTF8(encoded_original_query), *i, &url);
}
break;

case GOOGLE_PAGE_CLASSIFICATION:
if (search_terms_args.page_classification !=
metrics::OmniboxEventProto::INVALID_SPEC) {
HandleReplacement(
"pgcl", base::IntToString(search_terms_args.page_classification),
*i, &url);
}
break;

case GOOGLE_PREFETCH_QUERY: {
const std::string& query = search_terms_args.prefetch_query;
const std::string& type = search_terms_args.prefetch_query_type;
if (!query.empty() && !type.empty()) {
HandleReplacement(
std::string(), "pfq=" + query + "&qha=" + type + "&", *i, &url);
}
break;
}

case GOOGLE_RLZ: {
DCHECK(!i->is_post_param);
// On platforms that don't have RLZ, we still want this branch
// to happen so that we replace the RLZ template with the
// empty string.  (If we don't handle this case, we hit a
// NOTREACHED below.)
base::string16 rlz_string = search_terms_data.GetRlzParameterValue(
search_terms_args.from_app_list);
if (!rlz_string.empty()) {
HandleReplacement("rlz", base::UTF16ToUTF8(rlz_string), *i, &url);
}
break;
}

case GOOGLE_SEARCH_CLIENT: {
DCHECK(!i->is_post_param);
std::string client = search_terms_data.GetSearchClient();
if (!client.empty())
HandleReplacement("client", client, *i, &url);
break;
}

case GOOGLE_SEARCH_FIELDTRIAL_GROUP:
// We are not currently running any fieldtrials that modulate the search
// url.  If we do, then we'd have some conditional insert such as:
// url.insert(i->index, used_www ? "gcx=w&" : "gcx=c&");
break;

case GOOGLE_SEARCH_VERSION:
HandleReplacement("gs_rn", "42", *i, &url);
break;

case GOOGLE_SESSION_TOKEN: {
std::string token = search_terms_args.session_token;
if (!token.empty())
HandleReplacement("psi", token, *i, &url);
break;
}

case GOOGLE_SUGGEST_CLIENT:
HandleReplacement(
std::string(), search_terms_data.GetSuggestClient(), *i, &url);
break;

case GOOGLE_SUGGEST_REQUEST_ID:
HandleReplacement(
std::string(), search_terms_data.GetSuggestRequestIdentifier(), *i,
&url);
break;

case GOOGLE_UNESCAPED_SEARCH_TERMS: {
std::string unescaped_terms;
base::UTF16ToCodepage(search_terms_args.search_terms,
input_encoding.c_str(),
base::OnStringConversionError::SKIP,
&unescaped_terms);
HandleReplacement(std::string(), unescaped_terms, *i, &url);
break;
}

case LANGUAGE:
HandleReplacement(
std::string(), search_terms_data.GetApplicationLocale(), *i, &url);
break;

case SEARCH_TERMS:
HandleReplacement(
std::string(), base::UTF16ToUTF8(encoded_terms), *i, &url);
break;

case GOOGLE_IMAGE_THUMBNAIL:
HandleReplacement(
std::string(), search_terms_args.image_thumbnail_content, *i, &url);
post_params_[i->index].content_type = "image/jpeg";
break;

case GOOGLE_IMAGE_URL:
if (search_terms_args.image_url.is_valid()) {
HandleReplacement(
std::string(), search_terms_args.image_url.spec(), *i, &url);
}
break;

case GOOGLE_IMAGE_ORIGINAL_WIDTH:
if (!search_terms_args.image_original_size.IsEmpty()) {
HandleReplacement(
std::string(),
base::IntToString(search_terms_args.image_original_size.width()),
*i, &url);
}
break;

case GOOGLE_IMAGE_ORIGINAL_HEIGHT:
if (!search_terms_args.image_original_size.IsEmpty()) {
HandleReplacement(
std::string(),
base::IntToString(search_terms_args.image_original_size.height()),
*i, &url);
}
break;

case GOOGLE_IMAGE_SEARCH_SOURCE:
HandleReplacement(
std::string(), search_terms_data.GoogleImageSearchSource(), *i,
&url);
break;

case GOOGLE_IOS_SEARCH_LANGUAGE:
#if defined(OS_IOS)
HandleReplacement("hl", search_terms_data.GetApplicationLocale(), *i,
&url);
#endif
break;

default:
NOTREACHED();
break;
}
}

if (!post_params_.empty())
EncodeFormData(post_params_, post_content);

return url;
}

bool TemplateURL::ExtractSearchTermsFromURL(
    const GURL& url,
    const SearchTermsData& search_terms_data,
    base::string16* search_terms) const {
  return FindSearchTermsInURL(url, search_terms_data, search_terms, NULL, NULL);
}
