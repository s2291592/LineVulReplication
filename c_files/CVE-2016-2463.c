void* H264SwDecMalloc(u32 size)
{

#if defined(CHECK_MEMORY_USAGE)
/* Note that if the decoder has to free and reallocate some of the buffers
* the total value will be invalid */
static u32 numBytes = 0;
    numBytes += size;
DEBUG(("Allocated %d bytes, total %d\n", size, numBytes));
#endif

    return malloc(size);
}

void H264SwDecRelease(H264SwDecInst decInst)
{

 decContainer_t *pDecCont;

    DEC_API_TRC("H264SwDecRelease#");

 if (decInst == NULL)
 {
        DEC_API_TRC("H264SwDecRelease# ERROR: decInst == NULL");
 return;
 }

    pDecCont = (decContainer_t*)decInst;

#ifdef H264DEC_TRACE
    sprintf(pDecCont->str, "H264SwDecRelease# decInst %p",decInst);
    DEC_API_TRC(pDecCont->str);
#endif

    h264bsdShutdown(&pDecCont->storage);

    H264SwDecFree(pDecCont);

}

u32 h264bsdPicHeight(storage_t *pStorage)
{

/* Variables */

/* Code */

    ASSERT(pStorage);

 if (pStorage->activeSps)
 return(pStorage->activeSps->picHeightInMbs);
 else
 return(0);

}

void H264SwDecFree(void *ptr)
{
    free(ptr);
}

void WriteOutput(FILE *fid, u8 *data, u32 picSize)
{
    fwrite(data, 1, picSize, fid);
}

H264SwDecRet H264SwDecNextPicture(H264SwDecInst decInst,
    H264SwDecPicture *pOutput, u32 flushBuffer)
{

 decContainer_t *pDecCont;
    u32 numErrMbs, isIdrPic, picId;
    u32 *pOutPic;

    DEC_API_TRC("H264SwDecNextPicture#");

 if (decInst == NULL || pOutput == NULL)
 {
        DEC_API_TRC("H264SwDecNextPicture# ERROR: decInst or pOutput is NULL");
 return(H264SWDEC_PARAM_ERR);
 }

    pDecCont = (decContainer_t*)decInst;

#ifdef H264DEC_TRACE
    sprintf(pDecCont->str, "H264SwDecNextPicture# decInst %p pOutput %p %s %d",
            decInst, (void*)pOutput, "flushBuffer", flushBuffer);
    DEC_API_TRC(pDecCont->str);
#endif

 if (flushBuffer)
        h264bsdFlushBuffer(&pDecCont->storage);

    pOutPic = (u32*)h264bsdNextOutputPicture(&pDecCont->storage, &picId,
 &isIdrPic, &numErrMbs);

 if (pOutPic == NULL)
 {
        DEC_API_TRC("H264SwDecNextPicture# OK: return H264SWDEC_OK");
 return(H264SWDEC_OK);
 }
 else
 {
        pOutput->pOutputPicture = pOutPic;
        pOutput->picId          = picId;
        pOutput->isIdrPicture   = isIdrPic;
        pOutput->nbrOfErrMBs    = numErrMbs;
        DEC_API_TRC("H264SwDecNextPicture# OK: return H264SWDEC_PIC_RDY");
 return(H264SWDEC_PIC_RDY);
 }

}

void* H264SwDecMalloc(u32 size)
{
    return malloc(size);
}

u32 h264bsdDecode(storage_t *pStorage, u8 *byteStrm, u32 len, u32 picId,
    u32 *readBytes)
{

/* Variables */

    u32 tmp, ppsId, spsId;
    i32 picOrderCnt;
 nalUnit_t nalUnit;
 seqParamSet_t seqParamSet;
 picParamSet_t picParamSet;
 strmData_t strm;
    u32 accessUnitBoundaryFlag = HANTRO_FALSE;
    u32 picReady = HANTRO_FALSE;

/* Code */

    ASSERT(pStorage);
    ASSERT(byteStrm);
    ASSERT(len);
    ASSERT(readBytes);

 /* if previous buffer was not finished and same pointer given -> skip NAL
     * unit extraction */
 if (pStorage->prevBufNotFinished && byteStrm == pStorage->prevBufPointer)
 {
        strm = pStorage->strm[0];
        strm.pStrmCurrPos = strm.pStrmBuffStart;
        strm.strmBuffReadBits = strm.bitPosInWord = 0;
 *readBytes = pStorage->prevBytesConsumed;
 }
 else
 {
        tmp = h264bsdExtractNalUnit(byteStrm, len, &strm, readBytes);
 if (tmp != HANTRO_OK)
 {
            EPRINT("BYTE_STREAM");
 return(H264BSD_ERROR);
 }
 /* store stream */
        pStorage->strm[0] = strm;
        pStorage->prevBytesConsumed = *readBytes;
        pStorage->prevBufPointer = byteStrm;
 }
    pStorage->prevBufNotFinished = HANTRO_FALSE;

    tmp = h264bsdDecodeNalUnit(&strm, &nalUnit);
 if (tmp != HANTRO_OK)
 {
        EPRINT("NAL_UNIT");
 return(H264BSD_ERROR);
 }

 /* Discard unspecified, reserved, SPS extension and auxiliary picture slices */
 if(nalUnit.nalUnitType == 0 || nalUnit.nalUnitType >= 13)
 {
        DEBUG(("DISCARDED NAL (UNSPECIFIED, REGISTERED, SPS ext or AUX slice)\n"));
 return(H264BSD_RDY);
 }

    tmp = h264bsdCheckAccessUnitBoundary(
 &strm,
 &nalUnit,
      pStorage,
 &accessUnitBoundaryFlag);
 if (tmp != HANTRO_OK)
 {
        EPRINT("ACCESS UNIT BOUNDARY CHECK");
 if (tmp == PARAM_SET_ERROR)
 return(H264BSD_PARAM_SET_ERROR);
 else
 return(H264BSD_ERROR);
 }

 if ( accessUnitBoundaryFlag )
 {
        DEBUG(("Access unit boundary\n"));
 /* conceal if picture started and param sets activated */
 if (pStorage->picStarted && pStorage->activeSps != NULL)
 {
            DEBUG(("CONCEALING..."));

 /* return error if second phase of
             * initialization is not completed */
 if (pStorage->pendingActivation)
 {
                EPRINT("Pending activation not completed");
 return (H264BSD_ERROR);
 }

 if (!pStorage->validSliceInAccessUnit)
 {
                pStorage->currImage->data =
                    h264bsdAllocateDpbImage(pStorage->dpb);
                h264bsdInitRefPicList(pStorage->dpb);
                tmp = h264bsdConceal(pStorage, pStorage->currImage, P_SLICE);
 }
 else
                tmp = h264bsdConceal(pStorage, pStorage->currImage,
                    pStorage->sliceHeader->sliceType);

            picReady = HANTRO_TRUE;

 /* current NAL unit should be decoded on next activation -> set
             * readBytes to 0 */
 *readBytes = 0;
            pStorage->prevBufNotFinished = HANTRO_TRUE;
            DEBUG(("...DONE\n"));
 }
 else
 {
            pStorage->validSliceInAccessUnit = HANTRO_FALSE;
 }
        pStorage->skipRedundantSlices = HANTRO_FALSE;
 }

 if (!picReady)
 {
 switch (nalUnit.nalUnitType)
 {
 case NAL_SEQ_PARAM_SET:
                DEBUG(("SEQ PARAM SET\n"));
                tmp = h264bsdDecodeSeqParamSet(&strm, &seqParamSet);
 if (tmp != HANTRO_OK)
 {
                    EPRINT("SEQ_PARAM_SET");
                    FREE(seqParamSet.offsetForRefFrame);
                    FREE(seqParamSet.vuiParameters);
 return(H264BSD_ERROR);
 }
                tmp = h264bsdStoreSeqParamSet(pStorage, &seqParamSet);
 break;

 case NAL_PIC_PARAM_SET:
                DEBUG(("PIC PARAM SET\n"));
                tmp = h264bsdDecodePicParamSet(&strm, &picParamSet);
 if (tmp != HANTRO_OK)
 {
                    EPRINT("PIC_PARAM_SET");
                    FREE(picParamSet.runLength);
                    FREE(picParamSet.topLeft);
                    FREE(picParamSet.bottomRight);
                    FREE(picParamSet.sliceGroupId);
 return(H264BSD_ERROR);
 }
                tmp = h264bsdStorePicParamSet(pStorage, &picParamSet);
 break;

 case NAL_CODED_SLICE_IDR:
                DEBUG(("IDR "));
 /* fall through */
 case NAL_CODED_SLICE:
                DEBUG(("SLICE HEADER\n"));

 /* picture successfully finished and still decoding same old
                 * access unit -> no need to decode redundant slices */
 if (pStorage->skipRedundantSlices)
 return(H264BSD_RDY);

                pStorage->picStarted = HANTRO_TRUE;

 if (h264bsdIsStartOfPicture(pStorage))
 {
                    pStorage->numConcealedMbs = 0;
                    pStorage->currentPicId    = picId;

                    tmp = h264bsdCheckPpsId(&strm, &ppsId);
                    ASSERT(tmp == HANTRO_OK);
 /* store old activeSpsId and return headers ready
                     * indication if activeSps changes */
                    spsId = pStorage->activeSpsId;
                    tmp = h264bsdActivateParamSets(pStorage, ppsId,
                            IS_IDR_NAL_UNIT(&nalUnit) ?
                            HANTRO_TRUE : HANTRO_FALSE);
 if (tmp != HANTRO_OK)
 {
                        EPRINT("Param set activation");
                        pStorage->activePpsId = MAX_NUM_PIC_PARAM_SETS;
                        pStorage->activePps = NULL;
                        pStorage->activeSpsId = MAX_NUM_SEQ_PARAM_SETS;
                        pStorage->activeSps = NULL;
                        pStorage->pendingActivation = HANTRO_FALSE;

 if(tmp == MEMORY_ALLOCATION_ERROR)
 {
 return H264BSD_MEMALLOC_ERROR;
 }
 else
 return(H264BSD_PARAM_SET_ERROR);
 }

 if (spsId != pStorage->activeSpsId)
 {
 seqParamSet_t *oldSPS = NULL;
 seqParamSet_t *newSPS = pStorage->activeSps;
                        u32 noOutputOfPriorPicsFlag = 1;

 if(pStorage->oldSpsId < MAX_NUM_SEQ_PARAM_SETS)
 {
                            oldSPS = pStorage->sps[pStorage->oldSpsId];
 }

 *readBytes = 0;
                        pStorage->prevBufNotFinished = HANTRO_TRUE;


 if(nalUnit.nalUnitType == NAL_CODED_SLICE_IDR)
 {
                            tmp =
                            h264bsdCheckPriorPicsFlag(&noOutputOfPriorPicsFlag,
 &strm, newSPS,
                                                          pStorage->activePps,
                                                          nalUnit.nalUnitType);
 }
 else
 {
                            tmp = HANTRO_NOK;
 }

 if((tmp != HANTRO_OK) ||
 (noOutputOfPriorPicsFlag != 0) ||
 (pStorage->dpb->noReordering) ||
 (oldSPS == NULL) ||
 (oldSPS->picWidthInMbs != newSPS->picWidthInMbs) ||
 (oldSPS->picHeightInMbs != newSPS->picHeightInMbs) ||
 (oldSPS->maxDpbSize != newSPS->maxDpbSize))
 {
                            pStorage->dpb->flushed = 0;
 }
 else
 {
                            h264bsdFlushDpb(pStorage->dpb);
 }

                        pStorage->oldSpsId = pStorage->activeSpsId;

 return(H264BSD_HDRS_RDY);
 }
 }

 /* return error if second phase of
                 * initialization is not completed */
 if (pStorage->pendingActivation)
 {
                    EPRINT("Pending activation not completed");
 return (H264BSD_ERROR);
 }
                tmp = h264bsdDecodeSliceHeader(&strm, pStorage->sliceHeader + 1,
                    pStorage->activeSps, pStorage->activePps, &nalUnit);
 if (tmp != HANTRO_OK)
 {
                    EPRINT("SLICE_HEADER");
 return(H264BSD_ERROR);
 }
 if (h264bsdIsStartOfPicture(pStorage))
 {
 if (!IS_IDR_NAL_UNIT(&nalUnit))
 {
                        tmp = h264bsdCheckGapsInFrameNum(pStorage->dpb,
                            pStorage->sliceHeader[1].frameNum,
                            nalUnit.nalRefIdc != 0 ?
                            HANTRO_TRUE : HANTRO_FALSE,
                            pStorage->activeSps->
                            gapsInFrameNumValueAllowedFlag);
 if (tmp != HANTRO_OK)
 {
                            EPRINT("Gaps in frame num");
 return(H264BSD_ERROR);
 }
 }
                    pStorage->currImage->data =
                        h264bsdAllocateDpbImage(pStorage->dpb);
 }

 /* store slice header to storage if successfully decoded */
                pStorage->sliceHeader[0] = pStorage->sliceHeader[1];
                pStorage->validSliceInAccessUnit = HANTRO_TRUE;
                pStorage->prevNalUnit[0] = nalUnit;

                h264bsdComputeSliceGroupMap(pStorage,
                    pStorage->sliceHeader->sliceGroupChangeCycle);

                h264bsdInitRefPicList(pStorage->dpb);
                tmp = h264bsdReorderRefPicList(pStorage->dpb,
 &pStorage->sliceHeader->refPicListReordering,
                    pStorage->sliceHeader->frameNum,
                    pStorage->sliceHeader->numRefIdxL0Active);
 if (tmp != HANTRO_OK)
 {
                    EPRINT("Reordering");
 return(H264BSD_ERROR);
 }

                DEBUG(("SLICE DATA, FIRST %d\n",
                        pStorage->sliceHeader->firstMbInSlice));
                tmp = h264bsdDecodeSliceData(&strm, pStorage,
                    pStorage->currImage, pStorage->sliceHeader);
 if (tmp != HANTRO_OK)
 {
                    EPRINT("SLICE_DATA");
                    h264bsdMarkSliceCorrupted(pStorage,
                        pStorage->sliceHeader->firstMbInSlice);
 return(H264BSD_ERROR);
 }

 if (h264bsdIsEndOfPicture(pStorage))
 {
                    picReady = HANTRO_TRUE;
                    pStorage->skipRedundantSlices = HANTRO_TRUE;
 }
 break;

 case NAL_SEI:
                DEBUG(("SEI MESSAGE, NOT DECODED"));
 break;

 default:
                DEBUG(("NOT IMPLEMENTED YET %d\n",nalUnit.nalUnitType));
 }
 }

 if (picReady)
 {
        h264bsdFilterPicture(pStorage->currImage, pStorage->mb);

        h264bsdResetStorage(pStorage);

        picOrderCnt = h264bsdDecodePicOrderCnt(pStorage->poc,
            pStorage->activeSps, pStorage->sliceHeader, pStorage->prevNalUnit);

 if (pStorage->validSliceInAccessUnit)
 {
 if (pStorage->prevNalUnit->nalRefIdc)
 {
                tmp = h264bsdMarkDecRefPic(pStorage->dpb,
 &pStorage->sliceHeader->decRefPicMarking,
                    pStorage->currImage, pStorage->sliceHeader->frameNum,
                    picOrderCnt,
                    IS_IDR_NAL_UNIT(pStorage->prevNalUnit) ?
                    HANTRO_TRUE : HANTRO_FALSE,
                    pStorage->currentPicId, pStorage->numConcealedMbs);
 }
 /* non-reference picture, just store for possible display
             * reordering */
 else
 {
                tmp = h264bsdMarkDecRefPic(pStorage->dpb, NULL,
                    pStorage->currImage, pStorage->sliceHeader->frameNum,
                    picOrderCnt,
                    IS_IDR_NAL_UNIT(pStorage->prevNalUnit) ?
                    HANTRO_TRUE : HANTRO_FALSE,
                    pStorage->currentPicId, pStorage->numConcealedMbs);
 }
 }

        pStorage->picStarted = HANTRO_FALSE;
        pStorage->validSliceInAccessUnit = HANTRO_FALSE;

 return(H264BSD_PIC_RDY);
 }
 else
 return(H264BSD_RDY);

}

void H264SwDecMemcpy(void *dest, void *src, u32 count)
{
    memcpy(dest, src, count);
}

u32 h264bsdMatrixCoefficients(storage_t *pStorage)
{

/* Variables */

/* Code */

    ASSERT(pStorage);

 if (pStorage->activeSps && pStorage->activeSps->vuiParametersPresentFlag &&
        pStorage->activeSps->vuiParameters &&
        pStorage->activeSps->vuiParameters->videoSignalTypePresentFlag &&
        pStorage->activeSps->vuiParameters->colourDescriptionPresentFlag)
 return(pStorage->activeSps->vuiParameters->matrixCoefficients);
 else /* default unspecified */
 return(2);

}

u8* h264bsdNextOutputPicture(storage_t *pStorage, u32 *picId, u32 *isIdrPic,
    u32 *numErrMbs)
{

/* Variables */

 dpbOutPicture_t *pOut;

/* Code */

    ASSERT(pStorage);

    pOut = h264bsdDpbOutputPicture(pStorage->dpb);

 if (pOut != NULL)
 {
 *picId = pOut->picId;
 *isIdrPic = pOut->isIdr;
 *numErrMbs = pOut->numErrMbs;
 return (pOut->data);
 }
 else
 return(NULL);

}

void H264SwDecTrace(char *string) {

     UNUSED(string);
 }

H264SwDecRet H264SwDecDecode(H264SwDecInst decInst, H264SwDecInput *pInput,
                  H264SwDecOutput *pOutput)
{

 decContainer_t *pDecCont;
    u32 strmLen;
    u32 numReadBytes;
    u8 *tmpStream;
    u32 decResult = 0;
    H264SwDecRet returnValue = H264SWDEC_STRM_PROCESSED;

    DEC_API_TRC("H264SwDecDecode#");

 /* Check that function input parameters are valid */
 if (pInput == NULL || pOutput == NULL)
 {
        DEC_API_TRC("H264SwDecDecode# ERROR: pInput or pOutput is NULL");
 return(H264SWDEC_PARAM_ERR);
 }

 if ((pInput->pStream == NULL) || (pInput->dataLen == 0))
 {
        DEC_API_TRC("H264SwDecDecode# ERROR: Invalid input parameters");
 return(H264SWDEC_PARAM_ERR);
 }

    pDecCont = (decContainer_t *)decInst;

 /* Check if decoder is in an incorrect mode */
 if (decInst == NULL || pDecCont->decStat == UNINITIALIZED)
 {
        DEC_API_TRC("H264SwDecDecode# ERROR: Decoder not initialized");
 return(H264SWDEC_NOT_INITIALIZED);
 }

#ifdef H264DEC_EVALUATION
 if (pDecCont->picNumber >= H264DEC_EVALUATION_LIMIT)
 return(H264SWDEC_EVALUATION_LIMIT_EXCEEDED);
#endif

#ifdef H264DEC_TRACE
    sprintf(pDecCont->str, "H264SwDecDecode# decInst %p  pInput %p  pOutput %p",
            decInst, (void*)pInput, (void*)pOutput);
    DEC_API_TRC(pDecCont->str);
#endif

    pOutput->pStrmCurrPos   = NULL;

    numReadBytes = 0;
    strmLen = pInput->dataLen;
    tmpStream = pInput->pStream;
    pDecCont->storage.intraConcealmentFlag = pInput->intraConcealmentMethod;

 do
 {
 /* Return HDRS_RDY after DPB flush caused by new SPS */
 if (pDecCont->decStat == NEW_HEADERS)
 {
            decResult = H264BSD_HDRS_RDY;
            pDecCont->decStat = INITIALIZED;
 }
 else /* Continue decoding normally */
 {
            decResult = h264bsdDecode(&pDecCont->storage, tmpStream, strmLen,
                pInput->picId, &numReadBytes);
 }
        tmpStream += numReadBytes;
 /* check if too many bytes are read from stream */
 if ( (i32)(strmLen - numReadBytes) >= 0 )
            strmLen -= numReadBytes;
 else
            strmLen = 0;

        pOutput->pStrmCurrPos = tmpStream;

 switch (decResult)
 {
 case H264BSD_HDRS_RDY:

 if(pDecCont->storage.dpb->flushed &&
                   pDecCont->storage.dpb->numOut !=
                   pDecCont->storage.dpb->outIndex)
 {
 /* output first all DPB stored pictures
                     * DPB flush caused by new SPS */
                    pDecCont->storage.dpb->flushed = 0;
                    pDecCont->decStat = NEW_HEADERS;
                    returnValue = H264SWDEC_PIC_RDY_BUFF_NOT_EMPTY;
                    strmLen = 0;
 }
 else
 {
                    returnValue = H264SWDEC_HDRS_RDY_BUFF_NOT_EMPTY;
                    strmLen = 0;
 }
 break;

 case H264BSD_PIC_RDY:
                pDecCont->picNumber++;

 if (strmLen == 0)
                    returnValue = H264SWDEC_PIC_RDY;
 else
                    returnValue = H264SWDEC_PIC_RDY_BUFF_NOT_EMPTY;

                strmLen = 0;
 break;

 case H264BSD_PARAM_SET_ERROR:
 if ( !h264bsdCheckValidParamSets(&pDecCont->storage) &&
                     strmLen == 0 )
 {
                    returnValue = H264SWDEC_STRM_ERR;
 }
 break;
 case H264BSD_MEMALLOC_ERROR:
 {
                    returnValue = H264SWDEC_MEMFAIL;
                    strmLen = 0;
 }
 break;
 default:
 break;
 }

 } while (strmLen);

#ifdef H264DEC_TRACE
    sprintf(pDecCont->str, "H264SwDecDecode# OK: DecResult %d",
            returnValue);
    DEC_API_TRC(pDecCont->str);
#endif

 return(returnValue);

}

u32 h264bsdPicWidth(storage_t *pStorage)
{

/* Variables */

/* Code */

    ASSERT(pStorage);

 if (pStorage->activeSps)
 return(pStorage->activeSps->picWidthInMbs);
 else
 return(0);

}

void H264SwDecMemcpy(void *dest, void *src, u32 count) {
    memcpy(dest, src, count);
}

int main(int argc, char **argv)
{

u8 *byteStrmStart;
u8 *byteStrm;
u32 strmLen;
u32 picSize;
H264SwDecInst decInst;
H264SwDecRet ret;
H264SwDecInput decInput;
H264SwDecOutput decOutput;
H264SwDecPicture decPicture;
H264SwDecInfo decInfo;
u32 picNumber;

FILE *finput;
FILE *foutput;

/* Check that enough command line arguments given, if not -> print usage
* information out */
if (argc < 2)
{
printf( "Usage: %s file.h264\n", argv[0]);
return -1;
}

/* open output file for writing, output file named out.yuv. If file open
* fails -> exit */
foutput = fopen("out.yuv", "wb");
if (foutput == NULL)
{
printf("UNABLE TO OPEN OUTPUT FILE\n");
return -1;
}

/* open input file for reading, file name given by user. If file open
* fails -> exit */
finput = fopen(argv[argc-1], "rb");
if (finput == NULL)
{
printf("UNABLE TO OPEN INPUT FILE\n");
return -1;
}

/* check size of the input file -> length of the stream in bytes */
fseek(finput, 0L, SEEK_END);
strmLen = (u32)ftell(finput);

rewind(finput);

/* allocate memory for stream buffer, exit if unsuccessful */
    byteStrm = byteStrmStart = (u8 *)H264SwDecMalloc(sizeof(u8)*strmLen);
if (byteStrm == NULL)
{
printf("UNABLE TO ALLOCATE MEMORY\n");
return -1;
}

/* read input stream from file to buffer and close input file */
fread(byteStrm, sizeof(u8), strmLen, finput);
fclose(finput);

/* initialize decoder. If unsuccessful -> exit */
ret = H264SwDecInit(&decInst, 0);
if (ret != H264SWDEC_OK)
{
printf("DECODER INITIALIZATION FAILED\n");
return -1;
}

/* initialize H264SwDecDecode() input structure */
decInput.pStream = byteStrmStart;
decInput.dataLen = strmLen;
decInput.intraConcealmentMethod = 0;

picNumber = 0;

/* For performance measurements, read the start time (in seconds) here.
* The decoding time should be measured over several frames and after
* that average fps (frames/second) can be calculated.
*
* startTime = GetTime();
*
* To prevent calculating file I/O latensies as a decoding time,
* comment out WriteOutput function call. Also prints to stdout might
* consume considerable amount of cycles during measurement */

/* main decoding loop */
do
{
/* call API function to perform decoding */
ret = H264SwDecDecode(decInst, &decInput, &decOutput);

switch(ret)
{

case H264SWDEC_HDRS_RDY_BUFF_NOT_EMPTY:

/* picture dimensions are available for query now */
ret = H264SwDecGetInfo(decInst, &decInfo);
if (ret != H264SWDEC_OK)
return -1;

/* picture size in pixels */
picSize = decInfo.picWidth * decInfo.picHeight;
/* memory needed for YCbCr 4:2:0 picture in bytes */
picSize = (3 * picSize)/2;
/* memory needed for 16-bit RGB picture in bytes
* picSize = (decInfo.picWidth * decInfo.picHeight) * 2; */

printf("Width %d Height %d\n",
decInfo.picWidth, decInfo.picHeight);

/* update H264SwDecDecode() input structure, number of bytes
* "consumed" is computed as difference between the new stream
* pointer and old stream pointer */
decInput.dataLen -=
(u32)(decOutput.pStrmCurrPos - decInput.pStream);
decInput.pStream = decOutput.pStrmCurrPos;
break;

case H264SWDEC_PIC_RDY_BUFF_NOT_EMPTY:
case H264SWDEC_PIC_RDY:

/* update H264SwDecDecode() input structure, number of bytes
* "consumed" is computed as difference between the new stream
* pointer and old stream pointer */
decInput.dataLen -=
(u32)(decOutput.pStrmCurrPos - decInput.pStream);
decInput.pStream = decOutput.pStrmCurrPos;

/* use function H264SwDecNextPicture() to obtain next picture
* in display order. Function is called until no more images
* are ready for display */
while (H264SwDecNextPicture(decInst, &decPicture, 0) ==
H264SWDEC_PIC_RDY) { picNumber++;

printf("PIC %d, type %s, concealed %d\n", picNumber,
decPicture.isIdrPicture ? "IDR" : "NON-IDR",
decPicture.nbrOfErrMBs);
fflush(stdout);

/* Do color conversion if needed to get display image
* in RGB-format
*
* YuvToRgb( decPicture.pOutputPicture, pRgbPicture ); */

/* write next display image to output file */
WriteOutput(foutput, (u8*)decPicture.pOutputPicture,
picSize);
}

break;

case H264SWDEC_EVALUATION_LIMIT_EXCEEDED:
/* evaluation version of the decoder has limited decoding
* capabilities */
printf("EVALUATION LIMIT REACHED\n");
goto end;

default:
printf("UNRECOVERABLE ERROR\n");
return -1;
}
/* keep decoding until all data from input stream buffer consumed */
} while (decInput.dataLen > 0);

end:

/* if output in display order is preferred, the decoder shall be forced
* to output pictures remaining in decoded picture buffer. Use function
* H264SwDecNextPicture() to obtain next picture in display order. Function
* is called until no more images are ready for display. Second parameter
* for the function is set to '1' to indicate that this is end of the
* stream and all pictures shall be output */
while (H264SwDecNextPicture(decInst, &decPicture, 1) ==
H264SWDEC_PIC_RDY) {

picNumber++;

printf("PIC %d, type %s, concealed %d\n", picNumber,
decPicture.isIdrPicture ? "IDR" : "NON-IDR",
decPicture.nbrOfErrMBs);
fflush(stdout);

/* Do color conversion if needed to get display image
* in RGB-format
*
* YuvToRgb( decPicture.pOutputPicture, pRgbPicture ); */

/* write next display image to output file */
WriteOutput(foutput, (u8*)decPicture.pOutputPicture, picSize);
}

/* For performance measurements, read the end time (in seconds) here.
*
* endTime = GetTime();
*
* Now the performance can be calculated as frames per second:
* fps = picNumber / (endTime - startTime); */


/* release decoder instance */
H264SwDecRelease(decInst);

/* close output file */
fclose(foutput);

/* free byte stream buffer */
free(byteStrmStart);

return 0;

}

H264SwDecRet H264SwDecGetInfo(H264SwDecInst decInst, H264SwDecInfo *pDecInfo)
{

 storage_t *pStorage;

    DEC_API_TRC("H264SwDecGetInfo#");

 if (decInst == NULL || pDecInfo == NULL)
 {
        DEC_API_TRC("H264SwDecGetInfo# ERROR: decInst or pDecInfo is NULL");
 return(H264SWDEC_PARAM_ERR);
 }

    pStorage = &(((decContainer_t *)decInst)->storage);

 if (pStorage->activeSps == NULL || pStorage->activePps == NULL)
 {
        DEC_API_TRC("H264SwDecGetInfo# ERROR: Headers not decoded yet");
 return(H264SWDEC_HDRS_NOT_RDY);
 }

#ifdef H264DEC_TRACE
    sprintf(((decContainer_t*)decInst)->str,
 "H264SwDecGetInfo# decInst %p  pDecInfo %p", decInst, (void*)pDecInfo);
    DEC_API_TRC(((decContainer_t*)decInst)->str);
#endif

 /* h264bsdPicWidth and -Height return dimensions in macroblock units,
     * picWidth and -Height in pixels */
    pDecInfo->picWidth        = h264bsdPicWidth(pStorage) << 4;
    pDecInfo->picHeight       = h264bsdPicHeight(pStorage) << 4;
    pDecInfo->videoRange      = h264bsdVideoRange(pStorage);
    pDecInfo->matrixCoefficients = h264bsdMatrixCoefficients(pStorage);

    h264bsdCroppingParams(pStorage,
 &pDecInfo->croppingFlag,
 &pDecInfo->cropParams.cropLeftOffset,
 &pDecInfo->cropParams.cropOutWidth,
 &pDecInfo->cropParams.cropTopOffset,
 &pDecInfo->cropParams.cropOutHeight);

 /* sample aspect ratio */
    h264bsdSampleAspectRatio(pStorage,
 &pDecInfo->parWidth,
 &pDecInfo->parHeight);

 /* profile */
    pDecInfo->profile = h264bsdProfile(pStorage);

    DEC_API_TRC("H264SwDecGetInfo# OK");

 return(H264SWDEC_OK);

}

void h264bsdFlushBuffer(storage_t *pStorage)
{

/* Variables */

/* Code */

    ASSERT(pStorage);

    h264bsdFlushDpb(pStorage->dpb);

}

H264SwDecApiVersion H264SwDecGetAPIVersion()
{
    H264SwDecApiVersion ver;

    ver.major = H264SWDEC_MAJOR_VERSION;
    ver.minor = H264SWDEC_MINOR_VERSION;

 return(ver);
}

void H264SwDecTrace(char *string)
{
 FILE *fp;

    fp = fopen("dec_api.trc", "at");

 if (!fp)
 return;

    fwrite(string, 1, strlen(string), fp);
    fwrite("\n", 1,1, fp);

    fclose(fp);
}

void H264SwDecMemset(void *ptr, i32 value, u32 count)
{
    memset(ptr, value, count);
}

void h264bsdCroppingParams(storage_t *pStorage, u32 *croppingFlag,
    u32 *leftOffset, u32 *width, u32 *topOffset, u32 *height)
{

/* Variables */

/* Code */

    ASSERT(pStorage);

 if (pStorage->activeSps && pStorage->activeSps->frameCroppingFlag)
 {
 *croppingFlag = 1;
 *leftOffset = 2 * pStorage->activeSps->frameCropLeftOffset;
 *width = 16 * pStorage->activeSps->picWidthInMbs -
 2 * (pStorage->activeSps->frameCropLeftOffset +
                      pStorage->activeSps->frameCropRightOffset);
 *topOffset = 2 * pStorage->activeSps->frameCropTopOffset;
 *height = 16 * pStorage->activeSps->picHeightInMbs -
 2 * (pStorage->activeSps->frameCropTopOffset +
                       pStorage->activeSps->frameCropBottomOffset);
 }
 else
 {
 *croppingFlag = 0;
 *leftOffset = 0;
 *width = 0;
 *topOffset = 0;
 *height = 0;
 }

}

void* H264SwDecMalloc(u32 size) {
    return malloc(size);
}

void h264bsdSampleAspectRatio(storage_t *pStorage, u32 *sarWidth, u32 *sarHeight)
{

/* Variables */
    u32 w = 1;
    u32 h = 1;
/* Code */

    ASSERT(pStorage);


 if (pStorage->activeSps &&
        pStorage->activeSps->vuiParametersPresentFlag &&
        pStorage->activeSps->vuiParameters &&
        pStorage->activeSps->vuiParameters->aspectRatioPresentFlag )
 {
 switch (pStorage->activeSps->vuiParameters->aspectRatioIdc)
 {
 case ASPECT_RATIO_UNSPECIFIED:  w = 0; h = 0; break;
 case ASPECT_RATIO_1_1:          w = 1; h = 1; break;
 case ASPECT_RATIO_12_11:        w = 12; h = 11; break;
 case ASPECT_RATIO_10_11:        w = 10; h = 11; break;
 case ASPECT_RATIO_16_11:        w = 16; h = 11; break;
 case ASPECT_RATIO_40_33:        w = 40; h = 33; break;
 case ASPECT_RATIO_24_11:        w = 24; h = 11; break;
 case ASPECT_RATIO_20_11:        w = 20; h = 11; break;
 case ASPECT_RATIO_32_11:        w = 32; h = 11; break;
 case ASPECT_RATIO_80_33:        w = 80; h = 33; break;
 case ASPECT_RATIO_18_11:        w = 18; h = 11; break;
 case ASPECT_RATIO_15_11:        w = 15; h = 11; break;
 case ASPECT_RATIO_64_33:        w = 64; h = 33; break;
 case ASPECT_RATIO_160_99:       w = 160; h = 99; break;
 case ASPECT_RATIO_EXTENDED_SAR:
                w = pStorage->activeSps->vuiParameters->sarWidth;
                h = pStorage->activeSps->vuiParameters->sarHeight;
 if ((w == 0) || (h == 0))
                    w = h = 0;
 break;
 default:
                w = 0;
                h = 0;
 break;
 }
 }

 /* set aspect ratio*/
 *sarWidth = w;
 *sarHeight = h;

}

H264SwDecRet H264SwDecInit(H264SwDecInst *decInst, u32 noOutputReordering)
{
u32 rv = 0;

decContainer_t *pDecCont;

DEC_API_TRC("H264SwDecInit#");

/* check that right shift on negative numbers is performed signed */
/*lint -save -e* following check causes multiple lint messages */
if ( ((-1)>>1) != (-1) )
{
DEC_API_TRC("H264SwDecInit# ERROR: Right shift is not signed");
return(H264SWDEC_INITFAIL);
}
/*lint -restore */

if (decInst == NULL)
{
DEC_API_TRC("H264SwDecInit# ERROR: decInst == NULL");

return(H264SWDEC_PARAM_ERR);
}

    pDecCont = (decContainer_t *)H264SwDecMalloc(sizeof(decContainer_t));

if (pDecCont == NULL)
{
DEC_API_TRC("H264SwDecInit# ERROR: Memory allocation failed");
return(H264SWDEC_MEMFAIL);
}

#ifdef H264DEC_TRACE
sprintf(pDecCont->str, "H264SwDecInit# decInst %p noOutputReordering %d",
(void*)decInst, noOutputReordering);
DEC_API_TRC(pDecCont->str);
#endif

rv = h264bsdInit(&pDecCont->storage, noOutputReordering);
if (rv != HANTRO_OK)
{
H264SwDecRelease(pDecCont);
return(H264SWDEC_MEMFAIL);
}

pDecCont->decStat  = INITIALIZED;
pDecCont->picNumber = 0;

#ifdef H264DEC_TRACE
sprintf(pDecCont->str, "H264SwDecInit# OK: return %p", (void*)pDecCont);
DEC_API_TRC(pDecCont->str);
#endif

*decInst = (decContainer_t *)pDecCont;

return(H264SWDEC_OK);

}

void H264SwDecMemset(void *ptr, i32 value, u32 count) {
    memset(ptr, value, count);
}

u32 CropPicture(u8 *pOutImage, u8 *pInImage,
    u32 picWidth, u32 picHeight, CropParams *pCropParams)
{

    u32 i, j;
    u32 outWidth, outHeight;
    u8 *pOut, *pIn;

 if (pOutImage == NULL || pInImage == NULL || pCropParams == NULL ||
 !picWidth || !picHeight)
 {
 /* just to prevent lint warning, returning non-zero will result in
         * return without freeing the memory */
        free(pOutImage);
 return(1);
 }

 if ( ((pCropParams->cropLeftOffset + pCropParams->cropOutWidth) >
           picWidth ) ||
 ((pCropParams->cropTopOffset + pCropParams->cropOutHeight) >
           picHeight ) )
 {
 /* just to prevent lint warning, returning non-zero will result in
         * return without freeing the memory */
        free(pOutImage);
 return(1);
 }

    outWidth = pCropParams->cropOutWidth;
    outHeight = pCropParams->cropOutHeight;

 /* Calculate starting pointer for luma */
    pIn = pInImage + pCropParams->cropTopOffset*picWidth +
        pCropParams->cropLeftOffset;
    pOut = pOutImage;

 /* Copy luma pixel values */
 for (i = outHeight; i; i--)
 {
 for (j = outWidth; j; j--)
 {
 *pOut++ = *pIn++;
 }
        pIn += picWidth - outWidth;
 }

    outWidth >>= 1;
    outHeight >>= 1;

 /* Calculate starting pointer for cb */
    pIn = pInImage + picWidth*picHeight +
        pCropParams->cropTopOffset*picWidth/4 + pCropParams->cropLeftOffset/2;

 /* Copy cb pixel values */
 for (i = outHeight; i; i--)
 {
 for (j = outWidth; j; j--)
 {
 *pOut++ = *pIn++;
 }
        pIn += picWidth/2 - outWidth;
 }

 /* Calculate starting pointer for cr */
    pIn = pInImage + 5*picWidth*picHeight/4 +
        pCropParams->cropTopOffset*picWidth/4 + pCropParams->cropLeftOffset/2;

 /* Copy cr pixel values */
 for (i = outHeight; i; i--)
 {
 for (j = outWidth; j; j--)
 {
 *pOut++ = *pIn++;
 }
        pIn += picWidth/2 - outWidth;
 }

 return (0);
}

void CropWriteOutput(FILE *foutput, u8 *imageData, u32 cropDisplay,
        H264SwDecInfo *decInfo)
{
    u8 *tmpImage = NULL;
    u32 tmp, picSize;

 if (cropDisplay && decInfo->croppingFlag)
 {
        picSize = decInfo->cropParams.cropOutWidth *
                  decInfo->cropParams.cropOutHeight;
        picSize = (3 * picSize)/2;
        tmpImage = malloc(picSize);
 if (tmpImage == NULL)
            exit(1);
        tmp = CropPicture(tmpImage, imageData,
            decInfo->picWidth, decInfo->picHeight,
 &(decInfo->cropParams));
 if (tmp)
            exit(1);
 WriteOutput(foutput, tmpImage, picSize);
        free(tmpImage);
 }
 else
 {
        picSize = decInfo->picWidth * decInfo->picHeight;
        picSize = (3 * picSize)/2;
 WriteOutput(foutput, imageData, picSize);
 }

}

u32 h264bsdProfile(storage_t *pStorage)
{
 if (pStorage->activeSps)
 return pStorage->activeSps->profileIdc;
 else
 return 0;
}

u32 CropPicture(u8 *pOutImage, u8 *pInImage,
    u32 picWidth, u32 picHeight, CropParams *pCropParams)
{

    u32 i, j;
    u32 outWidth, outHeight;
    u8 *pOut, *pIn;

 if (pOutImage == NULL || pInImage == NULL || pCropParams == NULL ||
 !picWidth || !picHeight)
 {
 /* due to lint warning */
        free(pOutImage);
 return(1);
 }

 if ( ((pCropParams->cropLeftOffset + pCropParams->cropOutWidth) >
           picWidth ) ||
 ((pCropParams->cropTopOffset + pCropParams->cropOutHeight) >
           picHeight ) )
 {
 /* due to lint warning */
        free(pOutImage);
 return(1);
 }

    outWidth = pCropParams->cropOutWidth;
    outHeight = pCropParams->cropOutHeight;

    pIn = pInImage + pCropParams->cropTopOffset*picWidth +
        pCropParams->cropLeftOffset;
    pOut = pOutImage;

 /* luma */
 for (i = outHeight; i; i--)
 {
 for (j = outWidth; j; j--)
 {
 *pOut++ = *pIn++;
 }
        pIn += picWidth - outWidth;
 }

    outWidth >>= 1;
    outHeight >>= 1;

    pIn = pInImage + picWidth*picHeight +
        pCropParams->cropTopOffset*picWidth/4 + pCropParams->cropLeftOffset/2;

 /* cb */
 for (i = outHeight; i; i--)
 {
 for (j = outWidth; j; j--)
 {
 *pOut++ = *pIn++;
 }
        pIn += picWidth/2 - outWidth;
 }

    pIn = pInImage + 5*picWidth*picHeight/4 +
        pCropParams->cropTopOffset*picWidth/4 + pCropParams->cropLeftOffset/2;

 /* cr */
 for (i = outHeight; i; i--)
 {
 for (j = outWidth; j; j--)
 {
 *pOut++ = *pIn++;
 }
        pIn += picWidth/2 - outWidth;
 }

 return (0);

}

int $Sub$$main(char argc, char * argv[])
{
  cache_init(); // does some extra setup work setting up caches
 return $Super$$main(argc, argv); // calls the original function
}

u32 h264bsdVideoRange(storage_t *pStorage)
{

/* Variables */

/* Code */

    ASSERT(pStorage);

 if (pStorage->activeSps && pStorage->activeSps->vuiParametersPresentFlag &&
        pStorage->activeSps->vuiParameters &&
        pStorage->activeSps->vuiParameters->videoSignalTypePresentFlag &&
        pStorage->activeSps->vuiParameters->videoFullRangeFlag)
 return(1);
 else /* default value of video_full_range_flag is 0 */
 return(0);

}

u32 h264bsdCheckValidParamSets(storage_t *pStorage)
{

/* Variables */

/* Code */

    ASSERT(pStorage);

 return(h264bsdValidParamSets(pStorage) == HANTRO_OK ? 1 : 0);

}

int main(int argc, char **argv)
{

    u32 i, tmp;
    u32 maxNumPics = 0;
    u8 *byteStrmStart;
    u8 *imageData;
    u8 *tmpImage = NULL;
    u32 strmLen;
    u32 picSize;
    H264SwDecInst decInst;
    H264SwDecRet ret;
    H264SwDecInput decInput;
    H264SwDecOutput decOutput;
    H264SwDecPicture decPicture;
    H264SwDecInfo decInfo;
    H264SwDecApiVersion decVer;
    u32 picDecodeNumber;
    u32 picDisplayNumber;
    u32 numErrors = 0;
    u32 cropDisplay = 0;
    u32 disableOutputReordering = 0;

 FILE *finput;

 char outFileName[256] = "";

 /* Print API version number */
    decVer = H264SwDecGetAPIVersion();
    DEBUG(("H.264 Decoder API v%d.%d\n", decVer.major, decVer.minor));

 /* Print tag name if '-T' argument present */
 if ( argc > 1 && strcmp(argv[1], "-T") == 0 )
 {
        DEBUG(("%s\n", tagName));
 return 0;
 }

 /* Check that enough command line arguments given, if not -> print usage
     * information out */
 if (argc < 2)
 {
        DEBUG((
 "Usage: %s [-Nn] [-Ooutfile] [-P] [-U] [-C] [-R] [-T] file.h264\n",
            argv[0]));
        DEBUG(("\t-Nn forces decoding to stop after n pictures\n"));
#if defined(_NO_OUT)
        DEBUG(("\t-Ooutfile output writing disabled at compile time\n"));
#else
        DEBUG(("\t-Ooutfile write output to \"outfile\" (default out_wxxxhyyy.yuv)\n"));
        DEBUG(("\t-Onone does not write output\n"));
#endif
        DEBUG(("\t-P packet-by-packet mode\n"));
        DEBUG(("\t-U NAL unit stream mode\n"));
        DEBUG(("\t-C display cropped image (default decoded image)\n"));
        DEBUG(("\t-R disable DPB output reordering\n"));
        DEBUG(("\t-T to print tag name and exit\n"));
 return 0;
 }

 /* read command line arguments */
 for (i = 1; i < (u32)(argc-1); i++)
 {
 if ( strncmp(argv[i], "-N", 2) == 0 )
 {
            maxNumPics = (u32)atoi(argv[i]+2);
 }
 else if ( strncmp(argv[i], "-O", 2) == 0 )
 {
            strcpy(outFileName, argv[i]+2);
 }
 else if ( strcmp(argv[i], "-P") == 0 )
 {
            packetize = 1;
 }
 else if ( strcmp(argv[i], "-U") == 0 )
 {
            nalUnitStream = 1;
 }
 else if ( strcmp(argv[i], "-C") == 0 )
 {
            cropDisplay = 1;
 }
 else if ( strcmp(argv[i], "-R") == 0 )
 {
            disableOutputReordering = 1;
 }
 }

 /* open input file for reading, file name given by user. If file open
     * fails -> exit */
    finput = fopen(argv[argc-1],"rb");
 if (finput == NULL)
 {
        DEBUG(("UNABLE TO OPEN INPUT FILE\n"));
 return -1;
 }

 /* check size of the input file -> length of the stream in bytes */
    fseek(finput,0L,SEEK_END);
    strmLen = (u32)ftell(finput);
    rewind(finput);

 /* allocate memory for stream buffer. if unsuccessful -> exit */
    byteStrmStart = (u8 *)malloc(sizeof(u8)*strmLen);
 if (byteStrmStart == NULL)
 {
        DEBUG(("UNABLE TO ALLOCATE MEMORY\n"));
 return -1;
 }

 /* read input stream from file to buffer and close input file */
    fread(byteStrmStart, sizeof(u8), strmLen, finput);
    fclose(finput);

 /* initialize decoder. If unsuccessful -> exit */
    ret = H264SwDecInit(&decInst, disableOutputReordering);
 if (ret != H264SWDEC_OK)
 {
        DEBUG(("DECODER INITIALIZATION FAILED\n"));
        free(byteStrmStart);
 return -1;
 }

 /* initialize H264SwDecDecode() input structure */
    streamStop = byteStrmStart + strmLen;
    decInput.pStream = byteStrmStart;
    decInput.dataLen = strmLen;
    decInput.intraConcealmentMethod = 0;

 /* get pointer to next packet and the size of packet
     * (for packetize or nalUnitStream modes) */
 if ( (tmp = NextPacket(&decInput.pStream)) != 0 )
        decInput.dataLen = tmp;

    picDecodeNumber = picDisplayNumber = 1;
 /* main decoding loop */
 do
 {
 /* Picture ID is the picture number in decoding order */
        decInput.picId = picDecodeNumber;

 /* call API function to perform decoding */
        ret = H264SwDecDecode(decInst, &decInput, &decOutput);

 switch(ret)
 {

 case H264SWDEC_HDRS_RDY_BUFF_NOT_EMPTY:
 /* Stream headers were successfully decoded
                 * -> stream information is available for query now */

                ret = H264SwDecGetInfo(decInst, &decInfo);
 if (ret != H264SWDEC_OK)
 return -1;

                DEBUG(("Profile %d\n", decInfo.profile));

                DEBUG(("Width %d Height %d\n",
                    decInfo.picWidth, decInfo.picHeight));

 if (cropDisplay && decInfo.croppingFlag)
 {
                    DEBUG(("Cropping params: (%d, %d) %dx%d\n",
                        decInfo.cropParams.cropLeftOffset,
                        decInfo.cropParams.cropTopOffset,
                        decInfo.cropParams.cropOutWidth,
                        decInfo.cropParams.cropOutHeight));

 /* Cropped frame size in planar YUV 4:2:0 */
                    picSize = decInfo.cropParams.cropOutWidth *
                              decInfo.cropParams.cropOutHeight;
                    picSize = (3 * picSize)/2;
                    tmpImage = malloc(picSize);
 if (tmpImage == NULL)
 return -1;
 }
 else
 {
 /* Decoder output frame size in planar YUV 4:2:0 */
                    picSize = decInfo.picWidth * decInfo.picHeight;
                    picSize = (3 * picSize)/2;
 }

                DEBUG(("videoRange %d, matrixCoefficients %d\n",
                    decInfo.videoRange, decInfo.matrixCoefficients));

 /* update H264SwDecDecode() input structure, number of bytes
                 * "consumed" is computed as difference between the new stream
                 * pointer and old stream pointer */
                decInput.dataLen -=
 (u32)(decOutput.pStrmCurrPos - decInput.pStream);
                decInput.pStream = decOutput.pStrmCurrPos;

 /* If -O option not used, generate default file name */
 if (outFileName[0] == 0)
                    sprintf(outFileName, "out_w%dh%d.yuv",
                            decInfo.picWidth, decInfo.picHeight);
 break;

 case H264SWDEC_PIC_RDY_BUFF_NOT_EMPTY:
 /* Picture is ready and more data remains in input buffer
                 * -> update H264SwDecDecode() input structure, number of bytes
                 * "consumed" is computed as difference between the new stream
                 * pointer and old stream pointer */
                decInput.dataLen -=
 (u32)(decOutput.pStrmCurrPos - decInput.pStream);
                decInput.pStream = decOutput.pStrmCurrPos;
 /* fall through */

 case H264SWDEC_PIC_RDY:

 /*lint -esym(644,tmpImage,picSize) variable initialized at
                 * H264SWDEC_HDRS_RDY_BUFF_NOT_EMPTY case */

 if (ret == H264SWDEC_PIC_RDY)
                    decInput.dataLen = NextPacket(&decInput.pStream);

 /* If enough pictures decoded -> force decoding to end
                 * by setting that no more stream is available */
 if (maxNumPics && picDecodeNumber == maxNumPics)
                    decInput.dataLen = 0;

 /* Increment decoding number for every decoded picture */
                picDecodeNumber++;

 /* use function H264SwDecNextPicture() to obtain next picture
                 * in display order. Function is called until no more images
                 * are ready for display */
 while ( H264SwDecNextPicture(decInst, &decPicture, 0) ==
                        H264SWDEC_PIC_RDY )
 {
                    DEBUG(("PIC %d, type %s", picDisplayNumber,
                        decPicture.isIdrPicture ? "IDR" : "NON-IDR"));
 if (picDisplayNumber != decPicture.picId)
                        DEBUG((", decoded pic %d", decPicture.picId));
 if (decPicture.nbrOfErrMBs)
 {
                        DEBUG((", concealed %d\n", decPicture.nbrOfErrMBs));
 }
 else
                        DEBUG(("\n"));
                    fflush(stdout);

                    numErrors += decPicture.nbrOfErrMBs;

 /* Increment display number for every displayed picture */
                    picDisplayNumber++;

 /*lint -esym(644,decInfo) always initialized if pictures
                     * available for display */

 /* Write output picture to file */
                    imageData = (u8*)decPicture.pOutputPicture;
 if (cropDisplay && decInfo.croppingFlag)
 {
                        tmp = CropPicture(tmpImage, imageData,
                            decInfo.picWidth, decInfo.picHeight,
 &decInfo.cropParams);
 if (tmp)
 return -1;
 WriteOutput(outFileName, tmpImage, picSize);
 }
 else
 {
 WriteOutput(outFileName, imageData, picSize);
 }
 }

 break;

 case H264SWDEC_STRM_PROCESSED:
 case H264SWDEC_STRM_ERR:
 /* Input stream was decoded but no picture is ready
                 * -> Get more data */
                decInput.dataLen = NextPacket(&decInput.pStream);
 break;

 default:
                DEBUG(("FATAL ERROR\n"));
 return -1;

 }
 /* keep decoding until all data from input stream buffer consumed */
 } while (decInput.dataLen > 0);

 /* if output in display order is preferred, the decoder shall be forced
     * to output pictures remaining in decoded picture buffer. Use function
     * H264SwDecNextPicture() to obtain next picture in display order. Function
     * is called until no more images are ready for display. Second parameter
     * for the function is set to '1' to indicate that this is end of the
     * stream and all pictures shall be output */
 while (H264SwDecNextPicture(decInst, &decPicture, 1) == H264SWDEC_PIC_RDY)
 {
        DEBUG(("PIC %d, type %s", picDisplayNumber,
            decPicture.isIdrPicture ? "IDR" : "NON-IDR"));
 if (picDisplayNumber != decPicture.picId)
            DEBUG((", decoded pic %d", decPicture.picId));
 if (decPicture.nbrOfErrMBs)
 {
            DEBUG((", concealed %d\n", decPicture.nbrOfErrMBs));
 }
 else
            DEBUG(("\n"));
        fflush(stdout);

        numErrors += decPicture.nbrOfErrMBs;

 /* Increment display number for every displayed picture */
        picDisplayNumber++;

 /* Write output picture to file */
        imageData = (u8*)decPicture.pOutputPicture;
 if (cropDisplay && decInfo.croppingFlag)
 {
            tmp = CropPicture(tmpImage, imageData,
                decInfo.picWidth, decInfo.picHeight,
 &decInfo.cropParams);
 if (tmp)
 return -1;
 WriteOutput(outFileName, tmpImage, picSize);
 }
 else
 {
 WriteOutput(outFileName, imageData, picSize);
 }
 }

 /* release decoder instance */
    H264SwDecRelease(decInst);

 if (foutput)
        fclose(foutput);

 /* free allocated buffers */
    free(byteStrmStart);
    free(tmpImage);

    DEBUG(("Output file: %s\n", outFileName));

    DEBUG(("DECODING DONE\n"));
 if (numErrors || picDecodeNumber == 1)
 {
        DEBUG(("ERRORS FOUND\n"));
 return 1;
 }

 return 0;
}
