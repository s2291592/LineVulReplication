  static std::unique_ptr<NavigationThrottle> Create(NavigationHandle* handle) {
    return std::make_unique<RequestBlockingNavigationThrottle>(handle);
  }

  std::unique_ptr<content::URLLoaderInterceptor> SetupRequestFailForURL(
      const GURL& url) {
    return URLLoaderInterceptor::SetupRequestFailForURL(url,
                                                        net::ERR_DNS_TIMED_OUT);
  }

GURL SiteInstance::GetSiteForURL(BrowserContext* browser_context,
                                 const GURL& url) {
  return SiteInstanceImpl::GetSiteForURL(browser_context, url,
                                         true /* should_use_effective_urls */);
}

GURL SiteInstanceImpl::DetermineProcessLockURL(BrowserContext* browser_context,
                                               const GURL& url) {
  return SiteInstanceImpl::GetSiteForURL(browser_context, url,
                                         false /* should_use_effective_urls */);
}

  void AssertForegroundAndRepost(const base::Process& renderer_process) {
    ASSERT_FALSE(renderer_process.IsProcessBackgrounded());
    base::ThreadTaskRunnerHandle::Get()->PostDelayedTask(
        FROM_HERE,
        base::BindOnce(&AssertForegroundHelper::AssertForegroundAndRepost,
                       weak_ptr_factory_.GetWeakPtr(),
                       base::ConstRef(renderer_process)),
        base::TimeDelta::FromMilliseconds(1));
  }

  RenderFrameHostManagerUnloadBrowserTest() {}

RenderProcessHost* SiteInstanceImpl::GetProcess() {

  if (!process_) {
    BrowserContext* browser_context = browsing_instance_->browser_context();

    bool should_use_process_per_site =
        has_site_ &&
        RenderProcessHost::ShouldUseProcessPerSite(browser_context, site_);
    if (should_use_process_per_site) {
      process_reuse_policy_ = ProcessReusePolicy::PROCESS_PER_SITE;
    } else if (process_reuse_policy_ == ProcessReusePolicy::PROCESS_PER_SITE) {
      process_reuse_policy_ = ProcessReusePolicy::DEFAULT;
    }

    process_ = RenderProcessHostImpl::GetProcessHostForSiteInstance(this);

    CHECK(process_);
    process_->AddObserver(this);

    if (process_reuse_policy_ == ProcessReusePolicy::PROCESS_PER_SITE &&
        has_site_) {
      RenderProcessHostImpl::RegisterSoleProcessHostForSite(browser_context,
                                                            process_, this);
    }

    TRACE_EVENT2("navigation", "SiteInstanceImpl::GetProcess",
                 "site id", id_, "process id", process_->GetID());
    GetContentClient()->browser()->SiteInstanceGotProcess(this);

    if (has_site_)
      LockToOriginIfNeeded();
  }
  DCHECK(process_);

  return process_;
}

void SiteInstanceImpl::LockToOriginIfNeeded() {
  DCHECK(HasSite());

  process_->SetIsUsed();

  ChildProcessSecurityPolicyImpl* policy =
      ChildProcessSecurityPolicyImpl::GetInstance();
  auto lock_state = policy->CheckOriginLock(process_->GetID(), lock_url());
  if (ShouldLockToOrigin(GetBrowserContext(), site_)) {
    CHECK(!process_->IsForGuestsOnly());

    switch (lock_state) {
      case CheckOriginLockResult::NO_LOCK: {
        TRACE_EVENT2("navigation", "SiteInstanceImpl::LockToOrigin", "site id",
                     id_, "lock", lock_url().possibly_invalid_spec());
        process_->LockToOrigin(lock_url());
        break;
      }
      case CheckOriginLockResult::HAS_WRONG_LOCK:
        base::debug::SetCrashKeyString(bad_message::GetRequestedSiteURLKey(),
                                       site_.spec());
        base::debug::SetCrashKeyString(
            bad_message::GetKilledProcessOriginLockKey(),
            policy->GetOriginLock(process_->GetID()).spec());
        CHECK(false) << "Trying to lock a process to " << lock_url()
                     << " but the process is already locked to "
                     << policy->GetOriginLock(process_->GetID());
        break;
      case CheckOriginLockResult::HAS_EQUAL_LOCK:
        break;
      default:
        NOTREACHED();
    }
  } else {
    if (lock_state != CheckOriginLockResult::NO_LOCK) {
      base::debug::SetCrashKeyString(bad_message::GetRequestedSiteURLKey(),
                                     site_.spec());
      base::debug::SetCrashKeyString(
          bad_message::GetKilledProcessOriginLockKey(),
          policy->GetOriginLock(process_->GetID()).spec());
      CHECK(false) << "Trying to commit non-isolated site " << site_
                   << " in process locked to "
                   << policy->GetOriginLock(process_->GetID());
    }
  }
}

void SiteInstanceImpl::SetSite(const GURL& url) {
  TRACE_EVENT2("navigation", "SiteInstanceImpl::SetSite",
               "site id", id_, "url", url.possibly_invalid_spec());
  DCHECK(!has_site_);

  has_site_ = true;
  BrowserContext* browser_context = browsing_instance_->browser_context();
  site_ =
      GetSiteForURL(browser_context, url, true /* should_use_effective_urls */);
  original_url_ = url;
  lock_url_ = DetermineProcessLockURL(browser_context, url);

  browsing_instance_->RegisterSiteInstance(this);

  bool should_use_process_per_site =
      RenderProcessHost::ShouldUseProcessPerSite(browser_context, site_);
  if (should_use_process_per_site) {
    process_reuse_policy_ = ProcessReusePolicy::PROCESS_PER_SITE;
  }

  if (process_) {
    LockToOriginIfNeeded();

    if (should_use_process_per_site) {
      RenderProcessHostImpl::RegisterSoleProcessHostForSite(browser_context,
                                                            process_, this);
    }
  }
}

bool SiteInstanceImpl::HasWrongProcessForURL(const GURL& url) {
  if (!HasProcess())
    return false;

  if (IsRendererDebugURL(url))
    return false;

  if (url.IsAboutBlank() && site_ != GURL(kUnreachableWebDataURL))
    return false;

  GURL site_url =
      SiteInstance::GetSiteForURL(browsing_instance_->browser_context(), url);
  GURL origin_lock =
      DetermineProcessLockURL(browsing_instance_->browser_context(), url);
  return !RenderProcessHostImpl::IsSuitableHost(
      GetProcess(), browsing_instance_->browser_context(), site_url,
      origin_lock);
}

  void AssertForegroundAndRepost(const base::Process& renderer_process,
                                 base::PortProvider* port_provider) {
    ASSERT_FALSE(renderer_process.IsProcessBackgrounded(port_provider));
    base::ThreadTaskRunnerHandle::Get()->PostDelayedTask(
        FROM_HERE,
        base::BindOnce(&AssertForegroundHelper::AssertForegroundAndRepost,
                       weak_ptr_factory_.GetWeakPtr(),
                       base::ConstRef(renderer_process), port_provider),
        base::TimeDelta::FromMilliseconds(1));
  }

  void TestWebFrameInWebUIProcessDisallowed(int bindings) {
    FrameTreeNode* root = static_cast<WebContentsImpl*>(shell()->web_contents())
                              ->GetFrameTree()
                              ->root();
    GURL data_url("data:text/html,a data url document");
    EXPECT_TRUE(NavigateToURL(shell(), data_url));
    EXPECT_EQ(data_url, root->current_frame_host()->GetLastCommittedURL());
    EXPECT_FALSE(
        ChildProcessSecurityPolicyImpl::GetInstance()->HasWebUIBindings(
            root->current_frame_host()->GetProcess()->GetID()));

    ChildProcessSecurityPolicyImpl::GetInstance()->GrantWebUIBindings(
        root->current_frame_host()->GetProcess()->GetID(), bindings);
    EXPECT_TRUE(ChildProcessSecurityPolicyImpl::GetInstance()->HasWebUIBindings(
        root->current_frame_host()->GetProcess()->GetID()));
    {
      GURL web_url(embedded_test_server()->GetURL("/title2.html"));
      std::string script = base::StringPrintf(
          "var frame = document.createElement('iframe');\n"
          "frame.src = '%s';\n"
          "document.body.appendChild(frame);\n",
          web_url.spec().c_str());

      TestNavigationObserver navigation_observer(shell()->web_contents());
      EXPECT_TRUE(ExecuteScript(shell(), script));
      navigation_observer.Wait();

      EXPECT_EQ(1U, root->child_count());
      EXPECT_FALSE(navigation_observer.last_navigation_succeeded());
    }
  }

  RenderProcessReadyObserver(RenderProcessHost* render_process_host)
      : render_process_host_(render_process_host),
        quit_closure_(run_loop_.QuitClosure()) {
    render_process_host_->AddObserver(this);
  }

  explicit RequestBlockingNavigationThrottle(NavigationHandle* handle)
      : NavigationThrottle(handle) {}

  WebUINavigationBrowserTest() {}

GURL SiteInstanceImpl::GetSiteForURL(BrowserContext* browser_context,
                                     const GURL& real_url,
                                     bool should_use_effective_urls) {
  if (real_url.SchemeIs(kGuestScheme))
    return real_url;

  GURL url = should_use_effective_urls
                 ? SiteInstanceImpl::GetEffectiveURL(browser_context, real_url)
                 : real_url;
  url::Origin origin = url::Origin::Create(url);

  if (!origin.host().empty() && origin.scheme() != url::kFileScheme) {
    GURL site_url(GetSiteForOrigin(origin));

    auto* policy = ChildProcessSecurityPolicyImpl::GetInstance();
    url::Origin isolated_origin;
    if (policy->GetMatchingIsolatedOrigin(origin, site_url, &isolated_origin))
      return isolated_origin.GetURL();

    if (should_use_effective_urls && url != real_url) {
      std::string non_translated_site_url(
          GetSiteForURL(browser_context, real_url,
                        false /* should_use_effective_urls */)
              .spec());
      GURL::Replacements replacements;
      replacements.SetRefStr(non_translated_site_url.c_str());
      site_url = site_url.ReplaceComponents(replacements);
    }

    return site_url;
  }

  if (!origin.opaque()) {
    DCHECK(!origin.scheme().empty());
    return GURL(origin.scheme() + ":");
  } else if (url.has_scheme()) {
    bool is_site_isolation_enabled =
        SiteIsolationPolicy::UseDedicatedProcessesForAllSites() ||
        SiteIsolationPolicy::AreIsolatedOriginsEnabled();
    if (is_site_isolation_enabled &&
        (url.SchemeIsBlob() || url.scheme() == url::kDataScheme)) {
      if (url.has_ref()) {
        GURL::Replacements replacements;
        replacements.ClearRef();
        url = url.ReplaceComponents(replacements);
      }
      return url;
    }

    DCHECK(!url.scheme().empty());
    return GURL(url.scheme() + ":");
  }

  DCHECK(!url.is_valid()) << url;
  return GURL();
}

  ChromeRenderProcessHostBackgroundingTestWithAudio() {}

  void StartMonitoringRequestsFor(const GURL& url) {
    request_url_ = url;
    saw_request_url_ = false;
  }

  void SimulateFreezeSignal(content::WebContents* contents) {
    TabLifecycleUnitSource::GetInstance()
        ->GetTabLifecycleUnit(contents)
        ->UpdateLifecycleState(mojom::LifecycleState::kFrozen);
  }

  WebContents* OpenBackgroundTab(const GURL& page) {
    ui_test_utils::NavigateToURLWithDisposition(
        browser(), page, WindowOpenDisposition::NEW_BACKGROUND_TAB,
        ui_test_utils::BROWSER_TEST_WAIT_FOR_NAVIGATION);

    TabStripModel* tab_strip = browser()->tab_strip_model();
    WebContents* wc =
        tab_strip->GetWebContentsAt(tab_strip->active_index() + 1);
    CHECK(wc->GetVisibleURL() == page);

    WaitForLauncherThread();
    WaitForMessageProcessing(wc);
    return wc;
  }

GURL SiteInstanceImpl::GetSiteForOrigin(const url::Origin& origin) {
  std::string domain = net::registry_controlled_domains::GetDomainAndRegistry(
      origin.host(),
      net::registry_controlled_domains::INCLUDE_PRIVATE_REGISTRIES);
  std::string site = origin.scheme();
  site += url::kStandardSchemeSeparator;
  site += domain.empty() ? origin.host() : domain;
  return GURL(site);
}

  void ExtendSubframeUnloadTimeoutForTerminationPing(RenderFrameHostImpl* rfh) {
    rfh->SetSubframeUnloadTimeoutForTesting(base::TimeDelta::FromSeconds(30));
  }

void TestProcessOverflow() {
int tab_count = 1;
int host_count = 1;
WebContents* tab1 = NULL;
WebContents* tab2 = NULL;
content::RenderProcessHost* rph1 = NULL;
content::RenderProcessHost* rph2 = NULL;
content::RenderProcessHost* rph3 = NULL;

const extensions::Extension* extension =
LoadExtension(test_data_dir_.AppendASCII("options_page"));

// Change the first tab to be the omnibox page (WebUI).
GURL omnibox(chrome::kChromeUIOmniboxURL);
ui_test_utils::NavigateToURL(browser(), omnibox);
EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());
tab1 = browser()->tab_strip_model()->GetWebContentsAt(tab_count - 1);
rph1 = tab1->GetMainFrame()->GetProcess();
EXPECT_EQ(omnibox, tab1->GetURL());
EXPECT_EQ(host_count, RenderProcessHostCount());

// Create a new normal tab with a data URL. It should be in its own process.
GURL page1("data:text/html,hello world1");

ui_test_utils::WindowedTabAddedNotificationObserver observer1(
content::NotificationService::AllSources());
::ShowSingletonTab(browser(), page1);
observer1.Wait();

tab_count++;
host_count++;
EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());
tab1 = browser()->tab_strip_model()->GetWebContentsAt(tab_count - 1);
rph2 = tab1->GetMainFrame()->GetProcess();
EXPECT_EQ(tab1->GetURL(), page1);
EXPECT_EQ(host_count, RenderProcessHostCount());
EXPECT_NE(rph1, rph2);

// Create another data URL tab.  With Site Isolation, this will require its
// own process, but without Site Isolation, it can share the previous
// process.
GURL page2("data:text/html,hello world2");
ui_test_utils::WindowedTabAddedNotificationObserver observer2(
content::NotificationService::AllSources());
::ShowSingletonTab(browser(), page2);
observer2.Wait();
tab_count++;
if (content::AreAllSitesIsolatedForTesting())
host_count++;
EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());
tab2 = browser()->tab_strip_model()->GetWebContentsAt(tab_count - 1);
EXPECT_EQ(tab2->GetURL(), page2);
EXPECT_EQ(host_count, RenderProcessHostCount());
if (content::AreAllSitesIsolatedForTesting())
EXPECT_NE(tab2->GetMainFrame()->GetProcess(), rph2);
else
EXPECT_EQ(tab2->GetMainFrame()->GetProcess(), rph2);

    // Create another WebUI tab.  It should share the process with omnibox.
// Note: intentionally create this tab after the normal tabs to exercise bug
// 43448 where extension and WebUI tabs could get combined into normal
// renderers.
GURL history(chrome::kChromeUIHistoryURL);
ui_test_utils::WindowedTabAddedNotificationObserver observer3(
content::NotificationService::AllSources());
::ShowSingletonTab(browser(), history);
observer3.Wait();
tab_count++;
EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());
tab2 = browser()->tab_strip_model()->GetWebContentsAt(tab_count - 1);
EXPECT_EQ(tab2->GetURL(), GURL(history));
EXPECT_EQ(host_count, RenderProcessHostCount());
    EXPECT_EQ(tab2->GetMainFrame()->GetProcess(), rph1);

// Create an extension tab.  It should be in its own process.
GURL extension_url("chrome-extension://" + extension->id());
ui_test_utils::WindowedTabAddedNotificationObserver observer4(
content::NotificationService::AllSources());
::ShowSingletonTab(browser(), extension_url);

observer4.Wait();
tab_count++;
host_count++;
EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());
tab1 = browser()->tab_strip_model()->GetWebContentsAt(tab_count - 1);
rph3 = tab1->GetMainFrame()->GetProcess();
EXPECT_EQ(tab1->GetURL(), extension_url);
EXPECT_EQ(host_count, RenderProcessHostCount());
EXPECT_NE(rph1, rph3);
EXPECT_NE(rph2, rph3);
}

  void OpenTwoTabs(const GURL& first_url, const GURL& second_url) {
    content::WindowedNotificationObserver load1(
        content::NOTIFICATION_LOAD_COMPLETED_MAIN_FRAME,
        content::NotificationService::AllSources());
    OpenURLParams open1(first_url, content::Referrer(),
                        WindowOpenDisposition::CURRENT_TAB,
                        ui::PAGE_TRANSITION_TYPED, false);
    content::WebContents* web_contents = browser()->OpenURL(open1);
    load1.Wait();
    if (URLShouldBeStoredInLocalDatabase(first_url))
      testing::ExpireLocalDBObservationWindows(web_contents);

    content::WindowedNotificationObserver load2(
        content::NOTIFICATION_LOAD_COMPLETED_MAIN_FRAME,
        content::NotificationService::AllSources());
    OpenURLParams open2(second_url, content::Referrer(),
                        WindowOpenDisposition::NEW_BACKGROUND_TAB,
                        ui::PAGE_TRANSITION_TYPED, false);
    web_contents = browser()->OpenURL(open2);
    load2.Wait();
    if (URLShouldBeStoredInLocalDatabase(second_url))
      testing::ExpireLocalDBObservationWindows(web_contents);

    ASSERT_EQ(2, tsm()->count());
  }

  void TestWebUISubframeNewWindowToWebAllowed(int bindings) {
    FrameTreeNode* root = static_cast<WebContentsImpl*>(shell()->web_contents())
                              ->GetFrameTree()
                              ->root();

    GURL chrome_url = GURL(std::string(kChromeUIScheme) + "://" +
                           std::string(kChromeUIBlobInternalsHost));
    EXPECT_TRUE(NavigateToURL(shell(), chrome_url));
    RenderFrameHost* webui_rfh = root->current_frame_host();
    scoped_refptr<SiteInstance> webui_site_instance =
        webui_rfh->GetSiteInstance();

    ChildProcessSecurityPolicyImpl::GetInstance()->GrantWebUIBindings(
        webui_rfh->GetProcess()->GetID(), bindings);

    EXPECT_EQ(chrome_url, webui_rfh->GetLastCommittedURL());
    EXPECT_TRUE(ChildProcessSecurityPolicyImpl::GetInstance()->HasWebUIBindings(
        webui_rfh->GetProcess()->GetID()));

    {
      std::string script = base::StringPrintf(
          "var frame = document.createElement('iframe');\n"
          "frame.src = '%s';\n"
          "document.body.appendChild(frame);\n",
          chrome_url.spec().c_str());

      TestNavigationObserver navigation_observer(shell()->web_contents());
      EXPECT_TRUE(ExecuteScript(shell(), script));
      navigation_observer.Wait();

      EXPECT_EQ(1U, root->child_count());
      EXPECT_TRUE(navigation_observer.last_navigation_succeeded());
    }

    GURL web_url(embedded_test_server()->GetURL("/title2.html"));
    std::string script = base::StringPrintf(
        "var a = document.createElement('a');"
        "a.href = '%s'; a.target = '_blank'; a.click()",
        web_url.spec().c_str());

    ShellAddedObserver new_shell_observer;
    EXPECT_TRUE(ExecuteScript(root->child_at(0)->current_frame_host(), script));
    Shell* new_shell = new_shell_observer.GetShell();
    WaitForLoadStop(new_shell->web_contents());

    EXPECT_EQ(web_url, new_shell->web_contents()->GetLastCommittedURL());

  }
