static int Downmix_Command(effect_handle_t self, uint32_t cmdCode, uint32_t cmdSize,
 void *pCmdData, uint32_t *replySize, void *pReplyData) {

 downmix_module_t *pDwmModule = (downmix_module_t *) self;
 downmix_object_t *pDownmixer;

 if (pDwmModule == NULL || pDwmModule->context.state == DOWNMIX_STATE_UNINITIALIZED) {
 return -EINVAL;
 }

    pDownmixer = (downmix_object_t*) &pDwmModule->context;

    ALOGV("Downmix_Command command %" PRIu32 " cmdSize %" PRIu32, cmdCode, cmdSize);

 switch (cmdCode) {
 case EFFECT_CMD_INIT:
 if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {
 return -EINVAL;
 }
 *(int *) pReplyData = Downmix_Init(pDwmModule);
 break;

 case EFFECT_CMD_SET_CONFIG:
 if (pCmdData == NULL || cmdSize != sizeof(effect_config_t)
 || pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {
 return -EINVAL;
 }
 *(int *) pReplyData = Downmix_Configure(pDwmModule,
 (effect_config_t *)pCmdData, false);
 break;

 case EFFECT_CMD_RESET:
 Downmix_Reset(pDownmixer, false);
 break;

 case EFFECT_CMD_GET_PARAM:
        ALOGV("Downmix_Command EFFECT_CMD_GET_PARAM pCmdData %p, *replySize %" PRIu32 ", pReplyData: %p",
                pCmdData, *replySize, pReplyData);
 if (pCmdData == NULL || cmdSize < (int)(sizeof(effect_param_t) + sizeof(int32_t)) ||
                pReplyData == NULL || replySize == NULL ||
 *replySize < (int) sizeof(effect_param_t) + 2 * sizeof(int32_t)) {
 return -EINVAL;
 }
 effect_param_t *rep = (effect_param_t *) pReplyData;
        memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + sizeof(int32_t));
        ALOGV("Downmix_Command EFFECT_CMD_GET_PARAM param %" PRId32 ", replySize %" PRIu32,
 *(int32_t *)rep->data, rep->vsize);
        rep->status = Downmix_getParameter(pDownmixer, *(int32_t *)rep->data, &rep->vsize,
                rep->data + sizeof(int32_t));
 *replySize = sizeof(effect_param_t) + sizeof(int32_t) + rep->vsize;
 break;

 case EFFECT_CMD_SET_PARAM:
        ALOGV("Downmix_Command EFFECT_CMD_SET_PARAM cmdSize %d pCmdData %p, *replySize %" PRIu32
 ", pReplyData %p", cmdSize, pCmdData, *replySize, pReplyData);
 if (pCmdData == NULL || (cmdSize < (int)(sizeof(effect_param_t) + sizeof(int32_t)))
 || pReplyData == NULL || replySize == NULL || *replySize != (int)sizeof(int32_t)) {

             return -EINVAL;
         }
         effect_param_t *cmd = (effect_param_t *) pCmdData;
         *(int *)pReplyData = Downmix_setParameter(pDownmixer, *(int32_t *)cmd->data,
                 cmd->vsize, cmd->data + sizeof(int32_t));
         break;

 case EFFECT_CMD_SET_PARAM_DEFERRED:
        ALOGW("Downmix_Command command EFFECT_CMD_SET_PARAM_DEFERRED not supported, FIXME");
 break;

 case EFFECT_CMD_SET_PARAM_COMMIT:
        ALOGW("Downmix_Command command EFFECT_CMD_SET_PARAM_COMMIT not supported, FIXME");
 break;

 case EFFECT_CMD_ENABLE:
 if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {
 return -EINVAL;
 }
 if (pDownmixer->state != DOWNMIX_STATE_INITIALIZED) {
 return -ENOSYS;
 }
        pDownmixer->state = DOWNMIX_STATE_ACTIVE;
        ALOGV("EFFECT_CMD_ENABLE() OK");
 *(int *)pReplyData = 0;
 break;

 case EFFECT_CMD_DISABLE:
 if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {
 return -EINVAL;
 }
 if (pDownmixer->state != DOWNMIX_STATE_ACTIVE) {
 return -ENOSYS;
 }
        pDownmixer->state = DOWNMIX_STATE_INITIALIZED;
        ALOGV("EFFECT_CMD_DISABLE() OK");
 *(int *)pReplyData = 0;
 break;

 case EFFECT_CMD_SET_DEVICE:
 if (pCmdData == NULL || cmdSize != (int)sizeof(uint32_t)) {
 return -EINVAL;
 }
        ALOGV("Downmix_Command EFFECT_CMD_SET_DEVICE: 0x%08" PRIx32, *(uint32_t *)pCmdData);
 break;

 case EFFECT_CMD_SET_VOLUME: {
 if (pCmdData == NULL || cmdSize != (int)sizeof(uint32_t) * 2) {
 return -EINVAL;
 }
        ALOGW("Downmix_Command command EFFECT_CMD_SET_VOLUME not supported, FIXME");
 float left = (float)(*(uint32_t *)pCmdData) / (1 << 24);
 float right = (float)(*((uint32_t *)pCmdData + 1)) / (1 << 24);
        ALOGV("Downmix_Command EFFECT_CMD_SET_VOLUME: left %f, right %f ", left, right);
 break;
 }

 case EFFECT_CMD_SET_AUDIO_MODE:
 if (pCmdData == NULL || cmdSize != (int)sizeof(uint32_t)) {
 return -EINVAL;
 }
        ALOGV("Downmix_Command EFFECT_CMD_SET_AUDIO_MODE: %" PRIu32, *(uint32_t *)pCmdData);
 break;

 case EFFECT_CMD_SET_CONFIG_REVERSE:
 case EFFECT_CMD_SET_INPUT_DEVICE:
 break;

 default:
        ALOGW("Downmix_Command invalid command %" PRIu32, cmdCode);
 return -EINVAL;
 }

 return 0;
}

int Downmix_Reset(downmix_object_t *pDownmixer __unused, bool init __unused) {
 return 0;
}

int Reverb_command(effect_handle_t  self,
uint32_t            cmdCode,
uint32_t            cmdSize,
void *pCmdData,
uint32_t *replySize,
void *pReplyData){
android::ReverbContext * pContext = (android::ReverbContext *) self;
LVREV_ControlParams_st    ActiveParams; /* Current control Parameters */
LVREV_ReturnStatus_en     LvmStatus=LVREV_SUCCESS; /* Function call status */


if (pContext == NULL){
ALOGV("\tLVM_ERROR : Reverb_command ERROR pContext == NULL");
return -EINVAL;
}

//ALOGV("\tReverb_command INPUTS are: command %d cmdSize %d",cmdCode, cmdSize);

switch (cmdCode){
case EFFECT_CMD_INIT:
//ALOGV("\tReverb_command cmdCode Case: "
//        "EFFECT_CMD_INIT start");

if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)){
ALOGV("\tLVM_ERROR : Reverb_command cmdCode Case: "
"EFFECT_CMD_INIT: ERROR");
return -EINVAL;
}
*(int *) pReplyData = 0;
break;

case EFFECT_CMD_SET_CONFIG:
//ALOGV("\tReverb_command cmdCode Case: "
//        "EFFECT_CMD_SET_CONFIG start");
if (pCmdData == NULL || cmdSize != sizeof(effect_config_t) ||
pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {
ALOGV("\tLVM_ERROR : Reverb_command cmdCode Case: "
"EFFECT_CMD_SET_CONFIG: ERROR");
return -EINVAL;
}
*(int *) pReplyData = android::Reverb_setConfig(pContext,
(effect_config_t *) pCmdData);
break;

case EFFECT_CMD_GET_CONFIG:
if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(effect_config_t)) {
ALOGV("\tLVM_ERROR : Reverb_command cmdCode Case: "
"EFFECT_CMD_GET_CONFIG: ERROR");
return -EINVAL;
}

android::Reverb_getConfig(pContext, (effect_config_t *)pReplyData);
break;

case EFFECT_CMD_RESET:
//ALOGV("\tReverb_command cmdCode Case: "
//        "EFFECT_CMD_RESET start");
Reverb_setConfig(pContext, &pContext->config);
break;

case EFFECT_CMD_GET_PARAM:{
//ALOGV("\tReverb_command cmdCode Case: "
//        "EFFECT_CMD_GET_PARAM start");
effect_param_t *p = (effect_param_t *)pCmdData;
if (SIZE_MAX - sizeof(effect_param_t) < (size_t)p->psize) {
android_errorWriteLog(0x534e4554, "26347509");
return -EINVAL;
}
if (pCmdData == NULL || cmdSize < sizeof(effect_param_t) ||
cmdSize < (sizeof(effect_param_t) + p->psize) ||
pReplyData == NULL || replySize == NULL ||
*replySize < (sizeof(effect_param_t) + p->psize)) {
ALOGV("\tLVM_ERROR : Reverb_command cmdCode Case: "
"EFFECT_CMD_GET_PARAM: ERROR");
return -EINVAL;
}

memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + p->psize);

p = (effect_param_t *)pReplyData;

int voffset = ((p->psize - 1) / sizeof(int32_t) + 1) * sizeof(int32_t);

p->status = android::Reverb_getParameter(pContext,
(void *)p->data,
&p->vsize,
p->data + voffset);

*replySize = sizeof(effect_param_t) + voffset + p->vsize;

//ALOGV("\tReverb_command EFFECT_CMD_GET_PARAM "
//        "*pCmdData %d, *replySize %d, *pReplyData %d ",
//        *(int32_t *)((char *)pCmdData + sizeof(effect_param_t)),
//        *replySize,
//        *(int16_t *)((char *)pReplyData + sizeof(effect_param_t) + voffset));

} break;
case EFFECT_CMD_SET_PARAM:{

//ALOGV("\tReverb_command cmdCode Case: "
//        "EFFECT_CMD_SET_PARAM start");
//ALOGV("\tReverb_command EFFECT_CMD_SET_PARAM param %d, *replySize %d, value %d ",
//        *(int32_t *)((char *)pCmdData + sizeof(effect_param_t)),
//        *replySize,
//        *(int16_t *)((char *)pCmdData + sizeof(effect_param_t) + sizeof(int32_t)));

if (pCmdData == NULL || (cmdSize < (sizeof(effect_param_t) + sizeof(int32_t))) ||
pReplyData == NULL ||  replySize == NULL || *replySize != sizeof(int32_t)) {
ALOGV("\tLVM_ERROR : Reverb_command cmdCode Case: "
"EFFECT_CMD_SET_PARAM: ERROR");
return -EINVAL;
}

effect_param_t *p = (effect_param_t *) pCmdData;

if (p->psize != sizeof(int32_t)){
ALOGV("\t4LVM_ERROR : Reverb_command cmdCode Case: "
"EFFECT_CMD_SET_PARAM: ERROR, psize is not sizeof(int32_t)");
return -EINVAL;
}

//ALOGV("\tn5Reverb_command cmdSize is %d\n"
//        "\tsizeof(effect_param_t) is  %d\n"
//        "\tp->psize is %d\n"
//        "\tp->vsize is %d"
//        "\n",
//        cmdSize, sizeof(effect_param_t), p->psize, p->vsize );


*(int *)pReplyData = android::Reverb_setParameter(pContext,
(void *)p->data,
                                                              p->data + p->psize);
} break;

case EFFECT_CMD_ENABLE:
//ALOGV("\tReverb_command cmdCode Case: "
//        "EFFECT_CMD_ENABLE start");

if (pReplyData == NULL || *replySize != sizeof(int)){
ALOGV("\tLVM_ERROR : Reverb_command cmdCode Case: "
"EFFECT_CMD_ENABLE: ERROR");
return -EINVAL;
}
if(pContext->bEnabled == LVM_TRUE){
ALOGV("\tLVM_ERROR : Reverb_command cmdCode Case: "
"EFFECT_CMD_ENABLE: ERROR-Effect is already enabled");
return -EINVAL;
}
*(int *)pReplyData = 0;
pContext->bEnabled = LVM_TRUE;
/* Get the current settings */
LvmStatus = LVREV_GetControlParameters(pContext->hInstance, &ActiveParams);
LVM_ERROR_CHECK(LvmStatus, "LVREV_GetControlParameters", "EFFECT_CMD_ENABLE")
pContext->SamplesToExitCount =
(ActiveParams.T60 * pContext->config.inputCfg.samplingRate)/1000;
// force no volume ramp for first buffer processed after enabling the effect
pContext->volumeMode = android::REVERB_VOLUME_FLAT;
//ALOGV("\tEFFECT_CMD_ENABLE SamplesToExitCount = %d", pContext->SamplesToExitCount);
break;
case EFFECT_CMD_DISABLE:
//ALOGV("\tReverb_command cmdCode Case: "
//        "EFFECT_CMD_DISABLE start");

if (pReplyData == NULL || *replySize != sizeof(int)){
ALOGV("\tLVM_ERROR : Reverb_command cmdCode Case: "
"EFFECT_CMD_DISABLE: ERROR");
return -EINVAL;
}
if(pContext->bEnabled == LVM_FALSE){
ALOGV("\tLVM_ERROR : Reverb_command cmdCode Case: "
"EFFECT_CMD_DISABLE: ERROR-Effect is not yet enabled");
return -EINVAL;
}
*(int *)pReplyData = 0;
pContext->bEnabled = LVM_FALSE;
break;

case EFFECT_CMD_SET_VOLUME:
if (pCmdData == NULL ||
cmdSize != 2 * sizeof(uint32_t)) {
ALOGV("\tLVM_ERROR : Reverb_command cmdCode Case: "
"EFFECT_CMD_SET_VOLUME: ERROR");
return -EINVAL;
}


if (pReplyData != NULL) { // we have volume control
pContext->leftVolume = (LVM_INT16)((*(uint32_t *)pCmdData + (1 << 11)) >> 12);
pContext->rightVolume = (LVM_INT16)((*((uint32_t *)pCmdData + 1) + (1 << 11)) >> 12);
*(uint32_t *)pReplyData = (1 << 24);
*((uint32_t *)pReplyData + 1) = (1 << 24);
if (pContext->volumeMode == android::REVERB_VOLUME_OFF) {
// force no volume ramp for first buffer processed after getting volume control
pContext->volumeMode = android::REVERB_VOLUME_FLAT;
}
} else { // we don't have volume control
pContext->leftVolume = REVERB_UNIT_VOLUME;
pContext->rightVolume = REVERB_UNIT_VOLUME;
pContext->volumeMode = android::REVERB_VOLUME_OFF;
}
ALOGV("EFFECT_CMD_SET_VOLUME left %d, right %d mode %d",
pContext->leftVolume, pContext->rightVolume,  pContext->volumeMode);
break;

case EFFECT_CMD_SET_DEVICE:
case EFFECT_CMD_SET_AUDIO_MODE:
//ALOGV("\tReverb_command cmdCode Case: "
//        "EFFECT_CMD_SET_DEVICE/EFFECT_CMD_SET_VOLUME/EFFECT_CMD_SET_AUDIO_MODE start");
break;

default:
ALOGV("\tLVM_ERROR : Reverb_command cmdCode Case: "
"DEFAULT start %d ERROR",cmdCode);
return -EINVAL;
}

//ALOGV("\tReverb_command end\n\n");
return 0;
} /* end Reverb_command */

int32_t DownmixLib_Create(const effect_uuid_t *uuid,
 int32_t sessionId __unused,
 int32_t ioId __unused,
 effect_handle_t *pHandle) {
 int ret;
 int i;
 downmix_module_t *module;
 const effect_descriptor_t *desc;

    ALOGV("DownmixLib_Create()");

#ifdef DOWNMIX_TEST_CHANNEL_INDEX
    ALOGI("DOWNMIX_TEST_CHANNEL_INDEX: should work:");
 Downmix_testIndexComputation(AUDIO_CHANNEL_OUT_FRONT_LEFT | AUDIO_CHANNEL_OUT_FRONT_RIGHT |
                    AUDIO_CHANNEL_OUT_LOW_FREQUENCY | AUDIO_CHANNEL_OUT_BACK_CENTER);
 Downmix_testIndexComputation(CHANNEL_MASK_QUAD_SIDE | CHANNEL_MASK_QUAD_BACK);
 Downmix_testIndexComputation(CHANNEL_MASK_5POINT1_SIDE | AUDIO_CHANNEL_OUT_BACK_CENTER);
 Downmix_testIndexComputation(CHANNEL_MASK_5POINT1_BACK | AUDIO_CHANNEL_OUT_BACK_CENTER);
    ALOGI("DOWNMIX_TEST_CHANNEL_INDEX: should NOT work:");
 Downmix_testIndexComputation(AUDIO_CHANNEL_OUT_FRONT_LEFT | AUDIO_CHANNEL_OUT_FRONT_RIGHT |
                        AUDIO_CHANNEL_OUT_LOW_FREQUENCY | AUDIO_CHANNEL_OUT_BACK_LEFT);
 Downmix_testIndexComputation(AUDIO_CHANNEL_OUT_FRONT_LEFT | AUDIO_CHANNEL_OUT_FRONT_RIGHT |
                            AUDIO_CHANNEL_OUT_LOW_FREQUENCY | AUDIO_CHANNEL_OUT_SIDE_LEFT);
 Downmix_testIndexComputation(AUDIO_CHANNEL_OUT_FRONT_LEFT |
                        AUDIO_CHANNEL_OUT_BACK_LEFT | AUDIO_CHANNEL_OUT_BACK_RIGHT);
 Downmix_testIndexComputation(AUDIO_CHANNEL_OUT_FRONT_LEFT |
                            AUDIO_CHANNEL_OUT_SIDE_LEFT | AUDIO_CHANNEL_OUT_SIDE_RIGHT);
#endif

 if (pHandle == NULL || uuid == NULL) {
 return -EINVAL;
 }

 for (i = 0 ; i < kNbEffects ; i++) {
        desc = gDescriptors[i];
 if (memcmp(uuid, &desc->uuid, sizeof(effect_uuid_t)) == 0) {
 break;
 }
 }

 if (i == kNbEffects) {
 return -ENOENT;
 }

    module = malloc(sizeof(downmix_module_t));

    module->itfe = &gDownmixInterface;

    module->context.state = DOWNMIX_STATE_UNINITIALIZED;

    ret = Downmix_Init(module);
 if (ret < 0) {
        ALOGW("DownmixLib_Create() init failed");
        free(module);
 return ret;
 }

 *pHandle = (effect_handle_t) module;

    ALOGV("DownmixLib_Create() %p , size %zu", module, sizeof(downmix_module_t));

 return 0;
}

int Reverb_getParameter(ReverbContext *pContext,
 void *pParam,
 uint32_t *pValueSize,
 void *pValue){
 int status = 0;
 int32_t *pParamTemp = (int32_t *)pParam;
 int32_t param = *pParamTemp++;
    t_reverb_settings *pProperties;

 if (pContext->preset) {
 if (param != REVERB_PARAM_PRESET || *pValueSize < sizeof(uint16_t)) {
 return -EINVAL;
 }

 *(uint16_t *)pValue = pContext->nextPreset;
        ALOGV("get REVERB_PARAM_PRESET, preset %d", pContext->nextPreset);
 return 0;
 }

 switch (param){
 case REVERB_PARAM_ROOM_LEVEL:
 if (*pValueSize != sizeof(int16_t)){
                ALOGV("\tLVM_ERROR : Reverb_getParameter() invalid pValueSize1 %d", *pValueSize);
 return -EINVAL;
 }
 *pValueSize = sizeof(int16_t);
 break;
 case REVERB_PARAM_ROOM_HF_LEVEL:
 if (*pValueSize != sizeof(int16_t)){
                ALOGV("\tLVM_ERROR : Reverb_getParameter() invalid pValueSize12 %d", *pValueSize);
 return -EINVAL;
 }
 *pValueSize = sizeof(int16_t);
 break;
 case REVERB_PARAM_DECAY_TIME:
 if (*pValueSize != sizeof(uint32_t)){
                ALOGV("\tLVM_ERROR : Reverb_getParameter() invalid pValueSize3 %d", *pValueSize);
 return -EINVAL;
 }
 *pValueSize = sizeof(uint32_t);
 break;
 case REVERB_PARAM_DECAY_HF_RATIO:
 if (*pValueSize != sizeof(int16_t)){
                ALOGV("\tLVM_ERROR : Reverb_getParameter() invalid pValueSize4 %d", *pValueSize);
 return -EINVAL;
 }
 *pValueSize = sizeof(int16_t);
 break;
 case REVERB_PARAM_REFLECTIONS_LEVEL:
 if (*pValueSize != sizeof(int16_t)){
                ALOGV("\tLVM_ERROR : Reverb_getParameter() invalid pValueSize5 %d", *pValueSize);
 return -EINVAL;
 }
 *pValueSize = sizeof(int16_t);
 break;
 case REVERB_PARAM_REFLECTIONS_DELAY:
 if (*pValueSize != sizeof(uint32_t)){
                ALOGV("\tLVM_ERROR : Reverb_getParameter() invalid pValueSize6 %d", *pValueSize);
 return -EINVAL;
 }
 *pValueSize = sizeof(uint32_t);
 break;
 case REVERB_PARAM_REVERB_LEVEL:
 if (*pValueSize != sizeof(int16_t)){
                ALOGV("\tLVM_ERROR : Reverb_getParameter() invalid pValueSize7 %d", *pValueSize);
 return -EINVAL;
 }
 *pValueSize = sizeof(int16_t);
 break;
 case REVERB_PARAM_REVERB_DELAY:
 if (*pValueSize != sizeof(uint32_t)){
                ALOGV("\tLVM_ERROR : Reverb_getParameter() invalid pValueSize8 %d", *pValueSize);
 return -EINVAL;
 }
 *pValueSize = sizeof(uint32_t);
 break;
 case REVERB_PARAM_DIFFUSION:
 if (*pValueSize != sizeof(int16_t)){
                ALOGV("\tLVM_ERROR : Reverb_getParameter() invalid pValueSize9 %d", *pValueSize);
 return -EINVAL;
 }
 *pValueSize = sizeof(int16_t);
 break;
 case REVERB_PARAM_DENSITY:
 if (*pValueSize != sizeof(int16_t)){
                ALOGV("\tLVM_ERROR : Reverb_getParameter() invalid pValueSize10 %d", *pValueSize);
 return -EINVAL;
 }
 *pValueSize = sizeof(int16_t);
 break;
 case REVERB_PARAM_PROPERTIES:
 if (*pValueSize != sizeof(t_reverb_settings)){
                ALOGV("\tLVM_ERROR : Reverb_getParameter() invalid pValueSize11 %d", *pValueSize);
 return -EINVAL;
 }
 *pValueSize = sizeof(t_reverb_settings);
 break;

 default:
            ALOGV("\tLVM_ERROR : Reverb_getParameter() invalid param %d", param);
 return -EINVAL;
 }

    pProperties = (t_reverb_settings *) pValue;

 switch (param){
 case REVERB_PARAM_PROPERTIES:
            pProperties->roomLevel = ReverbGetRoomLevel(pContext);
            pProperties->roomHFLevel = ReverbGetRoomHfLevel(pContext);
            pProperties->decayTime = ReverbGetDecayTime(pContext);
            pProperties->decayHFRatio = ReverbGetDecayHfRatio(pContext);
            pProperties->reflectionsLevel = 0;
            pProperties->reflectionsDelay = 0;
            pProperties->reverbDelay = 0;
            pProperties->reverbLevel = ReverbGetReverbLevel(pContext);
            pProperties->diffusion = ReverbGetDiffusion(pContext);
            pProperties->density = ReverbGetDensity(pContext);

            ALOGV("\tReverb_getParameter() REVERB_PARAM_PROPERTIES Value is roomLevel        %d",
                pProperties->roomLevel);
            ALOGV("\tReverb_getParameter() REVERB_PARAM_PROPERTIES Value is roomHFLevel      %d",
                pProperties->roomHFLevel);
            ALOGV("\tReverb_getParameter() REVERB_PARAM_PROPERTIES Value is decayTime        %d",
                pProperties->decayTime);
            ALOGV("\tReverb_getParameter() REVERB_PARAM_PROPERTIES Value is decayHFRatio     %d",
                pProperties->decayHFRatio);
            ALOGV("\tReverb_getParameter() REVERB_PARAM_PROPERTIES Value is reflectionsLevel %d",
                pProperties->reflectionsLevel);
            ALOGV("\tReverb_getParameter() REVERB_PARAM_PROPERTIES Value is reflectionsDelay %d",
                pProperties->reflectionsDelay);
            ALOGV("\tReverb_getParameter() REVERB_PARAM_PROPERTIES Value is reverbDelay      %d",
                pProperties->reverbDelay);
            ALOGV("\tReverb_getParameter() REVERB_PARAM_PROPERTIES Value is reverbLevel      %d",
                pProperties->reverbLevel);
            ALOGV("\tReverb_getParameter() REVERB_PARAM_PROPERTIES Value is diffusion        %d",
                pProperties->diffusion);
            ALOGV("\tReverb_getParameter() REVERB_PARAM_PROPERTIES Value is density          %d",
                pProperties->density);
 break;

 case REVERB_PARAM_ROOM_LEVEL:
 *(int16_t *)pValue = ReverbGetRoomLevel(pContext);

 break;
 case REVERB_PARAM_ROOM_HF_LEVEL:
 *(int16_t *)pValue = ReverbGetRoomHfLevel(pContext);

 break;
 case REVERB_PARAM_DECAY_TIME:
 *(uint32_t *)pValue = ReverbGetDecayTime(pContext);

 break;
 case REVERB_PARAM_DECAY_HF_RATIO:
 *(int16_t *)pValue = ReverbGetDecayHfRatio(pContext);

 break;
 case REVERB_PARAM_REVERB_LEVEL:
 *(int16_t *)pValue = ReverbGetReverbLevel(pContext);

 break;
 case REVERB_PARAM_DIFFUSION:
 *(int16_t *)pValue = ReverbGetDiffusion(pContext);

 break;
 case REVERB_PARAM_DENSITY:
 *(uint16_t *)pValue = 0;
 *(int16_t *)pValue = ReverbGetDensity(pContext);
 break;
 case REVERB_PARAM_REFLECTIONS_LEVEL:
 *(uint16_t *)pValue = 0;
 case REVERB_PARAM_REFLECTIONS_DELAY:
 *(uint32_t *)pValue = 0;
 case REVERB_PARAM_REVERB_DELAY:
 *(uint32_t *)pValue = 0;
 break;

 default:
            ALOGV("\tLVM_ERROR : Reverb_getParameter() invalid param %d", param);
            status = -EINVAL;
 break;
 }

 return status;
} /* end Reverb_getParameter */

static bool Downmix_validChannelMask(uint32_t mask)
{
 if (!mask) {
 return false;
 }
 if (mask & kUnsupported) {
        ALOGE("Unsupported channels (top or front left/right of center)");
 return false;
 }
 if ((mask & AUDIO_CHANNEL_OUT_STEREO) != AUDIO_CHANNEL_OUT_STEREO) {
        ALOGE("Front channels must be present");
 return false;
 }
 if ((mask & kSides) != 0) {
 if ((mask & kSides) != kSides) {
            ALOGE("Side channels must be used as a pair");
 return false;
 }
 }
 if ((mask & kBacks) != 0) {
 if ((mask & kBacks) != kBacks) {
            ALOGE("Back channels must be used as a pair");
 return false;
 }
 }
 return true;
}

int Reverb_setParameter (ReverbContext *pContext, void *pParam, void *pValue){
     int status = 0;
     int16_t level;
     int16_t ratio;
 uint32_t time;
    t_reverb_settings *pProperties;
 int32_t *pParamTemp = (int32_t *)pParam;
 int32_t param = *pParamTemp++;

 if (pContext->preset) {
 if (param != REVERB_PARAM_PRESET) {
 return -EINVAL;
 }

 uint16_t preset = *(uint16_t *)pValue;
        ALOGV("set REVERB_PARAM_PRESET, preset %d", preset);
 if (preset > REVERB_PRESET_LAST) {
 return -EINVAL;
 }
        pContext->nextPreset = preset;

         return 0;
     }
 
     switch (param){
         case REVERB_PARAM_PROPERTIES:
             ALOGV("\tReverb_setParameter() REVERB_PARAM_PROPERTIES");
            pProperties = (t_reverb_settings *) pValue;
 ReverbSetRoomLevel(pContext, pProperties->roomLevel);
 ReverbSetRoomHfLevel(pContext, pProperties->roomHFLevel);
 ReverbSetDecayTime(pContext, pProperties->decayTime);
 ReverbSetDecayHfRatio(pContext, pProperties->decayHFRatio);
 ReverbSetReverbLevel(pContext, pProperties->reverbLevel);
 ReverbSetDiffusion(pContext, pProperties->diffusion);
 ReverbSetDensity(pContext, pProperties->density);
 break;
 case REVERB_PARAM_ROOM_LEVEL:
            level = *(int16_t *)pValue;
 ReverbSetRoomLevel(pContext, level);
 break;
 case REVERB_PARAM_ROOM_HF_LEVEL:
            level = *(int16_t *)pValue;
 ReverbSetRoomHfLevel(pContext, level);
 break;
 case REVERB_PARAM_DECAY_TIME:
            time = *(uint32_t *)pValue;
 ReverbSetDecayTime(pContext, time);
 break;
 case REVERB_PARAM_DECAY_HF_RATIO:
            ratio = *(int16_t *)pValue;
 ReverbSetDecayHfRatio(pContext, ratio);
 break;
 case REVERB_PARAM_REVERB_LEVEL:
            level = *(int16_t *)pValue;
 ReverbSetReverbLevel(pContext, level);
 break;
 case REVERB_PARAM_DIFFUSION:
            ratio = *(int16_t *)pValue;
 ReverbSetDiffusion(pContext, ratio);
 break;
 case REVERB_PARAM_DENSITY:
            ratio = *(int16_t *)pValue;
 ReverbSetDensity(pContext, ratio);
 break;
 break;
 case REVERB_PARAM_REFLECTIONS_LEVEL:
 case REVERB_PARAM_REFLECTIONS_DELAY:
 case REVERB_PARAM_REVERB_DELAY:
 break;
 default:
            ALOGV("\tLVM_ERROR : Reverb_setParameter() invalid param %d", param);
 break;
 }


     return status;
 } /* end Reverb_setParameter */
