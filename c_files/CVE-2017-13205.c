IMPEG2D_ERROR_CODES_T impeg2d_dec_pic_hdr(dec_state_t *ps_dec)
{
 stream_t *ps_stream;
    ps_stream = &ps_dec->s_bit_stream;

    impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);
 /* Flush temporal reference */
    impeg2d_bit_stream_get(ps_stream,10);

 /* Picture type */
    ps_dec->e_pic_type = (e_pic_type_t)impeg2d_bit_stream_get(ps_stream,3);
 if((ps_dec->e_pic_type < I_PIC) || (ps_dec->e_pic_type > D_PIC))
 {
        impeg2d_next_code(ps_dec, PICTURE_START_CODE);
 return IMPEG2D_INVALID_PIC_TYPE;
 }

 /* Flush vbv_delay */
    impeg2d_bit_stream_get(ps_stream,16);

 if(ps_dec->e_pic_type == P_PIC || ps_dec->e_pic_type == B_PIC)
 {
        ps_dec->u2_full_pel_forw_vector = impeg2d_bit_stream_get_bit(ps_stream);
        ps_dec->u2_forw_f_code          = impeg2d_bit_stream_get(ps_stream,3);
 }
 if(ps_dec->e_pic_type == B_PIC)
 {
        ps_dec->u2_full_pel_back_vector = impeg2d_bit_stream_get_bit(ps_stream);
        ps_dec->u2_back_f_code          = impeg2d_bit_stream_get(ps_stream,3);
 }

 
     if(ps_dec->u2_is_mpeg2 == 0)
     {
         ps_dec->au2_f_code[0][0] = ps_dec->au2_f_code[0][1] = ps_dec->u2_forw_f_code;
         ps_dec->au2_f_code[1][0] = ps_dec->au2_f_code[1][1] = ps_dec->u2_back_f_code;
     }

 /*-----------------------------------------------------------------------*/
 /*  Flush the extra bit value                                            */
 /*                                                                       */
 /*  while(impeg2d_bit_stream_nxt() == '1')                                  */
 /*  {                                                                    */
 /*      extra_bit_picture         1                                      */
 /*      extra_information_picture 8                                      */
 /*  }                                                                    */
 /*  extra_bit_picture             1                                      */
 /*-----------------------------------------------------------------------*/
 while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&
           ps_stream->u4_offset < ps_stream->u4_max_offset)
 {
        impeg2d_bit_stream_get(ps_stream,9);
 }
    impeg2d_bit_stream_get_bit(ps_stream);
    impeg2d_next_start_code(ps_dec);

 return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;
}

IMPEG2D_ERROR_CODES_T impeg2d_process_video_bit_stream(dec_state_t *ps_dec)
{
 stream_t *ps_stream;
    UWORD32 u4_next_bits, u4_start_code_found;
    IMPEG2D_ERROR_CODES_T e_error;

    ps_stream = &ps_dec->s_bit_stream;
    impeg2d_next_start_code(ps_dec);
 /* If the stream is MPEG-2 compliant stream */
    u4_start_code_found = 0;

 if(ps_dec->u2_is_mpeg2)
 {
 /* MPEG2 decoding starts */
 while((u4_start_code_found == 0) && (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))
 {
            u4_next_bits = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);

 if(u4_next_bits == SEQUENCE_HEADER_CODE)
 {
 if(ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset)
 {
                    e_error = impeg2d_dec_seq_hdr(ps_dec);
 if ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE != e_error)
 {
 return e_error;
 }

                    u4_start_code_found = 0;

 }
 else
 {
 return IMPEG2D_BITSTREAM_BUFF_EXCEEDED_ERR;
 }


 if(ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset)
 {
                    IMPEG2D_ERROR_CODES_T e_error;
                    e_error = impeg2d_dec_seq_ext(ps_dec);
 if ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE != e_error)
 {
 return e_error;
 }
                    u4_start_code_found = 0;

 }
 else
 {
 return IMPEG2D_BITSTREAM_BUFF_EXCEEDED_ERR;
 }
 }
 else if((u4_next_bits == USER_DATA_START_CODE) || (u4_next_bits == EXTENSION_START_CODE))
 {
 if(ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset)
 {
                    impeg2d_dec_seq_ext_data(ps_dec);
                    u4_start_code_found = 0;

 }

 }
 else if((ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset)
 && (u4_next_bits == GOP_START_CODE))
 {
                impeg2d_dec_grp_of_pic_hdr(ps_dec);
                impeg2d_dec_user_data(ps_dec);
                u4_start_code_found = 0;

 }
 else if((ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset)
 && (u4_next_bits == PICTURE_START_CODE))
 {
                ps_dec->i4_pic_count++;

                e_error = impeg2d_dec_pic_hdr(ps_dec);
 if ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE != e_error)
 {
 return e_error;
 }
                e_error = impeg2d_dec_pic_coding_ext(ps_dec);
 if ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE != e_error)
 {
 return e_error;
 }
                e_error = impeg2d_dec_pic_ext_data(ps_dec);
 if ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE != e_error)
 {
 return e_error;
 }
                e_error = impeg2d_pre_pic_dec_proc(ps_dec);
 if ((IMPEG2D_ERROR_CODES_T) IVD_ERROR_NONE != e_error)
 {
 return e_error;
 }
                impeg2d_dec_pic_data(ps_dec);
                impeg2d_post_pic_dec_proc(ps_dec);
                u4_start_code_found = 1;
 }
 else

 {
                FLUSH_BITS(ps_dec->s_bit_stream.u4_offset, ps_dec->s_bit_stream.u4_buf, ps_dec->s_bit_stream.u4_buf_nxt, 8, ps_dec->s_bit_stream.pu4_buf_aligned);

 }
 if(u4_start_code_found == 0)
 {
                impeg2d_next_start_code(ps_dec);
 /* In case a dec_pic_data call has not been made, the number of
                 * bytes consumed in the previous header decode has to be
                 * consumed. Not consuming it will result in zero bytes consumed
                 * loops in case there are multiple headers and the second
                 * or a future header has a resolution change/other error where
                 * the bytes of the last header are not consumed.
                 */
                ps_dec->i4_bytes_consumed = (ps_dec->s_bit_stream.u4_offset + 7) >> 3;
                ps_dec->i4_bytes_consumed -= ((size_t)ps_dec->s_bit_stream.pv_bs_buf & 3);
 }
 }
 if((u4_start_code_found == 0) && (ps_dec->s_bit_stream.u4_offset > ps_dec->s_bit_stream.u4_max_offset))
 {
 return IMPEG2D_FRM_HDR_START_CODE_NOT_FOUND;
 }

 }
 /* If the stream is MPEG-1 compliant stream */
 else
 {
 while((u4_start_code_found == 0) && (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))
 {
            u4_next_bits = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);

 if(impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) == SEQUENCE_HEADER_CODE)
 {
 if(ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset)
 {
                    e_error = impeg2d_dec_seq_hdr(ps_dec);
 if ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE != e_error)
 {
 return e_error;
 }

                    u4_start_code_found = 0;
 }
 else
 {
 return IMPEG2D_BITSTREAM_BUFF_EXCEEDED_ERR;
 }
 }
 else if((ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset) && (u4_next_bits == EXTENSION_START_CODE || u4_next_bits == USER_DATA_START_CODE))
 {
                impeg2d_flush_ext_and_user_data(ps_dec);
                u4_start_code_found = 0;
 }


 else if ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) == GOP_START_CODE)
 && (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))
 {
                impeg2d_dec_grp_of_pic_hdr(ps_dec);
                impeg2d_flush_ext_and_user_data(ps_dec);
                u4_start_code_found = 0;
 }
 else if ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) == PICTURE_START_CODE)
 && (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))
 {
                ps_dec->i4_pic_count++;

                e_error = impeg2d_dec_pic_hdr(ps_dec);
 if ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE != e_error)
 {
 return e_error;
 }
                impeg2d_flush_ext_and_user_data(ps_dec);
                impeg2d_pre_pic_dec_proc(ps_dec);
                impeg2d_dec_pic_data(ps_dec);
                impeg2d_post_pic_dec_proc(ps_dec);
                u4_start_code_found = 1;
 }
 else
 {
                FLUSH_BITS(ps_dec->s_bit_stream.u4_offset, ps_dec->s_bit_stream.u4_buf, ps_dec->s_bit_stream.u4_buf_nxt, 8, ps_dec->s_bit_stream.pu4_buf_aligned);
 }
            impeg2d_next_start_code(ps_dec);
 if (0 == u4_start_code_found)
 {
 /* In case a dec_pic_data call has not been made, the number of
                 * bytes consumed in the previous header decode has to be
                 * consumed. Not consuming it will result in zero bytes consumed
                 * loops in case there are multiple headers and the second
                 * or a future header has a resolution change/other error where
                 * the bytes of the last header are not consumed.
                 */
                ps_dec->i4_bytes_consumed = (ps_dec->s_bit_stream.u4_offset + 7) >> 3;
                ps_dec->i4_bytes_consumed -= ((size_t)ps_dec->s_bit_stream.pv_bs_buf & 3);
 }
 }
 if((u4_start_code_found == 0) && (ps_dec->s_bit_stream.u4_offset > ps_dec->s_bit_stream.u4_max_offset))
 {
 return IMPEG2D_FRM_HDR_START_CODE_NOT_FOUND;
 }
 }

 return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;
}

void impeg2d_dec_pic_data_thread(dec_state_t *ps_dec)
{
    WORD32 i4_continue_decode;

    WORD32 i4_cur_row, temp;
    UWORD32 u4_bits_read;
    WORD32 i4_dequeue_job;
    IMPEG2D_ERROR_CODES_T e_error;

    i4_cur_row = ps_dec->u2_mb_y + 1;

    i4_continue_decode = 1;

    i4_dequeue_job = 1;
 do
 {
 if(i4_cur_row > ps_dec->u2_num_vert_mb)
 {
            i4_continue_decode = 0;
 break;
 }

 {
 if((ps_dec->i4_num_cores> 1) && (i4_dequeue_job))
 {
 job_t s_job;
                IV_API_CALL_STATUS_T e_ret;
                UWORD8 *pu1_buf;

                e_ret = impeg2_jobq_dequeue(ps_dec->pv_jobq, &s_job, sizeof(s_job), 1, 1);
 if(e_ret != IV_SUCCESS)
 break;

 if(CMD_PROCESS == s_job.i4_cmd)
 {
                    pu1_buf = ps_dec->pu1_inp_bits_buf + s_job.i4_bistream_ofst;
                    impeg2d_bit_stream_init(&(ps_dec->s_bit_stream), pu1_buf,
 (ps_dec->u4_num_inp_bytes - s_job.i4_bistream_ofst));
                    i4_cur_row      = s_job.i2_start_mb_y;
                    ps_dec->i4_start_mb_y = s_job.i2_start_mb_y;
                    ps_dec->i4_end_mb_y = s_job.i2_end_mb_y;
                    ps_dec->u2_mb_x = 0;
                    ps_dec->u2_mb_y = ps_dec->i4_start_mb_y;
                    ps_dec->u2_num_mbs_left = (ps_dec->i4_end_mb_y - ps_dec->i4_start_mb_y) * ps_dec->u2_num_horiz_mb;

 }
 else
 {
                    WORD32 start_row;
                    WORD32 num_rows;
                    start_row = s_job.i2_start_mb_y << 4;
                    num_rows = MIN((s_job.i2_end_mb_y << 4), ps_dec->u2_vertical_size);
                    num_rows -= start_row;

 if(ps_dec->u4_deinterlace && (0 == ps_dec->u2_progressive_frame))
 {
                        impeg2d_deinterlace(ps_dec,
                                            ps_dec->ps_disp_pic,
                                            ps_dec->ps_disp_frm_buf,
                                            start_row,
                                            num_rows);

 }
 else
 {
                        impeg2d_format_convert(ps_dec, ps_dec->ps_disp_pic,
                                               ps_dec->ps_disp_frm_buf,
                                               start_row, num_rows);
 }
 break;

 }

 }
            e_error = impeg2d_dec_slice(ps_dec);

 if ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE != e_error)
 {
                impeg2d_next_start_code(ps_dec);
 if(ps_dec->s_bit_stream.u4_offset >= ps_dec->s_bit_stream.u4_max_offset)
 {
                    ps_dec->u4_error_code = IMPEG2D_BITSTREAM_BUFF_EXCEEDED_ERR;
 return;
 }
 }
 }

 /* Detecting next slice start code */
 while(1)
 {
            u4_bits_read = impeg2d_bit_stream_nxt(&ps_dec->s_bit_stream,START_CODE_LEN);
            temp = u4_bits_read & 0xFF;
            i4_continue_decode = (((u4_bits_read >> 8) == 0x01) && (temp) && (temp <= 0xAF));

 if (1 == ps_dec->i4_num_cores && 0 == ps_dec->u2_num_mbs_left)
 {
                i4_continue_decode = 0;
#ifdef __ANDROID__
                android_errorWriteLog(0x534e4554, "26070014");
#endif
 }

 if(i4_continue_decode)
 {
 /* If the slice is from the same row, then continue decoding without dequeue */
 if((temp - 1) == i4_cur_row)
 {
                    i4_dequeue_job = 0;
 break;
 }

 if(temp < ps_dec->i4_end_mb_y)
 {
                    i4_cur_row = ps_dec->u2_mb_y;
 }
 else
 {
                    i4_dequeue_job = 1;
 }
 break;

 }
 else
 break;
 }

 }while(i4_continue_decode);
 if(ps_dec->i4_num_cores > 1)
 {
 while(1)
 {
 job_t s_job;
            IV_API_CALL_STATUS_T e_ret;

            e_ret = impeg2_jobq_dequeue(ps_dec->pv_jobq, &s_job, sizeof(s_job), 1, 1);
 if(e_ret != IV_SUCCESS)
 break;
 if(CMD_FMTCONV == s_job.i4_cmd)
 {
                WORD32 start_row;
                WORD32 num_rows;
                start_row = s_job.i2_start_mb_y << 4;
                num_rows = MIN((s_job.i2_end_mb_y << 4), ps_dec->u2_vertical_size);
                num_rows -= start_row;
 if(ps_dec->u4_deinterlace && (0 == ps_dec->u2_progressive_frame))
 {
                    impeg2d_deinterlace(ps_dec,
                                        ps_dec->ps_disp_pic,
                                        ps_dec->ps_disp_frm_buf,
                                        start_row,
                                        num_rows);

 }
 else
 {
                    impeg2d_format_convert(ps_dec,
                                           ps_dec->ps_disp_pic,
                                           ps_dec->ps_disp_frm_buf,
                                           start_row,
                                           num_rows);
 }
 }
 }
 }
 else
 {
 if((NULL != ps_dec->ps_disp_pic) && ((0 == ps_dec->u4_share_disp_buf) || (IV_YUV_420P != ps_dec->i4_chromaFormat)))
 {
 if(ps_dec->u4_deinterlace && (0 == ps_dec->u2_progressive_frame))
 {
                impeg2d_deinterlace(ps_dec,
                                    ps_dec->ps_disp_pic,
                                    ps_dec->ps_disp_frm_buf,
 0,
                                    ps_dec->u2_vertical_size);

 }
 else
 {
                impeg2d_format_convert(ps_dec, ps_dec->ps_disp_pic,
                                        ps_dec->ps_disp_frm_buf,
 0, ps_dec->u2_vertical_size);
 }
 }
 }
}

UWORD16 impeg2d_get_mb_addr_incr(stream_t *ps_stream)
{
    UWORD16 u2_mb_addr_incr = 0;
 while (impeg2d_bit_stream_nxt(ps_stream,MB_ESCAPE_CODE_LEN) == MB_ESCAPE_CODE &&
            ps_stream->u4_offset < ps_stream->u4_max_offset)
 {
        impeg2d_bit_stream_flush(ps_stream,MB_ESCAPE_CODE_LEN);
        u2_mb_addr_incr += 33;
 }
    u2_mb_addr_incr += impeg2d_dec_vld_symbol(ps_stream,gai2_impeg2d_mb_addr_incr,MB_ADDR_INCR_LEN) +
        MB_ADDR_INCR_OFFSET;
 return(u2_mb_addr_incr);
}

void impeg2d_format_convert(dec_state_t *ps_dec,
 pic_buf_t *ps_src_pic,
 iv_yuv_buf_t *ps_disp_frm_buf,
                            UWORD32 u4_start_row, UWORD32 u4_num_rows)
{
    UWORD8  *pu1_src_y,*pu1_src_u,*pu1_src_v;
    UWORD8  *pu1_dst_y,*pu1_dst_u,*pu1_dst_v;



 if((NULL == ps_src_pic) || (NULL == ps_src_pic->pu1_y) || (0 == u4_num_rows))
 return;

    pu1_src_y   = ps_src_pic->pu1_y + (u4_start_row * ps_dec->u2_frame_width);
    pu1_src_u   = ps_src_pic->pu1_u + ((u4_start_row >> 1) * (ps_dec->u2_frame_width >> 1));
    pu1_src_v   = ps_src_pic->pu1_v + ((u4_start_row >> 1) *(ps_dec->u2_frame_width >> 1));

    pu1_dst_y  = (UWORD8 *)ps_disp_frm_buf->pv_y_buf + (u4_start_row *  ps_dec->u4_frm_buf_stride);
    pu1_dst_u = (UWORD8 *)ps_disp_frm_buf->pv_u_buf +((u4_start_row >> 1)*(ps_dec->u4_frm_buf_stride >> 1));
    pu1_dst_v = (UWORD8 *)ps_disp_frm_buf->pv_v_buf +((u4_start_row >> 1)*(ps_dec->u4_frm_buf_stride >> 1));

 if (IV_YUV_420P == ps_dec->i4_chromaFormat)
 {
        ps_dec->pf_copy_yuv420p_buf(pu1_src_y, pu1_src_u, pu1_src_v, pu1_dst_y,
                                    pu1_dst_u, pu1_dst_v,
                                    ps_dec->u2_horizontal_size,
                                    u4_num_rows,
                                    ps_dec->u2_frame_width,
 (ps_dec->u2_frame_width >> 1),
 (ps_dec->u2_frame_width >> 1),
                                    ps_dec->u4_frm_buf_stride,
 (ps_dec->u4_frm_buf_stride >> 1),
 (ps_dec->u4_frm_buf_stride >> 1));
 }
 else if (IV_YUV_422ILE == ps_dec->i4_chromaFormat)
 {
 void *pv_yuv422i;
        UWORD32 u2_height,u2_width,u2_stride_y,u2_stride_u,u2_stride_v;
        UWORD32 u2_stride_yuv422i;


        pv_yuv422i          = (UWORD8 *)ps_disp_frm_buf->pv_y_buf + ((ps_dec->u2_vertical_size)*(ps_dec->u4_frm_buf_stride));
        u2_height           = u4_num_rows;
        u2_width            = ps_dec->u2_horizontal_size;
        u2_stride_y         = ps_dec->u2_frame_width;
        u2_stride_u         = u2_stride_y >> 1;
        u2_stride_v         = u2_stride_u;
        u2_stride_yuv422i   = (0 == ps_dec->u4_frm_buf_stride) ? ps_dec->u2_horizontal_size : ps_dec->u4_frm_buf_stride;

        ps_dec->pf_fmt_conv_yuv420p_to_yuv422ile(pu1_src_y,
            pu1_src_u,
            pu1_src_v,
            pv_yuv422i,
            u2_width,
            u2_height,
            u2_stride_y,
            u2_stride_u,
            u2_stride_v,
            u2_stride_yuv422i);

 }
 else if((ps_dec->i4_chromaFormat == IV_YUV_420SP_UV) ||
 (ps_dec->i4_chromaFormat == IV_YUV_420SP_VU))
 {

        UWORD32 dest_inc_Y=0,dest_inc_UV=0;
        WORD32 convert_uv_only;

        pu1_dst_u = (UWORD8 *)ps_disp_frm_buf->pv_u_buf +((u4_start_row >> 1)*(ps_dec->u4_frm_buf_stride));
        dest_inc_Y =    ps_dec->u4_frm_buf_stride;
        dest_inc_UV = ((ps_dec->u4_frm_buf_stride + 1) >> 1) << 1;
        convert_uv_only = 0;

 if(1 == ps_dec->u4_share_disp_buf)
            convert_uv_only = 1;

 if(pu1_src_y == pu1_dst_y)
            convert_uv_only = 1;

 if(ps_dec->i4_chromaFormat == IV_YUV_420SP_UV)
 {
            ps_dec->pf_fmt_conv_yuv420p_to_yuv420sp_uv(pu1_src_y,
                pu1_src_u,
                pu1_src_v,
                pu1_dst_y,
                pu1_dst_u,
                u4_num_rows,
                ps_dec->u2_horizontal_size,
                ps_dec->u2_frame_width,
                ps_dec->u2_frame_width >> 1,
                ps_dec->u2_frame_width >> 1,
                dest_inc_Y,
                dest_inc_UV,
                convert_uv_only);
 }
 else
 {
            ps_dec->pf_fmt_conv_yuv420p_to_yuv420sp_vu(pu1_src_y,
                    pu1_src_u,
                    pu1_src_v,
                    pu1_dst_y,
                    pu1_dst_u,
                    u4_num_rows,
                    ps_dec->u2_horizontal_size,
                    ps_dec->u2_frame_width,
                    ps_dec->u2_frame_width >> 1,
                    ps_dec->u2_frame_width >> 1,
                    dest_inc_Y,
                    dest_inc_UV,
                    convert_uv_only);
 }



 }

}

IMPEG2D_ERROR_CODES_T impeg2d_dec_seq_hdr(dec_state_t *ps_dec)
{
 stream_t *ps_stream;
    ps_stream = &ps_dec->s_bit_stream;
    UWORD16 u2_height;
    UWORD16 u2_width;

 if (impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != SEQUENCE_HEADER_CODE)
 {
        impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);
 return IMPEG2D_FRM_HDR_START_CODE_NOT_FOUND;

 }
    impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);

    u2_width    = impeg2d_bit_stream_get(ps_stream,12);
    u2_height   = impeg2d_bit_stream_get(ps_stream,12);

 if (0 == u2_width || 0 == u2_height)
 {
        IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_FRM_HDR_DECODE_ERR;
 return e_error;
 }

 if ((u2_width != ps_dec->u2_horizontal_size)
 || (u2_height != ps_dec->u2_vertical_size))
 {
 if (0 == ps_dec->u2_header_done)
 {
 /* This is the first time we are reading the resolution */
            ps_dec->u2_horizontal_size = u2_width;
            ps_dec->u2_vertical_size = u2_height;
 if (0 == ps_dec->u4_frm_buf_stride)
 {
                ps_dec->u4_frm_buf_stride  = (UWORD32) (u2_width);
 }
 }
 else
 {
 if (0 == ps_dec->i4_pic_count)
 {
 /* Decoder has not decoded a single frame since the last
                 * reset/init. This implies that we have two headers in the
                 * input stream. So, do not indicate a resolution change, since
                 * this can take the decoder into an infinite loop.
                 */
 return (IMPEG2D_ERROR_CODES_T) IMPEG2D_FRM_HDR_DECODE_ERR;
 }
 else if((u2_width > ps_dec->u2_create_max_width)
 || (u2_height > ps_dec->u2_create_max_height))
 {
                IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS;

                ps_dec->u2_reinit_max_height   = u2_height;
                ps_dec->u2_reinit_max_width    = u2_width;

 return e_error;
 }
 else
 {
 /* The resolution has changed */
 return (IMPEG2D_ERROR_CODES_T)IVD_RES_CHANGED;
 }
 }
 }

 if((ps_dec->u2_horizontal_size > ps_dec->u2_create_max_width)
 || (ps_dec->u2_vertical_size > ps_dec->u2_create_max_height))
 {
        IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS;
        ps_dec->u2_reinit_max_height   = ps_dec->u2_vertical_size;
        ps_dec->u2_reinit_max_width    = ps_dec->u2_horizontal_size;
 return e_error;
 }


 /*------------------------------------------------------------------------*/
 /* Flush the following as they are not being used                         */
 /* aspect_ratio_info (4 bits)                                             */
 /*------------------------------------------------------------------------*/
    ps_dec->u2_aspect_ratio_info = impeg2d_bit_stream_get(ps_stream,4);

 /*------------------------------------------------------------------------*/
 /* Frame rate code(4 bits)                                                */
 /*------------------------------------------------------------------------*/
    ps_dec->u2_frame_rate_code = impeg2d_bit_stream_get(ps_stream,4);
 if (ps_dec->u2_frame_rate_code > MPEG2_MAX_FRAME_RATE_CODE)
 {
 return IMPEG2D_FRM_HDR_DECODE_ERR;
 }
 /*------------------------------------------------------------------------*/
 /* Flush the following as they are not being used                         */
 /* bit_rate_value (18 bits)                                               */
 /*------------------------------------------------------------------------*/
    impeg2d_bit_stream_flush(ps_stream,18);
    GET_MARKER_BIT(ps_dec,ps_stream);
 /*------------------------------------------------------------------------*/
 /* Flush the following as they are not being used                         */
 /* vbv_buffer_size_value(10 bits), constrained_parameter_flag (1 bit)     */
 /*------------------------------------------------------------------------*/
    impeg2d_bit_stream_flush(ps_stream,11);

 /*------------------------------------------------------------------------*/
 /* Quantization matrix for the intra blocks                               */
 /*------------------------------------------------------------------------*/
 if(impeg2d_bit_stream_get_bit(ps_stream) == 1)
 {
        UWORD16 i;
 for(i = 0; i < NUM_PELS_IN_BLOCK; i++)
 {
            ps_dec->au1_intra_quant_matrix[gau1_impeg2_inv_scan_zig_zag[i]] = (UWORD8)impeg2d_bit_stream_get(ps_stream,8);
 }

 }
 else
 {
        memcpy(ps_dec->au1_intra_quant_matrix,gau1_impeg2_intra_quant_matrix_default,
                NUM_PELS_IN_BLOCK);
 }

 /*------------------------------------------------------------------------*/
 /* Quantization matrix for the inter blocks                               */
 /*------------------------------------------------------------------------*/
 if(impeg2d_bit_stream_get_bit(ps_stream) == 1)
 {
        UWORD16 i;
 for(i = 0; i < NUM_PELS_IN_BLOCK; i++)
 {
            ps_dec->au1_inter_quant_matrix[gau1_impeg2_inv_scan_zig_zag[i]] = (UWORD8)impeg2d_bit_stream_get(ps_stream,8);
 }
 }
 else
 {
        memcpy(ps_dec->au1_inter_quant_matrix,gau1_impeg2_inter_quant_matrix_default,
            NUM_PELS_IN_BLOCK);
 }
    impeg2d_next_start_code(ps_dec);

 return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;
}

IMPEG2D_ERROR_CODES_T impeg2d_pre_pic_dec_proc(dec_state_t *ps_dec)
{
    WORD32 u4_get_disp;
 pic_buf_t *ps_disp_pic;
    IMPEG2D_ERROR_CODES_T e_error = (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;

    u4_get_disp = 0;
    ps_disp_pic = NULL;

 /* Field Picture */
 if(ps_dec->u2_picture_structure != FRAME_PICTURE)
 {
        ps_dec->u2_num_vert_mb       = (ps_dec->u2_vertical_size + 31) >> 5;

 if(ps_dec->u2_num_flds_decoded == 0)
 {
 pic_buf_t *ps_pic_buf;
            u4_get_disp = 1;

            ps_pic_buf = impeg2_buf_mgr_get_next_free(ps_dec->pv_pic_buf_mg, &ps_dec->i4_cur_buf_id);

 if (NULL == ps_pic_buf)
 {
 return IMPEG2D_NO_FREE_BUF_ERR;
 }

            impeg2_buf_mgr_set_status((buf_mgr_t *)ps_dec->pv_pic_buf_mg, ps_dec->i4_cur_buf_id, BUF_MGR_DISP);
            impeg2_buf_mgr_set_status((buf_mgr_t *)ps_dec->pv_pic_buf_mg, ps_dec->i4_cur_buf_id, BUF_MGR_REF);
 if(ps_dec->u4_deinterlace)
                impeg2_buf_mgr_set_status((buf_mgr_t *)ps_dec->pv_pic_buf_mg, ps_dec->i4_cur_buf_id, MPEG2_BUF_MGR_DEINT);

            ps_pic_buf->u4_ts = ps_dec->u4_inp_ts;
            ps_pic_buf->e_pic_type = ps_dec->e_pic_type;
            ps_dec->ps_cur_pic = ps_pic_buf;
            ps_dec->s_cur_frm_buf.pu1_y = ps_pic_buf->pu1_y;
            ps_dec->s_cur_frm_buf.pu1_u = ps_pic_buf->pu1_u;
            ps_dec->s_cur_frm_buf.pu1_v = ps_pic_buf->pu1_v;
 }

 if(ps_dec->u2_picture_structure == TOP_FIELD)
 {
            ps_dec->u2_fld_parity = TOP;
 }
 else
 {
            ps_dec->u2_fld_parity = BOTTOM;
 }
        ps_dec->u2_field_dct           = 0;
        ps_dec->u2_read_dct_type        = 0;
        ps_dec->u2_read_motion_type     = 1;
        ps_dec->u2_fld_pic             = 1;
        ps_dec->u2_frm_pic             = 0;
        ps_dec->ps_func_forw_or_back     = gas_impeg2d_func_fld_fw_or_bk;
        ps_dec->ps_func_bi_direct       = gas_impeg2d_func_fld_bi_direct;
 }
 /* Frame Picture */
 else
 {
 pic_buf_t *ps_pic_buf;


        ps_dec->u2_num_vert_mb       = (ps_dec->u2_vertical_size + 15) >> 4;
        u4_get_disp = 1;
        ps_pic_buf = impeg2_buf_mgr_get_next_free(ps_dec->pv_pic_buf_mg, &ps_dec->i4_cur_buf_id);

 if (NULL == ps_pic_buf)
 {
 return IMPEG2D_NO_FREE_BUF_ERR;
 }
        impeg2_buf_mgr_set_status((buf_mgr_t *)ps_dec->pv_pic_buf_mg, ps_dec->i4_cur_buf_id, BUF_MGR_DISP);
        impeg2_buf_mgr_set_status((buf_mgr_t *)ps_dec->pv_pic_buf_mg, ps_dec->i4_cur_buf_id, BUF_MGR_REF);
 if(ps_dec->u4_deinterlace)
            impeg2_buf_mgr_set_status((buf_mgr_t *)ps_dec->pv_pic_buf_mg, ps_dec->i4_cur_buf_id, MPEG2_BUF_MGR_DEINT);

        ps_pic_buf->u4_ts = ps_dec->u4_inp_ts;
        ps_pic_buf->e_pic_type = ps_dec->e_pic_type;
        ps_dec->ps_cur_pic = ps_pic_buf;
        ps_dec->s_cur_frm_buf.pu1_y = ps_pic_buf->pu1_y;
        ps_dec->s_cur_frm_buf.pu1_u = ps_pic_buf->pu1_u;
        ps_dec->s_cur_frm_buf.pu1_v = ps_pic_buf->pu1_v;


 if(ps_dec->u2_frame_pred_frame_dct == 0)
 {
            ps_dec->u2_read_dct_type    = 1;
            ps_dec->u2_read_motion_type = 1;
 }
 else
 {
            ps_dec->u2_read_dct_type    = 0;
            ps_dec->u2_read_motion_type = 0;
            ps_dec->u2_motion_type     = 2;
            ps_dec->u2_field_dct       = 0;
 }

        ps_dec->u2_fld_parity          = TOP;
        ps_dec->u2_fld_pic             = 0;
        ps_dec->u2_frm_pic             = 1;
        ps_dec->ps_func_forw_or_back     = gas_impeg2d_func_frm_fw_or_bk;
        ps_dec->ps_func_bi_direct       = gas_impeg2d_func_frm_bi_direct;
 }
    ps_dec->u2_def_dc_pred[Y_LUMA] = 128 << ps_dec->u2_intra_dc_precision;
    ps_dec->u2_def_dc_pred[U_CHROMA] = 128 << ps_dec->u2_intra_dc_precision;
    ps_dec->u2_def_dc_pred[V_CHROMA] = 128 << ps_dec->u2_intra_dc_precision;
    ps_dec->u2_num_mbs_left  = ps_dec->u2_num_horiz_mb * ps_dec->u2_num_vert_mb;
 if(u4_get_disp)
 {
 if(ps_dec->u4_num_frames_decoded > 1)
 {
            ps_disp_pic = impeg2_disp_mgr_get(&ps_dec->s_disp_mgr, &ps_dec->i4_disp_buf_id);
 }
        ps_dec->ps_disp_pic = ps_disp_pic;
 if(ps_disp_pic)
 {
 if(1 == ps_dec->u4_share_disp_buf)
 {
                ps_dec->ps_disp_frm_buf->pv_y_buf  = ps_disp_pic->pu1_y;
 if(IV_YUV_420P == ps_dec->i4_chromaFormat)
 {
                    ps_dec->ps_disp_frm_buf->pv_u_buf  = ps_disp_pic->pu1_u;
                    ps_dec->ps_disp_frm_buf->pv_v_buf  = ps_disp_pic->pu1_v;
 }
 else
 {
                    UWORD8 *pu1_buf;

                    pu1_buf = ps_dec->as_disp_buffers[ps_disp_pic->i4_buf_id].pu1_bufs[1];
                    ps_dec->ps_disp_frm_buf->pv_u_buf  = pu1_buf;

                    pu1_buf = ps_dec->as_disp_buffers[ps_disp_pic->i4_buf_id].pu1_bufs[2];
                    ps_dec->ps_disp_frm_buf->pv_v_buf  = pu1_buf;
 }
 }
 }
 }


 switch(ps_dec->e_pic_type)
 {
 case I_PIC:
 {
            ps_dec->pf_decode_slice = impeg2d_dec_i_slice;
 break;
 }
 case D_PIC:
 {
            ps_dec->pf_decode_slice = impeg2d_dec_d_slice;
 break;
 }
 case P_PIC:
 {
            ps_dec->pf_decode_slice = impeg2d_dec_p_b_slice;
            ps_dec->pu2_mb_type       = gau2_impeg2d_p_mb_type;
 break;
 }
 case B_PIC:
 {
            ps_dec->pf_decode_slice = impeg2d_dec_p_b_slice;
            ps_dec->pu2_mb_type       = gau2_impeg2d_b_mb_type;
 break;
 }
 default:
 return IMPEG2D_INVALID_PIC_TYPE;
 }

 /*************************************************************************/
 /* Set the reference pictures                                            */
 /*************************************************************************/

 /* Error resilience: If forward and backward pictures are going to be NULL*/
 /* then assign both to the current                                        */
 /* if one of them NULL then we will assign the non null to the NULL one   */

 if(ps_dec->e_pic_type == P_PIC)
 {
 if (NULL == ps_dec->as_recent_fld[1][0].pu1_y)
 {
            ps_dec->as_recent_fld[1][0] = ps_dec->s_cur_frm_buf;
 }
 if (NULL == ps_dec->as_recent_fld[1][1].pu1_y)
 {
            impeg2d_get_bottom_field_buf(&ps_dec->s_cur_frm_buf, &ps_dec->as_recent_fld[1][1],
                ps_dec->u2_frame_width);
 }

        ps_dec->as_ref_buf[FORW][TOP] = ps_dec->as_recent_fld[1][0];
        ps_dec->as_ref_buf[FORW][BOTTOM] = ps_dec->as_recent_fld[1][1];


 }
 else if(ps_dec->e_pic_type == B_PIC)
 {
 if((NULL == ps_dec->as_recent_fld[1][0].pu1_y) && (NULL == ps_dec->as_recent_fld[0][0].pu1_y))
 {
            ps_dec->as_recent_fld[1][0] = ps_dec->s_cur_frm_buf;
            impeg2d_get_bottom_field_buf(&ps_dec->s_cur_frm_buf, &ps_dec->as_recent_fld[1][1],
                ps_dec->u2_frame_width);
            ps_dec->as_recent_fld[0][0] = ps_dec->s_cur_frm_buf;
            ps_dec->as_recent_fld[0][1] = ps_dec->as_recent_fld[1][1];
 }
 else if ((NULL != ps_dec->as_recent_fld[1][0].pu1_y) && (NULL == ps_dec->as_recent_fld[0][0].pu1_y))
 {
            ps_dec->as_recent_fld[0][0] = ps_dec->as_recent_fld[1][0];
            ps_dec->as_recent_fld[0][1] = ps_dec->as_recent_fld[1][1];
 }
 else if ((NULL == ps_dec->as_recent_fld[1][0].pu1_y) && (NULL != ps_dec->as_recent_fld[0][0].pu1_y))
 {
            ps_dec->as_recent_fld[1][0] = ps_dec->as_recent_fld[0][0];
            ps_dec->as_recent_fld[1][1] = ps_dec->as_recent_fld[0][1];
 }

 /* Error resilience: If forward and backward pictures are going to be NULL*/
 /* then assign both to the current                                        */
 /* if one of them NULL then we will assign the non null to the NULL one   */

 if((NULL == ps_dec->as_recent_fld[0][1].pu1_y) && (NULL == ps_dec->as_recent_fld[1][1].pu1_y))
 {
            ps_dec->as_recent_fld[1][0] = ps_dec->s_cur_frm_buf;
            impeg2d_get_bottom_field_buf(&ps_dec->s_cur_frm_buf, &ps_dec->as_recent_fld[1][1],
                                         ps_dec->u2_frame_width);
            ps_dec->as_recent_fld[0][0] = ps_dec->s_cur_frm_buf;
            ps_dec->as_recent_fld[0][1] = ps_dec->as_recent_fld[1][1];
 }

 else if((NULL == ps_dec->as_recent_fld[0][1].pu1_y) && (NULL != ps_dec->as_recent_fld[1][1].pu1_y))
 {
            ps_dec->as_recent_fld[0][0] = ps_dec->as_recent_fld[1][0];
            ps_dec->as_recent_fld[0][1] = ps_dec->as_recent_fld[1][1];
 }

 else if((NULL == ps_dec->as_recent_fld[1][1].pu1_y) && (NULL != ps_dec->as_recent_fld[0][1].pu1_y))
 {
            ps_dec->as_recent_fld[1][0] = ps_dec->as_recent_fld[0][0];
            ps_dec->as_recent_fld[1][1] = ps_dec->as_recent_fld[0][1];
 }
        ps_dec->as_ref_buf[FORW][TOP] = ps_dec->as_recent_fld[0][0];
        ps_dec->as_ref_buf[FORW][BOTTOM] = ps_dec->as_recent_fld[0][1];
        ps_dec->as_ref_buf[BACK][TOP] = ps_dec->as_recent_fld[1][0];
        ps_dec->as_ref_buf[BACK][BOTTOM] = ps_dec->as_recent_fld[1][1];


 }

 return e_error;
}

IMPEG2D_ERROR_CODES_T impeg2d_init_video_state(dec_state_t *ps_dec, e_video_type_t e_video_type)
{
 /*-----------------------------------------------------------------------*/
 /* Bit Stream  that conforms to MPEG-1 <ISO/IEC 11172-2> standard        */
 /*-----------------------------------------------------------------------*/
 if(e_video_type == MPEG_1_VIDEO)
 {
        ps_dec->u2_is_mpeg2 = 0;

 /*-------------------------------------------------------------------*/
 /* force MPEG-1 parameters for proper decoder behavior               */
 /* see ISO/IEC 13818-2 section D.9.14                                */
 /*-------------------------------------------------------------------*/
        ps_dec->u2_progressive_sequence         = 1;
        ps_dec->u2_intra_dc_precision           = 0;
        ps_dec->u2_picture_structure            = FRAME_PICTURE;
        ps_dec->u2_frame_pred_frame_dct         = 1;
        ps_dec->u2_concealment_motion_vectors   = 0;
        ps_dec->u2_q_scale_type                 = 0;
        ps_dec->u2_intra_vlc_format             = 0;
        ps_dec->u2_alternate_scan               = 0;
        ps_dec->u2_repeat_first_field           = 0;

         ps_dec->u2_progressive_frame            = 1;
         ps_dec->u2_frame_rate_extension_n       = 0;
         ps_dec->u2_frame_rate_extension_d       = 0;
 
         ps_dec->pf_vld_inv_quant                  = impeg2d_vld_inv_quant_mpeg1;
         /*-------------------------------------------------------------------*/
 /* Setting of parameters other than those mentioned in MPEG2 standard*/
 /* but used in decoding process.                                     */
 /*-------------------------------------------------------------------*/
 }
 /*-----------------------------------------------------------------------*/
 /* Bit Stream  that conforms to MPEG-2                                   */
 /*-----------------------------------------------------------------------*/
 else
 {
        ps_dec->u2_is_mpeg2                  = 1;
        ps_dec->u2_full_pel_forw_vector   = 0;
        ps_dec->u2_forw_f_code            = 7;
        ps_dec->u2_full_pel_back_vector   = 0;
        ps_dec->u2_back_f_code            = 7;
        ps_dec->pf_vld_inv_quant       = impeg2d_vld_inv_quant_mpeg2;


 }


    impeg2d_init_function_ptr(ps_dec);

 /* Set the frame Width and frame Height */
    ps_dec->u2_frame_height        = ALIGN16(ps_dec->u2_vertical_size);
    ps_dec->u2_frame_width         = ALIGN16(ps_dec->u2_horizontal_size);
    ps_dec->u2_num_horiz_mb         = (ps_dec->u2_horizontal_size + 15) >> 4;
 if (ps_dec->u2_frame_height > ps_dec->u2_create_max_height || ps_dec->u2_frame_width > ps_dec->u2_create_max_width)
 {
 return IMPEG2D_PIC_SIZE_NOT_SUPPORTED;
 }

    ps_dec->u2_num_flds_decoded = 0;

 /* Calculate the frame period */
 {
        UWORD32 numer;
        UWORD32 denom;
        numer = (UWORD32)gau2_impeg2_frm_rate_code[ps_dec->u2_frame_rate_code][1] *
 (UWORD32)(ps_dec->u2_frame_rate_extension_d + 1);

        denom = (UWORD32)gau2_impeg2_frm_rate_code[ps_dec->u2_frame_rate_code][0] *
 (UWORD32)(ps_dec->u2_frame_rate_extension_n + 1);
        ps_dec->u2_framePeriod = (numer * 1000 * 100) / denom;
 }


 if(VERTICAL_SCAN == ps_dec->u2_alternate_scan)
 {
    ps_dec->pu1_inv_scan_matrix = (UWORD8 *)gau1_impeg2_inv_scan_vertical;
 }
 else
 {
    ps_dec->pu1_inv_scan_matrix = (UWORD8 *)gau1_impeg2_inv_scan_zig_zag;
 }
 return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;
}
