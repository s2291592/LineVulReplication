TabLifecycleUnitSource::TabLifecycleUnit::AsTabLifecycleUnitExternal() {
  return this;
}

LocalSiteCharacteristicsDataImpl::UsesNotificationsInBackground() const {
  return GetFeatureUsage(
      site_characteristics_.uses_notifications_in_background(),
      GetSiteCharacteristicsDatabaseParams()
          .notifications_usage_observation_window);
}

content::Visibility TestLifecycleUnit::GetVisibility() const {
  return content::Visibility::VISIBLE;
}

void LocalSiteCharacteristicsDataImpl::DecrementNumLoadedBackgroundTabs() {
  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
  DCHECK_GT(loaded_tabs_in_background_count_, 0U);
  loaded_tabs_in_background_count_--;
  if (loaded_tabs_in_background_count_ > 0U)
    return;

  DCHECK(!background_session_begin_.is_null());
  base::TimeDelta extra_observation_duration =
      NowTicks() - background_session_begin_;

  for (auto* iter : GetAllFeaturesFromProto(&site_characteristics_))
    IncrementFeatureObservationDuration(iter, extra_observation_duration);
}

bool TestLifecycleUnit::Unfreeze() {
  return false;
}

void LocalSiteCharacteristicsWebContentsObserver::OnVisibilityChanged(
    content::Visibility visibility) {
  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
  if (!writer_)
    return;

  auto rc_visibility = ContentVisibilityToRCVisibility(visibility);
  writer_->NotifySiteVisibilityChanged(rc_visibility);
}

void LocalSiteCharacteristicsDataImpl::InitWithDefaultValues(
    bool only_init_uninitialized_fields) {
  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
  for (auto* iter : GetAllFeaturesFromProto(&site_characteristics_)) {
    if (!only_init_uninitialized_fields || !iter->IsInitialized())
      InitSiteCharacteristicsFeatureProtoWithDefaultValues(iter);
  }

  if (!only_init_uninitialized_fields ||
      !site_characteristics_.has_last_loaded()) {
    site_characteristics_.set_last_loaded(
        LocalSiteCharacteristicsDataImpl::TimeDeltaToInternalRepresentation(
            base::TimeDelta()));
  }
}

bool TabLifecycleUnitSource::TabLifecycleUnit::Load() {
  if (GetLoadingState() != LifecycleUnitLoadingState::UNLOADED)
    return false;


  GetWebContents()->GetController().SetNeedsReload();
  GetWebContents()->GetController().LoadIfNecessary();
  return true;
}

  explicit LenientMockDataWriter(const url::Origin& origin) : origin_(origin) {}

  LocalSiteCharacteristicsDatabaseTest()
      : scoped_set_tick_clock_for_testing_(&test_clock_),
        test_server_(net::test_server::EmbeddedTestServer::TYPE_HTTPS) {}

  void Wait() {
    EXPECT_NE(expected_state_, lifecycle_unit_->GetState());
    run_loop_.Run();
    EXPECT_EQ(expected_state_, lifecycle_unit_->GetState());
  }

 void ExpectCanDiscardFalseTrivialAllReasons(
    const LifecycleUnit* lifecycle_unit) {
  ExpectCanDiscardFalseTrivial(lifecycle_unit, DiscardReason::kExternal);
  ExpectCanDiscardFalseTrivial(lifecycle_unit, DiscardReason::kProactive);
  ExpectCanDiscardFalseTrivial(lifecycle_unit, DiscardReason::kUrgent);
}

  void TestTransitionFromActiveToPendingFreeze() {
    content::SetupCrossSiteRedirector(embedded_test_server());
    ASSERT_TRUE(embedded_test_server()->Start());

    GURL main_url(
        embedded_test_server()->GetURL("a.com", "/iframe_cross_site.html"));
    OpenTwoTabs(GURL(chrome::kChromeUIAboutURL), main_url);
    constexpr int kFreezingIndex = 1;
    LifecycleUnit* const lifecycle_unit = GetLifecycleUnitAt(kFreezingIndex);
    content::WebContents* const content = GetWebContentsAt(kFreezingIndex);

    content::RenderFrameHost* main_frame = content->GetMainFrame();
    ASSERT_EQ(3u, content->GetAllFrames().size());
    content::RenderFrameHost* child_frame = content->GetAllFrames()[1];
    EXPECT_FALSE(content::SiteInstance::IsSameWebSite(
        browser()->profile(), main_frame->GetLastCommittedURL(),
        child_frame->GetLastCommittedURL()));
    if (content::AreAllSitesIsolatedForTesting()) {
      EXPECT_NE(main_frame->GetProcess()->GetID(),
                child_frame->GetProcess()->GetID());
    }

    bool hidden_state_result;
    EXPECT_TRUE(content::ExecuteScriptAndExtractBool(
        main_frame,
        "window.domAutomationController.send("
        "window.document.hidden);",
        &hidden_state_result));
    EXPECT_TRUE(hidden_state_result);

    EXPECT_TRUE(content::ExecuteScript(
        main_frame,
        "if (window.location.pathname != '/iframe_cross_site.html')"
        "  throw 'Incorrect frame';"
        "mainFrameFreezeCount = 0;"
        "window.document.onfreeze = function(){ mainFrameFreezeCount++; };"));

    EXPECT_TRUE(content::ExecuteScript(
        child_frame,
        "if (window.location.pathname != '/title1.html') throw 'Incorrect "
        "frame';"
        "childFrameFreezeCount = 0;"
        "window.document.onfreeze = function(){ childFrameFreezeCount++; };"));

    int freeze_count_result;
    EXPECT_TRUE(content::ExecuteScriptAndExtractInt(
        main_frame, kMainFrameFrozenStateJS, &freeze_count_result));
    EXPECT_EQ(0, freeze_count_result);
    EXPECT_TRUE(content::ExecuteScriptAndExtractInt(
        child_frame, kChildFrameFrozenStateJS, &freeze_count_result));
    EXPECT_EQ(0, freeze_count_result);

    EXPECT_EQ(LifecycleUnitState::ACTIVE, lifecycle_unit->GetState());
    EXPECT_TRUE(lifecycle_unit->Freeze());
    EXPECT_EQ(LifecycleUnitState::PENDING_FREEZE, lifecycle_unit->GetState());
  }

    SkipObserverRegistrationForTesting() {
  g_skip_observer_registration_for_testing = true;
}

    ~LocalSiteCharacteristicsWebContentsObserver() {
  DCHECK(!writer_);
}

void NoopLocalSiteCharacteristicsDatabase::RemoveSiteCharacteristicsFromDB(
    const std::vector<url::Origin>& site_origins) {}

void ExpectCanDiscardFalseTrivial(const LifecycleUnit* lifecycle_unit,
DiscardReason discard_reason) {
DecisionDetails decision_details;
EXPECT_FALSE(lifecycle_unit->CanDiscard(discard_reason, &decision_details));
EXPECT_FALSE(decision_details.IsPositive());
  EXPECT_TRUE(decision_details.reasons().empty());
}

TestLifecycleUnit::TestLifecycleUnit(content::Visibility visibility)
    : LifecycleUnitBase(visibility) {}

void CloseTabsAndExpectNotifications(
TabStripModel* tab_strip_model,
std::vector<LifecycleUnit*> lifecycle_units) {
    std::vector<std::unique_ptr<testing::StrictMock<MockLifecycleUnitObserver>>>
observers;
for (LifecycleUnit* lifecycle_unit : lifecycle_units) {
observers.emplace_back(
          std::make_unique<testing::StrictMock<MockLifecycleUnitObserver>>());
lifecycle_unit->AddObserver(observers.back().get());
EXPECT_CALL(*observers.back().get(),
OnLifecycleUnitDestroyed(lifecycle_unit));
}
tab_strip_model->CloseAllTabs();
}

LocalSiteCharacteristicsDataImpl::~LocalSiteCharacteristicsDataImpl() {
  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
  DCHECK(!IsLoaded());
  DCHECK_EQ(0U, loaded_tabs_in_background_count_);

  DCHECK(delegate_);
  delegate_->OnLocalSiteCharacteristicsDataImplDestroyed(this);

  if (is_dirty_ && safe_to_write_to_db_) {
    DCHECK(site_characteristics_.IsInitialized());
    database_->WriteSiteCharacteristicsIntoDB(origin_, site_characteristics_);
  }
}

int TabLifecycleUnitSource::TabLifecycleUnit::GetDiscardCount() const {
  return discard_count_;
}

void LocalSiteCharacteristicsDataImpl::IncrementFeatureObservationDuration(
    SiteCharacteristicsFeatureProto* feature_proto,
    base::TimeDelta extra_observation_duration) {
  if (!feature_proto->has_use_timestamp() ||
      InternalRepresentationToTimeDelta(feature_proto->use_timestamp())
          .is_zero()) {
    feature_proto->set_observation_duration(TimeDeltaToInternalRepresentation(
        InternalRepresentationToTimeDelta(
            feature_proto->observation_duration()) +
        extra_observation_duration));
  }
}

::mojom::LifecycleUnitLoadingState TestLifecycleUnit::GetLoadingState() const {
  return ::mojom::LifecycleUnitLoadingState::LOADED;
}

void CreateTwoTabs(bool focus_tab_strip,
LifecycleUnit** first_lifecycle_unit,
LifecycleUnit** second_lifecycle_unit) {
if (focus_tab_strip)
source_->SetFocusedTabStripModelForTesting(tab_strip_model_.get());

// Add a foreground tab to the tab strip.
task_runner_->FastForwardBy(kShortDelay);
auto time_before_first_tab = NowTicks();
    EXPECT_CALL(source_observer_, OnLifecycleUnitCreated(testing::_))
        .WillOnce(testing::Invoke([&](LifecycleUnit* lifecycle_unit) {
*first_lifecycle_unit = lifecycle_unit;

if (focus_tab_strip) {
EXPECT_TRUE(IsFocused(*first_lifecycle_unit));
} else {
EXPECT_EQ(time_before_first_tab,
(*first_lifecycle_unit)->GetLastFocusedTime());
}
}));
std::unique_ptr<content::WebContents> first_web_contents =
CreateAndNavigateWebContents();
content::WebContents* raw_first_web_contents = first_web_contents.get();
tab_strip_model_->AppendWebContents(std::move(first_web_contents), true);
    testing::Mock::VerifyAndClear(&source_observer_);
EXPECT_TRUE(source_->GetTabLifecycleUnitExternal(raw_first_web_contents));

// Add another foreground tab to the focused tab strip.
task_runner_->FastForwardBy(kShortDelay);
auto time_before_second_tab = NowTicks();
    EXPECT_CALL(source_observer_, OnLifecycleUnitCreated(testing::_))
        .WillOnce(testing::Invoke([&](LifecycleUnit* lifecycle_unit) {
*second_lifecycle_unit = lifecycle_unit;

if (focus_tab_strip) {
EXPECT_EQ(time_before_second_tab,
(*first_lifecycle_unit)->GetLastFocusedTime());
EXPECT_TRUE(IsFocused(*second_lifecycle_unit));
} else {
EXPECT_EQ(time_before_first_tab,
(*first_lifecycle_unit)->GetLastFocusedTime());
EXPECT_EQ(time_before_second_tab,
(*second_lifecycle_unit)->GetLastFocusedTime());
}
}));
std::unique_ptr<content::WebContents> second_web_contents =
CreateAndNavigateWebContents();
content::WebContents* raw_second_web_contents = second_web_contents.get();
tab_strip_model_->AppendWebContents(std::move(second_web_contents), true);
    testing::Mock::VerifyAndClear(&source_observer_);
EXPECT_TRUE(source_->GetTabLifecycleUnitExternal(raw_second_web_contents));

// TabStripModel doesn't update the visibility of its WebContents by itself.
raw_first_web_contents->WasHidden();
}

  bool IsTabDiscarded(content::WebContents* content) {
    return TabLifecycleUnitExternal::FromWebContents(content)->IsDiscarded();
  }

std::unique_ptr<SiteCharacteristicsDataReader> GetReaderForOrigin(
Profile* profile,
const url::Origin& origin) {
SiteCharacteristicsDataStore* data_store =
LocalSiteCharacteristicsDataStoreFactory::GetForProfile(profile);
EXPECT_TRUE(data_store);
std::unique_ptr<SiteCharacteristicsDataReader> reader =
data_store->GetReaderForOrigin(origin);

    internal::LocalSiteCharacteristicsDataImpl* impl =
static_cast<LocalSiteCharacteristicsDataReader*>(reader.get())
            ->impl_for_testing()
            .get();
while (!impl->site_characteristics_for_testing().IsInitialized())
base::RunLoop().RunUntilIdle();
return reader;
}

base::TimeTicks TestLifecycleUnit::GetLastFocusedTime() const {
  return last_focused_time_;
}

TestLifecycleUnit::~TestLifecycleUnit() {
  OnLifecycleUnitDestroyed();
}

void TabLifecycleUnitSource::TabLifecycleUnit::SetWebContents(
    content::WebContents* web_contents) {
  DCHECK(web_contents);
  Observe(web_contents);
}

base::ProcessHandle TabLifecycleUnitSource::TabLifecycleUnit::GetProcessHandle()
    const {
  content::RenderFrameHost* main_frame = GetWebContents()->GetMainFrame();
  if (!main_frame)
    return base::ProcessHandle();
  content::RenderProcessHost* process = main_frame->GetProcess();
  if (!process)
    return base::ProcessHandle();
  return process->GetProcess().Handle();
}

void LocalSiteCharacteristicsWebContentsObserver::WebContentsDestroyed() {
  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
  if (!g_skip_observer_registration_for_testing) {
    TabLoadTracker::Get()->RemoveObserver(this);
    PageSignalReceiver::GetInstance()->RemoveObserver(this);
  }
  writer_.reset();
  writer_origin_ = url::Origin();
}

Browser* CreateBrowserWithTabs(int num_tabs) {
  Browser* current_browser = BrowserList::GetInstance()->GetLastActive();
  ui_test_utils::BrowserAddedObserver browser_added_observer;
  chrome::NewWindow(current_browser);
  Browser* new_browser = browser_added_observer.WaitForSingleNewBrowser();
  EXPECT_EQ(new_browser, BrowserList::GetInstance()->GetLastActive());
  EnsureTabsInBrowser(new_browser, num_tabs);
  return new_browser;
}

void EnsureTabsInBrowser(Browser* browser, int num_tabs) {
  for (int i = 0; i < num_tabs; ++i) {
    ui_test_utils::NavigateToURLWithDisposition(
        browser, GURL(chrome::kChromeUICreditsURL),
        i == 0 ? WindowOpenDisposition::CURRENT_TAB
               : WindowOpenDisposition::NEW_BACKGROUND_TAB,
        ui_test_utils::BROWSER_TEST_WAIT_FOR_NAVIGATION);
  }

  EXPECT_EQ(num_tabs, browser->tab_strip_model()->count());
}

bool TestLifecycleUnit::CanFreeze(DecisionDetails* decision_details) const {
  return false;
}

TabLifecycleUnitSource::TabLifecycleUnit::~TabLifecycleUnit() {
  OnLifecycleUnitDestroyed();
}

LifecycleUnit::SortKey TestLifecycleUnit::GetSortKey() const {
  return SortKey(last_focused_time_);
}

int TestLifecycleUnit::GetEstimatedMemoryFreedOnDiscardKB() const {
  return 0;
}

  ExpectStateTransitionObserver(LifecycleUnit* lifecyle_unit,
                                LifecycleUnitState expected_state)
      : lifecycle_unit_(lifecyle_unit), expected_state_(expected_state) {
    lifecycle_unit_->AddObserver(this);
  }

TabLifecycleUnitSource::TabLifecycleUnit::GetRenderProcessHost() const {
  return GetWebContents()->GetMainFrame()->GetProcess();
}

void CanOnlyDiscardOnceTest(DiscardReason reason) {
LifecycleUnit* background_lifecycle_unit = nullptr;
LifecycleUnit* foreground_lifecycle_unit = nullptr;
CreateTwoTabs(true /* focus_tab_strip */, &background_lifecycle_unit,
&foreground_lifecycle_unit);
content::WebContents* initial_web_contents =
tab_strip_model_->GetWebContentsAt(0);

// It should be possible to discard the background tab.
ExpectCanDiscardTrueAllReasons(background_lifecycle_unit);

// Discard the tab.
EXPECT_EQ(LifecycleUnitState::ACTIVE,
background_lifecycle_unit->GetState());
    EXPECT_CALL(tab_observer_, OnDiscardedStateChange(testing::_, true));
background_lifecycle_unit->Discard(reason);

    testing::Mock::VerifyAndClear(&tab_observer_);

TransitionFromPendingDiscardToDiscardedIfNeeded(reason,
background_lifecycle_unit);

EXPECT_NE(initial_web_contents, tab_strip_model_->GetWebContentsAt(0));
EXPECT_FALSE(tab_strip_model_->GetWebContentsAt(0)
->GetController()
.GetPendingEntry());

// Explicitly reload the tab. Expect the state to be LOADED.
    EXPECT_CALL(tab_observer_, OnDiscardedStateChange(testing::_, false));
tab_strip_model_->GetWebContentsAt(0)->GetController().Reload(
content::ReloadType::NORMAL, false);
    testing::Mock::VerifyAndClear(&tab_observer_);
EXPECT_EQ(LifecycleUnitState::ACTIVE,
background_lifecycle_unit->GetState());
EXPECT_TRUE(tab_strip_model_->GetWebContentsAt(0)
->GetController()
.GetPendingEntry());

// It shouldn't be possible to discard the background tab again, except for
// an urgent discard on ChromeOS.
ExpectCanDiscardFalseTrivial(background_lifecycle_unit,
DiscardReason::kExternal);
ExpectCanDiscardFalseTrivial(background_lifecycle_unit,
DiscardReason::kProactive);
#if defined(OS_CHROMEOS)
ExpectCanDiscardTrue(background_lifecycle_unit, DiscardReason::kUrgent);
#else
ExpectCanDiscardFalseTrivial(background_lifecycle_unit,
DiscardReason::kUrgent);
#endif
}

void TabLifecycleUnitSource::TabLifecycleUnit::SetTabStripModel(
    TabStripModel* tab_strip_model) {
  tab_strip_model_ = tab_strip_model;
}

base::ProcessHandle TestLifecycleUnit::GetProcessHandle() const {
  return process_handle_;
}

bool TestLifecycleUnit::Load() {
  return false;
}

bool IsFocused(LifecycleUnit* lifecycle_unit) {
   return lifecycle_unit->GetLastFocusedTime() == base::TimeTicks::Max();
 }

content::Visibility TabLifecycleUnitSource::TabLifecycleUnit::GetVisibility()
    const {
  return GetWebContents()->GetVisibility();
}

bool TestLifecycleUnit::Discard(DiscardReason discard_reason) {
  return false;
}

void ExpectCanDiscardTrue(const LifecycleUnit* lifecycle_unit,
                          DiscardReason discard_reason) {
  DecisionDetails decision_details;
  EXPECT_TRUE(lifecycle_unit->CanDiscard(discard_reason, &decision_details));
  EXPECT_TRUE(decision_details.IsPositive());
  EXPECT_EQ(1u, decision_details.reasons().size());
  EXPECT_EQ(DecisionSuccessReason::HEURISTIC_OBSERVED_TO_BE_SAFE,
            decision_details.SuccessReason());
}

 LocalSiteCharacteristicsDataImpl::LocalSiteCharacteristicsDataImpl(
     const url::Origin& origin,
     OnDestroyDelegate* delegate,
    LocalSiteCharacteristicsDatabase* database)
    : origin_(origin),
      loaded_tabs_count_(0U),
      loaded_tabs_in_background_count_(0U),
      database_(database),
      delegate_(delegate),
      safe_to_write_to_db_(false),
      is_dirty_(false),
      weak_factory_(this) {
  DCHECK(database_);
  DCHECK(delegate_);
  DCHECK(!site_characteristics_.IsInitialized());

  database_->ReadSiteCharacteristicsFromDB(
      origin_, base::BindOnce(&LocalSiteCharacteristicsDataImpl::OnInitCallback,
                              weak_factory_.GetWeakPtr()));
}

void TabLifecycleUnitSource::TabLifecycleUnit::DidStartLoading() {
  if (IsDiscardedOrPendingDiscard(GetState()))
    SetState(LifecycleUnitState::ACTIVE, StateChangeReason::BROWSER_INITIATED);
}

   TabLifecycleUnitSourceTest()
       : scoped_context_(
            std::make_unique<base::TestMockTimeTaskRunner::ScopedContext>(
                task_runner_)),
        scoped_set_tick_clock_for_testing_(task_runner_->GetMockTickClock()) {
    base::MessageLoopCurrent::Get()->SetTaskRunner(task_runner_);
   }

void LocalSiteCharacteristicsDataImpl::NotifyUsesNotificationsInBackground() {
  NotifyFeatureUsage(
       site_characteristics_.mutable_uses_notifications_in_background());
 }

bool TabLifecycleUnitSource::TabLifecycleUnit::IsDiscarded() const {
  return IsDiscardedOrPendingDiscard(GetState());
}

  TabLifecycleUnitTest() : scoped_set_tick_clock_for_testing_(&test_clock_) {
    observers_.AddObserver(&observer_);
   }

  explicit NonResumingBackgroundTabNavigationThrottle(
      content::NavigationHandle* handle)
      : BackgroundTabNavigationThrottle(handle) {}

bool TabLifecycleUnitSource::TabLifecycleUnit::CanFreeze(
DecisionDetails* decision_details) const {
DCHECK(decision_details->reasons().empty());

// Leave the |decision_details| empty and return immediately for "trivial"
// rejection reasons. These aren't worth reporting about, as they have nothing
// to do with the content itself.

if (!IsValidStateChange(GetState(), LifecycleUnitState::PENDING_FREEZE,
StateChangeReason::BROWSER_INITIATED)) {
return false;
}

// Allow a page to load fully before freezing it.
if (TabLoadTracker::Get()->GetLoadingState(GetWebContents()) !=
TabLoadTracker::LoadingState::LOADED) {
return false;
}

  // TODO(chrisha): Integrate local database observations into this policy
  // decision.
// We deliberately run through all of the logic without early termination.
// This ensures that the decision details lists all possible reasons that the
// transition can be denied.

if (GetWebContents()->GetVisibility() == content::Visibility::VISIBLE)
decision_details->AddReason(DecisionFailureReason::LIVE_STATE_VISIBLE);

// Do not freeze tabs that are casting/mirroring/playing audio.
IsMediaTabImpl(decision_details);

  // TODO(chrisha): Add integration of feature policy and global whitelist
  // logic. In the meantime, the only success reason is because the heuristic
  // deems the operation to be safe.
if (decision_details->reasons().empty()) {
decision_details->AddReason(
DecisionSuccessReason::HEURISTIC_OBSERVED_TO_BE_SAFE);
    DCHECK(decision_details->IsPositive());
}
return decision_details->IsPositive();
}

void LocalSiteCharacteristicsDataImpl::NotifyLoadedSiteForegrounded() {
  DecrementNumLoadedBackgroundTabs();
}

ukm::SourceId TabLifecycleUnitSource::TabLifecycleUnit::GetUkmSourceId() const {
  resource_coordinator::ResourceCoordinatorTabHelper* observer =
      resource_coordinator::ResourceCoordinatorTabHelper::FromWebContents(
          web_contents());
  if (!observer)
    return ukm::kInvalidSourceId;
  return observer->ukm_source_id();
}

TabLifecycleUnitExternal* TestLifecycleUnit::AsTabLifecycleUnitExternal() {
  return nullptr;
}

base::TimeDelta LocalSiteCharacteristicsDataImpl::FeatureObservationDuration(
    const SiteCharacteristicsFeatureProto& feature_proto) const {
  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
  base::TimeDelta observation_time_for_feature =
      InternalRepresentationToTimeDelta(feature_proto.observation_duration());

  if (loaded_tabs_in_background_count_ > 0U &&
      InternalRepresentationToTimeDelta(feature_proto.use_timestamp())
          .is_zero()) {
    base::TimeDelta observation_time_since_backgrounded =
        NowTicks() - background_session_begin_;
    observation_time_for_feature += observation_time_since_backgrounded;
  }

  return observation_time_for_feature;
}

base::TimeDelta GetLongestObservationWindow() {
  const SiteCharacteristicsDatabaseParams& params =
      GetStaticSiteCharacteristicsDatabaseParams();
  return std::max({params.favicon_update_observation_window,
                   params.title_update_observation_window,
                   params.audio_usage_observation_window,
                   params.notifications_usage_observation_window});
}

bool TabLifecycleUnitSource::TabLifecycleUnit::DiscardTab() {
  return Discard(DiscardReason::kExternal);
}

base::string16 TestLifecycleUnit::GetTitle() const {
  return base::string16();
}

void LocalSiteCharacteristicsDataImpl::NotifyLoadedSiteBackgrounded() {
  if (loaded_tabs_in_background_count_ == 0)
    background_session_begin_ = NowTicks();

  loaded_tabs_in_background_count_++;

  DCHECK_LE(loaded_tabs_in_background_count_, loaded_tabs_count_);
}

    EnsureFreezeTimeoutTimerInitialized() {
  if (!freeze_timeout_timer_) {
    freeze_timeout_timer_ =
        std::make_unique<base::OneShotTimer>(GetTickClock());
  }
}

bool TabLifecycleUnitSource::TabLifecycleUnit::Unfreeze() {
  if (!IsValidStateChange(GetState(), LifecycleUnitState::ACTIVE,
                          StateChangeReason::BROWSER_INITIATED)) {
    return false;
  }

  if (GetWebContents()->GetVisibility() == content::Visibility::VISIBLE)
    return false;

  SetState(LifecycleUnitState::ACTIVE, StateChangeReason::BROWSER_INITIATED);
  GetWebContents()->SetPageFrozen(false);
  return true;
}

void LocalSiteCharacteristicsDataImpl::NotifySiteUnloaded(
    TabVisibility tab_visibility) {
  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);

  if (tab_visibility == TabVisibility::kBackground)
    DecrementNumLoadedBackgroundTabs();

  loaded_tabs_count_--;
  if (loaded_tabs_count_ > 0U)
    return;

  base::TimeDelta current_unix_time = GetTickDeltaSinceEpoch();

  site_characteristics_.set_last_loaded(
      TimeDeltaToInternalRepresentation(current_unix_time));
}

    OnNonPersistentNotificationCreated(
        content::WebContents* contents,
        const PageNavigationIdentity& page_navigation_id) {
  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
  if (web_contents() != contents)
    return;

  MaybeNotifyBackgroundFeatureUsage(
      &SiteCharacteristicsDataWriter::NotifyUsesNotificationsInBackground);
}

TestLifecycleUnit::TestLifecycleUnit(base::TimeTicks last_focused_time,
                                     base::ProcessHandle process_handle,
                                     bool can_discard)
    : LifecycleUnitBase(content::Visibility::VISIBLE),
      last_focused_time_(last_focused_time),
      process_handle_(process_handle),
      can_discard_(can_discard) {}

  content::WebContents* GetWebContentsAt(int index) {
    return tsm()->GetWebContentsAt(index);
  }

void LocalSiteCharacteristicsDataImpl::NotifyUsesAudioInBackground() {
  NotifyFeatureUsage(site_characteristics_.mutable_uses_audio_in_background());
}

void LocalSiteCharacteristicsDataImpl::NotifyUpdatesFaviconInBackground() {
  NotifyFeatureUsage(
      site_characteristics_.mutable_updates_favicon_in_background());
}

void LocalSiteCharacteristicsWebContentsObserver::DidFinishNavigation(
content::NavigationHandle* navigation_handle) {
DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
DCHECK(navigation_handle);

// Ignore the navigation events happening in a subframe of in the same
// document.
if (!navigation_handle->IsInMainFrame() ||
navigation_handle->IsSameDocument()) {
return;
}

first_time_title_set_ = false;
first_time_favicon_set_ = false;

if (!navigation_handle->HasCommitted())
return;

const url::Origin new_origin =
url::Origin::Create(navigation_handle->GetURL());

if (writer_ && new_origin == writer_origin_)
return;

writer_.reset();
writer_origin_ = url::Origin();

  // Only store information for the HTTP(S) sites for now.
  if (!navigation_handle->GetURL().SchemeIsHTTPOrHTTPS())
return;

Profile* profile =
Profile::FromBrowserContext(web_contents()->GetBrowserContext());
DCHECK(profile);
SiteCharacteristicsDataStore* data_store =
LocalSiteCharacteristicsDataStoreFactory::GetForProfile(profile);
DCHECK(data_store);
writer_ = data_store->GetWriterForOrigin(
new_origin,
ContentVisibilityToRCVisibility(web_contents()->GetVisibility()));

// The writer is initially in an unloaded state, load it if necessary.
if (TabLoadTracker::Get()->GetLoadingState(web_contents()) ==
LoadingState::LOADED) {
writer_->NotifySiteLoaded();
}

writer_origin_ = new_origin;
}

    ShouldIgnoreFeatureUsageEvent() {
  if (!writer_)
    return true;

  if (TabLoadTracker::Get()->GetLoadingState(web_contents()) !=
      LoadingState::LOADED) {
    return true;
  }

  return false;
}

void DiscardTest(DiscardReason reason) {
const base::TimeTicks kDummyLastActiveTime =
base::TimeTicks() + kShortDelay;

LifecycleUnit* background_lifecycle_unit = nullptr;
LifecycleUnit* foreground_lifecycle_unit = nullptr;
CreateTwoTabs(true /* focus_tab_strip */, &background_lifecycle_unit,
&foreground_lifecycle_unit);
content::WebContents* initial_web_contents =
tab_strip_model_->GetWebContentsAt(0);
content::WebContentsTester::For(initial_web_contents)
->SetLastActiveTime(kDummyLastActiveTime);

// Discard the tab.
EXPECT_EQ(LifecycleUnitState::ACTIVE,
background_lifecycle_unit->GetState());
    EXPECT_CALL(tab_observer_, OnDiscardedStateChange(testing::_, true));
background_lifecycle_unit->Discard(reason);
    testing::Mock::VerifyAndClear(&tab_observer_);

// Expect the tab to be discarded and the last active time to be preserved.
TransitionFromPendingDiscardToDiscardedIfNeeded(reason,
background_lifecycle_unit);

EXPECT_NE(initial_web_contents, tab_strip_model_->GetWebContentsAt(0));
EXPECT_FALSE(tab_strip_model_->GetWebContentsAt(0)
->GetController()
.GetPendingEntry());
EXPECT_EQ(kDummyLastActiveTime,
tab_strip_model_->GetWebContentsAt(0)->GetLastActiveTime());

source_->SetFocusedTabStripModelForTesting(nullptr);
}

  void DiscardAndAttachTabHelpers(LifecycleUnit* lifecycle_unit) {}

bool TestLifecycleUnit::Freeze() {
  return false;
}

bool TestLifecycleUnit::CanPurge() const {
  return false;
}

  virtual void CheckThrottleResults(
      NavigationThrottle::ThrottleCheckResult result1,
      NavigationThrottle::ThrottleCheckResult result2,
      NavigationThrottle::ThrottleCheckResult result3,
      size_t loading_slots) {
    EXPECT_EQ(content::NavigationThrottle::PROCEED, result1);
    switch (loading_slots) {
      case 1:
        EXPECT_EQ(content::NavigationThrottle::DEFER, result2);
        EXPECT_EQ(content::NavigationThrottle::DEFER, result3);
        break;
      case 2:
        EXPECT_EQ(content::NavigationThrottle::PROCEED, result2);
        EXPECT_EQ(content::NavigationThrottle::DEFER, result3);
        break;
      case 3:
        EXPECT_EQ(content::NavigationThrottle::PROCEED, result2);
        EXPECT_EQ(content::NavigationThrottle::PROCEED, result3);
        break;
      default:
        NOTREACHED();
    }
  }

void ExpectCanDiscardFalse(const LifecycleUnit* lifecycle_unit,
                           DecisionFailureReason failure_reason,
                           DiscardReason discard_reason) {
  DecisionDetails decision_details;
  EXPECT_FALSE(lifecycle_unit->CanDiscard(discard_reason, &decision_details));
  EXPECT_FALSE(decision_details.IsPositive());
  EXPECT_EQ(1u, decision_details.reasons().size());
  EXPECT_EQ(failure_reason, decision_details.FailureReason());
}

    MaybeNotifyBackgroundFeatureUsage(
        void (SiteCharacteristicsDataWriter::*method)()) {
  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);

  if (ShouldIgnoreFeatureUsageEvent())
    return;

  if (ContentVisibilityToRCVisibility(web_contents()->GetVisibility()) ==
      TabVisibility::kBackground) {
    (writer_.get()->*method)();
  }
}

void LocalSiteCharacteristicsWebContentsObserver::TitleWasSet(
    content::NavigationEntry* entry) {
  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);

  if (!first_time_title_set_) {
    first_time_title_set_ = true;
    return;
  }

  MaybeNotifyBackgroundFeatureUsage(
      &SiteCharacteristicsDataWriter::NotifyUpdatesTitleInBackground);
}

void TabLifecycleUnitSource::TabLifecycleUnit::FinishDiscard(
    DiscardReason discard_reason) {
  UMA_HISTOGRAM_BOOLEAN(
      "TabManager.Discarding.DiscardedTabHasBeforeUnloadHandler",
      GetWebContents()->NeedToFireBeforeUnload());

  content::WebContents* const old_contents = GetWebContents();
  content::WebContents::CreateParams create_params(tab_strip_model_->profile());
  create_params.initially_hidden =
      old_contents->GetVisibility() == content::Visibility::HIDDEN;
  create_params.desired_renderer_state =
      content::WebContents::CreateParams::kNoRendererProcess;
  create_params.last_active_time = old_contents->GetLastActiveTime();
  std::unique_ptr<content::WebContents> null_contents =
      content::WebContents::Create(create_params);
  content::WebContents* raw_null_contents = null_contents.get();

  ResourceCoordinatorTabHelper::CreateForWebContents(raw_null_contents);

  null_contents->GetController().CopyStateFrom(old_contents->GetController(),
                                               /* needs_reload */ false);

  bool fast_shutdown_success =
      GetRenderProcessHost()->FastShutdownIfPossible(1u, false);

#if defined(OS_CHROMEOS)
  if (!fast_shutdown_success && discard_reason == DiscardReason::kUrgent) {
    content::RenderFrameHost* main_frame = old_contents->GetMainFrame();
    DCHECK(main_frame);
    if (!main_frame->GetSuddenTerminationDisablerState(
            blink::kBeforeUnloadHandler)) {
      fast_shutdown_success = GetRenderProcessHost()->FastShutdownIfPossible(
          1u, /* skip_unload_handlers */ true);
    }
    UMA_HISTOGRAM_BOOLEAN(
        "TabManager.Discarding.DiscardedTabCouldUnsafeFastShutdown",
        fast_shutdown_success);
  }
#endif
  UMA_HISTOGRAM_BOOLEAN("TabManager.Discarding.DiscardedTabCouldFastShutdown",
                        fast_shutdown_success);

  const int index = tab_strip_model_->GetIndexOfWebContents(old_contents);
  DCHECK_NE(index, TabStripModel::kNoTab);
  std::unique_ptr<content::WebContents> old_contents_deleter =
      tab_strip_model_->ReplaceWebContentsAt(index, std::move(null_contents));
  DCHECK_EQ(GetWebContents(), raw_null_contents);

  raw_null_contents->SetWasDiscarded(true);

  old_contents_deleter.reset();

  SetState(LifecycleUnitState::DISCARDED,
           DiscardReasonToStateChangeReason(discard_reason));
  ++discard_count_;
  DCHECK_EQ(GetLoadingState(), LifecycleUnitLoadingState::UNLOADED);
}

bool IsDiscardedOrPendingDiscard(LifecycleUnitState state) {
  return state == LifecycleUnitState::DISCARDED ||
         state == LifecycleUnitState::PENDING_DISCARD;
}

void TabLifecycleUnitSource::TabLifecycleUnit::OnVisibilityChanged(
    content::Visibility visibility) {
  OnLifecycleUnitVisibilityChanged(visibility);
}

bool TabLifecycleUnitSource::TabLifecycleUnit::IsMediaTabImpl(
    DecisionDetails* decision_details) const {

  bool is_media_tab = false;

  if (recently_audible_time_ == base::TimeTicks::Max() ||
      (!recently_audible_time_.is_null() &&
       NowTicks() - recently_audible_time_ < kTabAudioProtectionTime)) {
    is_media_tab = true;
    if (decision_details) {
      decision_details->AddReason(
          DecisionFailureReason::LIVE_STATE_PLAYING_AUDIO);
    }
  }

  scoped_refptr<MediaStreamCaptureIndicator> media_indicator =
      MediaCaptureDevicesDispatcher::GetInstance()
          ->GetMediaStreamCaptureIndicator();

  if (media_indicator->IsCapturingUserMedia(GetWebContents())) {
    is_media_tab = true;
    if (decision_details)
      decision_details->AddReason(DecisionFailureReason::LIVE_STATE_CAPTURING);
  }

  if (media_indicator->IsBeingMirrored(GetWebContents())) {
    is_media_tab = true;
    if (decision_details)
      decision_details->AddReason(DecisionFailureReason::LIVE_STATE_MIRRORING);
  }

  return is_media_tab;
}

 TabLifecycleUnitSource::TabLifecycleUnit::TabLifecycleUnit(
    base::ObserverList<TabLifecycleObserver>* observers,
    content::WebContents* web_contents,
    TabStripModel* tab_strip_model)
    : LifecycleUnitBase(web_contents->GetVisibility()),
      content::WebContentsObserver(web_contents),
      observers_(observers),
      tab_strip_model_(tab_strip_model) {
  DCHECK(observers_);
  DCHECK(GetWebContents());
  DCHECK(tab_strip_model_);
}

void TabLifecycleUnitSource::TabLifecycleUnit::SetRecentlyAudible(
    bool recently_audible) {
  if (recently_audible)
    recently_audible_time_ = base::TimeTicks::Max();
  else if (recently_audible_time_ == base::TimeTicks::Max())
    recently_audible_time_ = NowTicks();
}

  void MaybeThrottleNavigations(TabManager* tab_manager,
                                size_t loading_slots = 1,
                                const char* url1 = kTestUrl,
                                const char* url2 = kTestUrl,
                                const char* url3 = kTestUrl) {
    PrepareTabs(url1, url2, url3);

    NavigationThrottle::ThrottleCheckResult result1 =
        tab_manager->MaybeThrottleNavigation(throttle1_.get());
    NavigationThrottle::ThrottleCheckResult result2 =
        tab_manager->MaybeThrottleNavigation(throttle2_.get());
    NavigationThrottle::ThrottleCheckResult result3 =
        tab_manager->MaybeThrottleNavigation(throttle3_.get());

    CheckThrottleResults(result1, result2, result3, loading_slots);
  }

  void TransitionFromPendingDiscardToDiscardedIfNeeded(
      DiscardReason reason,
      LifecycleUnit* lifecycle_unit) {
    if (reason == DiscardReason::kProactive) {
      EXPECT_EQ(LifecycleUnitState::PENDING_DISCARD,
                lifecycle_unit->GetState());
      task_runner_->FastForwardBy(kProactiveDiscardFreezeTimeout);
    }
    EXPECT_EQ(LifecycleUnitState::DISCARDED, lifecycle_unit->GetState());
  }

void NoopLocalSiteCharacteristicsDatabase::WriteSiteCharacteristicsIntoDB(
    const url::Origin& origin,
    const SiteCharacteristicsProto& site_characteristic_proto) {}

    InitSiteCharacteristicsFeatureProtoWithDefaultValues(
        SiteCharacteristicsFeatureProto* proto) {
  DCHECK_NE(nullptr, proto);
  static const auto zero_interval =
      LocalSiteCharacteristicsDataImpl::TimeDeltaToInternalRepresentation(
          base::TimeDelta());
  proto->set_observation_duration(zero_interval);
  proto->set_use_timestamp(zero_interval);
}

void ExpectCanDiscardFalseAllReasons(const LifecycleUnit* lifecycle_unit,
                                     DecisionFailureReason failure_reason) {
  ExpectCanDiscardFalse(lifecycle_unit, failure_reason,
                        DiscardReason::kExternal);
  ExpectCanDiscardFalse(lifecycle_unit, failure_reason,
                        DiscardReason::kProactive);
  ExpectCanDiscardFalse(lifecycle_unit, failure_reason, DiscardReason::kUrgent);
}

bool TabLifecycleUnitSource::TabLifecycleUnit::Freeze() {
  if (!IsValidStateChange(GetState(), LifecycleUnitState::PENDING_FREEZE,
                          StateChangeReason::BROWSER_INITIATED)) {
    return false;
  }

  if (GetWebContents()->GetVisibility() == content::Visibility::VISIBLE)
    return false;

  SetState(LifecycleUnitState::PENDING_FREEZE,
           StateChangeReason::BROWSER_INITIATED);
  GetWebContents()->SetPageFrozen(true);
  return true;
}

    GetEstimatedMemoryFreedOnDiscardKB() const {
#if defined(OS_CHROMEOS)
  std::unique_ptr<base::ProcessMetrics> process_metrics(
      base::ProcessMetrics::CreateProcessMetrics(GetProcessHandle()));
  base::ProcessMetrics::TotalsSummary summary =
      process_metrics->GetTotalsSummary();
  return summary.private_clean_kb + summary.private_dirty_kb + summary.swap_kb;
#else
  return 0;
#endif
}

    LocalSiteCharacteristicsWebContentsObserver(
        content::WebContents* web_contents)
    : content::WebContentsObserver(web_contents) {
  if (!g_skip_observer_registration_for_testing) {
    DCHECK(PageSignalReceiver::IsEnabled());

    TabLoadTracker::Get()->AddObserver(this);
    PageSignalReceiver::GetInstance()->AddObserver(this);
  }
}

void NoopLocalSiteCharacteristicsDatabase::ReadSiteCharacteristicsFromDB(
    const url::Origin& origin,
    ReadSiteCharacteristicsFromDBCallback callback) {
  std::move(callback).Run(base::nullopt);
}

void OpenTwoTabs(const GURL& first_url, const GURL& second_url) {
// Open two tabs. Wait for both of them to load.
content::WindowedNotificationObserver load1(
content::NOTIFICATION_LOAD_COMPLETED_MAIN_FRAME,
content::NotificationService::AllSources());
OpenURLParams open1(first_url, content::Referrer(),
WindowOpenDisposition::CURRENT_TAB,
ui::PAGE_TRANSITION_TYPED, false);
    browser()->OpenURL(open1);
load1.Wait();

content::WindowedNotificationObserver load2(
content::NOTIFICATION_LOAD_COMPLETED_MAIN_FRAME,
content::NotificationService::AllSources());
OpenURLParams open2(second_url, content::Referrer(),
WindowOpenDisposition::NEW_BACKGROUND_TAB,
ui::PAGE_TRANSITION_TYPED, false);
    browser()->OpenURL(open2);
load2.Wait();

ASSERT_EQ(2, tsm()->count());
}

void TabLifecycleUnitSource::TabLifecycleUnit::UpdateLifecycleState(
    mojom::LifecycleState state) {
  switch (state) {
    case mojom::LifecycleState::kFrozen: {
      if (GetState() == LifecycleUnitState::PENDING_DISCARD) {
        freeze_timeout_timer_->Stop();
        FinishDiscard(discard_reason_);
      } else {
        SetState(LifecycleUnitState::FROZEN,
                 StateChangeReason::RENDERER_INITIATED);
      }
      break;
    }

    case mojom::LifecycleState::kRunning: {
      SetState(LifecycleUnitState::ACTIVE,
               StateChangeReason::RENDERER_INITIATED);
      break;
    }

    default: {
      NOTREACHED();
      break;
    }
  }
}

bool ObserveNavEntryCommitted(const GURL& expected_url,
                              const content::NotificationSource& source,
                              const content::NotificationDetails& details) {
  return content::Details<content::LoadCommittedDetails>(details)
             ->entry->GetURL() == expected_url;
}

   MockDataWriter* NavigateAndReturnMockWriter(const GURL& url) {
    content::WebContentsTester* web_contents_tester =
        content::WebContentsTester::For(web_contents());
    EXPECT_TRUE(web_contents_tester);
    web_contents_tester->NavigateAndCommit(url);
    return static_cast<MockDataWriter*>(observer_->GetWriterForTesting());
  }

void TabLifecycleUnitSource::TabLifecycleUnit::RequestFreezeForDiscard(
    DiscardReason reason) {
  DCHECK_EQ(reason, DiscardReason::kProactive);

  SetState(LifecycleUnitState::PENDING_DISCARD,
           DiscardReasonToStateChangeReason(reason));
  EnsureFreezeTimeoutTimerInitialized();
  freeze_timeout_timer_->Start(
      FROM_HERE, kProactiveDiscardFreezeTimeout,
      base::BindRepeating(&TabLifecycleUnit::FinishDiscard,
                          base::Unretained(this), reason));
  GetWebContents()->SetPageFrozen(true);
}

void TabLifecycleUnitSource::TabLifecycleUnit::OnLifecycleUnitStateChanged(
    LifecycleUnitState last_state,
    LifecycleUnitStateChangeReason reason) {
  DCHECK(IsValidStateChange(last_state, GetState(), reason))
      << "Cannot transition TabLifecycleUnit state from " << last_state
      << " to " << GetState() << " with reason " << reason;

  const bool was_discarded = IsDiscardedOrPendingDiscard(last_state);
  const bool is_discarded = IsDiscardedOrPendingDiscard(GetState());
  if (was_discarded != is_discarded) {
    for (auto& observer : *observers_)
      observer.OnDiscardedStateChange(GetWebContents(), is_discarded);
  }
}

bool TabLifecycleUnitSource::TabLifecycleUnit::IsMediaTab() const {
  return IsMediaTabImpl(nullptr);
}

base::TimeDelta GetTickDeltaSinceEpoch() {
  return NowTicks() - base::TimeTicks::UnixEpoch();
}

void LocalSiteCharacteristicsDataImpl::NotifyUpdatesTitleInBackground() {
  NotifyFeatureUsage(
      site_characteristics_.mutable_updates_title_in_background());
}

  void ResetState() {
    nav_handle1_.reset();
    nav_handle2_.reset();
    nav_handle3_.reset();
    throttle1_.reset();
    throttle2_.reset();
     throttle3_.reset();
 
     contents1_.reset();
     contents2_.reset();
    contents3_.reset();
  }

TabLifecycleUnitSource::TabLifecycleUnit::GetLoadingState() const {
  return TabLoadTracker::Get()->GetLoadingState(GetWebContents());
}

void TabLifecycleUnitSource::TabLifecycleUnit::SetFocused(bool focused) {
  const bool was_focused = last_focused_time_ == base::TimeTicks::Max();
  if (focused == was_focused)
    return;
  last_focused_time_ = focused ? base::TimeTicks::Max() : NowTicks();

  if (!focused)
    return;

  switch (GetState()) {
    case LifecycleUnitState::DISCARDED: {
      SetState(LifecycleUnitState::ACTIVE,
               StateChangeReason::BROWSER_INITIATED);
      bool loaded = Load();
      DCHECK(loaded);
      break;
    }

    case LifecycleUnitState::PENDING_DISCARD: {
      freeze_timeout_timer_->Stop();
      SetState(LifecycleUnitState::PENDING_FREEZE,
               StateChangeReason::BROWSER_INITIATED);
      break;
    }

    default:
      break;
  }
}

SiteFeatureUsage LocalSiteCharacteristicsDataImpl::UpdatesTitleInBackground()
    const {
  return GetFeatureUsage(
      site_characteristics_.updates_title_in_background(),
      GetSiteCharacteristicsDatabaseParams().title_update_observation_window);
}

std::string SerializeOriginIntoDatabaseKey(const url::Origin& origin) {
   return base::MD5String(origin.host());
 }

   std::unique_ptr<WebContents> CreateWebContents() {
     std::unique_ptr<WebContents> web_contents = CreateTestWebContents();
     content::WebContentsTester::For(web_contents.get())
         ->NavigateAndCommit(GURL("https://www.example.com"));
     return web_contents;
   }

bool TabLifecycleUnitSource::TabLifecycleUnit::IsAutoDiscardable() const {
  return auto_discardable_;
}

  ProactiveTabFreezeAndDiscardParams GetTestProactiveDiscardParams() {
    ProactiveTabFreezeAndDiscardParams params = {};
    params.should_proactively_discard = true;
    params.low_occluded_timeout = kLowOccludedTimeout;
    params.moderate_occluded_timeout = kModerateOccludedTimeout;
    params.high_occluded_timeout = kHighOccludedTimeout;
    params.low_loaded_tab_count = kLowLoadedTabCount;
    params.moderate_loaded_tab_count = kModerateLoadedTabCount;
    params.high_loaded_tab_count = kHighLoadedTabCount;
    params.freeze_timeout = kFreezeTimeout;
    return params;
  }

  TabManager* tab_manager() { return g_browser_process->GetTabManager(); }

   TabManagerTest()
       : scoped_context_(
            std::make_unique<base::TestMockTimeTaskRunner::ScopedContext>(
                task_runner_)),
        scoped_set_tick_clock_for_testing_(task_runner_->GetMockTickClock()) {
    base::MessageLoopCurrent::Get()->SetTaskRunner(task_runner_);
  }

void ExpectCanDiscardTrueAllReasons(const LifecycleUnit* lifecycle_unit) {
  ExpectCanDiscardTrue(lifecycle_unit, DiscardReason::kExternal);
  ExpectCanDiscardTrue(lifecycle_unit, DiscardReason::kProactive);
  ExpectCanDiscardTrue(lifecycle_unit, DiscardReason::kUrgent);
}

SiteFeatureUsage LocalSiteCharacteristicsDataImpl::GetFeatureUsage(
    const SiteCharacteristicsFeatureProto& feature_proto,
    const base::TimeDelta min_obs_time) const {
  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);

  if (!feature_proto.IsInitialized())
    return SiteFeatureUsage::kSiteFeatureUsageUnknown;

  if (!InternalRepresentationToTimeDelta(feature_proto.use_timestamp())
           .is_zero()) {
    return SiteFeatureUsage::kSiteFeatureInUse;
  }

  if (FeatureObservationDuration(feature_proto) >= min_obs_time)
    return SiteFeatureUsage::kSiteFeatureNotInUse;

  return SiteFeatureUsage::kSiteFeatureUsageUnknown;
}

bool TabLifecycleUnitSource::TabLifecycleUnit::CanDiscard(
    DiscardReason reason,
    DecisionDetails* decision_details) const {
  DCHECK(decision_details->reasons().empty());


  if (!tab_strip_model_)
    return false;

  const LifecycleUnitState target_state =
      reason == DiscardReason::kProactive &&
              GetState() != LifecycleUnitState::FROZEN
          ? LifecycleUnitState::PENDING_DISCARD
          : LifecycleUnitState::DISCARDED;
  if (!IsValidStateChange(GetState(), target_state,
                          DiscardReasonToStateChangeReason(reason))) {
    return false;
  }

  if (GetWebContents()->IsCrashed())
    return false;

  if (!GetWebContents()->GetLastCommittedURL().is_valid() ||
      GetWebContents()->GetLastCommittedURL().is_empty()) {
    return false;
  }

  if (discard_count_ > 0) {
#if defined(OS_CHROMEOS)
    if (reason != DiscardReason::kUrgent)
      return false;
#else
    return false;
 #endif  // defined(OS_CHROMEOS)
   }
 

#if defined(OS_CHROMEOS)
  if (GetWebContents()->GetVisibility() == content::Visibility::VISIBLE)
    decision_details->AddReason(DecisionFailureReason::LIVE_STATE_VISIBLE);
#else
  if (tab_strip_model_->GetActiveWebContents() == GetWebContents())
    decision_details->AddReason(DecisionFailureReason::LIVE_STATE_VISIBLE);
#endif  // defined(OS_CHROMEOS)

  if (GetWebContents()->GetPageImportanceSignals().had_form_interaction)
    decision_details->AddReason(DecisionFailureReason::LIVE_STATE_FORM_ENTRY);

  IsMediaTabImpl(decision_details);

  if (GetWebContents()->GetContentsMimeType() == "application/pdf")
    decision_details->AddReason(DecisionFailureReason::LIVE_STATE_IS_PDF);

  if (!IsAutoDiscardable()) {
    decision_details->AddReason(
         DecisionFailureReason::LIVE_STATE_EXTENSION_DISALLOWED);
   }
 
   if (decision_details->reasons().empty()) {
     decision_details->AddReason(
         DecisionSuccessReason::HEURISTIC_OBSERVED_TO_BE_SAFE);
    DCHECK(decision_details->IsPositive());
  }
  return decision_details->IsPositive();
}

    ClearObservationsAndInvalidateReadOperation() {
  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);

  weak_factory_.InvalidateWeakPtrs();

  InitWithDefaultValues(false);

  if (IsLoaded()) {
    site_characteristics_.set_last_loaded(
        TimeDeltaToInternalRepresentation(GetTickDeltaSinceEpoch()));
  }

  safe_to_write_to_db_ = true;
}

void LocalSiteCharacteristicsDataImpl::NotifySiteLoaded() {
  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
  if (loaded_tabs_count_ == 0) {
    site_characteristics_.set_last_loaded(
        TimeDeltaToInternalRepresentation(GetTickDeltaSinceEpoch()));

    is_dirty_ = true;
  }
  loaded_tabs_count_++;
}

void TestAppendTabsToTabStrip(bool focus_tab_strip) {
LifecycleUnit* first_lifecycle_unit = nullptr;
LifecycleUnit* second_lifecycle_unit = nullptr;
CreateTwoTabs(focus_tab_strip, &first_lifecycle_unit,
&second_lifecycle_unit);

const base::TimeTicks first_tab_last_focused_time =
first_lifecycle_unit->GetLastFocusedTime();
const base::TimeTicks second_tab_last_focused_time =
second_lifecycle_unit->GetLastFocusedTime();

// Add a background tab to the focused tab strip.
task_runner_->FastForwardBy(kShortDelay);
LifecycleUnit* third_lifecycle_unit = nullptr;
    EXPECT_CALL(source_observer_, OnLifecycleUnitCreated(testing::_))
        .WillOnce(testing::Invoke([&](LifecycleUnit* lifecycle_unit) {
third_lifecycle_unit = lifecycle_unit;

if (focus_tab_strip) {
EXPECT_EQ(first_tab_last_focused_time,
first_lifecycle_unit->GetLastFocusedTime());
EXPECT_TRUE(IsFocused(second_lifecycle_unit));
} else {
EXPECT_EQ(first_tab_last_focused_time,
first_lifecycle_unit->GetLastFocusedTime());
EXPECT_EQ(second_tab_last_focused_time,
second_lifecycle_unit->GetLastFocusedTime());
}
EXPECT_EQ(NowTicks(), third_lifecycle_unit->GetLastFocusedTime());
}));
std::unique_ptr<content::WebContents> third_web_contents =
CreateAndNavigateWebContents();
content::WebContents* raw_third_web_contents = third_web_contents.get();
tab_strip_model_->AppendWebContents(std::move(third_web_contents), false);
    testing::Mock::VerifyAndClear(&source_observer_);
EXPECT_TRUE(source_->GetTabLifecycleUnitExternal(raw_third_web_contents));

// Expect notifications when tabs are closed.
CloseTabsAndExpectNotifications(
tab_strip_model_.get(),
{first_lifecycle_unit, second_lifecycle_unit, third_lifecycle_unit});
}

bool TabLifecycleUnitSource::TabLifecycleUnit::CanPurge() const {
  return !IsMediaTab();
}

  const url::Origin& Origin() const { return origin_; }

base::TimeTicks TabLifecycleUnitSource::TabLifecycleUnit::GetLastFocusedTime()
    const {
  return last_focused_time_;
}
