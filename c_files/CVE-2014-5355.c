krb5_recvauth(krb5_context context, krb5_auth_context *auth_context, krb5_pointer fd, char *appl_version, krb5_principal server, krb5_int32 flags, krb5_keytab keytab, krb5_ticket **ticket)
{
    return recvauth_common (context, auth_context, fd, appl_version,
                            server, flags, keytab, ticket, 0);
}

int main(argc, argv)
int argc;
char *argv[];
{
krb5_data pname_data, tkt_data;
int sock = 0;
socklen_t l;
int retval;
struct sockaddr_in l_inaddr, f_inaddr;        /* local, foreign address */
krb5_creds creds, *new_creds;
krb5_ccache cc;
krb5_data msgtext, msg;
krb5_context context;
krb5_auth_context auth_context = NULL;

#ifndef DEBUG
freopen("/tmp/uu-server.log", "w", stderr);
#endif

retval = krb5_init_context(&context);
if (retval) {
com_err(argv[0], retval, "while initializing krb5");
exit(1);
}

#ifdef DEBUG
{
int one = 1;
int acc;
struct servent *sp;
socklen_t namelen = sizeof(f_inaddr);

if ((sock = socket(PF_INET, SOCK_STREAM, 0)) < 0) {
com_err("uu-server", errno, "creating socket");
exit(3);
}

l_inaddr.sin_family = AF_INET;
l_inaddr.sin_addr.s_addr = 0;
if (argc == 2) {
l_inaddr.sin_port = htons(atoi(argv[1]));
} else  {
if (!(sp = getservbyname("uu-sample", "tcp"))) {
com_err("uu-server", 0, "can't find uu-sample/tcp service");
exit(3);
}
l_inaddr.sin_port = sp->s_port;
}

(void) setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char *)&one, sizeof (one));
if (bind(sock, (struct sockaddr *)&l_inaddr, sizeof(l_inaddr))) {
com_err("uu-server", errno, "binding socket");
exit(3);
}
if (listen(sock, 1) == -1) {
com_err("uu-server", errno, "listening");
exit(3);
}

printf("Server started\n");
fflush(stdout);

if ((acc = accept(sock, (struct sockaddr *)&f_inaddr, &namelen)) == -1) {
com_err("uu-server", errno, "accepting");
exit(3);
}
dup2(acc, 0);
close(sock);
sock = 0;
}
#endif

retval = krb5_read_message(context, (krb5_pointer) &sock, &pname_data);
    if (retval) {
com_err ("uu-server", retval, "reading pname");
return 2;
}

retval = krb5_read_message(context, (krb5_pointer) &sock, &tkt_data);
if (retval) {
com_err ("uu-server", retval, "reading ticket data");
return 2;
}

retval = krb5_cc_default(context, &cc);
if (retval) {
com_err("uu-server", retval, "getting credentials cache");
return 4;
}

memset (&creds, 0, sizeof(creds));
retval = krb5_cc_get_principal(context, cc, &creds.client);
if (retval) {
com_err("uu-client", retval, "getting principal name");
return 6;
}

/* client sends it already null-terminated. */
printf ("uu-server: client principal is \"%s\".\n", pname_data.data);

retval = krb5_parse_name(context, pname_data.data, &creds.server);
if (retval) {
com_err("uu-server", retval, "parsing client name");
return 3;
}

creds.second_ticket = tkt_data;
printf ("uu-server: client ticket is %d bytes.\n",
creds.second_ticket.length);

retval = krb5_get_credentials(context, KRB5_GC_USER_USER, cc,
&creds, &new_creds);
if (retval) {
com_err("uu-server", retval, "getting user-user ticket");
return 5;
}

#ifndef DEBUG
l = sizeof(f_inaddr);
if (getpeername(0, (struct sockaddr *)&f_inaddr, &l) == -1)
{
com_err("uu-server", errno, "getting client address");
return 6;
}
#endif
l = sizeof(l_inaddr);
if (getsockname(0, (struct sockaddr *)&l_inaddr, &l) == -1)
{
com_err("uu-server", errno, "getting local address");
return 6;
}

/* send a ticket/authenticator to the other side, so it can get the key
we're using for the krb_safe below. */

retval = krb5_auth_con_init(context, &auth_context);
if (retval) {
com_err("uu-server", retval, "making auth_context");
return 8;
}

retval = krb5_auth_con_setflags(context, auth_context,
KRB5_AUTH_CONTEXT_DO_SEQUENCE);
if (retval) {
com_err("uu-server", retval, "initializing the auth_context flags");
return 8;
}

retval =
krb5_auth_con_genaddrs(context, auth_context, sock,
KRB5_AUTH_CONTEXT_GENERATE_LOCAL_FULL_ADDR |
KRB5_AUTH_CONTEXT_GENERATE_REMOTE_FULL_ADDR);
if (retval) {
com_err("uu-server", retval, "generating addrs for auth_context");
return 9;
}

#if 1
retval = krb5_mk_req_extended(context, &auth_context,
AP_OPTS_USE_SESSION_KEY,
NULL, new_creds, &msg);
if (retval) {
com_err("uu-server", retval, "making AP_REQ");
return 8;
}
retval = krb5_write_message(context, (krb5_pointer) &sock, &msg);
#else
retval = krb5_sendauth(context, &auth_context, (krb5_pointer)&sock, "???",
0, 0,
AP_OPTS_MUTUAL_REQUIRED | AP_OPTS_USE_SESSION_KEY,
NULL, &creds, cc, NULL, NULL, NULL);
#endif
if (retval)
goto cl_short_wrt;

free(msg.data);

msgtext.length = 32;
msgtext.data = "Hello, other end of connection.";

retval = krb5_mk_safe(context, auth_context, &msgtext, &msg, NULL);
if (retval) {
com_err("uu-server", retval, "encoding message to client");
return 6;
}

retval = krb5_write_message(context, (krb5_pointer) &sock, &msg);
if (retval) {
cl_short_wrt:
com_err("uu-server", retval, "writing message to client");
return 7;
}


krb5_free_data_contents(context, &msg);
krb5_free_data_contents(context, &pname_data);
/* tkt_data freed with creds */
krb5_free_cred_contents(context, &creds);
krb5_free_creds(context, new_creds);
krb5_cc_close(context, cc);
krb5_auth_con_free(context, auth_context);
krb5_free_context(context);
return 0;
}

recvauth_common(krb5_context context,
krb5_auth_context * auth_context,
/* IN */
krb5_pointer fd,
char *appl_version,
krb5_principal server,
krb5_int32 flags,
krb5_keytab keytab,
/* OUT */
krb5_ticket ** ticket,
krb5_data *version)
{
krb5_auth_context     new_auth_context;
krb5_flags            ap_option = 0;
krb5_error_code       retval, problem;
krb5_data             inbuf;
krb5_data             outbuf;
krb5_rcache           rcache = 0;
krb5_octet            response;
krb5_data             null_server;
int                   need_error_free = 0;
int                   local_rcache = 0, local_authcon = 0;

/*
* Zero out problem variable.  If problem is set at the end of
* the intial version negotiation section, it means that we
* need to send an error code back to the client application
* and exit.
*/
problem = 0;
response = 0;

if (!(flags & KRB5_RECVAUTH_SKIP_VERSION)) {
/*
* First read the sendauth version string and check it.
*/
if ((retval = krb5_read_message(context, fd, &inbuf)))
return(retval);
        if (strcmp(inbuf.data, sendauth_version)) {
problem = KRB5_SENDAUTH_BADAUTHVERS;
response = 1;
}
free(inbuf.data);
}
if (flags & KRB5_RECVAUTH_BADAUTHVERS) {
problem = KRB5_SENDAUTH_BADAUTHVERS;
response = 1;
}

/*
* Do the same thing for the application version string.
*/
if ((retval = krb5_read_message(context, fd, &inbuf)))
return(retval);
    if (appl_version && strcmp(inbuf.data, appl_version)) {
        if (!problem) {
problem = KRB5_SENDAUTH_BADAPPLVERS;
response = 2;
}
}
if (version && !problem)
*version = inbuf;
else
free(inbuf.data);

/*
* Now we actually write the response.  If the response is non-zero,
* exit with a return value of problem
*/
if ((krb5_net_write(context, *((int *)fd), (char *)&response, 1)) < 0) {
return(problem); /* We'll return the top-level problem */
}
if (problem)
return(problem);

/* We are clear of errors here */

/*
* Now, let's read the AP_REQ message and decode it
*/
if ((retval = krb5_read_message(context, fd, &inbuf)))
return retval;

if (*auth_context == NULL) {
problem = krb5_auth_con_init(context, &new_auth_context);
*auth_context = new_auth_context;
local_authcon = 1;
}
krb5_auth_con_getrcache(context, *auth_context, &rcache);
if ((!problem) && rcache == NULL) {
/*
* Setup the replay cache.
*/
if (server != NULL && server->length > 0) {
problem = krb5_get_server_rcache(context, &server->data[0],
&rcache);
} else {
null_server.length = 7;
null_server.data = "default";
problem = krb5_get_server_rcache(context, &null_server, &rcache);
}
if (!problem)
problem = krb5_auth_con_setrcache(context, *auth_context, rcache);
local_rcache = 1;
}
if (!problem) {
problem = krb5_rd_req(context, auth_context, &inbuf, server,
keytab, &ap_option, ticket);
free(inbuf.data);
}

/*
* If there was a problem, send back a krb5_error message,
* preceeded by the length of the krb5_error message.  If
* everything's ok, send back 0 for the length.
*/
if (problem) {
krb5_error      error;
const   char *message;

memset(&error, 0, sizeof(error));
krb5_us_timeofday(context, &error.stime, &error.susec);
if(server)
error.server = server;
else {
/* If this fails - ie. ENOMEM we are hosed
we cannot even send the error if we wanted to... */
(void) krb5_parse_name(context, "????", &error.server);
need_error_free = 1;
}

error.error = problem - ERROR_TABLE_BASE_krb5;
if (error.error > 127)
error.error = KRB_ERR_GENERIC;
message = error_message(problem);
error.text.length  = strlen(message) + 1;
error.text.data = strdup(message);
if (!error.text.data) {
retval = ENOMEM;
goto cleanup;
}
if ((retval = krb5_mk_error(context, &error, &outbuf))) {
free(error.text.data);
goto cleanup;
}
free(error.text.data);
if(need_error_free)
krb5_free_principal(context, error.server);

} else {
outbuf.length = 0;
outbuf.data = 0;
}

retval = krb5_write_message(context, fd, &outbuf);
if (outbuf.data) {
free(outbuf.data);
/* We sent back an error, we need cleanup then return */
retval = problem;
goto cleanup;
}
if (retval)
goto cleanup;

/* Here lies the mutual authentication stuff... */
if ((ap_option & AP_OPTS_MUTUAL_REQUIRED)) {
if ((retval = krb5_mk_rep(context, *auth_context, &outbuf))) {
return(retval);
}
retval = krb5_write_message(context, fd, &outbuf);
free(outbuf.data);
}

cleanup:;
if (retval) {
if (local_authcon) {
krb5_auth_con_free(context, *auth_context);
} else if (local_rcache && rcache != NULL) {
krb5_rc_close(context, rcache);
krb5_auth_con_setrcache(context, *auth_context, NULL);
}
}
return retval;
}
