void PPB_URLLoader_Impl::didReceiveResponse(WebURLLoader* loader,
                                            const WebURLResponse& response) {
  SaveResponse(response);

  total_bytes_to_be_received_ = response.expectedContentLength();
  UpdateStatus();

  RunCallback(PP_OK);
}

PluginModule* ResourceTracker::GetModule(PP_Module module) {
  DLOG_IF(ERROR, !CheckIdType(module, PP_ID_TYPE_MODULE))
      << module << " is not a PP_Module.";
  ModuleMap::iterator found = module_map_.find(module);
  if (found == module_map_.end())
    return NULL;
  return found->second;
}

void PPB_URLLoader_Impl::didFail(WebURLLoader* loader,
                                 const WebURLError& error) {
  if (error.domain.equals(WebString::fromUTF8(net::kErrorDomain))) {
    switch (error.reason) {
      case net::ERR_ACCESS_DENIED:
      case net::ERR_NETWORK_ACCESS_DENIED:
        done_status_ = PP_ERROR_NOACCESS;
        break;
      default:
        done_status_ = PP_ERROR_FAILED;
        break;
    }
  } else {
    done_status_ = PP_ERROR_NOACCESS;
  }

  RunCallback(done_status_);
}

PluginInstance* ResourceTracker::GetInstance(PP_Instance instance) {
  DLOG_IF(ERROR, !CheckIdType(instance, PP_ID_TYPE_INSTANCE))
      << instance << " is not a PP_Instance.";
  InstanceMap::iterator found = instance_map_.find(instance);
  if (found == instance_map_.end())
    return NULL;
  return found->second->instance;
}

PP_Bool HandleEvent(PP_Resource resource, const PP_InputEvent* event) {
  scoped_refptr<PPB_Widget_Impl> widget(
      Resource::GetAs<PPB_Widget_Impl>(resource));
  return BoolToPPBool(widget && widget->HandleEvent(event));
}

void PPB_Widget_Impl::SetLocation(const PP_Rect* location) {
  location_ = *location;
  SetLocationInternal(location);
 }

PPB_URLLoader_Impl::PPB_URLLoader_Impl(PluginInstance* instance,
                                       bool main_document_loader)
    : Resource(instance),
      main_document_loader_(main_document_loader),
      pending_callback_(),
      bytes_sent_(0),
      total_bytes_to_be_sent_(-1),
      bytes_received_(0),
      total_bytes_to_be_received_(-1),
      user_buffer_(NULL),
      user_buffer_size_(0),
      done_status_(PP_OK_COMPLETIONPENDING),
      is_streaming_to_file_(false),
      is_asynchronous_load_suspended_(false),
      has_universal_access_(false),
      status_callback_(NULL) {
}

 int32_t PPB_URLLoader_Impl::Open(PP_Resource request_id,
                                 PP_CompletionCallback callback) {
  EnterResourceNoLock<PPB_URLRequestInfo_API> enter_request(request_id, true);
  if (enter_request.failed())
    return PP_ERROR_BADARGUMENT;
  PPB_URLRequestInfo_Impl* request = static_cast<PPB_URLRequestInfo_Impl*>(
      enter_request.object());

  int32_t rv = ValidateCallback(callback);
  if (rv != PP_OK)
    return rv;

  if (request->RequiresUniversalAccess() && !has_universal_access_)
    return PP_ERROR_NOACCESS;

  if (loader_.get())
    return PP_ERROR_INPROGRESS;

  WebFrame* frame = instance()->container()->element().document().frame();
  if (!frame)
    return PP_ERROR_FAILED;
  WebURLRequest web_request(request->ToWebURLRequest(frame));

  WebURLLoaderOptions options;
  if (has_universal_access_) {
    options.crossOriginRequestPolicy =
        WebURLLoaderOptions::CrossOriginRequestPolicyAllow;
    options.allowCredentials = true;
  } else if (request->allow_cross_origin_requests()) {
    options.crossOriginRequestPolicy =
        WebURLLoaderOptions::CrossOriginRequestPolicyUseAccessControl;
    options.allowCredentials = request->allow_credentials();
  }

  is_asynchronous_load_suspended_ = false;
  loader_.reset(frame->createAssociatedURLLoader(options));
  if (!loader_.get())
    return PP_ERROR_FAILED;

  loader_->loadAsynchronously(web_request, this);
  if (done_status_ == PP_ERROR_FAILED ||
      done_status_ == PP_ERROR_NOACCESS)
    return done_status_;

  request_info_ = scoped_refptr<PPB_URLRequestInfo_Impl>(request);

  RegisterCallback(callback);
  return PP_OK_COMPLETIONPENDING;
}

PPB_URLLoader_Impl::~PPB_URLLoader_Impl() {
}

bool ResourceTracker::AddRefVar(int32 var_id) {
  DLOG_IF(ERROR, !CheckIdType(var_id, PP_ID_TYPE_VAR))
      << var_id << " is not a PP_Var ID.";
  VarMap::iterator i = live_vars_.find(var_id);
  if (i != live_vars_.end()) {
    ++i->second.second;
    return true;
  }
  return false;
}

PP_Instance ResourceTracker::GetInstanceForResource(PP_Resource pp_resource) {
  scoped_refptr<Resource> resource(GetResource(pp_resource));
  if (!resource.get())
    return 0;
  return resource->instance()->pp_instance();
}

PP_Resource PPB_URLLoader_Impl::Create(PP_Instance pp_instance) {
  PluginInstance* instance = ResourceTracker::Get()->GetInstance(pp_instance);
  if (!instance)
    return 0;

  PPB_URLLoader_Impl* loader = new PPB_URLLoader_Impl(instance, false);
  return loader->GetReference();
}

uint32 ResourceTracker::GetLiveObjectsForInstance(
PP_Instance instance) const {
InstanceMap::const_iterator found = instance_map_.find(instance);
if (found == instance_map_.end())
return 0;
  return static_cast<uint32>(found->second->resources.size() +
found->second->object_vars.size());
}

int32_t PPB_URLLoader_Impl::ReadResponseBody(void* buffer,
                                             int32_t bytes_to_read,
                                             PP_CompletionCallback callback) {
  int32_t rv = ValidateCallback(callback);
  if (rv != PP_OK)
    return rv;
  if (!response_info_ || response_info_->body())
    return PP_ERROR_FAILED;
  if (bytes_to_read <= 0 || !buffer)
    return PP_ERROR_BADARGUMENT;

  user_buffer_ = static_cast<char*>(buffer);
  user_buffer_size_ = bytes_to_read;

  if (!buffer_.empty())
    return FillUserBuffer();

  if (done_status_ != PP_OK_COMPLETIONPENDING) {
    user_buffer_ = NULL;
    user_buffer_size_ = 0;
    return done_status_;
  }

  RegisterCallback(callback);
  return PP_OK_COMPLETIONPENDING;
}

int32_t PPB_URLLoader_Impl::FollowRedirect(PP_CompletionCallback callback) {
  int32_t rv = ValidateCallback(callback);
  if (rv != PP_OK)
    return rv;

  WebURL redirect_url = GURL(response_info_->redirect_url());

  loader_->setDefersLoading(false);  // Allow the redirect to continue.
  RegisterCallback(callback);
  return PP_OK_COMPLETIONPENDING;
}

void PPB_URLLoader_Impl::GrantUniversalAccess() {
  has_universal_access_ = true;
}

void ResourceTracker::ModuleDeleted(PP_Module module) {
  DLOG_IF(ERROR, !CheckIdType(module, PP_ID_TYPE_MODULE))
      << module << " is not a PP_Module.";
  ModuleMap::iterator found = module_map_.find(module);
  if (found == module_map_.end()) {
    NOTREACHED();
    return;
  }
  module_map_.erase(found);
}

void Resource::LastPluginRefWasDeleted(bool instance_destroyed) {
DCHECK(resource_id_ != 0);
instance()->module()->GetCallbackTracker()->PostAbortForResource(
resource_id_);
resource_id_ = 0;
  if (instance_destroyed)
    instance_ = NULL;
}

template <typename T> static inline T MakeTypedId(T value, PPIdType type) {
  return (value << kPPIdTypeBits) | static_cast<T>(type);
}

void PPB_URLLoader_Impl::willSendRequest(
    WebURLLoader* loader,
    WebURLRequest& new_request,
    const WebURLResponse& redirect_response) {
  if (!request_info_->follow_redirects()) {
    SaveResponse(redirect_response);
    loader_->setDefersLoading(true);
    RunCallback(PP_OK);
  }
}

void PPB_URLLoader_Impl::didDownloadData(WebURLLoader* loader,
                                         int data_length) {
  bytes_received_ += data_length;
  UpdateStatus();
}

PPB_Widget_Impl::~PPB_Widget_Impl() {
}

void PPB_URLLoader_Impl::SaveResponse(const WebURLResponse& response) {
  scoped_refptr<PPB_URLResponseInfo_Impl> response_info(
      new PPB_URLResponseInfo_Impl(instance()));
  if (response_info->Initialize(response))
    response_info_ = response_info;
}

void PPB_URLLoader_Impl::RegisterCallback(PP_CompletionCallback callback) {
  DCHECK(callback.func);
  DCHECK(!pending_callback_.get() || pending_callback_->completed());

  PP_Resource resource_id = GetReferenceNoAddRef();
  CHECK(resource_id);
  pending_callback_ = new TrackedCompletionCallback(
      instance()->module()->GetCallbackTracker(), resource_id, callback);
}

void ResourceTracker::CleanupInstanceData(PP_Instance instance,
bool delete_instance) {
DLOG_IF(ERROR, !CheckIdType(instance, PP_ID_TYPE_INSTANCE))
<< instance << " is not a PP_Instance.";
InstanceMap::iterator found = instance_map_.find(instance);
if (found == instance_map_.end()) {
NOTREACHED();
return;
}
InstanceData& data = *found->second;

// Force release all plugin references to resources associated with the
// deleted instance.
  ResourceSet::iterator cur_res = data.resources.begin();
  while (cur_res != data.resources.end()) {
ResourceMap::iterator found_resource = live_resources_.find(*cur_res);
if (found_resource == live_resources_.end()) {
NOTREACHED();
} else {
Resource* resource = found_resource->second.first;

// Must delete from the resource set first since the resource's instance
// pointer will get zeroed out in LastPluginRefWasDeleted.
      resource->LastPluginRefWasDeleted(true);
live_resources_.erase(*cur_res);
}

// Iterators to a set are stable so we can iterate the set while the items
// are being deleted as long as we're careful not to delete the item we're
// holding an iterator to.
ResourceSet::iterator current = cur_res++;
    data.resources.erase(current);
}
  DCHECK(data.resources.empty());

// Force delete all var references.
VarSet::iterator cur_var = data.object_vars.begin();
while (cur_var != data.object_vars.end()) {
VarSet::iterator current = cur_var++;

// Tell the corresponding ObjectVar that the instance is gone.
PP_Var object_pp_var;
object_pp_var.type = PP_VARTYPE_OBJECT;
object_pp_var.value.as_id = *current;
scoped_refptr<ObjectVar> object_var(ObjectVar::FromPPVar(object_pp_var));
if (object_var.get())
object_var->InstanceDeleted();

// Clear the object from the var mapping and the live instance object list.
live_vars_.erase(*current);
data.object_vars.erase(*current);
}
DCHECK(data.object_vars.empty());

if (delete_instance)
instance_map_.erase(found);
}

ResourceTracker::~ResourceTracker() {
}

int32_t PPB_URLLoader_Impl::FinishStreamingToFile(
    PP_CompletionCallback callback) {
  int32_t rv = ValidateCallback(callback);
  if (rv != PP_OK)
    return rv;
  if (!response_info_ || !response_info_->body())
    return PP_ERROR_FAILED;

  if (done_status_ != PP_OK_COMPLETIONPENDING)
    return done_status_;

  is_streaming_to_file_ = true;
  if (is_asynchronous_load_suspended_) {
    loader_->setDefersLoading(false);
    is_asynchronous_load_suspended_ = false;
  }

  RegisterCallback(callback);
  return PP_OK_COMPLETIONPENDING;
}

bool PPB_URLLoader_Impl::RecordDownloadProgress() const {
  return request_info_ && request_info_->record_download_progress();
}

PP_Resource Resource::GetReferenceNoAddRef() const {
   return resource_id_;
 }

scoped_refptr<Resource> ResourceTracker::GetResource(PP_Resource res) const {
  DLOG_IF(ERROR, !CheckIdType(res, PP_ID_TYPE_RESOURCE))
      << res << " is not a PP_Resource.";
  ResourceMap::const_iterator result = live_resources_.find(res);
  if (result == live_resources_.end()) {
    return scoped_refptr<Resource>();
  }
  return result->second.first;
}

void PPB_URLLoader_Impl::didFinishLoading(WebURLLoader* loader,
                                          double finish_time) {
  done_status_ = PP_OK;
  RunCallback(done_status_);
}

void PPB_URLLoader_Impl::LastPluginRefWasDeleted(bool instance_destroyed) {
  Resource::LastPluginRefWasDeleted(instance_destroyed);
  if (instance_destroyed) {
    // Free the WebKit request when the instance has been destroyed to avoid
    // using bandwidth just in case this object lives longer than the instance.
    loader_.reset();
  }
}

void SetLocation(PP_Resource resource, const PP_Rect* location) {
  scoped_refptr<PPB_Widget_Impl> widget(
      Resource::GetAs<PPB_Widget_Impl>(resource));
  if (widget)
    widget->SetLocation(location);
}

void PPB_URLLoader_Impl::SetStatusCallback(
    PP_URLLoaderTrusted_StatusCallback cb) {
  status_callback_ = cb;
}

void PPB_URLLoader_Impl::Close() {
  if (loader_.get()) {
    loader_->cancel();
  } else if (main_document_loader_) {
    WebFrame* frame = instance()->container()->element().document().frame();
    frame->stopLoading();
  }
}

PP_Bool IsWidget(PP_Resource resource) {
  return BoolToPPBool(!!Resource::GetAs<PPB_Widget_Impl>(resource));
}

::ppapi::FunctionGroupBase* ResourceTracker::GetFunctionAPI(
    PP_Instance pp_instance,
    pp::proxy::InterfaceID id) {
  PluginInstance* instance = GetInstance(pp_instance);
  if (!instance)
    return NULL;

  if (id == pp::proxy::INTERFACE_ID_PPB_INSTANCE)
    return instance;

  scoped_ptr< ::ppapi::FunctionGroupBase >& proxy =
      instance_map_[pp_instance]->function_proxies[id];
  if (proxy.get())
    return proxy.get();

  switch (id) {
    case pp::proxy::INTERFACE_ID_PPB_CHAR_SET:
      proxy.reset(new PPB_CharSet_Impl(instance));
      break;
    case pp::proxy::INTERFACE_ID_PPB_CURSORCONTROL:
      proxy.reset(new PPB_CursorControl_Impl(instance));
      break;
    case pp::proxy::INTERFACE_ID_PPB_FIND:
      proxy.reset(new PPB_Find_Impl(instance));
      break;
    case pp::proxy::INTERFACE_ID_PPB_FONT:
      proxy.reset(new PPB_Font_FunctionImpl(instance));
      break;
    case pp::proxy::INTERFACE_ID_RESOURCE_CREATION:
      proxy.reset(new ResourceCreationImpl(instance));
      break;
    default:
      NOTREACHED();
  }

  return proxy.get();
}

void ResourceTracker::InstanceDeleted(PP_Instance instance) {
  CleanupInstanceData(instance, true);
}

 PP_Resource Resource::GetReference() {
  ResourceTracker *tracker = ResourceTracker::Get();
  if (resource_id_)
    tracker->AddRefResource(resource_id_);
  else
    resource_id_ = tracker->AddResource(this);
  return resource_id_;
}

PP_Module ResourceTracker::AddModule(PluginModule* module) {
#ifndef NDEBUG
  for (ModuleMap::const_iterator i = module_map_.begin();
       i != module_map_.end(); ++i)
    DCHECK(i->second != module);
#endif

  PP_Module new_module;
  do {
    new_module = MakeTypedId(static_cast<PP_Module>(base::RandUint64()),
                             PP_ID_TYPE_MODULE);
  } while (!new_module ||
           module_map_.find(new_module) != module_map_.end());
  module_map_[new_module] = module;
  return new_module;
}

int32_t PPB_URLLoader_Impl::ValidateCallback(PP_CompletionCallback callback) {
  if (!callback.func)
    return PP_ERROR_BADARGUMENT;

  if (pending_callback_.get() && !pending_callback_->completed())
    return PP_ERROR_INPROGRESS;

  return PP_OK;
}

void ResourceTracker::SetSingletonOverride(ResourceTracker* tracker) {
  DCHECK(!singleton_override_);
  singleton_override_ = tracker;
}

size_t PPB_URLLoader_Impl::FillUserBuffer() {
  DCHECK(user_buffer_);
  DCHECK(user_buffer_size_);

  size_t bytes_to_copy = std::min(buffer_.size(), user_buffer_size_);
  std::copy(buffer_.begin(), buffer_.begin() + bytes_to_copy, user_buffer_);
  buffer_.erase(buffer_.begin(), buffer_.begin() + bytes_to_copy);

  DCHECK(!is_asynchronous_load_suspended_ || request_info_);
  if (is_asynchronous_load_suspended_ &&
      buffer_.size() <= static_cast<size_t>(
          request_info_->prefetch_buffer_lower_threshold())) {
    DVLOG(1) << "Resuming async load - buffer size: " << buffer_.size();
    loader_->setDefersLoading(false);
    is_asynchronous_load_suspended_ = false;
  }

  user_buffer_ = NULL;
  user_buffer_size_ = 0;
  return bytes_to_copy;
}

void ResourceTracker::ClearSingletonOverride() {
  DCHECK(singleton_override_);
  singleton_override_ = NULL;
}

bool ResourceTracker::AddRefResource(PP_Resource res) {
  DLOG_IF(ERROR, !CheckIdType(res, PP_ID_TYPE_RESOURCE))
      << res << " is not a PP_Resource.";
  ResourceMap::iterator i = live_resources_.find(res);
  if (i != live_resources_.end()) {
    ++i->second.second;
    return true;
  } else {
    return false;
  }
}

 Resource::Resource(PluginInstance* instance)
     : resource_id_(0), instance_(instance) {
 }

  InstanceData() : instance(0) {}

 void PPB_Widget_Impl::Invalidate(const PP_Rect* dirty) {
   const PPP_Widget_Dev* widget = static_cast<const PPP_Widget_Dev*>(
       instance()->module()->GetPluginInterface(PPP_WIDGET_DEV_INTERFACE));
   if (!widget)
    return;
  ScopedResourceId resource(this);
  widget->Invalidate(instance()->pp_instance(), resource.id, dirty);
}

PP_Bool PPB_URLLoader_Impl::GetDownloadProgress(
    int64_t* bytes_received,
    int64_t* total_bytes_to_be_received) {
  if (!RecordDownloadProgress()) {
    *bytes_received = 0;
    *total_bytes_to_be_received = 0;
    return PP_FALSE;
  }
  *bytes_received = bytes_received_;
  *total_bytes_to_be_received = total_bytes_to_be_received_;
  return PP_TRUE;
}

PP_Bool GetLocation(PP_Resource resource, PP_Rect* location) {
  scoped_refptr<PPB_Widget_Impl> widget(
      Resource::GetAs<PPB_Widget_Impl>(resource));
  return BoolToPPBool(widget && widget->GetLocation(location));
}

void ResourceTracker::InstanceCrashed(PP_Instance instance) {
  CleanupInstanceData(instance, false);
}

PPB_Widget_Impl* PPB_Widget_Impl::AsPPB_Widget_Impl() {
  return this;
}

bool ResourceTracker::UnrefVar(int32 var_id) {
  DLOG_IF(ERROR, !CheckIdType(var_id, PP_ID_TYPE_VAR))
      << var_id << " is not a PP_Var ID.";
  VarMap::iterator i = live_vars_.find(var_id);
  if (i != live_vars_.end()) {
    if (!--i->second.second) {
      ObjectVar* object_var = i->second.first->AsObjectVar();
      if (object_var) {
        instance_map_[object_var->instance()->pp_instance()]->object_vars.erase(
            var_id);
      }
      live_vars_.erase(i);
    }
    return true;
  }
  return false;
}

ResourceTracker::ResourceTracker()
    : last_resource_id_(0),
      last_var_id_(0) {
  ::ppapi::TrackerBase::Init(&GetTrackerBase);
}

PP_Resource PPB_URLLoader_Impl::GetResponseInfo() {
  if (!response_info_)
    return 0;
  return response_info_->GetReference();
}

const PPB_Widget_Dev* PPB_Widget_Impl::GetInterface() {
  return &ppb_widget;
}

PP_Resource ResourceTracker::AddResource(Resource* resource) {
// If the plugin manages to create 1 billion resources, don't do crazy stuff.
if (last_resource_id_ ==
(std::numeric_limits<PP_Resource>::max() >> kPPIdTypeBits))
return 0;

// Add the resource with plugin use-count 1.
PP_Resource new_id = MakeTypedId(++last_resource_id_, PP_ID_TYPE_RESOURCE);
live_resources_.insert(std::make_pair(new_id, std::make_pair(resource, 1)));

// Track associated with the instance.
PP_Instance pp_instance = resource->instance()->pp_instance();
DCHECK(instance_map_.find(pp_instance) != instance_map_.end());
  instance_map_[pp_instance]->resources.insert(new_id);
return new_id;
}

scoped_refptr<Var> ResourceTracker::GetVar(int32 var_id) const {
  DLOG_IF(ERROR, !CheckIdType(var_id, PP_ID_TYPE_VAR))
      << var_id << " is not a PP_Var ID.";
  VarMap::const_iterator result = live_vars_.find(var_id);
  if (result == live_vars_.end())
    return scoped_refptr<Var>();
  return result->second.first;
}

PP_Bool PPB_URLLoader_Impl::GetUploadProgress(int64_t* bytes_sent,
                                              int64_t* total_bytes_to_be_sent) {
  if (!RecordUploadProgress()) {
    *bytes_sent = 0;
    *total_bytes_to_be_sent = 0;
    return PP_FALSE;
  }
  *bytes_sent = bytes_sent_;
  *total_bytes_to_be_sent = total_bytes_to_be_sent_;
  return PP_TRUE;
}
