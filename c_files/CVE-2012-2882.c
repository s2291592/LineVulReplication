  virtual ~EventTestWindow() {}

aura::Window* GetContainerById(int id) {
  return Shell::GetInstance()->GetContainer(id);
}

StackingController::StackingController() {
  aura::client::SetStackingClient(this);
  always_on_top_controller_.reset(new internal::AlwaysOnTopController);
  always_on_top_controller_->SetContainers(
      GetContainerById(internal::kShellWindowId_DefaultContainer),
      GetContainerById(internal::kShellWindowId_AlwaysOnTopContainer));
}

 bool IsWindowModal(aura::Window* window) {
  return window->transient_parent() &&
      window->GetProperty(aura::client::kModalKey) == ui::MODAL_TYPE_WINDOW;
}

aura::Window* GetContainerForWindow(aura::Window* window) {
  aura::Window* container = window->parent();
  while (container && container->type() != aura::client::WINDOW_TYPE_UNKNOWN)
    container = container->parent();
  return container;
 }

  aura::Window* OpenTestWindow(aura::Window* parent) {
    views::Widget* widget =
        views::Widget::CreateWindowWithParent(this, parent);
    widget->Show();
    return widget->GetNativeView();
  }

  virtual ~TransientWindowObserver() {}

aura::Window* StackingController::GetSystemModalContainer(
    aura::Window* window) const {
  if (!IsSystemModal(window))
    return NULL;

  aura::Window* lock_container =
      GetContainerById(internal::kShellWindowId_LockScreenContainer);
  if (!lock_container->children().size())
    return GetContainerById(internal::kShellWindowId_SystemModalContainer);

  int lock_container_id = lock_container->id();
  int window_container_id = window->transient_parent()->parent()->id();

  aura::Window* container = NULL;
  if (window_container_id < lock_container_id) {
    container = GetContainerById(
        internal::kShellWindowId_SystemModalContainer);
  } else {
    container = GetContainerById(
        internal::kShellWindowId_LockSystemModalContainer);
  }

  return container;
}

   virtual ~TestWindow() {}

  bool destroyed() const { return destroyed_; }

  explicit EventTestWindow(bool modal) : TestWindow(modal),
                                         mouse_presses_(0) {}

aura::Window* StackingController::GetDefaultParent(aura::Window* window) {
  switch (window->type()) {
    case aura::client::WINDOW_TYPE_NORMAL:
    case aura::client::WINDOW_TYPE_POPUP:
      if (IsSystemModal(window))
        return GetSystemModalContainer(window);
      else if (IsWindowModal(window))
        return GetContainerForWindow(window->transient_parent());
      return always_on_top_controller_->GetContainer(window);
    case aura::client::WINDOW_TYPE_PANEL:
      return GetContainerById(internal::kShellWindowId_PanelContainer);
    case aura::client::WINDOW_TYPE_MENU:
      return GetContainerById(internal::kShellWindowId_MenuContainer);
    case aura::client::WINDOW_TYPE_TOOLTIP:
      return GetContainerById(
          internal::kShellWindowId_DragImageAndTooltipContainer);
    case aura::client::WINDOW_TYPE_CONTROL:
      return GetContainerById(
          internal::kShellWindowId_UnparentedControlContainer);
    default:
      NOTREACHED() << "Window " << window->id()
                   << " has unhandled type " << window->type();
      break;
  }
  return NULL;
}

static aura::Window* OpenTestWindow(aura::Window* parent, bool modal) {
    DCHECK(!modal || (modal && parent));
views::Widget* widget =
views::Widget::CreateWindowWithParent(new TestWindow(modal), parent);
widget->Show();
return widget->GetNativeView();
}

StackingController::~StackingController() {
}

aura::Window* GetModalContainer() {
  return Shell::GetInstance()->GetContainer(
      ash::internal::kShellWindowId_SystemModalContainer);
}

  int mouse_presses() const { return mouse_presses_; }

aura::Window* GetDefaultContainer() {
  return Shell::GetInstance()->GetContainer(
      ash::internal::kShellWindowId_DefaultContainer);
}

  TransientWindowObserver() : destroyed_(false) {}
