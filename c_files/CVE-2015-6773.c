void SelectionController::ContextDestroyed(Document*) {
  original_base_in_flat_tree_ = PositionInFlatTreeWithAffinity();
}

void FrameSelection::MoveCaretSelection(const IntPoint& point) {
DCHECK(!GetDocument().NeedsLayoutTreeUpdate());

Element* const editable =
ComputeVisibleSelectionInDOMTree().RootEditableElement();
if (!editable)
return;

const VisiblePosition position =
VisiblePositionForContentsPoint(point, GetFrame());
SelectionInDOMTree::Builder builder;
builder.SetIsDirectional(GetSelectionInDOMTree().IsDirectional());
  builder.SetIsHandleVisible(true);
if (position.IsNotNull())
builder.Collapse(position.ToPositionWithAffinity());
SetSelection(builder.Build(), SetSelectionData::Builder()
.SetShouldCloseTyping(true)
.SetShouldClearTypingStyle(true)
.SetSetSelectionBy(SetSelectionBy::kUser)
.Build());
}

void FrameSelection::SetUseSecureKeyboardEntryWhenActive(
    bool uses_secure_keyboard) {
  if (use_secure_keyboard_entry_when_active_ == uses_secure_keyboard)
    return;
  use_secure_keyboard_entry_when_active_ = uses_secure_keyboard;
  UpdateSecureKeyboardEntryIfActive();
}

void Editor::DeleteSelectionWithSmartDelete(
    DeleteMode delete_mode,
    InputEvent::InputType input_type,
    const Position& reference_move_position) {
  if (GetFrame()
          .Selection()
          .ComputeVisibleSelectionInDOMTreeDeprecated()
          .IsNone())
    return;

  const bool kMergeBlocksAfterDelete = true;
  const bool kExpandForSpecialElements = false;
  const bool kSanitizeMarkup = true;
  DCHECK(GetFrame().GetDocument());
  DeleteSelectionCommand::Create(
      *GetFrame().GetDocument(), delete_mode == DeleteMode::kSmart,
      kMergeBlocksAfterDelete, kExpandForSpecialElements, kSanitizeMarkup,
      input_type, reference_move_position)
      ->Apply();
}

void SelectionEditor::DidUpdateCharacterData(CharacterData* node,
                                             unsigned offset,
                                             unsigned old_length,
                                             unsigned new_length) {
  if (selection_.IsNone() || !node || !node->isConnected()) {
    DidFinishDOMMutation();
    return;
  }
  const Position& new_base = UpdatePositionAfterAdoptingTextReplacement(
      selection_.base_, node, offset, old_length, new_length);
  const Position& new_extent = UpdatePositionAfterAdoptingTextReplacement(
      selection_.extent_, node, offset, old_length, new_length);
  DidFinishTextChange(new_base, new_extent);
}

void FrameSelection::DocumentAttached(Document* document) {
  DCHECK(document);
  use_secure_keyboard_entry_when_active_ = false;
  selection_editor_->DocumentAttached(document);
  SetContext(document);
}

void FrameSelection::UpdateSecureKeyboardEntryIfActive() {
  if (!FrameIsFocusedAndActive())
    return;
  SetUseSecureKeyboardEntry(use_secure_keyboard_entry_when_active_);
}

void Editor::PasteWithPasteboard(Pasteboard* pasteboard) {
  DocumentFragment* fragment = nullptr;
  bool chose_plain_text = false;

  if (pasteboard->IsHTMLAvailable()) {
    unsigned fragment_start = 0;
    unsigned fragment_end = 0;
    KURL url;
    String markup = pasteboard->ReadHTML(url, fragment_start, fragment_end);
    if (!markup.IsEmpty()) {
      DCHECK(GetFrame().GetDocument());
      fragment = CreateFragmentFromMarkupWithContext(
          *GetFrame().GetDocument(), markup, fragment_start, fragment_end, url,
          kDisallowScriptingAndPluginContent);
    }
  }

  if (!fragment) {
    String text = pasteboard->PlainText();
    if (!text.IsEmpty()) {
      chose_plain_text = true;

      GetFrame().GetDocument()->UpdateStyleAndLayoutIgnorePendingStylesheets();

      fragment = CreateFragmentFromText(SelectedRange(), text);
    }
  }

  if (fragment)
    PasteAsFragment(fragment, CanSmartReplaceWithPasteboard(pasteboard),
                    chose_plain_text);
}

bool Editor::InsertText(const String& text, KeyboardEvent* triggering_event) {
  return GetFrame().GetEventHandler().HandleTextInputEvent(text,
                                                           triggering_event);
}

bool InputMethodController::FinishComposingText(
ConfirmCompositionBehavior confirm_behavior) {
if (!HasComposition())
return false;

// If text is longer than maxlength, give input/textarea's handler a chance to
// clamp the text by replacing the composition with the same value.
const bool is_too_long = IsTextTooLongAt(composition_range_->StartPosition());

const String& composing = ComposingText();

if (confirm_behavior == kKeepSelection) {
// Do not dismiss handles even if we are moving selection, because we will
// eventually move back to the old selection offsets.
const bool is_handle_visible = GetFrame().Selection().IsHandleVisible();

const PlainTextRange& old_offsets = GetSelectionOffsets();
Editor::RevealSelectionScope reveal_selection_scope(&GetEditor());

if (is_too_long) {
ReplaceComposition(ComposingText());
} else {
Clear();
DispatchCompositionEndEvent(GetFrame(), composing);
}

// TODO(editing-dev): Use of updateStyleAndLayoutIgnorePendingStylesheets
// needs to be audited. see http://crbug.com/590369 for more details.
GetDocument().UpdateStyleAndLayoutIgnorePendingStylesheets();

const EphemeralRange& old_selection_range =
EphemeralRangeForOffsets(old_offsets);
if (old_selection_range.IsNull())
return false;
const SelectionInDOMTree& selection =
SelectionInDOMTree::Builder()
.SetBaseAndExtent(old_selection_range)
            .SetIsHandleVisible(is_handle_visible)
.Build();
GetFrame().Selection().SetSelection(
        selection,
        SetSelectionData::Builder().SetShouldCloseTyping(true).Build());
return true;
}

Element* root_editable_element =
GetFrame()
.Selection()
.ComputeVisibleSelectionInDOMTreeDeprecated()
.RootEditableElement();
if (!root_editable_element)
return false;
PlainTextRange composition_range =
PlainTextRange::Create(*root_editable_element, *composition_range_);
if (composition_range.IsNull())
return false;

if (is_too_long) {
ReplaceComposition(ComposingText());
} else {
Clear();
}

if (!MoveCaret(composition_range.End()))
return false;

DispatchCompositionEndEvent(GetFrame(), composing);
return true;
}

FrameSelection::~FrameSelection() {}

void Transpose(LocalFrame& frame) {
  Editor& editor = frame.GetEditor();
  if (!editor.CanEdit())
    return;

  Document* const document = frame.GetDocument();

  document->UpdateStyleAndLayoutIgnorePendingStylesheets();

  const EphemeralRange& range = ComputeRangeForTranspose(frame);
  if (range.IsNull())
    return;

  const String& text = PlainText(range);
  if (text.length() != 2)
    return;
  const String& transposed = text.Right(1) + text.Left(1);

  if (DispatchBeforeInputInsertText(
          EventTargetNodeForDocument(document), transposed,
          InputEvent::InputType::kInsertTranspose,
          new StaticRangeVector(1, StaticRange::Create(range))) !=
      DispatchEventResult::kNotCanceled)
    return;

  if (frame.GetDocument() != document)
    return;

  document->UpdateStyleAndLayoutIgnorePendingStylesheets();

  const EphemeralRange& new_range = ComputeRangeForTranspose(frame);
  if (new_range.IsNull())
    return;

  const String& new_text = PlainText(new_range);
  if (new_text.length() != 2)
    return;
  const String& new_transposed = new_text.Right(1) + new_text.Left(1);

  const SelectionInDOMTree& new_selection =
      SelectionInDOMTree::Builder().SetBaseAndExtent(new_range).Build();

  if (CreateVisibleSelection(new_selection) !=
      frame.Selection().ComputeVisibleSelectionInDOMTree())
    frame.Selection().SetSelection(new_selection);

  editor.ReplaceSelectionWithText(new_transposed, false, false,
                                  InputEvent::InputType::kInsertTranspose);
}

void Editor::ApplyStyle(StylePropertySet* style,
                        InputEvent::InputType input_type) {
  const VisibleSelection& selection =
      GetFrame().Selection().ComputeVisibleSelectionInDOMTreeDeprecated();
  if (selection.IsNone())
    return;
  if (selection.IsCaret()) {
    ComputeAndSetTypingStyle(style, input_type);
    return;
  }
  DCHECK(selection.IsRange()) << selection;
  if (!style)
    return;
  DCHECK(GetFrame().GetDocument());
  ApplyStyleCommand::Create(*GetFrame().GetDocument(),
                            EditingStyle::Create(style), input_type)
      ->Apply();
}

bool FrameSelection::IsHandleVisible() const {
  return GetSelectionInDOMTree().IsHandleVisible();
}

bool Editor::ReplaceSelectionAfterDraggingWithEvents(
    Element* drop_target,
    DragData* drag_data,
    DocumentFragment* fragment,
    Range* drop_caret_range,
    InsertMode insert_mode,
    DragSourceType drag_source_type) {
  if (!drop_target || !drop_target->isConnected())
    return true;

  DataTransfer* data_transfer =
      DataTransfer::Create(DataTransfer::kDragAndDrop, kDataTransferReadable,
                           drag_data->PlatformData());
  data_transfer->SetSourceOperation(drag_data->DraggingSourceOperationMask());
  const bool should_insert =
      DispatchBeforeInputDataTransfer(
          drop_target, InputEvent::InputType::kInsertFromDrop, data_transfer) ==
      DispatchEventResult::kNotCanceled;

  if (frame_->GetDocument()->GetFrame() != frame_)
    return false;

  if (should_insert && drop_target->isConnected())
    ReplaceSelectionAfterDragging(fragment, insert_mode, drag_source_type);

  return true;
}

void InputMethodController::WillChangeFocus() {
  FinishComposingText(kKeepSelection);
}

void FrameSelection::SetSelection(const SelectionInDOMTree& selection,
                                  const SetSelectionData& data) {
  if (SetSelectionDeprecated(selection, data))
    DidSetSelectionDeprecated(data);
}

void FrameSelection::Clear() {
  granularity_ = TextGranularity::kCharacter;
   if (granularity_strategy_)
     granularity_strategy_->Clear();
   SetSelection(SelectionInDOMTree());
 }

GranularityStrategy* FrameSelection::GetGranularityStrategy() {
  SelectionStrategy strategy_type = SelectionStrategy::kCharacter;
  Settings* settings = frame_ ? frame_->GetSettings() : 0;
  if (settings &&
      settings->GetSelectionStrategy() == SelectionStrategy::kDirection)
    strategy_type = SelectionStrategy::kDirection;

  if (granularity_strategy_ &&
      granularity_strategy_->GetType() == strategy_type)
    return granularity_strategy_.get();

  if (strategy_type == SelectionStrategy::kDirection)
    granularity_strategy_ = WTF::MakeUnique<DirectionGranularityStrategy>();
  else
    granularity_strategy_ = WTF::MakeUnique<CharacterGranularityStrategy>();
  return granularity_strategy_.get();
}

Element* Editor::FindEventTargetFrom(const VisibleSelection& selection) const {
  Element* target = AssociatedElementOf(selection.Start());
  if (!target)
    target = GetFrame().GetDocument()->body();

  return target;
}

VisiblePositionInFlatTree VisiblePositionOfHitTestResult(
    const HitTestResult& hit_test_result) {
  return CreateVisiblePosition(FromPositionInDOMTree<EditingInFlatTreeStrategy>(
      hit_test_result.InnerNode()->GetLayoutObject()->PositionForPoint(
          hit_test_result.LocalPoint())));
}

Document& SelectionController::GetDocument() const {
  DCHECK(frame_->GetDocument());
  return *frame_->GetDocument();
}

Editor* Editor::Create(LocalFrame& frame) {
  return new Editor(frame);
}

bool FrameSelection::SetSelectionDeprecated(
const SelectionInDOMTree& passed_selection,
const SetSelectionData& options) {
DCHECK(IsAvailable());
passed_selection.AssertValidFor(GetDocument());

SelectionInDOMTree::Builder builder(passed_selection);
if (ShouldAlwaysUseDirectionalSelection(frame_))
builder.SetIsDirectional(true);
SelectionInDOMTree new_selection = builder.Build();
if (granularity_strategy_ && !options.DoNotClearStrategy())
granularity_strategy_->Clear();
granularity_ = options.Granularity();

// TODO(yosin): We should move to call |TypingCommand::closeTyping()| to
// |Editor| class.
if (options.ShouldCloseTyping())
TypingCommand::CloseTyping(frame_);

if (options.ShouldClearTypingStyle())
frame_->GetEditor().ClearTypingStyle();

const SelectionInDOMTree old_selection_in_dom_tree =
selection_editor_->GetSelectionInDOMTree();
  if (old_selection_in_dom_tree == new_selection)
return false;
  selection_editor_->SetSelection(new_selection);
ScheduleVisualUpdateForPaintInvalidationIfNeeded();

const Document& current_document = GetDocument();
// TODO(yosin): We should get rid of unsued |options| for
// |Editor::respondToChangedSelection()|.
// Note: Since, setting focus can modify DOM tree, we should use
// |oldSelection| before setting focus
frame_->GetEditor().RespondToChangedSelection(
old_selection_in_dom_tree.ComputeStartPosition(),
options.ShouldCloseTyping() ? TypingContinuation::kEnd
: TypingContinuation::kContinue);
DCHECK_EQ(current_document, GetDocument());
return true;
}

void Editor::ComputeAndSetTypingStyle(StylePropertySet* style,
                                      InputEvent::InputType input_type) {
  if (!style || style->IsEmpty()) {
    ClearTypingStyle();
    return;
  }

  if (typing_style_)
    typing_style_->OverrideWithStyle(style);
  else
    typing_style_ = EditingStyle::Create(style);

  typing_style_->PrepareToApplyAt(
      GetFrame()
          .Selection()
          .ComputeVisibleSelectionInDOMTreeDeprecated()
          .VisibleStart()
          .DeepEquivalent(),
      EditingStyle::kPreserveWritingDirection);

  EditingStyle* block_style = typing_style_->ExtractAndRemoveBlockProperties();
  if (!block_style->IsEmpty()) {
    DCHECK(GetFrame().GetDocument());
    ApplyStyleCommand::Create(*GetFrame().GetDocument(), block_style,
                              input_type)
        ->Apply();
  }
}

void SelectionController::HandleMouseDraggedEvent(
    const MouseEventWithHitTestResults& event,
    const IntPoint& mouse_down_pos,
    const LayoutPoint& drag_start_pos,
    Node* mouse_press_node,
    const IntPoint& last_known_mouse_position) {
  TRACE_EVENT0("blink", "SelectionController::handleMouseDraggedEvent");

  if (!Selection().IsAvailable())
    return;
  if (selection_state_ != SelectionState::kExtendedSelection) {
    HitTestRequest request(HitTestRequest::kReadOnly | HitTestRequest::kActive);
    HitTestResult result(request, mouse_down_pos);
    frame_->GetDocument()->GetLayoutViewItem().HitTest(result);

    UpdateSelectionForMouseDrag(result, mouse_press_node, drag_start_pos,
                                last_known_mouse_position);
  }
  UpdateSelectionForMouseDrag(event.GetHitTestResult(), mouse_press_node,
                              drag_start_pos, last_known_mouse_position);
}

void SelectionController::SetCaretAtHitTestResult(
    const HitTestResult& hit_test_result) {
  Node* inner_node = hit_test_result.InnerNode();
  const VisiblePositionInFlatTree& visible_hit_pos =
      VisiblePositionOfHitTestResult(hit_test_result);
  const VisiblePositionInFlatTree& visible_pos =
      visible_hit_pos.IsNull()
          ? CreateVisiblePosition(
                PositionInFlatTree::FirstPositionInOrBeforeNode(inner_node))
          : visible_hit_pos;

  if (visible_pos.IsNull()) {
    UpdateSelectionForMouseDownDispatchingSelectStart(
        inner_node, SelectionInFlatTree(), TextGranularity::kCharacter,
        HandleVisibility::kVisible);
    return;
  }
  UpdateSelectionForMouseDownDispatchingSelectStart(
      inner_node,
      ExpandSelectionToRespectUserSelectAll(
          inner_node, SelectionInFlatTree::Builder()
                          .Collapse(visible_pos.ToPositionWithAffinity())
                          .Build()),
      TextGranularity::kCharacter, HandleVisibility::kVisible);
}

Text* FrameSelectionTest::AppendTextNode(const String& data) {
  Text* text = GetDocument().createTextNode(data);
  GetDocument().body()->AppendChild(text);
  return text;
}

bool SelectionController::MouseDownWasSingleClickInSelection() const {
  return mouse_down_was_single_click_in_selection_;
}

static void DispatchEditableContentChangedEvents(Element* start_root,
                                                 Element* end_root) {
  if (start_root)
    start_root->DispatchEvent(
        Event::Create(EventTypeNames::webkitEditableContentChanged));
  if (end_root && end_root != start_root)
    end_root->DispatchEvent(
        Event::Create(EventTypeNames::webkitEditableContentChanged));
}

void FrameSelection::CommitAppearanceIfNeeded() {
  return layout_selection_->Commit();
}

static PositionInFlatTree ComputeStartFromEndForExtendForward(
    const PositionInFlatTree& end,
    TextGranularity granularity) {
  if (granularity == TextGranularity::kCharacter)
    return end;
  return ComputeStartRespectingGranularity(
      PreviousPositionOf(CreateVisiblePosition(end),
                         kCannotCrossEditingBoundary)
          .DeepEquivalent(),
      granularity);
}

bool Editor::CanCut() const {
  return CanCopy() && CanDelete();
}

bool SelectionController::SelectClosestWordFromMouseEvent(
    const MouseEventWithHitTestResults& result) {
  if (!mouse_down_may_start_select_)
    return false;

  AppendTrailingWhitespace append_trailing_whitespace =
      (result.Event().click_count == 2 &&
       frame_->GetEditor().IsSelectTrailingWhitespaceEnabled())
          ? AppendTrailingWhitespace::kShouldAppend
          : AppendTrailingWhitespace::kDontAppend;

  DCHECK(!frame_->GetDocument()->NeedsLayoutTreeUpdate());

  return SelectClosestWordFromHitTestResult(
      result.GetHitTestResult(), append_trailing_whitespace,
      result.Event().FromTouch() ? SelectInputEventType::kTouch
                                 : SelectInputEventType::kMouse);
}

void Editor::RespondToChangedContents(const Position& position) {
  if (GetFrame().GetSettings() &&
      GetFrame().GetSettings()->GetAccessibilityEnabled()) {
    Node* node = position.AnchorNode();
    if (AXObjectCache* cache =
            GetFrame().GetDocument()->ExistingAXObjectCache())
      cache->HandleEditableTextContentChanged(node);
  }

  GetSpellChecker().RespondToChangedContents();
  Client().RespondToChangedContents();
}

void FrameSelection::ClearPreviousCaretVisualRect(const LayoutBlock& block) {
  frame_caret_->ClearPreviousVisualRect(block);
}

void Editor::SetMarkedTextMatchesAreHighlighted(bool flag) {
  if (flag == are_marked_text_matches_highlighted_)
    return;

  are_marked_text_matches_highlighted_ = flag;
  GetFrame().GetDocument()->Markers().RepaintMarkers(
      DocumentMarker::kTextMatch);
}

constexpr bool IsInvalidDeletionLength(const int length) {
  return length == kInvalidDeletionLength;
}

void DispatchInputEventEditableContentChanged(
    Element* start_root,
    Element* end_root,
    InputEvent::InputType input_type,
    const String& data,
    InputEvent::EventIsComposing is_composing) {
  if (start_root)
    DispatchInputEvent(start_root, input_type, data, is_composing);
  if (end_root && end_root != start_root)
    DispatchInputEvent(end_root, input_type, data, is_composing);
}

 bool FrameSelection::SelectionHasFocus() const {
  GetDocument().UpdateStyleAndLayoutIgnorePendingStylesheets();
  if (ComputeVisibleSelectionInFlatTree().IsNone())
    return false;
  const Node* current =
      ComputeVisibleSelectionInFlatTree().Start().ComputeContainerNode();
  if (!current)
    return false;

  Element* const focused_element = GetDocument().FocusedElement()
                                       ? GetDocument().FocusedElement()
                                       : GetDocument().documentElement();
  if (!focused_element)
    return false;

  if (focused_element->IsTextControl())
    return focused_element->ContainsIncludingHostElements(*current);

  const PositionInFlatTree& focused_position =
      PositionInFlatTree::FirstPositionInNode(*focused_element);
  if (ComputeVisibleSelectionInFlatTree().Start() <= focused_position &&
      ComputeVisibleSelectionInFlatTree().End() >= focused_position)
    return true;

  bool has_editable_style = HasEditableStyle(*current);
  do {
    if (has_editable_style && !HasEditableStyle(*current))
      return false;

    if (current == focused_element)
      return true;
    current = current->ParentOrShadowHostNode();
  } while (current);

  return false;
}

DEFINE_TRACE(InputMethodController) {
  visitor->Trace(frame_);
  visitor->Trace(composition_range_);
  SynchronousMutationObserver::Trace(visitor);
}

DispatchEventResult DispatchSelectStart(Node* node) {
  if (!node || !node->GetLayoutObject())
    return DispatchEventResult::kNotCanceled;

  return node->DispatchEvent(
      Event::CreateCancelableBubble(EventTypeNames::selectstart));
}

void FrameSelection::NotifyTextControlOfSelectionChange(
    SetSelectionBy set_selection_by) {
  TextControlElement* text_control =
      EnclosingTextControl(GetSelectionInDOMTree().Base());
  if (!text_control)
    return;
  text_control->SelectionChanged(set_selection_by == SetSelectionBy::kUser);
}

static SelectionInFlatTree AdjustEndpointsAtBidiBoundary(
    const VisiblePositionInFlatTree& visible_base,
    const VisiblePositionInFlatTree& visible_extent) {
  DCHECK(visible_base.IsValid());
  DCHECK(visible_extent.IsValid());

  RenderedPosition base(visible_base);
  RenderedPosition extent(visible_extent);

  const SelectionInFlatTree& unchanged_selection =
      SelectionInFlatTree::Builder()
          .SetBaseAndExtent(visible_base.DeepEquivalent(),
                            visible_extent.DeepEquivalent())
          .Build();

  if (base.IsNull() || extent.IsNull() || base.IsEquivalent(extent))
    return unchanged_selection;

  if (base.AtLeftBoundaryOfBidiRun()) {
    if (!extent.AtRightBoundaryOfBidiRun(base.BidiLevelOnRight()) &&
        base.IsEquivalent(
            extent.LeftBoundaryOfBidiRun(base.BidiLevelOnRight()))) {
      return SelectionInFlatTree::Builder()
          .SetBaseAndExtent(
              CreateVisiblePosition(
                  ToPositionInFlatTree(base.PositionAtLeftBoundaryOfBiDiRun()))
                  .DeepEquivalent(),
              visible_extent.DeepEquivalent())
          .Build();
    }
    return unchanged_selection;
  }

  if (base.AtRightBoundaryOfBidiRun()) {
    if (!extent.AtLeftBoundaryOfBidiRun(base.BidiLevelOnLeft()) &&
        base.IsEquivalent(
            extent.RightBoundaryOfBidiRun(base.BidiLevelOnLeft()))) {
      return SelectionInFlatTree::Builder()
          .SetBaseAndExtent(
              CreateVisiblePosition(
                  ToPositionInFlatTree(base.PositionAtRightBoundaryOfBiDiRun()))
                  .DeepEquivalent(),
              visible_extent.DeepEquivalent())
          .Build();
    }
    return unchanged_selection;
  }

  if (extent.AtLeftBoundaryOfBidiRun() &&
      extent.IsEquivalent(
          base.LeftBoundaryOfBidiRun(extent.BidiLevelOnRight()))) {
    return SelectionInFlatTree::Builder()
        .SetBaseAndExtent(
            visible_base.DeepEquivalent(),
            CreateVisiblePosition(
                ToPositionInFlatTree(extent.PositionAtLeftBoundaryOfBiDiRun()))
                .DeepEquivalent())
        .Build();
  }

  if (extent.AtRightBoundaryOfBidiRun() &&
      extent.IsEquivalent(
          base.RightBoundaryOfBidiRun(extent.BidiLevelOnLeft()))) {
    return SelectionInFlatTree::Builder()
        .SetBaseAndExtent(
            visible_base.DeepEquivalent(),
            CreateVisiblePosition(
                ToPositionInFlatTree(extent.PositionAtRightBoundaryOfBiDiRun()))
                .DeepEquivalent())
        .Build();
  }
  return unchanged_selection;
}

bool Editor::DeleteSelectionAfterDraggingWithEvents(
    Element* drag_source,
    DeleteMode delete_mode,
    const Position& reference_move_position) {
  if (!drag_source || !drag_source->isConnected())
    return true;

  const bool should_delete =
      DispatchBeforeInputEditorCommand(
          drag_source, InputEvent::InputType::kDeleteByDrag,
          TargetRangesForInputEvent(*drag_source)) ==
      DispatchEventResult::kNotCanceled;

  if (frame_->GetDocument()->GetFrame() != frame_)
    return false;

  if (should_delete && drag_source->isConnected()) {
    DeleteSelectionWithSmartDelete(delete_mode,
                                   InputEvent::InputType::kDeleteByDrag,
                                   reference_move_position);
  }

  return true;
}

bool InputMethodController::MoveCaret(int new_caret_position) {
  GetDocument().UpdateStyleAndLayoutIgnorePendingStylesheets();
  PlainTextRange selected_range =
      CreateRangeForSelection(new_caret_position, new_caret_position, 0);
  if (selected_range.IsNull())
    return false;
  return SetEditableSelectionOffsets(selected_range);
}

static Position UpdatePositionAfterAdoptingTextReplacement(
    const Position& position,
    CharacterData* node,
    unsigned offset,
    unsigned old_length,
    unsigned new_length) {
  if (position.AnchorNode() != node)
    return position;

  if (position.IsBeforeAnchor()) {
    return UpdatePositionAfterAdoptingTextReplacement(
        Position(node, 0), node, offset, old_length, new_length);
  }
  if (position.IsAfterAnchor()) {
    return UpdatePositionAfterAdoptingTextReplacement(
        Position(node, old_length), node, offset, old_length, new_length);
  }

  DCHECK_GE(position.OffsetInContainerNode(), 0);
  unsigned position_offset =
      static_cast<unsigned>(position.OffsetInContainerNode());
  if (position_offset >= offset && position_offset <= offset + old_length)
    position_offset = offset;

  if (position_offset > offset + old_length)
    position_offset = position_offset - old_length + new_length;

  if (position_offset > node->length())
    position_offset = node->length();

  return Position(node, position_offset);
}

void SelectionController::UpdateSelectionForMouseDrag(
    const HitTestResult& hit_test_result,
    Node* mouse_press_node,
    const LayoutPoint& drag_start_pos,
    const IntPoint& last_known_mouse_position) {
  if (!mouse_down_may_start_select_)
    return;

  Node* target = hit_test_result.InnerNode();
  if (!target)
    return;

  frame_->GetDocument()->UpdateStyleAndLayoutIgnorePendingStylesheets();

  const PositionWithAffinity& raw_target_position =
      Selection().SelectionHasFocus()
          ? PositionRespectingEditingBoundary(
                Selection().ComputeVisibleSelectionInDOMTree().Start(),
                hit_test_result.LocalPoint(), target)
          : PositionWithAffinity();
  VisiblePositionInFlatTree target_position = CreateVisiblePosition(
      FromPositionInDOMTree<EditingInFlatTreeStrategy>(raw_target_position));
  if (target_position.IsNull())
    return;


  if (ShouldRespectSVGTextBoundaries(*target, Selection()))
    return;

  if (selection_state_ == SelectionState::kHaveNotStartedSelection &&
      DispatchSelectStart(target) != DispatchEventResult::kNotCanceled)
    return;


  const bool should_extend_selection =
      selection_state_ == SelectionState::kExtendedSelection;
  selection_state_ = SelectionState::kExtendedSelection;

  const VisibleSelectionInFlatTree& visible_selection =
      Selection().ComputeVisibleSelectionInFlatTree();
  if (visible_selection.IsNone()) {
    return;
  }

  const PositionInFlatTree& adjusted_position =
      AdjustPositionRespectUserSelectAll(target, visible_selection.Start(),
                                         visible_selection.End(),
                                         target_position.DeepEquivalent());
  const SelectionInFlatTree& adjusted_selection =
      should_extend_selection
          ? ExtendSelectionAsDirectional(adjusted_position, visible_selection,
                                         Selection().Granularity())
          : SelectionInFlatTree::Builder().Collapse(adjusted_position).Build();

  SetNonDirectionalSelectionIfNeeded(
      adjusted_selection, Selection().Granularity(),
      kAdjustEndpointsAtBidiBoundary, HandleVisibility::kNotVisible);
}

void FrameSelection::SelectAll(SetSelectionBy set_selection_by) {
if (isHTMLSelectElement(GetDocument().FocusedElement())) {
HTMLSelectElement* select_element =
toHTMLSelectElement(GetDocument().FocusedElement());
if (select_element->CanSelectAll()) {
select_element->SelectAll();
return;
}
}

Node* root = nullptr;
Node* select_start_target = nullptr;
if (set_selection_by == SetSelectionBy::kUser && IsHidden()) {
// Hidden selection appears as no selection to user, in which case user-
// triggered SelectAll should act as if there is no selection.
root = GetDocument().documentElement();
select_start_target = GetDocument().body();
} else if (ComputeVisibleSelectionInDOMTree().IsContentEditable()) {
root = HighestEditableRoot(ComputeVisibleSelectionInDOMTree().Start());
if (Node* shadow_root = NonBoundaryShadowTreeRootNode(
ComputeVisibleSelectionInDOMTree().Start()))
select_start_target = shadow_root->OwnerShadowHost();
else
select_start_target = root;
} else {
root = NonBoundaryShadowTreeRootNode(
ComputeVisibleSelectionInDOMTree().Start());
if (root) {
select_start_target = root->OwnerShadowHost();
} else {
root = GetDocument().documentElement();
select_start_target = GetDocument().body();
}
}
if (!root || EditingIgnoresContent(*root))
return;

if (select_start_target) {
const Document& expected_document = GetDocument();
if (select_start_target->DispatchEvent(Event::CreateCancelableBubble(
EventTypeNames::selectstart)) != DispatchEventResult::kNotCanceled)
return;
// The frame may be detached due to selectstart event.
if (!IsAvailable()) {
// Reached by editing/selection/selectstart_detach_frame.html
return;
}
// |root| may be detached due to selectstart event.
if (!root->isConnected() || expected_document != root->GetDocument())
return;
}

// TODO(editing-dev): Should we pass in set_selection_by?
  SetSelection(SelectionInDOMTree::Builder()
                   .SelectAllChildren(*root)
                   .SetIsHandleVisible(IsHandleVisible())
.Build());
SelectFrameElementInParentIfFullySelected();
// TODO(editing-dev): Should we pass in set_selection_by?
NotifyTextControlOfSelectionChange(SetSelectionBy::kUser);
if (IsHandleVisible()) {
ContextMenuAllowedScope scope;
frame_->GetEventHandler().ShowNonLocatedContextMenu(nullptr,
kMenuSourceTouch);
}
}

const DisplayItemClient& FrameSelection::CaretDisplayItemClientForTesting()
    const {
  return frame_caret_->GetDisplayItemClient();
}

void Editor::RevealSelectionAfterEditingOperation(
    const ScrollAlignment& alignment,
    RevealExtentOption reveal_extent_option) {
  if (prevent_reveal_selection_)
    return;
  if (!GetFrame().Selection().IsAvailable())
    return;
  GetFrame().Selection().RevealSelection(alignment, reveal_extent_option);
}

static SelectionInDOMTree CorrectedSelectionAfterCommand(
    const VisibleSelection& passed_selection,
    Document* document) {
  if (!passed_selection.Base().IsConnected() ||
      !passed_selection.Extent().IsConnected() ||
      passed_selection.Base().GetDocument() != document ||
      passed_selection.Base().GetDocument() !=
          passed_selection.Extent().GetDocument())
    return SelectionInDOMTree();
  return passed_selection.AsSelection();
}

static SelectionInFlatTree ExtendSelectionAsNonDirectional(
    const PositionInFlatTree& position,
    const VisibleSelectionInFlatTree& selection,
    TextGranularity granularity) {
  DCHECK(!selection.IsNone());
  DCHECK(position.IsNotNull());
  const PositionInFlatTree& start = selection.Start();
  const PositionInFlatTree& end = selection.End();
  if (position < start) {
    return SelectionInFlatTree::Builder()
        .SetBaseAndExtent(
            end, ComputeStartRespectingGranularity(
                     PositionInFlatTreeWithAffinity(position), granularity))
        .Build();
  }
  if (end < position) {
    return SelectionInFlatTree::Builder()
        .SetBaseAndExtent(
            start,
            ComputeEndRespectingGranularity(
                start, PositionInFlatTreeWithAffinity(position), granularity))
        .Build();
  }
  const int distance_to_start = TextDistance(start, position);
  const int distance_to_end = TextDistance(position, end);
  if (distance_to_start <= distance_to_end) {
    return SelectionInFlatTree::Builder()
        .SetBaseAndExtent(
            end, ComputeStartRespectingGranularity(
                     PositionInFlatTreeWithAffinity(position), granularity))
        .Build();
  }
  return SelectionInFlatTree::Builder()
      .SetBaseAndExtent(
          start,
          ComputeEndRespectingGranularity(
              start, PositionInFlatTreeWithAffinity(position), granularity))
      .Build();
}

void FrameSelection::PaintCaret(GraphicsContext& context,
                                const LayoutPoint& paint_offset) {
  frame_caret_->PaintCaret(context, paint_offset);
}

void Editor::ReappliedEditing(UndoStep* cmd) {
  EventQueueScope scope;

  DispatchEditableContentChangedEvents(cmd->StartingRootEditableElement(),
                                       cmd->EndingRootEditableElement());
  DispatchInputEventEditableContentChanged(
      cmd->StartingRootEditableElement(), cmd->EndingRootEditableElement(),
      InputEvent::InputType::kHistoryRedo, g_null_atom,
      InputEvent::EventIsComposing::kNotComposing);

  const SelectionInDOMTree& new_selection = CorrectedSelectionAfterCommand(
      cmd->EndingSelection(), GetFrame().GetDocument());
  ChangeSelectionAfterCommand(new_selection,
                              SetSelectionData::Builder()
                                  .SetShouldCloseTyping(true)
                                  .SetShouldClearTypingStyle(true)
                                  .Build());

  last_edit_command_ = nullptr;
  undo_stack_->RegisterUndoStep(cmd);
  RespondToChangedContents(new_selection.Base());
}

void SelectionController::SetNonDirectionalSelectionIfNeeded(
const SelectionInFlatTree& passed_selection,
TextGranularity granularity,
EndPointsAdjustmentMode endpoints_adjustment_mode,
HandleVisibility handle_visibility) {
// TODO(editing-dev): The use of updateStyleAndLayoutIgnorePendingStylesheets
// needs to be audited.  See http://crbug.com/590369 for more details.
GetDocument().UpdateStyleAndLayoutIgnorePendingStylesheets();

const VisibleSelectionInFlatTree& new_selection =
CreateVisibleSelection(passed_selection);
// TODO(editing-dev): We should use |PositionWithAffinity| to pass affinity
// to |CreateVisiblePosition()| for |original_base|.
const PositionInFlatTree& base_position =
original_base_in_flat_tree_.GetPosition();
const VisiblePositionInFlatTree& original_base =
base_position.IsConnected() ? CreateVisiblePosition(base_position)
: VisiblePositionInFlatTree();
const VisiblePositionInFlatTree& base =
original_base.IsNotNull() ? original_base
: CreateVisiblePosition(new_selection.Base());
const VisiblePositionInFlatTree& extent =
CreateVisiblePosition(new_selection.Extent());
const SelectionInFlatTree& adjusted_selection =
endpoints_adjustment_mode == kAdjustEndpointsAtBidiBoundary
? AdjustEndpointsAtBidiBoundary(base, extent)
: SelectionInFlatTree::Builder()
.SetBaseAndExtent(base.DeepEquivalent(),
extent.DeepEquivalent())
.Build();

SelectionInFlatTree::Builder builder(new_selection.AsSelection());
if (adjusted_selection.Base() != base.DeepEquivalent() ||
adjusted_selection.Extent() != extent.DeepEquivalent()) {
original_base_in_flat_tree_ = base.ToPositionWithAffinity();
SetContext(&GetDocument());
builder.SetBaseAndExtent(adjusted_selection.Base(),
adjusted_selection.Extent());
} else if (original_base.IsNotNull()) {
if (CreateVisiblePosition(
Selection().ComputeVisibleSelectionInFlatTree().Base())
.DeepEquivalent() ==
CreateVisiblePosition(new_selection.Base()).DeepEquivalent()) {
builder.SetBaseAndExtent(original_base.DeepEquivalent(),
new_selection.Extent());
}
original_base_in_flat_tree_ = PositionInFlatTreeWithAffinity();
}

  builder.SetIsHandleVisible(handle_visibility == HandleVisibility::kVisible);
const SelectionInFlatTree& selection_in_flat_tree = builder.Build();
if (Selection().ComputeVisibleSelectionInFlatTree() ==
CreateVisibleSelection(selection_in_flat_tree) &&
      Selection().IsHandleVisible() == selection_in_flat_tree.IsHandleVisible())
return;
Selection().SetSelection(
ConvertToSelectionInDOMTree(selection_in_flat_tree),
SetSelectionData::Builder()
.SetShouldCloseTyping(true)
.SetShouldClearTypingStyle(true)
.SetCursorAlignOnScroll(CursorAlignOnScroll::kIfNeeded)
.SetGranularity(granularity)
.Build());
}

Editor::~Editor() {}

String FrameSelection::SelectedHTMLForClipboard() const {
  const VisibleSelectionInFlatTree& visible_selection =
      ComputeVisibleSelectionInFlatTree();
  const EphemeralRangeInFlatTree& range =
      visible_selection.ToNormalizedEphemeralRange();
  return CreateMarkup(
      range.StartPosition(), range.EndPosition(), kAnnotateForInterchange,
      ConvertBlocksToInlines::kNotConvert, kResolveNonLocalURLs);
}

bool Editor::HandleTextEvent(TextEvent* event) {
  if (event->IsDrop())
    return false;

  if (event->IsIncrementalInsertion())
    return false;

  frame_->GetDocument()->UpdateStyleAndLayoutIgnorePendingStylesheets();

  if (event->IsPaste()) {
    if (event->PastingFragment()) {
      ReplaceSelectionWithFragment(
          event->PastingFragment(), false, event->ShouldSmartReplace(),
          event->ShouldMatchStyle(), InputEvent::InputType::kInsertFromPaste);
    } else {
      ReplaceSelectionWithText(event->data(), false,
                               event->ShouldSmartReplace(),
                               InputEvent::InputType::kInsertFromPaste);
    }
    return true;
  }

  String data = event->data();
  if (data == "\n") {
    if (event->IsLineBreak())
      return InsertLineBreak();
    return InsertParagraphSeparator();
  }

  if (data == " " && !CanEditRichly() &&
      IsCaretAtStartOfWrappedLine(GetFrame().Selection())) {
    InsertLineBreak();
  }

  return InsertTextWithoutSendingTextEvent(data, false, event);
}

static bool IsCaretAtStartOfWrappedLine(const FrameSelection& selection) {
  if (!selection.ComputeVisibleSelectionInDOMTree().IsCaret())
    return false;
  if (selection.GetSelectionInDOMTree().Affinity() != TextAffinity::kDownstream)
    return false;
  const Position& position =
      selection.ComputeVisibleSelectionInDOMTree().Start();
  return !InSameLine(PositionWithAffinity(position, TextAffinity::kUpstream),
                     PositionWithAffinity(position, TextAffinity::kDownstream));
}

void InputMethodController::DeleteSurroundingText(int before, int after) {
  if (!GetEditor().CanEdit())
    return;
  const PlainTextRange selection_offsets(GetSelectionOffsets());
  if (selection_offsets.IsNull())
    return;
  Element* const root_editable_element =
      GetFrame()
          .Selection()
          .ComputeVisibleSelectionInDOMTreeDeprecated()
          .RootEditableElement();
  if (!root_editable_element)
    return;
  int selection_start = static_cast<int>(selection_offsets.Start());
  int selection_end = static_cast<int>(selection_offsets.End());

  if (before > 0 && selection_start > 0) {
    const int start = std::max(selection_start - before, 0);

    const EphemeralRange& range =
        PlainTextRange(0, start).CreateRange(*root_editable_element);
    if (range.IsNull())
      return;
    const Position& position = range.EndPosition();

    const size_t diff = ComputeDistanceToLeftGraphemeBoundary(position);
    const int adjusted_start = start - static_cast<int>(diff);
    if (!SetSelectionOffsets(PlainTextRange(adjusted_start, selection_start)))
      return;
    TypingCommand::DeleteSelection(GetDocument());

    selection_end = selection_end - (selection_start - adjusted_start);
    selection_start = adjusted_start;
  }

  if (after > 0) {
    const PlainTextRange range(0, selection_end + after);
    if (range.IsNull())
      return;
    const EphemeralRange& valid_range =
        range.CreateRange(*root_editable_element);
    if (valid_range.IsNull())
      return;
    const int end =
        PlainTextRange::Create(*root_editable_element, valid_range).End();
    const Position& position = valid_range.EndPosition();

    const size_t diff = ComputeDistanceToRightGraphemeBoundary(position);
    const int adjusted_end = end + static_cast<int>(diff);
    if (!SetSelectionOffsets(PlainTextRange(selection_end, adjusted_end)))
      return;
    TypingCommand::DeleteSelection(GetDocument());
  }

  SetSelectionOffsets(PlainTextRange(selection_start, selection_end));
}

void InputMethodController::AddCompositionUnderlines(
    const Vector<CompositionUnderline>& underlines,
    ContainerNode* base_element,
    unsigned offset_in_plain_chars) {
  for (const auto& underline : underlines) {
    unsigned underline_start = offset_in_plain_chars + underline.StartOffset();
    unsigned underline_end = offset_in_plain_chars + underline.EndOffset();

    EphemeralRange ephemeral_line_range =
        PlainTextRange(underline_start, underline_end)
            .CreateRange(*base_element);
    if (ephemeral_line_range.IsNull())
      continue;

    GetDocument().Markers().AddCompositionMarker(
        ephemeral_line_range, underline.GetColor(),
        underline.Thick() ? StyleableMarker::Thickness::kThick
                          : StyleableMarker::Thickness::kThin,
        underline.BackgroundColor());
  }
}

bool Editor::CanDelete() const {
  FrameSelection& selection = GetFrame().Selection();
  return selection.ComputeVisibleSelectionInDOMTreeDeprecated().IsRange() &&
         selection.ComputeVisibleSelectionInDOMTree().RootEditableElement();
}

void Editor::ApplyParagraphStyle(StylePropertySet* style,
                                 InputEvent::InputType input_type) {
  if (GetFrame()
          .Selection()
          .ComputeVisibleSelectionInDOMTreeDeprecated()
          .IsNone() ||
      !style)
    return;
  DCHECK(GetFrame().GetDocument());
  ApplyStyleCommand::Create(*GetFrame().GetDocument(),
                            EditingStyle::Create(style), input_type,
                            ApplyStyleCommand::kForceBlockProperties)
      ->Apply();
}

void FrameSelection::ShowTreeForThis() const {
  ComputeVisibleSelectionInDOMTreeDeprecated().ShowTreeForThis();
}

  PositionWithAffinity CaretPosition() const {
    return Selection().frame_caret_->CaretPosition();
  }

Range* Editor::FindRangeOfString(const String& target,
                                 const EphemeralRange& reference,
                                 FindOptions options) {
  return FindRangeOfStringAlgorithm<EditingStrategy>(
      *GetFrame().GetDocument(), target, reference, options);
}

base::Optional<int> FrameSelection::LayoutSelectionEnd() const {
  return layout_selection_->SelectionEnd();
}

bool FrameSelection::SelectWordAroundPosition(const VisiblePosition& position) {
  static const EWordSide kWordSideList[2] = {kRightWordIfOnBoundary,
                                             kLeftWordIfOnBoundary};
  for (EWordSide word_side : kWordSideList) {
    VisiblePosition start = StartOfWord(position, word_side);
    VisiblePosition end = EndOfWord(position, word_side);
    String text =
        PlainText(EphemeralRange(start.DeepEquivalent(), end.DeepEquivalent()));
    if (!text.IsEmpty() && !IsSeparator(text.CharacterStartingAt(0))) {
      SetSelection(SelectionInDOMTree::Builder()
                       .Collapse(start.ToPositionWithAffinity())
                       .Extend(end.DeepEquivalent())
                       .Build(),
                   SetSelectionData::Builder()
                       .SetShouldCloseTyping(true)
                       .SetShouldClearTypingStyle(true)
                       .SetGranularity(TextGranularity::kWord)
                       .Build());
      return true;
    }
  }

  return false;
}

void SelectionController::HandleGestureTwoFingerTap(
    const GestureEventWithHitTestResults& targeted_event) {
  TRACE_EVENT0("blink", "SelectionController::handleGestureTwoFingerTap");

  SetCaretAtHitTestResult(targeted_event.GetHitTestResult());
}

void FrameSelection::RevealSelection(const ScrollAlignment& alignment,
                                     RevealExtentOption reveal_extent_option) {
  DCHECK(IsAvailable());

  GetDocument().UpdateStyleAndLayoutIgnorePendingStylesheets();

  const VisibleSelection& selection = ComputeVisibleSelectionInDOMTree();
  if (selection.IsNone())
    return;

  if (DocumentLoader* document_loader = frame_->Loader().GetDocumentLoader())
    document_loader->GetInitialScrollState().was_scrolled_by_user = true;
  const Position& start = selection.Start();
  DCHECK(start.AnchorNode());
  DCHECK(start.AnchorNode()->GetLayoutObject());
  GetDocument().EnsurePaintLocationDataValidForNode(start.AnchorNode());
  if (!start.AnchorNode()->GetLayoutObject()->ScrollRectToVisible(
          LayoutRect(ComputeRectToScroll(reveal_extent_option)), alignment,
          alignment))
    return;

  UpdateAppearance();
}

SelectionInDOMTree ConvertToSelectionInDOMTree(
const SelectionInFlatTree& selection_in_flat_tree) {
return SelectionInDOMTree::Builder()
.SetAffinity(selection_in_flat_tree.Affinity())
.SetBaseAndExtent(ToPositionInDOMTree(selection_in_flat_tree.Base()),
ToPositionInDOMTree(selection_in_flat_tree.Extent()))
.SetIsDirectional(selection_in_flat_tree.IsDirectional())
      .SetIsHandleVisible(selection_in_flat_tree.IsHandleVisible())
.Build();
}

bool Editor::DispatchCPPEvent(const AtomicString& event_type,
                              DataTransferAccessPolicy policy,
                              PasteMode paste_mode) {
  Element* target = FindEventTargetFromSelection();
  if (!target)
    return true;

  DataTransfer* data_transfer =
      DataTransfer::Create(DataTransfer::kCopyAndPaste, policy,
                           policy == kDataTransferWritable
                               ? DataObject::Create()
                               : DataObject::CreateFromPasteboard(paste_mode));

  Event* evt = ClipboardEvent::Create(event_type, true, true, data_transfer);
  target->DispatchEvent(evt);
  bool no_default_processing = evt->defaultPrevented();
  if (no_default_processing && policy == kDataTransferWritable)
    Pasteboard::GeneralPasteboard()->WriteDataObject(
        data_transfer->GetDataObject());

  data_transfer->SetAccessPolicy(kDataTransferNumb);

  return !no_default_processing;
}

bool Editor::SmartInsertDeleteEnabled() const {
  if (Settings* settings = GetFrame().GetSettings())
    return settings->GetSmartInsertDeleteEnabled();
  return false;
}

bool Editor::CanEdit() const {
  return GetFrame()
      .Selection()
      .ComputeVisibleSelectionInDOMTreeDeprecated()
      .RootEditableElement();
}

 const VisibleSelection& FrameSelection::ComputeVisibleSelectionInDOMTree()
     const {
   return selection_editor_->ComputeVisibleSelectionInDOMTree();
}

WebTextInputInfo InputMethodController::TextInputInfo() const {
  WebTextInputInfo info;
  if (!IsAvailable())
    return info;

  if (!GetFrame().Selection().IsAvailable()) {
    return info;
  }
  Element* element = RootEditableElementOfSelection(GetFrame().Selection());
  if (!element)
    return info;

  info.input_mode = InputModeOfFocusedElement();
  info.type = TextInputType();
  info.flags = TextInputFlags();
  if (info.type == kWebTextInputTypeNone)
    return info;

  if (!GetFrame().GetEditor().CanEdit())
    return info;

  GetDocument().UpdateStyleAndLayoutIgnorePendingStylesheets();

  DocumentLifecycle::DisallowTransitionScope disallow_transition(
      GetDocument().Lifecycle());

  info.value = PlainText(EphemeralRange::RangeOfContents(*element),
                         TextIteratorBehavior::Builder()
                             .SetEmitsObjectReplacementCharacter(true)
                             .SetEmitsSpaceForNbsp(true)
                             .Build());

  if (info.value.IsEmpty())
    return info;

  EphemeralRange first_range = FirstEphemeralRangeOf(
      GetFrame().Selection().ComputeVisibleSelectionInDOMTreeDeprecated());
  if (first_range.IsNotNull()) {
    PlainTextRange plain_text_range(
        PlainTextRange::Create(*element, first_range));
    if (plain_text_range.IsNotNull()) {
      info.selection_start = plain_text_range.Start();
      info.selection_end = plain_text_range.End();
    }
  }

  EphemeralRange range = CompositionEphemeralRange();
  if (range.IsNotNull()) {
    PlainTextRange plain_text_range(PlainTextRange::Create(*element, range));
    if (plain_text_range.IsNotNull()) {
      info.composition_start = plain_text_range.Start();
      info.composition_end = plain_text_range.End();
    }
  }

  return info;
}

  const VisibleSelection& VisibleSelectionInDOMTree() const {
    return Selection().ComputeVisibleSelectionInDOMTree();
  }

void SelectionController::InitializeSelectionState() {
  selection_state_ = SelectionState::kHaveNotStartedSelection;
}

void Editor::CountEvent(ExecutionContext* execution_context,
                        const Event* event) {
  if (!execution_context)
    return;

  if (event->type() == EventTypeNames::textInput) {
    CountEditingEvent(execution_context, event,
                      WebFeature::kTextInputEventOnInput,
                      WebFeature::kTextInputEventOnTextArea,
                      WebFeature::kTextInputEventOnContentEditable,
                      WebFeature::kTextInputEventOnNotNode);
    return;
  }

  if (event->type() == EventTypeNames::webkitBeforeTextInserted) {
    CountEditingEvent(execution_context, event,
                      WebFeature::kWebkitBeforeTextInsertedOnInput,
                      WebFeature::kWebkitBeforeTextInsertedOnTextArea,
                      WebFeature::kWebkitBeforeTextInsertedOnContentEditable,
                      WebFeature::kWebkitBeforeTextInsertedOnNotNode);
    return;
  }

  if (event->type() == EventTypeNames::webkitEditableContentChanged) {
    CountEditingEvent(
        execution_context, event,
        WebFeature::kWebkitEditableContentChangedOnInput,
        WebFeature::kWebkitEditableContentChangedOnTextArea,
        WebFeature::kWebkitEditableContentChangedOnContentEditable,
        WebFeature::kWebkitEditableContentChangedOnNotNode);
  }
}

DEFINE_TRACE(SelectionEditor) {
  visitor->Trace(frame_);
  visitor->Trace(selection_);
  visitor->Trace(cached_visible_selection_in_dom_tree_);
  visitor->Trace(cached_visible_selection_in_flat_tree_);
  visitor->Trace(cached_range_);
  SynchronousMutationObserver::Trace(visitor);
}

InputEvent::EventIsComposing IsComposingFromCommand(
    const CompositeEditCommand* command) {
  if (command->IsTypingCommand() &&
      ToTypingCommand(command)->CompositionType() !=
          TypingCommand::kTextCompositionNone)
    return InputEvent::EventIsComposing::kIsComposing;
  return InputEvent::EventIsComposing::kNotComposing;
}

bool SelectionEditor::NeedsUpdateVisibleSelectionInFlatTree() const {
  return cached_visible_selection_in_flat_tree_is_dirty_ ||
         style_version_for_flat_tree_ != GetDocument().StyleVersion();
}

bool InputMethodController::SetSelectionOffsets(
    const PlainTextRange& selection_offsets) {
  return SetSelectionOffsets(selection_offsets, TypingContinuation::kEnd);
}

InputMethodController* InputMethodController::Create(LocalFrame& frame) {
  return new InputMethodController(frame);
}

void GranularityStrategyTest::ParseText(const TextNodeVector& text_nodes) {
  bool word_started = false;
  int word_start_index = 0;
  for (auto& text : text_nodes) {
    int word_start_index_offset = letter_pos_.size();
    String str = text->wholeText();
    for (size_t i = 0; i < str.length(); i++) {
      letter_pos_.push_back(VisiblePositionToContentsPoint(
          CreateVisiblePosition(Position(text, i))));
      char c = str[i];
      if (IsASCIIAlphanumeric(c) && !word_started) {
        word_start_index = i + word_start_index_offset;
        word_started = true;
      } else if (!IsASCIIAlphanumeric(c) && word_started) {
        IntPoint word_middle((letter_pos_[word_start_index].X() +
                              letter_pos_[i + word_start_index_offset].X()) /
                                 2,
                             letter_pos_[word_start_index].Y());
        word_middles_.push_back(word_middle);
        word_started = false;
      }
    }
  }
  if (word_started) {
    const auto& last_node = text_nodes.back();
    int x_end = VisiblePositionToContentsPoint(
                    CreateVisiblePosition(
                        Position(last_node, last_node->wholeText().length())))
                    .X();
    IntPoint word_middle((letter_pos_[word_start_index].X() + x_end) / 2,
                         letter_pos_[word_start_index].Y());
    word_middles_.push_back(word_middle);
  }
}

ContainerNode* RootEditableElementOrTreeScopeRootNodeOf(
    const Position& position) {
  Element* selection_root = RootEditableElementOf(position);
  if (selection_root)
    return selection_root;

  Node* const node = position.ComputeContainerNode();
  return node ? &node->GetTreeScope().RootNode() : 0;
}

PlainTextRange InputMethodController::GetSelectionOffsets() const {
  EphemeralRange range = FirstEphemeralRangeOf(
      GetFrame().Selection().ComputeVisibleSelectionInDOMTreeDeprecated());
  if (range.IsNull())
    return PlainTextRange();
  ContainerNode* const editable = RootEditableElementOrTreeScopeRootNodeOf(
      GetFrame().Selection().ComputeVisibleSelectionInDOMTree().Base());
  DCHECK(editable);
  return PlainTextRange::Create(*editable, range);
}

int CalculateBeforeDeletionLengthsInCodePoints(
    const String& text,
    const int before_length_in_code_points,
    const int selection_start) {
  DCHECK_GE(before_length_in_code_points, 0);
  DCHECK_GE(selection_start, 0);
  DCHECK_LE(selection_start, static_cast<int>(text.length()));

  const UChar* u_text = text.Characters16();
  BackwardCodePointStateMachine backward_machine;
  int counter = before_length_in_code_points;
  int deletion_start = selection_start;
  while (counter > 0 && deletion_start > 0) {
    const TextSegmentationMachineState state =
        backward_machine.FeedPrecedingCodeUnit(u_text[deletion_start - 1]);
    if (state == TextSegmentationMachineState::kInvalid)
      return kInvalidDeletionLength;

    if (backward_machine.AtCodePointBoundary())
      --counter;
    --deletion_start;
  }
  if (!backward_machine.AtCodePointBoundary())
    return kInvalidDeletionLength;

  const int offset = backward_machine.GetBoundaryOffset();
  DCHECK_EQ(-offset, selection_start - deletion_start);
  return -offset;
}

bool InputMethodController::ReplaceComposition(const String& text) {
  if (!HasComposition())
    return false;

  SelectComposition();

  if (GetFrame()
          .Selection()
          .ComputeVisibleSelectionInDOMTreeDeprecated()
          .IsNone())
    return false;

  if (!IsAvailable())
    return false;

  Clear();

  InsertTextDuringCompositionWithEvents(
      GetFrame(), text, 0,
      TypingCommand::TextCompositionType::kTextCompositionConfirm);
  if (!IsAvailable())
    return false;

  DispatchCompositionEndEvent(GetFrame(), text);

  return true;
}

static PositionInFlatTree AdjustPositionRespectUserSelectAll(
    Node* inner_node,
    const PositionInFlatTree& selection_start,
    const PositionInFlatTree& selection_end,
    const PositionInFlatTree& position) {
  const VisibleSelectionInFlatTree& selection_in_user_select_all =
      CreateVisibleSelection(ExpandSelectionToRespectUserSelectAll(
          inner_node,
          position.IsNull()
              ? SelectionInFlatTree()
              : SelectionInFlatTree::Builder().Collapse(position).Build()));
  if (!selection_in_user_select_all.IsRange())
    return position;
  if (selection_in_user_select_all.Start().CompareTo(selection_start) < 0)
    return selection_in_user_select_all.Start();
  if (selection_end.CompareTo(selection_in_user_select_all.End()) < 0)
    return selection_in_user_select_all.End();
  return position;
}

bool FrameSelection::FrameIsFocusedAndActive() const {
  return focused_ && frame_->GetPage() &&
         frame_->GetPage()->GetFocusController().IsActive();
}

Element* Editor::FindEventTargetFromSelection() const {
  return FindEventTargetFrom(
      GetFrame().Selection().ComputeVisibleSelectionInDOMTreeDeprecated());
}

void SelectionEditor::DidChangeChildren(const ContainerNode&) {
  MarkCacheDirty();
  DidFinishDOMMutation();
}

TypingCommand* Editor::LastTypingCommandIfStillOpenForTyping() const {
  return TypingCommand::LastTypingCommandIfStillOpenForTyping(&GetFrame());
}

Editor::RevealSelectionScope::~RevealSelectionScope() {
  DCHECK(editor_->prevent_reveal_selection_);
  --editor_->prevent_reveal_selection_;
  if (!editor_->prevent_reveal_selection_) {
    editor_->GetFrame().Selection().RevealSelection(
        ScrollAlignment::kAlignToEdgeIfNeeded, kRevealExtent);
  }
}

SelectionController::SelectionController(LocalFrame& frame)
    : frame_(&frame),
      mouse_down_may_start_select_(false),
      mouse_down_was_single_click_in_selection_(false),
      mouse_down_allows_multi_click_(false),
      selection_state_(SelectionState::kHaveNotStartedSelection) {}

Text* GranularityStrategyTest::SetupTranslateZ(String str) {
  SetInnerHTML(
      "<html>"
      "<head>"
      "<style>"
      "div {"
      "transform: translateZ(0);"
      "}"
      "</style>"
      "</head>"
      "<body>"
      "<div id='mytext'></div>"
      "</body>"
      "</html>");

  Text* text = GetDocument().createTextNode(str);
  Element* div = GetDocument().getElementById("mytext");
  div->AppendChild(text);

  GetDocument().View()->UpdateAllLifecyclePhases();

  ParseText(text);
  return text;
}

static inline bool ShouldAlwaysUseDirectionalSelection(LocalFrame* frame) {
  return frame->GetEditor().Behavior().ShouldConsiderSelectionAsDirectional();
}

void Editor::ApplyParagraphStyleToSelection(StylePropertySet* style,
                                            InputEvent::InputType input_type) {
  if (!style || style->IsEmpty() || !CanEditRichly())
    return;

  ApplyParagraphStyle(style, input_type);
}

void FrameSelection::SelectAll() {
  SelectAll(SetSelectionBy::kSystem);
}

InputMethodController::InputMethodController(LocalFrame& frame)
    : frame_(&frame), has_composition_(false) {}

void Editor::Cut(EditorCommandSource source) {
  if (TryDHTMLCut())
    return;  // DHTML did the whole operation
  if (!CanCut())
    return;

  GetFrame().GetDocument()->UpdateStyleAndLayoutIgnorePendingStylesheets();

  if (source == kCommandFromMenuOrKeyBinding &&
      !GetFrame().Selection().SelectionHasFocus())
    return;

  if (CanDeleteRange(SelectedRange())) {
    GetSpellChecker().UpdateMarkersForWordsAffectedByEditing(true);
    if (EnclosingTextControl(GetFrame()
                                 .Selection()
                                 .ComputeVisibleSelectionInDOMTree()
                                 .Start())) {
      String plain_text = GetFrame().SelectedTextForClipboard();
      Pasteboard::GeneralPasteboard()->WritePlainText(
          plain_text, CanSmartCopyOrDelete() ? Pasteboard::kCanSmartReplace
                                             : Pasteboard::kCannotSmartReplace);
    } else {
      WriteSelectionToPasteboard();
    }

    if (source == kCommandFromMenuOrKeyBinding) {
      if (DispatchBeforeInputDataTransfer(FindEventTargetFromSelection(),
                                          InputEvent::InputType::kDeleteByCut,
                                          nullptr) !=
          DispatchEventResult::kNotCanceled)
        return;
      if (frame_->GetDocument()->GetFrame() != frame_)
        return;
    }
    DeleteSelectionWithSmartDelete(
        CanSmartCopyOrDelete() ? DeleteMode::kSmart : DeleteMode::kSimple,
        InputEvent::InputType::kDeleteByCut);
  }
}

void Editor::SetBaseWritingDirection(WritingDirection direction) {
  Element* focused_element = GetFrame().GetDocument()->FocusedElement();
  if (IsTextControlElement(focused_element)) {
    if (direction == NaturalWritingDirection)
      return;
    focused_element->setAttribute(
        dirAttr, direction == LeftToRightWritingDirection ? "ltr" : "rtl");
    focused_element->DispatchInputEvent();
    return;
  }

  MutableStylePropertySet* style =
      MutableStylePropertySet::Create(kHTMLQuirksMode);
  style->SetProperty(
      CSSPropertyDirection,
      direction == LeftToRightWritingDirection
          ? "ltr"
          : direction == RightToLeftWritingDirection ? "rtl" : "inherit",
      false);
  ApplyParagraphStyleToSelection(
      style, InputEvent::InputType::kFormatSetBlockTextDirection);
}

Document& FrameSelection::GetDocument() const {
  DCHECK(LifecycleContext());
   return *LifecycleContext();
 }

void SelectionEditor::DidFinishTextChange(const Position& new_base,
                                          const Position& new_extent) {
  if (new_base == selection_.base_ && new_extent == selection_.extent_) {
    DidFinishDOMMutation();
    return;
  }
  selection_.base_ = new_base;
  selection_.extent_ = new_extent;
  MarkCacheDirty();
  DidFinishDOMMutation();
}

void SelectionEditor::NodeWillBeRemoved(Node& node_to_be_removed) {
if (selection_.IsNone())
return;
const Position old_base = selection_.base_;
const Position old_extent = selection_.extent_;
const Position& new_base =
ComputePositionForNodeRemoval(old_base, node_to_be_removed);
const Position& new_extent =
ComputePositionForNodeRemoval(old_extent, node_to_be_removed);
if (new_base == old_base && new_extent == old_extent)
return;
selection_ = SelectionInDOMTree::Builder()
.SetBaseAndExtent(new_base, new_extent)
                   .SetIsHandleVisible(selection_.IsHandleVisible())
.Build();
MarkCacheDirty();
}

void Editor::ReplaceSelectionAfterDragging(DocumentFragment* fragment,
                                           InsertMode insert_mode,
                                           DragSourceType drag_source_type) {
  ReplaceSelectionCommand::CommandOptions options =
      ReplaceSelectionCommand::kSelectReplacement |
      ReplaceSelectionCommand::kPreventNesting;
  if (insert_mode == InsertMode::kSmart)
    options |= ReplaceSelectionCommand::kSmartReplace;
  if (drag_source_type == DragSourceType::kPlainTextSource)
    options |= ReplaceSelectionCommand::kMatchStyle;
  DCHECK(GetFrame().GetDocument());
  ReplaceSelectionCommand::Create(*GetFrame().GetDocument(), fragment, options,
                                  InputEvent::InputType::kInsertFromDrop)
      ->Apply();
}

Range* Editor::FindRangeOfString(const String& target,
                                 const EphemeralRangeInFlatTree& reference,
                                 FindOptions options) {
  return FindRangeOfStringAlgorithm<EditingInFlatTreeStrategy>(
      *GetFrame().GetDocument(), target, reference, options);
}

bool Editor::InsertParagraphSeparator() {
  if (!CanEdit())
    return false;

  if (!CanEditRichly())
    return InsertLineBreak();

  VisiblePosition caret =
      GetFrame().Selection().ComputeVisibleSelectionInDOMTree().VisibleStart();
  bool align_to_edge = IsEndOfEditableOrNonEditableContent(caret);
  DCHECK(GetFrame().GetDocument());
  EditingState editing_state;
  if (!TypingCommand::InsertParagraphSeparator(*GetFrame().GetDocument()))
    return false;
  RevealSelectionAfterEditingOperation(
      align_to_edge ? ScrollAlignment::kAlignToEdgeIfNeeded
                    : ScrollAlignment::kAlignCenterIfNeeded);

  return true;
}

void Editor::Copy(EditorCommandSource source) {
  if (TryDHTMLCopy())
    return;  // DHTML did the whole operation
  if (!CanCopy())
    return;

  GetFrame().GetDocument()->UpdateStyleAndLayoutIgnorePendingStylesheets();

  if (source == kCommandFromMenuOrKeyBinding &&
      !GetFrame().Selection().SelectionHasFocus())
    return;

  if (EnclosingTextControl(
          GetFrame().Selection().ComputeVisibleSelectionInDOMTree().Start())) {
    Pasteboard::GeneralPasteboard()->WritePlainText(
        GetFrame().SelectedTextForClipboard(),
        CanSmartCopyOrDelete() ? Pasteboard::kCanSmartReplace
                               : Pasteboard::kCannotSmartReplace);
  } else {
    Document* document = GetFrame().GetDocument();
    if (HTMLImageElement* image_element =
            ImageElementFromImageDocument(document))
      WriteImageNodeToPasteboard(Pasteboard::GeneralPasteboard(), image_element,
                                 document->title());
    else
      WriteSelectionToPasteboard();
  }
}

void showTree(const blink::FrameSelection& sel) {
  sel.ShowTreeForThis();
}

static int TextDistance(const PositionInFlatTree& start,
                        const PositionInFlatTree& end) {
  return TextIteratorInFlatTree::RangeLength(
      start, end,
      TextIteratorBehavior::AllVisiblePositionsRangeLengthBehavior());
}

TriState Editor::SelectionHasStyle(CSSPropertyID property_id,
                                   const String& value) const {
  return EditingStyle::Create(property_id, value)
      ->TriStateOfStyle(
          GetFrame().Selection().ComputeVisibleSelectionInDOMTreeDeprecated());
}

static Node* NonBoundaryShadowTreeRootNode(const Position& position) {
  return position.AnchorNode() && !position.AnchorNode()->IsShadowRoot()
             ? position.AnchorNode()->NonBoundaryShadowTreeRootNode()
             : nullptr;
}

void FrameSelection::NotifyEventHandlerForSelectionChange() {
  frame_->GetEventHandler().GetSelectionController().NotifySelectionChanged();
}

SelectionEditor::SelectionEditor(LocalFrame& frame) : frame_(frame) {
  ClearVisibleSelection();
}

static void WriteImageNodeToPasteboard(Pasteboard* pasteboard,
                                       Node* node,
                                       const String& title) {
  DCHECK(pasteboard);
  DCHECK(node);

  RefPtr<Image> image = ImageFromNode(*node);
  if (!image.Get())
    return;

  AtomicString url_string;
  if (isHTMLImageElement(*node) || isHTMLInputElement(*node))
    url_string = ToHTMLElement(node)->getAttribute(srcAttr);
  else if (isSVGImageElement(*node))
    url_string = ToSVGElement(node)->ImageSourceURL();
  else if (isHTMLEmbedElement(*node) || isHTMLObjectElement(*node) ||
           isHTMLCanvasElement(*node))
    url_string = ToHTMLElement(node)->ImageSourceURL();
  KURL url = url_string.IsEmpty()
                 ? KURL()
                 : node->GetDocument().CompleteURL(
                       StripLeadingAndTrailingHTMLSpaces(url_string));

  pasteboard->WriteImage(image.Get(), url, title);
}

bool IsLinkSelection(const MouseEventWithHitTestResults& event) {
  return (event.Event().GetModifiers() & WebInputEvent::Modifiers::kAltKey) !=
             0 &&
         event.IsOverLink();
}

bool Editor::CanEditRichly() const {
  return GetFrame()
      .Selection()
      .ComputeVisibleSelectionInDOMTreeDeprecated()
      .IsContentRichlyEditable();
}

bool SelectionController::UpdateSelectionForMouseDownDispatchingSelectStart(
    Node* target_node,
    const SelectionInFlatTree& selection,
    TextGranularity granularity,
    HandleVisibility handle_visibility) {
  if (target_node && target_node->GetLayoutObject() &&
      !target_node->GetLayoutObject()->IsSelectable())
    return false;

  const VisibleSelectionInFlatTree& visible_selection =
      CreateVisibleSelection(selection);

  if (DispatchSelectStart(target_node) != DispatchEventResult::kNotCanceled)
    return false;

  if (!this->Selection().IsAvailable())
    return false;

  if (!visible_selection.IsValidFor(this->Selection().GetDocument()))
    return false;

  if (visible_selection.IsRange()) {
    selection_state_ = SelectionState::kExtendedSelection;
    SetNonDirectionalSelectionIfNeeded(
        selection, granularity, kDoNotAdjustEndpoints, handle_visibility);

    return true;
  }

  selection_state_ = SelectionState::kPlacedCaret;
  SetNonDirectionalSelectionIfNeeded(selection, TextGranularity::kCharacter,
                                     kDoNotAdjustEndpoints, handle_visibility);
  return true;
}

Range* SelectionEditor::DocumentCachedRange() const {
  return cached_range_;
}

bool Editor::SelectionStartHasStyle(CSSPropertyID property_id,
                                    const String& value) const {
  EditingStyle* style_to_check = EditingStyle::Create(property_id, value);
  EditingStyle* style_at_start =
      EditingStyleUtilities::CreateStyleAtSelectionStart(
          GetFrame().Selection().ComputeVisibleSelectionInDOMTreeDeprecated(),
          property_id == CSSPropertyBackgroundColor, style_to_check->Style());
  return style_to_check->TriStateOfStyle(style_at_start);
}

void Editor::UnappliedEditing(UndoStep* cmd) {
  EventQueueScope scope;

  DispatchEditableContentChangedEvents(cmd->StartingRootEditableElement(),
                                       cmd->EndingRootEditableElement());
  DispatchInputEventEditableContentChanged(
      cmd->StartingRootEditableElement(), cmd->EndingRootEditableElement(),
      InputEvent::InputType::kHistoryUndo, g_null_atom,
      InputEvent::EventIsComposing::kNotComposing);

  const SelectionInDOMTree& new_selection = CorrectedSelectionAfterCommand(
      cmd->StartingSelection(), GetFrame().GetDocument());
  ChangeSelectionAfterCommand(new_selection,
                              SetSelectionData::Builder()
                                  .SetShouldCloseTyping(true)
                                  .SetShouldClearTypingStyle(true)
                                  .Build());

  last_edit_command_ = nullptr;
  undo_stack_->RegisterRedoStep(cmd);
  RespondToChangedContents(new_selection.Base());
}

FrameSelection& GranularityStrategyTest::Selection() const {
  return dummy_page_holder_->GetFrame().Selection();
}

void Editor::Paste(EditorCommandSource source) {
  DCHECK(GetFrame().GetDocument());
  if (TryDHTMLPaste(kAllMimeTypes))
    return;  // DHTML did the whole operation
  if (!CanPaste())
    return;

  GetFrame().GetDocument()->UpdateStyleAndLayoutIgnorePendingStylesheets();

  if (source == kCommandFromMenuOrKeyBinding &&
      !GetFrame().Selection().SelectionHasFocus())
    return;

  GetSpellChecker().UpdateMarkersForWordsAffectedByEditing(false);
  ResourceFetcher* loader = GetFrame().GetDocument()->Fetcher();
  ResourceCacheValidationSuppressor validation_suppressor(loader);

  const PasteMode paste_mode = CanEditRichly() ? kAllMimeTypes : kPlainTextOnly;

  if (source == kCommandFromMenuOrKeyBinding) {
    DataTransfer* data_transfer =
        DataTransfer::Create(DataTransfer::kCopyAndPaste, kDataTransferReadable,
                             DataObject::CreateFromPasteboard(paste_mode));

    if (DispatchBeforeInputDataTransfer(FindEventTargetFromSelection(),
                                        InputEvent::InputType::kInsertFromPaste,
                                        data_transfer) !=
        DispatchEventResult::kNotCanceled)
      return;
    if (frame_->GetDocument()->GetFrame() != frame_)
      return;
  }

  if (paste_mode == kAllMimeTypes)
    PasteWithPasteboard(Pasteboard::GeneralPasteboard());
  else
    PasteAsPlainTextWithPasteboard(Pasteboard::GeneralPasteboard());
}

void Editor::RegisterCommandGroup(CompositeEditCommand* command_group_wrapper) {
  DCHECK(command_group_wrapper->IsCommandGroupWrapper());
  last_edit_command_ = command_group_wrapper;
}

void Editor::PerformDelete() {
  if (!CanDelete())
    return;

  GetFrame().GetDocument()->UpdateStyleAndLayoutIgnorePendingStylesheets();

  AddToKillRing(SelectedRange());
  DeleteSelectionWithSmartDelete(
      CanSmartCopyOrDelete() ? DeleteMode::kSmart : DeleteMode::kSimple,
      InputEvent::InputType::kDeleteContentBackward);

  SetStartNewKillRingSequence(false);
}

void FrameSelection::SetSelection(const SelectionInDOMTree& selection) {
  SetSelection(selection, SetSelectionData::Builder()
                              .SetShouldCloseTyping(true)
                              .SetShouldClearTypingStyle(true)
                              .Build());
}

FrameSelection::ComputeVisibleSelectionInDOMTreeDeprecated() const {
  GetDocument().UpdateStyleAndLayoutIgnorePendingStylesheets();
  return ComputeVisibleSelectionInDOMTree();
}

Text* GranularityStrategyTest::AppendTextNode(const String& data) {
  Text* text = GetDocument().createTextNode(data);
  GetDocument().body()->AppendChild(text);
  return text;
}

bool Editor::CanSmartReplaceWithPasteboard(Pasteboard* pasteboard) {
  return SmartInsertDeleteEnabled() && pasteboard->CanSmartReplace();
}

void FrameSelection::LayoutBlockWillBeDestroyed(const LayoutBlock& block) {
  frame_caret_->LayoutBlockWillBeDestroyed(block);
}

void SelectionEditor::UpdateCachedVisibleSelectionInFlatTreeIfNeeded() const {
  DCHECK_GE(GetDocument().Lifecycle().GetState(),
            DocumentLifecycle::kAfterPerformLayout);
  AssertSelectionValid();
  if (!NeedsUpdateVisibleSelectionInFlatTree())
    return;
  style_version_for_flat_tree_ = GetDocument().StyleVersion();
  cached_visible_selection_in_flat_tree_is_dirty_ = false;
  SelectionInFlatTree::Builder builder;
  const PositionInFlatTree& base = ToPositionInFlatTree(selection_.Base());
  const PositionInFlatTree& extent = ToPositionInFlatTree(selection_.Extent());
  if (base.IsNotNull() && extent.IsNotNull())
    builder.SetBaseAndExtent(base, extent);
  else if (base.IsNotNull())
    builder.Collapse(base);
  else if (extent.IsNotNull())
    builder.Collapse(extent);
  builder.SetAffinity(selection_.Affinity())
      .SetIsDirectional(selection_.IsDirectional());
  cached_visible_selection_in_flat_tree_ =
      CreateVisibleSelection(builder.Build());
  if (!cached_visible_selection_in_flat_tree_.IsNone())
    return;
  style_version_for_dom_tree_ = GetDocument().StyleVersion();
  cached_visible_selection_in_dom_tree_is_dirty_ = false;
  cached_visible_selection_in_dom_tree_ = VisibleSelection();
}

Text* GranularityStrategyTest::SetupRotate(String str) {
  SetInnerHTML(
      "<html>"
      "<head>"
      "<style>"
      "div {"
      "transform: translate(0px,600px) rotate(90deg);"
      "}"
      "</style>"
      "</head>"
      "<body>"
      "<div id='mytext'></div>"
      "</body>"
      "</html>");

  Text* text = GetDocument().createTextNode(str);
  Element* div = GetDocument().getElementById("mytext");
  div->AppendChild(text);

  GetDocument().View()->UpdateAllLifecyclePhases();

  ParseText(text);
  return text;
}

void InputMethodController::CancelComposition() {
  if (!HasComposition())
    return;

  Editor::RevealSelectionScope reveal_selection_scope(&GetEditor());

  if (GetFrame()
          .Selection()
          .ComputeVisibleSelectionInDOMTreeDeprecated()
          .IsNone())
    return;

  Clear();

  InsertTextDuringCompositionWithEvents(
      GetFrame(), g_empty_string, 0,
      TypingCommand::TextCompositionType::kTextCompositionCancel);
  if (!IsAvailable())
    return;

  TypingCommand::CloseTyping(frame_);

  DispatchCompositionEndEvent(GetFrame(), g_empty_string);
}

PlainTextRange InputMethodController::CreateSelectionRangeForSetComposition(
    int selection_start,
    int selection_end,
    size_t text_length) const {
  const int selection_offsets_start =
      static_cast<int>(GetSelectionOffsets().Start());
  const int start = selection_offsets_start + selection_start;
  const int end = selection_offsets_start + selection_end;
  return CreateRangeForSelection(start, end, text_length);
}

void SelectionEditor::ClearVisibleSelection() {
  selection_ = SelectionInDOMTree();
  cached_visible_selection_in_dom_tree_ = VisibleSelection();
  cached_visible_selection_in_flat_tree_ = VisibleSelectionInFlatTree();
  cached_visible_selection_in_dom_tree_is_dirty_ = false;
  cached_visible_selection_in_flat_tree_is_dirty_ = false;
  if (!ShouldAlwaysUseDirectionalSelection())
    return;
  selection_.is_directional_ = true;
}

bool CanMouseDownStartSelect(Node* node) {
  if (!node || !node->GetLayoutObject())
    return true;

  if (!node->CanStartSelection())
    return false;

  return true;
}

void Editor::PasteAsPlainTextWithPasteboard(Pasteboard* pasteboard) {
  String text = pasteboard->PlainText();
  PasteAsPlainText(text, CanSmartReplaceWithPasteboard(pasteboard));
}

void InputMethodController::ContextDestroyed(Document*) {
  Clear();
  composition_range_ = nullptr;
}

static int ComputeAbsoluteCaretPosition(size_t text_start,
                                        size_t text_length,
                                        int relative_caret_position) {
  return text_start + text_length + relative_caret_position;
}

void Editor::RespondToChangedSelection(const Position& old_selection_start,
                                       TypingContinuation typing_continuation) {
  GetSpellChecker().RespondToChangedSelection(old_selection_start,
                                              typing_continuation);
  Client().RespondToChangedSelection(
      &GetFrame(), GetFrame().Selection().GetSelectionInDOMTree().Type());
  SetStartNewKillRingSequence(true);
}

void FrameSelection::DidLayout() {
  UpdateAppearance();
}

void DispatchCompositionUpdateEvent(LocalFrame& frame, const String& text) {
  Element* target = frame.GetDocument()->FocusedElement();
  if (!target)
    return;

  CompositionEvent* event = CompositionEvent::Create(
      EventTypeNames::compositionupdate, frame.DomWindow(), text);
  target->DispatchEvent(event);
}

bool SelectionController::HandlePasteGlobalSelection(
    const WebMouseEvent& mouse_event) {
  if (mouse_event.GetType() != WebInputEvent::kMouseUp)
    return false;

  if (!frame_->GetPage())
    return false;
  Frame* focus_frame =
      frame_->GetPage()->GetFocusController().FocusedOrMainFrame();
  if (frame_ == focus_frame &&
      frame_->GetEditor().Behavior().SupportsGlobalSelection())
    return frame_->GetEditor().CreateCommand("PasteGlobalSelection").Execute();

  return false;
}

SelectionController* SelectionController::Create(LocalFrame& frame) {
  return new SelectionController(frame);
}

void FrameSelection::ClearLayoutSelection() {
  layout_selection_->ClearSelection();
}

void FrameSelection::ScheduleVisualUpdateForPaintInvalidationIfNeeded() const {
  if (LocalFrameView* frame_view = frame_->View())
    frame_view->ScheduleVisualUpdateForPaintInvalidationIfNeeded();
}

void FrameSelection::NodeWillBeRemoved(Node& node) {
  if (!node.InActiveDocument())
    return;
  if (!GetDocument().IsRunningExecCommand())
    TypingCommand::CloseTyping(frame_);
}

bool Editor::DeleteWithDirection(DeleteDirection direction,
                                 TextGranularity granularity,
                                 bool kill_ring,
                                 bool is_typing_action) {
  if (!CanEdit())
    return false;

  EditingState editing_state;
  if (GetFrame()
          .Selection()
          .ComputeVisibleSelectionInDOMTreeDeprecated()
          .IsRange()) {
    if (is_typing_action) {
      DCHECK(GetFrame().GetDocument());
      TypingCommand::DeleteKeyPressed(
          *GetFrame().GetDocument(),
          CanSmartCopyOrDelete() ? TypingCommand::kSmartDelete : 0,
          granularity);
      RevealSelectionAfterEditingOperation();
    } else {
      if (kill_ring)
        AddToKillRing(SelectedRange());
      DeleteSelectionWithSmartDelete(
          CanSmartCopyOrDelete() ? DeleteMode::kSmart : DeleteMode::kSimple,
          DeletionInputTypeFromTextGranularity(direction, granularity));
    }
  } else {
    TypingCommand::Options options = 0;
    if (CanSmartCopyOrDelete())
      options |= TypingCommand::kSmartDelete;
    if (kill_ring)
      options |= TypingCommand::kKillRing;
    switch (direction) {
      case DeleteDirection::kForward:
        DCHECK(GetFrame().GetDocument());
        TypingCommand::ForwardDeleteKeyPressed(
            *GetFrame().GetDocument(), &editing_state, options, granularity);
        if (editing_state.IsAborted())
          return false;
        break;
      case DeleteDirection::kBackward:
        DCHECK(GetFrame().GetDocument());
        TypingCommand::DeleteKeyPressed(*GetFrame().GetDocument(), options,
                                        granularity);
        break;
    }
    RevealSelectionAfterEditingOperation();
  }

  if (kill_ring)
    SetStartNewKillRingSequence(false);

  return true;
}

bool FrameSelection::Modify(SelectionModifyAlteration alter,
                            SelectionModifyDirection direction,
                            TextGranularity granularity,
                            SetSelectionBy set_selection_by) {
  SelectionModifier selection_modifier(*GetFrame(),
                                       ComputeVisibleSelectionInDOMTree(),
                                       x_pos_for_vertical_arrow_navigation_);
  const bool modified =
      selection_modifier.Modify(alter, direction, granularity);
  if (set_selection_by == SetSelectionBy::kUser &&
      selection_modifier.Selection().IsRange() &&
      ComputeVisibleSelectionInDOMTree().IsCaret() &&
      DispatchSelectStart(ComputeVisibleSelectionInDOMTree()) !=
          DispatchEventResult::kNotCanceled) {
    return false;
  }
  if (!modified) {
    if (set_selection_by == SetSelectionBy::kSystem)
      return false;
    if (IsSpatialNavigationEnabled(frame_))
      return false;
    return true;
  }

  SetSelection(selection_modifier.Selection().AsSelection(),
               SetSelectionData::Builder()
                   .SetShouldCloseTyping(true)
                   .SetShouldClearTypingStyle(true)
                   .SetSetSelectionBy(set_selection_by)
                   .Build());

  if (granularity == TextGranularity::kLine ||
      granularity == TextGranularity::kParagraph)
    x_pos_for_vertical_arrow_navigation_ =
        selection_modifier.XPosForVerticalArrowNavigation();

  if (set_selection_by == SetSelectionBy::kUser)
    granularity_ = TextGranularity::kCharacter;

  ScheduleVisualUpdateForPaintInvalidationIfNeeded();

  return true;
}

bool SelectionEditor::NeedsUpdateVisibleSelection() const {
  return cached_visible_selection_in_dom_tree_is_dirty_ ||
         style_version_for_dom_tree_ != GetDocument().StyleVersion();
}

LayoutRect FrameSelection::UnclippedBounds() const {
  LocalFrameView* view = frame_->View();
  LayoutViewItem layout_view = frame_->ContentLayoutItem();

  if (!view || layout_view.IsNull())
    return LayoutRect();

  view->UpdateLifecycleToLayoutClean();
  return LayoutRect(layout_selection_->SelectionBounds());
}

bool InputMethodController::SetEditableSelectionOffsets(
    const PlainTextRange& selection_offsets,
    TypingContinuation typing_continuation) {
  if (!GetEditor().CanEdit())
    return false;
  return SetSelectionOffsets(selection_offsets, typing_continuation);
}

void GranularityStrategyTest::TestDirectionExpand() {
  Selection().MoveRangeSelectionExtent(letter_pos_[20]);
  EXPECT_EQ_SELECTED_TEXT("pq");
  Selection().MoveRangeSelectionExtent(letter_pos_[20]);
  EXPECT_EQ_SELECTED_TEXT("pq");
  Selection().MoveRangeSelectionExtent(letter_pos_[21]);
  EXPECT_EQ_SELECTED_TEXT("pqr");
  Selection().MoveRangeSelectionExtent(letter_pos_[22]);
  EXPECT_EQ_SELECTED_TEXT("pqr ");
  Selection().MoveRangeSelectionExtent(letter_pos_[24]);
  EXPECT_EQ_SELECTED_TEXT("pqr ");
  IntPoint p = word_middles_[4];
  p.Move(-1, 0);
  Selection().MoveRangeSelectionExtent(p);
  EXPECT_EQ_SELECTED_TEXT("pqr ");
  p.Move(1, 0);
  Selection().MoveRangeSelectionExtent(p);
  EXPECT_EQ_SELECTED_TEXT("pqr stuvwi");
  Selection().MoveRangeSelectionExtent(letter_pos_[27]);
  EXPECT_EQ_SELECTED_TEXT("pqr stuvwi");
  Selection().MoveRangeSelectionExtent(letter_pos_[28]);
  EXPECT_EQ_SELECTED_TEXT("pqr stuvwi");
  Selection().MoveRangeSelectionExtent(letter_pos_[29]);
  EXPECT_EQ_SELECTED_TEXT("pqr stuvwi ");
  int y = letter_pos_[29].Y();
  for (int x = letter_pos_[29].X() + 1; x < word_middles_[5].X(); x++) {
    Selection().MoveRangeSelectionExtent(IntPoint(x, y));
    Selection().MoveRangeSelectionExtent(IntPoint(x, y));
    EXPECT_EQ_SELECTED_TEXT("pqr stuvwi ");
  }
  Selection().MoveRangeSelectionExtent(word_middles_[5]);
  EXPECT_EQ_SELECTED_TEXT("pqr stuvwi inm");
  p = word_middles_[6];
  p.Move(-1, 0);
  Selection().MoveRangeSelectionExtent(p);
  EXPECT_EQ_SELECTED_TEXT("pqr stuvwi inm ");
  p.Move(1, 0);
  Selection().MoveRangeSelectionExtent(p);
  EXPECT_EQ_SELECTED_TEXT("pqr stuvwi inm mnii");
}

void GranularityStrategyTest::SetSelection(
    const VisibleSelection& new_selection) {
  dummy_page_holder_->GetFrame().Selection().SetSelection(
      new_selection.AsSelection());
}

Editor::RevealSelectionScope::RevealSelectionScope(Editor* editor)
    : editor_(editor) {
  ++editor_->prevent_reveal_selection_;
}

bool Editor::CanSmartCopyOrDelete() const {
  return SmartInsertDeleteEnabled() &&
         GetFrame().Selection().Granularity() == TextGranularity::kWord;
}

bool FrameSelection::IsHidden() const {
  if (SelectionHasFocus())
    return false;

  const Node* start =
      ComputeVisibleSelectionInDOMTree().Start().ComputeContainerNode();
  if (!start)
    return true;

  if (!GetSelectionInDOMTree().IsRange())
    return true;

  return EnclosingTextControl(start);
}

bool Editor::InsertTextWithoutSendingTextEvent(
    const String& text,
    bool select_inserted_text,
    TextEvent* triggering_event,
    InputEvent::InputType input_type) {
  const VisibleSelection& selection = SelectionForCommand(triggering_event);
  if (!selection.IsContentEditable())
    return false;

  GetSpellChecker().UpdateMarkersForWordsAffectedByEditing(
      !text.IsEmpty() && IsSpaceOrNewline(text[0]));

  TypingCommand::InsertText(
      *selection.Start().GetDocument(), text, selection.AsSelection(),
      select_inserted_text ? TypingCommand::kSelectInsertedText : 0,
      triggering_event && triggering_event->IsComposition()
          ? TypingCommand::kTextCompositionConfirm
          : TypingCommand::kTextCompositionNone,
      false, input_type);

  if (LocalFrame* edited_frame = selection.Start().GetDocument()->GetFrame()) {
    if (Page* page = edited_frame->GetPage()) {
      LocalFrame* focused_or_main_frame =
          ToLocalFrame(page->GetFocusController().FocusedOrMainFrame());
      focused_or_main_frame->Selection().RevealSelection(
          ScrollAlignment::kAlignCenterIfNeeded);
    }
  }

  return true;
}

void Editor::PasteAsPlainText(EditorCommandSource source) {
  if (TryDHTMLPaste(kPlainTextOnly))
    return;
  if (!CanPaste())
    return;

  GetFrame().GetDocument()->UpdateStyleAndLayoutIgnorePendingStylesheets();

  if (source == kCommandFromMenuOrKeyBinding &&
      !GetFrame().Selection().SelectionHasFocus())
    return;

  GetSpellChecker().UpdateMarkersForWordsAffectedByEditing(false);
  PasteAsPlainTextWithPasteboard(Pasteboard::GeneralPasteboard());
}

void SelectionController::SendContextMenuEvent(
    const MouseEventWithHitTestResults& mev,
    const LayoutPoint& position) {
  if (!Selection().IsAvailable())
    return;
  if (Selection().Contains(position) || mev.GetScrollbar() ||
      !(Selection()
            .ComputeVisibleSelectionInDOMTreeDeprecated()
            .IsContentEditable() ||
        (mev.InnerNode() && mev.InnerNode()->IsTextNode())))
    return;

  AutoReset<bool> mouse_down_may_start_select_change(
      &mouse_down_may_start_select_, true);

  if (mev.Event().menu_source_type != kMenuSourceTouchHandle &&
      HitTestResultIsMisspelled(mev.GetHitTestResult()))
    return SelectClosestMisspellingFromMouseEvent(mev);

  if (!frame_->GetEditor().Behavior().ShouldSelectOnContextualMenuClick())
    return;

  SelectClosestWordOrLinkFromMouseEvent(mev);
}

Range* FrameSelection::DocumentCachedRange() const {
  return selection_editor_->DocumentCachedRange();
}

void DispatchCompositionEndEvent(LocalFrame& frame, const String& text) {
  Element* target = frame.GetDocument()->FocusedElement();
  if (!target)
    return;

  CompositionEvent* event = CompositionEvent::Create(
      EventTypeNames::compositionend, frame.DomWindow(), text);
  target->DispatchEvent(event);
}

bool InputMethodController::ReplaceCompositionAndMoveCaret(
    const String& text,
    int relative_caret_position,
    const Vector<CompositionUnderline>& underlines) {
  Element* root_editable_element =
      GetFrame()
          .Selection()
          .ComputeVisibleSelectionInDOMTreeDeprecated()
          .RootEditableElement();
  if (!root_editable_element)
    return false;
  DCHECK(HasComposition());
  PlainTextRange composition_range =
      PlainTextRange::Create(*root_editable_element, *composition_range_);
  if (composition_range.IsNull())
    return false;
  int text_start = composition_range.Start();

  if (!ReplaceComposition(text))
    return false;

  GetDocument().UpdateStyleAndLayoutIgnorePendingStylesheets();

  AddCompositionUnderlines(underlines, root_editable_element, text_start);

  int absolute_caret_position = ComputeAbsoluteCaretPosition(
      text_start, text.length(), relative_caret_position);
  return MoveCaret(absolute_caret_position);
}

Text* GranularityStrategyTest::SetupTransform(String str) {
  SetInnerHTML(
      "<html>"
      "<head>"
      "<style>"
      "div {"
      "transform: scale(1,-1) translate(0,-100px);"
      "}"
      "</style>"
      "</head>"
      "<body>"
      "<div id='mytext'></div>"
      "</body>"
      "</html>");

  Text* text = GetDocument().createTextNode(str);
  Element* div = GetDocument().getElementById("mytext");
  div->AppendChild(text);

  GetDocument().View()->UpdateAllLifecyclePhases();

  ParseText(text);
  return text;
}

EphemeralRange InputMethodController::CompositionEphemeralRange() const {
  if (!HasComposition())
    return EphemeralRange();
  return EphemeralRange(composition_range_.Get());
}

bool Editor::CanDHTMLCut() {
  GetFrame().GetDocument()->UpdateStyleAndLayoutIgnorePendingStylesheets();
  return !IsInPasswordField(GetFrame()
                                .Selection()
                                .ComputeVisibleSelectionInDOMTree()
                                .Start()) &&
         !DispatchCPPEvent(EventTypeNames::beforecut, kDataTransferNumb);
}

void InputMethodController::ExtendSelectionAndDelete(int before, int after) {
  if (!GetEditor().CanEdit())
    return;
  PlainTextRange selection_offsets(GetSelectionOffsets());
  if (selection_offsets.IsNull())
    return;

  do {
    if (!SetSelectionOffsets(PlainTextRange(
            std::max(static_cast<int>(selection_offsets.Start()) - before, 0),
            selection_offsets.End() + after)))
      return;
    if (before == 0)
      break;
    ++before;
  } while (GetFrame()
                   .Selection()
                   .ComputeVisibleSelectionInDOMTreeDeprecated()
                   .Start() == GetFrame()
                                   .Selection()
                                   .ComputeVisibleSelectionInDOMTreeDeprecated()
                                   .End() &&
           before <= static_cast<int>(selection_offsets.Start()));
  Node* target = GetDocument().FocusedElement();
  if (target) {
    DispatchBeforeInputEditorCommand(
        target, InputEvent::InputType::kDeleteContentBackward,
        TargetRangesForInputEvent(*target));
  }
  TypingCommand::DeleteSelection(GetDocument());
}

bool InputMethodController::InsertTextAndMoveCaret(
    const String& text,
    int relative_caret_position,
    const Vector<CompositionUnderline>& underlines) {
  PlainTextRange selection_range = GetSelectionOffsets();
  if (selection_range.IsNull())
    return false;
  int text_start = selection_range.Start();

  if (!InsertText(text))
    return false;
  Element* root_editable_element =
      GetFrame()
          .Selection()
          .ComputeVisibleSelectionInDOMTreeDeprecated()
          .RootEditableElement();
  if (root_editable_element) {
    AddCompositionUnderlines(underlines, root_editable_element, text_start);
  }

  int absolute_caret_position = ComputeAbsoluteCaretPosition(
      text_start, text.length(), relative_caret_position);
  return MoveCaret(absolute_caret_position);
}

void SelectionController::PassMousePressEventToSubframe(
    const MouseEventWithHitTestResults& mev) {
  frame_->GetDocument()->UpdateStyleAndLayoutIgnorePendingStylesheets();

  IntPoint p = frame_->View()->RootFrameToContents(
      FlooredIntPoint(mev.Event().PositionInRootFrame()));
  if (!Selection().Contains(p))
    return;

  const VisiblePositionInFlatTree& visible_pos =
      VisiblePositionOfHitTestResult(mev.GetHitTestResult());
  if (visible_pos.IsNull()) {
    Selection().SetSelection(SelectionInDOMTree());
    return;
  }
  Selection().SetSelection(ConvertToSelectionInDOMTree(
      SelectionInFlatTree::Builder()
          .Collapse(visible_pos.ToPositionWithAffinity())
          .Build()));
}

bool SelectionController::SelectClosestWordFromHitTestResult(
    const HitTestResult& result,
    AppendTrailingWhitespace append_trailing_whitespace,
    SelectInputEventType select_input_event_type) {
  Node* const inner_node = result.InnerNode();

  if (!inner_node || !inner_node->GetLayoutObject() ||
      !inner_node->GetLayoutObject()->IsSelectable())
    return false;

  HitTestResult adjusted_hit_test_result = result;
  if (select_input_event_type == SelectInputEventType::kTouch &&
      result.GetImage())
    adjusted_hit_test_result.SetNodeAndPosition(result.InnerNode(),
                                                LayoutPoint(0, 0));

  const VisiblePositionInFlatTree& pos =
      VisiblePositionOfHitTestResult(adjusted_hit_test_result);
  const VisibleSelectionInFlatTree& new_selection =
      pos.IsNotNull() ? CreateVisibleSelectionWithGranularity(
                            SelectionInFlatTree::Builder()
                                .Collapse(pos.ToPositionWithAffinity())
                                .Build(),
                            TextGranularity::kWord)
                      : VisibleSelectionInFlatTree();

  HandleVisibility visibility = HandleVisibility::kNotVisible;
  if (select_input_event_type == SelectInputEventType::kTouch) {
    EphemeralRangeInFlatTree range(new_selection.Start(), new_selection.End());
    const String& str = PlainText(
        range,
        TextIteratorBehavior::Builder()
            .SetEmitsObjectReplacementCharacter(HasEditableStyle(*inner_node))
            .Build());
    if (str.IsEmpty() || str.SimplifyWhiteSpace().ContainsOnlyWhitespace())
      return false;

    if (new_selection.RootEditableElement() &&
        pos.DeepEquivalent() == VisiblePositionInFlatTree::LastPositionInNode(
                                    *new_selection.RootEditableElement())
                                    .DeepEquivalent())
      return false;

    visibility = HandleVisibility::kVisible;
  }

  const SelectionInFlatTree& adjusted_selection =
      append_trailing_whitespace == AppendTrailingWhitespace::kShouldAppend
          ? AdjustSelectionWithTrailingWhitespace(new_selection.AsSelection())
          : new_selection.AsSelection();

  return UpdateSelectionForMouseDownDispatchingSelectStart(
      inner_node,
      ExpandSelectionToRespectUserSelectAll(inner_node, adjusted_selection),
      TextGranularity::kWord, visibility);
}

bool InputMethodController::SetSelectionOffsets(
    const PlainTextRange& selection_offsets,
    TypingContinuation typing_continuation) {
  const EphemeralRange range = EphemeralRangeForOffsets(selection_offsets);
  if (range.IsNull())
    return false;

  GetFrame().Selection().SetSelection(
      SelectionInDOMTree::Builder().SetBaseAndExtent(range).Build(),
      SetSelectionData::Builder()
          .SetShouldCloseTyping(typing_continuation == TypingContinuation::kEnd)
          .Build());
  return true;
}

void Editor::CopyImage(const HitTestResult& result) {
  WriteImageNodeToPasteboard(Pasteboard::GeneralPasteboard(),
                             result.InnerNodeOrImageMapImage(),
                             result.AltDisplayString());
}

void Editor::Clear() {
  should_style_with_css_ = false;
  default_paragraph_separator_ = kEditorParagraphSeparatorIsDiv;
  last_edit_command_ = nullptr;
  undo_stack_->Clear();
}

std::pair<int, int> FrameSelection::LayoutSelectionStartEnd() {
  return layout_selection_->SelectionStartEnd();
}

void FrameSelection::SetFocusedNodeIfNeeded() {
  if (ComputeVisibleSelectionInDOMTreeDeprecated().IsNone() ||
      !FrameIsFocused())
    return;

  if (Element* target =
          ComputeVisibleSelectionInDOMTreeDeprecated().RootEditableElement()) {
    GetDocument().UpdateStyleAndLayoutTreeIgnorePendingStylesheets();
    while (target) {
      if (target->IsMouseFocusable() && !IsFrameElement(target)) {
        frame_->GetPage()->GetFocusController().SetFocusedElement(target,
                                                                  frame_);
        return;
      }
      target = target->ParentOrShadowHostElement();
    }
    GetDocument().ClearFocusedElement();
  }
}

bool Editor::FindString(const String& target, FindOptions options) {
  VisibleSelection selection =
      GetFrame().Selection().ComputeVisibleSelectionInDOMTreeDeprecated();

  Range* result_range = FindRangeOfString(
      target, EphemeralRange(selection.Start(), selection.End()),
      static_cast<FindOptions>(options | kFindAPICall));

  if (!result_range)
    return false;

  GetFrame().Selection().SetSelection(
      SelectionInDOMTree::Builder()
          .SetBaseAndExtent(EphemeralRange(result_range))
          .Build());
  GetFrame().Selection().RevealSelection();
  return true;
}

bool Editor::CanUndo() {
  return undo_stack_->CanUndo();
}

static HTMLImageElement* ImageElementFromImageDocument(Document* document) {
  if (!document)
    return 0;
  if (!document->IsImageDocument())
    return 0;

  HTMLElement* body = document->body();
  if (!body)
    return 0;

  Node* node = body->firstChild();
  if (!isHTMLImageElement(node))
    return 0;
  return toHTMLImageElement(node);
}

bool InputMethodController::SetEditableSelectionOffsets(
    const PlainTextRange& selection_offsets) {
  return SetEditableSelectionOffsets(selection_offsets,
                                     TypingContinuation::kEnd);
}

String FrameSelection::SelectedText() const {
  return SelectedText(TextIteratorBehavior());
}

const VisibleSelectionInFlatTree& FrameSelection::GetSelectionInFlatTree()
    const {
  return ComputeVisibleSelectionInFlatTree();
}

IntRect Editor::FirstRectForRange(const EphemeralRange& range) const {
  DCHECK(!GetFrame().GetDocument()->NeedsLayoutTreeUpdate());
  DocumentLifecycle::DisallowTransitionScope disallow_transition(
      GetFrame().GetDocument()->Lifecycle());

  LayoutUnit extra_width_to_end_of_line;
  DCHECK(range.IsNotNull());

  IntRect start_caret_rect =
      RenderedPosition(
          CreateVisiblePosition(range.StartPosition()).DeepEquivalent(),
          TextAffinity::kDownstream)
          .AbsoluteRect(&extra_width_to_end_of_line);
  if (start_caret_rect.IsEmpty())
    return IntRect();

  IntRect end_caret_rect =
      RenderedPosition(
          CreateVisiblePosition(range.EndPosition()).DeepEquivalent(),
          TextAffinity::kUpstream)
          .AbsoluteRect();
  if (end_caret_rect.IsEmpty())
    return IntRect();

  if (start_caret_rect.Y() == end_caret_rect.Y()) {
    return IntRect(
        std::min(start_caret_rect.X(), end_caret_rect.X()),
        start_caret_rect.Y(), abs(end_caret_rect.X() - start_caret_rect.X()),
        std::max(start_caret_rect.Height(), end_caret_rect.Height()));
  }

  return IntRect(
      start_caret_rect.X(), start_caret_rect.Y(),
      (start_caret_rect.Width() + extra_width_to_end_of_line).ToInt(),
      start_caret_rect.Height());
}

bool FrameSelection::ShouldShowBlockCursor() const {
  return frame_caret_->ShouldShowBlockCursor();
}

void InputMethodController::SelectComposition() const {
  const EphemeralRange range = CompositionEphemeralRange();
  if (range.IsNull())
    return;

  GetFrame().Selection().SetSelection(
      SelectionInDOMTree::Builder().SetBaseAndExtent(range).Build());
}

bool SelectionEditor::ShouldAlwaysUseDirectionalSelection() const {
  return GetFrame()
      ->GetEditor()
      .Behavior()
      .ShouldConsiderSelectionAsDirectional();
}

void FrameSelection::InvalidatePaint(const LayoutBlock& block,
                                     const PaintInvalidatorContext& context) {
  frame_caret_->InvalidatePaint(block, context);
}

void FrameSelection::NodeChildrenWillBeRemoved(ContainerNode& container) {
  if (!container.InActiveDocument())
    return;
  if (!GetDocument().IsRunningExecCommand())
    TypingCommand::CloseTyping(frame_);
}

static bool IsFrameElement(const Node* n) {
  if (!n)
    return false;
  LayoutObject* layout_object = n->GetLayoutObject();
  if (!layout_object || !layout_object->IsLayoutEmbeddedContent())
    return false;
  return ToLayoutEmbeddedContent(layout_object)->ChildFrameView();
}

VisibleSelection Editor::SelectionForCommand(Event* event) {
  VisibleSelection selection =
      GetFrame().Selection().ComputeVisibleSelectionInDOMTree();
  if (!event)
    return selection;
  TextControlElement* text_control_of_selection_start =
      EnclosingTextControl(selection.Start());
  TextControlElement* text_control_of_target =
      IsTextControlElement(*event->target()->ToNode())
          ? ToTextControlElement(event->target()->ToNode())
          : nullptr;
  if (text_control_of_target &&
      (selection.Start().IsNull() ||
       text_control_of_target != text_control_of_selection_start)) {
    const SelectionInDOMTree& select = text_control_of_target->Selection();
    if (!select.IsNone())
      return CreateVisibleSelection(select);
  }
  return selection;
}

bool SelectionController::HandleMouseReleaseEvent(
    const MouseEventWithHitTestResults& event,
    const LayoutPoint& drag_start_pos) {
  TRACE_EVENT0("blink", "SelectionController::handleMouseReleaseEvent");

  if (!Selection().IsAvailable())
    return false;

  bool handled = false;
  mouse_down_may_start_select_ = false;
  if (mouse_down_was_single_click_in_selection_ &&
      selection_state_ != SelectionState::kExtendedSelection &&
      drag_start_pos == FlooredIntPoint(event.Event().PositionInRootFrame()) &&
      Selection().ComputeVisibleSelectionInDOMTreeDeprecated().IsRange() &&
      event.Event().button != WebPointerProperties::Button::kRight) {
    frame_->GetDocument()->UpdateStyleAndLayoutIgnorePendingStylesheets();

    SelectionInFlatTree::Builder builder;
    Node* node = event.InnerNode();
    if (node && node->GetLayoutObject() && HasEditableStyle(*node)) {
      const VisiblePositionInFlatTree pos =
          VisiblePositionOfHitTestResult(event.GetHitTestResult());
      if (pos.IsNotNull())
        builder.Collapse(pos.ToPositionWithAffinity());
    }

    if (Selection().ComputeVisibleSelectionInFlatTree() !=
        CreateVisibleSelection(builder.Build())) {
      Selection().SetSelection(ConvertToSelectionInDOMTree(builder.Build()));
    }

    handled = true;
  }

  Selection().NotifyTextControlOfSelectionChange(SetSelectionBy::kUser);

  Selection().SelectFrameElementInParentIfFullySelected();

  if (event.Event().button == WebPointerProperties::Button::kMiddle &&
      !event.IsOverLink()) {
    handled = HandlePasteGlobalSelection(event.Event()) || handled;
  }

  return handled;
}

void SelectionController::UpdateSelectionForMouseDrag(
    Node* mouse_press_node,
    const LayoutPoint& drag_start_pos,
    const IntPoint& last_known_mouse_position) {
  LocalFrameView* view = frame_->View();
  if (!view)
    return;
  LayoutViewItem layout_item = frame_->ContentLayoutItem();
  if (layout_item.IsNull())
    return;

  HitTestRequest request(HitTestRequest::kReadOnly | HitTestRequest::kActive |
                         HitTestRequest::kMove);
  HitTestResult result(request,
                       view->RootFrameToContents(last_known_mouse_position));
  layout_item.HitTest(result);
  UpdateSelectionForMouseDrag(result, mouse_press_node, drag_start_pos,
                              last_known_mouse_position);
}

void SelectionController::NotifySelectionChanged() {
  DocumentLifecycle::DisallowTransitionScope disallow_transition(
      frame_->GetDocument()->Lifecycle());

  const SelectionInDOMTree& selection =
      this->Selection().GetSelectionInDOMTree();
  switch (selection.Type()) {
    case kNoSelection:
      selection_state_ = SelectionState::kHaveNotStartedSelection;
      return;
    case kCaretSelection:
      selection_state_ = SelectionState::kPlacedCaret;
      return;
    case kRangeSelection:
      selection_state_ = SelectionState::kExtendedSelection;
      return;
  }
  NOTREACHED() << "We should handle all SelectionType" << selection;
}

void SelectionController::HandleGestureLongTap(
    const GestureEventWithHitTestResults& targeted_event) {
  TRACE_EVENT0("blink", "SelectionController::handleGestureLongTap");

  SetCaretAtHitTestResult(targeted_event.GetHitTestResult());
}

void SelectionEditor::CacheRangeOfDocument(Range* range) {
  cached_range_ = range;
}

FrameSelection& SelectionController::Selection() const {
  return frame_->Selection();
}

void SelectionEditor::UpdateCachedVisibleSelectionIfNeeded() const {
  DCHECK_GE(GetDocument().Lifecycle().GetState(),
            DocumentLifecycle::kAfterPerformLayout);
  AssertSelectionValid();
  if (!NeedsUpdateVisibleSelection())
    return;
  style_version_for_dom_tree_ = GetDocument().StyleVersion();
  cached_visible_selection_in_dom_tree_is_dirty_ = false;
  cached_visible_selection_in_dom_tree_ = CreateVisibleSelection(selection_);
  if (!cached_visible_selection_in_dom_tree_.IsNone())
    return;
  style_version_for_flat_tree_ = GetDocument().StyleVersion();
  cached_visible_selection_in_flat_tree_is_dirty_ = false;
  cached_visible_selection_in_flat_tree_ = VisibleSelectionInFlatTree();
}

Editor::Editor(LocalFrame& frame)
    : frame_(&frame),
      undo_stack_(UndoStack::Create()),
      prevent_reveal_selection_(0),
      should_start_new_kill_ring_sequence_(false),
      should_style_with_css_(false),
      kill_ring_(WTF::WrapUnique(new KillRing)),
      are_marked_text_matches_highlighted_(false),
      default_paragraph_separator_(kEditorParagraphSeparatorIsDiv),
      overwrite_mode_enabled_(false) {}

Range* InputMethodController::CompositionRange() const {
  return HasComposition() ? composition_range_ : nullptr;
}

void Editor::ApplyStyleToSelection(StylePropertySet* style,
                                   InputEvent::InputType input_type) {
  if (!style || style->IsEmpty() || !CanEditRichly())
    return;

  ApplyStyle(style, input_type);
}

void FrameSelection::SetCaretBlinkingSuspended(bool suspended) {
  frame_caret_->SetCaretBlinkingSuspended(suspended);
}

WebTextInputMode InputMethodController::InputModeOfFocusedElement() const {
  if (!RuntimeEnabledFeatures::InputModeAttributeEnabled())
    return kWebTextInputModeDefault;

  AtomicString mode = GetInputModeAttribute(GetDocument().FocusedElement());

  if (mode.IsEmpty())
    return kWebTextInputModeDefault;
  if (mode == InputModeNames::verbatim)
    return kWebTextInputModeVerbatim;
  if (mode == InputModeNames::latin)
    return kWebTextInputModeLatin;
  if (mode == InputModeNames::latin_name)
    return kWebTextInputModeLatinName;
  if (mode == InputModeNames::latin_prose)
    return kWebTextInputModeLatinProse;
  if (mode == InputModeNames::full_width_latin)
    return kWebTextInputModeFullWidthLatin;
  if (mode == InputModeNames::kana)
    return kWebTextInputModeKana;
  if (mode == InputModeNames::kana_name)
    return kWebTextInputModeKanaName;
  if (mode == InputModeNames::katakana)
    return kWebTextInputModeKataKana;
  if (mode == InputModeNames::numeric)
    return kWebTextInputModeNumeric;
  if (mode == InputModeNames::tel)
    return kWebTextInputModeTel;
  if (mode == InputModeNames::email)
    return kWebTextInputModeEmail;
  if (mode == InputModeNames::url)
    return kWebTextInputModeUrl;
  return kWebTextInputModeDefault;
}

base::Optional<int> FrameSelection::LayoutSelectionStart() const {
  return layout_selection_->SelectionStart();
}

void InputMethodController::SetComposition(
    const String& text,
    const Vector<CompositionUnderline>& underlines,
    int selection_start,
    int selection_end) {
  Editor::RevealSelectionScope reveal_selection_scope(&GetEditor());

  GetDocument().UpdateStyleAndLayoutTree();

  SelectComposition();

  if (GetFrame()
          .Selection()
          .ComputeVisibleSelectionInDOMTreeDeprecated()
          .IsNone())
    return;

  Element* target = GetDocument().FocusedElement();
  if (!target)
    return;

  GetDocument().UpdateStyleAndLayoutIgnorePendingStylesheets();

  PlainTextRange selected_range = CreateSelectionRangeForSetComposition(
      selection_start, selection_end, text.length());

  if (text.IsEmpty()) {
    if (HasComposition()) {
      Editor::RevealSelectionScope reveal_selection_scope(&GetEditor());
      ReplaceComposition(g_empty_string);
    } else {
      TypingCommand::DeleteSelection(GetDocument(),
                                     TypingCommand::kPreventSpellChecking);
    }

    GetDocument().UpdateStyleAndLayoutIgnorePendingStylesheets();

    SetEditableSelectionOffsets(selected_range);
    return;
  }

  if (!HasComposition()) {
    target->DispatchEvent(CompositionEvent::Create(
        EventTypeNames::compositionstart, GetFrame().DomWindow(),
        GetFrame().SelectedText()));
    if (!IsAvailable())
      return;
  }

  DCHECK(!text.IsEmpty());

  Clear();

  InsertTextDuringCompositionWithEvents(
      GetFrame(), text,
      TypingCommand::kSelectInsertedText | TypingCommand::kPreventSpellChecking,
      TypingCommand::kTextCompositionUpdate);
  if (!IsAvailable())
    return;

  GetDocument().UpdateStyleAndLayoutIgnorePendingStylesheets();

  Position base = MostForwardCaretPosition(
      GetFrame().Selection().ComputeVisibleSelectionInDOMTree().Base());
  Node* base_node = base.AnchorNode();
  if (!base_node || !base_node->IsTextNode())
    return;

  Position extent =
      GetFrame().Selection().ComputeVisibleSelectionInDOMTree().Extent();
  Node* extent_node = extent.AnchorNode();

  unsigned extent_offset = extent.ComputeOffsetInContainerNode();
  unsigned base_offset = base.ComputeOffsetInContainerNode();

  has_composition_ = true;
  if (!composition_range_)
    composition_range_ = Range::Create(GetDocument());
  composition_range_->setStart(base_node, base_offset);
  composition_range_->setEnd(extent_node, extent_offset);

  if (base_node->GetLayoutObject())
    base_node->GetLayoutObject()->SetShouldDoFullPaintInvalidation();

  GetDocument().UpdateStyleAndLayoutIgnorePendingStylesheets();

  SetEditableSelectionOffsets(selected_range, TypingContinuation::kContinue);

  if (underlines.IsEmpty()) {
    GetDocument().Markers().AddCompositionMarker(
        EphemeralRange(composition_range_), Color::kBlack,
        StyleableMarker::Thickness::kThin,
        LayoutTheme::GetTheme().PlatformDefaultCompositionBackgroundColor());
    return;
  }

  const PlainTextRange composition_plain_text_range =
      PlainTextRange::Create(*base_node->parentNode(), *composition_range_);
  AddCompositionUnderlines(underlines, base_node->parentNode(),
                           composition_plain_text_range.Start());
}

void SelectionController::SetMouseDownMayStartSelect(bool may_start_select) {
  mouse_down_may_start_select_ = may_start_select;
}

void GranularityStrategyTest::SetUp() {
  dummy_page_holder_ = DummyPageHolder::Create(IntSize(800, 600));
  document_ = &dummy_page_holder_->GetDocument();
  DCHECK(document_);
  GetDummyPageHolder().GetFrame().GetSettings()->SetDefaultFontSize(12);
  GetDummyPageHolder().GetFrame().GetSettings()->SetSelectionStrategy(
      SelectionStrategy::kDirection);
}

EditingBehavior Editor::Behavior() const {
  if (!GetFrame().GetSettings())
    return EditingBehavior(kEditingMacBehavior);

  return EditingBehavior(GetFrame().GetSettings()->GetEditingBehaviorType());
}

IntRect FrameSelection::ComputeRectToScroll(
    RevealExtentOption reveal_extent_option) {
  const VisibleSelection& selection = ComputeVisibleSelectionInDOMTree();
  if (selection.IsCaret())
    return AbsoluteCaretBounds();
  DCHECK(selection.IsRange());
  if (reveal_extent_option == kRevealExtent)
    return AbsoluteCaretBoundsOf(CreateVisiblePosition(selection.Extent()));
  layout_selection_->SetHasPendingSelection();
  return layout_selection_->SelectionBounds();
}

void SelectionEditor::DocumentAttached(Document* document) {
  DCHECK(document);
  DCHECK(!LifecycleContext()) << LifecycleContext();
  style_version_for_dom_tree_ = static_cast<uint64_t>(-1);
  style_version_for_flat_tree_ = static_cast<uint64_t>(-1);
  ClearVisibleSelection();
  SetContext(document);
}

  DummyPageHolder& GetDummyPageHolder() const { return *dummy_page_holder_; }

  int LayoutCount() const {
    return dummy_page_holder_->GetFrameView().LayoutCount();
  }

int CalculateAfterDeletionLengthsInCodePoints(
    const String& text,
    const int after_length_in_code_points,
    const int selection_end) {
  DCHECK_GE(after_length_in_code_points, 0);
  DCHECK_GE(selection_end, 0);
  const int length = text.length();
  DCHECK_LE(selection_end, length);

  const UChar* u_text = text.Characters16();
  ForwardCodePointStateMachine forward_machine;
  int counter = after_length_in_code_points;
  int deletion_end = selection_end;
  while (counter > 0 && deletion_end < length) {
    const TextSegmentationMachineState state =
        forward_machine.FeedFollowingCodeUnit(u_text[deletion_end]);
    if (state == TextSegmentationMachineState::kInvalid)
      return kInvalidDeletionLength;

    if (forward_machine.AtCodePointBoundary())
      --counter;
    ++deletion_end;
  }
  if (!forward_machine.AtCodePointBoundary())
    return kInvalidDeletionLength;

  const int offset = forward_machine.GetBoundaryOffset();
  DCHECK_EQ(offset, deletion_end - selection_end);
  return offset;
}

void FrameSelection::SetUseSecureKeyboardEntry(bool enable) {
  if (enable)
    EnableSecureTextInput();
  else
    DisableSecureTextInput();
}

void FrameSelection::CacheRangeOfDocument(Range* range) {
  selection_editor_->CacheRangeOfDocument(range);
}

EphemeralRange InputMethodController::EphemeralRangeForOffsets(
    const PlainTextRange& offsets) const {
  if (offsets.IsNull())
    return EphemeralRange();
  Element* root_editable_element =
      GetFrame()
          .Selection()
          .ComputeVisibleSelectionInDOMTreeDeprecated()
          .RootEditableElement();
  if (!root_editable_element)
    return EphemeralRange();

  DCHECK(!GetDocument().NeedsLayoutTreeUpdate());

  return offsets.CreateRange(*root_editable_element);
}

static Range* FindRangeOfStringAlgorithm(
    Document& document,
    const String& target,
    const EphemeralRangeTemplate<Strategy>& reference_range,
    FindOptions options) {
  if (target.IsEmpty())
    return nullptr;

  EphemeralRangeTemplate<Strategy> document_range =
      EphemeralRangeTemplate<Strategy>::RangeOfContents(document);
  EphemeralRangeTemplate<Strategy> search_range(document_range);

  bool forward = !(options & kBackwards);
  bool start_in_reference_range = false;
  if (reference_range.IsNotNull()) {
    start_in_reference_range = options & kStartInSelection;
    if (forward && start_in_reference_range)
      search_range = EphemeralRangeTemplate<Strategy>(
          reference_range.StartPosition(), document_range.EndPosition());
    else if (forward)
      search_range = EphemeralRangeTemplate<Strategy>(
          reference_range.EndPosition(), document_range.EndPosition());
    else if (start_in_reference_range)
      search_range = EphemeralRangeTemplate<Strategy>(
          document_range.StartPosition(), reference_range.EndPosition());
    else
      search_range = EphemeralRangeTemplate<Strategy>(
          document_range.StartPosition(), reference_range.StartPosition());
  }

  Range* result_range =
      FindStringBetweenPositions(target, search_range, options);

  if (result_range && start_in_reference_range &&
      NormalizeRange(EphemeralRangeTemplate<Strategy>(result_range)) ==
          reference_range) {
    if (forward)
      search_range = EphemeralRangeTemplate<Strategy>(
          FromPositionInDOMTree<Strategy>(result_range->EndPosition()),
          search_range.EndPosition());
    else
      search_range = EphemeralRangeTemplate<Strategy>(
          search_range.StartPosition(),
          FromPositionInDOMTree<Strategy>(result_range->StartPosition()));
    result_range = FindStringBetweenPositions(target, search_range, options);
  }

  if (!result_range && options & kWrapAround)
    return FindStringBetweenPositions(target, document_range, options);

  return result_range;
}

bool Editor::CanDeleteRange(const EphemeralRange& range) const {
  if (range.IsCollapsed())
    return false;

  Node* start_container = range.StartPosition().ComputeContainerNode();
  Node* end_container = range.EndPosition().ComputeContainerNode();
  if (!start_container || !end_container)
    return false;

  return HasEditableStyle(*start_container) && HasEditableStyle(*end_container);
}

bool FrameSelection::IsCaretBlinkingSuspended() const {
  return frame_caret_->IsCaretBlinkingSuspended();
}

void SelectionEditor::Dispose() {
  ClearDocumentCachedRange();
  ClearVisibleSelection();
}

void Editor::ToggleOverwriteModeEnabled() {
  overwrite_mode_enabled_ = !overwrite_mode_enabled_;
  GetFrame().Selection().SetShouldShowBlockCursor(overwrite_mode_enabled_);
}

static RefPtr<Image> ImageFromNode(const Node& node) {
  DCHECK(!node.GetDocument().NeedsLayoutTreeUpdate());
  DocumentLifecycle::DisallowTransitionScope disallow_transition(
      node.GetDocument().Lifecycle());

  LayoutObject* layout_object = node.GetLayoutObject();
  if (!layout_object)
    return nullptr;

  if (layout_object->IsCanvas()) {
    return toHTMLCanvasElement(const_cast<Node&>(node))
        .CopiedImage(kFrontBuffer, kPreferNoAcceleration,
                     kSnapshotReasonCopyToClipboard);
  }

  if (layout_object->IsImage()) {
    LayoutImage* layout_image = ToLayoutImage(layout_object);
    if (!layout_image)
      return nullptr;

    ImageResourceContent* cached_image = layout_image->CachedImage();
    if (!cached_image || cached_image->ErrorOccurred())
      return nullptr;
    return cached_image->GetImage();
  }

  return nullptr;
}

void GranularityStrategyTest::SetupTextSpan(String str1,
                                            String str2,
                                            String str3,
                                            size_t sel_begin,
                                            size_t sel_end) {
  Text* text1 = GetDocument().createTextNode(str1);
  Text* text2 = GetDocument().createTextNode(str2);
  Text* text3 = GetDocument().createTextNode(str3);
  Element* span = HTMLSpanElement::Create(GetDocument());
  Element* div = GetDocument().getElementById("mytext");
  div->AppendChild(text1);
  div->AppendChild(span);
  span->AppendChild(text2);
  div->AppendChild(text3);

  GetDocument().View()->UpdateAllLifecyclePhases();

  Vector<IntPoint> letter_pos;
  Vector<IntPoint> word_middle_pos;

  TextNodeVector text_nodes;
  text_nodes.push_back(text1);
  text_nodes.push_back(text2);
  text_nodes.push_back(text3);
  ParseText(text_nodes);

  Position p1;
  Position p2;
  if (sel_begin < str1.length())
    p1 = Position(text1, sel_begin);
  else if (sel_begin < str1.length() + str2.length())
    p1 = Position(text2, sel_begin - str1.length());
  else
    p1 = Position(text3, sel_begin - str1.length() - str2.length());
  if (sel_end < str1.length())
    p2 = Position(text1, sel_end);
  else if (sel_end < str1.length() + str2.length())
    p2 = Position(text2, sel_end - str1.length());
  else
    p2 = Position(text3, sel_end - str1.length() - str2.length());

  Selection().SetSelection(
      SelectionInDOMTree::Builder().SetBaseAndExtent(p1, p2).Build());
}

IntPoint VisiblePositionToContentsPoint(const VisiblePosition& pos) {
  IntPoint result = AbsoluteSelectionBoundsOf(pos).MinXMaxYCorner();
  result.Move(0, -1);
  return result;
}

bool Editor::TryDHTMLPaste(PasteMode paste_mode) {
  return !DispatchCPPEvent(EventTypeNames::paste, kDataTransferReadable,
                           paste_mode);
}

String InputMethodController::ComposingText() const {
  DocumentLifecycle::DisallowTransitionScope disallow_transition(
      GetDocument().Lifecycle());
  return PlainText(
      CompositionEphemeralRange(),
      TextIteratorBehavior::Builder().SetEmitsOriginalText(true).Build());
}

void Editor::ReplaceSelection(const String& text) {
  DCHECK(!GetFrame().GetDocument()->NeedsLayoutTreeUpdate());
  bool select_replacement = Behavior().ShouldSelectReplacement();
  bool smart_replace = true;
  ReplaceSelectionWithText(text, select_replacement, smart_replace,
                           InputEvent::InputType::kInsertReplacementText);
}

void Editor::ReplaceSelectionWithText(const String& text,
                                      bool select_replacement,
                                      bool smart_replace,
                                      InputEvent::InputType input_type) {
  ReplaceSelectionWithFragment(CreateFragmentFromText(SelectedRange(), text),
                               select_replacement, smart_replace, true,
                               input_type);
}

String FrameSelection::SelectedText(
    const TextIteratorBehavior& behavior) const {
  return ExtractSelectedText(*this, behavior);
}

void GranularityStrategyTest::TestDirectionShrink() {
  Selection().MoveRangeSelectionExtent(word_middles_[4]);
  EXPECT_EQ_SELECTED_TEXT("pqr iiinmni");
  IntPoint p = word_middles_[4];
  p.Move(letter_pos_[28].X() - letter_pos_[29].X(), 0);
  Selection().MoveRangeSelectionExtent(p);
  EXPECT_EQ_SELECTED_TEXT("pqr iiinmn");
  p.Move(letter_pos_[27].X() - letter_pos_[28].X(), 0);
  Selection().MoveRangeSelectionExtent(p);
  EXPECT_EQ_SELECTED_TEXT("pqr iiinm");
  p.Move(letter_pos_[26].X() - letter_pos_[27].X(), 0);
  Selection().MoveRangeSelectionExtent(p);
  EXPECT_EQ_SELECTED_TEXT("pqr iiin");
  p.Move(letter_pos_[27].X() - letter_pos_[26].X(), 0);
  Selection().MoveRangeSelectionExtent(p);
  EXPECT_EQ_SELECTED_TEXT("pqr iiin");
  p.Move(letter_pos_[25].X() - letter_pos_[26].X(), 0);
  Selection().MoveRangeSelectionExtent(p);
  EXPECT_EQ_SELECTED_TEXT("pqr iii");
  p.Move(letter_pos_[24].X() - letter_pos_[25].X(), 0);
  Selection().MoveRangeSelectionExtent(p);
  EXPECT_EQ_SELECTED_TEXT("pqr ii");
  Selection().MoveRangeSelectionExtent(letter_pos_[24]);
  EXPECT_EQ_SELECTED_TEXT("pqr ii");
  Selection().MoveRangeSelectionExtent(letter_pos_[25]);
  EXPECT_EQ_SELECTED_TEXT("pqr iii");

  Selection().MoveRangeSelectionExtent(letter_pos_[22]);
  EXPECT_EQ_SELECTED_TEXT("pqr ");
  p = letter_pos_[22];
  p.Move(1, 0);
  Selection().MoveRangeSelectionExtent(p);
  EXPECT_EQ_SELECTED_TEXT("pqr ");
  Selection().MoveRangeSelectionExtent(letter_pos_[23]);
  EXPECT_EQ_SELECTED_TEXT("pqr i");
}

DEFINE_TRACE(Editor) {
  visitor->Trace(frame_);
  visitor->Trace(last_edit_command_);
  visitor->Trace(undo_stack_);
  visitor->Trace(mark_);
  visitor->Trace(typing_style_);
}

SelectionEditor::ComputeVisibleSelectionInFlatTree() const {
  DCHECK_EQ(GetFrame()->GetDocument(), GetDocument());
  DCHECK_EQ(GetFrame(), GetDocument().GetFrame());
  UpdateCachedVisibleSelectionInFlatTreeIfNeeded();
  if (cached_visible_selection_in_flat_tree_.IsNone())
    return cached_visible_selection_in_flat_tree_;
  DCHECK_EQ(cached_visible_selection_in_flat_tree_.Base().GetDocument(),
            GetDocument());
  return cached_visible_selection_in_flat_tree_;
}

void SelectionEditor::MarkCacheDirty() {
  if (!cached_visible_selection_in_dom_tree_is_dirty_) {
    cached_visible_selection_in_dom_tree_ = VisibleSelection();
    cached_visible_selection_in_dom_tree_is_dirty_ = true;
  }
  if (!cached_visible_selection_in_flat_tree_is_dirty_) {
    cached_visible_selection_in_flat_tree_ = VisibleSelectionInFlatTree();
    cached_visible_selection_in_flat_tree_is_dirty_ = true;
  }
}

bool Editor::IsSelectTrailingWhitespaceEnabled() const {
  if (Settings* settings = GetFrame().GetSettings())
    return settings->GetSelectTrailingWhitespaceEnabled();
  return false;
}

  int LayoutCount() const {
    return GetDummyPageHolder().GetFrameView().LayoutCount();
  }

bool Editor::CanPaste() const {
  return CanEdit();
}

bool IsExtendingSelection(const MouseEventWithHitTestResults& event) {
  bool is_mouse_down_on_link_or_image =
      event.IsOverLink() || event.GetHitTestResult().GetImage();
  return (event.Event().GetModifiers() & WebInputEvent::Modifiers::kShiftKey) !=
             0 &&
         !is_mouse_down_on_link_or_image;
}

  LocalFrame& GetFrame() const { return dummy_page_holder_->GetFrame(); }

void FrameSelection::SelectFrameElementInParentIfFullySelected() {
  Frame* parent = frame_->Tree().Parent();
  if (!parent)
    return;
  Page* page = frame_->GetPage();
  if (!page)
    return;

  if (GetSelectionInDOMTree().Type() != kRangeSelection) {
    return;
  }

  GetDocument().UpdateStyleAndLayoutIgnorePendingStylesheets();

  if (!IsStartOfDocument(ComputeVisibleSelectionInDOMTree().VisibleStart()))
    return;
  if (!IsEndOfDocument(ComputeVisibleSelectionInDOMTree().VisibleEnd()))
    return;

  if (!parent->IsLocalFrame())
    return;

  HTMLFrameOwnerElement* owner_element = frame_->DeprecatedLocalOwner();
  if (!owner_element)
    return;
  ContainerNode* owner_element_parent = owner_element->parentNode();
  if (!owner_element_parent)
    return;

  owner_element_parent->GetDocument()
      .UpdateStyleAndLayoutIgnorePendingStylesheets();

  if (!blink::HasEditableStyle(*owner_element_parent))
    return;

  unsigned owner_element_node_index = owner_element->NodeIndex();
  VisiblePosition before_owner_element = CreateVisiblePosition(
      Position(owner_element_parent, owner_element_node_index));
  VisiblePosition after_owner_element = CreateVisiblePosition(
      Position(owner_element_parent, owner_element_node_index + 1),
      VP_UPSTREAM_IF_POSSIBLE);

  SelectionInDOMTree::Builder builder;
  builder
      .SetBaseAndExtentDeprecated(before_owner_element.DeepEquivalent(),
                                  after_owner_element.DeepEquivalent())
      .SetAffinity(before_owner_element.Affinity());

  VisibleSelection new_selection = CreateVisibleSelection(builder.Build());
  page->GetFocusController().SetFocusedFrame(parent);
  if (new_selection.IsNonOrphanedCaretOrRange())
    ToLocalFrame(parent)->Selection().SetSelection(new_selection.AsSelection());
}

bool SelectionController::HandleTripleClick(
    const MouseEventWithHitTestResults& event) {
  TRACE_EVENT0("blink",
               "SelectionController::handleMousePressEventTripleClick");

  if (!Selection().IsAvailable()) {
    return false;
  }

  if (!mouse_down_allows_multi_click_)
    return HandleSingleClick(event);

  if (event.Event().button != WebPointerProperties::Button::kLeft)
    return false;

  Node* const inner_node = event.InnerNode();
  if (!(inner_node && inner_node->GetLayoutObject() &&
        mouse_down_may_start_select_))
    return false;

  const VisiblePositionInFlatTree& pos =
      VisiblePositionOfHitTestResult(event.GetHitTestResult());
  const VisibleSelectionInFlatTree new_selection =
      pos.IsNotNull() ? CreateVisibleSelectionWithGranularity(
                            SelectionInFlatTree::Builder()
                                .Collapse(pos.ToPositionWithAffinity())
                                .Build(),
                            TextGranularity::kParagraph)
                      : VisibleSelectionInFlatTree();

  const bool is_handle_visible =
      event.Event().FromTouch() && new_selection.IsRange();

  const bool did_select = UpdateSelectionForMouseDownDispatchingSelectStart(
      inner_node,
      ExpandSelectionToRespectUserSelectAll(inner_node,
                                            new_selection.AsSelection()),
      TextGranularity::kParagraph,
      is_handle_visible ? HandleVisibility::kVisible
                        : HandleVisibility::kNotVisible);
  if (!did_select)
    return false;

  if (!Selection().IsHandleVisible())
    return true;
  frame_->GetEventHandler().ShowNonLocatedContextMenu(nullptr,
                                                      kMenuSourceTouch);
  return true;
}

bool FrameSelection::NeedsLayoutSelectionUpdate() const {
  return layout_selection_->HasPendingSelection();
}

static SelectionInFlatTree ExtendSelectionAsDirectional(
    const PositionInFlatTree& position,
    const VisibleSelectionInFlatTree& selection,
    TextGranularity granularity) {
  DCHECK(!selection.IsNone());
  DCHECK(position.IsNotNull());
  const PositionInFlatTree& start = selection.Start();
  const PositionInFlatTree& end = selection.End();
  const PositionInFlatTree& base = selection.IsBaseFirst() ? start : end;
  if (position < base) {
    const PositionInFlatTree& new_start = ComputeStartRespectingGranularity(
        PositionInFlatTreeWithAffinity(position), granularity);
    const PositionInFlatTree& new_end =
        selection.IsBaseFirst()
            ? ComputeEndRespectingGranularity(
                  new_start, PositionInFlatTreeWithAffinity(start), granularity)
            : end;
    return SelectionInFlatTree::Builder()
        .SetBaseAndExtent(new_end, new_start)
        .Build();
  }

  const PositionInFlatTree& new_start =
      selection.IsBaseFirst()
          ? start
          : ComputeStartFromEndForExtendForward(end, granularity);
  const PositionInFlatTree& new_end = ComputeEndRespectingGranularity(
      new_start, PositionInFlatTreeWithAffinity(position), granularity);
  return SelectionInFlatTree::Builder()
      .SetBaseAndExtent(new_start, new_end)
      .Build();
}

void GranularityStrategyTest::SetupVerticalAlign(String str1,
                                                 String str2,
                                                 String str3,
                                                 size_t sel_begin,
                                                 size_t sel_end) {
  SetInnerHTML(
      "<html>"
      "<head>"
      "<style>"
      "span {"
      "vertical-align:20px;"
      "}"
      "</style>"
      "</head>"
      "<body>"
      "<div id='mytext'></div>"
      "</body>"
      "</html>");

  SetupTextSpan(str1, str2, str3, sel_begin, sel_end);
}

FrameSelection::FrameSelection(LocalFrame& frame)
    : frame_(frame),
      layout_selection_(LayoutSelection::Create(*this)),
      selection_editor_(SelectionEditor::Create(frame)),
      granularity_(TextGranularity::kCharacter),
      x_pos_for_vertical_arrow_navigation_(NoXPosForVerticalArrowNavigation()),
      focused_(frame.GetPage() &&
               frame.GetPage()->GetFocusController().FocusedFrame() == frame),
      frame_caret_(new FrameCaret(frame, *selection_editor_)) {}

void Editor::ReplaceSelectionWithFragment(DocumentFragment* fragment,
                                          bool select_replacement,
                                          bool smart_replace,
                                          bool match_style,
                                          InputEvent::InputType input_type) {
  DCHECK(!GetFrame().GetDocument()->NeedsLayoutTreeUpdate());
  const VisibleSelection& selection =
      GetFrame().Selection().ComputeVisibleSelectionInDOMTree();
  if (selection.IsNone() || !selection.IsContentEditable() || !fragment)
    return;

  ReplaceSelectionCommand::CommandOptions options =
      ReplaceSelectionCommand::kPreventNesting |
      ReplaceSelectionCommand::kSanitizeFragment;
  if (select_replacement)
    options |= ReplaceSelectionCommand::kSelectReplacement;
  if (smart_replace)
    options |= ReplaceSelectionCommand::kSmartReplace;
  if (match_style)
    options |= ReplaceSelectionCommand::kMatchStyle;
  DCHECK(GetFrame().GetDocument());
  ReplaceSelectionCommand::Create(*GetFrame().GetDocument(), fragment, options,
                                  input_type)
      ->Apply();
  RevealSelectionAfterEditingOperation();
}

void GranularityStrategyTest::SetupFontSize(String str1,
                                            String str2,
                                            String str3,
                                            size_t sel_begin,
                                            size_t sel_end) {
  SetInnerHTML(
      "<html>"
      "<head>"
      "<style>"
      "span {"
      "font-size: 200%;"
      "}"
      "</style>"
      "</head>"
      "<body>"
      "<div id='mytext'></div>"
      "</body>"
      "</html>");

  SetupTextSpan(str1, str2, str3, sel_begin, sel_end);
}

static Position UpdatePostionAfterAdoptingTextNodeSplit(
    const Position& position,
    const Text& old_node) {
  if (!position.AnchorNode() || position.AnchorNode() != &old_node ||
      !position.IsOffsetInAnchor())
    return position;
  DCHECK_GE(position.OffsetInContainerNode(), 0);
  unsigned position_offset =
      static_cast<unsigned>(position.OffsetInContainerNode());
  unsigned old_length = old_node.length();
  if (position_offset <= old_length)
    return position;
  return Position(ToText(old_node.nextSibling()), position_offset - old_length);
}

static DispatchEventResult DispatchSelectStart(
    const VisibleSelection& selection) {
  Node* select_start_target = selection.Extent().ComputeContainerNode();
  if (!select_start_target)
    return DispatchEventResult::kNotCanceled;

  return select_start_target->DispatchEvent(
      Event::CreateCancelableBubble(EventTypeNames::selectstart));
}

void Editor::AppliedEditing(CompositeEditCommand* cmd) {
  DCHECK(!cmd->IsCommandGroupWrapper());
  EventQueueScope scope;

  GetSpellChecker().MarkMisspellingsAfterApplyingCommand(*cmd);

  UndoStep* undo_step = cmd->GetUndoStep();
  DCHECK(undo_step);
  DispatchEditableContentChangedEvents(undo_step->StartingRootEditableElement(),
                                       undo_step->EndingRootEditableElement());
  DispatchInputEventEditableContentChanged(
      undo_step->StartingRootEditableElement(),
      undo_step->EndingRootEditableElement(), cmd->GetInputType(),
      cmd->TextDataForInputEvent(), IsComposingFromCommand(cmd));

  const SelectionInDOMTree& new_selection = CorrectedSelectionAfterCommand(
      cmd->EndingVisibleSelection(), GetFrame().GetDocument());

  ChangeSelectionAfterCommand(new_selection, SetSelectionData());

  if (!cmd->PreservesTypingStyle())
    ClearTypingStyle();

  if (last_edit_command_.Get() == cmd) {
    DCHECK(cmd->IsTypingCommand());
  } else if (last_edit_command_ && last_edit_command_->IsDragAndDropCommand() &&
             (cmd->GetInputType() == InputEvent::InputType::kDeleteByDrag ||
              cmd->GetInputType() == InputEvent::InputType::kInsertFromDrop)) {
    if (!last_edit_command_->GetUndoStep())
      undo_stack_->RegisterUndoStep(last_edit_command_->EnsureUndoStep());
    last_edit_command_->EnsureUndoStep()->SetEndingSelection(
        cmd->EnsureUndoStep()->EndingSelection());
    last_edit_command_->AppendCommandToUndoStep(cmd);
  } else {
    last_edit_command_ = cmd;
    undo_stack_->RegisterUndoStep(last_edit_command_->EnsureUndoStep());
  }

  RespondToChangedContents(new_selection.Base());
}

void DispatchBeforeInputFromComposition(EventTarget* target,
                                        InputEvent::InputType input_type,
                                        const String& data) {
  if (!RuntimeEnabledFeatures::InputEventEnabled())
    return;
  if (!target)
    return;
  InputEvent* before_input_event = InputEvent::CreateBeforeInput(
      input_type, data, InputEvent::kNotCancelable,
      InputEvent::EventIsComposing::kIsComposing, nullptr);
  target->DispatchEvent(before_input_event);
}

bool FrameSelection::ShouldPaintCaret(const LayoutBlock& block) const {
  DCHECK_GE(GetDocument().Lifecycle().GetState(),
            DocumentLifecycle::kLayoutClean);
  bool result = frame_caret_->ShouldPaintCaret(block);
  DCHECK(!result ||
         (ComputeVisibleSelectionInDOMTree().IsCaret() &&
          IsEditablePosition(ComputeVisibleSelectionInDOMTree().Start())));
  return result;
}

void FrameSelection::NotifyCompositorForSelectionChange() {
  if (!RuntimeEnabledFeatures::CompositedSelectionUpdateEnabled())
    return;

  ScheduleVisualUpdate();
}

String FrameSelection::SelectedTextForClipboard() const {
  return ExtractSelectedText(
      *this, TextIteratorBehavior::Builder()
                 .SetEmitsImageAltText(
                     frame_->GetSettings() &&
                     frame_->GetSettings()->GetSelectionIncludesAltImageText())
                 .Build());
}

LayoutRect FrameSelection::Bounds() const {
  LocalFrameView* view = frame_->View();
  if (!view)
    return LayoutRect();

  return Intersection(UnclippedBounds(),
                      LayoutRect(view->VisibleContentRect()));
}

void InputMethodController::DocumentAttached(Document* document) {
  DCHECK(document);
  SetContext(document);
}

bool SelectionController::HandleMousePressEvent(
    const MouseEventWithHitTestResults& event) {
  TRACE_EVENT0("blink", "SelectionController::handleMousePressEvent");

  mouse_down_may_start_select_ =
      (CanMouseDownStartSelect(event.InnerNode()) || IsLinkSelection(event)) &&
      !event.GetScrollbar();
  mouse_down_was_single_click_in_selection_ = false;
  if (!Selection().IsAvailable()) {
    mouse_down_allows_multi_click_ = !event.Event().FromTouch();
  } else {
    mouse_down_allows_multi_click_ =
        !event.Event().FromTouch() ||
        IsEditablePosition(
            Selection().ComputeVisibleSelectionInDOMTreeDeprecated().Start());
  }

  if (event.Event().click_count >= 3)
    return HandleTripleClick(event);
  if (event.Event().click_count == 2)
    return HandleDoubleClick(event);
  return HandleSingleClick(event);
}

Element* RootEditableElementOfSelection(const FrameSelection& frameSelection) {
  const SelectionInDOMTree& selection = frameSelection.GetSelectionInDOMTree();
  if (selection.IsNone())
    return nullptr;
  if (Element* editable = RootEditableElementOf(selection.Base()))
    return editable;


  frameSelection.GetDocument().UpdateStyleAndLayoutIgnorePendingStylesheets();
  const VisibleSelection& visibleSeleciton =
      frameSelection.ComputeVisibleSelectionInDOMTree();
  return RootEditableElementOf(visibleSeleciton.Start());
}

EphemeralRange Editor::SelectedRange() {
  return GetFrame()
      .Selection()
      .ComputeVisibleSelectionInDOMTreeDeprecated()
      .ToNormalizedEphemeralRange();
}

bool Editor::CanDHTMLCopy() {
  GetFrame().GetDocument()->UpdateStyleAndLayoutIgnorePendingStylesheets();
  return !IsInPasswordField(GetFrame()
                                .Selection()
                                .ComputeVisibleSelectionInDOMTree()
                                .Start()) &&
         !DispatchCPPEvent(EventTypeNames::beforecopy, kDataTransferNumb);
}

void SelectionEditor::ContextDestroyed(Document*) {
  Dispose();
  style_version_for_dom_tree_ = static_cast<uint64_t>(-1);
  style_version_for_flat_tree_ = static_cast<uint64_t>(-1);
  selection_ = SelectionInDOMTree();
  cached_visible_selection_in_dom_tree_ = VisibleSelection();
  cached_visible_selection_in_flat_tree_ = VisibleSelectionInFlatTree();
  cached_visible_selection_in_dom_tree_is_dirty_ = false;
  cached_visible_selection_in_flat_tree_is_dirty_ = false;
}

bool Editor::TryDHTMLCopy() {
  GetFrame().GetDocument()->UpdateStyleAndLayoutIgnorePendingStylesheets();
  if (IsInPasswordField(
          GetFrame().Selection().ComputeVisibleSelectionInDOMTree().Start()))
    return false;

  return !DispatchCPPEvent(EventTypeNames::copy, kDataTransferWritable);
}

bool SelectionController::HandleSingleClick(
    const MouseEventWithHitTestResults& event) {
  TRACE_EVENT0("blink",
               "SelectionController::handleMousePressEventSingleClick");

  DCHECK(!frame_->GetDocument()->NeedsLayoutTreeUpdate());
  Node* inner_node = event.InnerNode();
  if (!(inner_node && inner_node->GetLayoutObject() &&
        mouse_down_may_start_select_))
    return false;

  bool extend_selection = IsExtendingSelection(event);

  const VisiblePositionInFlatTree& visible_hit_pos =
      VisiblePositionOfHitTestResult(event.GetHitTestResult());
  const VisiblePositionInFlatTree& visible_pos =
      visible_hit_pos.IsNull()
          ? CreateVisiblePosition(
                PositionInFlatTree::FirstPositionInOrBeforeNode(inner_node))
          : visible_hit_pos;
  const VisibleSelectionInFlatTree& selection =
      this->Selection().ComputeVisibleSelectionInFlatTree();

  if (LocalFrameView* view = frame_->View()) {
    const LayoutPoint v_point = view->RootFrameToContents(
        FlooredIntPoint(event.Event().PositionInRootFrame()));
    if (!extend_selection && this->Selection().Contains(v_point)) {
      mouse_down_was_single_click_in_selection_ = true;
      if (!event.Event().FromTouch())
        return false;

      if (!this->Selection().IsHandleVisible()) {
        const bool did_select =
            UpdateSelectionForMouseDownDispatchingSelectStart(
                inner_node, selection.AsSelection(),
                TextGranularity::kCharacter, HandleVisibility::kVisible);
        if (did_select) {
          frame_->GetEventHandler().ShowNonLocatedContextMenu(nullptr,
                                                              kMenuSourceTouch);
        }
        return false;
      }
    }
  }

  if (extend_selection && !selection.IsNone()) {
    const PositionInFlatTree& pos = AdjustPositionRespectUserSelectAll(
        inner_node, selection.Start(), selection.End(),
        visible_pos.DeepEquivalent());
    const TextGranularity granularity = Selection().Granularity();
    if (pos.IsNull()) {
      UpdateSelectionForMouseDownDispatchingSelectStart(
          inner_node, selection.AsSelection(), granularity,
          HandleVisibility::kNotVisible);
      return false;
    }
    UpdateSelectionForMouseDownDispatchingSelectStart(
        inner_node,
        frame_->GetEditor().Behavior().ShouldConsiderSelectionAsDirectional()
            ? ExtendSelectionAsDirectional(pos, selection, granularity)
            : ExtendSelectionAsNonDirectional(pos, selection, granularity),
        granularity, HandleVisibility::kNotVisible);
    return false;
  }

  if (selection_state_ == SelectionState::kExtendedSelection) {
    UpdateSelectionForMouseDownDispatchingSelectStart(
        inner_node, selection.AsSelection(), TextGranularity::kCharacter,
        HandleVisibility::kNotVisible);
    return false;
  }

  if (visible_pos.IsNull()) {
    UpdateSelectionForMouseDownDispatchingSelectStart(
        inner_node, SelectionInFlatTree(), TextGranularity::kCharacter,
        HandleVisibility::kNotVisible);
    return false;
  }

  bool is_handle_visible = false;
  const bool has_editable_style = HasEditableStyle(*inner_node);
  if (has_editable_style) {
    const bool is_text_box_empty =
        !RootEditableElement(*inner_node)->HasChildren();
    const bool not_left_click =
        event.Event().button != WebPointerProperties::Button::kLeft;
    if (!is_text_box_empty || not_left_click)
      is_handle_visible = event.Event().FromTouch();
  }

  UpdateSelectionForMouseDownDispatchingSelectStart(
      inner_node,
      ExpandSelectionToRespectUserSelectAll(
          inner_node, SelectionInFlatTree::Builder()
                          .Collapse(visible_pos.ToPositionWithAffinity())
                          .Build()),
      TextGranularity::kCharacter,
      is_handle_visible ? HandleVisibility::kVisible
                        : HandleVisibility::kNotVisible);

  if (has_editable_style && event.Event().FromTouch()) {
    frame_->GetTextSuggestionController().HandlePotentialMisspelledWordTap(
        visible_pos.DeepEquivalent());
  }

  return false;
}

void Editor::TidyUpHTMLStructure(Document& document) {
  document.UpdateStyleAndLayoutTree();
  bool needs_valid_structure = HasEditableStyle(document) ||
                               (document.documentElement() &&
                                HasEditableStyle(*document.documentElement()));
  if (!needs_valid_structure)
    return;
  Element* existing_head = nullptr;
  Element* existing_body = nullptr;
  Element* current_root = document.documentElement();
  if (current_root) {
    if (isHTMLHtmlElement(current_root))
      return;
    if (isHTMLHeadElement(current_root))
      existing_head = current_root;
    else if (isHTMLBodyElement(current_root))
      existing_body = current_root;
    else if (isHTMLFrameSetElement(current_root))
      existing_body = current_root;
  }
  document.AddConsoleMessage(ConsoleMessage::Create(
      kJSMessageSource, kWarningMessageLevel,
      "document.execCommand() doesn't work with an invalid HTML structure. It "
      "is corrected automatically."));
  UseCounter::Count(document, WebFeature::kExecCommandAltersHTMLStructure);

  Element* root = HTMLHtmlElement::Create(document);
  if (existing_head)
    root->AppendChild(existing_head);
  Element* body = nullptr;
  if (existing_body)
    body = existing_body;
  else
    body = HTMLBodyElement::Create(document);
  if (document.documentElement() && body != document.documentElement())
    body->AppendChild(document.documentElement());
  root->AppendChild(body);
  DCHECK(!document.documentElement());
  document.AppendChild(root);

}

void SelectionController::SelectClosestWordOrLinkFromMouseEvent(
    const MouseEventWithHitTestResults& result) {
  if (!result.GetHitTestResult().IsLiveLink()) {
    SelectClosestWordFromMouseEvent(result);
    return;
  }

  Node* const inner_node = result.InnerNode();

  if (!inner_node || !inner_node->GetLayoutObject() ||
      !mouse_down_may_start_select_)
    return;

  Element* url_element = result.GetHitTestResult().URLElement();
  const VisiblePositionInFlatTree pos =
      VisiblePositionOfHitTestResult(result.GetHitTestResult());
  const SelectionInFlatTree& new_selection =
      pos.IsNotNull() &&
              pos.DeepEquivalent().AnchorNode()->IsDescendantOf(url_element)
          ? SelectionInFlatTree::Builder()
                .SelectAllChildren(*url_element)
                .Build()
          : SelectionInFlatTree();

  UpdateSelectionForMouseDownDispatchingSelectStart(
      inner_node,
      ExpandSelectionToRespectUserSelectAll(inner_node, new_selection),
      TextGranularity::kWord, HandleVisibility::kNotVisible);
}

bool InputMethodController::InsertText(const String& text) {
  if (DispatchBeforeInputInsertText(GetDocument().FocusedElement(), text) !=
      DispatchEventResult::kNotCanceled)
    return false;
  GetEditor().InsertText(text, 0);
  return true;
}

void SelectionEditor::NodeChildrenWillBeRemoved(ContainerNode& container) {
if (selection_.IsNone())
return;
const Position old_base = selection_.base_;
const Position old_extent = selection_.extent_;
const Position& new_base =
ComputePositionForChildrenRemoval(old_base, container);
const Position& new_extent =
ComputePositionForChildrenRemoval(old_extent, container);
if (new_base == old_base && new_extent == old_extent)
return;
selection_ = SelectionInDOMTree::Builder()
.SetBaseAndExtent(new_base, new_extent)
                   .SetIsHandleVisible(selection_.IsHandleVisible())
.Build();
MarkCacheDirty();
}

void Editor::Undo() {
  undo_stack_->Undo();
}

void FrameSelection::SetShouldShowBlockCursor(bool should_show_block_cursor) {
  frame_caret_->SetShouldShowBlockCursor(should_show_block_cursor);
}

void Editor::WriteSelectionToPasteboard() {
  KURL url = GetFrame().GetDocument()->Url();
  String html = GetFrame().Selection().SelectedHTMLForClipboard();
  String plain_text = GetFrame().SelectedTextForClipboard();
  Pasteboard::GeneralPasteboard()->WriteHTML(html, url, plain_text,
                                             CanSmartCopyOrDelete());
}
