void svcinfo_death(struct binder_state *bs, void *ptr)
{
 struct svcinfo *si = (struct svcinfo* ) ptr;

    ALOGI("service '%s' died\n", str8(si->name, si->len));
 if (si->handle) {
        binder_release(bs, si->handle);
        si->handle = 0;
 }
}

int do_add_service(struct binder_state *bs,
 const uint16_t *s, size_t len,
 uint32_t handle, uid_t uid, int allow_isolated,
 pid_t spid)
{
 struct svcinfo *si;


 if (!handle || (len == 0) || (len > 127))
 return -1;

 if (!svc_can_register(s, len, spid, uid)) {
        ALOGE("add_service('%s',%x) uid=%d - PERMISSION DENIED\n",
             str8(s, len), handle, uid);
 return -1;
 }

    si = find_svc(s, len);
 if (si) {
 if (si->handle) {
            ALOGE("add_service('%s',%x) uid=%d - ALREADY REGISTERED, OVERRIDE\n",
                 str8(s, len), handle, uid);
            svcinfo_death(bs, si);
 }
        si->handle = handle;
 } else {
        si = malloc(sizeof(*si) + (len + 1) * sizeof(uint16_t));
 if (!si) {
            ALOGE("add_service('%s',%x) uid=%d - OUT OF MEMORY\n",
                 str8(s, len), handle, uid);
 return -1;
 }
        si->handle = handle;
        si->len = len;
        memcpy(si->name, s, (len + 1) * sizeof(uint16_t));
        si->name[len] = '\0';
        si->death.func = (void*) svcinfo_death;
        si->death.ptr = si;
        si->allow_isolated = allow_isolated;
        si->next = svclist;
        svclist = si;
 }

    binder_acquire(bs, handle);
    binder_link_to_death(bs, handle, &si->death);
 return 0;
}

 static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid)
 {
     const char *perm = "add";
     return check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0;
 }

struct svcinfo *find_svc(const uint16_t *s16, size_t len)
{
 struct svcinfo *si;

 for (si = svclist; si; si = si->next) {
 if ((len == si->len) &&
 !memcmp(s16, si->name, len * sizeof(uint16_t))) {
 return si;
 }
 }
 return NULL;
}

static int svc_can_find(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid)
{
 const char *perm = "find";
 return check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0;
}

static bool check_mac_perms_from_getcon(pid_t spid, uid_t uid, const char *perm)
{
 if (selinux_enabled <= 0) {
 return true;
 }

 return check_mac_perms(spid, uid, service_manager_context, perm, NULL);
}

static bool check_mac_perms_from_lookup(pid_t spid, uid_t uid, const char *perm, const char *name)
{
 bool allowed;
 char *tctx = NULL;

 if (selinux_enabled <= 0) {
 return true;
 }

 if (!sehandle) {
        ALOGE("SELinux: Failed to find sehandle. Aborting service_manager.\n");
        abort();
 }

 if (selabel_lookup(sehandle, &tctx, name, 0) != 0) {
        ALOGE("SELinux: No match for %s in service_contexts.\n", name);
 return false;
 }

    allowed = check_mac_perms(spid, uid, tctx, perm, name);
    freecon(tctx);
 return allowed;
}

uint32_t do_find_service(const uint16_t *s, size_t len, uid_t uid, pid_t spid)
{
 struct svcinfo *si = find_svc(s, len);

 if (!si || !si->handle) {
 return 0;
 }

 if (!si->allow_isolated) {
 uid_t appid = uid % AID_USER;
 if (appid >= AID_ISOLATED_START && appid <= AID_ISOLATED_END) {
 return 0;
 }
 }

 if (!svc_can_find(s, len, spid, uid)) {
 return 0;
 }

 return si->handle;
}

static int svc_can_list(pid_t spid, uid_t uid)
{
 const char *perm = "list";
 return check_mac_perms_from_getcon(spid, uid, perm) ? 1 : 0;
}

int str16eq(const uint16_t *a, const char *b)
{
 while (*a && *b)
 if (*a++ != *b++) return 0;
 if (*a || *b)
 return 0;
 return 1;
}

static int audit_callback(void *data, __unused security_class_t cls, char *buf, size_t len)
{
 struct audit_data *ad = (struct audit_data *)data;

 if (!ad || !ad->name) {
        ALOGE("No service manager audit data");
 return 0;
 }

    snprintf(buf, len, "service=%s pid=%d uid=%d", ad->name, ad->pid, ad->uid);
 return 0;
}
