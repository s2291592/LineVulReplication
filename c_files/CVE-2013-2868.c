static scoped_refptr<Extension> MakeSyncTestExtension(
SyncTestExtensionType type,
const GURL& update_url,
const GURL& launch_url,
Manifest::Location location,
int num_plugins,
const base::FilePath& extension_path,
      int creation_flags) {
base::DictionaryValue source;
source.SetString(keys::kName, "PossiblySyncableExtension");
source.SetString(keys::kVersion, "0.0.0.0");
if (type == APP)
source.SetString(keys::kApp, "true");
if (type == THEME)
source.Set(keys::kTheme, new base::DictionaryValue());
if (!update_url.is_empty()) {
source.SetString(keys::kUpdateURL, update_url.spec());
}
if (!launch_url.is_empty()) {
source.SetString(keys::kLaunchWebURL, launch_url.spec());
}
if (type != THEME) {
source.SetBoolean(keys::kConvertedFromUserScript, type == USER_SCRIPT);
base::ListValue* plugins = new base::ListValue();
for (int i = 0; i < num_plugins; ++i) {
base::DictionaryValue* plugin = new base::DictionaryValue();
plugin->SetString(keys::kPluginsPath, std::string());
plugins->Set(i, plugin);
}
source.Set(keys::kPlugins, plugins);
}

std::string error;
scoped_refptr<Extension> extension = Extension::Create(
extension_path, location, source, creation_flags, &error);
EXPECT_TRUE(extension.get());
EXPECT_EQ("", error);
return extension;
}

bool IsSyncableExtension(const Extension* extension) {
  return GetSyncType(extension) == SYNC_TYPE_EXTENSION;
}

bool IsSyncable(const Extension* extension) {

  bool is_syncable = (extension->location() == Manifest::INTERNAL &&
                      !extension->was_installed_by_default());
  is_syncable |= (extension->id() == extension_misc::kWebStoreAppId);
  return is_syncable;
}

bool IsSyncableApp(const Extension* extension) {
  return GetSyncType(extension) == SYNC_TYPE_APP;
}

SyncType GetSyncType(const Extension* extension) {
if (!IsSyncable(extension)) {
// We have a non-standard location.
return SYNC_TYPE_NONE;
}

// Disallow extensions with non-gallery auto-update URLs for now.
//
// TODO(akalin): Relax this restriction once we've put in UI to
// approve synced extensions.
if (!ManifestURL::GetUpdateURL(extension).is_empty() &&
!ManifestURL::UpdatesFromGallery(extension)) {
return SYNC_TYPE_NONE;
}

// Disallow extensions with native code plugins.
//
// TODO(akalin): Relax this restriction once we've put in UI to
// approve synced extensions.
  if (PluginInfo::HasPlugins(extension))
return SYNC_TYPE_NONE;

switch (extension->GetType()) {
case Manifest::TYPE_EXTENSION:
return SYNC_TYPE_EXTENSION;

case Manifest::TYPE_USER_SCRIPT:
// We only want to sync user scripts with gallery update URLs.
if (ManifestURL::UpdatesFromGallery(extension))
return SYNC_TYPE_EXTENSION;
return SYNC_TYPE_NONE;

case Manifest::TYPE_HOSTED_APP:
case Manifest::TYPE_LEGACY_PACKAGED_APP:
case Manifest::TYPE_PLATFORM_APP:
return SYNC_TYPE_APP;

case Manifest::TYPE_UNKNOWN:
// Confusingly, themes are actually synced.
// TODO(yoz): Make this look less inconsistent.
case Manifest::TYPE_THEME:
case Manifest::TYPE_SHARED_MODULE:
return SYNC_TYPE_NONE;
}
NOTREACHED();
return SYNC_TYPE_NONE;
}
