log2vis_unicode (PyObject * unicode, FriBidiParType base_direction, int clean, int reordernsm)
{
	PyObject *logical = NULL;	/* input string encoded in utf-8 *
	PyObject *visual = NULL;	/* output string encoded in utf-8 *
	PyObject *result = NULL;	/* unicode output string *
	int length = PyUnicode_GET_SIZE (unicode);
	logical = PyUnicode_AsUTF8String (unicode);
	if (logical == NULL)
		goto cleanup;
	visual = log2vis_utf8 (logical, length, base_direction, clean, reordernsm);
	if (visual == NULL)
		goto cleanup;
	result = PyUnicode_DecodeUTF8 (PyString_AS_STRING (visual),
				       PyString_GET_SIZE (visual), "strict");
      cleanup:
	Py_XDECREF (logical);
	Py_XDECREF (visual);
	return result;
}

_pyfribidi_log2vis (PyObject * self, PyObject * args, PyObject * kw)
{
	PyObject *logical = NULL;	/* input unicode or string object *
	FriBidiParType base = FRIBIDI_TYPE_RTL;	/* optional direction *
	const char *encoding = "utf-8";	/* optional input string encoding *
	int clean = 0; /* optional flag to clean the string *
	int reordernsm = 1; /* optional flag to allow reordering of non spacing marks*
	static char *kwargs[] =
	        { "logical", "base_direction", "encoding", "clean", "reordernsm", NULL };
        if (!PyArg_ParseTupleAndKeywords (args, kw, "O|isii", kwargs,
					  &logical, &base, &encoding, &clean, &reordernsm))
		return NULL;
	/* Validate base *
	if (!(base == FRIBIDI_TYPE_RTL ||
	      base == FRIBIDI_TYPE_LTR || base == FRIBIDI_TYPE_ON))
		return PyErr_Format (PyExc_ValueError,
				     "invalid value %d: use either RTL, LTR or ON",
				     base);
	/* Check object type and delegate to one of the log2vis functions *
	if (PyUnicode_Check (logical))
	        return log2vis_unicode (logical, base, clean, reordernsm);
	else if (PyString_Check (logical))
	        return log2vis_encoded_string (logical, encoding, base, clean, reordernsm);
	else
		return PyErr_Format (PyExc_TypeError,
				     "expected unicode or str, not %s",
				     logical->ob_type->tp_name);
}

initpyfribidi (void)
{
	PyObject *module;
	/* XXX What should be done if we fail here? *
	module = Py_InitModule3 ("pyfribidi", PyfribidiMethods,
				 _pyfribidi__doc__);
PyModule_AddIntConstant (module, "RTL", (long) FRIBIDI_TYPE_RTL);
PyModule_AddIntConstant (module, "LTR", (long) FRIBIDI_TYPE_LTR);
PyModule_AddIntConstant (module, "ON", (long) FRIBIDI_TYPE_ON);
	PyModule_AddStringConstant (module, "__author__",
				    "Yaacov Zamir and Nir Soffer");
}

log2vis_encoded_string (PyObject * string, const char *encoding,
			FriBidiParType base_direction, int clean, int reordernsm)
{
	PyObject *logical = NULL;	/* logical unicode object *
	PyObject *result = NULL;	/* output string object *
	/* Always needed for the string length *
	logical = PyUnicode_Decode (PyString_AS_STRING (string),
				    PyString_GET_SIZE (string),
				    encoding, "strict");
	if (logical == NULL)
		return NULL;
	if (strcmp (encoding, "utf-8") == 0)
		/* Shortcut for utf8 strings (little faster) *
		result = log2vis_utf8 (string,
				       PyUnicode_GET_SIZE (logical),
				       base_direction, clean, reordernsm);
	else
	{
		/* Invoke log2vis_unicode and encode back to encoding *
		PyObject *visual = log2vis_unicode (logical, base_direction, clean, reordernsm);
		if (visual)
		{
			result = PyUnicode_Encode (PyUnicode_AS_UNICODE
						   (visual),
						   PyUnicode_GET_SIZE (visual),
						   encoding, "strict");
			Py_DECREF (visual);
		}
	}
	Py_DECREF (logical);
	return result;
}
