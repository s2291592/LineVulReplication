Node* TextTrackCue::Owner() const {
  return track_ ? track_->Owner() : nullptr;
}

void TextTrack::removeCue(TextTrackCue* cue, ExceptionState& exception_state) {
  DCHECK(cue);



  if (cue->track() != this) {
    exception_state.ThrowDOMException(
        kNotFoundError,
        "The specified cue is not listed in the TextTrack's list of cues.");
    return;
  }

  DCHECK(cues_);

  bool was_removed = cues_->Remove(cue);
  DCHECK(was_removed);

  DCHECK(!cue->IsActive() || GetCueTimeline());

  cue->SetTrack(nullptr);

  if (GetCueTimeline())
    GetCueTimeline()->RemoveCue(this, cue);
}

TextTrack::TextTrack(const AtomicString& kind,
                     const AtomicString& label,
                     const AtomicString& language,
                     const AtomicString& id,
                     TextTrackType type)
    : TrackBase(WebMediaPlayer::kTextTrack, kind, label, language, id),
      active_cues_(nullptr),
      track_list_(nullptr),
      mode_(DisabledKeyword()),
      track_type_(type),
      readiness_state_(kNotLoaded),
      track_index_(kInvalidTrackIndex),
      rendered_track_index_(kInvalidTrackIndex),
      has_been_configured_(false) {}

void TextTrackCueList::InvalidateCueIndex(size_t index) {
  first_invalid_index_ = std::min(first_invalid_index_, index);
}

const AtomicString& TextTrack::ChaptersKeyword() {
  DEFINE_STATIC_LOCAL(const AtomicString, chapters, ("chapters"));
  return chapters;
}

void TextTrack::CueWillChange(TextTrackCue* cue) {
  if (GetCueTimeline())
    GetCueTimeline()->RemoveCue(this, cue);
}

void CueTimeline::UpdateActiveCues(double movie_time) {
// 4.8.10.8 Playing the media resource

//  If the current playback position changes while the steps are running,
//  then the user agent must wait for the steps to complete, and then must
//  immediately rerun the steps.
if (IgnoreUpdateRequests())
return;

HTMLMediaElement& media_element = MediaElement();

// Don't run the "time marches on" algorithm if the document has been
// detached. This primarily guards against dispatch of events w/
// HTMLTrackElement targets.
if (media_element.GetDocument().IsDetached())
return;

// https://html.spec.whatwg.org/#time-marches-on

// 1 - Let current cues be a list of cues, initialized to contain all the
// cues of all the hidden, showing, or showing by default text tracks of the
// media element (not the disabled ones) whose start times are less than or
// equal to the current playback position and whose end times are greater
// than the current playback position.
CueList current_cues;

// The user agent must synchronously unset [the text track cue active] flag
// whenever ... the media element's readyState is changed back to
// kHaveNothing.
if (media_element.getReadyState() != HTMLMediaElement::kHaveNothing &&
      media_element.GetWebMediaPlayer())
current_cues =
cue_tree_.AllOverlaps(cue_tree_.CreateInterval(movie_time, movie_time));

CueList previous_cues;
CueList missed_cues;

// 2 - Let other cues be a list of cues, initialized to contain all the cues
// of hidden, showing, and showing by default text tracks of the media
// element that are not present in current cues.
previous_cues = currently_active_cues_;

// 3 - Let last time be the current playback position at the time this
// algorithm was last run for this media element, if this is not the first
// time it has run.
double last_time = last_update_time_;
double last_seek_time = media_element.LastSeekTime();

// 4 - If the current playback position has, since the last time this
// algorithm was run, only changed through its usual monotonic increase
// during normal playback, then let missed cues be the list of cues in other
// cues whose start times are greater than or equal to last time and whose
// end times are less than or equal to the current playback position.
// Otherwise, let missed cues be an empty list.
if (last_time >= 0 && last_seek_time < movie_time) {
CueList potentially_skipped_cues =
cue_tree_.AllOverlaps(cue_tree_.CreateInterval(last_time, movie_time));

for (CueInterval cue : potentially_skipped_cues) {
// Consider cues that may have been missed since the last seek time.
if (cue.Low() > std::max(last_seek_time, last_time) &&
cue.High() < movie_time)
missed_cues.push_back(cue);
}
}

last_update_time_ = movie_time;

// 5 - If the time was reached through the usual monotonic increase of the
// current playback position during normal playback, and if the user agent
// has not fired a timeupdate event at the element in the past 15 to 250ms
// and is not still running event handlers for such an event, then the user
// agent must queue a task to fire a simple event named timeupdate at the
// element. (In the other cases, such as explicit seeks, relevant events get
// fired as part of the overall process of changing the current playback
// position.)
if (!media_element.seeking() && last_seek_time < last_time)
media_element.ScheduleTimeupdateEvent(true);

// Explicitly cache vector sizes, as their content is constant from here.
size_t missed_cues_size = missed_cues.size();
size_t previous_cues_size = previous_cues.size();

// 6 - If all of the cues in current cues have their text track cue active
// flag set, none of the cues in other cues have their text track cue active
// flag set, and missed cues is empty, then abort these steps.
bool active_set_changed = missed_cues_size;

for (size_t i = 0; !active_set_changed && i < previous_cues_size; ++i) {
if (!current_cues.Contains(previous_cues[i]) &&
previous_cues[i].Data()->IsActive())
active_set_changed = true;
}

for (CueInterval current_cue : current_cues) {
// Notify any cues that are already active of the current time to mark
// past and future nodes. Any inactive cues have an empty display state;
// they will be notified of the current time when the display state is
// updated.
if (current_cue.Data()->IsActive())
current_cue.Data()->UpdatePastAndFutureNodes(movie_time);
else
active_set_changed = true;
}

if (!active_set_changed)
return;

// 7 - If the time was reached through the usual monotonic increase of the
// current playback position during normal playback, and there are cues in
// other cues that have their text track cue pause-on-exi flag set and that
// either have their text track cue active flag set or are also in missed
// cues, then immediately pause the media element.
for (size_t i = 0; !media_element.paused() && i < previous_cues_size; ++i) {
if (previous_cues[i].Data()->pauseOnExit() &&
previous_cues[i].Data()->IsActive() &&
!current_cues.Contains(previous_cues[i]))
media_element.pause();
}

for (size_t i = 0; !media_element.paused() && i < missed_cues_size; ++i) {
if (missed_cues[i].Data()->pauseOnExit())
media_element.pause();
}

// 8 - Let events be a list of tasks, initially empty. Each task in this
// list will be associated with a text track, a text track cue, and a time,
// which are used to sort the list before the tasks are queued.
HeapVector<std::pair<double, Member<TextTrackCue>>> event_tasks;

// 8 - Let affected tracks be a list of text tracks, initially empty.
HeapVector<Member<TextTrack>> affected_tracks;

for (const auto& missed_cue : missed_cues) {
// 9 - For each text track cue in missed cues, prepare an event named enter
// for the TextTrackCue object with the text track cue start time.
event_tasks.push_back(
std::make_pair(missed_cue.Data()->startTime(), missed_cue.Data()));

// 10 - For each text track [...] in missed cues, prepare an event
// named exit for the TextTrackCue object with the  with the later of
// the text track cue end time and the text track cue start time.

// Note: An explicit task is added only if the cue is NOT a zero or
// negative length cue. Otherwise, the need for an exit event is
// checked when these tasks are actually queued below. This doesn't
// affect sorting events before dispatch either, because the exit
// event has the same time as the enter event.
if (missed_cue.Data()->startTime() < missed_cue.Data()->endTime()) {
event_tasks.push_back(
std::make_pair(missed_cue.Data()->endTime(), missed_cue.Data()));
}
}

for (const auto& previous_cue : previous_cues) {
// 10 - For each text track cue in other cues that has its text
// track cue active flag set prepare an event named exit for the
// TextTrackCue object with the text track cue end time.
if (!current_cues.Contains(previous_cue)) {
event_tasks.push_back(
std::make_pair(previous_cue.Data()->endTime(), previous_cue.Data()));
}
}

for (const auto& current_cue : current_cues) {
// 11 - For each text track cue in current cues that does not have its
// text track cue active flag set, prepare an event named enter for the
// TextTrackCue object with the text track cue start time.
if (!previous_cues.Contains(current_cue)) {
event_tasks.push_back(
std::make_pair(current_cue.Data()->startTime(), current_cue.Data()));
}
}

// 12 - Sort the tasks in events in ascending time order (tasks with earlier
// times first).
NonCopyingSort(event_tasks.begin(), event_tasks.end(), EventTimeCueCompare);

for (const auto& task : event_tasks) {
if (!affected_tracks.Contains(task.second->track()))
affected_tracks.push_back(task.second->track());

// 13 - Queue each task in events, in list order.

// Each event in eventTasks may be either an enterEvent or an exitEvent,
// depending on the time that is associated with the event. This
// correctly identifies the type of the event, if the startTime is
// less than the endTime in the cue.
if (task.second->startTime() >= task.second->endTime()) {
media_element.ScheduleEvent(
CreateEventWithTarget(EventTypeNames::enter, task.second.Get()));
media_element.ScheduleEvent(
CreateEventWithTarget(EventTypeNames::exit, task.second.Get()));
} else {
bool is_enter_event = task.first == task.second->startTime();
AtomicString event_name =
is_enter_event ? EventTypeNames::enter : EventTypeNames::exit;
media_element.ScheduleEvent(
CreateEventWithTarget(event_name, task.second.Get()));
}
}

// 14 - Sort affected tracks in the same order as the text tracks appear in
// the media element's list of text tracks, and remove duplicates.
NonCopyingSort(affected_tracks.begin(), affected_tracks.end(),
TrackIndexCompare);

// 15 - For each text track in affected tracks, in the list order, queue a
// task to fire a simple event named cuechange at the TextTrack object, and,
// ...
for (const auto& track : affected_tracks) {
media_element.ScheduleEvent(
CreateEventWithTarget(EventTypeNames::cuechange, track.Get()));

// ... if the text track has a corresponding track element, to then fire a
// simple event named cuechange at the track element as well.
if (track->TrackType() == TextTrack::kTrackElement) {
HTMLTrackElement* track_element =
ToLoadableTextTrack(track.Get())->TrackElement();
DCHECK(track_element);
media_element.ScheduleEvent(
CreateEventWithTarget(EventTypeNames::cuechange, track_element));
}
}

// 16 - Set the text track cue active flag of all the cues in the current
// cues, and unset the text track cue active flag of all the cues in the
// other cues.
for (const auto& cue : current_cues)
cue.Data()->SetIsActive(true);

for (const auto& previous_cue : previous_cues) {
if (!current_cues.Contains(previous_cue)) {
TextTrackCue* cue = previous_cue.Data();
cue->SetIsActive(false);
cue->RemoveDisplayTree();
}
}

// Update the current active cues.
currently_active_cues_ = current_cues;
media_element.UpdateTextTrackDisplay();
}

static bool CueIsBefore(const TextTrackCue* cue, TextTrackCue* other_cue) {
  if (cue->startTime() < other_cue->startTime())
    return true;

  return cue->startTime() == other_cue->startTime() &&
         cue->endTime() > other_cue->endTime();
}

size_t TextTrackCueList::FindInsertionIndex(
    const TextTrackCue* cue_to_insert) const {
  auto it =
      std::upper_bound(list_.begin(), list_.end(), cue_to_insert, CueIsBefore);
  size_t index = SafeCast<size_t>(it - list_.begin());
  SECURITY_DCHECK(index <= list_.size());
  return index;
}

static bool EventTimeCueCompare(const std::pair<double, TextTrackCue*>& a,
                                const std::pair<double, TextTrackCue*>& b) {
  if (a.first != b.first)
    return a.first - b.first < 0;

  if (a.second->track() != b.second->track())
    return TrackIndexCompare(a.second->track(), b.second->track());

  return a.second->CueIndex() < b.second->CueIndex();
}

void TextTrackCue::InvalidateCueIndex() {
  cue_index_ = kInvalidCueIndex;
}

bool TextTrackCueList::Remove(TextTrackCue* cue) {
  size_t index = list_.Find(cue);
  if (index == kNotFound)
    return false;

  list_.EraseAt(index);
  InvalidateCueIndex(index);
  cue->InvalidateCueIndex();
  return true;
}

void TextTrackCue::setId(const AtomicString& id) {
  if (id_ == id)
    return;

  CueWillChange();
  id_ = id;
  CueDidChange();
 }

void TextTrackCueList::ValidateCueIndexes() {
  for (size_t i = first_invalid_index_; i < list_.size(); ++i)
    list_[i]->UpdateCueIndex(SafeCast<unsigned>(i));
  first_invalid_index_ = list_.size();
}

bool TextTrack::IsVisualKind() const {
  return kind() == SubtitlesKeyword() || kind() == CaptionsKeyword();
}

void CueTimeline::Trace(blink::Visitor* visitor) {
  visitor->Trace(media_element_);
}

bool TextTrack::IsRendered() const {
  return mode_ == ShowingKeyword() && IsVisualKind();
}

int TextTrack::TrackIndexRelativeToRenderedTracks() {
  DCHECK(track_list_);

  if (rendered_track_index_ == kInvalidTrackIndex)
    rendered_track_index_ =
        track_list_->GetTrackIndexRelativeToRenderedTracks(this);

  return rendered_track_index_;
}

void TextTrackCueList::TraceWrappers(
    const ScriptWrappableVisitor* visitor) const {
  for (auto cue : list_) {
    visitor->TraceWrappers(cue);
  }
}

const AtomicString& TextTrack::DisabledKeyword() {
  DEFINE_STATIC_LOCAL(const AtomicString, disabled, ("disabled"));
  return disabled;
}

unsigned TextTrackCue::CueIndex() {
  DCHECK(track() && track()->cues());
  TextTrackCueList* cue_list = track()->cues();
  if (!cue_list->IsCueIndexValid(cue_index_))
    cue_list->ValidateCueIndexes();
  return cue_index_;
}

const AtomicString& TextTrack::InterfaceName() const {
  return EventTargetNames::TextTrack;
}

const AtomicString& TextTrack::ShowingKeyword() {
  DEFINE_STATIC_LOCAL(const AtomicString, showing, ("showing"));
  return showing;
}

void CueTimeline::RemoveCue(TextTrack*, TextTrackCue* cue) {
  RemoveCueInternal(cue);
  UpdateActiveCues(MediaElement().currentTime());
}

const AtomicString& TextTrack::SubtitlesKeyword() {
  DEFINE_STATIC_LOCAL(const AtomicString, subtitles, ("subtitles"));
  return subtitles;
}

bool TextTrack::CanBeRendered() const {
  return GetReadinessState() != kFailedToLoad && IsVisualKind();
}

int TextTrack::TrackIndex() {
  DCHECK(track_list_);

  if (track_index_ == kInvalidTrackIndex)
    track_index_ = track_list_->GetTrackIndex(this);

  return track_index_;
}

void CueTimeline::RemoveCues(TextTrack*, const TextTrackCueList* cues) {
  for (size_t i = 0; i < cues->length(); ++i)
    RemoveCueInternal(cues->AnonymousIndexedGetter(i));
  UpdateActiveCues(MediaElement().currentTime());
}

CueTimeline* TextTrack::GetCueTimeline() const {
  return MediaElement() ? &MediaElement()->GetCueTimeline() : nullptr;
}

const AtomicString& TextTrack::MetadataKeyword() {
  DEFINE_STATIC_LOCAL(const AtomicString, metadata, ("metadata"));
  return metadata;
}

const AtomicString& TextTrack::HiddenKeyword() {
  DEFINE_STATIC_LOCAL(const AtomicString, hidden, ("hidden"));
  return hidden;
}

bool TextTrackCueList::Add(TextTrackCue* cue) {
  DCHECK_GE(cue->startTime(), 0);
  DCHECK_GE(cue->endTime(), 0);
// Maintain text track cue order:
// https://html.spec.whatwg.org/#text-track-cue-order
size_t index = FindInsertionIndex(cue);

// FIXME: The cue should not exist in the list in the first place.
if (!list_.IsEmpty() && (index > 0) && (list_[index - 1].Get() == cue))
return false;

list_.insert(index, cue);
InvalidateCueIndex(index);
return true;
}

bool TextTrack::IsValidKindKeyword(const String& value) {
  if (value == SubtitlesKeyword())
    return true;
  if (value == CaptionsKeyword())
    return true;
  if (value == DescriptionsKeyword())
    return true;
  if (value == ChaptersKeyword())
    return true;
  if (value == MetadataKeyword())
    return true;

  return false;
}

void TextTrackCueList::UpdateCueIndex(TextTrackCue* cue) {
  if (!Remove(cue))
    return;
  Add(cue);
}

void TextTrackCue::setEndTime(double value) {
  // TODO(93143): Add spec-compliant behavior for negative time values.
  if (end_time_ == value || value < 0)
return;

CueWillChange();
end_time_ = value;
CueDidChange(kCueMutationAffectsOrder);
}

void CueTimeline::HideCues(TextTrack*, const TextTrackCueList* cues) {
  for (size_t i = 0; i < cues->length(); ++i)
    cues->AnonymousIndexedGetter(i)->RemoveDisplayTree();
}

void TextTrack::CueDidChange(TextTrackCue* cue, bool update_cue_index) {
  DCHECK(cues_ && cue->track() == this);

  if (update_cue_index)
    cues_->UpdateCueIndex(cue);

  DCHECK(!cue->IsActive());

  if (mode_ == DisabledKeyword())
    return;

  if (GetCueTimeline())
    GetCueTimeline()->AddCue(this, cue);
}

const AtomicString& TextTrackCue::InterfaceName() const {
  return EventTargetNames::TextTrackCue;
}

TextTrackCueList::TextTrackCueList() : first_invalid_index_(0) {}

TextTrackCue* TextTrackCueList::getCueById(const AtomicString& id) const {
  for (const auto& cue : list_) {
    if (cue->id() == id)
      return cue.Get();
  }
  return nullptr;
}

CueTimeline::CueTimeline(HTMLMediaElement& media_element)
    : media_element_(&media_element),
      last_update_time_(-1),
      ignore_update_(0) {}

ExecutionContext* TextTrack::GetExecutionContext() const {
  HTMLMediaElement* owner = MediaElement();
  return owner ? owner->GetExecutionContext() : nullptr;
}

static bool TrackIndexCompare(TextTrack* a, TextTrack* b) {
  return a->TrackIndex() - b->TrackIndex() < 0;
}

unsigned long TextTrackCueList::length() const {
  return list_.size();
}

TextTrackCueList* TextTrack::activeCues() {
  if (!cues_ || mode_ == DisabledKeyword())
    return nullptr;

  if (!active_cues_) {
    active_cues_ = TextTrackCueList::Create();
  }

  cues_->CollectActiveCues(*active_cues_);
  return active_cues_;
}

void CueTimeline::AddCueInternal(TextTrackCue* cue) {
  double end_time = std::max(cue->startTime(), cue->endTime());

  CueInterval interval =
      cue_tree_.CreateInterval(cue->startTime(), end_time, cue);
  if (!cue_tree_.Contains(interval))
    cue_tree_.Add(interval);
}

static Event* CreateEventWithTarget(const AtomicString& event_name,
                                    EventTarget* event_target) {
  Event* event = Event::Create(event_name);
  event->SetTarget(event_target);
  return event;
}

void TextTrackCue::SetTrack(TextTrack* track) {
  track_ = track;
}

TextTrack* TextTrackCue::track() const {
  return track_;
}

Node* TextTrack::Owner() const {
  return MediaElement();
}

TextTrackCueList* TextTrack::EnsureTextTrackCueList() {
  if (!cues_) {
    cues_ = TextTrackCueList::Create();
  }

  return cues_.Get();
}

DispatchEventResult TextTrackCue::DispatchEventInternal(Event* event) {
  if (!track() || track()->mode() == TextTrack::DisabledKeyword())
    return DispatchEventResult::kCanceledBeforeDispatch;

  return EventTarget::DispatchEventInternal(event);
}

HTMLMediaElement* TextTrack::MediaElement() const {
  return track_list_ ? track_list_->Owner() : nullptr;
}

void TextTrackCueList::CollectActiveCues(TextTrackCueList& active_cues) const {
  active_cues.Clear();
  for (auto& cue : list_) {
    if (cue->IsActive())
      active_cues.Add(cue);
  }
 }

void CueTimeline::EndIgnoringUpdateRequests() {
  DCHECK(ignore_update_);
  --ignore_update_;
  if (!ignore_update_)
    UpdateActiveCues(MediaElement().currentTime());
}

void CueTimeline::AddCues(TextTrack* track, const TextTrackCueList* cues) {
  DCHECK_NE(track->mode(), TextTrack::DisabledKeyword());
  for (size_t i = 0; i < cues->length(); ++i)
    AddCueInternal(cues->AnonymousIndexedGetter(i));
  UpdateActiveCues(MediaElement().currentTime());
}

const AtomicString& TextTrack::DescriptionsKeyword() {
  DEFINE_STATIC_LOCAL(const AtomicString, descriptions, ("descriptions"));
  return descriptions;
}

void TextTrack::Trace(blink::Visitor* visitor) {
  visitor->Trace(cues_);
  visitor->Trace(active_cues_);
  visitor->Trace(track_list_);
  TrackBase::Trace(visitor);
  EventTargetWithInlineData::Trace(visitor);
}

void CueTimeline::AddCue(TextTrack* track, TextTrackCue* cue) {
  DCHECK_NE(track->mode(), TextTrack::DisabledKeyword());
  AddCueInternal(cue);
  UpdateActiveCues(MediaElement().currentTime());
}

TextTrackCue* TextTrackCueList::AnonymousIndexedGetter(unsigned index) const {
  if (index < list_.size())
    return list_[index].Get();
  return nullptr;
}

TextTrackCueList* TextTrack::cues() {
  if (mode_ != DisabledKeyword())
    return EnsureTextTrackCueList();
  return nullptr;
}

void TextTrackCue::setPauseOnExit(bool value) {
  if (pause_on_exit_ == value)
    return;

  CueWillChange();
  pause_on_exit_ = value;
  CueDidChange();
}

TextTrackCue::TextTrackCue(double start, double end)
    : start_time_(start),
      end_time_(end),
      track_(nullptr),
      cue_index_(kInvalidCueIndex),
      is_active_(false),
      pause_on_exit_(false) {}

void TextTrack::RemoveAllCues() {
  if (!cues_)
    return;

  if (GetCueTimeline())
    GetCueTimeline()->RemoveCues(this, cues_.Get());

  for (size_t i = 0; i < cues_->length(); ++i)
    cues_->AnonymousIndexedGetter(i)->SetTrack(nullptr);

  cues_->RemoveAll();
  if (active_cues_)
    active_cues_->RemoveAll();
}

void TextTrack::InvalidateTrackIndex() {
  track_index_ = kInvalidTrackIndex;
  rendered_track_index_ = kInvalidTrackIndex;
}
