void PrintWebViewHelper::PrintPreviewContext::Finished() {
  DCHECK_EQ(DONE, state_);
  ClearContext();
}

bool PrintWebViewHelper::InitPrintSettingsAndPrepareFrame(
WebKit::WebFrame* frame, WebKit::WebNode* node,
scoped_ptr<PrepareFrameAndViewForPrint>* prepare) {
  if (!InitPrintSettings(frame, node, false))
return false;

DCHECK(!prepare->get());
prepare->reset(new PrepareFrameAndViewForPrint(print_pages_params_->params,
frame, node));
UpdatePrintableSizeInPrintParameters(frame, node, prepare->get(),
&print_pages_params_->params);
Send(new PrintHostMsg_DidGetDocumentCookie(
routing_id(), print_pages_params_->params.document_cookie));
return true;
}

void PrintingMessageFilter::OnGetDefaultPrintSettingsReply(
    scoped_refptr<printing::PrinterQuery> printer_query,
    IPC::Message* reply_msg) {
  PrintMsg_Print_Params params;
  if (!printer_query.get() ||
      printer_query->last_status() != printing::PrintingContext::OK) {
    params.Reset();
  } else {
    RenderParamsFromPrintSettings(printer_query->settings(), &params);
    params.document_cookie = printer_query->cookie();
  }
  PrintHostMsg_GetDefaultPrintSettings::WriteReplyParams(reply_msg, params);
  Send(reply_msg);
  if (printer_query.get()) {
    if (printer_query->cookie() && printer_query->settings().dpi()) {
      print_job_manager_->QueuePrinterQuery(printer_query.get());
    } else {
      printer_query->StopWorker();
    }
  }
}

void PrintDialogGtk::SendDocumentToPrinter(const string16& document_name) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  if (!printer_) {
    Release();
    return;
  }

  GtkPrintJob* print_job = gtk_print_job_new(
      UTF16ToUTF8(document_name).c_str(),
      printer_,
      gtk_settings_,
      page_setup_);
  gtk_print_job_set_source_file(print_job, path_to_pdf_.value().c_str(), NULL);
  gtk_print_job_send(print_job, OnJobCompletedThunk, this, NULL);
}

void MockPrinter::PrintPage(const PrintHostMsg_DidPrintPage_Params& params) {
  EXPECT_EQ(PRINTER_PRINTING, printer_status_);
  EXPECT_EQ(document_cookie_, params.document_cookie);
  EXPECT_EQ(page_number_, params.page_number);
  EXPECT_LE(params.page_number, number_pages_);

#if defined(OS_WIN) || defined(OS_MACOSX)
  EXPECT_GT(params.data_size, 0U);
#if defined(OS_WIN)
  base::SharedMemory metafile_data(params.metafile_data_handle, true,
                                   GetCurrentProcess());
#elif defined(OS_MACOSX)
  base::SharedMemory metafile_data(params.metafile_data_handle, true);
#endif
  metafile_data.Map(params.data_size);
#if defined(OS_MACOSX)
  printing::PdfMetafileCg metafile;
#else
  printing::NativeMetafile metafile;
#endif
  metafile.InitFromData(metafile_data.memory(), params.data_size);
  printing::Image image(metafile);
  MockPrinterPage* page_data = new MockPrinterPage(metafile_data.memory(),
                                                   params.data_size,
                                                   image);
  if (!page_data) {
    printer_status_ = PRINTER_ERROR;
    return;
  }

  scoped_refptr<MockPrinterPage> page(page_data);
  pages_.push_back(page);
#endif

  ++page_number_;
  if (number_pages_ == page_number_)
    ResetPrinter();
}

void PrintWebViewHelper::OnPrintForSystemDialog() {
  WebFrame* frame = print_preview_context_.frame();
  if (!frame) {
    NOTREACHED();
    return;
  }

  WebNode* node = print_preview_context_.node();
  if (!node) {
    Print(frame, NULL);
  } else {
    WebNode duplicate_node(*node);
    Print(frame, &duplicate_node);
  }
}

void PrintingContextCairo::ReleaseContext() {
}

  virtual void SetUp() {
    CommandLine::ForCurrentProcess()->AppendSwitch(
        switches::kEnablePrintPreview);

    RenderViewTest::SetUp();
  }

void PrintingContextCairo::Cancel() {
  abort_printing_ = true;
  in_print_job_ = false;
}

bool MockPrinter::SaveSource(
    unsigned int page, const FilePath& filepath) const {
  if (printer_status_ != PRINTER_READY || page >= pages_.size())
    return false;
  const uint8* source_data = pages_[page]->source_data();
  uint32 source_size = pages_[page]->source_size();
  file_util::WriteFile(filepath, reinterpret_cast<const char*>(source_data),
                       source_size);
  return true;
}

void PrintDialogGtk::PrintDocument(const printing::Metafile* metafile,
                                   const string16& document_name) {
  DCHECK(!BrowserThread::CurrentlyOn(BrowserThread::UI));

  AddRef();

  bool error = false;
  if (!file_util::CreateTemporaryFile(&path_to_pdf_)) {
    LOG(ERROR) << "Creating temporary file failed";
    error = true;
  }

  if (!error && !metafile->SaveTo(path_to_pdf_)) {
    LOG(ERROR) << "Saving metafile failed";
    file_util::Delete(path_to_pdf_, false);
    error = true;
  }

  if (error) {
    Release();
  } else {
    BrowserThread::PostTask(
        BrowserThread::UI, FROM_HERE,
        NewRunnableMethod(this,
                          &PrintDialogGtk::SendDocumentToPrinter,
                          document_name));
  }
}

MockPrinter::MockPrinter()
  : dpi_(printing::kPointsPerInch),
    max_shrink_(2.0),
    min_shrink_(1.25),
    desired_dpi_(printing::kPointsPerInch),
    selection_only_(false),
    document_cookie_(-1),
    current_document_cookie_(0),
    printer_status_(PRINTER_READY),
    number_pages_(0),
    page_number_(0),
    is_first_request_(true),
    preview_request_id_(0),
    display_header_footer_(false),
    date_(ASCIIToUTF16("date")),
    title_(ASCIIToUTF16("title")),
    url_(ASCIIToUTF16("url")),
    use_invalid_settings_(false) {
  page_size_.SetSize(static_cast<int>(8.5 * dpi_),
                     static_cast<int>(11.0 * dpi_));
  printable_size_.SetSize(static_cast<int>((7.5 * dpi_)),
                          static_cast<int>((10.0 * dpi_)));
  margin_left_ = margin_top_ = static_cast<int>(0.5 * dpi_);
}

PrintingContext::Result PrintingContextCairo::DocumentDone() {
  if (abort_printing_)
    return CANCEL;
  DCHECK(in_print_job_);

  ResetSettings();
  return OK;
}

void PrintDialogGtk::OnResponse(GtkWidget* dialog, int response_id) {
  gtk_widget_hide(dialog_);

  switch (response_id) {
    case GTK_RESPONSE_OK: {
      if (gtk_settings_)
        g_object_unref(gtk_settings_);
      gtk_settings_ = gtk_print_unix_dialog_get_settings(
          GTK_PRINT_UNIX_DIALOG(dialog_));

      if (printer_)
        g_object_unref(printer_);
      printer_ = gtk_print_unix_dialog_get_selected_printer(
          GTK_PRINT_UNIX_DIALOG(dialog_));
      g_object_ref(printer_);

      if (page_setup_)
        g_object_unref(page_setup_);
      page_setup_ = gtk_print_unix_dialog_get_page_setup(
          GTK_PRINT_UNIX_DIALOG(dialog_));
      g_object_ref(page_setup_);

      PageRanges ranges_vector;
      gint num_ranges;
      GtkPageRange* gtk_range =
          gtk_print_settings_get_page_ranges(gtk_settings_, &num_ranges);
      if (gtk_range) {
        for (int i = 0; i < num_ranges; ++i) {
          printing::PageRange range;
          range.from = gtk_range[i].start;
          range.to = gtk_range[i].end;
          ranges_vector.push_back(range);
        }
        g_free(gtk_range);
      }

      PrintSettings settings;
      printing::PrintSettingsInitializerGtk::InitPrintSettings(
          gtk_settings_, page_setup_, ranges_vector, false, &settings);
      context_->InitWithSettings(settings);
      callback_->Run(PrintingContextCairo::OK);
      callback_ = NULL;
      return;
    }
    case GTK_RESPONSE_DELETE_EVENT:  // Fall through.
    case GTK_RESPONSE_CANCEL: {
      callback_->Run(PrintingContextCairo::CANCEL);
      callback_ = NULL;
      return;
    }
    case GTK_RESPONSE_APPLY:
    default: {
      NOTREACHED();
    }
  }
}

  void VerifyPrintPreviewGenerated(bool generated_preview) {
    const IPC::Message* preview_msg =
        render_thread_.sink().GetUniqueMessageMatching(
            PrintHostMsg_MetafileReadyForPrinting::ID);
    bool did_get_preview_msg = (NULL != preview_msg);
    ASSERT_EQ(generated_preview, did_get_preview_msg);
    if (did_get_preview_msg) {
      PrintHostMsg_MetafileReadyForPrinting::Param preview_param;
      PrintHostMsg_MetafileReadyForPrinting::Read(preview_msg, &preview_param);
      EXPECT_NE(0, preview_param.a.document_cookie);
      EXPECT_NE(0, preview_param.a.expected_pages_count);
      EXPECT_NE(0U, preview_param.a.data_size);
    }
  }

  void VerifyDidPreviewPage(bool generate_draft_pages, int page_number) {
    bool msg_found = false;
    size_t msg_count = render_thread_.sink().message_count();
    for (size_t i = 0; i < msg_count; ++i) {
      const IPC::Message* msg = render_thread_.sink().GetMessageAt(i);
      if (msg->type() == PrintHostMsg_DidPreviewPage::ID) {
        PrintHostMsg_DidPreviewPage::Param page_param;
        PrintHostMsg_DidPreviewPage::Read(msg, &page_param);
        if (page_param.a.page_number == page_number) {
          msg_found = true;
          if (generate_draft_pages)
            EXPECT_NE(0U, page_param.a.data_size);
          else
            EXPECT_EQ(0U, page_param.a.data_size);
          break;
        }
      }
    }
    ASSERT_EQ(generate_draft_pages, msg_found);
  }

bool PrintWebViewHelper::InitPrintSettings(WebKit::WebFrame* frame,
                                           WebKit::WebNode* node,
                                           bool is_preview) {
DCHECK(frame);
PrintMsg_PrintPages_Params settings;

Send(new PrintHostMsg_GetDefaultPrintSettings(routing_id(),
&settings.params));
// Check if the printer returned any settings, if the settings is empty, we
// can safely assume there are no printer drivers configured. So we safely
// terminate.
bool result = true;
if (PrintMsg_Print_Params_IsEmpty(settings.params)) {
    if (!is_preview) {
      render_view()->runModalAlertDialog(
          frame,
          l10n_util::GetStringUTF16(
              IDS_PRINT_PREVIEW_INVALID_PRINTER_SETTINGS));
    }
result = false;
}

if (result &&
(settings.params.dpi < kMinDpi || settings.params.document_cookie == 0)) {
// Invalid print page settings.
NOTREACHED();
result = false;
}

settings.pages.clear();
print_pages_params_.reset(new PrintMsg_PrintPages_Params(settings));
return result;
}

bool PrintWebViewHelper::UpdatePrintSettings(
const DictionaryValue& job_settings, bool is_preview) {
  PrintMsg_PrintPages_Params settings;

Send(new PrintHostMsg_UpdatePrintSettings(routing_id(),
       print_pages_params_->params.document_cookie, job_settings, &settings));
if (settings.params.dpi < kMinDpi || !settings.params.document_cookie) {
print_preview_context_.set_error(PREVIEW_ERROR_UPDATING_PRINT_SETTINGS);
return false;
}

if (is_preview) {
// Validate expected print preview settings.
if (!job_settings.GetString(printing::kPreviewUIAddr,
&(settings.params.preview_ui_addr)) ||
!job_settings.GetInteger(printing::kPreviewRequestID,
&(settings.params.preview_request_id)) ||
!job_settings.GetBoolean(printing::kIsFirstRequest,
&(settings.params.is_first_request))) {
NOTREACHED();
print_preview_context_.set_error(PREVIEW_ERROR_BAD_SETTING);
return false;
}

if (settings.params.is_first_request &&
!print_preview_context_.IsModifiable()) {
settings.params.display_header_footer = false;
}

// Margins: Send default page layout to browser process.
PageSizeMargins default_page_layout;
GetPageSizeAndMarginsInPoints(NULL, -1, settings.params,
&default_page_layout);
if (!old_print_pages_params_.get() ||
!PageLayoutIsEqual(*old_print_pages_params_, settings)) {
Send(new PrintHostMsg_DidGetDefaultPageLayout(routing_id(),
default_page_layout));
}
SetCustomMarginsIfSelected(job_settings, &settings);

// Header/Footer: Set |header_footer_info_|.
if (settings.params.display_header_footer) {
header_footer_info_.reset(new DictionaryValue());
header_footer_info_->SetString(printing::kSettingHeaderFooterDate,
settings.params.date);
header_footer_info_->SetString(printing::kSettingHeaderFooterURL,
settings.params.url);
header_footer_info_->SetString(printing::kSettingHeaderFooterTitle,
settings.params.title);
}
}

print_pages_params_.reset(new PrintMsg_PrintPages_Params(settings));
Send(new PrintHostMsg_DidGetDocumentCookie(routing_id(),
settings.params.document_cookie));
return true;
}

  virtual void SetUp() {
    RenderViewTest::SetUp();
  }

void PrintWebViewHelper::OnPrintForPrintPreview(
const DictionaryValue& job_settings) {
DCHECK(is_preview_);
// If still not finished with earlier print request simply ignore.
if (print_web_view_)
return;

if (!render_view()->webview())
return;
WebFrame* main_frame = render_view()->webview()->mainFrame();
if (!main_frame)
return;

WebDocument document = main_frame->document();
// <object> with id="pdf-viewer" is created in
// chrome/browser/resources/print_preview/print_preview.js
WebElement pdf_element = document.getElementById("pdf-viewer");
if (pdf_element.isNull()) {
NOTREACHED();
return;
}

  WebFrame* pdf_frame = pdf_element.document().frame();
  scoped_ptr<PrepareFrameAndViewForPrint> prepare;
  if (!InitPrintSettingsAndPrepareFrame(pdf_frame, &pdf_element, &prepare)) {
    LOG(ERROR) << "Failed to initialize print page settings";
    return;
  }
if (!UpdatePrintSettings(job_settings, false)) {
LOG(ERROR) << "UpdatePrintSettings failed";
DidFinishPrinting(FAIL_PRINT);
return;
}

// Render Pages for printing.
if (!RenderPagesForPrint(pdf_frame, &pdf_element, prepare.get())) {
LOG(ERROR) << "RenderPagesForPrint failed";
DidFinishPrinting(FAIL_PRINT);
}
}

void PrintWebViewHelper::PrintPreviewContext::InitWithFrame(
    WebKit::WebFrame* web_frame) {
  DCHECK(web_frame);
  state_ = INITIALIZED;
  frame_ = web_frame;
  node_.reset();
}

PrintWebViewHelper::PrintPreviewContext::print_params() const {
   return *print_params_;
 }

  PrintWebViewHelperPreviewTest() {}

  PrintWebViewHelperTestBase() {}

  static bool SetPrinter(GtkPrinter* printer, GtkPrinterList* printer_list) {
    if (gtk_printer_is_default(printer))
      printer_list->default_printer_ = printer;

    g_object_ref(printer);
    printer_list->printers_.push_back(printer);

    return false;
  }

MockPrinterPage::~MockPrinterPage() {}

    PrintDialogGtkInterface* (*create_dialog_func)(
        PrintingContextCairo* context)) {
  DCHECK(create_dialog_func);
  DCHECK(!create_dialog_func_);
  create_dialog_func_ = create_dialog_func;
}

PrepareFrameAndViewForPrint::PrepareFrameAndViewForPrint(
    const PrintMsg_Print_Params& print_params,
    WebFrame* frame,
    WebNode* node)
        : frame_(frame),
          web_view_(frame->view()),
          dpi_(static_cast<int>(print_params.dpi)),
          expected_pages_count_(0),
          use_browser_overlays_(true),
          finished_(false) {
  gfx::Size canvas_size;
  CalculatePrintCanvasSize(print_params, &canvas_size);

  if (WebFrame* web_frame = web_view_->mainFrame())
    prev_scroll_offset_ = web_frame->scrollOffset();
  prev_view_size_ = web_view_->size();

  if (node)
    node_to_print_ = *node;

  StartPrinting(canvas_size);
}

  void VerifyPrintPreviewCancelled(bool did_cancel) {
    bool print_preview_cancelled =
        (render_thread_.sink().GetUniqueMessageMatching(
            PrintHostMsg_PrintPreviewCancelled::ID) != NULL);
    EXPECT_EQ(did_cancel, print_preview_cancelled);
  }

bool MockPrinter::SaveBitmap(
    unsigned int page, const FilePath& filepath) const {
  if (printer_status_ != PRINTER_READY || page >= pages_.size())
    return false;

  pages_[page]->image().SaveToPng(filepath);
  return true;
}

bool PrintDialogGtk::UpdateSettings(const DictionaryValue& settings,
                                    const printing::PageRanges& ranges) {
  bool collate;
  int color;
  bool landscape;
  bool print_to_pdf;
  int copies;
  int duplex_mode;
  std::string device_name;

  if (!settings.GetBoolean(printing::kSettingLandscape, &landscape) ||
      !settings.GetBoolean(printing::kSettingCollate, &collate) ||
      !settings.GetInteger(printing::kSettingColor, &color) ||
      !settings.GetBoolean(printing::kSettingPrintToPDF, &print_to_pdf) ||
      !settings.GetInteger(printing::kSettingDuplexMode, &duplex_mode) ||
      !settings.GetInteger(printing::kSettingCopies, &copies) ||
      !settings.GetString(printing::kSettingDeviceName, &device_name)) {
     return false;
   }
 
   if (!print_to_pdf) {
     scoped_ptr<GtkPrinterList> printer_list(new GtkPrinterList);
     printer_ = printer_list->GetPrinterWithName(device_name.c_str());
     if (printer_) {
       g_object_ref(printer_);
       gtk_print_settings_set_printer(gtk_settings_,
                                      gtk_printer_get_name(printer_));
     }
     gtk_print_settings_set_n_copies(gtk_settings_, copies);
     gtk_print_settings_set_collate(gtk_settings_, collate);
 
    const char* color_mode;
    switch (color) {
      case printing::COLOR:
        color_mode = kColor;
        break;
      case printing::CMYK:
        color_mode = kCMYK;
        break;
      default:
        color_mode = kGrayscale;
        break;
    }
    gtk_print_settings_set(gtk_settings_, kCUPSColorModel, color_mode);

    if (duplex_mode != printing::UNKNOWN_DUPLEX_MODE) {
      const char* cups_duplex_mode = NULL;
      switch (duplex_mode) {
        case printing::LONG_EDGE:
          cups_duplex_mode = kDuplexNoTumble;
          break;
        case printing::SHORT_EDGE:
          cups_duplex_mode = kDuplexTumble;
          break;
        case printing::SIMPLEX:
          cups_duplex_mode = kDuplexNone;
          break;
        default:  // UNKNOWN_DUPLEX_MODE
          NOTREACHED();
          break;
      }
      gtk_print_settings_set(gtk_settings_, kCUPSDuplex, cups_duplex_mode);
    }
  }

  gtk_print_settings_set_orientation(
      gtk_settings_,
      landscape ? GTK_PAGE_ORIENTATION_LANDSCAPE :
                  GTK_PAGE_ORIENTATION_PORTRAIT);

  InitPrintSettings(ranges);
  return true;
}

int MockPrinter::GetPrintedPages() const {
  if (printer_status_ != PRINTER_READY)
    return -1;
  return page_number_;
}

printing::PrintDialogGtkInterface* PrintDialogGtk::CreatePrintDialog(
    PrintingContextCairo* context) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  return new PrintDialogGtk(context);
}

int MockPrinter::GetWidth(unsigned int page) const {
  if (printer_status_ != PRINTER_READY || page >= pages_.size())
    return -1;
  return pages_[page]->width();
}

  GtkPrinter* default_printer() {
    return default_printer_;
  }

WebKit::WebNode* PrintWebViewHelper::PrintPreviewContext::node() const {
  return node_.get();
}

int MockPrinter::CreateDocumentCookie() {
  return use_invalid_settings_ ? 0 : ++current_document_cookie_;
}

void PrintWebViewHelper::OnPrintNodeUnderContextMenu() {
  const WebNode& context_menu_node = render_view()->context_menu_node();
  if (context_menu_node.isNull()) {
    NOTREACHED();
    return;
  }

  if (is_preview_) {
    print_preview_context_.InitWithNode(context_menu_node);
    RequestPrintPreview();
  } else {
    WebNode duplicate_node(context_menu_node);
    Print(duplicate_node.document().frame(), &duplicate_node);
  }
}

void PrintSettingsInitializerWin::InitPrintSettings(
HDC hdc,
const DEVMODE& dev_mode,
const PageRanges& new_ranges,
const std::wstring& new_device_name,
bool print_selection_only,
PrintSettings* print_settings) {
DCHECK(hdc);
DCHECK(print_settings);

print_settings->set_printer_name(dev_mode.dmDeviceName);
print_settings->set_device_name(new_device_name);
  print_settings->ranges = new_ranges;
print_settings->set_landscape(dev_mode.dmOrientation == DMORIENT_LANDSCAPE);
print_settings->selection_only = print_selection_only;

int dpi = GetDeviceCaps(hdc, LOGPIXELSX);
print_settings->set_dpi(dpi);
const int kAlphaCaps = SB_CONST_ALPHA | SB_PIXEL_ALPHA;
print_settings->set_supports_alpha_blend(
(GetDeviceCaps(hdc, SHADEBLENDCAPS) & kAlphaCaps) == kAlphaCaps);
// No printer device is known to advertise different dpi in X and Y axis; even
// the fax device using the 200x100 dpi setting. It's ought to break so many
// applications that it's not even needed to care about. WebKit doesn't
// support different dpi settings in X and Y axis.
DCHECK_EQ(dpi, GetDeviceCaps(hdc, LOGPIXELSY));

DCHECK_EQ(GetDeviceCaps(hdc, SCALINGFACTORX), 0);
DCHECK_EQ(GetDeviceCaps(hdc, SCALINGFACTORY), 0);

// Initialize page_setup_device_units_.
gfx::Size physical_size_device_units(GetDeviceCaps(hdc, PHYSICALWIDTH),
GetDeviceCaps(hdc, PHYSICALHEIGHT));
gfx::Rect printable_area_device_units(GetDeviceCaps(hdc, PHYSICALOFFSETX),
GetDeviceCaps(hdc, PHYSICALOFFSETY),
GetDeviceCaps(hdc, HORZRES),
GetDeviceCaps(hdc, VERTRES));

print_settings->SetPrinterPrintableArea(physical_size_device_units,
printable_area_device_units,
dpi);
}

PrintingContext::Result PrintingContextCairo::UpdatePrinterSettings(
    const DictionaryValue& job_settings, const PageRanges& ranges) {
#if defined(OS_CHROMEOS)
  bool landscape = false;

  if (!job_settings.GetBoolean(kSettingLandscape, &landscape))
    return OnError();

  settings_.SetOrientation(landscape);
  settings_.ranges = ranges;

  return OK;
 #else
   DCHECK(!in_print_job_);
 
   if (!print_dialog_->UpdateSettings(job_settings, ranges))
     return OnError();
 
  return OK;
#endif
}

 PrintWebViewHelper::PrintPreviewContext::GetPrintCanvasSize() const {
   return prep_frame_view_->GetPrintCanvasSize();
}

void MockPrinter::SetPrintParams(PrintMsg_Print_Params* params) {
  params->dpi = dpi_;
  params->max_shrink = max_shrink_;
  params->min_shrink = min_shrink_;
  params->desired_dpi = desired_dpi_;
  params->selection_only = selection_only_;
  params->document_cookie = document_cookie_;
  params->page_size = page_size_;
  params->printable_size = printable_size_;
  params->margin_left = margin_left_;
  params->margin_top = margin_top_;
  params->is_first_request = is_first_request_;
  params->preview_request_id = preview_request_id_;
  params->display_header_footer = display_header_footer_;
  params->date = date_;
  params->title = title_;
  params->url = url_;
}

void PrintWebViewHelper::OnPrintPreview(const DictionaryValue& settings) {
DCHECK(is_preview_);
print_preview_context_.OnPrintPreview();

  if (!InitPrintSettings(print_preview_context_.frame(),
                         print_preview_context_.node(),
                         true)) {
    Send(new PrintHostMsg_PrintPreviewInvalidPrinterSettings(
         routing_id(),
         print_pages_params_->params.document_cookie));
    return;
  }
if (!UpdatePrintSettings(settings, true)) {
    LOG(ERROR) << "UpdatePrintSettings failed";
DidFinishPrinting(FAIL_PREVIEW);
return;
}

if (!print_pages_params_->params.is_first_request &&
old_print_pages_params_.get() &&
PrintMsg_Print_Params_IsEqual(*old_print_pages_params_,
*print_pages_params_)) {
PrintHostMsg_DidPreviewDocument_Params preview_params;
preview_params.reuse_existing_data = true;
preview_params.data_size = 0;
preview_params.document_cookie =
print_pages_params_->params.document_cookie;
preview_params.expected_pages_count =
print_preview_context_.total_page_count();
preview_params.modifiable = print_preview_context_.IsModifiable();
preview_params.preview_request_id =
print_pages_params_->params.preview_request_id;

Send(new PrintHostMsg_MetafileReadyForPrinting(routing_id(),
preview_params));
return;
}
// Always clear |old_print_pages_params_| before rendering the pages.
old_print_pages_params_.reset();
is_print_ready_metafile_sent_ = false;

// PDF printer device supports alpha blending.
print_pages_params_->params.supports_alpha_blend = true;

bool generate_draft_pages = false;
if (!settings.GetBoolean(printing::kSettingGenerateDraftData,
&generate_draft_pages)) {
NOTREACHED();
}
print_preview_context_.set_generate_draft_pages(generate_draft_pages);

if (CreatePreviewDocument()) {
DidFinishPrinting(OK);
} else {
if (notify_browser_of_print_failure_)
LOG(ERROR) << "CreatePreviewDocument failed";
DidFinishPrinting(FAIL_PREVIEW);
}
}

  void VerifyPagesPrinted(bool printed) {
#if defined(OS_CHROMEOS)
    bool did_print_msg = (render_thread_.sink().GetUniqueMessageMatching(
        PrintHostMsg_TempFileForPrintingWritten::ID) != NULL);
    ASSERT_EQ(printed, did_print_msg);
#else
    const IPC::Message* print_msg =
        render_thread_.sink().GetUniqueMessageMatching(
            PrintHostMsg_DidPrintPage::ID);
    bool did_print_msg = (NULL != print_msg);
    ASSERT_EQ(printed, did_print_msg);
    if (printed) {
      PrintHostMsg_DidPrintPage::Param post_did_print_page_param;
      PrintHostMsg_DidPrintPage::Read(print_msg, &post_did_print_page_param);
      EXPECT_EQ(0, post_did_print_page_param.a.page_number);
    }
#endif  // defined(OS_CHROMEOS)
  }

  void VerifyPrintFailed(bool did_fail) {
    bool print_failed = (render_thread_.sink().GetUniqueMessageMatching(
        PrintHostMsg_PrintingFailed::ID) != NULL);
    EXPECT_EQ(did_fail, print_failed);
  }

void PrintWebViewHelper::Print(WebKit::WebFrame* frame, WebKit::WebNode* node) {
// If still not finished with earlier print request simply ignore.
if (print_web_view_)
return;

// Initialize print settings.
scoped_ptr<PrepareFrameAndViewForPrint> prepare;
  if (!InitPrintSettingsAndPrepareFrame(frame, node, &prepare))
return;  // Failed to init print page settings.

int expected_page_count = 0;
bool use_browser_overlays = true;

expected_page_count = prepare->GetExpectedPageCount();
if (expected_page_count)
use_browser_overlays = prepare->ShouldUseBrowserOverlays();

// Release the prepare before going any further, since we are going to
// show UI and wait for the user.
prepare.reset();

// Some full screen plugins can say they don't want to print.
if (!expected_page_count) {
DidFinishPrinting(OK);  // Release resources and fail silently.
return;
}

// Ask the browser to show UI to retrieve the final print settings.
if (!GetPrintSettingsFromUser(frame, expected_page_count,
use_browser_overlays)) {
DidFinishPrinting(OK);  // Release resources and fail silently.
return;
}

// Render Pages for printing.
if (!RenderPagesForPrint(frame, node, NULL)) {
LOG(ERROR) << "RenderPagesForPrint failed";
DidFinishPrinting(FAIL_PRINT);
}
ResetScriptedPrintCount();
}

PrintingContext::Result PrintingContextCairo::NewPage() {
  if (abort_printing_)
    return CANCEL;
  DCHECK(in_print_job_);


  return OK;
}

void PrintWebViewHelper::DisplayPrintJobError() {
  WebView* web_view = print_web_view_;
  if (!web_view)
    web_view = render_view()->webview();

  render_view()->runModalAlertDialog(
      web_view->mainFrame(),
      l10n_util::GetStringUTF16(IDS_PRINT_SPOOL_FAILED_ERROR_TEXT));
}

void CreatePrintSettingsDictionary(DictionaryValue* dict) {
  dict->SetBoolean(printing::kSettingLandscape, false);
  dict->SetBoolean(printing::kSettingCollate, false);
  dict->SetInteger(printing::kSettingColor, printing::GRAY);
  dict->SetBoolean(printing::kSettingPrintToPDF, true);
  dict->SetInteger(printing::kSettingDuplexMode, printing::SIMPLEX);
  dict->SetInteger(printing::kSettingCopies, 1);
  dict->SetString(printing::kSettingDeviceName, "dummy");
  dict->SetString(printing::kPreviewUIAddr, "0xb33fbeef");
  dict->SetInteger(printing::kPreviewRequestID, 12345);
  dict->SetBoolean(printing::kIsFirstRequest, true);
  dict->SetBoolean(printing::kSettingDefaultMarginsSelected, true);
  dict->SetBoolean(printing::kSettingHeaderFooterEnabled, false);
  dict->SetBoolean(printing::kSettingGenerateDraftData, true);
}

void MockPrinter::SetDefaultPrintSettings(const PrintMsg_Print_Params& params) {
  dpi_ = params.dpi;
  max_shrink_ = params.max_shrink;
  min_shrink_ = params.min_shrink;
  desired_dpi_ = params.desired_dpi;
  selection_only_ = params.selection_only;
  page_size_ = params.page_size;
  printable_size_ = params.printable_size;
  margin_left_ = params.margin_left;
  margin_top_ = params.margin_top;
  display_header_footer_ = params.display_header_footer;
  date_ = params.date;
  title_ = params.title;
  url_ = params.url;
}

PrintingContext::Result PrintingContextCairo::UseDefaultSettings() {
  DCHECK(!in_print_job_);

  ResetSettings();
#if defined(OS_CHROMEOS)
  int dpi = 300;
  gfx::Size physical_size_device_units;
  gfx::Rect printable_area_device_units;
  int32_t width = 0;
  int32_t height = 0;
  UErrorCode error = U_ZERO_ERROR;
  ulocdata_getPaperSize(app_locale_.c_str(), &height, &width, &error);
  if (error != U_ZERO_ERROR) {
    LOG(WARNING) << "ulocdata_getPaperSize failed, using 8.5 x 11, error: "
                 << error;
    width = static_cast<int>(8.5 * dpi);
    height = static_cast<int>(11 * dpi);
  } else {
    width = static_cast<int>(ConvertUnitDouble(width, 25.4, 1.0) * dpi);
    height = static_cast<int>(ConvertUnitDouble(height, 25.4, 1.0) * dpi);
  }

  physical_size_device_units.SetSize(width, height);
  printable_area_device_units.SetRect(
      static_cast<int>(PrintSettingsInitializerGtk::kLeftMarginInInch * dpi),
      static_cast<int>(PrintSettingsInitializerGtk::kTopMarginInInch * dpi),
      width - (PrintSettingsInitializerGtk::kLeftMarginInInch +
          PrintSettingsInitializerGtk::kRightMarginInInch) * dpi,
      height - (PrintSettingsInitializerGtk::kTopMarginInInch +
          PrintSettingsInitializerGtk::kBottomMarginInInch) * dpi);

  settings_.set_dpi(dpi);
  settings_.SetPrinterPrintableArea(physical_size_device_units,
                                    printable_area_device_units,
                                    dpi);
#else
  if (!print_dialog_) {
    print_dialog_ = create_dialog_func_(this);
    print_dialog_->AddRefToDialog();
  }
  print_dialog_->UseDefaultSettings();
#endif  // defined(OS_CHROMEOS)

  return OK;
}

void PrintDialogGtk::ReleaseDialog() {
  Release();
}

void PrintWebViewHelper::PrintPreviewContext::set_generate_draft_pages(
    bool generate_draft_pages) {
  generate_draft_pages_ = generate_draft_pages;
}

void PrintingMessageFilter::OnScriptedPrintReply(
    scoped_refptr<printing::PrinterQuery> printer_query,
    int routing_id,
    IPC::Message* reply_msg) {
  PrintMsg_PrintPages_Params params;
  if (printer_query->last_status() != printing::PrintingContext::OK ||
      !printer_query->settings().dpi()) {
    params.Reset();
  } else {
    RenderParamsFromPrintSettings(printer_query->settings(), &params.params);
    params.params.document_cookie = printer_query->cookie();
    params.pages =
        printing::PageRange::GetPages(printer_query->settings().ranges);
  }
  PrintHostMsg_ScriptedPrint::WriteReplyParams(reply_msg, params);
  Send(reply_msg);
  if (params.params.dpi && params.params.document_cookie) {
    print_job_manager_->QueuePrinterQuery(printer_query.get());
  } else {
    printer_query->StopWorker();
  }
}

void MockPrinter::SetPrintedPagesCount(int cookie, int number_pages) {
  EXPECT_EQ(document_cookie_, cookie);
  EXPECT_EQ(PRINTER_PRINTING, printer_status_);
  EXPECT_EQ(0, number_pages_);
  EXPECT_EQ(0, page_number_);

  number_pages_ = number_pages;
  page_number_ = 0;
  pages_.clear();
}

const MockPrinterPage* MockPrinter::GetPrintedPage(unsigned int pageno) const {
  if (pages_.size() > pageno)
    return pages_[pageno];
  else
    return NULL;
}

void PrintDialogGtk::OnJobCompletedThunk(GtkPrintJob* print_job,
                                         gpointer user_data,
                                         GError* error) {
  static_cast<PrintDialogGtk*>(user_data)->OnJobCompleted(print_job, error);
}

void PrintDialogGtk::AddRefToDialog() {
  AddRef();
}

PrintingContextCairo::~PrintingContextCairo() {
  ReleaseContext();

#if !defined(OS_CHROMEOS)
  if (print_dialog_)
    print_dialog_->ReleaseDialog();
#endif
}

void PrintingContextCairo::PrintDocument(const Metafile* metafile) {
  DCHECK(print_dialog_);
  DCHECK(metafile);
  print_dialog_->PrintDocument(metafile, document_name_);
}

void PrintWebViewHelper::OnPrintPages() {
  WebFrame* frame;
  if (GetPrintFrame(&frame))
    Print(frame, NULL);
}

  void VerifyPageCount(int count) {
#if defined(OS_CHROMEOS)
#else
    const IPC::Message* page_cnt_msg =
        render_thread_.sink().GetUniqueMessageMatching(
            PrintHostMsg_DidGetPrintedPagesCount::ID);
    ASSERT_TRUE(page_cnt_msg);
    PrintHostMsg_DidGetPrintedPagesCount::Param post_page_count_param;
    PrintHostMsg_DidGetPrintedPagesCount::Read(page_cnt_msg,
                                               &post_page_count_param);
    EXPECT_EQ(count, post_page_count_param.b);
#endif  // defined(OS_CHROMEOS)
  }

PrintingContext* PrintingContext::Create(const std::string& app_locale) {
  return static_cast<PrintingContext*>(new PrintingContextCairo(app_locale));
}

void RenderParamsFromPrintSettings(const printing::PrintSettings& settings,
                                   PrintMsg_Print_Params* params) {
  params->page_size = settings.page_setup_device_units().physical_size();
  params->printable_size.SetSize(
      settings.page_setup_device_units().content_area().width(),
      settings.page_setup_device_units().content_area().height());
  params->margin_top = settings.page_setup_device_units().content_area().x();
  params->margin_left = settings.page_setup_device_units().content_area().y();
  params->dpi = settings.dpi();
  params->min_shrink = settings.min_shrink;
  params->max_shrink = settings.max_shrink;
  params->desired_dpi = settings.desired_dpi;
  params->document_cookie = 0;
  params->selection_only = settings.selection_only;
  params->supports_alpha_blend = settings.supports_alpha_blend();

  params->display_header_footer = settings.display_header_footer;
  if (!settings.display_header_footer)
    return;
  params->date = settings.date;
  params->title = settings.title;
  params->url = settings.url;
}

void MockPrinter::ResetPrinter() {
  printer_status_ = PRINTER_READY;
  document_cookie_ = -1;
}

  ~PrintWebViewHelperTestBase() {}

void PrintingContextCairo::AskUserForSettings(
    gfx::NativeView parent_view,
    int max_pages,
    bool has_selection,
    PrintSettingsCallback* callback) {
#if defined(OS_CHROMEOS)
  callback->Run(OK);
#else
  print_dialog_->ShowDialog(callback);
#endif  // defined(OS_CHROMEOS)
}

  virtual ~PrintWebViewHelperPreviewTest() {}

void PrintingMessageFilter::OverrideThreadForMessage(
    const IPC::Message& message, BrowserThread::ID* thread) {
#if defined(OS_CHROMEOS)
  if (message.type() == PrintHostMsg_AllocateTempFileForPrinting::ID ||
      message.type() == PrintHostMsg_TempFileForPrintingWritten::ID) {
    *thread = BrowserThread::FILE;
  }
#endif
}

void PrintingMessageFilter::OnUpdatePrintSettings(
int document_cookie, const DictionaryValue& job_settings,
IPC::Message* reply_msg) {
scoped_refptr<printing::PrinterQuery> printer_query;
  print_job_manager_->PopPrinterQuery(document_cookie, &printer_query);
  if (printer_query.get()) {
    CancelableTask* task = NewRunnableMethod(
        this,
        &PrintingMessageFilter::OnUpdatePrintSettingsReply,
        printer_query,
        reply_msg);
    printer_query->SetSettings(job_settings, task);
}
}

bool PrintWebViewHelper::PrintPreviewContext::CreatePreviewDocument(
    PrintMsg_Print_Params* print_params,
    const std::vector<int>& pages) {
  DCHECK(IsReadyToRender());
  state_ = RENDERING;

  print_params_.reset(new PrintMsg_Print_Params(*print_params));

  metafile_.reset(new printing::PreviewMetafile);
  if (!metafile_->Init()) {
    set_error(PREVIEW_ERROR_METAFILE_INIT_FAILED);
    LOG(ERROR) << "PreviewMetafile Init failed";
    return false;
  }

  prep_frame_view_.reset(new PrepareFrameAndViewForPrint(*print_params, frame(),
                                                         node()));
  UpdatePrintableSizeInPrintParameters(frame_, node_.get(),
                                       prep_frame_view_.get(), print_params);

  total_page_count_ = prep_frame_view_->GetExpectedPageCount();
  if (total_page_count_ == 0) {
    LOG(ERROR) << "CreatePreviewDocument got 0 page count";
    set_error(PREVIEW_ERROR_ZERO_PAGES);
    return false;
  }

  int selected_page_count = pages.size();
  current_page_index_ = 0;
  print_ready_metafile_page_count_ = selected_page_count;
  pages_to_render_ = pages;

  if (selected_page_count == 0) {
    print_ready_metafile_page_count_ = total_page_count_;
    for (int i = 0; i < total_page_count_; ++i)
      pages_to_render_.push_back(i);
  } else if (generate_draft_pages_) {
    int pages_index = 0;
    for (int i = 0; i < total_page_count_; ++i) {
      if (pages_index < selected_page_count && i == pages[pages_index]) {
        pages_index++;
        continue;
      }
      pages_to_render_.push_back(i);
    }
  }

  document_render_time_ = base::TimeDelta();
  begin_time_ = base::TimeTicks::Now();

  return true;
}

bool PrintWebViewHelper::PrintPages(const PrintMsg_PrintPages_Params& params,
                                    WebFrame* frame,
                                    WebNode* node,
                                    PrepareFrameAndViewForPrint* prepare) {
  PrintMsg_Print_Params print_params = params.params;
  scoped_ptr<PrepareFrameAndViewForPrint> prep_frame_view;
  if (!prepare) {
    prep_frame_view.reset(new PrepareFrameAndViewForPrint(print_params, frame,
                                                          node));
    prepare = prep_frame_view.get();
  }
  UpdatePrintableSizeInPrintParameters(frame, node, prepare, &print_params);

  int page_count = prepare->GetExpectedPageCount();
  if (!page_count)
    return false;
  Send(new PrintHostMsg_DidGetPrintedPagesCount(routing_id(),
                                                print_params.document_cookie,
                                                page_count));

  const gfx::Size& canvas_size = prepare->GetPrintCanvasSize();
  PrintMsg_PrintPage_Params page_params;
  page_params.params = print_params;
  if (params.pages.empty()) {
    for (int i = 0; i < page_count; ++i) {
      page_params.page_number = i;
      PrintPageInternal(page_params, canvas_size, frame);
    }
  } else {
    for (size_t i = 0; i < params.pages.size(); ++i) {
      if (params.pages[i] >= page_count)
        break;
      page_params.page_number = params.pages[i];
      PrintPageInternal(page_params, canvas_size, frame);
    }
  }
  return true;
}

void PrintingMessageFilter::OnGetDefaultPrintSettings(IPC::Message* reply_msg) {
  scoped_refptr<printing::PrinterQuery> printer_query;
  if (!print_job_manager_->printing_enabled()) {
    OnGetDefaultPrintSettingsReply(printer_query, reply_msg);
    return;
  }

  print_job_manager_->PopPrinterQuery(0, &printer_query);
  if (!printer_query.get()) {
    printer_query = new printing::PrinterQuery;
  }

  CancelableTask* task = NewRunnableMethod(
      this,
      &PrintingMessageFilter::OnGetDefaultPrintSettingsReply,
      printer_query,
      reply_msg);
  printer_query->GetSettings(printing::PrinterQuery::DEFAULTS,
                             NULL,
                             0,
                             false,
                             true,
                             task);
}

void PrintWebViewHelper::PrintPreviewContext::OnPrintPreview() {
  DCHECK(IsReadyToRender());
  ClearContext();
}

void PrintWebViewHelper::OnInitiatePrintPreview() {
  DCHECK(is_preview_);
  WebFrame* frame;
  if (GetPrintFrame(&frame)) {
    print_preview_context_.InitWithFrame(frame);
    RequestPrintPreview();
  }
}

void PrintDialogGtk::ShowDialog(
    PrintingContextCairo::PrintSettingsCallback* callback) {
  callback_ = callback;

  GtkWindow* parent = BrowserList::GetLastActive()->window()->GetNativeHandle();
  dialog_ = gtk_print_unix_dialog_new(NULL, parent);
  g_signal_connect(dialog_, "delete-event",
                   G_CALLBACK(gtk_widget_hide_on_delete), NULL);


  gtk_window_set_modal(GTK_WINDOW(dialog_), TRUE);

  GtkPrintCapabilities cap = static_cast<GtkPrintCapabilities>(
      GTK_PRINT_CAPABILITY_GENERATE_PDF |
      GTK_PRINT_CAPABILITY_PAGE_SET |
      GTK_PRINT_CAPABILITY_COPIES |
      GTK_PRINT_CAPABILITY_COLLATE |
      GTK_PRINT_CAPABILITY_REVERSE);
  gtk_print_unix_dialog_set_manual_capabilities(GTK_PRINT_UNIX_DIALOG(dialog_),
                                                cap);
  gtk_print_unix_dialog_set_embed_page_setup(GTK_PRINT_UNIX_DIALOG(dialog_),
                                             TRUE);
  g_signal_connect(dialog_, "response", G_CALLBACK(OnResponseThunk), this);
  gtk_widget_show(dialog_);
}

void PrintDialogGtk::InitPrintSettings(const PageRanges& page_ranges) {
  PrintSettings settings;
  printing::PrintSettingsInitializerGtk::InitPrintSettings(
      gtk_settings_, page_setup_, page_ranges, false, &settings);
  context_->InitWithSettings(settings);
}

void MockPrinter::ScriptedPrint(int cookie,
                                int expected_pages_count,
                                bool has_selection,
                                PrintMsg_PrintPages_Params* settings) {
  EXPECT_EQ(document_cookie_, cookie);

  settings->Reset();

  settings->params.dpi = dpi_;
  settings->params.max_shrink = max_shrink_;
  settings->params.min_shrink = min_shrink_;
  settings->params.desired_dpi = desired_dpi_;
  settings->params.selection_only = selection_only_;
  settings->params.document_cookie = document_cookie_;
  settings->params.page_size = page_size_;
  settings->params.printable_size = printable_size_;
  settings->params.is_first_request = is_first_request_;
  settings->params.preview_request_id = preview_request_id_;
  settings->params.display_header_footer = display_header_footer_;
  settings->params.date = date_;
  settings->params.title = title_;
  settings->params.url = url_;
  printer_status_ = PRINTER_PRINTING;
}

void PrintWebViewHelper::didStopLoading() {
  PrintMsg_PrintPages_Params* params = print_pages_params_.get();
  DCHECK(params != NULL);
  PrintPages(*params, print_web_view_->mainFrame(), NULL, NULL);
}

PrintWebViewHelper::PrintPreviewContext::metafile() const {
  return metafile_.get();
}

void PrintWebViewHelper::DidFinishPrinting(PrintingResult result) {
bool store_print_pages_params = true;
if (result == FAIL_PRINT) {
DisplayPrintJobError();

if (notify_browser_of_print_failure_ && print_pages_params_.get()) {
int cookie = print_pages_params_->params.document_cookie;
Send(new PrintHostMsg_PrintingFailed(routing_id(), cookie));
}
} else if (result == FAIL_PREVIEW) {
DCHECK(is_preview_);
store_print_pages_params = false;
    int cookie = print_pages_params_->params.document_cookie;
if (notify_browser_of_print_failure_)
Send(new PrintHostMsg_PrintPreviewFailed(routing_id(), cookie));
else
Send(new PrintHostMsg_PrintPreviewCancelled(routing_id(), cookie));
print_preview_context_.Failed(notify_browser_of_print_failure_);
}

if (print_web_view_) {
print_web_view_->close();
print_web_view_ = NULL;
}

if (store_print_pages_params) {
old_print_pages_params_.reset(print_pages_params_.release());
} else {
print_pages_params_.reset();
old_print_pages_params_.reset();
}

notify_browser_of_print_failure_ = true;
}

void PrintingMessageFilter::OnTempFileForPrintingWritten(int sequence_number) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::FILE));
  SequenceToPathMap* map = &g_printing_file_descriptor_map.Get().map;
  SequenceToPathMap::iterator it = map->find(sequence_number);
  if (it == map->end()) {
    NOTREACHED() << "Got a sequence that we didn't pass to the "
                    "renderer: " << sequence_number;
    return;
  }

  if (cloud_print_enabled_)
    print_dialog_cloud::CreatePrintDialogForFile(
        it->second,
        string16(),
        string16(),
        std::string("application/pdf"),
        true,
        false);
  else
    NOTIMPLEMENTED();

  map->erase(it);
}

int PrintWebViewHelper::PrintPreviewContext::total_page_count() const {
  DCHECK(IsReadyToRender());
  return total_page_count_;
}

MockPrinter::~MockPrinter() {
}

MockPrinterPage::MockPrinterPage(const void* source_data,
                                 uint32 source_size,
                                 const printing::Image& image)
    : source_size_(source_size),
      image_(image) {
  source_data_.reset(new uint8[source_size]);
  if (source_data_.get())
    memcpy(source_data_.get(), source_data, source_size);
}

gfx::NativeDrawingContext PrintingContextCairo::context() const {
  return NULL;
}

void PrintWebViewHelper::PrintPage(WebKit::WebFrame* frame) {
  DCHECK(frame);

  if (prerender::PrerenderHelper::IsPrerendering(render_view())) {
    Send(new ChromeViewHostMsg_CancelPrerenderForPrinting(routing_id()));
    return;
  }

  if (IsScriptInitiatedPrintTooFrequent(frame))
    return;
  IncrementScriptedPrintCount();

  if (is_preview_) {
    print_preview_context_.InitWithFrame(frame);
    RequestPrintPreview();
  } else {
    Print(frame, NULL);
  }
}

void PrintWebViewHelper::UpdatePrintableSizeInPrintParameters(
    WebFrame* frame,
    WebNode* node,
    PrepareFrameAndViewForPrint* prepare,
    PrintMsg_Print_Params* params) {
  PageSizeMargins page_layout_in_points;
  PrintWebViewHelper::GetPageSizeAndMarginsInPoints(frame, 0, *params,
                                                    &page_layout_in_points);
  int dpi = GetDPI(params);
  params->printable_size = gfx::Size(
      static_cast<int>(ConvertUnitDouble(
          page_layout_in_points.content_width,
          printing::kPointsPerInch, dpi)),
      static_cast<int>(ConvertUnitDouble(
          page_layout_in_points.content_height,
          printing::kPointsPerInch, dpi)));

  double page_width_in_points =
      page_layout_in_points.content_width +
      page_layout_in_points.margin_left +
      page_layout_in_points.margin_right;
  double page_height_in_points =
      page_layout_in_points.content_height +
      page_layout_in_points.margin_top +
      page_layout_in_points.margin_bottom;

  params->page_size = gfx::Size(
      static_cast<int>(ConvertUnitDouble(
          page_width_in_points, printing::kPointsPerInch, dpi)),
      static_cast<int>(ConvertUnitDouble(
          page_height_in_points, printing::kPointsPerInch, dpi)));

  params->margin_top = static_cast<int>(ConvertUnitDouble(
      page_layout_in_points.margin_top, printing::kPointsPerInch, dpi));
  params->margin_left = static_cast<int>(ConvertUnitDouble(
      page_layout_in_points.margin_left, printing::kPointsPerInch, dpi));

   prepare->UpdatePrintParams(*params);
 }

void PrintingMessageFilter::OnScriptedPrint(
    const PrintHostMsg_ScriptedPrint_Params& params,
    IPC::Message* reply_msg) {
  gfx::NativeView host_view =
      gfx::NativeViewFromIdInBrowser(params.host_window_id);

  scoped_refptr<printing::PrinterQuery> printer_query;
  print_job_manager_->PopPrinterQuery(params.cookie, &printer_query);
  if (!printer_query.get()) {
    printer_query = new printing::PrinterQuery;
  }

  CancelableTask* task = NewRunnableMethod(
      this,
      &PrintingMessageFilter::OnScriptedPrintReply,
      printer_query,
      params.routing_id,
      reply_msg);

  printer_query->GetSettings(printing::PrinterQuery::ASK_USER,
                             host_view,
                             params.expected_pages_count,
                             params.has_selection,
                             params.use_overlays,
                             task);
}

  virtual ~PrintWebViewHelperTest() {}

void PrintDialogGtk::UseDefaultSettings() {
  DCHECK(!page_setup_);

  gtk_settings_ = gtk_print_settings_new();

  scoped_ptr<GtkPrinterList> printer_list(new GtkPrinterList);
  printer_ = printer_list->default_printer();
  if (printer_) {
    g_object_ref(printer_);
    gtk_print_settings_set_printer(gtk_settings_,
                                   gtk_printer_get_name(printer_));
    page_setup_ = gtk_printer_get_default_page_size(printer_);
  }

  if (!page_setup_)
    page_setup_ = gtk_page_setup_new();

  PageRanges ranges_vector;
  InitPrintSettings(ranges_vector);
}

bool PrintWebViewHelper::PrintPreviewContext::IsLastPageOfPrintReadyMetafile()
    const {
  return current_page_index_ == print_ready_metafile_page_count_;
}

void PrintWebViewHelper::PrintPreviewContext::FinalizePrintReadyDocument() {
  if (state_ != DONE && state_ != RENDERING)
    NOTREACHED();

  base::TimeTicks begin_time = base::TimeTicks::Now();
  metafile_->FinishDocument();

  if (print_ready_metafile_page_count_ <= 0) {
    NOTREACHED();
    return;
  }

  UMA_HISTOGRAM_MEDIUM_TIMES("PrintPreview.RenderToPDFTime",
                             document_render_time_);
  base::TimeDelta total_time = (base::TimeTicks::Now() - begin_time) +
                               document_render_time_;
  UMA_HISTOGRAM_MEDIUM_TIMES("PrintPreview.RenderAndGeneratePDFTime",
                             total_time);
  UMA_HISTOGRAM_MEDIUM_TIMES("PrintPreview.RenderAndGeneratePDFTimeAvgPerPage",
                             total_time / pages_to_render_.size());
}

void PrintWebViewHelper::PrintPreviewContext::InitWithNode(
    const WebKit::WebNode& web_node) {
  DCHECK(!web_node.isNull());
  state_ = INITIALIZED;
  frame_ = web_node.document().frame();
  node_.reset(new WebNode(web_node));
}

int MockPrinter::GetHeight(unsigned int page) const {
  if (printer_status_ != PRINTER_READY || page >= pages_.size())
    return -1;
  return pages_[page]->height();
}

void MockPrinter::UpdateSettings(int cookie,
PrintMsg_PrintPages_Params* params,
const std::vector<int>& pages) {
  EXPECT_EQ(document_cookie_, cookie);
params->Reset();
params->pages = pages;
SetPrintParams(&(params->params));
printer_status_ = PRINTER_PRINTING;
}

 void PrintingMessageFilter::OnCheckForCancel(const std::string& preview_ui_addr,
                                             int preview_request_id,
                                             bool* cancel) {
  PrintPreviewUI::GetCurrentPrintPreviewStatus(preview_ui_addr,
                                               preview_request_id,
                                               cancel);
}

  GtkPrinter* GetPrinterWithName(const char* name) {
    if (!name || !*name)
      return NULL;

    for (std::vector<GtkPrinter*>::iterator it = printers_.begin();
         it < printers_.end(); ++it) {
      if (strcmp(name, gtk_printer_get_name(*it)) == 0) {
        return *it;
      }
    }

    return NULL;
  }

void PrintingMessageFilter::OnAllocateTempFileForPrinting(
    base::FileDescriptor* temp_file_fd, int* sequence_number) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::FILE));
  temp_file_fd->fd = *sequence_number = -1;
  temp_file_fd->auto_close = false;

  SequenceToPathMap* map = &g_printing_file_descriptor_map.Get().map;
  *sequence_number = g_printing_file_descriptor_map.Get().sequence++;

  FilePath path;
  if (file_util::CreateTemporaryFile(&path)) {
    int fd = open(path.value().c_str(), O_WRONLY);
    if (fd >= 0) {
      SequenceToPathMap::iterator it = map->find(*sequence_number);
      if (it != map->end()) {
        NOTREACHED() << "Sequence number already in use. seq=" <<
            *sequence_number;
      } else {
        (*map)[*sequence_number] = path;
        temp_file_fd->fd = fd;
        temp_file_fd->auto_close = true;
      }
    }
  }
}

  void VerifyPrintPreviewFailed(bool did_fail) {
    bool print_preview_failed = (render_thread_.sink().GetUniqueMessageMatching(
        PrintHostMsg_PrintPreviewFailed::ID) != NULL);
    EXPECT_EQ(did_fail, print_preview_failed);
  }

PrintWebViewHelper::PrintWebViewHelper(RenderView* render_view)
    : RenderViewObserver(render_view),
      RenderViewObserverTracker<PrintWebViewHelper>(render_view),
      print_web_view_(NULL),
      is_preview_(switches::IsPrintPreviewEnabled()),
      is_print_ready_metafile_sent_(false),
      user_cancelled_scripted_print_count_(0),
      notify_browser_of_print_failure_(true) {
}

void PrintDialogGtk::OnJobCompleted(GtkPrintJob* print_job, GError* error) {
  if (error)
    LOG(ERROR) << "Printing failed: " << error->message;
  if (print_job)
    g_object_unref(print_job);
  base::FileUtilProxy::Delete(
      BrowserThread::GetMessageLoopProxyForThread(BrowserThread::FILE),
      path_to_pdf_,
      false,
      NULL);
  Release();
}

void PrintingMessageFilter::OnDuplicateSection(
    base::SharedMemoryHandle renderer_handle,
    base::SharedMemoryHandle* browser_handle) {
  base::SharedMemory shared_buf(renderer_handle, true, peer_handle());
  shared_buf.GiveToProcess(base::GetCurrentProcessHandle(), browser_handle);
}

bool PrintWebViewHelper::RenderPagesForPrint(
    WebKit::WebFrame* frame,
    WebKit::WebNode* node,
    PrepareFrameAndViewForPrint* prepare) {
  PrintMsg_PrintPages_Params print_settings = *print_pages_params_;
  if (print_settings.params.selection_only) {
    return CopyAndPrint(frame);
  } else {
    return PrintPages(print_settings, frame, node, prepare);
  }
}
