FillLightMode ParseFillLightMode(const String& blink_mode) {
  if (blink_mode == "off")
    return FillLightMode::OFF;
  if (blink_mode == "auto")
    return FillLightMode::AUTO;
  if (blink_mode == "flash")
    return FillLightMode::FLASH;
  NOTREACHED();
  return FillLightMode::OFF;
}

ExecutionContext* ImageCapture::GetExecutionContext() const {
  return ContextLifecycleObserver::GetExecutionContext();
}

void ImageCapture::ResolveWithPhotoCapabilities(
    ScriptPromiseResolver* resolver) {
  DCHECK(resolver);
  resolver->Resolve(photo_capabilities_);
 }

bool ImageCapture::HasPendingActivity() const {
  return GetExecutionContext() && HasEventListeners();
}

void ImageCapture::OnMojoSetOptions(ScriptPromiseResolver* resolver,
                                    PromiseResolverFunction resolve_function,
                                    bool trigger_take_photo,
                                    bool result) {
  DCHECK(service_requests_.Contains(resolver));

  if (!result) {
    resolver->Reject(DOMException::Create(kUnknownError, "setOptions failed"));
    service_requests_.erase(resolver);
    return;
  }

  service_->GetPhotoState(
      stream_track_->Component()->Source()->Id(),
      ConvertToBaseCallback(WTF::Bind(
          &ImageCapture::OnMojoGetPhotoState, WrapPersistent(this),
          WrapPersistent(resolver), WTF::Passed(std::move(resolve_function)),
          trigger_take_photo)));
}

MediaTrackCapabilities& ImageCapture::GetMediaTrackCapabilities() {
  return capabilities_;
}

ScriptPromise ImageCapture::setOptions(ScriptState* script_state,
                                       const PhotoSettings& photo_settings,
                                       bool trigger_take_photo /* = false */) {
  ScriptPromiseResolver* resolver = ScriptPromiseResolver::Create(script_state);
  ScriptPromise promise = resolver->Promise();

  if (TrackIsInactive(*stream_track_)) {
    resolver->Reject(DOMException::Create(
        kInvalidStateError, "The associated Track is in an invalid state."));
    return promise;
  }

  if (!service_) {
    resolver->Reject(DOMException::Create(kNotFoundError, kNoServiceError));
    return promise;
  }
  service_requests_.insert(resolver);

  auto settings = media::mojom::blink::PhotoSettings::New();

  settings->has_height = photo_settings.hasImageHeight();
  if (settings->has_height) {
    const double height = photo_settings.imageHeight();
    if (photo_capabilities_ &&
        (height < photo_capabilities_->imageHeight()->min() ||
         height > photo_capabilities_->imageHeight()->max())) {
      resolver->Reject(DOMException::Create(
          kNotSupportedError, "imageHeight setting out of range"));
      return promise;
    }
    settings->height = height;
  }
  settings->has_width = photo_settings.hasImageWidth();
  if (settings->has_width) {
    const double width = photo_settings.imageWidth();
    if (photo_capabilities_ &&
        (width < photo_capabilities_->imageWidth()->min() ||
         width > photo_capabilities_->imageWidth()->max())) {
      resolver->Reject(DOMException::Create(kNotSupportedError,
                                            "imageWidth setting out of range"));
      return promise;
    }
    settings->width = width;
  }

  settings->has_red_eye_reduction = photo_settings.hasRedEyeReduction();
  if (settings->has_red_eye_reduction) {
    if (photo_capabilities_ &&
        !photo_capabilities_->IsRedEyeReductionControllable()) {
      resolver->Reject(DOMException::Create(
          kNotSupportedError, "redEyeReduction is not controllable."));
      return promise;
    }
    settings->red_eye_reduction = photo_settings.redEyeReduction();
  }

  settings->has_fill_light_mode = photo_settings.hasFillLightMode();
  if (settings->has_fill_light_mode) {
    const String fill_light_mode = photo_settings.fillLightMode();
    if (photo_capabilities_ && photo_capabilities_->fillLightMode().Find(
                                   fill_light_mode) == kNotFound) {
      resolver->Reject(DOMException::Create(kNotSupportedError,
                                            "Unsupported fillLightMode"));
      return promise;
    }
    settings->fill_light_mode = ParseFillLightMode(fill_light_mode);
  }

  auto resolver_cb =
      WTF::Bind(&ImageCapture::ResolveWithNothing, WrapPersistent(this));

  service_->SetOptions(
      stream_track_->Component()->Source()->Id(), std::move(settings),
      ConvertToBaseCallback(
          WTF::Bind(&ImageCapture::OnMojoSetOptions, WrapPersistent(this),
                    WrapPersistent(resolver),
                    WTF::Passed(std::move(resolver_cb)), trigger_take_photo)));
  return promise;
}

void ImageCapture::OnServiceConnectionError() {
  service_.reset();
  for (ScriptPromiseResolver* resolver : service_requests_)
    resolver->Reject(DOMException::Create(kNotFoundError, kNoServiceError));
  service_requests_.clear();
}

ScriptPromise ImageCapture::grabFrame(ScriptState* script_state) {
  ScriptPromiseResolver* resolver = ScriptPromiseResolver::Create(script_state);
  ScriptPromise promise = resolver->Promise();

  if (TrackIsInactive(*stream_track_)) {
    resolver->Reject(DOMException::Create(
        kInvalidStateError, "The associated Track is in an invalid state."));
    return promise;
  }

  if (!frame_grabber_) {
    frame_grabber_ = Platform::Current()->CreateImageCaptureFrameGrabber();
  }

  if (!frame_grabber_) {
    resolver->Reject(DOMException::Create(
        kUnknownError, "Couldn't create platform resources"));
    return promise;
  }

  WebMediaStreamTrack track(stream_track_->Component());
  frame_grabber_->GrabFrame(
      &track, new CallbackPromiseAdapter<ImageBitmap, void>(resolver));

  return promise;
}

void ImageCapture::GetMediaTrackSettings(MediaTrackSettings& settings) const {

  if (settings_.hasWhiteBalanceMode())
    settings.setWhiteBalanceMode(settings_.whiteBalanceMode());
  if (settings_.hasExposureMode())
    settings.setExposureMode(settings_.exposureMode());
  if (settings_.hasFocusMode())
    settings.setFocusMode(settings_.focusMode());

  if (settings_.hasPointsOfInterest() &&
      !settings_.pointsOfInterest().IsEmpty()) {
    settings.setPointsOfInterest(settings_.pointsOfInterest());
  }

  if (settings_.hasExposureCompensation())
    settings.setExposureCompensation(settings_.exposureCompensation());
  if (settings_.hasColorTemperature())
    settings.setColorTemperature(settings_.colorTemperature());
  if (settings_.hasIso())
    settings.setIso(settings_.iso());

  if (settings_.hasBrightness())
    settings.setBrightness(settings_.brightness());
  if (settings_.hasContrast())
    settings.setContrast(settings_.contrast());
  if (settings_.hasSaturation())
    settings.setSaturation(settings_.saturation());
  if (settings_.hasSharpness())
    settings.setSharpness(settings_.sharpness());

  if (settings_.hasZoom())
    settings.setZoom(settings_.zoom());
  if (settings_.hasTorch())
    settings.setTorch(settings_.torch());
}

ScriptPromise ImageCapture::getPhotoSettings(ScriptState* script_state) {
  ScriptPromiseResolver* resolver = ScriptPromiseResolver::Create(script_state);
  ScriptPromise promise = resolver->Promise();

  if (!service_) {
    resolver->Reject(DOMException::Create(kNotFoundError, kNoServiceError));
    return promise;
  }
  service_requests_.insert(resolver);

  auto resolver_cb =
      WTF::Bind(&ImageCapture::ResolveWithPhotoSettings, WrapPersistent(this));

  service_->GetPhotoState(
      stream_track_->Component()->Source()->Id(),
      ConvertToBaseCallback(WTF::Bind(
          &ImageCapture::OnMojoGetPhotoState, WrapPersistent(this),
          WrapPersistent(resolver), WTF::Passed(std::move(resolver_cb)),
          false /* trigger_take_photo */)));
  return promise;
}

MeteringMode ParseMeteringMode(const String& blink_mode) {
  if (blink_mode == "manual")
    return MeteringMode::MANUAL;
  if (blink_mode == "single-shot")
    return MeteringMode::SINGLE_SHOT;
  if (blink_mode == "continuous")
    return MeteringMode::CONTINUOUS;
  if (blink_mode == "none")
    return MeteringMode::NONE;
  NOTREACHED();
  return MeteringMode::NONE;
}

void ImageCapture::ResolveWithPhotoSettings(ScriptPromiseResolver* resolver) {
  DCHECK(resolver);
  resolver->Resolve(photo_settings_);
}

ImageCapture::ImageCapture(ExecutionContext* context, MediaStreamTrack* track)
    : ContextLifecycleObserver(context), stream_track_(track) {
  DCHECK(stream_track_);
  DCHECK(!service_.is_bound());

  if (!GetFrame())
    return;

  GetFrame()->GetInterfaceProvider().GetInterface(mojo::MakeRequest(&service_));

  service_.set_connection_error_handler(ConvertToBaseCallback(WTF::Bind(
      &ImageCapture::OnServiceConnectionError, WrapWeakPersistent(this))));

  service_->GetPhotoState(
      stream_track_->Component()->Source()->Id(),
      ConvertToBaseCallback(WTF::Bind(
          &ImageCapture::UpdateMediaTrackCapabilities, WrapPersistent(this))));
}

ScriptPromise ImageCapture::takePhoto(ScriptState* script_state,
                                      const PhotoSettings& photo_settings) {
  return setOptions(script_state, photo_settings,
                    true /* trigger_take_photo */);
}

ImageCapture::~ImageCapture() {
  DCHECK(!HasEventListeners());
  DCHECK(service_requests_.IsEmpty());
}

const AtomicString& ImageCapture::InterfaceName() const {
  return EventTargetNames::ImageCapture;
}

ScriptPromise ImageCapture::takePhoto(ScriptState* script_state) {
  ScriptPromiseResolver* resolver = ScriptPromiseResolver::Create(script_state);
  ScriptPromise promise = resolver->Promise();

  if (TrackIsInactive(*stream_track_)) {
    resolver->Reject(DOMException::Create(
        kInvalidStateError, "The associated Track is in an invalid state."));
    return promise;
  }
  if (!service_) {
    resolver->Reject(DOMException::Create(kNotFoundError, kNoServiceError));
    return promise;
  }

  service_requests_.insert(resolver);

  service_->TakePhoto(stream_track_->Component()->Source()->Id(),
                      ConvertToBaseCallback(WTF::Bind(
                          &ImageCapture::OnMojoTakePhoto, WrapPersistent(this),
                          WrapPersistent(resolver))));
  return promise;
}

void ImageCapture::ResolveWithMediaTrackConstraints(
    MediaTrackConstraints constraints,
ScriptPromiseResolver* resolver) {
DCHECK(resolver);
resolver->Resolve(constraints);
}

WebString ToString(MeteringMode value) {
  switch (value) {
    case MeteringMode::NONE:
      return WebString::FromUTF8("none");
    case MeteringMode::MANUAL:
      return WebString::FromUTF8("manual");
    case MeteringMode::SINGLE_SHOT:
      return WebString::FromUTF8("single-shot");
    case MeteringMode::CONTINUOUS:
      return WebString::FromUTF8("continuous");
    default:
      NOTREACHED() << "Unknown MeteringMode";
  }
  return WebString();
}

ImageCapture* ImageCapture::Create(ExecutionContext* context,
                                   MediaStreamTrack* track,
                                   ExceptionState& exception_state) {
  if (track->kind() != "video") {
    exception_state.ThrowDOMException(
        kNotSupportedError,
        "Cannot create an ImageCapturer from a non-video Track.");
    return nullptr;
  }

  return new ImageCapture(context, track);
}

const MediaTrackConstraintSet& ImageCapture::GetMediaTrackConstraints() const {
  return current_constraints_;
}

DEFINE_TRACE(ImageCapture) {
  visitor->Trace(stream_track_);
  visitor->Trace(capabilities_);
  visitor->Trace(settings_);
  visitor->Trace(current_constraints_);
  visitor->Trace(photo_capabilities_);
  visitor->Trace(service_requests_);
  EventTargetWithInlineData::Trace(visitor);
  ContextLifecycleObserver::Trace(visitor);
}

void ImageCapture::ClearMediaTrackConstraints() {
  current_constraints_ = MediaTrackConstraintSet();

}

void ImageCapture::OnMojoGetPhotoState(
    ScriptPromiseResolver* resolver,
    PromiseResolverFunction resolve_function,
    bool trigger_take_photo,
    media::mojom::blink::PhotoStatePtr photo_state) {
  DCHECK(service_requests_.Contains(resolver));

  if (photo_state.is_null()) {
    resolver->Reject(DOMException::Create(kUnknownError, "platform error"));
    service_requests_.erase(resolver);
    return;
  }

  photo_settings_ = PhotoSettings();
  photo_settings_.setImageHeight(photo_state->height->current);
  photo_settings_.setImageWidth(photo_state->width->current);

  photo_capabilities_ = PhotoCapabilities::Create();
  photo_capabilities_->SetRedEyeReduction(photo_state->red_eye_reduction);
  if (photo_state->height->min != 0 || photo_state->height->max != 0) {
    photo_capabilities_->SetImageHeight(
        MediaSettingsRange::Create(std::move(photo_state->height)));
  }
  if (photo_state->width->min != 0 || photo_state->width->max != 0) {
    photo_capabilities_->SetImageWidth(
        MediaSettingsRange::Create(std::move(photo_state->width)));
  }
  if (!photo_state->fill_light_mode.IsEmpty())
    photo_capabilities_->SetFillLightMode(photo_state->fill_light_mode);

  UpdateMediaTrackCapabilities(std::move(photo_state));

  if (trigger_take_photo) {
    service_->TakePhoto(stream_track_->Component()->Source()->Id(),
                        ConvertToBaseCallback(WTF::Bind(
                            &ImageCapture::OnMojoTakePhoto,
                            WrapPersistent(this), WrapPersistent(resolver))));
    return;
  }

  resolve_function(resolver);
  service_requests_.erase(resolver);
}
