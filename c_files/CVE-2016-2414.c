void SparseBitSet::clear() {
    mMaxVal = 0;
    mIndices.reset();
    mBitmaps.reset();
}

void SparseBitSet::initFromRanges(const uint32_t* ranges, size_t nRanges) {
 if (nRanges == 0) {
        mMaxVal = 0;
        mIndices.reset();
        mBitmaps.reset();
 return;
 }
    mMaxVal = ranges[nRanges * 2 - 1];
 size_t indexSize = (mMaxVal + kPageMask) >> kLogValuesPerPage;
    mIndices.reset(new uint32_t[indexSize]);
 uint32_t nPages = calcNumPages(ranges, nRanges);
    mBitmaps.reset(new element[nPages << (kLogValuesPerPage - kLogBitsPerEl)]);
    memset(mBitmaps.get(), 0, nPages << (kLogValuesPerPage - 3));
    mZeroPageIndex = noZeroPage;
 uint32_t nonzeroPageEnd = 0;
 uint32_t currentPage = 0;

     for (size_t i = 0; i < nRanges; i++) {
         uint32_t start = ranges[i * 2];
         uint32_t end = ranges[i * 2 + 1];
         uint32_t startPage = start >> kLogValuesPerPage;
         uint32_t endPage = (end - 1) >> kLogValuesPerPage;
         if (startPage >= nonzeroPageEnd) {
 if (startPage > nonzeroPageEnd) {
 if (mZeroPageIndex == noZeroPage) {
                    mZeroPageIndex = (currentPage++) << (kLogValuesPerPage - kLogBitsPerEl);
 }
 for (uint32_t j = nonzeroPageEnd; j < startPage; j++) {
                    mIndices[j] = mZeroPageIndex;
 }
 }
            mIndices[startPage] = (currentPage++) << (kLogValuesPerPage - kLogBitsPerEl);
 }

 size_t index = ((currentPage - 1) << (kLogValuesPerPage - kLogBitsPerEl)) +
 ((start & kPageMask) >> kLogBitsPerEl);
 size_t nElements = (end - (start & ~kElMask) + kElMask) >> kLogBitsPerEl;
 if (nElements == 1) {
            mBitmaps[index] |= (kElAllOnes >> (start & kElMask)) &
 (kElAllOnes << ((-end) & kElMask));
 } else {
            mBitmaps[index] |= kElAllOnes >> (start & kElMask);
 for (size_t j = 1; j < nElements - 1; j++) {
                mBitmaps[index + j] = kElAllOnes;
 }
            mBitmaps[index + nElements - 1] |= kElAllOnes << ((-end) & kElMask);
 }
 for (size_t j = startPage + 1; j < endPage + 1; j++) {
            mIndices[j] = (currentPage++) << (kLogValuesPerPage - kLogBitsPerEl);
 }
        nonzeroPageEnd = endPage + 1;
 }
}

static uint32_t readU16(const uint8_t* data, size_t offset) {
 return ((uint32_t)data[offset]) << 8 | ((uint32_t)data[offset + 1]);
}

bool CmapCoverage::getCoverage(SparseBitSet& coverage, const uint8_t* cmap_data, size_t cmap_size) {
 vector<uint32_t> coverageVec;
 const size_t kHeaderSize = 4;
 const size_t kNumTablesOffset = 2;
 const size_t kTableSize = 8;
 const size_t kPlatformIdOffset = 0;
 const size_t kEncodingIdOffset = 2;
 const size_t kOffsetOffset = 4;
 const uint16_t kMicrosoftPlatformId = 3;
 const uint16_t kUnicodeBmpEncodingId = 1;
 const uint16_t kUnicodeUcs4EncodingId = 10;
 const uint32_t kNoTable = UINT32_MAX;
 if (kHeaderSize > cmap_size) {
 return false;
 }
 uint32_t numTables = readU16(cmap_data, kNumTablesOffset);
 if (kHeaderSize + numTables * kTableSize > cmap_size) {
 return false;
 }
 uint32_t bestTable = kNoTable;
 for (uint32_t i = 0; i < numTables; i++) {
 uint16_t platformId = readU16(cmap_data, kHeaderSize + i * kTableSize + kPlatformIdOffset);
 uint16_t encodingId = readU16(cmap_data, kHeaderSize + i * kTableSize + kEncodingIdOffset);
 if (platformId == kMicrosoftPlatformId && encodingId == kUnicodeUcs4EncodingId) {
            bestTable = i;
 break;
 } else if (platformId == kMicrosoftPlatformId && encodingId == kUnicodeBmpEncodingId) {
            bestTable = i;
 }
 }
#ifdef VERBOSE_DEBUG
    ALOGD("best table = %d\n", bestTable);
#endif
 if (bestTable == kNoTable) {
 return false;
 }
 uint32_t offset = readU32(cmap_data, kHeaderSize + bestTable * kTableSize + kOffsetOffset);
 if (offset > cmap_size - 2) {
 return false;
 }
 uint16_t format = readU16(cmap_data, offset);
 bool success = false;
 const uint8_t* tableData = cmap_data + offset;
 const size_t tableSize = cmap_size - offset;
 if (format == 4) {
        success = getCoverageFormat4(coverageVec, tableData, tableSize);
 } else if (format == 12) {
        success = getCoverageFormat12(coverageVec, tableData, tableSize);
 }
 if (success) {
        coverage.initFromRanges(&coverageVec.front(), coverageVec.size() >> 1);
 }
#ifdef VERBOSE_DEBUG
 for (size_t i = 0; i < coverageVec.size(); i += 2) {
        ALOGD("%x:%x\n", coverageVec[i], coverageVec[i + 1]);
 }
    ALOGD("success = %d", success);
#endif
 return success;
}

static bool getCoverageFormat12(vector<uint32_t>& coverage, const uint8_t* data, size_t size) {
 const size_t kNGroupsOffset = 12;
 const size_t kFirstGroupOffset = 16;
 const size_t kGroupSize = 12;
 const size_t kStartCharCodeOffset = 0;
 const size_t kEndCharCodeOffset = 4;
 const size_t kMaxNGroups = 0xfffffff0 / kGroupSize; // protection against overflow
 if (kFirstGroupOffset > size) {
 return false;

     }
     uint32_t nGroups = readU32(data, kNGroupsOffset);
     if (nGroups >= kMaxNGroups || kFirstGroupOffset + nGroups * kGroupSize > size) {
         return false;
     }
     for (uint32_t i = 0; i < nGroups; i++) {
 uint32_t groupOffset = kFirstGroupOffset + i * kGroupSize;
 uint32_t start = readU32(data, groupOffset + kStartCharCodeOffset);

         uint32_t end = readU32(data, groupOffset + kEndCharCodeOffset);
         if (end < start) {
             return false;
         }
         addRange(coverage, start, end + 1);  // file is inclusive, vector is exclusive
 }
 return true;
}

bool CmapCoverage::getCoverage(SparseBitSet& coverage, const uint8_t* cmap_data, size_t cmap_size) {
vector<uint32_t> coverageVec;
const size_t kHeaderSize = 4;
const size_t kNumTablesOffset = 2;
const size_t kTableSize = 8;

const size_t kPlatformIdOffset = 0;
const size_t kEncodingIdOffset = 2;
const size_t kOffsetOffset = 4;
    const int kMicrosoftPlatformId = 3;
    const int kUnicodeBmpEncodingId = 1;
    const int kUnicodeUcs4EncodingId = 10;
if (kHeaderSize > cmap_size) {
return false;
}
    int numTables = readU16(cmap_data, kNumTablesOffset);
if (kHeaderSize + numTables * kTableSize > cmap_size) {
return false;
}
    int bestTable = -1;
    for (int i = 0; i < numTables; i++) {
uint16_t platformId = readU16(cmap_data, kHeaderSize + i * kTableSize + kPlatformIdOffset);
uint16_t encodingId = readU16(cmap_data, kHeaderSize + i * kTableSize + kEncodingIdOffset);
if (platformId == kMicrosoftPlatformId && encodingId == kUnicodeUcs4EncodingId) {
bestTable = i;
break;
} else if (platformId == kMicrosoftPlatformId && encodingId == kUnicodeBmpEncodingId) {
bestTable = i;
}
}

#ifdef PRINTF_DEBUG
printf("best table = %d\n", bestTable);
#endif
    if (bestTable < 0) {
return false;
}
uint32_t offset = readU32(cmap_data, kHeaderSize + bestTable * kTableSize + kOffsetOffset);
    if (offset + 2 > cmap_size) {
return false;
}
uint16_t format = readU16(cmap_data, offset);
bool success = false;
const uint8_t* tableData = cmap_data + offset;
const size_t tableSize = cmap_size - offset;
if (format == 4) {
success = getCoverageFormat4(coverageVec, tableData, tableSize);
} else if (format == 12) {
success = getCoverageFormat12(coverageVec, tableData, tableSize);
}
if (success) {
coverage.initFromRanges(&coverageVec.front(), coverageVec.size() >> 1);
}
#ifdef PRINTF_DEBUG
for (int i = 0; i < coverageVec.size(); i += 2) {
printf("%x:%x\n", coverageVec[i], coverageVec[i + 1]);
}
#endif
return success;
}

static void addRange(vector<uint32_t> &coverage, uint32_t start, uint32_t end) {
#ifdef VERBOSE_DEBUG
    ALOGD("adding range %d-%d\n", start, end);
#endif
 if (coverage.empty() || coverage.back() < start) {
        coverage.push_back(start);
        coverage.push_back(end);
 } else {
        coverage.back() = end;
 }
}

static bool getCoverageFormat4(vector<uint32_t>& coverage, const uint8_t* data, size_t size) {
const size_t kSegCountOffset = 6;
const size_t kEndCountOffset = 14;
const size_t kHeaderSize = 16;
const size_t kSegmentSize = 8; // total size of array elements for one segment
if (kEndCountOffset > size) {
return false;
}
size_t segCount = readU16(data, kSegCountOffset) >> 1;
if (kHeaderSize + segCount * kSegmentSize > size) {

return false;
}
for (size_t i = 0; i < segCount; i++) {
        int end = readU16(data, kEndCountOffset + 2 * i);
        int start = readU16(data, kHeaderSize + 2 * (segCount + i));
        int rangeOffset = readU16(data, kHeaderSize + 2 * (3 * segCount + i));
if (rangeOffset == 0) {
            int delta = readU16(data, kHeaderSize + 2 * (2 * segCount + i));
if (((end + delta) & 0xffff) > end - start) {
addRange(coverage, start, end + 1);
} else {
                for (int j = start; j < end + 1; j++) {
if (((j + delta) & 0xffff) != 0) {
addRange(coverage, j, j + 1);
}
}
}
} else {
            for (int j = start; j < end + 1; j++) {
uint32_t actualRangeOffset = kHeaderSize + 6 * segCount + rangeOffset +
(i + j - start) * 2;
if (actualRangeOffset + 2 > size) {
return false;
}
                int glyphId = readU16(data, actualRangeOffset);
if (glyphId != 0) {
addRange(coverage, j, j + 1);
}
}
}
}
return true;
}

static uint32_t readU32(const uint8_t* data, size_t offset) {
 return ((uint32_t)data[offset]) << 24 | ((uint32_t)data[offset + 1]) << 16 |
 ((uint32_t)data[offset + 2]) << 8 | ((uint32_t)data[offset + 3]);
}

int SparseBitSet::CountLeadingZeros(element x) {
 return sizeof(element) <= sizeof(int) ? __builtin_clz(x) : __builtin_clzl(x);
}

static bool getCoverageFormat12(vector<uint32_t>& coverage, const uint8_t* data, size_t size) {
 const size_t kNGroupsOffset = 12;
 const size_t kFirstGroupOffset = 16;
 const size_t kGroupSize = 12;
 const size_t kStartCharCodeOffset = 0;
 const size_t kEndCharCodeOffset = 4;
 const size_t kMaxNGroups = 0xfffffff0 / kGroupSize; // protection against overflow
 if (kFirstGroupOffset > size) {
 return false;
 }
 uint32_t nGroups = readU32(data, kNGroupsOffset);
 if (nGroups >= kMaxNGroups || kFirstGroupOffset + nGroups * kGroupSize > size) {
 return false;
 }
 for (uint32_t i = 0; i < nGroups; i++) {

         uint32_t groupOffset = kFirstGroupOffset + i * kGroupSize;
         uint32_t start = readU32(data, groupOffset + kStartCharCodeOffset);
         uint32_t end = readU32(data, groupOffset + kEndCharCodeOffset);
         addRange(coverage, start, end + 1);  // file is inclusive, vector is exclusive
     }
     return true;
}

uint32_t SparseBitSet::calcNumPages(const uint32_t* ranges, size_t nRanges) {
 bool haveZeroPage = false;
 uint32_t nonzeroPageEnd = 0;
 uint32_t nPages = 0;
 for (size_t i = 0; i < nRanges; i++) {
 uint32_t start = ranges[i * 2];
 uint32_t end = ranges[i * 2 + 1];
 uint32_t startPage = start >> kLogValuesPerPage;
 uint32_t endPage = (end - 1) >> kLogValuesPerPage;
 if (startPage >= nonzeroPageEnd) {
 if (startPage > nonzeroPageEnd) {
 if (!haveZeroPage) {
                    haveZeroPage = true;
                    nPages++;
 }
 }
            nPages++;
 }
        nPages += endPage - startPage;
        nonzeroPageEnd = endPage + 1;
 }
 return nPages;
}
