static int validate_and_calculate_camera_metadata_entry_data_size(size_t *data_size, uint8_t type,
 size_t data_count) {
 if (type >= NUM_TYPES) return ERROR;

 if (data_count != 0 &&
            camera_metadata_type_size[type] > (SIZE_MAX - DATA_ALIGNMENT + 1) / data_count) {
        android_errorWriteLog(SN_EVENT_LOG_ID, "30741779");
 return ERROR;
 }

 size_t data_bytes = data_count * camera_metadata_type_size[type];

 if (data_size) {
 *data_size = data_bytes <= 4 ? 0 : ALIGN_TO(data_bytes, DATA_ALIGNMENT);
 }

 return OK;
}

camera_metadata_t *clone_camera_metadata(const camera_metadata_t *src) {
 int res;
 if (src == NULL) return NULL;
 camera_metadata_t *clone = allocate_camera_metadata(
        get_camera_metadata_entry_count(src),
        get_camera_metadata_data_count(src));
 if (clone != NULL) {
        res = append_camera_metadata(clone, src);
 if (res != OK) {
            free_camera_metadata(clone);
            clone = NULL;
 }
 }
    assert(validate_camera_metadata_structure(clone, NULL) == OK);
 return clone;
}

size_t calculate_camera_metadata_entry_data_size(uint8_t type,
 size_t data_count) {
 if (type >= NUM_TYPES) return 0;

 size_t data_bytes = data_count *
            camera_metadata_type_size[type];

 return data_bytes <= 4 ? 0 : ALIGN_TO(data_bytes, DATA_ALIGNMENT);
}

int append_camera_metadata(camera_metadata_t *dst,

         const camera_metadata_t *src) {
     if (dst == NULL || src == NULL ) return ERROR;
 
     if (dst->entry_capacity < src->entry_count + dst->entry_count) return ERROR;
     if (dst->data_capacity < src->data_count + dst->data_count) return ERROR;
 
    memcpy(get_entries(dst) + dst->entry_count, get_entries(src),
 sizeof(camera_metadata_buffer_entry_t[src->entry_count]));
    memcpy(get_data(dst) + dst->data_count, get_data(src),
 sizeof(uint8_t[src->data_count]));
 if (dst->data_count != 0) {
 camera_metadata_buffer_entry_t *entry = get_entries(dst) + dst->entry_count;
 for (size_t i = 0; i < src->entry_count; i++, entry++) {
 if ( calculate_camera_metadata_entry_data_size(entry->type,
                            entry->count) > 0 ) {
                entry->data.offset += dst->data_count;
 }
 }
 }
 if (dst->entry_count == 0) {
        dst->flags |= src->flags & FLAG_SORTED;
 } else if (src->entry_count != 0) {
        dst->flags &= ~FLAG_SORTED;
 } else {
 }
    dst->entry_count += src->entry_count;
    dst->data_count += src->data_count;

    assert(validate_camera_metadata_structure(dst, NULL) == OK);
 return OK;
}

camera_metadata_t* copy_camera_metadata(void *dst, size_t dst_size,
 const camera_metadata_t *src) {
 size_t memory_needed = get_camera_metadata_compact_size(src);

 if (dst == NULL) return NULL;
 if (dst_size < memory_needed) return NULL;

 camera_metadata_t *metadata =
        place_camera_metadata(dst, dst_size, src->entry_count, src->data_count);

    metadata->flags = src->flags;
    metadata->entry_count = src->entry_count;
    metadata->data_count = src->data_count;

    memcpy(get_entries(metadata), get_entries(src),
 sizeof(camera_metadata_buffer_entry_t[metadata->entry_count]));
    memcpy(get_data(metadata), get_data(src),
 sizeof(uint8_t[metadata->data_count]));

    assert(validate_camera_metadata_structure(metadata, NULL) == OK);
 return metadata;
}
