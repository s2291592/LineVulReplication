static bool hal_open() {
  LOG_INFO("%s", __func__);

 int number_of_ports = vendor->send_command(VENDOR_OPEN_USERIAL, &uart_fds);

 if (number_of_ports != 2 && number_of_ports != 4) {
    LOG_ERROR("%s opened the wrong number of ports: got %d, expected 2 or 4.", __func__, number_of_ports);
 goto error;
 }

  LOG_INFO("%s got uart fds: CMD=%d, EVT=%d, ACL_OUT=%d, ACL_IN=%d",
      __func__, uart_fds[CH_CMD], uart_fds[CH_EVT], uart_fds[CH_ACL_OUT], uart_fds[CH_ACL_IN]);

 if (uart_fds[CH_CMD] == INVALID_FD) {
    LOG_ERROR("%s unable to open the command uart serial port.", __func__);
 goto error;
 }

 if (uart_fds[CH_EVT] == INVALID_FD) {
    LOG_ERROR("%s unable to open the event uart serial port.", __func__);
 goto error;
 }

 if (uart_fds[CH_ACL_OUT] == INVALID_FD) {
    LOG_ERROR("%s unable to open the acl-out uart serial port.", __func__);
 goto error;
 }

 if (uart_fds[CH_ACL_IN] == INVALID_FD) {
    LOG_ERROR("%s unable to open the acl-in uart serial port.", __func__);
 goto error;
 }

  event_stream = eager_reader_new(uart_fds[CH_EVT], &allocator_malloc, HCI_HAL_SERIAL_BUFFER_SIZE, SIZE_MAX, "hci_mct");
 if (!event_stream) {
    LOG_ERROR("%s unable to create eager reader for the event uart serial port.", __func__);
 goto error;
 }

  acl_stream = eager_reader_new(uart_fds[CH_ACL_IN], &allocator_malloc, HCI_HAL_SERIAL_BUFFER_SIZE, SIZE_MAX, "hci_mct");
 if (!event_stream) {
    LOG_ERROR("%s unable to create eager reader for the acl-in uart serial port.", __func__);
 goto error;
 }

  eager_reader_register(event_stream, thread_get_reactor(thread), event_event_stream_has_bytes, NULL);
  eager_reader_register(acl_stream, thread_get_reactor(thread), event_acl_stream_has_bytes, NULL);

 return true;

error:;
  interface.close();
 return false;
}

void *atomic_thread(void *context) {
struct atomic_test_s32_s *at = (struct atomic_test_s32_s *)context;
for (int i = 0; i < at->max_val; i++) {
    usleep(1);
atomic_inc_prefix_s32(&at->data[i]);
}
return NULL;
}

const config_section_node_t *config_section_end(const config_t *config) {
  assert(config != NULL);
 return (const config_section_node_t *)list_end(config->sections);
}

static char * adev_get_parameters(const struct audio_hw_device *dev,
 const char *keys)
{
 struct str_parms *parms;
    UNUSED(dev);

    FNLOG();

    parms = str_parms_create_str(keys);

    str_parms_dump(parms);

    str_parms_destroy(parms);

 return strdup("");
}

static int create_server_sdp_record(rfc_slot_t *slot) {
 if(slot->scn == 0) {
 return false;
 }
  slot->sdp_handle = add_rfc_sdp_rec(slot->service_name, slot->service_uuid, slot->scn);
 return (slot->sdp_handle > 0);
}

static int out_get_presentation_position(const struct audio_stream_out *stream,
 uint64_t *frames, struct timespec *timestamp)
{
 struct a2dp_stream_out *out = (struct a2dp_stream_out *)stream;

    FNLOG();
 if (stream == NULL || frames == NULL || timestamp == NULL)
 return -EINVAL;

 int ret = -EWOULDBLOCK;
    pthread_mutex_lock(&out->common.lock);
 uint64_t latency_frames = (uint64_t)out_get_latency(stream) * out->common.cfg.rate / 1000;
 if (out->frames_presented >= latency_frames) {
 *frames = out->frames_presented - latency_frames;
        clock_gettime(CLOCK_MONOTONIC, timestamp); // could also be associated with out_write().
        ret = 0;
 }
    pthread_mutex_unlock(&out->common.lock);
 return ret;
}

bt_status_t btif_get_remote_service_record(bt_bdaddr_t *remote_addr,
 bt_uuid_t *uuid)
{
 if (!btif_is_enabled())
 return BT_STATUS_NOT_READY;

 return btif_dm_get_remote_service_record(remote_addr, uuid);
}

static bt_status_t register_application(bthl_reg_param_t *p_reg_param, int *app_id){
 btif_hl_app_cb_t *p_acb;
    tBTA_HL_SUP_FEATURE         *p_sup;
    tBTA_HL_MDEP_CFG            *p_cfg;
    tBTA_HL_MDEP_DATA_TYPE_CFG  *p_data;
    UINT8                       app_idx=0, i=0;
 bthl_mdep_cfg_t *p_mdep_cfg;
 bt_status_t                 status = BT_STATUS_SUCCESS;
 btif_hl_evt_cb_t            evt_param;
 int                         len;

    CHECK_BTHL_INIT();
    BTIF_TRACE_EVENT("%s", __FUNCTION__);
    btif_hl_display_calling_process_name();

 if (btif_hl_get_state() == BTIF_HL_STATE_DISABLED)
 {
        btif_hl_init();
        btif_hl_set_state(BTIF_HL_STATE_ENABLING);
        BTA_HlEnable(btif_hl_ctrl_cback);
 }

 if (!btif_hl_find_avail_app_idx(&app_idx))
 {
        BTIF_TRACE_ERROR("Unable to allocate a new application control block");
 return BT_STATUS_FAIL;
 }

    p_acb = BTIF_HL_GET_APP_CB_PTR(app_idx);
    p_acb->in_use = TRUE;


    p_acb->app_id = btif_hl_get_next_app_id();

 if (p_reg_param->application_name != NULL )
        strncpy(p_acb->application_name, p_reg_param->application_name, BTIF_HL_APPLICATION_NAME_LEN);

 if (p_reg_param->provider_name != NULL )
        strncpy(p_acb->provider_name, p_reg_param->provider_name, BTA_PROVIDER_NAME_LEN);

 if (p_reg_param->srv_name != NULL )
        strncpy(p_acb->srv_name, p_reg_param->srv_name, BTA_SERVICE_NAME_LEN);

 if (p_reg_param->srv_desp != NULL )
        strncpy(p_acb->srv_desp, p_reg_param->srv_desp, BTA_SERVICE_DESP_LEN);

    p_sup = &p_acb->sup_feature;
    p_sup->advertize_source_sdp = TRUE;
    p_sup->echo_cfg.max_rx_apdu_size = BTIF_HL_ECHO_MAX_TX_RX_APDU_SIZE;
    p_sup->echo_cfg.max_tx_apdu_size = BTIF_HL_ECHO_MAX_TX_RX_APDU_SIZE;
    p_sup->num_of_mdeps = p_reg_param->number_of_mdeps;

 for (i=0, p_mdep_cfg = p_reg_param->mdep_cfg ; i<  p_sup->num_of_mdeps; i++, p_mdep_cfg++ )
 {
        p_cfg = &p_sup->mdep[i].mdep_cfg;
        p_cfg->num_of_mdep_data_types = 1;
        p_data  = &p_cfg->data_cfg[0];

 if ( !btif_hl_get_bta_mdep_role(p_mdep_cfg->mdep_role, &(p_cfg->mdep_role)))
 {
            BTIF_TRACE_ERROR("Invalid mdep_role=%d", p_mdep_cfg->mdep_role);
            status = BT_STATUS_FAIL;
 break;
 }
 else
 {
 if (p_cfg->mdep_role == BTA_HL_MDEP_ROLE_SINK )
                p_sup->app_role_mask |= BTA_HL_MDEP_ROLE_MASK_SINK;
 else
                p_sup->app_role_mask |=  BTA_HL_MDEP_ROLE_MASK_SOURCE;

 if ( (p_sup->app_role_mask & BTA_HL_MDEP_ROLE_MASK_SINK) &&
 (p_sup->app_role_mask & BTA_HL_MDEP_ROLE_MASK_SINK) )
 {
                p_acb->dev_type = BTA_HL_DEVICE_TYPE_DUAL;
 }
 else if ( p_sup->app_role_mask & BTA_HL_MDEP_ROLE_MASK_SINK )
                p_acb->dev_type = BTA_HL_DEVICE_TYPE_SINK;
 else

                p_acb->dev_type = BTA_HL_DEVICE_TYPE_SOURCE;

            p_data->data_type = (UINT16) p_mdep_cfg->data_type;
            p_data->max_rx_apdu_size = btif_hl_get_max_rx_apdu_size(p_cfg->mdep_role, p_data->data_type);
            p_data->max_tx_apdu_size = btif_hl_get_max_tx_apdu_size(p_cfg->mdep_role, p_data->data_type);

 if (p_mdep_cfg->mdep_description != NULL )
                strncpy(p_data->desp, p_mdep_cfg->mdep_description, BTA_SERVICE_DESP_LEN);

 if ( !btif_hl_get_bta_channel_type(p_mdep_cfg->channel_type, &(p_acb->channel_type[i])))
 {
                BTIF_TRACE_ERROR("Invalid channel_type=%d", p_mdep_cfg->channel_type);
                status = BT_STATUS_FAIL;
 break;
 }
 }
 }

 if (status == BT_STATUS_SUCCESS)
 {
 *app_id = (int) p_acb->app_id;
        evt_param.reg.app_idx = app_idx;
        len = sizeof(btif_hl_reg_t);
        p_acb->reg_pending = TRUE;
        reg_counter++;
        BTIF_TRACE_DEBUG("calling btif_transfer_context status=%d app_id=%d", status, *app_id);
        status = btif_transfer_context (btif_hl_proc_cb_evt, BTIF_HL_REG_APP,
 (char*) &evt_param, len, NULL);
        ASSERTC(status == BT_STATUS_SUCCESS, "context transfer failed", status);

 }
 else
 {
        btif_hl_free_app_idx(app_idx);
 }

    BTIF_TRACE_DEBUG("register_application status=%d app_id=%d", status, *app_id);
 return status;
}

static void btif_hl_disable(void){
    BTIF_TRACE_DEBUG("%s", __FUNCTION__);

 if ((p_btif_hl_cb->state != BTIF_HL_STATE_DISABLING) &&
 (p_btif_hl_cb->state != BTIF_HL_STATE_DISABLED))
 {
        btif_hl_set_state(BTIF_HL_STATE_DISABLING);
        BTA_HlDisable();
 }
}

bt_status_t btsock_rfc_connect(const bt_bdaddr_t *bd_addr, const uint8_t *service_uuid, int channel, int *sock_fd, int flags) {
  assert(sock_fd != NULL);
  assert(service_uuid != NULL || (channel >= 1 && channel <= MAX_RFC_CHANNEL));

 *sock_fd = INVALID_FD;

 if (!is_init_done())
 return BT_STATUS_NOT_READY;

 int status = BT_STATUS_FAIL;
  pthread_mutex_lock(&slot_lock);

 rfc_slot_t *slot = alloc_rfc_slot(bd_addr, NULL, service_uuid, channel, flags, false);
 if (!slot) {
    LOG_ERROR("%s unable to allocate RFCOMM slot.", __func__);
 goto out;
 }

 if (is_uuid_empty(service_uuid)) {
    tBTA_JV_STATUS ret = BTA_JvRfcommConnect(slot->security, slot->role, slot->scn, slot->addr.address, rfcomm_cback, (void *)(uintptr_t)slot->id);
 if (ret != BTA_JV_SUCCESS) {
      LOG_ERROR("%s unable to initiate RFCOMM connection: %d", __func__, ret);
      cleanup_rfc_slot(slot);
 goto out;
 }

 if (!send_app_scn(slot)) {
      LOG_ERROR("%s unable to send channel number.", __func__);
      cleanup_rfc_slot(slot);
 goto out;
 }
 } else {
    tSDP_UUID sdp_uuid;
    sdp_uuid.len = 16;
    memcpy(sdp_uuid.uu.uuid128, service_uuid, sizeof(sdp_uuid.uu.uuid128));

 if (!is_requesting_sdp()) {
      BTA_JvStartDiscovery((uint8_t *)bd_addr->address, 1, &sdp_uuid, (void *)(uintptr_t)slot->id);
      slot->f.pending_sdp_request = false;
      slot->f.doing_sdp_request = true;
 } else {
      slot->f.pending_sdp_request = true;
      slot->f.doing_sdp_request = false;
 }
 }

 *sock_fd = slot->app_fd; // Transfer ownership of fd to caller.
  slot->app_fd = INVALID_FD; // Drop our reference to the fd.
  btsock_thread_add_fd(pth, slot->fd, BTSOCK_RFCOMM, SOCK_THREAD_FD_RD, slot->id);
  status = BT_STATUS_SUCCESS;

out:;
  pthread_mutex_unlock(&slot_lock);
 return status;
}

static bt_status_t set_info (bt_bdaddr_t *bd_addr, bthh_hid_info_t hid_info )
{
    CHECK_BTHH_INIT();
    tBTA_HH_DEV_DSCP_INFO dscp_info;
    BD_ADDR* bda = (BD_ADDR*) bd_addr;

    BTIF_TRACE_DEBUG("addr = %02X:%02X:%02X:%02X:%02X:%02X",
 (*bda)[0], (*bda)[1], (*bda)[2], (*bda)[3], (*bda)[4], (*bda)[5]);
    BTIF_TRACE_DEBUG("%s: sub_class = 0x%02x, app_id = %d, vendor_id = 0x%04x, "
 "product_id = 0x%04x, version= 0x%04x",
         __FUNCTION__, hid_info.sub_class,
         hid_info.app_id, hid_info.vendor_id, hid_info.product_id,
         hid_info.version);

 if (btif_hh_cb.status == BTIF_HH_DISABLED)
 {
        BTIF_TRACE_ERROR("%s: Error, HH status = %d", __FUNCTION__, btif_hh_cb.status);
 return BT_STATUS_FAIL;
 }

    dscp_info.vendor_id  = hid_info.vendor_id;
    dscp_info.product_id = hid_info.product_id;
    dscp_info.version    = hid_info.version;
    dscp_info.ctry_code  = hid_info.ctry_code;

    dscp_info.descriptor.dl_len = hid_info.dl_len;
    dscp_info.descriptor.dsc_list = (UINT8 *) GKI_getbuf(dscp_info.descriptor.dl_len);
 if (dscp_info.descriptor.dsc_list == NULL)
 {
        LOG_ERROR("%s: Failed to allocate DSCP for CB", __FUNCTION__);
 return BT_STATUS_FAIL;
 }
    memcpy(dscp_info.descriptor.dsc_list, &(hid_info.dsc_list), hid_info.dl_len);

 if (btif_hh_add_added_dev(*bd_addr, hid_info.attr_mask))
 {
        BTA_HhAddDev(*bda, hid_info.attr_mask, hid_info.sub_class,
                     hid_info.app_id, dscp_info);
 }

    GKI_freebuf(dscp_info.descriptor.dsc_list);

 return BT_STATUS_SUCCESS;
}

static bt_status_t init( bthh_callbacks_t* callbacks )
{
    UINT32 i;
    BTIF_TRACE_EVENT("%s", __FUNCTION__);

    bt_hh_callbacks = callbacks;
    memset(&btif_hh_cb, 0, sizeof(btif_hh_cb));
 for (i = 0; i < BTIF_HH_MAX_HID; i++){
        btif_hh_cb.devices[i].dev_status = BTHH_CONN_STATE_UNKNOWN;
 }
 /* Invoke the enable service API to the core to set the appropriate service_id */
    btif_enable_service(BTA_HID_SERVICE_ID);
 return BT_STATUS_SUCCESS;
}

static void on_rfc_outgoing_congest(tBTA_JV_RFCOMM_CONG *p, uint32_t id) {
  pthread_mutex_lock(&slot_lock);

 rfc_slot_t *slot = find_rfc_slot_by_id(id);
 if (slot) {
    slot->f.outgoing_congest = p->cong ? 1 : 0;
 if (!slot->f.outgoing_congest)
      btsock_thread_add_fd(pth, slot->fd, BTSOCK_RFCOMM, SOCK_THREAD_FD_RD, slot->id);
 }

  pthread_mutex_unlock(&slot_lock);
}

static btif_hl_state_t btif_hl_get_state(void){
    BTIF_TRACE_DEBUG("btif_hl_get_state:  %d   ", p_btif_hl_cb->state);
 return p_btif_hl_cb->state;
}

static void usage(const char *name) {
  printf("Usage: %s <command> [options]\n", name);
  printf("Commands:\n");
 for (size_t i = 0; i < ARRAY_SIZE(commands); ++i)
    printf("  %s\n", commands[i].name);
  printf("For detailed help on a command, run '%s help <command>'.\n", name);
}

int btsock_thread_post_cmd(int h, int type, const unsigned char* data, int size, uint32_t user_id)
{
if(h < 0 || h >= MAX_THREAD)
{
APPL_TRACE_ERROR("invalid bt thread handle:%d", h);
return FALSE;
}
if(ts[h].cmd_fdw == -1)
{
APPL_TRACE_ERROR("cmd socket is not created. socket thread may not initialized");
return FALSE;
}
sock_cmd_t cmd = {CMD_USER_PRIVATE, 0, type, size, user_id};
APPL_TRACE_DEBUG("post cmd type:%d, size:%d, h:%d, ", type, size, h);
sock_cmd_t* cmd_send = &cmd;
int size_send = sizeof(cmd);
if(data && size)
{
size_send = sizeof(cmd) + size;
cmd_send = (sock_cmd_t*)alloca(size_send);
if(cmd_send)
{
*cmd_send = cmd;
memcpy(cmd_send + 1, data, size);
}
else
{
APPL_TRACE_ERROR("alloca failed at h:%d, cmd type:%d, size:%d", h, type, size_send);

return FALSE;
}
}
    return send(ts[h].cmd_fdw, cmd_send, size_send, 0) == size_send;
}

static void uipc_flush_ch_locked(tUIPC_CH_ID ch_id)
{
char buf[UIPC_FLUSH_BUFFER_SIZE];
struct pollfd pfd;
int ret;

pfd.events = POLLIN;
pfd.fd = uipc_main.ch[ch_id].fd;

if (uipc_main.ch[ch_id].fd == UIPC_DISCONNECTED)
{
BTIF_TRACE_EVENT("%s() - fd disconnected. Exiting", __FUNCTION__);
return;
}


while (1)
{
        ret = poll(&pfd, 1, 1);
BTIF_TRACE_VERBOSE("%s() - polling fd %d, revents: 0x%x, ret %d",
__FUNCTION__, pfd.fd, pfd.revents, ret);

if (pfd.revents & (POLLERR|POLLHUP))
{
BTIF_TRACE_EVENT("%s() - POLLERR or POLLHUP. Exiting", __FUNCTION__);
return;
}

if (ret <= 0)
{
BTIF_TRACE_EVENT("%s() - error (%d). Exiting", __FUNCTION__, ret);
return;
}


/* read sufficiently large buffer to ensure flush empties socket faster than
it is getting refilled */
        read(pfd.fd, &buf, UIPC_FLUSH_BUFFER_SIZE);
}
}

static int in_remove_audio_effect(const struct audio_stream *stream, effect_handle_t effect)
{
    UNUSED(stream);
    UNUSED(effect);

    FNLOG();

 return 0;
}

static void set_data_queue(fixed_queue_t *queue) {
  upwards_data_queue = queue;
}

static void uipc_flush_locked(tUIPC_CH_ID ch_id)
{
 if (ch_id >= UIPC_CH_NUM)
 return;

 switch(ch_id)
 {
 case UIPC_CH_ID_AV_CTRL:
            uipc_flush_ch_locked(UIPC_CH_ID_AV_CTRL);
 break;

 case UIPC_CH_ID_AV_AUDIO:
            uipc_flush_ch_locked(UIPC_CH_ID_AV_AUDIO);
 break;
 }
}

UINT8 btif_hl_num_dchs_in_use(UINT8 mcl_handle){

 btif_hl_app_cb_t * p_acb;
 btif_hl_mcl_cb_t *p_mcb;
    UINT8               i,j,x;
    UINT8               cnt=0;

 for (i=0; i<BTA_HL_NUM_APPS; i++)
 {
        BTIF_TRACE_DEBUG("btif_hl_num_dchs:i = %d",i);
        p_acb =BTIF_HL_GET_APP_CB_PTR(i);
 if (p_acb && p_acb->in_use)
 {
 for (j=0; j < BTA_HL_NUM_MCLS ; j++)
 {
 if(p_acb->mcb[j].in_use)
                    BTIF_TRACE_DEBUG("btif_hl_num_dchs:mcb in use j=%d, mcl_handle=%d,mcb handle=%d",
                                        j,mcl_handle, p_acb->mcb[j].mcl_handle);
 if (p_acb->mcb[j].in_use &&
 (p_acb->mcb[j].mcl_handle == mcl_handle))
 {
                    p_mcb = &p_acb->mcb[j];
                    BTIF_TRACE_DEBUG("btif_hl_num_dchs: mcl handle found j =%d",j);
 for (x=0; x < BTA_HL_NUM_MDLS_PER_MCL ; x ++)
 {
 if (p_mcb->mdl[x].in_use)
 {
                            BTIF_TRACE_DEBUG("btif_hl_num_dchs_in_use:found x =%d",x);
                            cnt++;
 }
 }
 }
 }
 }
 }

    BTIF_TRACE_DEBUG("%s dch in use count=%d", __FUNCTION__, cnt);
 return cnt;
}

int btsock_thread_add_fd(int h, int fd, int type, int flags, uint32_t user_id)
{
if(h < 0 || h >= MAX_THREAD)
{
APPL_TRACE_ERROR("invalid bt thread handle:%d", h);
return FALSE;
}
if(ts[h].cmd_fdw == -1)
{
APPL_TRACE_ERROR("cmd socket is not created. socket thread may not initialized");
return FALSE;
}
if(flags & SOCK_THREAD_ADD_FD_SYNC)
{
//must executed in socket poll thread
if(ts[h].thread_id == pthread_self())
{
//cleanup one-time flags
flags &= ~SOCK_THREAD_ADD_FD_SYNC;
add_poll(h, fd, type, flags, user_id);
return TRUE;
}
APPL_TRACE_DEBUG("THREAD_ADD_FD_SYNC is not called in poll thread, fallback to async");

}
sock_cmd_t cmd = {CMD_ADD_FD, fd, type, flags, user_id};
APPL_TRACE_DEBUG("adding fd:%d, flags:0x%x", fd, flags);
    return send(ts[h].cmd_fdw, &cmd, sizeof(cmd), 0) == sizeof(cmd);
}

void handle_rc_disconnect (tBTA_AV_RC_CLOSE *p_rc_close)
{
#if (AVRC_CTLR_INCLUDED == TRUE)
 bt_bdaddr_t rc_addr;
    tBTA_AV_FEAT features;
#endif
    BTIF_TRACE_DEBUG("%s: rc_handle: %d", __FUNCTION__, p_rc_close->rc_handle);
 if ((p_rc_close->rc_handle != btif_rc_cb.rc_handle)
 && (bdcmp(btif_rc_cb.rc_addr, p_rc_close->peer_addr)))
 {
        BTIF_TRACE_ERROR("Got disconnect of unknown device");
 return;
 }

    btif_rc_cb.rc_handle = 0;
    btif_rc_cb.rc_connected = FALSE;
    memset(btif_rc_cb.rc_addr, 0, sizeof(BD_ADDR));
    memset(btif_rc_cb.rc_notif, 0, sizeof(btif_rc_cb.rc_notif));
#if (AVRC_CTLR_INCLUDED == TRUE)
    features = btif_rc_cb.rc_features;
#endif
    btif_rc_cb.rc_features = 0;
    btif_rc_cb.rc_vol_label=MAX_LABEL;
    btif_rc_cb.rc_volume=MAX_VOLUME;
    init_all_transactions();
    close_uinput();
#if (AVRC_CTLR_INCLUDED == TRUE)
    bdcpy(rc_addr.address, btif_rc_cb.rc_addr);
#endif
    memset(btif_rc_cb.rc_addr, 0, sizeof(BD_ADDR));
#if (AVRC_CTLR_INCLUDED == TRUE)
 /* report connection state if device is AVRCP target */
 if (features & BTA_AV_FEAT_RCTG) {
 if (bt_rc_ctrl_callbacks != NULL) {
            HAL_CBACK(bt_rc_ctrl_callbacks, connection_state_cb, FALSE, &rc_addr);
 }
 }
#endif
}

static void btif_hl_upstreams_evt(UINT16 event, char* p_param){
    tBTA_HL *p_data = (tBTA_HL *)p_param;
    UINT8                 app_idx, mcl_idx;
 btif_hl_app_cb_t *p_acb;
 btif_hl_mcl_cb_t *p_mcb = NULL;
 btif_hl_pend_dch_op_t  pending_op;
    BOOLEAN status;

    BTIF_TRACE_DEBUG("%s event %d", __FUNCTION__, event);
    btif_hl_display_calling_process_name();
 switch (event)
 {
 case BTA_HL_REGISTER_CFM_EVT:
            BTIF_TRACE_DEBUG("Rcv BTA_HL_REGISTER_CFM_EVT");
            BTIF_TRACE_DEBUG("app_id=%d app_handle=%d status=%d ",
                              p_data->reg_cfm.app_id,
                              p_data->reg_cfm.app_handle,
                              p_data->reg_cfm.status );

            btif_hl_proc_reg_cfm(p_data);
 break;
 case BTA_HL_SDP_INFO_IND_EVT:
            BTIF_TRACE_DEBUG("Rcv BTA_HL_SDP_INFO_IND_EVT");
            BTIF_TRACE_DEBUG("app_handle=%d ctrl_psm=0x%04x data_psm=0x%04x x_spec=%d mcap_sup_procs=0x%02x",
                              p_data->sdp_info_ind.app_handle,
                              p_data->sdp_info_ind.ctrl_psm,
                              p_data->sdp_info_ind.data_psm,
                              p_data->sdp_info_ind.data_x_spec,
                              p_data->sdp_info_ind.mcap_sup_procs);
 break;

 case BTA_HL_DEREGISTER_CFM_EVT:
            BTIF_TRACE_DEBUG("Rcv BTA_HL_DEREGISTER_CFM_EVT");
            BTIF_TRACE_DEBUG("app_handle=%d status=%d ",
                              p_data->dereg_cfm.app_handle,
                              p_data->dereg_cfm.status );
            btif_hl_proc_dereg_cfm(p_data);
 break;

 case BTA_HL_SDP_QUERY_CFM_EVT:
            BTIF_TRACE_DEBUG("Rcv BTA_HL_SDP_QUERY_CFM_EVT");
            BTIF_TRACE_DEBUG("app_handle=%d app_id =%d,status =%d",
                              p_data->sdp_query_cfm.app_handle,p_data->sdp_query_cfm.app_id,
                              p_data->sdp_query_cfm.status);

            BTIF_TRACE_DEBUG("DB [%02x] [%02x] [%02x] [%02x] [%02x] [%02x]",
                              p_data->sdp_query_cfm.bd_addr[0], p_data->sdp_query_cfm.bd_addr[1],
                              p_data->sdp_query_cfm.bd_addr[2], p_data->sdp_query_cfm.bd_addr[3],
                              p_data->sdp_query_cfm.bd_addr[4], p_data->sdp_query_cfm.bd_addr[5]);

 if (p_data->sdp_query_cfm.status == BTA_HL_STATUS_OK)
                status = btif_hl_proc_sdp_query_cfm(p_data);
 else
                status = FALSE;

 if (!status)
 {
                BTIF_TRACE_DEBUG("BTA_HL_SDP_QUERY_CFM_EVT Status = %d",
                                                        p_data->sdp_query_cfm.status);
 if (btif_hl_find_app_idx_using_app_id(p_data->sdp_query_cfm.app_id, &app_idx))
 {
                    p_acb = BTIF_HL_GET_APP_CB_PTR(app_idx);
 if (btif_hl_find_mcl_idx(app_idx, p_data->sdp_query_cfm.bd_addr, &mcl_idx))
 {
                        p_mcb = BTIF_HL_GET_MCL_CB_PTR(app_idx, mcl_idx);
 if ( (p_mcb->cch_oper ==  BTIF_HL_CCH_OP_MDEP_FILTERING) ||
 (p_mcb->cch_oper == BTIF_HL_CCH_OP_DCH_OPEN) )
 {
                            pending_op = p_mcb->pcb.op;
 switch (pending_op)
 {
 case BTIF_HL_PEND_DCH_OP_OPEN:
                                    btif_hl_send_setup_disconnected_cb(app_idx, mcl_idx);
 break;
 case BTIF_HL_PEND_DCH_OP_RECONNECT:
 case BTIF_HL_PEND_DCH_OP_DELETE_MDL:
 default:
 break;
 }
 if (!p_mcb->is_connected)
                                btif_hl_clean_mcl_cb(app_idx, mcl_idx);
 }
 }
 }
 }

 break;


 case BTA_HL_CCH_OPEN_CFM_EVT:
            BTIF_TRACE_DEBUG("Rcv BTA_HL_CCH_OPEN_CFM_EVT");
            BTIF_TRACE_DEBUG("app_id=%d,app_handle=%d mcl_handle=%d status =%d",
                              p_data->cch_open_cfm.app_id,
                              p_data->cch_open_cfm.app_handle,
                              p_data->cch_open_cfm.mcl_handle,
                              p_data->cch_open_cfm.status);
            BTIF_TRACE_DEBUG("DB [%02x] [%02x] [%02x] [%02x] [%02x] [%02x]",
                              p_data->cch_open_cfm.bd_addr[0], p_data->cch_open_cfm.bd_addr[1],
                              p_data->cch_open_cfm.bd_addr[2], p_data->cch_open_cfm.bd_addr[3],
                              p_data->cch_open_cfm.bd_addr[4], p_data->cch_open_cfm.bd_addr[5]);

 if (p_data->cch_open_cfm.status == BTA_HL_STATUS_OK ||
                        p_data->cch_open_cfm.status == BTA_HL_STATUS_DUPLICATE_CCH_OPEN)
 {
                status = btif_hl_proc_cch_open_cfm(p_data);
 }
 else
 {
                status = FALSE;
 }

 if (!status)
 {
 if (btif_hl_find_app_idx_using_app_id(p_data->cch_open_cfm.app_id, &app_idx))
 {
                    p_acb = BTIF_HL_GET_APP_CB_PTR(app_idx);
 if (btif_hl_find_mcl_idx(app_idx, p_data->cch_open_cfm.bd_addr, &mcl_idx))
 {
                        p_mcb = BTIF_HL_GET_MCL_CB_PTR(app_idx, mcl_idx);
                        pending_op = p_mcb->pcb.op;
 switch (pending_op)
 {
 case BTIF_HL_PEND_DCH_OP_OPEN:
                                btif_hl_send_setup_disconnected_cb(app_idx, mcl_idx);
 break;
 case BTIF_HL_PEND_DCH_OP_RECONNECT:
 case BTIF_HL_PEND_DCH_OP_DELETE_MDL:
 default:
 break;
 }
                        btif_hl_clean_mcl_cb(app_idx, mcl_idx);
 }
 }
 }
 break;

 case BTA_HL_DCH_OPEN_CFM_EVT:
            BTIF_TRACE_DEBUG("Rcv BTA_HL_DCH_OPEN_CFM_EVT");
            BTIF_TRACE_DEBUG("mcl_handle=%d mdl_handle=0x%x status=%d ",
                              p_data->dch_open_cfm.mcl_handle,
                              p_data->dch_open_cfm.mdl_handle,
                              p_data->dch_open_cfm.status);
            BTIF_TRACE_DEBUG("first_reliable =%d dch_mode=%d local_mdep_id=%d mdl_id=%d mtu=%d",
                              p_data->dch_open_cfm.first_reliable,
                              p_data->dch_open_cfm.dch_mode,
                              p_data->dch_open_cfm.local_mdep_id,
                              p_data->dch_open_cfm.mdl_id,
                              p_data->dch_open_cfm.mtu);
 if (p_data->dch_open_cfm.status == BTA_HL_STATUS_OK)
 {
                status = btif_hl_proc_dch_open_cfm(p_data);
 }
 else
 {
                status = FALSE;
 }

 if (!status)
 {
 if (btif_hl_find_mcl_idx_using_handle(p_data->dch_open_cfm.mcl_handle,&app_idx, &mcl_idx))
 {
                    p_mcb = BTIF_HL_GET_MCL_CB_PTR(app_idx, mcl_idx);
                    pending_op = p_mcb->pcb.op;
 switch (pending_op)
 {
 case BTIF_HL_PEND_DCH_OP_OPEN:
                            btif_hl_send_setup_disconnected_cb(app_idx, mcl_idx);
 break;
 case BTIF_HL_PEND_DCH_OP_RECONNECT:
 case BTIF_HL_PEND_DCH_OP_DELETE_MDL:
 default:
 break;
 }
 }
 }
 break;


 case BTA_HL_CCH_OPEN_IND_EVT:
            BTIF_TRACE_DEBUG("Rcv BTA_HL_CCH_OPEN_IND_EVT");
            BTIF_TRACE_DEBUG("app_handle=%d mcl_handle=%d",
                              p_data->cch_open_ind.app_handle,
                              p_data->cch_open_ind.mcl_handle);
            BTIF_TRACE_DEBUG("DB [%02x] [%02x] [%02x] [%02x] [%02x] [%02x]",
                              p_data->cch_open_ind.bd_addr[0], p_data->cch_open_ind.bd_addr[1],
                              p_data->cch_open_ind.bd_addr[2], p_data->cch_open_ind.bd_addr[3],
                              p_data->cch_open_ind.bd_addr[4], p_data->cch_open_ind.bd_addr[5]);

            btif_hl_proc_cch_open_ind(p_data);
 break;

 case BTA_HL_DCH_CREATE_IND_EVT:
            BTIF_TRACE_DEBUG("Rcv BTA_HL_DCH_CREATE_IND_EVT");
            BTIF_TRACE_DEBUG("mcl_handle=%d",
                              p_data->dch_create_ind.mcl_handle );
            BTIF_TRACE_DEBUG("local_mdep_id =%d mdl_id=%d cfg=%d",
                              p_data->dch_create_ind.local_mdep_id,
                              p_data->dch_create_ind.mdl_id,
                              p_data->dch_create_ind.cfg);
            btif_hl_proc_create_ind(p_data);
 break;

 case BTA_HL_DCH_OPEN_IND_EVT:
            BTIF_TRACE_DEBUG("Rcv BTA_HL_DCH_OPEN_IND_EVT");
            BTIF_TRACE_DEBUG("mcl_handle=%d mdl_handle=0x%x",
                              p_data->dch_open_ind.mcl_handle,
                              p_data->dch_open_ind.mdl_handle );
            BTIF_TRACE_DEBUG("first_reliable =%d dch_mode=%d local_mdep_id=%d mdl_id=%d mtu=%d",
                              p_data->dch_open_ind.first_reliable,
                              p_data->dch_open_ind.dch_mode,
                              p_data->dch_open_ind.local_mdep_id,
                              p_data->dch_open_ind.mdl_id,
                              p_data->dch_open_ind.mtu);

            btif_hl_proc_dch_open_ind(p_data);
 break;

 case BTA_HL_DELETE_MDL_IND_EVT:
            BTIF_TRACE_DEBUG("Rcv BTA_HL_DELETE_MDL_IND_EVT");
            BTIF_TRACE_DEBUG("mcl_handle=%d mdl_id=0x%x",
                              p_data->delete_mdl_ind.mcl_handle,
                              p_data->delete_mdl_ind.mdl_id);
 break;

 case BTA_HL_DELETE_MDL_CFM_EVT:
            BTIF_TRACE_DEBUG("Rcv BTA_HL_DELETE_MDL_CFM_EVT");
            BTIF_TRACE_DEBUG("mcl_handle=%d mdl_id=0x%x status=%d",
                              p_data->delete_mdl_cfm.mcl_handle,
                              p_data->delete_mdl_cfm.mdl_id,
                              p_data->delete_mdl_cfm.status);

 if (btif_hl_find_app_idx_using_deleted_mdl_id( p_data->delete_mdl_cfm.mdl_id,
 &app_idx))
 {
                p_acb = BTIF_HL_GET_APP_CB_PTR(app_idx);
                btif_hl_send_destroyed_cb(p_acb);
                btif_hl_clean_delete_mdl(&p_acb->delete_mdl);
 }
 break;

 case BTA_HL_DCH_RECONNECT_CFM_EVT:
            BTIF_TRACE_DEBUG("Rcv BTA_HL_DCH_RECONNECT_CFM_EVT");
            BTIF_TRACE_DEBUG("mcl_handle=%d mdl_handle=%d status=%d   ",
                              p_data->dch_reconnect_cfm.mcl_handle,
                              p_data->dch_reconnect_cfm.mdl_handle,
                              p_data->dch_reconnect_cfm.status);
            BTIF_TRACE_DEBUG("first_reliable =%d dch_mode=%d mdl_id=%d mtu=%d",
                              p_data->dch_reconnect_cfm.first_reliable,
                              p_data->dch_reconnect_cfm.dch_mode,
                              p_data->dch_reconnect_cfm.mdl_id,
                              p_data->dch_reconnect_cfm.mtu);


 if (p_data->dch_reconnect_cfm.status == BTA_HL_STATUS_OK)
 {
                status = btif_hl_proc_dch_reconnect_cfm(p_data);
 }
 else
 {
                status = FALSE;
 }

 if (!status)
 {
 if (btif_hl_find_mcl_idx_using_handle(p_data->dch_open_cfm.mcl_handle,&app_idx, &mcl_idx))
 {
                    p_mcb = BTIF_HL_GET_MCL_CB_PTR(app_idx, mcl_idx);
                    pending_op = p_mcb->pcb.op;
 switch (pending_op)
 {
 case BTIF_HL_PEND_DCH_OP_OPEN:
                            btif_hl_send_setup_disconnected_cb(app_idx, mcl_idx);
 break;
 case BTIF_HL_PEND_DCH_OP_RECONNECT:
 case BTIF_HL_PEND_DCH_OP_DELETE_MDL:
 default:
 break;
 }
 }
 }

 break;

 case BTA_HL_CCH_CLOSE_CFM_EVT:
            BTIF_TRACE_DEBUG("Rcv BTA_HL_CCH_CLOSE_CFM_EVT");
            BTIF_TRACE_DEBUG("mcl_handle=%d status =%d",
                              p_data->cch_close_cfm.mcl_handle,
                              p_data->cch_close_cfm.status);
 if (p_data->cch_close_cfm.status == BTA_HL_STATUS_OK)
 {
                btif_hl_proc_cch_close_cfm(p_data);
 }
 break;

 case BTA_HL_CCH_CLOSE_IND_EVT:
            BTIF_TRACE_DEBUG("Rcv BTA_HL_CCH_CLOSE_IND_EVT");
            BTIF_TRACE_DEBUG("mcl_handle =%d intentional_close=%s",
                              p_data->cch_close_ind.mcl_handle,
 (p_data->cch_close_ind.intentional?"Yes":"No"));

            btif_hl_proc_cch_close_ind(p_data);
 break;

 case BTA_HL_DCH_CLOSE_IND_EVT:
            BTIF_TRACE_DEBUG("Rcv BTA_HL_DCH_CLOSE_IND_EVT");
            BTIF_TRACE_DEBUG("mdl_handle=%d intentional_close=%s",
                              p_data->dch_close_ind.mdl_handle,
 (p_data->dch_close_ind.intentional?"Yes":"No") );

            btif_hl_proc_dch_close_ind(p_data);
 break;

 case BTA_HL_DCH_CLOSE_CFM_EVT:
            BTIF_TRACE_DEBUG("Rcv BTA_HL_DCH_CLOSE_CFM_EVT");
            BTIF_TRACE_DEBUG("mdl_handle=%d status=%d ",
                              p_data->dch_close_cfm.mdl_handle,
                              p_data->dch_close_cfm.status);

 if (p_data->dch_close_cfm.status == BTA_HL_STATUS_OK)
 {
                btif_hl_proc_dch_close_cfm(p_data);
 }
 break;

 case BTA_HL_DCH_ECHO_TEST_CFM_EVT:
            BTIF_TRACE_DEBUG("Rcv BTA_HL_DCH_ECHO_TEST_CFM_EVT");
            BTIF_TRACE_DEBUG("mcl_handle=%d    status=%d",
                              p_data->echo_test_cfm.mcl_handle,
                              p_data->echo_test_cfm.status );
 /* not supported */
 break;


 case BTA_HL_DCH_RECONNECT_IND_EVT:
            BTIF_TRACE_DEBUG("Rcv BTA_HL_DCH_RECONNECT_IND_EVT");

            BTIF_TRACE_DEBUG("mcl_handle=%d mdl_handle=5d",
                              p_data->dch_reconnect_ind.mcl_handle,
                              p_data->dch_reconnect_ind.mdl_handle );
            BTIF_TRACE_DEBUG("first_reliable =%d dch_mode=%d mdl_id=%d mtu=%d",
                              p_data->dch_reconnect_ind.first_reliable,
                              p_data->dch_reconnect_ind.dch_mode,
                              p_data->dch_reconnect_ind.mdl_id,
                              p_data->dch_reconnect_ind.mtu);

            btif_hl_proc_dch_reconnect_ind(p_data);
 break;

 case BTA_HL_CONG_CHG_IND_EVT:
            BTIF_TRACE_DEBUG("Rcv BTA_HL_CONG_CHG_IND_EVT");
            BTIF_TRACE_DEBUG("mdl_handle=%d cong =%d",
                              p_data->dch_cong_ind.mdl_handle,
                              p_data->dch_cong_ind.cong);
            btif_hl_proc_dch_cong_ind(p_data);
 break;

 case BTA_HL_DCH_ABORT_IND_EVT:
            BTIF_TRACE_DEBUG("Rcv BTA_HL_DCH_ABORT_IND_EVT");
            BTIF_TRACE_DEBUG("mcl_handle=%d",
                              p_data->dch_abort_ind.mcl_handle );
            btif_hl_proc_abort_ind(p_data->dch_abort_ind.mcl_handle);
 break;
 case BTA_HL_DCH_ABORT_CFM_EVT:
            BTIF_TRACE_DEBUG("Rcv BTA_HL_DCH_ABORT_CFM_EVT");
            BTIF_TRACE_DEBUG("mcl_handle=%d status =%d",
                              p_data->dch_abort_cfm.mcl_handle,
                              p_data->dch_abort_cfm.status);
 if (p_data->dch_abort_cfm.status == BTA_HL_STATUS_OK)
 {
                btif_hl_proc_abort_cfm(p_data->dch_abort_ind.mcl_handle);
 }
 break;

 case BTA_HL_DCH_SEND_DATA_CFM_EVT:
            BTIF_TRACE_DEBUG("Rcv BTA_HL_DCH_SEND_DATA_CFM_EVT");
            BTIF_TRACE_DEBUG("mdl_handle=0x%x status =%d",
                              p_data->dch_send_data_cfm.mdl_handle,
                              p_data->dch_send_data_cfm.status);
            btif_hl_proc_send_data_cfm(p_data->dch_send_data_cfm.mdl_handle,
                                       p_data->dch_send_data_cfm.status);
 break;

 case BTA_HL_DCH_RCV_DATA_IND_EVT:
            BTIF_TRACE_DEBUG("Rcv BTA_HL_DCH_RCV_DATA_IND_EVT");
            BTIF_TRACE_DEBUG("mdl_handle=0x%x ",
                              p_data->dch_rcv_data_ind.mdl_handle);
 /* do nothing here */
 break;

 default:
            BTIF_TRACE_DEBUG("Unknown Event (0x%02x)...", event);
 break;
 }
}

static void btif_hl_reset_mdep_filter(UINT8 app_idx)
{
 btif_hl_app_cb_t *p_acb  =BTIF_HL_GET_APP_CB_PTR(app_idx);
    p_acb->filter.num_elems = 0;
}

static bt_status_t disconnect( bt_bdaddr_t *bd_addr )
{
    CHECK_BTHH_INIT();
 btif_hh_device_t *p_dev;

 if (btif_hh_cb.status == BTIF_HH_DISABLED)
 {
        BTIF_TRACE_WARNING("%s: Error, HH status = %d", __FUNCTION__, btif_hh_cb.status);
 return BT_STATUS_FAIL;
 }
    p_dev = btif_hh_find_connected_dev_by_bda(bd_addr);
 if (p_dev != NULL)
 {
 return btif_transfer_context(btif_hh_handle_evt, BTIF_HH_DISCONNECT_REQ_EVT,
 (char*)bd_addr, sizeof(bt_bdaddr_t), NULL);
 }
 else
 {
        BTIF_TRACE_WARNING("%s: Error, device  not opened.", __FUNCTION__);
 return BT_STATUS_FAIL;
 }
}

void create_tap_read_thread(int tap_fd)
{
 if (pan_pth < 0)
        pan_pth = btsock_thread_create(btpan_tap_fd_signaled, NULL);
 if (pan_pth >= 0)
        btsock_thread_add_fd(pan_pth, tap_fd, 0, SOCK_THREAD_FD_RD, 0);
}

void bta_hl_co_get_echo_data (UINT8 app_id, tBTA_HL_MCL_HANDLE mcl_handle,
                              UINT16 buf_size, UINT8 *p_buf,  UINT16 evt)
{
    tBTA_HL_STATUS status = BTA_HL_STATUS_FAIL;
    UNUSED(app_id);
    UNUSED(buf_size);
    UNUSED(p_buf);

    BTIF_TRACE_ERROR("%s not supported",__FUNCTION__);
    bta_hl_ci_get_echo_data(mcl_handle,  status, evt);
}

void btif_hl_set_socket_state(btif_hl_soc_cb_t *p_scb, btif_hl_soc_state_t new_state){
    BTIF_TRACE_DEBUG("btif_hl_set_socket_state %d---->%d", p_scb->state, new_state);
    p_scb->state = new_state;
}

static int out_get_render_position(const struct audio_stream_out *stream,
 uint32_t *dsp_frames)
{
 struct a2dp_stream_out *out = (struct a2dp_stream_out *)stream;

    FNLOG();
 if (stream == NULL || dsp_frames == NULL)
 return -EINVAL;

    pthread_mutex_lock(&out->common.lock);
 uint64_t latency_frames = (uint64_t)out_get_latency(stream) * out->common.cfg.rate / 1000;
 if (out->frames_rendered >= latency_frames) {
 *dsp_frames = (uint32_t)(out->frames_rendered - latency_frames);
 } else {
 *dsp_frames = 0;
 }
    pthread_mutex_unlock(&out->common.lock);
 return 0;
}

ssize_t socket_read(const socket_t *socket, void *buf, size_t count) {

assert(socket != NULL);
assert(buf != NULL);

  return recv(socket->fd, buf, count, MSG_DONTWAIT);
}

static void btif_dut_mode_cback( tBTM_VSC_CMPL *p )
{
    UNUSED(p);
 /* For now nothing to be done. */
}

static inline BOOLEAN send_app_psm_or_chan_l(l2cap_socket *sock)
{
 return sock_send_all(sock->our_fd, (const uint8_t*)&sock->channel, sizeof(sock->channel))
 == sizeof(sock->channel);
}

void btsnoop_net_close() {
#if (!defined(BT_NET_DEBUG) || (BT_NET_DEBUG != TRUE))
 return; // Disable using network sockets for security reasons
#endif

 if (listen_thread_valid_) {
    shutdown(listen_socket_, SHUT_RDWR);
    pthread_join(listen_thread_, NULL);
    safe_close_(&client_socket_);
    listen_thread_valid_ = false;
 }
}

static void btpan_close_conn(btpan_conn_t* conn)
{
    BTIF_TRACE_API("btpan_close_conn: %p",conn);

 if (conn && conn->state == PAN_STATE_OPEN)
 {
        BTIF_TRACE_DEBUG("btpan_close_conn: PAN_STATE_OPEN");

        conn->state = PAN_STATE_CLOSE;
        btpan_cb.open_count--;

 if (btpan_cb.open_count == 0)
 {
            destroy_tap_read_thread();
 if (btpan_cb.tap_fd != INVALID_FD)
 {
                btpan_tap_close(btpan_cb.tap_fd);
                btpan_cb.tap_fd = INVALID_FD;
 }
 }
 }
}

void config_free(config_t *config) {
 if (!config)
 return;

  list_free(config->sections);
  osi_free(config);
}

static void bond_state_changed(bt_status_t status, bt_bdaddr_t *bd_addr, bt_bond_state_t state)
{
 if ((pairing_cb.state == state) && (state == BT_BOND_STATE_BONDING))
 {
 if (!bdaddr_is_empty(&pairing_cb.static_bdaddr))
 {
            HAL_CBACK(bt_hal_cbacks, bond_state_changed_cb, status, bd_addr, state);
 }
 return;
 }

 if (pairing_cb.bond_type == BOND_TYPE_TEMPORARY)
        state = BT_BOND_STATE_NONE;

    BTIF_TRACE_DEBUG("%s: state=%d, prev_state=%d, sdp_attempts = %d", __func__,
                      state, pairing_cb.state, pairing_cb.sdp_attempts);

    HAL_CBACK(bt_hal_cbacks, bond_state_changed_cb, status, bd_addr, state);

 if (state == BT_BOND_STATE_BONDING)
 {
        pairing_cb.state = state;
        bdcpy(pairing_cb.bd_addr, bd_addr->address);
 } else {
 if (!pairing_cb.sdp_attempts)
            memset(&pairing_cb, 0, sizeof(pairing_cb));
 else
            BTIF_TRACE_DEBUG("%s: BR-EDR service discovery active", __func__);
 }
}

static char packet_put_head_l(l2cap_socket *sock, const void *data, uint32_t len)
{
 struct packet *p = packet_alloc((const uint8_t*)data, len);

 /*
     * We do not check size limits here since this is used to undo "getting" a
     * packet that the user read incompletely. That is to say the packet was
     * already in the queue. We do check thos elimits in packet_put_tail_l() since
     * that function is used to put new data into the queue.
     */

 if (!p)
 return FALSE;

    p->prev = NULL;
    p->next = sock->first_packet;
    sock->first_packet = p;
 if (p->next)
        p->next->prev = p;
 else
        sock->last_packet = p;

    sock->bytes_buffered += len;

 return TRUE;
}

static bt_status_t get_protocol (bt_bdaddr_t *bd_addr, bthh_protocol_mode_t protocolMode)
{
    CHECK_BTHH_INIT();
 btif_hh_device_t *p_dev;
    BD_ADDR* bda = (BD_ADDR*) bd_addr;
    UNUSED(protocolMode);

    BTIF_TRACE_DEBUG(" addr = %02X:%02X:%02X:%02X:%02X:%02X",
 (*bda)[0], (*bda)[1], (*bda)[2], (*bda)[3], (*bda)[4], (*bda)[5]);

 if (btif_hh_cb.status == BTIF_HH_DISABLED) {
        BTIF_TRACE_ERROR("%s: Error, HH status = %d", __FUNCTION__, btif_hh_cb.status);
 return BT_STATUS_FAIL;
 }

    p_dev = btif_hh_find_connected_dev_by_bda(bd_addr);
 if (p_dev != NULL) {

        BTA_HhGetProtoMode(p_dev->dev_handle);
 }
 else {
 return BT_STATUS_FAIL;
 }
 return BT_STATUS_SUCCESS;
}

static void btu_exec_tap_fd_read(void *p_param) {
struct pollfd ufd;
int fd = (int)p_param;

if (fd == INVALID_FD || fd != btpan_cb.tap_fd)
return;

// Don't occupy BTU context too long, avoid GKI buffer overruns and
// give other profiles a chance to run by limiting the amount of memory
// PAN can use from the shared pool buffer.
for (int i = 0; i < PAN_POOL_MAX && btif_is_enabled() && btpan_cb.flow; i++) {
BT_HDR *buffer = (BT_HDR *)GKI_getpoolbuf(PAN_POOL_ID);
if (!buffer) {
BTIF_TRACE_WARNING("%s unable to allocate buffer for packet.", __func__);
break;
}
buffer->offset = PAN_MINIMUM_OFFSET;
buffer->len = GKI_get_buf_size(buffer) - sizeof(BT_HDR) - buffer->offset;

UINT8 *packet = (UINT8 *)buffer + sizeof(BT_HDR) + buffer->offset;

// If we don't have an undelivered packet left over, pull one from the TAP driver.

// We save it in the congest_packet right away in case we can't deliver it in this
// attempt.
if (!btpan_cb.congest_packet_size) {
            ssize_t ret = read(fd, btpan_cb.congest_packet, sizeof(btpan_cb.congest_packet));
switch (ret) {
case -1:
BTIF_TRACE_ERROR("%s unable to read from driver: %s", __func__, strerror(errno));
GKI_freebuf(buffer);
//add fd back to monitor thread to try it again later
btsock_thread_add_fd(pan_pth, fd, 0, SOCK_THREAD_FD_RD, 0);
return;
case 0:
BTIF_TRACE_WARNING("%s end of file reached.", __func__);
GKI_freebuf(buffer);
//add fd back to monitor thread to process the exception
btsock_thread_add_fd(pan_pth, fd, 0, SOCK_THREAD_FD_RD, 0);
return;
default:
btpan_cb.congest_packet_size = ret;
break;
}
}

memcpy(packet, btpan_cb.congest_packet, MIN(btpan_cb.congest_packet_size, buffer->len));
buffer->len = MIN(btpan_cb.congest_packet_size, buffer->len);

if (buffer->len > sizeof(tETH_HDR) && should_forward((tETH_HDR *)packet)) {
// Extract the ethernet header from the buffer since the PAN_WriteBuf inside
// forward_bnep can't handle two pointers that point inside the same GKI buffer.
tETH_HDR hdr;
memcpy(&hdr, packet, sizeof(tETH_HDR));

// Skip the ethernet header.
buffer->len -= sizeof(tETH_HDR);
buffer->offset += sizeof(tETH_HDR);
if (forward_bnep(&hdr, buffer) != FORWARD_CONGEST)
btpan_cb.congest_packet_size = 0;
} else {
BTIF_TRACE_WARNING("%s dropping packet of length %d", __func__, buffer->len);
btpan_cb.congest_packet_size = 0;
GKI_freebuf(buffer);
}

// Bail out of the loop if reading from the TAP fd would block.

ufd.fd = fd;
ufd.events = POLLIN;
ufd.revents = 0;
        if (poll(&ufd, 1, 0) <= 0 || IS_EXCEPTION(ufd.revents))
break;
}
//add fd back to monitor thread
btsock_thread_add_fd(pan_pth, fd, 0, SOCK_THREAD_FD_RD, 0);
}

const config_section_node_t *config_section_next(const config_section_node_t *node) {
  assert(node != NULL);
 return (const config_section_node_t *)list_next((const list_node_t *)node);
}

BOOLEAN btif_hl_find_mdl_idx_using_handle(tBTA_HL_MDL_HANDLE mdl_handle,
                                          UINT8 *p_app_idx,UINT8 *p_mcl_idx,
                                          UINT8 *p_mdl_idx){
 btif_hl_app_cb_t *p_acb;
 btif_hl_mcl_cb_t *p_mcb;
 btif_hl_mdl_cb_t *p_dcb;
    BOOLEAN found=FALSE;
    UINT8 i,j,k;

 *p_app_idx = 0;
 *p_mcl_idx =0;
 *p_mdl_idx = 0;
 for (i=0; i < BTA_HL_NUM_APPS ; i ++)
 {
        p_acb =BTIF_HL_GET_APP_CB_PTR(i);
 for (j=0; j< BTA_HL_NUM_MCLS; j++)
 {
            p_mcb =BTIF_HL_GET_MCL_CB_PTR(i,j);
 for (k=0; k< BTA_HL_NUM_MDLS_PER_MCL; k++)
 {
                p_dcb =BTIF_HL_GET_MDL_CB_PTR(i,j,k);
 if (p_acb->in_use &&
                    p_mcb->in_use &&
                    p_dcb->in_use &&
 (p_dcb->mdl_handle == mdl_handle))
 {
                    found = TRUE;
 *p_app_idx = i;
 *p_mcl_idx =j;
 *p_mdl_idx = k;
 break;
 }
 }
 }
 }


    BTIF_TRACE_EVENT("%s found=%d app_idx=%d mcl_idx=%d mdl_idx=%d  ",
                      __FUNCTION__,found,i,j,k );
 return found;
}

bt_status_t btsock_rfc_listen(const char *service_name, const uint8_t *service_uuid, int channel, int *sock_fd, int flags) {
  assert(sock_fd != NULL);
  assert((service_uuid != NULL)
 || (channel >= 1 && channel <= MAX_RFC_CHANNEL)
 || ((flags & BTSOCK_FLAG_NO_SDP) != 0));

 *sock_fd = INVALID_FD;

 if (!is_init_done())
 return BT_STATUS_NOT_READY;

 if((flags & BTSOCK_FLAG_NO_SDP) == 0) {
 if(is_uuid_empty(service_uuid)) {
      APPL_TRACE_DEBUG("BTA_JvGetChannelId: service_uuid not set AND "
 "BTSOCK_FLAG_NO_SDP is not set - changing to SPP");
      service_uuid = UUID_SPP; // Use serial port profile to listen to specified channel
 } else {
 int reserved_channel = get_reserved_rfc_channel(service_uuid);
 if (reserved_channel > 0) {
            channel = reserved_channel;
 }
 }
 }

 int status = BT_STATUS_FAIL;
  pthread_mutex_lock(&slot_lock);

 rfc_slot_t *slot = alloc_rfc_slot(NULL, service_name, service_uuid, channel, flags, true);
 if (!slot) {
    LOG_ERROR("%s unable to allocate RFCOMM slot.", __func__);
 goto out;
 }
  APPL_TRACE_DEBUG("BTA_JvGetChannelId: service_name: %s - channel: %d", service_name, channel);
  BTA_JvGetChannelId(BTA_JV_CONN_TYPE_RFCOMM, (void*) slot->id, channel);
 *sock_fd = slot->app_fd; // Transfer ownership of fd to caller.
 /*TODO:
   * We are leaking one of the app_fd's - either the listen socket, or the connection socket.
   * WE need to close this in native, as the FD might belong to another process
    - This is the server socket FD
    - For accepted connections, we close the FD after passing it to JAVA.
    - Try to simply remove the = -1 to free the FD at rs cleanup.*/
  slot->app_fd = INVALID_FD; // Drop our reference to the fd.
  btsock_thread_add_fd(pth, slot->fd, BTSOCK_RFCOMM, SOCK_THREAD_FD_EXCEPTION, slot->id);

  status = BT_STATUS_SUCCESS;

out:;
  pthread_mutex_unlock(&slot_lock);
 return status;
}

void btif_dm_ble_sec_req_evt(tBTA_DM_BLE_SEC_REQ *p_ble_req)
{
 bt_bdaddr_t bd_addr;
 bt_bdname_t bd_name;
    UINT32 cod;
 int dev_type;

    BTIF_TRACE_DEBUG("%s", __FUNCTION__);

 if (pairing_cb.state == BT_BOND_STATE_BONDING)
 {
        BTIF_TRACE_DEBUG("%s Discard security request", __FUNCTION__);
 return;
 }

 /* Remote name update */
 if (!btif_get_device_type(p_ble_req->bd_addr, &dev_type))
 {
        dev_type = BT_DEVICE_TYPE_BLE;
 }
    btif_dm_update_ble_remote_properties(p_ble_req->bd_addr, p_ble_req->bd_name,
 (tBT_DEVICE_TYPE) dev_type);

    bdcpy(bd_addr.address, p_ble_req->bd_addr);
    memcpy(bd_name.name, p_ble_req->bd_name, BD_NAME_LEN);

    bond_state_changed(BT_STATUS_SUCCESS, &bd_addr, BT_BOND_STATE_BONDING);

    pairing_cb.bond_type = BOND_TYPE_PERSISTENT;
    pairing_cb.is_le_only = TRUE;
    pairing_cb.is_le_nc = FALSE;
    pairing_cb.is_ssp = TRUE;
    btm_set_bond_type_dev(p_ble_req->bd_addr, pairing_cb.bond_type);

    cod = COD_UNCLASSIFIED;

    HAL_CBACK(bt_hal_cbacks, ssp_request_cb, &bd_addr, &bd_name, cod,
              BT_SSP_VARIANT_CONSENT, 0);
}

static void initialize_transaction(int lbl)
{
    pthread_mutex_lock(&device.lbllock);
 if(lbl < MAX_TRANSACTIONS_PER_SESSION)
 {
       device.transaction[lbl].lbl = lbl;
       device.transaction[lbl].in_use=FALSE;
       device.transaction[lbl].handle=0;
 }
    pthread_mutex_unlock(&device.lbllock);
}

void    btif_dm_load_ble_local_keys(void)
{
    memset(&ble_local_key_cb, 0, sizeof(btif_dm_local_key_cb_t));

 if (btif_storage_get_ble_local_key(BTIF_DM_LE_LOCAL_KEY_ER,(char*)&ble_local_key_cb.er[0],
                                       BT_OCTET16_LEN)== BT_STATUS_SUCCESS)
 {
        ble_local_key_cb.is_er_rcvd = TRUE;
        BTIF_TRACE_DEBUG("%s BLE ER key loaded",__FUNCTION__ );
 }

 if ((btif_storage_get_ble_local_key(BTIF_DM_LE_LOCAL_KEY_IR,(char*)&ble_local_key_cb.id_keys.ir[0],
                                        BT_OCTET16_LEN)== BT_STATUS_SUCCESS )&&
 (btif_storage_get_ble_local_key(BTIF_DM_LE_LOCAL_KEY_IRK, (char*)&ble_local_key_cb.id_keys.irk[0],
                                        BT_OCTET16_LEN)== BT_STATUS_SUCCESS)&&
 (btif_storage_get_ble_local_key(BTIF_DM_LE_LOCAL_KEY_DHK,(char*)&ble_local_key_cb.id_keys.dhk[0],
                                        BT_OCTET16_LEN)== BT_STATUS_SUCCESS))
 {
        ble_local_key_cb.is_id_keys_rcvd = TRUE;
        BTIF_TRACE_DEBUG("%s BLE ID keys loaded",__FUNCTION__ );
 }

}

void bta_hh_co_open(UINT8 dev_handle, UINT8 sub_class, tBTA_HH_ATTR_MASK attr_mask,
UINT8 app_id)
{
UINT32 i;
btif_hh_device_t *p_dev = NULL;

if (dev_handle == BTA_HH_INVALID_HANDLE) {
APPL_TRACE_WARNING("%s: Oops, dev_handle (%d) is invalid...",
__FUNCTION__, dev_handle);
return;
}

for (i = 0; i < BTIF_HH_MAX_HID; i++) {
p_dev = &btif_hh_cb.devices[i];
if (p_dev->dev_status != BTHH_CONN_STATE_UNKNOWN &&
p_dev->dev_handle == dev_handle) {
// We found a device with the same handle. Must be a device reconnected.
APPL_TRACE_WARNING("%s: Found an existing device with the same handle "
"dev_status = %d",__FUNCTION__,
p_dev->dev_status);
APPL_TRACE_WARNING("%s:     bd_addr = [%02X:%02X:%02X:%02X:%02X:]", __FUNCTION__,
p_dev->bd_addr.address[0], p_dev->bd_addr.address[1], p_dev->bd_addr.address[2],
p_dev->bd_addr.address[3], p_dev->bd_addr.address[4]);
APPL_TRACE_WARNING("%s:     attr_mask = 0x%04x, sub_class = 0x%02x, app_id = %d",

__FUNCTION__, p_dev->attr_mask, p_dev->sub_class, p_dev->app_id);

if(p_dev->fd<0) {
                p_dev->fd = open(dev_path, O_RDWR | O_CLOEXEC);
if (p_dev->fd < 0){
APPL_TRACE_ERROR("%s: Error: failed to open uhid, err:%s",
__FUNCTION__,strerror(errno));
return;
}else
APPL_TRACE_DEBUG("%s: uhid fd = %d", __FUNCTION__, p_dev->fd);
}

p_dev->hh_keep_polling = 1;
p_dev->hh_poll_thread_id = create_thread(btif_hh_poll_event_thread, p_dev);
break;
}
p_dev = NULL;
}

if (p_dev == NULL) {
// Did not find a device reconnection case. Find an empty slot now.
for (i = 0; i < BTIF_HH_MAX_HID; i++) {
if (btif_hh_cb.devices[i].dev_status == BTHH_CONN_STATE_UNKNOWN) {
p_dev = &btif_hh_cb.devices[i];
p_dev->dev_handle = dev_handle;
p_dev->attr_mask  = attr_mask;
p_dev->sub_class  = sub_class;
p_dev->app_id     = app_id;
p_dev->local_vup  = FALSE;


btif_hh_cb.device_num++;
// This is a new device,open the uhid driver now.
                p_dev->fd = open(dev_path, O_RDWR | O_CLOEXEC);
if (p_dev->fd < 0){
APPL_TRACE_ERROR("%s: Error: failed to open uhid, err:%s",
__FUNCTION__,strerror(errno));
return;
}else{
APPL_TRACE_DEBUG("%s: uhid fd = %d", __FUNCTION__, p_dev->fd);
p_dev->hh_keep_polling = 1;
p_dev->hh_poll_thread_id = create_thread(btif_hh_poll_event_thread, p_dev);
}


break;
}
}
}

if (p_dev == NULL) {
APPL_TRACE_ERROR("%s: Error: too many HID devices are connected", __FUNCTION__);
return;
}

p_dev->dev_status = BTHH_CONN_STATE_CONNECTED;
APPL_TRACE_DEBUG("%s: Return device status %d", __FUNCTION__, p_dev->dev_status);
}

static void ts_log(char *tag, int val, struct timespec *pprev_opt)
{
 struct timespec now;
 static struct timespec prev = {0,0};
 unsigned long long now_us;
 unsigned long long diff_us;
    UNUSED(tag);
    UNUSED(val);

    clock_gettime(CLOCK_MONOTONIC, &now);

    now_us = now.tv_sec*USEC_PER_SEC + now.tv_nsec/1000;

 if (pprev_opt)
 {
        diff_us = (now.tv_sec - prev.tv_sec) * USEC_PER_SEC + (now.tv_nsec - prev.tv_nsec)/1000;
 *pprev_opt = now;
        DEBUG("[%s] ts %08lld, *diff %08lld, val %d", tag, now_us, diff_us, val);
 }
 else
 {
        diff_us = (now.tv_sec - prev.tv_sec) * USEC_PER_SEC + (now.tv_nsec - prev.tv_nsec)/1000;
        prev = now;
        DEBUG("[%s] ts %08lld, diff %08lld, val %d", tag, now_us, diff_us, val);
 }
}

void close_uinput (void)

{
BTIF_TRACE_DEBUG("%s", __FUNCTION__);
if (uinput_fd > 0) {
        ioctl(uinput_fd, UI_DEV_DESTROY);

close(uinput_fd);
uinput_fd = -1;
}
}

static const command_t *find_command(const char *name) {
 for (size_t i = 0; i < ARRAY_SIZE(commands); ++i)
 if (!strcmp(commands[i].name, name))
 return &commands[i];
 return NULL;
}

static int a2dp_ctrl_receive(struct a2dp_stream_common *common, void* buffer, int length)
{
    int ret = recv(common->ctrl_fd, buffer, length, MSG_NOSIGNAL);
if (ret < 0)
{
ERROR("ack failed (%s)", strerror(errno));
if (errno == EINTR)
{
/* retry again */
            ret = recv(common->ctrl_fd, buffer, length, MSG_NOSIGNAL);
if (ret < 0)
{
ERROR("ack failed (%s)", strerror(errno));
skt_disconnect(common->ctrl_fd);
common->ctrl_fd = AUDIO_SKT_DISCONNECTED;
return -1;
}
}
else
{
skt_disconnect(common->ctrl_fd);
common->ctrl_fd = AUDIO_SKT_DISCONNECTED;
return -1;

}
}
return ret;
}

int init_uinput (void)
{
 char *name = "AVRCP";

    BTIF_TRACE_DEBUG("%s", __FUNCTION__);
    uinput_fd = uinput_create(name);
 if (uinput_fd < 0) {
        BTIF_TRACE_ERROR("%s AVRCP: Failed to initialize uinput for %s (%d)",
                          __FUNCTION__, name, uinput_fd);
 } else {
        BTIF_TRACE_DEBUG("%s AVRCP: Initialized uinput for %s (fd=%d)",
                          __FUNCTION__, name, uinput_fd);
 }
 return uinput_fd;
}

int btif_is_enabled(void)
{
 return ((!btif_is_dut_mode()) && (stack_manager_get_interface()->get_stack_is_running()));
}

static void execute_storage_request(UINT16 event, char *p_param)
{
 bt_status_t status = BT_STATUS_SUCCESS;

    BTIF_TRACE_EVENT("execute storage request event : %d", event);

 switch(event)
 {
 case BTIF_CORE_STORAGE_ADAPTER_WRITE:
 {
 btif_storage_req_t *p_req = (btif_storage_req_t*)p_param;
 bt_property_t *p_prop = &(p_req->write_req.prop);
            BTIF_TRACE_EVENT("type: %d, len %d, 0x%x", p_prop->type,
                               p_prop->len, p_prop->val);

            status = btif_storage_set_adapter_property(p_prop);
            HAL_CBACK(bt_hal_cbacks, adapter_properties_cb, status, 1, p_prop);
 } break;

 case BTIF_CORE_STORAGE_ADAPTER_READ:
 {
 btif_storage_req_t *p_req = (btif_storage_req_t*)p_param;
 char buf[512];
 bt_property_t prop;
            prop.type = p_req->read_req.type;
            prop.val = (void*)buf;
            prop.len = sizeof(buf);
 if (prop.type == BT_PROPERTY_LOCAL_LE_FEATURES)
 {
 #if (BLE_INCLUDED == TRUE)
                tBTM_BLE_VSC_CB cmn_vsc_cb;
 bt_local_le_features_t local_le_features;

 /* LE features are not stored in storage. Should be retrived from stack */
                BTM_BleGetVendorCapabilities(&cmn_vsc_cb);
                local_le_features.local_privacy_enabled = BTM_BleLocalPrivacyEnabled();

                prop.len = sizeof (bt_local_le_features_t);
 if (cmn_vsc_cb.filter_support == 1)
                    local_le_features.max_adv_filter_supported = cmn_vsc_cb.max_filter;
 else
                    local_le_features.max_adv_filter_supported = 0;
                local_le_features.max_adv_instance = cmn_vsc_cb.adv_inst_max;
                local_le_features.max_irk_list_size = cmn_vsc_cb.max_irk_list_sz;
                local_le_features.rpa_offload_supported = cmn_vsc_cb.rpa_offloading;
                local_le_features.scan_result_storage_size = cmn_vsc_cb.tot_scan_results_strg;
                local_le_features.activity_energy_info_supported = cmn_vsc_cb.energy_support;
                local_le_features.version_supported = cmn_vsc_cb.version_supported;
                local_le_features.total_trackable_advertisers =
                    cmn_vsc_cb.total_trackable_advertisers;

                local_le_features.extended_scan_support = cmn_vsc_cb.extended_scan_support > 0;
                local_le_features.debug_logging_supported = cmn_vsc_cb.debug_logging_supported > 0;
                memcpy(prop.val, &local_le_features, prop.len);
 #endif
 }
 else
 {
                status = btif_storage_get_adapter_property(&prop);
 }
            HAL_CBACK(bt_hal_cbacks, adapter_properties_cb, status, 1, &prop);
 } break;

 case BTIF_CORE_STORAGE_ADAPTER_READ_ALL:
 {
            status = btif_in_get_adapter_properties();
 } break;

 case BTIF_CORE_STORAGE_NOTIFY_STATUS:
 {
            HAL_CBACK(bt_hal_cbacks, adapter_properties_cb, status, 0, NULL);
 } break;

 default:
            BTIF_TRACE_ERROR("%s invalid event id (%d)", __FUNCTION__, event);
 break;
 }
}

static  BOOLEAN btif_hl_find_mdep_cfg_idx(UINT8 app_idx,  tBTA_HL_MDEP_ID local_mdep_id,
                                          UINT8 *p_mdep_cfg_idx){
 btif_hl_app_cb_t *p_acb =BTIF_HL_GET_APP_CB_PTR(app_idx);
    tBTA_HL_SUP_FEATURE     *p_sup_feature= &p_acb->sup_feature;
    BOOLEAN found =FALSE;
    UINT8 i;

 for (i=0; i< p_sup_feature->num_of_mdeps; i++)
 {
        BTIF_TRACE_DEBUG("btif_hl_find_mdep_cfg_idx: mdep_id=%d app_idx = %d",
                    p_sup_feature->mdep[i].mdep_id,app_idx);
 if ( p_sup_feature->mdep[i].mdep_id == local_mdep_id)
 {
            found = TRUE;
 *p_mdep_cfg_idx = i;
 break;
 }
 }

    BTIF_TRACE_DEBUG("%s found=%d mdep_idx=%d local_mdep_id=%d app_idx=%d ",
                      __FUNCTION__, found,i, local_mdep_id,app_idx);
 return found;
}

void btsnoop_net_open() {
#if (!defined(BT_NET_DEBUG) || (BT_NET_DEBUG != TRUE))
 return; // Disable using network sockets for security reasons
#endif

  listen_thread_valid_ = (pthread_create(&listen_thread_, NULL, listen_fn_, NULL) == 0);
 if (!listen_thread_valid_) {
    LOG_ERROR("%s pthread_create failed: %s", __func__, strerror(errno));
 } else {
    LOG_DEBUG("initialized");
 }
}

static void on_l2cap_close(tBTA_JV_L2CAP_CLOSE * p_close, uint32_t id)
{
    l2cap_socket *sock;

    pthread_mutex_lock(&state_lock);
    sock = btsock_l2cap_find_by_id_l(id);
 if (sock) {
        APPL_TRACE_DEBUG("on_l2cap_close, slot id:%d, fd:%d, %s:%d, server:%d",
                sock->id, sock->our_fd, sock->fixed_chan ? "fixed_chan" : "PSM",
                sock->channel, sock->server);
        sock->handle = 0;
 if(!sock->fixed_chan && (sock->server == TRUE)) {
            BTA_JvFreeChannel(sock->channel, BTA_JV_CONN_TYPE_L2CAP);
 }
        btsock_l2cap_free_l(sock);
 }
    pthread_mutex_unlock(&state_lock);
}

uint16_t btif_dm_get_connection_state(const bt_bdaddr_t *bd_addr)
{
 uint8_t *bda = (uint8_t*)bd_addr->address;
 uint16_t rc = BTA_DmGetConnectionState(bda);

 if (rc != 0)
 {
 uint8_t flags = 0;

        BTM_GetSecurityFlagsByTransport(bda, &flags, BT_TRANSPORT_BR_EDR);
        BTIF_TRACE_DEBUG("%s: security flags (BR/EDR)=0x%02x", __FUNCTION__, flags);
 if (flags & BTM_SEC_FLAG_ENCRYPTED)
            rc |= ENCRYPTED_BREDR;

        BTM_GetSecurityFlagsByTransport(bda, &flags, BT_TRANSPORT_LE);
        BTIF_TRACE_DEBUG("%s: security flags (LE)=0x%02x", __FUNCTION__, flags);
 if (flags & BTM_SEC_FLAG_ENCRYPTED)
            rc |= ENCRYPTED_LE;
 }

 return rc;
}

static bt_status_t btpan_disconnect(const bt_bdaddr_t *bd_addr)
{
 btpan_conn_t* conn = btpan_find_conn_addr(bd_addr->address);
 if (conn && conn->handle >= 0)
 {
 /* Inform the application that the disconnect has been initiated successfully */
        btif_transfer_context(btif_in_pan_generic_evt, BTIF_PAN_CB_DISCONNECTING,
 (char *)bd_addr, sizeof(bt_bdaddr_t), NULL);
        BTA_PanClose(conn->handle);
 return BT_STATUS_SUCCESS;
 }
 return BT_STATUS_FAIL;
}

void bta_hh_co_close(UINT8 dev_handle, UINT8 app_id)
{
    UINT32 i;
 btif_hh_device_t *p_dev = NULL;

    APPL_TRACE_WARNING("%s: dev_handle = %d, app_id = %d", __FUNCTION__, dev_handle, app_id);
 if (dev_handle == BTA_HH_INVALID_HANDLE) {
        APPL_TRACE_WARNING("%s: Oops, dev_handle (%d) is invalid...", __FUNCTION__, dev_handle);
 return;
 }

 for (i = 0; i < BTIF_HH_MAX_HID; i++) {
        p_dev = &btif_hh_cb.devices[i];
 if (p_dev->dev_status != BTHH_CONN_STATE_UNKNOWN && p_dev->dev_handle == dev_handle) {
            APPL_TRACE_WARNING("%s: Found an existing device with the same handle "
 "dev_status = %d, dev_handle =%d"
 ,__FUNCTION__,p_dev->dev_status
 ,p_dev->dev_handle);
            btif_hh_close_poll_thread(p_dev);
 break;
 }
 }
}

static void btif_dm_ssp_key_notif_evt(tBTA_DM_SP_KEY_NOTIF *p_ssp_key_notif)
{
 bt_bdaddr_t bd_addr;
 bt_bdname_t bd_name;
    UINT32 cod;
 int dev_type;

    BTIF_TRACE_DEBUG("%s", __FUNCTION__);

 /* Remote properties update */
 if (!btif_get_device_type(p_ssp_key_notif->bd_addr, &dev_type))
 {
        dev_type = BT_DEVICE_TYPE_BREDR;
 }
    btif_update_remote_properties(p_ssp_key_notif->bd_addr, p_ssp_key_notif->bd_name,
                                  p_ssp_key_notif->dev_class, (tBT_DEVICE_TYPE) dev_type);

    bdcpy(bd_addr.address, p_ssp_key_notif->bd_addr);
    memcpy(bd_name.name, p_ssp_key_notif->bd_name, BD_NAME_LEN);

    bond_state_changed(BT_STATUS_SUCCESS, &bd_addr, BT_BOND_STATE_BONDING);
    pairing_cb.is_ssp = TRUE;
    cod = devclass2uint(p_ssp_key_notif->dev_class);

 if (cod == 0) {
        LOG_DEBUG("%s cod is 0, set as unclassified", __func__);
        cod = COD_UNCLASSIFIED;
 }

    HAL_CBACK(bt_hal_cbacks, ssp_request_cb, &bd_addr, &bd_name,
                     cod, BT_SSP_VARIANT_PASSKEY_NOTIFICATION,
                     p_ssp_key_notif->passkey);
}

static void btsnoop_write(const void *data, size_t length) {
if (logfile_fd != INVALID_FD)
    write(logfile_fd, data, length);

btsnoop_net_write(data, length);
}

static void spawn_reactor_thread(reactor_t *reactor) {
 int ret = pthread_create(&thread, NULL, reactor_thread, reactor);
  EXPECT_EQ(ret, 0);
}

static sent_status_t send_data_to_app(int fd, BT_HDR *p_buf) {

if (p_buf->len == 0)
return SENT_ALL;

  ssize_t sent = send(fd, p_buf->data + p_buf->offset, p_buf->len, MSG_DONTWAIT);

if (sent == -1) {
if (errno == EAGAIN || errno == EWOULDBLOCK || errno == EINTR)
return SENT_NONE;
LOG_ERROR("%s error writing RFCOMM data back to app: %s", __func__, strerror(errno));
return SENT_FAILED;
}

if (sent == 0)
return SENT_FAILED;

if (sent == p_buf->len)
return SENT_ALL;

p_buf->offset += sent;
p_buf->len -= sent;
return SENT_PARTIAL;
}

BOOLEAN bta_hl_co_get_echo_config(UINT8  app_id,
                                  tBTA_HL_ECHO_CFG *p_echo_cfg)
{
    UINT8               app_idx;
    BOOLEAN             success = FALSE;
 btif_hl_app_cb_t *p_acb;
    tBTA_HL_SUP_FEATURE *p_sup;

    BTIF_TRACE_DEBUG("%s app_id=%d",__FUNCTION__, app_id );

 if (btif_hl_find_app_idx(app_id, &app_idx))
 {
        p_acb = BTIF_HL_GET_APP_CB_PTR(app_idx);
        p_sup = &p_acb->sup_feature;
        p_echo_cfg->max_rx_apdu_size = p_sup->echo_cfg.max_rx_apdu_size;
        p_echo_cfg->max_tx_apdu_size = p_sup->echo_cfg.max_tx_apdu_size;
        success = TRUE;
 }

    BTIF_TRACE_DEBUG("%s success=%d max tx_size=%d rx_size=%d",
                      __FUNCTION__, success, p_echo_cfg->max_tx_apdu_size,
                      p_echo_cfg->max_rx_apdu_size );

 return success;
}

extern BOOLEAN UIPC_Ioctl(tUIPC_CH_ID ch_id, UINT32 request, void *param)
{
    BTIF_TRACE_DEBUG("#### UIPC_Ioctl : ch_id %d, request %d ####", ch_id, request);

    UIPC_LOCK();

 switch(request)
 {
 case UIPC_REQ_RX_FLUSH:
            uipc_flush_locked(ch_id);
 break;

 case UIPC_REG_CBACK:
            uipc_main.ch[ch_id].cback = (tUIPC_RCV_CBACK*)param;
 break;

 case UIPC_REG_REMOVE_ACTIVE_READSET:

 /* user will read data directly and not use select loop */
 if (uipc_main.ch[ch_id].fd != UIPC_DISCONNECTED)
 {
 /* remove this channel from active set */
                FD_CLR(uipc_main.ch[ch_id].fd, &uipc_main.active_set);

 /* refresh active set */
                uipc_wakeup_locked();
 }
 break;

 case UIPC_SET_READ_POLL_TMO:
            uipc_main.ch[ch_id].read_poll_tmo_ms = (intptr_t)param;
            BTIF_TRACE_EVENT("UIPC_SET_READ_POLL_TMO : CH %d, TMO %d ms", ch_id, uipc_main.ch[ch_id].read_poll_tmo_ms );
 break;

 default:
            BTIF_TRACE_EVENT("UIPC_Ioctl : request not handled (%d)", request);
 break;
 }

    UIPC_UNLOCK();

 return FALSE;
}

void btif_remote_properties_evt(bt_status_t status, bt_bdaddr_t *remote_addr,
 uint32_t num_props, bt_property_t *p_props)
{
    HAL_CBACK(bt_hal_cbacks, remote_device_properties_cb,
                     status, remote_addr, num_props, p_props);
}

static void free_thread_slot(int h)
{
 if(0 <= h && h < MAX_THREAD)
 {
        close_cmd_fd(h);
        ts[h].used = 0;
 }
 else APPL_TRACE_ERROR("invalid thread handle:%d", h);
}

static void expect_data_multibyte(eager_reader_t *reader, void *context) {
 char *data = (char *)context;
 int length = strlen(data);

 for (int i = 0; i < length;) {
 uint8_t buffer[28];
 int bytes_to_read = (length - i) > 28 ? 28 : (length - i);
 int bytes_read = eager_reader_read(reader, buffer, bytes_to_read, false);
    EXPECT_EQ(bytes_to_read, bytes_read);
 for (int j = 0; j < bytes_read && i < length; j++, i++) {
      EXPECT_EQ(data[i], buffer[j]);
 }
 }

  semaphore_post(done);
}

bt_status_t btif_get_remote_device_property(bt_bdaddr_t *remote_addr,
 bt_property_type_t type)
{
 btif_storage_req_t req;

 if (!btif_is_enabled())
 return BT_STATUS_NOT_READY;

    memcpy(&(req.read_req.bd_addr), remote_addr, sizeof(bt_bdaddr_t));
    req.read_req.type = type;
 return btif_transfer_context(execute_storage_remote_request,
                                 BTIF_CORE_STORAGE_REMOTE_READ,
 (char*)&req, sizeof(btif_storage_req_t),
                                 NULL);
}

static bt_status_t connect_channel(int app_id, bt_bdaddr_t *bd_addr, int mdep_cfg_index, int *channel_id){
    UINT8                   app_idx, mcl_idx;
 btif_hl_app_cb_t *p_acb = NULL;
 btif_hl_pending_chan_cb_t *p_pcb = NULL;
 btif_hl_mcl_cb_t *p_mcb=NULL;
 bt_status_t             status = BT_STATUS_SUCCESS;
    tBTA_HL_DCH_OPEN_PARAM  dch_open;
    BD_ADDR                 bda;
    UINT8 i;

    CHECK_BTHL_INIT();
    BTIF_TRACE_EVENT("%s", __FUNCTION__);
    btif_hl_display_calling_process_name();


 for (i=0; i<6; i++)
 {
        bda[i] = (UINT8) bd_addr->address[i];
 }
 if (btif_hl_find_app_idx(((UINT8)app_id), &app_idx))
 {
        p_acb = BTIF_HL_GET_APP_CB_PTR(app_idx);
 if (btif_hl_find_mcl_idx(app_idx, bda , &mcl_idx))
 {
            p_mcb = BTIF_HL_GET_MCL_CB_PTR(app_idx, mcl_idx);
 if (p_mcb->is_connected)
 {
                dch_open.ctrl_psm = p_mcb->ctrl_psm;
                dch_open.local_mdep_id = p_acb->sup_feature.mdep[mdep_cfg_index].mdep_id;
                BTIF_TRACE_DEBUG("connect_channel: app_idx =%d, mdep_cfg_indx =%d, mdep_id =%d app_id= %d", app_idx,
                                                mdep_cfg_index, dch_open.local_mdep_id, app_id);
 if (btif_hl_find_peer_mdep_id(p_acb->app_id, p_mcb->bd_addr,
                                              p_acb->sup_feature.mdep[mdep_cfg_index].mdep_cfg.mdep_role,
                                              p_acb->sup_feature.mdep[mdep_cfg_index].mdep_cfg.data_cfg[0].data_type, &dch_open.peer_mdep_id ))
 {
                    dch_open.local_cfg = p_acb->channel_type[mdep_cfg_index];
 if ((p_acb->sup_feature.mdep[mdep_cfg_index].mdep_cfg.mdep_role == BTA_HL_MDEP_ROLE_SOURCE)
 && !btif_hl_is_the_first_reliable_existed(app_idx,mcl_idx))
 {
                        dch_open.local_cfg = BTA_HL_DCH_CFG_RELIABLE;
 }
                    dch_open.sec_mask = (BTA_SEC_AUTHENTICATE | BTA_SEC_ENCRYPT);

 if( !btif_hl_dch_open(p_acb->app_id, bda, &dch_open,
                                              mdep_cfg_index, BTIF_HL_PEND_DCH_OP_OPEN, channel_id ))
 {
                        status = BT_STATUS_FAIL;
                        BTIF_TRACE_EVENT("%s loc0 status = BT_STATUS_FAIL", __FUNCTION__);
 }
 }
 else
 {
                    p_mcb->cch_oper = BTIF_HL_CCH_OP_MDEP_FILTERING;

                    p_pcb = BTIF_HL_GET_PCB_PTR(app_idx, mcl_idx);
                    p_pcb->in_use = TRUE;
                    p_pcb->mdep_cfg_idx = mdep_cfg_index;
                    memcpy(p_pcb->bd_addr, bda, sizeof(BD_ADDR));
                    p_pcb->op = BTIF_HL_PEND_DCH_OP_OPEN;
                    BTA_HlSdpQuery(app_id,p_acb->app_handle, bda);
 }
 }
 else
 {
                status = BT_STATUS_FAIL;
 }
 }
 else
 {
            p_acb->filter.num_elems =1;
            p_acb->filter.elem[0].data_type = p_acb->sup_feature.mdep[mdep_cfg_index].mdep_cfg.data_cfg[mdep_cfg_index].data_type;
 if (p_acb->sup_feature.mdep[mdep_cfg_index].mdep_cfg.mdep_role == BTA_HL_MDEP_ROLE_SINK)
                p_acb->filter.elem[0].peer_mdep_role = BTA_HL_MDEP_ROLE_SOURCE;
 else
                p_acb->filter.elem[0].peer_mdep_role = BTA_HL_MDEP_ROLE_SINK;

 if ( !btif_hl_cch_open(p_acb->app_id, bda, 0, mdep_cfg_index,
                                   BTIF_HL_PEND_DCH_OP_OPEN,
                                   channel_id))
 {
                status = BT_STATUS_FAIL;
 }
 }
 }
 else
 {
        status = BT_STATUS_FAIL;
 }

    BTIF_TRACE_DEBUG("%s status=%d channel_id=0x%08x", __FUNCTION__, status, *channel_id);

 return status;
}

rc_transaction_t *get_transaction_by_lbl(UINT8 lbl)
{
 rc_transaction_t *transaction = NULL;
    pthread_mutex_lock(&device.lbllock);

 /* Determine if this is a valid label */
 if (lbl < MAX_TRANSACTIONS_PER_SESSION)
 {
 if (FALSE==device.transaction[lbl].in_use)
 {
            transaction = NULL;
 }
 else
 {
            transaction = &(device.transaction[lbl]);
            BTIF_TRACE_DEBUG("%s: Got transaction.label: %d",__FUNCTION__,lbl);
 }
 }

    pthread_mutex_unlock(&device.lbllock);
 return transaction;
}

BOOLEAN btif_hl_find_channel_id_using_mdl_id(UINT8 app_idx, tBTA_HL_MDL_ID mdl_id,
 int *p_channel_id){
 btif_hl_app_cb_t *p_acb;
 btif_hl_mdl_cfg_t *p_mdl;
    BOOLEAN found=FALSE;
    UINT8 j=0;
 int mdl_cfg_channel_id;
    p_acb =BTIF_HL_GET_APP_CB_PTR(app_idx);
 if (p_acb && p_acb->in_use)
 {
 for (j=0; j< BTA_HL_NUM_MDL_CFGS; j++)
 {
                    p_mdl =BTIF_HL_GET_MDL_CFG_PTR(app_idx,j);
                    mdl_cfg_channel_id = *(BTIF_HL_GET_MDL_CFG_CHANNEL_ID_PTR(app_idx,j));
 if ( p_mdl->base.active && (p_mdl->base.mdl_id == mdl_id))
 {
                            found = TRUE;
 *p_channel_id = mdl_cfg_channel_id;
 break;
 }
 }
 }
    BTIF_TRACE_EVENT("%s found=%d channel_id=0x%08x, mdl_id=0x%x app_idx=%d mdl_cfg_idx=%d  ",
                    __FUNCTION__,found,*p_channel_id,mdl_id, app_idx,j );
 return found;
}

BOOLEAN btif_hl_find_mdl_cfg_idx_using_channel_id(int channel_id,
                                                  UINT8 *p_app_idx,
                                                  UINT8 *p_mdl_cfg_idx){
 btif_hl_app_cb_t *p_acb;
 btif_hl_mdl_cfg_t *p_mdl;
    BOOLEAN found=FALSE;
    UINT8 i,j;
 int mdl_cfg_channel_id;

 *p_app_idx = 0;
 *p_mdl_cfg_idx =0;
 for (i=0; i < BTA_HL_NUM_APPS ; i ++)
 {
        p_acb =BTIF_HL_GET_APP_CB_PTR(i);
 for (j=0; j< BTA_HL_NUM_MDL_CFGS; j++)
 {
            p_mdl =BTIF_HL_GET_MDL_CFG_PTR(i,j);
            mdl_cfg_channel_id = *(BTIF_HL_GET_MDL_CFG_CHANNEL_ID_PTR(i,j));
 if (p_acb->in_use &&
                p_mdl->base.active &&
 (mdl_cfg_channel_id == channel_id))
 {
                found = TRUE;
 *p_app_idx = i;
 *p_mdl_cfg_idx =j;
 break;
 }
 }
 }

    BTIF_TRACE_EVENT("%s found=%d channel_id=0x%08x, app_idx=%d mdl_cfg_idx=%d  ",
                      __FUNCTION__,found,channel_id, i,j );
 return found;
}

void UIPC_ReadBuf(tUIPC_CH_ID ch_id, BT_HDR *p_msg)
{
    UNUSED(p_msg);

    BTIF_TRACE_DEBUG("UIPC_ReadBuf : ch_id:%d NOT IMPLEMENTED", ch_id);

    UIPC_LOCK();
    UIPC_UNLOCK();
}

static void event_event_stream_has_bytes(UNUSED_ATTR eager_reader_t *reader, UNUSED_ATTR void *context) {
  callbacks->data_ready(DATA_TYPE_EVENT);
}

static void inbound_data_waiting(void *context) {
eager_reader_t *reader = (eager_reader_t *)context;

data_buffer_t *buffer = (data_buffer_t *)reader->allocator->alloc(reader->buffer_size + sizeof(data_buffer_t));
if (!buffer) {
LOG_ERROR("%s couldn't aquire memory for inbound data buffer.", __func__);
return;
}


buffer->length = 0;
buffer->offset = 0;

  int bytes_read = read(reader->inbound_fd, buffer->data, reader->buffer_size);
if (bytes_read > 0) {
// Save the data for later
buffer->length = bytes_read;
fixed_queue_enqueue(reader->buffers, buffer);

// Tell consumers data is available by incrementing
// the semaphore by the number of bytes we just read
eventfd_write(reader->bytes_available_fd, bytes_read);
} else {
if (bytes_read == 0)
LOG_WARN("%s fd said bytes existed, but none were found.", __func__);
else
LOG_WARN("%s unable to read from file descriptor: %s", __func__, strerror(errno));

reader->allocator->free(buffer);
}
}

BOOLEAN btif_hl_find_app_idx_using_handle(tBTA_HL_APP_HANDLE app_handle,
                                          UINT8 *p_app_idx){
    BOOLEAN found=FALSE;
    UINT8 i;

 for (i=0; i < BTA_HL_NUM_APPS ; i ++)
 {
 if (btif_hl_cb.acb[i].in_use &&
 (btif_hl_cb.acb[i].app_handle == app_handle))
 {
            found = TRUE;
 *p_app_idx = i;
 break;
 }
 }

    BTIF_TRACE_EVENT("%s status=%d handle=%d app_idx=%d ",
                      __FUNCTION__, found, app_handle , i);

 return found;
}

static void on_l2cap_write_fixed_done(void* req_id, uint32_t id)
{
    l2cap_socket *sock;

 if (req_id != NULL) {
        osi_free(req_id); //free the buffer
 }

    pthread_mutex_lock(&state_lock);
    sock = btsock_l2cap_find_by_id_l(id);
 if (sock && !sock->outgoing_congest) {
        btsock_thread_add_fd(pth, sock->our_fd, BTSOCK_L2CAP, SOCK_THREAD_FD_RD, sock->id);
 }
    pthread_mutex_unlock(&state_lock);
}

static bool filter_incoming_event(BT_HDR *packet) {
 waiting_command_t *wait_entry = NULL;
 uint8_t *stream = packet->data;
 uint8_t event_code;
 command_opcode_t opcode;

  STREAM_TO_UINT8(event_code, stream);
  STREAM_SKIP_UINT8(stream); // Skip the parameter total length field

 if (event_code == HCI_COMMAND_COMPLETE_EVT) {
    STREAM_TO_UINT8(command_credits, stream);
    STREAM_TO_UINT16(opcode, stream);

    wait_entry = get_waiting_command(opcode);
 if (!wait_entry)
      LOG_WARN("%s command complete event with no matching command. opcode: 0x%x.", __func__, opcode);
 else if (wait_entry->complete_callback)
      wait_entry->complete_callback(packet, wait_entry->context);
 else if (wait_entry->complete_future)
      future_ready(wait_entry->complete_future, packet);

 goto intercepted;
 } else if (event_code == HCI_COMMAND_STATUS_EVT) {
 uint8_t status;
    STREAM_TO_UINT8(status, stream);
    STREAM_TO_UINT8(command_credits, stream);
    STREAM_TO_UINT16(opcode, stream);


    wait_entry = get_waiting_command(opcode);
 if (!wait_entry)
      LOG_WARN("%s command status event with no matching command. opcode: 0x%x", __func__, opcode);
 else if (wait_entry->status_callback)
      wait_entry->status_callback(status, wait_entry->command, wait_entry->context);

 goto intercepted;
 }

 return false;
intercepted:;
  non_repeating_timer_restart_if(command_response_timer, !list_is_empty(commands_pending_response));

 if (wait_entry) {
 if (event_code == HCI_COMMAND_STATUS_EVT || (!wait_entry->complete_callback && !wait_entry->complete_future))
      buffer_allocator->free(packet);

 if (event_code == HCI_COMMAND_COMPLETE_EVT || !wait_entry->status_callback)
      buffer_allocator->free(wait_entry->command);

    osi_free(wait_entry);
 } else {
    buffer_allocator->free(packet);
 }

 return true;
}

static void btif_dm_data_copy(uint16_t event, char *dst, char *src)
{
    tBTA_DM_SEC *dst_dm_sec = (tBTA_DM_SEC*)dst;
    tBTA_DM_SEC *src_dm_sec = (tBTA_DM_SEC*)src;

 if (!src_dm_sec)
 return;

    assert(dst_dm_sec);
    memcpy(dst_dm_sec, src_dm_sec, sizeof(tBTA_DM_SEC));

 if (event == BTA_DM_BLE_KEY_EVT)
 {
        dst_dm_sec->ble_key.p_key_value = osi_malloc(sizeof(tBTM_LE_KEY_VALUE));
        assert(src_dm_sec->ble_key.p_key_value);
        assert(dst_dm_sec->ble_key.p_key_value);
        memcpy(dst_dm_sec->ble_key.p_key_value, src_dm_sec->ble_key.p_key_value, sizeof(tBTM_LE_KEY_VALUE));
 }
}

bt_status_t btif_dm_get_adapter_property(bt_property_t *prop)
{
    BTIF_TRACE_EVENT("%s: type=0x%x", __FUNCTION__, prop->type);
 switch (prop->type)
 {
 case BT_PROPERTY_BDNAME:
 {
 bt_bdname_t *bd_name = (bt_bdname_t*)prop->val;
            strncpy((char *)bd_name->name, (char *)btif_get_default_local_name(),
 sizeof(bd_name->name) - 1);
            bd_name->name[sizeof(bd_name->name) - 1] = 0;
            prop->len = strlen((char *)bd_name->name);
 }
 break;

 case BT_PROPERTY_ADAPTER_SCAN_MODE:
 {
 /* if the storage does not have it. Most likely app never set it. Default is NONE */
 bt_scan_mode_t *mode = (bt_scan_mode_t*)prop->val;
 *mode = BT_SCAN_MODE_NONE;
            prop->len = sizeof(bt_scan_mode_t);
 }
 break;

 case BT_PROPERTY_ADAPTER_DISCOVERY_TIMEOUT:
 {
 uint32_t *tmt = (uint32_t*)prop->val;
 *tmt = 120; /* default to 120s, if not found in NV */
            prop->len = sizeof(uint32_t);
 }
 break;

 default:
            prop->len = 0;
 return BT_STATUS_FAIL;
 }
 return BT_STATUS_SUCCESS;
}

static void btif_hl_upstreams_ctrl_evt(UINT16 event, char* p_param){
    tBTA_HL_CTRL *p_data = (tBTA_HL_CTRL *) p_param;
    UINT8               i;
    tBTA_HL_REG_PARAM   reg_param;
 btif_hl_app_cb_t *p_acb;

    BTIF_TRACE_DEBUG("%s event %d", __FUNCTION__, event);
    btif_hl_display_calling_process_name();

 switch ( event )
 {
 case BTA_HL_CTRL_ENABLE_CFM_EVT:
            BTIF_TRACE_DEBUG("Rcv BTA_HL_CTRL_ENABLE_CFM_EVT");
            BTIF_TRACE_DEBUG("status=%d", p_data->enable_cfm.status);

 if (p_data->enable_cfm.status == BTA_HL_STATUS_OK)
 {
                btif_hl_set_state(BTIF_HL_STATE_ENABLED);


 for (i=0; i < BTA_HL_NUM_APPS ; i ++)
 {
                    p_acb = BTIF_HL_GET_APP_CB_PTR(i);
 if (p_acb->in_use && p_acb->reg_pending)
 {
                        p_acb->reg_pending = FALSE;
                        reg_param.dev_type = p_acb->dev_type;
                        reg_param.sec_mask = BTA_SEC_AUTHENTICATE | BTA_SEC_ENCRYPT;
                        reg_param.p_srv_name = p_acb->srv_name;
                        reg_param.p_srv_desp = p_acb->srv_desp;
                        reg_param.p_provider_name = p_acb->provider_name;

                        BTIF_TRACE_DEBUG("Register pending app_id=%d", p_acb->app_id);
                        btif_hl_proc_reg_request (i, p_acb->app_id, &reg_param, btif_hl_cback);
 }
 }
 }

 break;
 case BTA_HL_CTRL_DISABLE_CFM_EVT:
            BTIF_TRACE_DEBUG("Rcv BTA_HL_CTRL_DISABLE_CFM_EVT");
            BTIF_TRACE_DEBUG("status=%d",
                              p_data->disable_cfm.status);

 if (p_data->disable_cfm.status == BTA_HL_STATUS_OK)
 {
                memset(p_btif_hl_cb, 0, sizeof(btif_hl_cb_t));
                btif_hl_set_state(BTIF_HL_STATE_DISABLED);
 }

 break;
 default:
 break;
 }
}

static void btif_hl_ctrl_cback(tBTA_HL_CTRL_EVT event, tBTA_HL_CTRL *p_data){
 bt_status_t status;
 int param_len = 0;

    BTIF_TRACE_DEBUG("%s event %d", __FUNCTION__, event);
    btif_hl_display_calling_process_name();

 switch ( event )
 {
 case BTA_HL_CTRL_ENABLE_CFM_EVT:
 case BTA_HL_CTRL_DISABLE_CFM_EVT:
            param_len = sizeof(tBTA_HL_CTRL_ENABLE_DISABLE);
 break;
 default:
 break;
 }

    status = btif_transfer_context(btif_hl_upstreams_ctrl_evt, (uint16_t)event, (void*)p_data, param_len, NULL);
    ASSERTC(status == BT_STATUS_SUCCESS, "context transfer failed", status);
}

static void *btif_hl_select_thread(void *arg){
fd_set org_set, curr_set;
int r, max_curr_s, max_org_s;
UNUSED(arg);

BTIF_TRACE_DEBUG("entered btif_hl_select_thread");
FD_ZERO(&org_set);
max_org_s = btif_hl_select_wakeup_init(&org_set);
BTIF_TRACE_DEBUG("max_s=%d ", max_org_s);

for (;;)
{
r = 0;

BTIF_TRACE_DEBUG("set curr_set = org_set ");
curr_set = org_set;
max_curr_s = max_org_s;
        int ret = select((max_curr_s + 1), &curr_set, NULL, NULL, NULL);
BTIF_TRACE_DEBUG("select unblocked ret=%d", ret);
if (ret == -1)
{
BTIF_TRACE_DEBUG("select() ret -1, exit the thread");
btif_hl_thread_cleanup();
select_thread_id = -1;
return 0;
}
else if (ret)
{
BTIF_TRACE_DEBUG("btif_hl_select_wake_signaled, signal ret=%d", ret);
if (btif_hl_select_wake_signaled(&curr_set))
{
r = btif_hl_select_wake_reset();
BTIF_TRACE_DEBUG("btif_hl_select_wake_signaled, signal:%d", r);
if (r == btif_hl_signal_select_wakeup || r == btif_hl_signal_select_close_connected )
{
btif_hl_select_wakeup_callback(&org_set, r);
}
else if( r == btif_hl_signal_select_exit)
{
btif_hl_thread_cleanup();
BTIF_TRACE_DEBUG("Exit hl_select_thread for btif_hl_signal_select_exit");
return 0;
}
}

btif_hl_select_monitor_callback(&curr_set, &org_set);
max_org_s = btif_hl_update_maxfd(max_org_s);
}
else
BTIF_TRACE_DEBUG("no data, select ret: %d\n", ret);
}
BTIF_TRACE_DEBUG("leaving hl_select_thread");
return 0;
}

static void prepare_poll_fds(int h, struct pollfd* pfds)
{
 int count = 0;
 int ps_i = 0;
 int pfd_i = 0;
    asrt(ts[h].poll_count <= MAX_POLL);
    memset(pfds, 0, sizeof(pfds[0])*ts[h].poll_count);
 while(count < ts[h].poll_count)
 {
 if(ps_i >= MAX_POLL)
 {
            APPL_TRACE_ERROR("exceed max poll range, ps_i:%d, MAX_POLL:%d, count:%d, ts[h].poll_count:%d",
                    ps_i, MAX_POLL, count, ts[h].poll_count);
 return;
 }
 if(ts[h].ps[ps_i].pfd.fd >= 0)
 {
            pfds[pfd_i] =  ts[h].ps[ps_i].pfd;
            ts[h].psi[pfd_i] = ps_i;
            count++;
            pfd_i++;
 }
        ps_i++;
 }
}

UINT16  btif_hl_get_max_tx_apdu_size(tBTA_HL_MDEP_ROLE mdep_role,
                                     UINT16 data_type ){
    UINT8 idx;
    UINT16 max_tx_apdu_size =0;

 if (btif_hl_find_data_type_idx(data_type, &idx))
 {
 if (mdep_role == BTA_HL_MDEP_ROLE_SOURCE)
 {
            max_tx_apdu_size = data_type_table[idx].max_tx_apdu_size;
 }
 else
 {
            max_tx_apdu_size = data_type_table[idx].max_rx_apdu_size;
 }
 }
 else
 {
 if (mdep_role == BTA_HL_MDEP_ROLE_SOURCE)
 {
            max_tx_apdu_size = BTIF_HL_DEFAULT_SRC_TX_APDU_SIZE;
 }
 else
 {
            max_tx_apdu_size = BTIF_HL_DEFAULT_SRC_RX_APDU_SIZE;
 }


 }

    BTIF_TRACE_DEBUG("%s mdep_role=%d data_type=0x%4x size=%d",
                      __FUNCTION__, mdep_role, data_type, max_tx_apdu_size);
 return max_tx_apdu_size;
}

btif_hl_soc_state_t btif_hl_get_socket_state(btif_hl_soc_cb_t *p_scb){
    BTIF_TRACE_DEBUG("btif_hl_get_socket_state state=%d", p_scb->state);
 return p_scb->state;
}

static void dispatch_reassembled(BT_HDR *packet) {
  assert((packet->event & MSG_EVT_MASK) != MSG_HC_TO_STACK_HCI_EVT);
  assert(upwards_data_queue != NULL);

 if (upwards_data_queue) {
    fixed_queue_enqueue(upwards_data_queue, packet);
 } else {
    LOG_ERROR("%s had no queue to place upwards data packet in. Dropping it on the floor.", __func__);
    buffer_allocator->free(packet);
 }
}

reactor_status_t reactor_run_once(reactor_t *reactor) {
  assert(reactor != NULL);
 return run_reactor(reactor, 1);
}

static int adev_open_output_stream(struct audio_hw_device *dev,
audio_io_handle_t handle,
audio_devices_t devices,
audio_output_flags_t flags,
struct audio_config *config,
struct audio_stream_out **stream_out,
const char *address)

{
struct a2dp_audio_device *a2dp_dev = (struct a2dp_audio_device *)dev;
struct a2dp_stream_out *out;
int ret = 0;
int i;
UNUSED(address);
UNUSED(handle);
UNUSED(devices);
UNUSED(flags);

INFO("opening output");

out = (struct a2dp_stream_out *)calloc(1, sizeof(struct a2dp_stream_out));

if (!out)
return -ENOMEM;

out->stream.common.get_sample_rate = out_get_sample_rate;
out->stream.common.set_sample_rate = out_set_sample_rate;
out->stream.common.get_buffer_size = out_get_buffer_size;
out->stream.common.get_channels = out_get_channels;
out->stream.common.get_format = out_get_format;
out->stream.common.set_format = out_set_format;
out->stream.common.standby = out_standby;
out->stream.common.dump = out_dump;
out->stream.common.set_parameters = out_set_parameters;
out->stream.common.get_parameters = out_get_parameters;
out->stream.common.add_audio_effect = out_add_audio_effect;
out->stream.common.remove_audio_effect = out_remove_audio_effect;
out->stream.get_latency = out_get_latency;
out->stream.set_volume = out_set_volume;
out->stream.write = out_write;
out->stream.get_render_position = out_get_render_position;
out->stream.get_presentation_position = out_get_presentation_position;


/* initialize a2dp specifics */
a2dp_stream_common_init(&out->common);

out->common.cfg.channel_flags = AUDIO_STREAM_DEFAULT_CHANNEL_FLAG;
out->common.cfg.format = AUDIO_STREAM_DEFAULT_FORMAT;
out->common.cfg.rate = AUDIO_STREAM_DEFAULT_RATE;

/* set output config values */
if (config)
{
config->format = out_get_format((const struct audio_stream *)&out->stream);
config->sample_rate = out_get_sample_rate((const struct audio_stream *)&out->stream);
config->channel_mask = out_get_channels((const struct audio_stream *)&out->stream);
}
*stream_out = &out->stream;
a2dp_dev->output = out;

a2dp_open_ctrl_path(&out->common);
if (out->common.ctrl_fd == AUDIO_SKT_DISCONNECTED)
{
ERROR("ctrl socket failed to connect (%s)", strerror(errno));
ret = -1;
goto err_open;
}


DEBUG("success");
/* Delay to ensure Headset is in proper state when START is initiated
from DUT immediately after the connection due to ongoing music playback. */
    usleep(250000);
return 0;

err_open:
free(out);
*stream_out = NULL;
a2dp_dev->output = NULL;
ERROR("failed");
return ret;
}

void btif_hl_send_destroyed_cb(btif_hl_app_cb_t *p_acb ){
 bt_bdaddr_t     bd_addr;
 int             app_id = (int) btif_hl_get_app_id(p_acb->delete_mdl.channel_id);

    btif_hl_copy_bda(&bd_addr, p_acb->delete_mdl.bd_addr);
    BTIF_TRACE_DEBUG("%s",__FUNCTION__);
    BTIF_TRACE_DEBUG("call channel state callback channel_id=0x%08x mdep_cfg_idx=%d, state=%d fd=%d",p_acb->delete_mdl.channel_id,
                      p_acb->delete_mdl.mdep_cfg_idx, BTHL_CONN_STATE_DESTROYED, 0);
    btif_hl_display_bt_bda(&bd_addr);

    BTIF_HL_CALL_CBACK(bt_hl_callbacks, channel_state_cb,  app_id,
 &bd_addr, p_acb->delete_mdl.mdep_cfg_idx,
                       p_acb->delete_mdl.channel_id, BTHL_CONN_STATE_DESTROYED, 0 );
}

int bta_co_rfc_data_incoming(void *user_data, BT_HDR *p_buf) {
  pthread_mutex_lock(&slot_lock);

 int ret = 0;
 uint32_t id = (uintptr_t)user_data;
 rfc_slot_t *slot = find_rfc_slot_by_id(id);
 if (!slot)
 goto out;

 if (list_is_empty(slot->incoming_queue)) {
 switch (send_data_to_app(slot->fd, p_buf)) {
 case SENT_NONE:
 case SENT_PARTIAL:
        list_append(slot->incoming_queue, p_buf);
        btsock_thread_add_fd(pth, slot->fd, BTSOCK_RFCOMM, SOCK_THREAD_FD_WR, slot->id);
 break;

 case SENT_ALL:
        GKI_freebuf(p_buf);
        ret = 1; // Enable data flow.
 break;

 case SENT_FAILED:
        GKI_freebuf(p_buf);
        cleanup_rfc_slot(slot);
 break;
 }
 } else {
    list_append(slot->incoming_queue, p_buf);
 }

out:;
  pthread_mutex_unlock(&slot_lock);
 return ret; // Return 0 to disable data flow.
}

static int adev_set_parameters(struct audio_hw_device *dev, const char *kvpairs)
{
 struct a2dp_audio_device *a2dp_dev = (struct a2dp_audio_device *)dev;
 struct a2dp_stream_out *out = a2dp_dev->output;
 int retval = 0;

 if (out == NULL)
 return retval;

    INFO("state %d", out->common.state);

    retval = out->stream.common.set_parameters((struct audio_stream *)out, kvpairs);

 return retval;
}

void btif_hl_send_disconnecting_cb(UINT8 app_idx, UINT8 mcl_idx, UINT8 mdl_idx){
 btif_hl_mdl_cb_t *p_dcb = BTIF_HL_GET_MDL_CB_PTR( app_idx,  mcl_idx, mdl_idx);
 btif_hl_soc_cb_t *p_scb = p_dcb->p_scb;
 bt_bdaddr_t             bd_addr;
 int                     app_id = (int) btif_hl_get_app_id(p_scb->channel_id);

    btif_hl_copy_bda(&bd_addr, p_scb->bd_addr);

    BTIF_TRACE_DEBUG("%s",__FUNCTION__);
    BTIF_TRACE_DEBUG("call channel state callback  channel_id=0x%08x mdep_cfg_idx=%d, state=%d fd=%d",p_scb->channel_id,
                      p_scb->mdep_cfg_idx, BTHL_CONN_STATE_DISCONNECTING, p_scb->socket_id[0]);
    btif_hl_display_bt_bda(&bd_addr);
    BTIF_HL_CALL_CBACK(bt_hl_callbacks, channel_state_cb,  app_id,
 &bd_addr, p_scb->mdep_cfg_idx,
                       p_scb->channel_id, BTHL_CONN_STATE_DISCONNECTING, p_scb->socket_id[0] );
}

static void btif_dm_search_devices_evt (UINT16 event, char *p_param)
{
    tBTA_DM_SEARCH *p_search_data;
    BTIF_TRACE_EVENT("%s event=%s", __FUNCTION__, dump_dm_search_event(event));

 switch (event)
 {
 case BTA_DM_DISC_RES_EVT:
 {
            p_search_data = (tBTA_DM_SEARCH *)p_param;
 /* Remote name update */
 if (strlen((const char *) p_search_data->disc_res.bd_name))
 {
 bt_property_t properties[1];
 bt_bdaddr_t bdaddr;
 bt_status_t status;

                properties[0].type = BT_PROPERTY_BDNAME;
                properties[0].val = p_search_data->disc_res.bd_name;
                properties[0].len = strlen((char *)p_search_data->disc_res.bd_name);
                bdcpy(bdaddr.address, p_search_data->disc_res.bd_addr);

                status = btif_storage_set_remote_device_property(&bdaddr, &properties[0]);
                ASSERTC(status == BT_STATUS_SUCCESS, "failed to save remote device property", status);
                HAL_CBACK(bt_hal_cbacks, remote_device_properties_cb,
                                 status, &bdaddr, 1, properties);
 }
 /* TODO: Services? */
 }
 break;

 case BTA_DM_INQ_RES_EVT:
 {
 /* inquiry result */
            UINT32 cod;
 bt_bdname_t bdname;
 bt_bdaddr_t bdaddr;
            UINT8 remote_name_len;
            tBTA_SERVICE_MASK services = 0;
 bdstr_t bdstr;

            p_search_data = (tBTA_DM_SEARCH *)p_param;
            bdcpy(bdaddr.address, p_search_data->inq_res.bd_addr);

            BTIF_TRACE_DEBUG("%s() %s device_type = 0x%x\n", __FUNCTION__, bdaddr_to_string(&bdaddr, bdstr, sizeof(bdstr)),
#if (BLE_INCLUDED == TRUE)
                    p_search_data->inq_res.device_type);
#else
                    BT_DEVICE_TYPE_BREDR);
#endif
            bdname.name[0] = 0;

            cod = devclass2uint (p_search_data->inq_res.dev_class);

 if (cod == 0) {
                LOG_DEBUG("%s cod is 0, set as unclassified", __func__);
                cod = COD_UNCLASSIFIED;
 }

 if (!check_eir_remote_name(p_search_data, bdname.name, &remote_name_len))
                check_cached_remote_name(p_search_data, bdname.name, &remote_name_len);

 /* Check EIR for remote name and services */
 if (p_search_data->inq_res.p_eir)
 {
                BTA_GetEirService(p_search_data->inq_res.p_eir, &services);
                BTIF_TRACE_DEBUG("%s()EIR BTA services = %08X", __FUNCTION__, (UINT32)services);
 /* TODO:  Get the service list and check to see which uuids we got and send it back to the client. */
 }


 {
 bt_property_t properties[5];
 bt_device_type_t dev_type;
 uint32_t num_properties = 0;
 bt_status_t status;
 int addr_type = 0;

                memset(properties, 0, sizeof(properties));
 /* BD_ADDR */
                BTIF_STORAGE_FILL_PROPERTY(&properties[num_properties],
                                    BT_PROPERTY_BDADDR, sizeof(bdaddr), &bdaddr);
                num_properties++;
 /* BD_NAME */
 /* Don't send BDNAME if it is empty */
 if (bdname.name[0])
 {
                    BTIF_STORAGE_FILL_PROPERTY(&properties[num_properties],
                                               BT_PROPERTY_BDNAME,
                                               strlen((char *)bdname.name), &bdname);
                    num_properties++;
 }

 /* DEV_CLASS */
                BTIF_STORAGE_FILL_PROPERTY(&properties[num_properties],
                                    BT_PROPERTY_CLASS_OF_DEVICE, sizeof(cod), &cod);
                num_properties++;
 /* DEV_TYPE */
#if (defined(BLE_INCLUDED) && (BLE_INCLUDED == TRUE))
 /* FixMe: Assumption is that bluetooth.h and BTE enums match */

 /* Verify if the device is dual mode in NVRAM */
 int stored_device_type = 0;
 if (btif_get_device_type(bdaddr.address, &stored_device_type) &&
 ((stored_device_type == BT_DEVICE_TYPE_BLE &&
                        p_search_data->inq_res.device_type == BT_DEVICE_TYPE_BREDR) ||
 (stored_device_type == BT_DEVICE_TYPE_BREDR &&
                        p_search_data->inq_res.device_type == BT_DEVICE_TYPE_BLE))) {
                    dev_type = BT_DEVICE_TYPE_DUMO;
 } else {
                    dev_type = p_search_data->inq_res.device_type;
 }

 if (p_search_data->inq_res.device_type == BT_DEVICE_TYPE_BLE)
                    addr_type = p_search_data->inq_res.ble_addr_type;
#else
                dev_type = BT_DEVICE_TYPE_BREDR;
#endif
                BTIF_STORAGE_FILL_PROPERTY(&properties[num_properties],
                                    BT_PROPERTY_TYPE_OF_DEVICE, sizeof(dev_type), &dev_type);
                num_properties++;
 /* RSSI */
                BTIF_STORAGE_FILL_PROPERTY(&properties[num_properties],
                                    BT_PROPERTY_REMOTE_RSSI, sizeof(int8_t),
 &(p_search_data->inq_res.rssi));
                num_properties++;

                status = btif_storage_add_remote_device(&bdaddr, num_properties, properties);
                ASSERTC(status == BT_STATUS_SUCCESS, "failed to save remote device (inquiry)", status);
#if (defined(BLE_INCLUDED) && (BLE_INCLUDED == TRUE))
                status = btif_storage_set_remote_addr_type(&bdaddr, addr_type);
                ASSERTC(status == BT_STATUS_SUCCESS, "failed to save remote addr type (inquiry)", status);
#endif
 /* Callback to notify upper layer of device */
                HAL_CBACK(bt_hal_cbacks, device_found_cb,
                                 num_properties, properties);
 }
 }
 break;

 case BTA_DM_INQ_CMPL_EVT:
 {
#if (defined(BLE_INCLUDED) && (BLE_INCLUDED == TRUE))
            tBTA_DM_BLE_PF_FILT_PARAMS adv_filt_param;
            memset(&adv_filt_param, 0, sizeof(tBTA_DM_BLE_PF_FILT_PARAMS));
            BTA_DmBleScanFilterSetup(BTA_DM_BLE_SCAN_COND_DELETE, 0, &adv_filt_param, NULL,
                                     bte_scan_filt_param_cfg_evt, 0);
#endif
 }
 break;
 case BTA_DM_DISC_CMPL_EVT:
 {
            HAL_CBACK(bt_hal_cbacks, discovery_state_changed_cb, BT_DISCOVERY_STOPPED);
 }
 break;
 case BTA_DM_SEARCH_CANCEL_CMPL_EVT:
 {
 /* if inquiry is not in progress and we get a cancel event, then
            * it means we are done with inquiry, but remote_name fetches are in
            * progress
            *
            * if inquiry  is in progress, then we don't want to act on this cancel_cmpl_evt
            * but instead wait for the cancel_cmpl_evt via the Busy Level
            *
            */
 if (btif_dm_inquiry_in_progress == FALSE)
 {
#if (defined(BLE_INCLUDED) && (BLE_INCLUDED == TRUE))
               tBTA_DM_BLE_PF_FILT_PARAMS adv_filt_param;
               memset(&adv_filt_param, 0, sizeof(tBTA_DM_BLE_PF_FILT_PARAMS));
               BTA_DmBleScanFilterSetup(BTA_DM_BLE_SCAN_COND_DELETE, 0, &adv_filt_param, NULL,
                                        bte_scan_filt_param_cfg_evt, 0);
#endif
               HAL_CBACK(bt_hal_cbacks, discovery_state_changed_cb, BT_DISCOVERY_STOPPED);
 }
 }
 break;
 }
}

static uint32_t in_get_sample_rate(const struct audio_stream *stream)
{
 struct a2dp_stream_in *in = (struct a2dp_stream_in *)stream;

    FNLOG();
 return in->common.cfg.rate;
}

static void pan_disable()
{
 if (btpan_cb.enabled)
 {
        btpan_cb.enabled = 0;
        BTA_PanDisable();
 if (btpan_cb.tap_fd != INVALID_FD)
 {
            btpan_tap_close(btpan_cb.tap_fd);
            btpan_cb.tap_fd = INVALID_FD;
 }
 }
}

static int adev_init_check(const struct audio_hw_device *dev)
{
 struct a2dp_audio_device *a2dp_dev = (struct a2dp_audio_device*)dev;

    FNLOG();

 return 0;
}

void bta_hl_co_save_mdl(UINT8 mdep_id, UINT8 item_idx, tBTA_HL_MDL_CFG *p_mdl_cfg )
{

    BTIF_TRACE_DEBUG("%s mdep_id =%d, item_idx=%d active=%d mdl_id=%d time=%d",
                      __FUNCTION__, mdep_id, item_idx,
                      p_mdl_cfg->active,
                      p_mdl_cfg->mdl_id,
                      p_mdl_cfg->time);

    btif_hl_save_mdl_cfg(mdep_id, item_idx, p_mdl_cfg);

}

static void event_epilog(UNUSED_ATTR void *context) {
  vendor->send_async_command(VENDOR_DO_EPILOG, NULL);
}

static void *reactor_thread(void *ptr) {
 reactor_t *reactor = (reactor_t *)ptr;

  thread_running = true;
  reactor_start(reactor);
  thread_running = false;

 return NULL;
}

static void command_timed_out(UNUSED_ATTR void *context) {
pthread_mutex_lock(&commands_pending_response_lock);

if (list_is_empty(commands_pending_response)) {
LOG_ERROR("%s with no commands pending response", __func__);
} else {
waiting_command_t *wait_entry = list_front(commands_pending_response);
pthread_mutex_unlock(&commands_pending_response_lock);

// We shouldn't try to recover the stack from this command timeout.
// If it's caused by a software bug, fix it. If it's a hardware bug, fix it.
LOG_ERROR("%s hci layer timeout waiting for response to a command. opcode: 0x%x", __func__, wait_entry->opcode);

}

LOG_ERROR("%s restarting the bluetooth process.", __func__);
  usleep(10000);
kill(getpid(), SIGKILL);
}

static UINT8 btif_hl_get_next_app_id(){
    UINT8 next_app_id = btif_hl_cb.next_app_id;

    btif_hl_cb.next_app_id++;
 return next_app_id;
}

static future_t *init(void) {
  memset(&gki_cb, 0, sizeof(gki_cb));

 pthread_mutexattr_t attr;
  pthread_mutexattr_init(&attr);
  pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE_NP);
  pthread_mutex_init(&gki_cb.lock, &attr);

  gki_buffer_init();
 return NULL;
}

static void event_uart_has_bytes(eager_reader_t *reader, UNUSED_ATTR void *context) {
 if (stream_has_interpretation) {
    callbacks->data_ready(current_data_type);
 } else {
 uint8_t type_byte;
 if (eager_reader_read(reader, &type_byte, 1, true) == 0) {
      LOG_ERROR("%s could not read HCI message type", __func__);
 return;
 }

 if (stream_corrupted_during_le_scan_workaround(type_byte))
 return;

 if (type_byte < DATA_TYPE_ACL || type_byte > DATA_TYPE_EVENT) {
      LOG_ERROR("%s Unknown HCI message type. Dropping this byte 0x%x, min %x, max %x", __func__, type_byte, DATA_TYPE_ACL, DATA_TYPE_EVENT);
 return;
 }

    stream_has_interpretation = true;
    current_data_type = type_byte;
 }
}

static char *trim(char *str) {
 while (isspace(*str))
 ++str;

 if (!*str)
 return str;

 char *end_str = str + strlen(str) - 1;
 while (end_str > str && isspace(*end_str))
 --end_str;

  end_str[1] = '\0';
 return str;
}

static char* btif_get_default_local_name() {
 if (btif_default_local_name[0] == '\0')
 {
 int max_len = sizeof(btif_default_local_name) - 1;
 if (BTM_DEF_LOCAL_NAME[0] != '\0')
 {
            strncpy(btif_default_local_name, BTM_DEF_LOCAL_NAME, max_len);
 }
 else
 {
 char prop_model[PROPERTY_VALUE_MAX];
            property_get(PROPERTY_PRODUCT_MODEL, prop_model, "");
            strncpy(btif_default_local_name, prop_model, max_len);
 }
        btif_default_local_name[max_len] = '\0';
 }
 return btif_default_local_name;
}

static void capture(const BT_HDR *buffer, bool is_received) {
 const uint8_t *p = buffer->data + buffer->offset;

  btsnoop_mem_capture(buffer);

 if (logfile_fd == INVALID_FD)
 return;

 switch (buffer->event & MSG_EVT_MASK) {
 case MSG_HC_TO_STACK_HCI_EVT:
      btsnoop_write_packet(kEventPacket, p, false);
 break;
 case MSG_HC_TO_STACK_HCI_ACL:
 case MSG_STACK_TO_HC_HCI_ACL:
      btsnoop_write_packet(kAclPacket, p, is_received);
 break;
 case MSG_HC_TO_STACK_HCI_SCO:
 case MSG_STACK_TO_HC_HCI_SCO:
      btsnoop_write_packet(kScoPacket, p, is_received);
 break;
 case MSG_STACK_TO_HC_HCI_CMD:
      btsnoop_write_packet(kCommandPacket, p, true);
 break;
 }
}

static void *btif_hh_poll_event_thread(void *arg)
{
btif_hh_device_t *p_dev = arg;
APPL_TRACE_DEBUG("%s: Thread created fd = %d", __FUNCTION__, p_dev->fd);
struct pollfd pfds[1];
int ret;

pfds[0].fd = p_dev->fd;
pfds[0].events = POLLIN;

// Set the uhid fd as non-blocking to ensure we never block the BTU thread

uhid_set_non_blocking(p_dev->fd);

while(p_dev->hh_keep_polling){
        ret = poll(pfds, 1, 50);
if (ret < 0) {
APPL_TRACE_ERROR("%s: Cannot poll for fds: %s\n", __FUNCTION__, strerror(errno));
break;
}
if (pfds[0].revents & POLLIN) {
APPL_TRACE_DEBUG("btif_hh_poll_event_thread: POLLIN");
ret = uhid_event(p_dev);
if (ret){
break;
}
}
}

p_dev->hh_poll_thread_id = -1;
return 0;
}

static int set_pcm_loopback(int argc, char **argv) {
 if (argc != 1) {
    printf("PCM loopback mode not specified.\n");
 return 1;
 }

 if (strcmp(argv[0], "true") && strcmp(argv[0], "false")) {
    printf("Invalid PCM mode '%s'.\n", argv[0]);
 return 2;
 }

 uint8_t packet[] = { 0x24, 0xFC, 0x01, 0x00 };
 if (argv[0][0] == 't')
    packet[ARRAY_SIZE(packet) - 1] = 0x01;

 return !write_hci_command(HCI_PACKET_COMMAND, packet, ARRAY_SIZE(packet));
}

bt_status_t btif_dm_get_remote_services_by_transport(bt_bdaddr_t *remote_addr, const int transport)
{
    BTIF_TRACE_EVENT("%s", __func__);

 /* Set the mask extension */
    tBTA_SERVICE_MASK_EXT mask_ext;
    mask_ext.num_uuid = 0;
    mask_ext.p_uuid = NULL;
    mask_ext.srvc_mask = BTA_ALL_SERVICE_MASK;

    BTA_DmDiscoverByTransport(remote_addr->address, &mask_ext,
                   bte_dm_search_services_evt, TRUE, transport);

 return BT_STATUS_SUCCESS;
}

static l2cap_socket *btsock_l2cap_find_by_id_l(uint32_t id)
{
    l2cap_socket *sock = socks;

 while (sock && sock->id != id)
        sock = sock->next;

 return sock;
}

static void event_command_ready(fixed_queue_t *queue, UNUSED_ATTR void *context) {
 if (command_credits > 0) {
 waiting_command_t *wait_entry = fixed_queue_dequeue(queue);
    command_credits--;

    pthread_mutex_lock(&commands_pending_response_lock);
    list_append(commands_pending_response, wait_entry);
    pthread_mutex_unlock(&commands_pending_response_lock);

    low_power_manager->wake_assert();
    packet_fragmenter->fragment_and_dispatch(wait_entry->command);
    low_power_manager->transmit_done();

    non_repeating_timer_restart_if(command_response_timer, !list_is_empty(commands_pending_response));
 }
}

static char packet_get_head_l(l2cap_socket *sock, uint8_t **data, uint32_t *len)
{
 struct packet *p = sock->first_packet;

 if (!p)
 return FALSE;

 if (data)
 *data = sock->first_packet->data;
 if (len)
 *len = sock->first_packet->len;
    sock->first_packet = p->next;
 if (sock->first_packet)
        sock->first_packet->prev = NULL;
 else
        sock->last_packet = NULL;

 if(len)
        sock->bytes_buffered -= *len;

    osi_free(p);

 return TRUE;
}

static void btif_dm_ble_key_notif_evt(tBTA_DM_SP_KEY_NOTIF *p_ssp_key_notif)
{
 bt_bdaddr_t bd_addr;
 bt_bdname_t bd_name;
    UINT32 cod;
 int dev_type;

    BTIF_TRACE_DEBUG("%s", __FUNCTION__);

 /* Remote name update */
 if (!btif_get_device_type(p_ssp_key_notif->bd_addr, &dev_type))
 {
        dev_type = BT_DEVICE_TYPE_BLE;
 }
    btif_dm_update_ble_remote_properties(p_ssp_key_notif->bd_addr , p_ssp_key_notif->bd_name,
 (tBT_DEVICE_TYPE) dev_type);
    bdcpy(bd_addr.address, p_ssp_key_notif->bd_addr);
    memcpy(bd_name.name, p_ssp_key_notif->bd_name, BD_NAME_LEN);

    bond_state_changed(BT_STATUS_SUCCESS, &bd_addr, BT_BOND_STATE_BONDING);
    pairing_cb.is_ssp = FALSE;
    cod = COD_UNCLASSIFIED;

    HAL_CBACK(bt_hal_cbacks, ssp_request_cb, &bd_addr, &bd_name,
              cod, BT_SSP_VARIANT_PASSKEY_NOTIFICATION,
              p_ssp_key_notif->passkey);
}

static int uhid_event(btif_hh_device_t *p_dev)
{
struct uhid_event ev;
ssize_t ret;
memset(&ev, 0, sizeof(ev));
if(!p_dev)
{

APPL_TRACE_ERROR("%s: Device not found",__FUNCTION__)
return -1;
}
    ret = read(p_dev->fd, &ev, sizeof(ev));
if (ret == 0) {
APPL_TRACE_ERROR("%s: Read HUP on uhid-cdev %s", __FUNCTION__,
strerror(errno));
return -EFAULT;
} else if (ret < 0) {
APPL_TRACE_ERROR("%s: Cannot read uhid-cdev: %s", __FUNCTION__,
strerror(errno));
return -errno;
} else if ((ev.type == UHID_OUTPUT) || (ev.type==UHID_OUTPUT_EV)) {
// Only these two types havae payload,
// ensure we read full event descriptor
if (ret < (ssize_t)sizeof(ev)) {
APPL_TRACE_ERROR("%s: Invalid size read from uhid-dev: %ld != %lu",
__FUNCTION__, ret, sizeof(ev.type));
return -EFAULT;
}
}

switch (ev.type) {
case UHID_START:
APPL_TRACE_DEBUG("UHID_START from uhid-dev\n");
p_dev->ready_for_data = TRUE;
break;
case UHID_STOP:
APPL_TRACE_DEBUG("UHID_STOP from uhid-dev\n");
p_dev->ready_for_data = FALSE;
break;
case UHID_OPEN:
APPL_TRACE_DEBUG("UHID_OPEN from uhid-dev\n");
break;
case UHID_CLOSE:
APPL_TRACE_DEBUG("UHID_CLOSE from uhid-dev\n");
p_dev->ready_for_data = FALSE;
break;
case UHID_OUTPUT:
if (ret < (ssize_t)(sizeof(ev.type) + sizeof(ev.u.output))) {
APPL_TRACE_ERROR("%s: Invalid size read from uhid-dev: %zd < %zu",
__FUNCTION__, ret,
sizeof(ev.type) + sizeof(ev.u.output));
return -EFAULT;
}

APPL_TRACE_DEBUG("UHID_OUTPUT: Report type = %d, report_size = %d"
,ev.u.output.rtype, ev.u.output.size);
//Send SET_REPORT with feature report if the report type in output event is FEATURE
if(ev.u.output.rtype == UHID_FEATURE_REPORT)
btif_hh_setreport(p_dev, BTHH_FEATURE_REPORT,
ev.u.output.size, ev.u.output.data);
else if(ev.u.output.rtype == UHID_OUTPUT_REPORT)
btif_hh_setreport(p_dev, BTHH_OUTPUT_REPORT,
ev.u.output.size, ev.u.output.data);
else
btif_hh_setreport(p_dev, BTHH_INPUT_REPORT,
ev.u.output.size, ev.u.output.data);
break;
case UHID_OUTPUT_EV:
APPL_TRACE_DEBUG("UHID_OUTPUT_EV from uhid-dev\n");
break;
case UHID_FEATURE:
APPL_TRACE_DEBUG("UHID_FEATURE from uhid-dev\n");
break;
case UHID_FEATURE_ANSWER:
APPL_TRACE_DEBUG("UHID_FEATURE_ANSWER from uhid-dev\n");
break;

default:
APPL_TRACE_DEBUG("Invalid event from uhid-dev: %u\n", ev.type);
}

return 0;
}

static BOOLEAN  btif_hl_find_data_type_idx(UINT16 data_type, UINT8 *p_idx){
    BOOLEAN found = FALSE;
    UINT8 i;

 for (i=0; i< BTIF_HL_DATA_TABLE_SIZE; i++ )
 {
 if (data_type_table[i].data_type == data_type)
 {
            found = TRUE;
 *p_idx= i;
 break;
 }
 }

    BTIF_TRACE_DEBUG("%s found=%d, data_type=0x%x idx=%d", __FUNCTION__, found, data_type, i);
 return found;
}

static void join_reactor_thread() {
  pthread_join(thread, NULL);
}

void btif_hl_soc_thread_init(void){
    BTIF_TRACE_DEBUG("%s", __FUNCTION__);
    soc_queue = list_new(NULL);
 if (soc_queue == NULL)
        LOG_ERROR("%s unable to allocate resources for thread", __func__);
    select_thread_id = create_thread(btif_hl_select_thread, NULL);
}

static void hal_close() {
  LOG_INFO("%s", __func__);

  eager_reader_free(uart_stream);
  vendor->send_command(VENDOR_CLOSE_USERIAL, NULL);
  uart_fd = INVALID_FD;
}

const btrc_interface_t *btif_rc_get_interface(void)
{
    BTIF_TRACE_EVENT("%s", __FUNCTION__);
 return &bt_rc_interface;
}

static bt_status_t register_notification_rsp(btrc_event_id_t event_id,
 btrc_notification_type_t type, btrc_register_notification_t *p_param)
{
    tAVRC_RESPONSE avrc_rsp;
    CHECK_RC_CONNECTED
    BTIF_TRACE_EVENT("## %s ## event_id:%s", __FUNCTION__, dump_rc_notification_event_id(event_id));
 if (btif_rc_cb.rc_notif[event_id-1].bNotify == FALSE)
 {
        BTIF_TRACE_ERROR("Avrcp Event id not registered: event_id = %x", event_id);
 return BT_STATUS_NOT_READY;
 }
    memset(&(avrc_rsp.reg_notif), 0, sizeof(tAVRC_REG_NOTIF_RSP));
    avrc_rsp.reg_notif.event_id = event_id;

 switch(event_id)
 {
 case BTRC_EVT_PLAY_STATUS_CHANGED:
            avrc_rsp.reg_notif.param.play_status = p_param->play_status;
 if (avrc_rsp.reg_notif.param.play_status == PLAY_STATUS_PLAYING)
                btif_av_clear_remote_suspend_flag();
 break;
 case BTRC_EVT_TRACK_CHANGE:
            memcpy(&(avrc_rsp.reg_notif.param.track), &(p_param->track), sizeof(btrc_uid_t));
 break;
 case BTRC_EVT_PLAY_POS_CHANGED:
            avrc_rsp.reg_notif.param.play_pos = p_param->song_pos;
 break;
 default:
            BTIF_TRACE_WARNING("%s : Unhandled event ID : 0x%x", __FUNCTION__, event_id);
 return BT_STATUS_UNHANDLED;
 }

    avrc_rsp.reg_notif.pdu = AVRC_PDU_REGISTER_NOTIFICATION;
    avrc_rsp.reg_notif.opcode = opcode_from_pdu(AVRC_PDU_REGISTER_NOTIFICATION);
    avrc_rsp.get_play_status.status = AVRC_STS_NO_ERROR;

 /* Send the response. */
    send_metamsg_rsp(btif_rc_cb.rc_handle, btif_rc_cb.rc_notif[event_id-1].label,
 ((type == BTRC_NOTIFICATION_TYPE_INTERIM)?AVRC_CMD_NOTIF:AVRC_RSP_CHANGED), &avrc_rsp);
 return BT_STATUS_SUCCESS;
}

int bta_co_rfc_data_outgoing(void *user_data, uint8_t *buf, uint16_t size) {
pthread_mutex_lock(&slot_lock);

uint32_t id = (uintptr_t)user_data;
int ret = false;
rfc_slot_t *slot = find_rfc_slot_by_id(id);

if (!slot)
goto out;

  int received = recv(slot->fd, buf, size, 0);
if(received == size) {
ret = true;
} else {
LOG_ERROR("%s error receiving RFCOMM data from app: %s", __func__, strerror(errno));
cleanup_rfc_slot(slot);
}

out:;
pthread_mutex_unlock(&slot_lock);
return ret;
}

void GKI_disable(void) {
  pthread_mutex_lock(&gki_cb.lock);
}

static void update_logging() {
bool should_log = module_started &&
(logging_enabled_via_api || stack_config->get_btsnoop_turned_on());

if (should_log == is_logging)
return;

is_logging = should_log;
if (should_log) {
btsnoop_net_open();

const char *log_path = stack_config->get_btsnoop_log_path();

// Save the old log if configured to do so
if (stack_config->get_btsnoop_should_save_last()) {
char last_log_path[PATH_MAX];
snprintf(last_log_path, PATH_MAX, "%s.%llu", log_path, btsnoop_timestamp());
if (!rename(log_path, last_log_path) && errno != ENOENT)

LOG_ERROR("%s unable to rename '%s' to '%s': %s", __func__, log_path, last_log_path, strerror(errno));
}

    logfile_fd = open(log_path, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH);
if (logfile_fd == INVALID_FD) {
LOG_ERROR("%s unable to open '%s': %s", __func__, log_path, strerror(errno));
is_logging = false;
return;
}

    write(logfile_fd, "btsnoop\0\0\0\0\1\0\0\x3\xea", 16);
} else {
if (logfile_fd != INVALID_FD)
close(logfile_fd);

logfile_fd = INVALID_FD;
btsnoop_net_close();
}
}

ssize_t socket_write_and_transfer_fd(const socket_t *socket, const void *buf, size_t count, int fd) {
assert(socket != NULL);
assert(buf != NULL);

if (fd == INVALID_FD)
return socket_write(socket, buf, count);

struct msghdr msg;
struct iovec iov;
char control_buf[CMSG_SPACE(sizeof(int))];

iov.iov_base = (void *)buf;
iov.iov_len = count;

msg.msg_iov = &iov;
msg.msg_iovlen = 1;
msg.msg_control = control_buf;
msg.msg_controllen = sizeof(control_buf);
msg.msg_name = NULL;
msg.msg_namelen = 0;

struct cmsghdr *header = CMSG_FIRSTHDR(&msg);
header->cmsg_level = SOL_SOCKET;
header->cmsg_type = SCM_RIGHTS;

header->cmsg_len = CMSG_LEN(sizeof(int));
*(int *)CMSG_DATA(header) = fd;

  ssize_t ret = sendmsg(socket->fd, &msg, MSG_DONTWAIT);
close(fd);
return ret;
}

void reactor_free(reactor_t *reactor) {
 if (!reactor)
 return;

  list_free(reactor->invalidation_list);
  close(reactor->event_fd);
  close(reactor->epoll_fd);
  osi_free(reactor);
}

void semaphore_post(semaphore_t *semaphore) {
  assert(semaphore != NULL);
  assert(semaphore->fd != INVALID_FD);

 if (eventfd_write(semaphore->fd, 1ULL) == -1)
    LOG_ERROR("%s unable to post to semaphore: %s", __func__, strerror(errno));
}

void GKI_delay(UINT32 timeout_ms) {
struct timespec delay;
delay.tv_sec = timeout_ms / 1000;
delay.tv_nsec = 1000 * 1000 * (timeout_ms % 1000);


int err;
do {
    err = nanosleep(&delay, &delay);
} while (err == -1 && errno == EINTR);
}

static bt_status_t btSock_start_l2cap_server_l(l2cap_socket *sock) {
    tL2CAP_CFG_INFO cfg;
 bt_status_t stat = BT_STATUS_SUCCESS;
 /* Setup ETM settings:
     *  mtu will be set below */
    memset(&cfg, 0, sizeof(tL2CAP_CFG_INFO));

    cfg.fcr_present = TRUE;
    cfg.fcr = obex_l2c_fcr_opts_def;

 if (sock->fixed_chan) {

 if (BTA_JvL2capStartServerLE(sock->security, 0, NULL, sock->channel,
                L2CAP_DEFAULT_MTU, NULL, btsock_l2cap_cbk, (void*)sock->id)
 != BTA_JV_SUCCESS)
            stat = BT_STATUS_FAIL;

 } else {
 /* If we have a channel specified in the request, just start the server,
         * else we request a PSM and start the server after we receive a PSM. */
 if(sock->channel < 0) {
 if(BTA_JvGetChannelId(BTA_JV_CONN_TYPE_L2CAP, (void*)sock->id, 0)
 != BTA_JV_SUCCESS)
                stat = BT_STATUS_FAIL;
 } else {
 if (BTA_JvL2capStartServer(sock->security, 0, &obex_l2c_etm_opt,
                    sock->channel, L2CAP_MAX_SDU_LENGTH, &cfg, btsock_l2cap_cbk, (void*)sock->id)
 != BTA_JV_SUCCESS)
                stat = BT_STATUS_FAIL;
 }
 }
 return stat;
}

void reactor_stop(reactor_t *reactor) {
  assert(reactor != NULL);

  eventfd_write(reactor->event_fd, EVENT_REACTOR_STOP);
}

static void on_cli_rfc_connect(tBTA_JV_RFCOMM_OPEN *p_open, uint32_t id) {
  pthread_mutex_lock(&slot_lock);

 rfc_slot_t *slot = find_rfc_slot_by_id(id);
 if (!slot)
 goto out;

 if (p_open->status != BTA_JV_SUCCESS) {
    cleanup_rfc_slot(slot);
 goto out;
 }

  slot->rfc_port_handle = BTA_JvRfcommGetPortHdl(p_open->handle);
  memcpy(slot->addr.address, p_open->rem_bda, 6);

 if (send_app_connect_signal(slot->fd, &slot->addr, slot->scn, 0, -1))
    slot->f.connected = true;
 else
    LOG_ERROR("%s unable to send connect completion signal to caller.", __func__);

out:;
  pthread_mutex_unlock(&slot_lock);
}

static BOOLEAN btif_hl_find_avail_app_idx(UINT8 *p_idx){
    BOOLEAN found = FALSE;
    UINT8 i;

 for (i=0; i < BTA_HL_NUM_APPS ; i ++)
 {
 if (!btif_hl_cb.acb[i].in_use)
 {
            found = TRUE;
 *p_idx = i;
 break;
 }
 }

    BTIF_TRACE_DEBUG("%s found=%d app_idx=%d", __FUNCTION__, found, i);
 return found;
}

static bt_status_t init( bthl_callbacks_t* callbacks ){
 bt_status_t status = BT_STATUS_SUCCESS;

    BTIF_TRACE_EVENT("%s", __FUNCTION__);
    btif_hl_display_calling_process_name();
    bt_hl_callbacks_cb = *callbacks;
    bt_hl_callbacks = &bt_hl_callbacks_cb;
    btif_hl_soc_thread_init();
    reg_counter = 0;
 return status;
}

static void btpan_cleanup_conn(btpan_conn_t* conn)
{
 if (conn)
 {
        conn->handle = -1;
        conn->state = -1;
        memset(&conn->peer, 0, sizeof(conn->peer));
        memset(&conn->eth_addr, 0, sizeof(conn->eth_addr));
        conn->local_role = conn->remote_role = 0;
 }
}

static void btif_dm_upstreams_evt(UINT16 event, char* p_param)
{
tBTA_DM_SEC *p_data = (tBTA_DM_SEC*)p_param;
tBTA_SERVICE_MASK service_mask;
uint32_t i;
bt_bdaddr_t bd_addr;

BTIF_TRACE_EVENT("btif_dm_upstreams_cback  ev: %s", dump_dm_event(event));

switch (event)
{
case BTA_DM_ENABLE_EVT:
{
BD_NAME bdname;
bt_status_t status;
bt_property_t prop;
prop.type = BT_PROPERTY_BDNAME;
prop.len = BD_NAME_LEN;
prop.val = (void*)bdname;

status = btif_storage_get_adapter_property(&prop);
if (status == BT_STATUS_SUCCESS)
{
/* A name exists in the storage. Make this the device name */
BTA_DmSetDeviceName((char*)prop.val);
}
else
{
/* Storage does not have a name yet.
* Use the default name and write it to the chip
*/
BTA_DmSetDeviceName(btif_get_default_local_name());
}

#if (defined(BLE_INCLUDED) && (BLE_INCLUDED == TRUE))
/* Enable local privacy */
BTA_DmBleConfigLocalPrivacy(BLE_LOCAL_PRIVACY_ENABLED);
#endif

/* for each of the enabled services in the mask, trigger the profile
* enable */
service_mask = btif_get_enabled_services_mask();
for (i=0; i <= BTA_MAX_SERVICE_ID; i++)
{
if (service_mask &
(tBTA_SERVICE_MASK)(BTA_SERVICE_ID_TO_SERVICE_MASK(i)))
{
btif_in_execute_service_request(i, TRUE);
}
}
/* clear control blocks */
memset(&pairing_cb, 0, sizeof(btif_dm_pairing_cb_t));
pairing_cb.bond_type = BOND_TYPE_PERSISTENT;

/* This function will also trigger the adapter_properties_cb
** and bonded_devices_info_cb
*/
btif_storage_load_bonded_devices();

btif_storage_load_autopair_device_list();

btif_enable_bluetooth_evt(p_data->enable.status);
}
break;

case BTA_DM_DISABLE_EVT:
/* for each of the enabled services in the mask, trigger the profile
* disable */
service_mask = btif_get_enabled_services_mask();
for (i=0; i <= BTA_MAX_SERVICE_ID; i++)
{
if (service_mask &
(tBTA_SERVICE_MASK)(BTA_SERVICE_ID_TO_SERVICE_MASK(i)))
{
btif_in_execute_service_request(i, FALSE);
}
}
btif_disable_bluetooth_evt();
break;

case BTA_DM_PIN_REQ_EVT:
btif_dm_pin_req_evt(&p_data->pin_req);
break;

case BTA_DM_AUTH_CMPL_EVT:
btif_dm_auth_cmpl_evt(&p_data->auth_cmpl);
break;

case BTA_DM_BOND_CANCEL_CMPL_EVT:
if (pairing_cb.state == BT_BOND_STATE_BONDING)
{
bdcpy(bd_addr.address, pairing_cb.bd_addr);
btm_set_bond_type_dev(pairing_cb.bd_addr, BOND_TYPE_UNKNOWN);
bond_state_changed(p_data->bond_cancel_cmpl.result, &bd_addr, BT_BOND_STATE_NONE);
}
break;

case BTA_DM_SP_CFM_REQ_EVT:
btif_dm_ssp_cfm_req_evt(&p_data->cfm_req);
break;
case BTA_DM_SP_KEY_NOTIF_EVT:
btif_dm_ssp_key_notif_evt(&p_data->key_notif);
break;

case BTA_DM_DEV_UNPAIRED_EVT:
bdcpy(bd_addr.address, p_data->link_down.bd_addr);
btm_set_bond_type_dev(p_data->link_down.bd_addr, BOND_TYPE_UNKNOWN);

/*special handling for HID devices */
#if (defined(BTA_HH_INCLUDED) && (BTA_HH_INCLUDED == TRUE))
btif_hh_remove_device(bd_addr);
#endif
btif_storage_remove_bonded_device(&bd_addr);
bond_state_changed(BT_STATUS_SUCCESS, &bd_addr, BT_BOND_STATE_NONE);
break;

case BTA_DM_BUSY_LEVEL_EVT:
{

if (p_data->busy_level.level_flags & BTM_BL_INQUIRY_PAGING_MASK)
{
if (p_data->busy_level.level_flags == BTM_BL_INQUIRY_STARTED)
{
HAL_CBACK(bt_hal_cbacks, discovery_state_changed_cb,
BT_DISCOVERY_STARTED);
btif_dm_inquiry_in_progress = TRUE;
}
else if (p_data->busy_level.level_flags == BTM_BL_INQUIRY_CANCELLED)
{
HAL_CBACK(bt_hal_cbacks, discovery_state_changed_cb,
BT_DISCOVERY_STOPPED);
btif_dm_inquiry_in_progress = FALSE;
}
else if (p_data->busy_level.level_flags == BTM_BL_INQUIRY_COMPLETE)
{
btif_dm_inquiry_in_progress = FALSE;
}
}
}break;

case BTA_DM_LINK_UP_EVT:
bdcpy(bd_addr.address, p_data->link_up.bd_addr);
BTIF_TRACE_DEBUG("BTA_DM_LINK_UP_EVT. Sending BT_ACL_STATE_CONNECTED");

btif_update_remote_version_property(&bd_addr);

HAL_CBACK(bt_hal_cbacks, acl_state_changed_cb, BT_STATUS_SUCCESS,
&bd_addr, BT_ACL_STATE_CONNECTED);
break;

case BTA_DM_LINK_DOWN_EVT:
bdcpy(bd_addr.address, p_data->link_down.bd_addr);
btm_set_bond_type_dev(p_data->link_down.bd_addr, BOND_TYPE_UNKNOWN);
BTIF_TRACE_DEBUG("BTA_DM_LINK_DOWN_EVT. Sending BT_ACL_STATE_DISCONNECTED");
HAL_CBACK(bt_hal_cbacks, acl_state_changed_cb, BT_STATUS_SUCCESS,
&bd_addr, BT_ACL_STATE_DISCONNECTED);
break;

case BTA_DM_HW_ERROR_EVT:

BTIF_TRACE_ERROR("Received H/W Error. ");
/* Flush storage data */
btif_config_flush();
            usleep(100000); /* 100milliseconds *
/* Killing the process to force a restart as part of fault tolerance */
kill(getpid(), SIGKILL);
break;

#if (defined(BLE_INCLUDED) && (BLE_INCLUDED == TRUE))
case BTA_DM_BLE_KEY_EVT:
BTIF_TRACE_DEBUG("BTA_DM_BLE_KEY_EVT key_type=0x%02x ", p_data->ble_key.key_type);

/* If this pairing is by-product of local initiated GATT client Read or Write,
BTA would not have sent BTA_DM_BLE_SEC_REQ_EVT event and Bond state would not
have setup properly. Setup pairing_cb and notify App about Bonding state now*/
if (pairing_cb.state != BT_BOND_STATE_BONDING)
{
BTIF_TRACE_DEBUG("Bond state not sent to App so far.Notify the app now");
bond_state_changed(BT_STATUS_SUCCESS, (bt_bdaddr_t*)p_data->ble_key.bd_addr,
BT_BOND_STATE_BONDING);
}
else if (memcmp (pairing_cb.bd_addr, p_data->ble_key.bd_addr, BD_ADDR_LEN)!=0)
{
BTIF_TRACE_ERROR("BD mismatch discard BLE key_type=%d ",p_data->ble_key.key_type);
break;
}

switch (p_data->ble_key.key_type)
{
case BTA_LE_KEY_PENC:
BTIF_TRACE_DEBUG("Rcv BTA_LE_KEY_PENC");
pairing_cb.ble.is_penc_key_rcvd = TRUE;
pairing_cb.ble.penc_key = p_data->ble_key.p_key_value->penc_key;
break;

case BTA_LE_KEY_PID:
BTIF_TRACE_DEBUG("Rcv BTA_LE_KEY_PID");
pairing_cb.ble.is_pid_key_rcvd = TRUE;
pairing_cb.ble.pid_key = p_data->ble_key.p_key_value->pid_key;
break;

case BTA_LE_KEY_PCSRK:
BTIF_TRACE_DEBUG("Rcv BTA_LE_KEY_PCSRK");
pairing_cb.ble.is_pcsrk_key_rcvd = TRUE;
pairing_cb.ble.pcsrk_key = p_data->ble_key.p_key_value->pcsrk_key;
break;

case BTA_LE_KEY_LENC:
BTIF_TRACE_DEBUG("Rcv BTA_LE_KEY_LENC");
pairing_cb.ble.is_lenc_key_rcvd = TRUE;
pairing_cb.ble.lenc_key = p_data->ble_key.p_key_value->lenc_key;
break;

case BTA_LE_KEY_LCSRK:
BTIF_TRACE_DEBUG("Rcv BTA_LE_KEY_LCSRK");
pairing_cb.ble.is_lcsrk_key_rcvd = TRUE;
pairing_cb.ble.lcsrk_key = p_data->ble_key.p_key_value->lcsrk_key;
break;

case BTA_LE_KEY_LID:
BTIF_TRACE_DEBUG("Rcv BTA_LE_KEY_LID");
pairing_cb.ble.is_lidk_key_rcvd =  TRUE;
break;

default:
BTIF_TRACE_ERROR("unknown BLE key type (0x%02x)", p_data->ble_key.key_type);
break;
}
break;
case BTA_DM_BLE_SEC_REQ_EVT:
BTIF_TRACE_DEBUG("BTA_DM_BLE_SEC_REQ_EVT. ");
btif_dm_ble_sec_req_evt(&p_data->ble_req);
break;
case BTA_DM_BLE_PASSKEY_NOTIF_EVT:
BTIF_TRACE_DEBUG("BTA_DM_BLE_PASSKEY_NOTIF_EVT. ");
btif_dm_ble_key_notif_evt(&p_data->key_notif);
break;
case BTA_DM_BLE_PASSKEY_REQ_EVT:
BTIF_TRACE_DEBUG("BTA_DM_BLE_PASSKEY_REQ_EVT. ");
btif_dm_ble_passkey_req_evt(&p_data->pin_req);
break;
case BTA_DM_BLE_NC_REQ_EVT:
BTIF_TRACE_DEBUG("BTA_DM_BLE_PASSKEY_REQ_EVT. ");
btif_dm_ble_key_nc_req_evt(&p_data->key_notif);
break;
case BTA_DM_BLE_OOB_REQ_EVT:
BTIF_TRACE_DEBUG("BTA_DM_BLE_OOB_REQ_EVT. ");
break;
case BTA_DM_BLE_LOCAL_IR_EVT:
BTIF_TRACE_DEBUG("BTA_DM_BLE_LOCAL_IR_EVT. ");
ble_local_key_cb.is_id_keys_rcvd = TRUE;
memcpy(&ble_local_key_cb.id_keys.irk[0],
&p_data->ble_id_keys.irk[0], sizeof(BT_OCTET16));
memcpy(&ble_local_key_cb.id_keys.ir[0],
&p_data->ble_id_keys.ir[0], sizeof(BT_OCTET16));
memcpy(&ble_local_key_cb.id_keys.dhk[0],
&p_data->ble_id_keys.dhk[0], sizeof(BT_OCTET16));
btif_storage_add_ble_local_key( (char *)&ble_local_key_cb.id_keys.irk[0],
BTIF_DM_LE_LOCAL_KEY_IRK,
BT_OCTET16_LEN);
btif_storage_add_ble_local_key( (char *)&ble_local_key_cb.id_keys.ir[0],
BTIF_DM_LE_LOCAL_KEY_IR,
BT_OCTET16_LEN);
btif_storage_add_ble_local_key( (char *)&ble_local_key_cb.id_keys.dhk[0],
BTIF_DM_LE_LOCAL_KEY_DHK,
BT_OCTET16_LEN);
break;
case BTA_DM_BLE_LOCAL_ER_EVT:
BTIF_TRACE_DEBUG("BTA_DM_BLE_LOCAL_ER_EVT. ");
ble_local_key_cb.is_er_rcvd = TRUE;
memcpy(&ble_local_key_cb.er[0], &p_data->ble_er[0], sizeof(BT_OCTET16));
btif_storage_add_ble_local_key( (char *)&ble_local_key_cb.er[0],
BTIF_DM_LE_LOCAL_KEY_ER,
BT_OCTET16_LEN);
break;

case BTA_DM_BLE_AUTH_CMPL_EVT:
BTIF_TRACE_DEBUG("BTA_DM_BLE_AUTH_CMPL_EVT. ");
btif_dm_ble_auth_cmpl_evt(&p_data->auth_cmpl);
break;

case BTA_DM_LE_FEATURES_READ:
{
tBTM_BLE_VSC_CB cmn_vsc_cb;
bt_local_le_features_t local_le_features;
char buf[512];
bt_property_t prop;
prop.type = BT_PROPERTY_LOCAL_LE_FEATURES;
prop.val = (void*)buf;
prop.len = sizeof(buf);

/* LE features are not stored in storage. Should be retrived from stack */
BTM_BleGetVendorCapabilities(&cmn_vsc_cb);
local_le_features.local_privacy_enabled = BTM_BleLocalPrivacyEnabled();

prop.len = sizeof (bt_local_le_features_t);
if (cmn_vsc_cb.filter_support == 1)
local_le_features.max_adv_filter_supported = cmn_vsc_cb.max_filter;
else
local_le_features.max_adv_filter_supported = 0;
local_le_features.max_adv_instance = cmn_vsc_cb.adv_inst_max;
local_le_features.max_irk_list_size = cmn_vsc_cb.max_irk_list_sz;
local_le_features.rpa_offload_supported = cmn_vsc_cb.rpa_offloading;
local_le_features.activity_energy_info_supported = cmn_vsc_cb.energy_support;
local_le_features.scan_result_storage_size = cmn_vsc_cb.tot_scan_results_strg;
local_le_features.version_supported = cmn_vsc_cb.version_supported;
local_le_features.total_trackable_advertisers =
cmn_vsc_cb.total_trackable_advertisers;

local_le_features.extended_scan_support = cmn_vsc_cb.extended_scan_support > 0;
local_le_features.debug_logging_supported = cmn_vsc_cb.debug_logging_supported > 0;

memcpy(prop.val, &local_le_features, prop.len);
HAL_CBACK(bt_hal_cbacks, adapter_properties_cb, BT_STATUS_SUCCESS, 1, &prop);
break;
}

case BTA_DM_ENER_INFO_READ:
{
btif_activity_energy_info_cb_t *p_ener_data = (btif_activity_energy_info_cb_t*) p_param;
bt_activity_energy_info energy_info;
energy_info.status = p_ener_data->status;
energy_info.ctrl_state = p_ener_data->ctrl_state;
energy_info.rx_time = p_ener_data->rx_time;
energy_info.tx_time = p_ener_data->tx_time;
energy_info.idle_time = p_ener_data->idle_time;
energy_info.energy_used = p_ener_data->energy_used;
HAL_CBACK(bt_hal_cbacks, energy_info_cb, &energy_info);
break;
}
#endif

case BTA_DM_AUTHORIZE_EVT:
case BTA_DM_SIG_STRENGTH_EVT:
case BTA_DM_SP_RMT_OOB_EVT:
case BTA_DM_SP_KEYPRESS_EVT:
case BTA_DM_ROLE_CHG_EVT:

default:
BTIF_TRACE_WARNING( "btif_dm_cback : unhandled event (%d)", event );
break;
}

btif_dm_data_free(event, p_data);
}

BOOLEAN UIPC_SendBuf(tUIPC_CH_ID ch_id, BT_HDR *p_msg)
{
    UNUSED(p_msg);

    BTIF_TRACE_DEBUG("UIPC_SendBuf : ch_id %d NOT IMPLEMENTED", ch_id);

    UIPC_LOCK();

 /* currently not used */

    UIPC_UNLOCK();

 return FALSE;
}

static bool write_hci_command(hci_packet_t type, const void *packet, size_t length) {
int sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (sock == INVALID_FD)
goto error;

struct sockaddr_in addr;

addr.sin_family = AF_INET;
addr.sin_addr.s_addr = htonl(0x7F000001);
addr.sin_port = htons(8873);
  if (connect(sock, (const struct sockaddr *)&addr, sizeof(addr)) == -1)
goto error;

  if (send(sock, &type, 1, 0) != 1)
goto error;

  if (send(sock, &length, 2, 0) != 2)
goto error;

  if (send(sock, packet, length, 0) != (ssize_t)length)
goto error;

close(sock);
return true;

error:;
close(sock);
return false;
}

ssize_t socket_write(const socket_t *socket, const void *buf, size_t count) {
assert(socket != NULL);
assert(buf != NULL);

  return send(socket->fd, buf, count, MSG_DONTWAIT);
}

static void btif_in_pan_generic_evt(UINT16 event, char *p_param)
{
    BTIF_TRACE_EVENT("%s: event=%d", __FUNCTION__, event);
 switch (event) {
 case BTIF_PAN_CB_DISCONNECTING:
 {
 bt_bdaddr_t *bd_addr = (bt_bdaddr_t*)p_param;
 btpan_conn_t* conn = btpan_find_conn_addr(bd_addr->address);
 int btpan_conn_local_role;
 int btpan_remote_role;
            asrt(conn != NULL);
 if (conn) {
                btpan_conn_local_role = bta_role_to_btpan(conn->local_role);
                btpan_remote_role = bta_role_to_btpan(conn->remote_role);
                callback.connection_state_cb(BTPAN_STATE_DISCONNECTING, BT_STATUS_SUCCESS,
 (const bt_bdaddr_t*)conn->peer, btpan_conn_local_role, btpan_remote_role);
 }
 } break;
 default:
 {
            BTIF_TRACE_WARNING("%s : Unknown event 0x%x", __FUNCTION__, event);
 }
 break;
 }
}

static void transmit_fragment(BT_HDR *packet, bool send_transmit_finished) {
 uint16_t event = packet->event & MSG_EVT_MASK;
 serial_data_type_t type = event_to_data_type(event);

  btsnoop->capture(packet, false);
  hal->transmit_data(type, packet->data + packet->offset, packet->len);

 if (event != MSG_STACK_TO_HC_HCI_CMD && send_transmit_finished)
    buffer_allocator->free(packet);
}

BOOLEAN btif_hl_is_reconnect_possible(UINT8 app_idx, UINT8 mcl_idx, int mdep_cfg_idx,
                                      tBTA_HL_DCH_OPEN_PARAM *p_dch_open_api, tBTA_HL_MDL_ID *p_mdl_id)
{
 btif_hl_app_cb_t *p_acb = BTIF_HL_GET_APP_CB_PTR(app_idx);
 btif_hl_mcl_cb_t *p_mcb = BTIF_HL_GET_MCL_CB_PTR(app_idx, mcl_idx);
    tBTA_HL_DCH_CFG      local_cfg = p_dch_open_api->local_cfg;
    tBTA_HL_DCH_MODE     dch_mode = BTA_HL_DCH_MODE_RELIABLE;
    BOOLEAN              use_mdl_dch_mode=FALSE;
 btif_hl_mdl_cfg_t *p_mdl;
 btif_hl_mdl_cfg_t *p_mdl1;
    UINT8                i, j;
    BOOLEAN              is_reconnect_ok=FALSE;
    BOOLEAN              stream_mode_avail=FALSE;
    UINT16               data_type = p_acb->sup_feature.mdep[mdep_cfg_idx].mdep_cfg.data_cfg[0].data_type;
    tBTA_HL_MDEP_ID      peer_mdep_id = p_dch_open_api->peer_mdep_id;
    UINT8                mdl_idx;


    BTIF_TRACE_DEBUG("%s app_idx=%d mcl_idx=%d mdep_cfg_idx=%d",
                      __FUNCTION__, app_idx, mcl_idx, mdep_cfg_idx  );
 switch (local_cfg)
 {
 case BTA_HL_DCH_CFG_NO_PREF:
 if (!btif_hl_is_the_first_reliable_existed(app_idx, mcl_idx))
 {
                dch_mode = BTA_HL_DCH_MODE_RELIABLE;
 }
 else
 {
                use_mdl_dch_mode = TRUE;
 }
 break;
 case BTA_HL_DCH_CFG_RELIABLE:
            dch_mode = BTA_HL_DCH_MODE_RELIABLE;
 break;
 case BTA_HL_DCH_CFG_STREAMING:
            dch_mode = BTA_HL_DCH_MODE_STREAMING;
 break;
 default:
            BTIF_TRACE_ERROR("Invalid local_cfg=%d",local_cfg );
 return is_reconnect_ok;
 break;

 }

    BTIF_TRACE_DEBUG("local_cfg=%d use_mdl_dch_mode=%d dch_mode=%d ",
                      local_cfg, use_mdl_dch_mode, dch_mode  );

 for (i=0, p_mdl=&p_acb->mdl_cfg[0] ; i< BTA_HL_NUM_MDL_CFGS; i++, p_mdl++ )
 {
 if (p_mdl->base.active &&
            p_mdl->extra.data_type ==data_type &&
 (p_mdl->extra.peer_mdep_id != BTA_HL_INVALID_MDEP_ID && p_mdl->extra.peer_mdep_id == peer_mdep_id) &&
            memcpy(p_mdl->base.peer_bd_addr, p_mcb->bd_addr,sizeof(BD_ADDR) ) &&
            p_mdl->base.mdl_id &&
 !btif_hl_find_mdl_idx(app_idx, mcl_idx,p_mdl->base.mdl_id, &mdl_idx))
 {
            BTIF_TRACE_DEBUG("i=%d Matched active=%d   mdl_id =%d, mdl_dch_mode=%d",
                              i, p_mdl->base.active, p_mdl->base.mdl_id,p_mdl->base.dch_mode);
 if (!use_mdl_dch_mode)
 {
 if (p_mdl->base.dch_mode == dch_mode)
 {
                    is_reconnect_ok = TRUE;
 *p_mdl_id = p_mdl->base.mdl_id;
                    BTIF_TRACE_DEBUG("reconnect is possible dch_mode=%d mdl_id=%d", dch_mode, p_mdl->base.mdl_id );
 break;
 }
 }
 else
 {
                is_reconnect_ok = TRUE;
 for (j=i, p_mdl1=&p_acb->mdl_cfg[i]; j< BTA_HL_NUM_MDL_CFGS; j++, p_mdl1++)
 {
 if (p_mdl1->base.active &&
                        p_mdl1->extra.data_type == data_type &&
 (p_mdl1->extra.peer_mdep_id != BTA_HL_INVALID_MDEP_ID && p_mdl1->extra.peer_mdep_id == peer_mdep_id) &&
                        memcpy(p_mdl1->base.peer_bd_addr, p_mcb->bd_addr,sizeof(BD_ADDR)) &&
                        p_mdl1->base.dch_mode == BTA_HL_DCH_MODE_STREAMING)
 {
                        stream_mode_avail = TRUE;
                        BTIF_TRACE_DEBUG("found streaming mode mdl index=%d", j);
 break;
 }
 }

 if (stream_mode_avail)
 {
                    dch_mode = BTA_HL_DCH_MODE_STREAMING;
 *p_mdl_id = p_mdl1->base.mdl_id;
                    BTIF_TRACE_DEBUG("reconnect is ok index=%d dch_mode=streaming  mdl_id=%d", j, *p_mdl_id);
 break;
 }
 else
 {
                    dch_mode= p_mdl->base.dch_mode;
 *p_mdl_id = p_mdl->base.mdl_id;
                    BTIF_TRACE_DEBUG("reconnect is ok index=%d  dch_mode=%d mdl_id=%d", i,  p_mdl->base.dch_mode, *p_mdl_id);
 break;

 }
 }

 }

 }

    BTIF_TRACE_DEBUG("is_reconnect_ok  dch_mode=%d mdl_id=%d",is_reconnect_ok, dch_mode, *p_mdl_id);
 return is_reconnect_ok;
}

BOOLEAN bta_hl_co_get_num_of_mdep(UINT8 app_id, UINT8 *p_num_of_mdep)
{
    UINT8 app_idx;
    BOOLEAN success = FALSE;

 if (btif_hl_find_app_idx(app_id, &app_idx))
 {
 *p_num_of_mdep = p_btif_hl_cb->acb[app_idx].sup_feature.num_of_mdeps;
        success = TRUE;
 }


    BTIF_TRACE_DEBUG("%s success=%d num_mdeps=%d",
                      __FUNCTION__, success, *p_num_of_mdep );
 return success;
}

static bool hal_open() {
  LOG_INFO("%s", __func__);

 int fd_array[CH_MAX];
 int number_of_ports = vendor->send_command(VENDOR_OPEN_USERIAL, &fd_array);

 if (number_of_ports != 1) {
    LOG_ERROR("%s opened the wrong number of ports: got %d, expected 1.", __func__, number_of_ports);
 goto error;
 }

  uart_fd = fd_array[0];
 if (uart_fd == INVALID_FD) {
    LOG_ERROR("%s unable to open the uart serial port.", __func__);
 goto error;
 }

  uart_stream = eager_reader_new(uart_fd, &allocator_malloc, HCI_HAL_SERIAL_BUFFER_SIZE, SIZE_MAX, "hci_single_channel");
 if (!uart_stream) {
    LOG_ERROR("%s unable to create eager reader for the uart serial port.", __func__);
 goto error;
 }

  stream_has_interpretation = false;
  stream_corruption_detected = false;
  stream_corruption_bytes_to_ignore = 0;
  eager_reader_register(uart_stream, thread_get_reactor(thread), event_uart_has_bytes, NULL);

  thread_set_priority(thread, HCI_THREAD_PRIORITY);
  thread_set_priority(eager_reader_get_read_thread(uart_stream), HCI_THREAD_PRIORITY);

 return true;

error:
  interface.close();
 return false;
}

static void btif_context_switched(void *p_msg)
{

    BTIF_TRACE_VERBOSE("btif_context_switched");

    tBTIF_CONTEXT_SWITCH_CBACK *p = (tBTIF_CONTEXT_SWITCH_CBACK *) p_msg;

 /* each callback knows how to parse the data */
 if (p->p_cb)
        p->p_cb(p->event, p->p_param);
}

void bta_hh_le_co_reset_rpt_cache (BD_ADDR remote_bda, UINT8 app_id)
{
    UNUSED(app_id);

 bdstr_t bdstr;
    sprintf(bdstr, "%02x:%02x:%02x:%02x:%02x:%02x",
        remote_bda[0], remote_bda[1], remote_bda[2],
        remote_bda[3], remote_bda[4], remote_bda[5]);
    btif_config_remove(bdstr, "HidReport");

    BTIF_TRACE_DEBUG("%s() - Reset cache for bda %s", __FUNCTION__, bdstr);
}

UINT16  btif_hl_get_max_rx_apdu_size(tBTA_HL_MDEP_ROLE mdep_role,
                                     UINT16 data_type ){
    UINT8  idx;
    UINT16 max_rx_apdu_size =0;

 if (btif_hl_find_data_type_idx(data_type, &idx))
 {
 if (mdep_role == BTA_HL_MDEP_ROLE_SOURCE)
 {
            max_rx_apdu_size = data_type_table[idx].max_rx_apdu_size;
 }
 else
 {
            max_rx_apdu_size = data_type_table[idx].max_tx_apdu_size;
 }
 }
 else
 {
 if (mdep_role == BTA_HL_MDEP_ROLE_SOURCE)
 {
            max_rx_apdu_size = BTIF_HL_DEFAULT_SRC_RX_APDU_SIZE;
 }
 else
 {
            max_rx_apdu_size = BTIF_HL_DEFAULT_SRC_TX_APDU_SIZE;
 }
 }


    BTIF_TRACE_DEBUG("%s mdep_role=%d data_type=0x%4x size=%d",
                      __FUNCTION__, mdep_role, data_type, max_rx_apdu_size);

 return max_rx_apdu_size;
}

void btif_dm_remove_ble_bonding_keys(void)
{
 bt_bdaddr_t bd_addr;

    BTIF_TRACE_DEBUG("%s",__FUNCTION__ );

    bdcpy(bd_addr.address, pairing_cb.bd_addr);
    btif_storage_remove_ble_bonding_keys(&bd_addr);
}

static bt_status_t set_volume(uint8_t volume)
{
    BTIF_TRACE_DEBUG("%s", __FUNCTION__);
    CHECK_RC_CONNECTED
    tAVRC_STS status = BT_STATUS_UNSUPPORTED;
 rc_transaction_t *p_transaction=NULL;

 if(btif_rc_cb.rc_volume==volume)
 {
        status=BT_STATUS_DONE;
        BTIF_TRACE_ERROR("%s: volume value already set earlier: 0x%02x",__FUNCTION__, volume);
 return status;
 }

 if ((btif_rc_cb.rc_features & BTA_AV_FEAT_RCTG) &&
 (btif_rc_cb.rc_features & BTA_AV_FEAT_ADV_CTRL))
 {
        tAVRC_COMMAND avrc_cmd = {0};
        BT_HDR *p_msg = NULL;

        BTIF_TRACE_DEBUG("%s: Peer supports absolute volume. newVolume=%d", __FUNCTION__, volume);
        avrc_cmd.volume.opcode = AVRC_OP_VENDOR;
        avrc_cmd.volume.pdu = AVRC_PDU_SET_ABSOLUTE_VOLUME;
        avrc_cmd.volume.status = AVRC_STS_NO_ERROR;
        avrc_cmd.volume.volume = volume;

 if (AVRC_BldCommand(&avrc_cmd, &p_msg) == AVRC_STS_NO_ERROR)
 {
 bt_status_t tran_status=get_transaction(&p_transaction);
 if(BT_STATUS_SUCCESS == tran_status && NULL!=p_transaction)
 {
                BTIF_TRACE_DEBUG("%s msgreq being sent out with label %d",
                                   __FUNCTION__,p_transaction->lbl);
                BTA_AvMetaCmd(btif_rc_cb.rc_handle,p_transaction->lbl, AVRC_CMD_CTRL, p_msg);
                status =  BT_STATUS_SUCCESS;
 }
 else
 {
 if(NULL!=p_msg)
                   GKI_freebuf(p_msg);
                BTIF_TRACE_ERROR("%s: failed to obtain transaction details. status: 0x%02x",
                                    __FUNCTION__, tran_status);
                status = BT_STATUS_FAIL;
 }
 }
 else
 {
            BTIF_TRACE_ERROR("%s: failed to build absolute volume command. status: 0x%02x",
                                __FUNCTION__, status);
            status = BT_STATUS_FAIL;
 }
 }
 else
        status=BT_STATUS_NOT_READY;
 return status;
}

void bte_dm_evt(tBTA_DM_SEC_EVT event, tBTA_DM_SEC *p_data)
{
 /* switch context to btif task context (copy full union size for convenience) */
 bt_status_t status = btif_transfer_context(btif_dm_upstreams_evt, (uint16_t)event,
 (void*)p_data, sizeof(tBTA_DM_SEC), btif_dm_data_copy);

 /* catch any failed context transfers */
    ASSERTC(status == BT_STATUS_SUCCESS, "context transfer failed", status);
}

static int adev_get_mic_mute(const struct audio_hw_device *dev, bool *state)
{
    UNUSED(dev);
    UNUSED(state);

    FNLOG();

 return -ENOSYS;
}

 void send_key (int fd, uint16_t key, int pressed)
{
    BTIF_TRACE_DEBUG("%s fd:%d key:%u pressed:%d", __FUNCTION__,
        fd, key, pressed);

 if (fd < 0)
 {
 return;
 }

    BTIF_TRACE_DEBUG("AVRCP: Send key %d (%d) fd=%d", key, pressed, fd);
    send_event(fd, EV_KEY, key, pressed);
    send_event(fd, EV_SYN, SYN_REPORT, 0);
}

static void init_layer_interface() {
 if (!interface_created) {
    interface.send_low_power_command = low_power_manager->post_command;
    interface.do_postload = do_postload;

    interface.event_dispatcher = data_dispatcher_new("hci_layer");
 if (!interface.event_dispatcher) {
      LOG_ERROR("%s could not create upward dispatcher.", __func__);
 return;
 }

    interface.set_data_queue = set_data_queue;
    interface.transmit_command = transmit_command;
    interface.transmit_command_futured = transmit_command_futured;
    interface.transmit_downward = transmit_downward;
    interface_created = true;
 }
}

void btif_hl_close_socket( fd_set *p_org_set){
    BTIF_TRACE_DEBUG("entering %s",__FUNCTION__);
 for (const list_node_t *node = list_begin(soc_queue);
            node != list_end(soc_queue); node = list_next(node)) {
 btif_hl_soc_cb_t *p_scb = list_node(node);
 if (btif_hl_get_socket_state(p_scb) == BTIF_HL_SOC_STATE_W4_REL) {
            BTIF_TRACE_DEBUG("app_idx=%d mcl_id=%d, mdl_idx=%d",
                    p_scb->app_idx, p_scb->mcl_idx, p_scb->mdl_idx);
            btif_hl_set_socket_state(p_scb, BTIF_HL_SOC_STATE_IDLE);
 if (p_scb->socket_id[1] != -1) {
                FD_CLR(p_scb->socket_id[1] , p_org_set);
                shutdown(p_scb->socket_id[1], SHUT_RDWR);
                close(p_scb->socket_id[1]);

 btif_hl_evt_cb_t evt_param;
                evt_param.chan_cb.app_id = (int) btif_hl_get_app_id(p_scb->channel_id);
                memcpy(evt_param.chan_cb.bd_addr, p_scb->bd_addr, sizeof(BD_ADDR));
                evt_param.chan_cb.channel_id = p_scb->channel_id;
                evt_param.chan_cb.fd = p_scb->socket_id[0];
                evt_param.chan_cb.mdep_cfg_index = (int ) p_scb->mdep_cfg_idx;
                evt_param.chan_cb.cb_state = BTIF_HL_CHAN_CB_STATE_DISCONNECTED_PENDING;
 int len = sizeof(btif_hl_send_chan_state_cb_t);
 bt_status_t status = btif_transfer_context (btif_hl_proc_cb_evt,
                        BTIF_HL_SEND_DISCONNECTED_CB,
 (char*) &evt_param, len, NULL);
                ASSERTC(status == BT_STATUS_SUCCESS, "context transfer failed", status);
 }
 }
 }

 for (const list_node_t *node = list_begin(soc_queue);
        node != list_end(soc_queue); ) {
 btif_hl_soc_cb_t *p_scb = list_node(node);
        node = list_next(node);
 if (btif_hl_get_socket_state(p_scb) == BTIF_HL_SOC_STATE_IDLE) {
 btif_hl_mdl_cb_t *p_dcb = BTIF_HL_GET_MDL_CB_PTR(p_scb->app_idx,
                    p_scb->mcl_idx, p_scb->mdl_idx);
            BTIF_TRACE_DEBUG("idle socket app_idx=%d mcl_id=%d, mdl_idx=%d p_dcb->in_use=%d",
                    p_scb->app_idx, p_scb->mcl_idx, p_scb->mdl_idx, p_dcb->in_use);
            list_remove(soc_queue, p_scb);
            btif_hl_free_buf((void **)&p_scb);
            p_dcb->p_scb = NULL;
 }
        BTIF_TRACE_DEBUG("p_scb=0x%x", p_scb);
 }
    BTIF_TRACE_DEBUG("leaving %s",__FUNCTION__);
}

static void btif_hl_proc_abort_cfm(tBTA_HL_MCL_HANDLE mcl_handle){
    BTIF_TRACE_DEBUG("%s", __FUNCTION__ );
 btif_hl_app_cb_t *p_acb;
    UINT8 i,j;

 for (i=0; i<BTA_HL_NUM_APPS; i++)
 {
        p_acb =BTIF_HL_GET_APP_CB_PTR(i);
 for (j=0; j < BTA_HL_NUM_MCLS ; j++)
 {
 if (p_acb->mcb[j].in_use)
                BTIF_TRACE_DEBUG("btif_hl_find_mcl_idx_using_handle: app_idx=%d,mcl_idx =%d mcl_handle=%d",i,j,p_acb->mcb[j].mcl_handle);
 if (p_acb->mcb[j].in_use &&
 (p_acb->mcb[j].mcl_handle == mcl_handle))
 {
                btif_hl_stop_cch_timer(i, j);
                btif_hl_send_setup_disconnected_cb(i, j);
                btif_hl_clean_mcl_cb(i, j);
 }
 }
 }

}

void btif_dm_hh_open_failed(bt_bdaddr_t *bdaddr)
{
 if (pairing_cb.state == BT_BOND_STATE_BONDING &&
            bdcmp(bdaddr->address, pairing_cb.bd_addr) == 0)
 {
        bond_state_changed(BT_STATUS_FAIL, bdaddr, BT_BOND_STATE_NONE);
 }
}

static int set_discoverable(int argc, char **argv) {
 if (argc != 1) {
    printf("Discoverable mode not specified.\n");
 return 1;
 }

 if (strcmp(argv[0], "true") && strcmp(argv[0], "false")) {
    printf("Invalid discoverable mode '%s'.\n", argv[0]);
 return 2;
 }

 uint8_t packet[] = { 0x1A, 0x0C, 0x01, 0x00 };
 if (argv[0][0] == 't')
    packet[ARRAY_SIZE(packet) - 1] = 0x03;

 return !write_hci_command(HCI_PACKET_COMMAND, packet, ARRAY_SIZE(packet));
}

static void search_services_copy_cb(UINT16 event, char *p_dest, char *p_src)
{
    tBTA_DM_SEARCH *p_dest_data = (tBTA_DM_SEARCH *) p_dest;
    tBTA_DM_SEARCH *p_src_data = (tBTA_DM_SEARCH *) p_src;

 if (!p_src)
 return;
    memcpy(p_dest_data, p_src_data, sizeof(tBTA_DM_SEARCH));
 switch (event)
 {
 case BTA_DM_DISC_RES_EVT:
 {
 if (p_src_data->disc_res.result == BTA_SUCCESS)
 {
 if (p_src_data->disc_res.num_uuids > 0)
 {
                       p_dest_data->disc_res.p_uuid_list =
 (UINT8*)(p_dest + sizeof(tBTA_DM_SEARCH));
                       memcpy(p_dest_data->disc_res.p_uuid_list, p_src_data->disc_res.p_uuid_list,
                              p_src_data->disc_res.num_uuids*MAX_UUID_SIZE);
                       GKI_freebuf(p_src_data->disc_res.p_uuid_list);
 }
 if (p_src_data->disc_res.p_raw_data != NULL)
 {
                      GKI_freebuf(p_src_data->disc_res.p_raw_data);
 }
 }
 } break;
 }
}

const hci_hal_t *hci_hal_mct_get_interface() {
  vendor = vendor_get_interface();
 return &interface;
}

static int stop_audio_datapath(struct a2dp_stream_common *common)
{
 int oldstate = common->state;

    INFO("state %d", common->state);

 if (common->ctrl_fd == AUDIO_SKT_DISCONNECTED)
 return -1;

 /* prevent any stray output writes from autostarting the stream
       while stopping audiopath */
    common->state = AUDIO_A2DP_STATE_STOPPING;

 if (a2dp_command(common, A2DP_CTRL_CMD_STOP) < 0)
 {
        ERROR("audiopath stop failed");
        common->state = oldstate;
 return -1;
 }

    common->state = AUDIO_A2DP_STATE_STOPPED;

 /* disconnect audio path */
    skt_disconnect(common->audio_fd);
    common->audio_fd = AUDIO_SKT_DISCONNECTED;

 return 0;
}

static int uipc_close_ch_locked(tUIPC_CH_ID ch_id)
{
 int wakeup = 0;

    BTIF_TRACE_EVENT("CLOSE CHANNEL %d", ch_id);

 if (ch_id >= UIPC_CH_NUM)
 return -1;

 if (uipc_main.ch[ch_id].srvfd != UIPC_DISCONNECTED)
 {
        BTIF_TRACE_EVENT("CLOSE SERVER (FD %d)", uipc_main.ch[ch_id].srvfd);
        close(uipc_main.ch[ch_id].srvfd);
        FD_CLR(uipc_main.ch[ch_id].srvfd, &uipc_main.active_set);
        uipc_main.ch[ch_id].srvfd = UIPC_DISCONNECTED;
        wakeup = 1;
 }

 if (uipc_main.ch[ch_id].fd != UIPC_DISCONNECTED)
 {
        BTIF_TRACE_EVENT("CLOSE CONNECTION (FD %d)", uipc_main.ch[ch_id].fd);
        close(uipc_main.ch[ch_id].fd);
        FD_CLR(uipc_main.ch[ch_id].fd, &uipc_main.active_set);
        uipc_main.ch[ch_id].fd = UIPC_DISCONNECTED;
        wakeup = 1;
 }

 /* notify this connection is closed */
 if (uipc_main.ch[ch_id].cback)
        uipc_main.ch[ch_id].cback(ch_id, UIPC_CLOSE_EVT);

 /* trigger main thread update if something was updated */
 if (wakeup)
        uipc_wakeup_locked();

 return 0;
}

static int btif_hl_get_next_channel_id(UINT8 app_id){
    UINT16 next_channel_id = btif_hl_cb.next_channel_id;
 int channel_id;
    btif_hl_cb.next_channel_id++;
    channel_id = (app_id << 16) + next_channel_id;
    BTIF_TRACE_DEBUG("%s channel_id=0x%08x, app_id=0x%02x next_channel_id=0x%04x", __FUNCTION__,
                      channel_id, app_id,  next_channel_id);
 return channel_id;
}

static void on_srv_rfc_listen_started(tBTA_JV_RFCOMM_START *p_start, uint32_t id) {
  pthread_mutex_lock(&slot_lock);

 rfc_slot_t *slot = find_rfc_slot_by_id(id);
 if (!slot)
 goto out;

 if (p_start->status == BTA_JV_SUCCESS) {
    slot->rfc_handle = p_start->handle;
 } else
    cleanup_rfc_slot(slot);

out:;
  pthread_mutex_unlock(&slot_lock);
}

static void fragmenter_transmit_finished(BT_HDR *packet, bool all_fragments_sent) {
 if (all_fragments_sent) {
    buffer_allocator->free(packet);
 } else {
    data_dispatcher_dispatch(interface.event_dispatcher, packet->event & MSG_EVT_MASK, packet);
 }
}

static void on_srv_l2cap_listen_started(tBTA_JV_L2CAP_START *p_start, uint32_t id)
{
    l2cap_socket *sock;

    pthread_mutex_lock(&state_lock);
    sock = btsock_l2cap_find_by_id_l(id);
 if (sock) {
 if (p_start->status != BTA_JV_SUCCESS) {
            APPL_TRACE_ERROR("Error starting l2cap_listen - status: 0x%04x", p_start->status);
            btsock_l2cap_free_l(sock);
 }
 else {
            sock->handle = p_start->handle;
            APPL_TRACE_DEBUG("on_srv_l2cap_listen_started() sock->handle =%d id:%d",
                    sock->handle, sock->id);
 if(sock->server_psm_sent == FALSE) {
 if (!send_app_psm_or_chan_l(sock)) {
                    APPL_TRACE_DEBUG("send_app_psm() failed, close rs->id:%d", sock->id);
                    btsock_l2cap_free_l(sock);
 } else {
                    sock->server_psm_sent = TRUE;
 }
 }
 }
 }
    pthread_mutex_unlock(&state_lock);
}

static inline int btif_hl_select_wake_reset(void){

char sig_recv = 0;

BTIF_TRACE_DEBUG("btif_hl_select_wake_reset");
    recv(signal_fds[0], &sig_recv, sizeof(sig_recv), MSG_WAITALL);
return(int)sig_recv;
}

void eager_reader_unregister(eager_reader_t *reader) {
  assert(reader != NULL);

 if (reader->outbound_registration) {
    reactor_unregister(reader->outbound_registration);
    reader->outbound_registration = NULL;
 }
}

static void btif_dm_remote_service_record_evt(UINT16 event, char *p_param)
{
    tBTA_DM_SEARCH *p_data = (tBTA_DM_SEARCH*)p_param;

    BTIF_TRACE_EVENT("%s:  event = %d", __FUNCTION__, event);
 switch (event)
 {
 case BTA_DM_DISC_RES_EVT:
 {
 bt_service_record_t rec;
 bt_property_t prop;
 bt_bdaddr_t bd_addr;

            memset(&rec, 0, sizeof(bt_service_record_t));
            bdcpy(bd_addr.address, p_data->disc_res.bd_addr);

            BTIF_TRACE_DEBUG("%s:(result=0x%x, services 0x%x)", __FUNCTION__,
                    p_data->disc_res.result, p_data->disc_res.services);
            prop.type = BT_PROPERTY_SERVICE_RECORD;
            prop.val = (void*)&rec;
            prop.len = sizeof(rec);

 /* disc_res.result is overloaded with SCN. Cannot check result */
            p_data->disc_res.services &= ~BTA_USER_SERVICE_MASK;
 /* TODO: Get the UUID as well */
            rec.channel = p_data->disc_res.result - 3;
 /* TODO: Need to get the service name using p_raw_data */
            rec.name[0] = 0;

            HAL_CBACK(bt_hal_cbacks, remote_device_properties_cb,
                             BT_STATUS_SUCCESS, &bd_addr, 1, &prop);
 }
 break;

 default:
 {
           ASSERTC(0, "unhandled remote service record event", event);
 }
 break;
 }
}

static int tap_if_up(const char *devname, const bt_bdaddr_t *addr)
{
struct ifreq ifr;
int sk, err;

sk = socket(AF_INET, SOCK_DGRAM, 0);
if (sk < 0)
return -1;


//set mac addr
memset(&ifr, 0, sizeof(ifr));
strncpy(ifr.ifr_name, devname, IFNAMSIZ - 1);
    err = ioctl(sk, SIOCGIFHWADDR, &ifr);
if (err < 0)
{
BTIF_TRACE_ERROR("Could not get network hardware for interface:%s, errno:%s", devname, strerror(errno));
close(sk);
return -1;
}

strncpy(ifr.ifr_name, devname, IFNAMSIZ - 1);
memcpy(ifr.ifr_hwaddr.sa_data, addr->address, 6);

/* The IEEE has specified that the most significant bit of the most significant byte is used to
* determine a multicast address. If its a 1, that means multicast, 0 means unicast.
* Kernel returns an error if we try to set a multicast address for the tun-tap ethernet interface.
* Mask this bit to avoid any issue with auto generated address.
*/
if (ifr.ifr_hwaddr.sa_data[0] & 0x01) {
BTIF_TRACE_WARNING("Not a unicast MAC address, force multicast bit flipping");

ifr.ifr_hwaddr.sa_data[0] &= ~0x01;
}

    err = ioctl(sk, SIOCSIFHWADDR, (caddr_t)&ifr);

if (err < 0) {
BTIF_TRACE_ERROR("Could not set bt address for interface:%s, errno:%s", devname, strerror(errno));
close(sk);
return -1;
}

//bring it up
memset(&ifr, 0, sizeof(ifr));
strncpy(ifr.ifr_name, devname, IF_NAMESIZE - 1);


ifr.ifr_flags |= IFF_UP;
ifr.ifr_flags |= IFF_MULTICAST;

    err = ioctl(sk, SIOCSIFFLAGS, (caddr_t) &ifr);


if (err < 0) {
BTIF_TRACE_ERROR("Could not bring up network interface:%s, errno:%d", devname, errno);
close(sk);
return -1;
}
close(sk);
BTIF_TRACE_DEBUG("network interface: %s is up", devname);
return 0;
}

bt_status_t btif_le_test_mode(uint16_t opcode, uint8_t *buf, uint8_t len)
{
 switch (opcode) {
 case HCI_BLE_TRANSMITTER_TEST:
 if (len != 3) return BT_STATUS_PARM_INVALID;
             BTM_BleTransmitterTest(buf[0],buf[1],buf[2], btif_dm_ble_tx_test_cback);
 break;
 case HCI_BLE_RECEIVER_TEST:
 if (len != 1) return BT_STATUS_PARM_INVALID;
             BTM_BleReceiverTest(buf[0], btif_dm_ble_rx_test_cback);
 break;
 case HCI_BLE_TEST_END:
             BTM_BleTestEnd((tBTM_CMPL_CB*) btif_dm_ble_test_end_cback);
 break;
 default:
             BTIF_TRACE_ERROR("%s: Unknown LE Test Mode Command 0x%x", __FUNCTION__, opcode);
 return BT_STATUS_UNSUPPORTED;
 }
 return BT_STATUS_SUCCESS;
}

void btif_pan_init()
{
    BTIF_TRACE_DEBUG("jni_initialized = %d, btpan_cb.enabled:%d", jni_initialized, btpan_cb.enabled);
    stack_initialized = true;

 if (jni_initialized && !btpan_cb.enabled)
 {
        BTIF_TRACE_DEBUG("Enabling PAN....");
        memset(&btpan_cb, 0, sizeof(btpan_cb));
        btpan_cb.tap_fd = INVALID_FD;
        btpan_cb.flow = 1;
 for (int i = 0; i < MAX_PAN_CONNS; i++)
            btpan_cleanup_conn(&btpan_cb.conns[i]);
        BTA_PanEnable(bta_pan_callback);
        btpan_cb.enabled = 1;
        btpan_enable(BTPAN_LOCAL_ROLE);
 }
}

void socket_unregister(socket_t *socket) {
  assert(socket != NULL);

 if (socket->reactor_object)
    reactor_unregister(socket->reactor_object);
  socket->reactor_object = NULL;
}

int sock_send_all(int sock_fd, const uint8_t* buf, int len)
{
int s = len;

int ret;
while(s)
{
        do ret = send(sock_fd, buf, s, 0);
while(ret < 0 && errno == EINTR);
if(ret <= 0)
{
BTIF_TRACE_ERROR("sock fd:%d send errno:%d, ret:%d", sock_fd, errno, ret);
return -1;
}
buf += ret;
s -= ret;
}
return len;
}

static void btif_pan_close_all_conns() {
 if (!stack_initialized)
 return;

 for (int i = 0; i < MAX_PAN_CONNS; ++i)
 {
 if (btpan_cb.conns[i].handle != -1)
            BTA_PanClose(btpan_cb.conns[i].handle);
 }
}

static int adev_close(hw_device_t *device)
{
    FNLOG();

    free(device);
 return 0;
}

static void cleanup()
{
    BTIF_TRACE_EVENT("## %s ##", __FUNCTION__);
    close_uinput();
 if (bt_rc_callbacks)
 {
        bt_rc_callbacks = NULL;
 }
    memset(&btif_rc_cb, 0, sizeof(btif_rc_cb_t));
    lbl_destroy();
    BTIF_TRACE_EVENT("## %s ## completed", __FUNCTION__);
}

static void btif_hl_clean_mdl_cb(btif_hl_mdl_cb_t *p_dcb)
{
    BTIF_TRACE_DEBUG("%s", __FUNCTION__ );
    btif_hl_free_buf((void **) &p_dcb->p_rx_pkt);
    btif_hl_free_buf((void **) &p_dcb->p_tx_pkt);
    memset(p_dcb, 0 , sizeof(btif_hl_mdl_cb_t));
}

static BOOLEAN btif_hl_is_no_active_app(void){
    BOOLEAN no_active_app = TRUE;
    UINT8 i;

 for (i=0; i < BTA_HL_NUM_APPS ; i ++)
 {
 if (btif_hl_cb.acb[i].in_use)
 {
            no_active_app = FALSE;
 break;
 }
 }

    BTIF_TRACE_DEBUG("%s no_active_app=%d  ", __FUNCTION__, no_active_app );
 return no_active_app;
}

static bt_status_t connect( bt_bdaddr_t *bd_addr)
{
 if(btif_hh_cb.status != BTIF_HH_DEV_CONNECTING)
 {
        btif_transfer_context(btif_hh_handle_evt, BTIF_HH_CONNECT_REQ_EVT,
 (char*)bd_addr, sizeof(bt_bdaddr_t), NULL);
 return BT_STATUS_SUCCESS;
 }
 else
 return BT_STATUS_BUSY;
}

static void on_srv_l2cap_psm_connect_l(tBTA_JV_L2CAP_OPEN *p_open, l2cap_socket *sock)
{
    l2cap_socket *accept_rs;
 uint32_t new_listen_id;

    accept_rs = btsock_l2cap_alloc_l(sock->name, (const bt_bdaddr_t*)p_open->rem_bda, FALSE, 0);
    accept_rs->connected = TRUE;
    accept_rs->security = sock->security;
    accept_rs->fixed_chan = sock->fixed_chan;
    accept_rs->channel = sock->channel;
    accept_rs->handle = sock->handle;
    sock->handle = -1; /* We should no longer associate this handle with the server socket */

 /* Swap IDs to hand over the GAP connection to the accepted socket, and start a new server on
       the newly create socket ID. */
    new_listen_id = accept_rs->id;
    accept_rs->id = sock->id;
    sock->id = new_listen_id;

 if (accept_rs) {
        btsock_thread_add_fd(pth, sock->our_fd, BTSOCK_L2CAP, SOCK_THREAD_FD_EXCEPTION, sock->id);
        btsock_thread_add_fd(pth, accept_rs->our_fd, BTSOCK_L2CAP, SOCK_THREAD_FD_RD,
                accept_rs->id);
        APPL_TRACE_DEBUG("sending connect signal & app fd: %d to app server to accept() the"
 " connection", accept_rs->app_fd);
        APPL_TRACE_DEBUG("server fd:%d, scn:%d", sock->our_fd, sock->channel);
        send_app_connect_signal(sock->our_fd, &accept_rs->addr, sock->channel, 0,
                accept_rs->app_fd, p_open->tx_mtu);
        accept_rs->app_fd = -1; // The fd is closed after sent to app in send_app_connect_signal()
 if(btSock_start_l2cap_server_l(sock) != BT_STATUS_SUCCESS) {
            btsock_l2cap_free_l(sock);
 }
 }
}

void *atomic_thread_inc_dec(void *context) {
struct atomic_test_s32_s *at = (struct atomic_test_s32_s *)context;
for (int i = 0; i < at->max_val; i++) {
    usleep(1);
atomic_inc_prefix_s32(&at->data[i]);
    usleep(1);
atomic_dec_prefix_s32(&at->data[i]);
}
return NULL;
}

void btif_hh_setreport(btif_hh_device_t *p_dev, bthh_report_type_t r_type, UINT16 size,
                            UINT8* report)
{
    BT_HDR* p_buf = create_pbuf(size, report);
 if (p_buf == NULL) {
        APPL_TRACE_ERROR("%s: Error, failed to allocate RPT buffer, size = %d", __FUNCTION__, size);
 return;
 }
    BTA_HhSetReport(p_dev->dev_handle, r_type, p_buf);
}

static bt_status_t init_ctrl(btrc_ctrl_callbacks_t* callbacks )
{
    BTIF_TRACE_EVENT("## %s ##", __FUNCTION__);
 bt_status_t result = BT_STATUS_SUCCESS;

 if (bt_rc_ctrl_callbacks)
 return BT_STATUS_DONE;

    bt_rc_ctrl_callbacks = callbacks;
    memset (&btif_rc_cb, 0, sizeof(btif_rc_cb));
    btif_rc_cb.rc_vol_label=MAX_LABEL;
    btif_rc_cb.rc_volume=MAX_VOLUME;
    lbl_init();

 return result;
}

void init_all_transactions()
{
    UINT8 txn_indx=0;
 for(txn_indx=0; txn_indx < MAX_TRANSACTIONS_PER_SESSION; txn_indx++)
 {
        initialize_transaction(txn_indx);
 }
}

void btif_hl_free_buf(void **p)
{
 if (*p != NULL)
 {
        BTIF_TRACE_DEBUG("%s OK", __FUNCTION__ );
        GKI_freebuf(*p);
 *p = NULL;
 }
 else
        BTIF_TRACE_ERROR("%s NULL pointer",__FUNCTION__ );
}

static bool btif_fetch_property(const char *key, bt_bdaddr_t *addr) {
 char val[PROPERTY_VALUE_MAX] = {0};

 if (property_get(key, val, NULL)) {
 if (string_to_bdaddr(val, addr)) {
            BTIF_TRACE_DEBUG("%s: Got BDA %s", __func__, val);
 return TRUE;
 }
        BTIF_TRACE_DEBUG("%s: System Property did not contain valid bdaddr", __func__);
 }
 return FALSE;
}

static void cleanup_ctrl()
{
    BTIF_TRACE_EVENT("## %s ##", __FUNCTION__);

 if (bt_rc_ctrl_callbacks)
 {
        bt_rc_ctrl_callbacks = NULL;
 }
    memset(&btif_rc_cb, 0, sizeof(btif_rc_cb_t));
    lbl_destroy();
    BTIF_TRACE_EVENT("## %s ## completed", __FUNCTION__);
}

void bta_hh_co_data(UINT8 dev_handle, UINT8 *p_rpt, UINT16 len, tBTA_HH_PROTO_MODE mode,
                    UINT8 sub_class, UINT8 ctry_code, BD_ADDR peer_addr, UINT8 app_id)
{
 btif_hh_device_t *p_dev;
    UNUSED(peer_addr);

    APPL_TRACE_DEBUG("%s: dev_handle = %d, subclass = 0x%02X, mode = %d, "
 "ctry_code = %d, app_id = %d",
         __FUNCTION__, dev_handle, sub_class, mode, ctry_code, app_id);

    p_dev = btif_hh_find_connected_dev_by_handle(dev_handle);
 if (p_dev == NULL) {
        APPL_TRACE_WARNING("%s: Error: unknown HID device handle %d", __FUNCTION__, dev_handle);
 return;
 }

 if ((p_dev->fd >= 0) && p_dev->ready_for_data) {
        bta_hh_co_write(p_dev->fd, p_rpt, len);
 }else {
        APPL_TRACE_WARNING("%s: Error: fd = %d, ready %d, len = %d", __FUNCTION__, p_dev->fd, 
                            p_dev->ready_for_data, len);
 }
}

static inline void btif_hh_close_poll_thread(btif_hh_device_t *p_dev)
{
    APPL_TRACE_DEBUG("%s", __FUNCTION__);
    p_dev->hh_keep_polling = 0;
 if(p_dev->hh_poll_thread_id > 0)
        pthread_join(p_dev->hh_poll_thread_id,NULL);

 return;
}

static int in_standby(struct audio_stream *stream)
{
    UNUSED(stream);

    FNLOG();
 return 0;
}

void btif_hh_stop_vup_timer(bt_bdaddr_t *bd_addr)
{
 btif_hh_device_t *p_dev  = btif_hh_find_connected_dev_by_bda(bd_addr);
 if(p_dev != NULL)
 {
 if (p_dev->vup_timer_active)
 {
            BTIF_TRACE_DEBUG("stop VUP timer ");
            btu_stop_timer(&p_dev->vup_timer);
 }
        p_dev->vup_timer_active = FALSE;
 }
}

void lbl_init()
{
    memset(&device,0,sizeof(rc_device_t));
 pthread_mutexattr_t attr;
    pthread_mutexattr_init(&attr);
    pthread_mutex_init(&(device.lbllock), &attr);
    pthread_mutexattr_destroy(&attr);
    init_all_transactions();
}

static void btif_fetch_local_bdaddr(bt_bdaddr_t *local_addr)
{
char val[PROPERTY_VALUE_MAX] = {0};
uint8_t valid_bda = FALSE;
int val_size = 0;
const uint8_t null_bdaddr[BD_ADDR_LEN] = {0,0,0,0,0,0};

/* Get local bdaddr storage path from property */
if (property_get(PROPERTY_BT_BDADDR_PATH, val, NULL))
{
int addr_fd;


BTIF_TRACE_DEBUG("%s, local bdaddr is stored in %s", __func__, val);

        if ((addr_fd = open(val, O_RDONLY)) != -1)
{
memset(val, 0, sizeof(val));
            read(addr_fd, val, FACTORY_BT_BDADDR_STORAGE_LEN);
/* If this is not a reserved/special bda, then use it */
if ((string_to_bdaddr(val, local_addr)) &&
(memcmp(local_addr->address, null_bdaddr, BD_ADDR_LEN) != 0))
{
valid_bda = TRUE;
BTIF_TRACE_DEBUG("%s: Got Factory BDA %s", __func__, val);
}
close(addr_fd);
}
}

if(!valid_bda)
{
val_size = sizeof(val);
if(btif_config_get_str("Adapter", "Address", val, &val_size))
{
string_to_bdaddr(val, local_addr);
BTIF_TRACE_DEBUG("local bdaddr from bt_config.xml is  %s", val);
return;
}
}

/* No factory BDADDR found. Look for previously generated random BDA */
if (!valid_bda) {
valid_bda = btif_fetch_property(PERSIST_BDADDR_PROPERTY, local_addr);
}

/* No BDADDR found in file. Look for BDA in factory property */
if (!valid_bda) {
valid_bda = btif_fetch_property(FACTORY_BT_ADDR_PROPERTY, local_addr);
}

/* Generate new BDA if necessary */
if (!valid_bda)
{
bdstr_t bdstr;
/* Seed the random number generator */
srand((unsigned int) (time(0)));

/* No autogen BDA. Generate one now. */
local_addr->address[0] = 0x22;
local_addr->address[1] = 0x22;
local_addr->address[2] = (uint8_t) ((rand() >> 8) & 0xFF);
local_addr->address[3] = (uint8_t) ((rand() >> 8) & 0xFF);
local_addr->address[4] = (uint8_t) ((rand() >> 8) & 0xFF);
local_addr->address[5] = (uint8_t) ((rand() >> 8) & 0xFF);

/* Convert to ascii, and store as a persistent property */
bdaddr_to_string(local_addr, bdstr, sizeof(bdstr));

BTIF_TRACE_DEBUG("No preset BDA. Generating BDA: %s for prop %s",
(char*)bdstr, PERSIST_BDADDR_PROPERTY);

if (property_set(PERSIST_BDADDR_PROPERTY, (char*)bdstr) < 0)
BTIF_TRACE_ERROR("Failed to set random BDA in prop %s",PERSIST_BDADDR_PROPERTY);
}

//save the bd address to config file
bdstr_t bdstr;
bdaddr_to_string(local_addr, bdstr, sizeof(bdstr));
val_size = sizeof(val);
if (btif_config_get_str("Adapter", "Address", val, &val_size))
{
if (strcmp(bdstr, val) ==0)
{
// BDA is already present in the config file.
return;
}
}
btif_config_set_str("Adapter", "Address", bdstr);
}

static bt_status_t get_report (bt_bdaddr_t *bd_addr, bthh_report_type_t reportType, uint8_t reportId, int bufferSize)
{
    CHECK_BTHH_INIT();
 btif_hh_device_t *p_dev;
    BD_ADDR* bda = (BD_ADDR*) bd_addr;

    BTIF_TRACE_DEBUG("%s:proto_mode = %dr_type = %d, rpt_id = %d, buf_size = %d", __FUNCTION__,
          reportType, reportId, bufferSize);

    BTIF_TRACE_DEBUG("addr = %02X:%02X:%02X:%02X:%02X:%02X",
 (*bda)[0], (*bda)[1], (*bda)[2], (*bda)[3], (*bda)[4], (*bda)[5]);

 if (btif_hh_cb.status == BTIF_HH_DISABLED) {
        BTIF_TRACE_ERROR("%s: Error, HH status = %d", __FUNCTION__, btif_hh_cb.status);
 return BT_STATUS_FAIL;
 }


    p_dev = btif_hh_find_connected_dev_by_bda(bd_addr);
 if (p_dev == NULL) {
        BTIF_TRACE_ERROR("%s: Error, device %02X:%02X:%02X:%02X:%02X:%02X not opened.",
 (*bda)[0], (*bda)[1], (*bda)[2], (*bda)[3], (*bda)[4], (*bda)[5]);
 return BT_STATUS_FAIL;
 }
 else if ( ((int) reportType) <= BTA_HH_RPTT_RESRV || ((int) reportType) > BTA_HH_RPTT_FEATURE) {
        BTIF_TRACE_ERROR(" Error, device %02X:%02X:%02X:%02X:%02X:%02X not opened.",
 (*bda)[0], (*bda)[1], (*bda)[2], (*bda)[3], (*bda)[4], (*bda)[5]);
 return BT_STATUS_FAIL;
 }
 else {
        BTA_HhGetReport(p_dev->dev_handle, reportType,
                        reportId, bufferSize);
 }

 return BT_STATUS_SUCCESS;
}

BOOLEAN check_cod(const bt_bdaddr_t *remote_bdaddr, uint32_t cod)
{
 uint32_t    remote_cod;
 bt_property_t prop_name;

 /* check if we already have it in our btif_storage cache */
    BTIF_STORAGE_FILL_PROPERTY(&prop_name, BT_PROPERTY_CLASS_OF_DEVICE,
 sizeof(uint32_t), &remote_cod);
 if (btif_storage_get_remote_device_property((bt_bdaddr_t *)remote_bdaddr, &prop_name) == BT_STATUS_SUCCESS)
 {
        LOG_INFO("%s remote_cod = 0x%08x cod = 0x%08x", __func__, remote_cod, cod);
 if ((remote_cod & 0x7ff) == cod)
 return TRUE;
 }

 return FALSE;
}

static BT_HDR *create_pbuf(UINT16 len, UINT8 *data)
{
    UINT16 buflen = (UINT16) (len + BTA_HH_MIN_OFFSET + sizeof(BT_HDR));
 if (buflen < len) {
      android_errorWriteWithInfoLog(0x534e4554, "28672558", -1, NULL, 0);
 return NULL;
 }
    BT_HDR* p_buf = GKI_getbuf(buflen);

 if (p_buf) {
        UINT8* pbuf_data;

        p_buf->len = len;
        p_buf->offset = BTA_HH_MIN_OFFSET;

        pbuf_data = (UINT8*) (p_buf + 1) + p_buf->offset;
        memcpy(pbuf_data, data, len);
 }
 return p_buf;
}

static bt_status_t btif_in_get_remote_device_properties(bt_bdaddr_t *bd_addr)
{
 bt_property_t remote_properties[8];
 uint32_t num_props = 0;

 bt_bdname_t name, alias;
 uint32_t cod, devtype;
 bt_uuid_t remote_uuids[BT_MAX_NUM_UUIDS];

    memset(remote_properties, 0, sizeof(remote_properties));
    BTIF_STORAGE_FILL_PROPERTY(&remote_properties[num_props], BT_PROPERTY_BDNAME,
 sizeof(name), &name);
    btif_storage_get_remote_device_property(bd_addr,
 &remote_properties[num_props]);
    num_props++;

    BTIF_STORAGE_FILL_PROPERTY(&remote_properties[num_props], BT_PROPERTY_REMOTE_FRIENDLY_NAME,
 sizeof(alias), &alias);
    btif_storage_get_remote_device_property(bd_addr,
 &remote_properties[num_props]);
    num_props++;

    BTIF_STORAGE_FILL_PROPERTY(&remote_properties[num_props], BT_PROPERTY_CLASS_OF_DEVICE,
 sizeof(cod), &cod);
    btif_storage_get_remote_device_property(bd_addr,
 &remote_properties[num_props]);
    num_props++;

    BTIF_STORAGE_FILL_PROPERTY(&remote_properties[num_props], BT_PROPERTY_TYPE_OF_DEVICE,
 sizeof(devtype), &devtype);
    btif_storage_get_remote_device_property(bd_addr,
 &remote_properties[num_props]);
    num_props++;

    BTIF_STORAGE_FILL_PROPERTY(&remote_properties[num_props], BT_PROPERTY_UUIDS,
 sizeof(remote_uuids), remote_uuids);
    btif_storage_get_remote_device_property(bd_addr,
 &remote_properties[num_props]);
    num_props++;

    HAL_CBACK(bt_hal_cbacks, remote_device_properties_cb,
                     BT_STATUS_SUCCESS, bd_addr, num_props, remote_properties);

 return BT_STATUS_SUCCESS;
}

int btpan_tap_open()
{
struct ifreq ifr;
int fd, err;
const char *clonedev = "/dev/tun";


/* open the clone device */

    if ((fd = open(clonedev, O_RDWR)) < 0)
{
BTIF_TRACE_DEBUG("could not open %s, err:%d", clonedev, errno);
return fd;
}

memset(&ifr, 0, sizeof(ifr));
ifr.ifr_flags = IFF_TAP | IFF_NO_PI;


strncpy(ifr.ifr_name, TAP_IF_NAME, IFNAMSIZ);

/* try to create the device */
    if ((err = ioctl(fd, TUNSETIFF, (void *) &ifr)) < 0)
{
BTIF_TRACE_DEBUG("ioctl error:%d, errno:%s", err, strerror(errno));
close(fd);
return err;

}
if (tap_if_up(TAP_IF_NAME, controller_get_interface()->get_address()) == 0)
{
        int flags = fcntl(fd, F_GETFL, 0);
        fcntl(fd, F_SETFL, flags | O_NONBLOCK);
return fd;
}
BTIF_TRACE_ERROR("can not bring up tap interface:%s", TAP_IF_NAME);
close(fd);
return INVALID_FD;
}

static int in_set_parameters(struct audio_stream *stream, const char *kvpairs)
{
    UNUSED(stream);
    UNUSED(kvpairs);

    FNLOG();
 return 0;
}

static int tap_if_down(const char *devname)
{
struct ifreq ifr;
int sk;

sk = socket(AF_INET, SOCK_DGRAM, 0);
if (sk < 0)
return -1;

memset(&ifr, 0, sizeof(ifr));
strncpy(ifr.ifr_name, devname, IF_NAMESIZE - 1);


ifr.ifr_flags &= ~IFF_UP;

    ioctl(sk, SIOCSIFFLAGS, (caddr_t) &ifr);

close(sk);

return 0;
}

void semaphore_wait(semaphore_t *semaphore) {
  assert(semaphore != NULL);
  assert(semaphore->fd != INVALID_FD);

 uint64_t value;
 if (eventfd_read(semaphore->fd, &value) == -1)
    LOG_ERROR("%s unable to wait on semaphore: %s", __func__, strerror(errno));
}

static BOOLEAN btif_hl_proc_cch_open_cfm(tBTA_HL *p_data)

{
 btif_hl_mcl_cb_t *p_mcb;
    UINT8                    app_idx, mcl_idx;
    BOOLEAN                  status = FALSE;

    BTIF_TRACE_DEBUG("%s", __FUNCTION__);

 if (btif_hl_find_app_idx_using_app_id(p_data->cch_open_cfm.app_id, &app_idx))
 {
        BTIF_TRACE_DEBUG("app_idx=%d", app_idx);
 if (btif_hl_find_mcl_idx(app_idx, p_data->cch_open_cfm.bd_addr, &mcl_idx))
 {
            BTIF_HL_GET_APP_CB_PTR(app_idx);

            p_mcb = BTIF_HL_GET_MCL_CB_PTR(app_idx, mcl_idx);
            BTIF_TRACE_DEBUG("mcl_idx=%d, mcl_handle=%d", mcl_idx,p_data->cch_open_cfm.mcl_handle);
            p_mcb->mcl_handle = p_data->cch_open_cfm.mcl_handle;
            p_mcb->is_connected = TRUE;
            status = btif_hl_proc_pending_op(app_idx, mcl_idx);
 if (status)
                btif_hl_start_cch_timer(app_idx, mcl_idx);
 }
 }

 return status;
}

static BOOLEAN btif_hl_get_bta_channel_type(bthl_channel_type_t channel_type, tBTA_HL_DCH_CFG *p){
    BOOLEAN status = TRUE;
 switch (channel_type)
 {
 case BTHL_CHANNEL_TYPE_RELIABLE:
 *p = BTA_HL_DCH_CFG_RELIABLE;
 break;
 case BTHL_CHANNEL_TYPE_STREAMING:
 *p = BTA_HL_DCH_CFG_STREAMING;
 break;
 case BTHL_CHANNEL_TYPE_ANY:
 *p = BTA_HL_DCH_CFG_NO_PREF;
 break;
 default:
            status = FALSE;
 break;
 }
    BTIF_TRACE_DEBUG("%s status = %d BTA DCH CFG=%d (1-rel 2-strm",
                      __FUNCTION__, status, *p);
 return status;
}

static int uhid_write(int fd, const struct uhid_event *ev)
{
    ssize_t ret = write(fd, ev, sizeof(*ev));
if (ret < 0){
int rtn = -errno;
APPL_TRACE_ERROR("%s: Cannot write to uhid:%s",
__FUNCTION__, strerror(errno));
return rtn;
} else if (ret != (ssize_t)sizeof(*ev)) {
APPL_TRACE_ERROR("%s: Wrong size written to uhid: %zd != %zu",
__FUNCTION__, ret, sizeof(*ev));
return -EFAULT;
}

return 0;
}

static BOOLEAN check_cached_remote_name(tBTA_DM_SEARCH *p_search_data,
                                UINT8 *p_remote_name, UINT8 *p_remote_name_len)
{
 bt_bdname_t bdname;
 bt_bdaddr_t remote_bdaddr;
 bt_property_t prop_name;

 /* check if we already have it in our btif_storage cache */
    bdcpy(remote_bdaddr.address, p_search_data->inq_res.bd_addr);
    BTIF_STORAGE_FILL_PROPERTY(&prop_name, BT_PROPERTY_BDNAME,
 sizeof(bt_bdname_t), &bdname);
 if (btif_storage_get_remote_device_property(
 &remote_bdaddr, &prop_name) == BT_STATUS_SUCCESS)
 {
 if (p_remote_name && p_remote_name_len)
 {
            strcpy((char *)p_remote_name, (char *)bdname.name);
 *p_remote_name_len = strlen((char *)p_remote_name);
 }
 return TRUE;
 }

 return FALSE;
}

void btif_rc_check_handle_pending_play (BD_ADDR peer_addr, BOOLEAN bSendToApp)
{
    UNUSED(peer_addr);

    BTIF_TRACE_DEBUG("%s: bSendToApp=%d", __FUNCTION__, bSendToApp);
 if (btif_rc_cb.rc_pending_play)
 {
 if (bSendToApp)
 {
            tBTA_AV_REMOTE_CMD remote_cmd;
            APPL_TRACE_DEBUG("%s: Sending queued PLAYED event to app", __FUNCTION__);

            memset (&remote_cmd, 0, sizeof(tBTA_AV_REMOTE_CMD));
            remote_cmd.rc_handle  = btif_rc_cb.rc_handle;
            remote_cmd.rc_id      = AVRC_ID_PLAY;
            remote_cmd.hdr.ctype  = AVRC_CMD_CTRL;
            remote_cmd.hdr.opcode = AVRC_OP_PASS_THRU;

 /* delay sending to app, else there is a timing issue in the framework,
             ** which causes the audio to be on th device's speaker. Delay between
             ** OPEN & RC_PLAYs
            */
            GKI_delay (200);
 /* send to app - both PRESSED & RELEASED */
            remote_cmd.key_state  = AVRC_STATE_PRESS;
            handle_rc_passthrough_cmd( &remote_cmd );

            GKI_delay (100);

            remote_cmd.key_state  = AVRC_STATE_RELEASE;
            handle_rc_passthrough_cmd( &remote_cmd );
 }
        btif_rc_cb.rc_pending_play = FALSE;
 }
}

static future_t *start_up(void) {
  module_started = true;
  update_logging();

 return NULL;
}

static int uipc_main_init(void)
{
 int i;
 pthread_mutexattr_t attr;
    pthread_mutexattr_init(&attr);
    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
    pthread_mutex_init(&uipc_main.mutex, &attr);

    BTIF_TRACE_EVENT("### uipc_main_init ###");

 /* setup interrupt socket pair */
 if (socketpair(AF_UNIX, SOCK_STREAM, 0, uipc_main.signal_fds) < 0)
 {
 return -1;
 }

    FD_SET(uipc_main.signal_fds[0], &uipc_main.active_set);
    uipc_main.max_fd = MAX(uipc_main.max_fd, uipc_main.signal_fds[0]);

 for (i=0; i< UIPC_CH_NUM; i++)
 {
        tUIPC_CHAN *p = &uipc_main.ch[i];
        p->srvfd = UIPC_DISCONNECTED;
        p->fd = UIPC_DISCONNECTED;
        p->task_evt_flags = 0;
        pthread_cond_init(&p->cond, NULL);
        pthread_mutex_init(&p->cond_mutex, NULL);
        p->cback = NULL;
 }

 return 0;
}

static void epilog_timer_expired(UNUSED_ATTR void *context) {
  LOG_INFO("%s", __func__);
  thread_stop(thread);
}

reactor_object_t *reactor_register(reactor_t *reactor,
 int fd, void *context,
 void (*read_ready)(void *context),
 void (*write_ready)(void *context)) {
  assert(reactor != NULL);
  assert(fd != INVALID_FD);

 reactor_object_t *object = (reactor_object_t *)osi_calloc(sizeof(reactor_object_t));
 if (!object) {
    LOG_ERROR("%s unable to allocate reactor object: %s", __func__, strerror(errno));
 return NULL;
 }

  object->reactor = reactor;
  object->fd = fd;
  object->context = context;
  object->read_ready = read_ready;
  object->write_ready = write_ready;
  pthread_mutex_init(&object->lock, NULL);

 struct epoll_event event;
  memset(&event, 0, sizeof(event));
 if (read_ready)
    event.events |= (EPOLLIN | EPOLLRDHUP);
 if (write_ready)
    event.events |= EPOLLOUT;
  event.data.ptr = object;

 if (epoll_ctl(reactor->epoll_fd, EPOLL_CTL_ADD, fd, &event) == -1) {
    LOG_ERROR("%s unable to register fd %d to epoll set: %s", __func__, fd, strerror(errno));
    pthread_mutex_destroy(&object->lock);
    osi_free(object);
 return NULL;
 }

 return object;
}

void btif_dm_load_local_oob(void)
{
 char prop_oob[PROPERTY_VALUE_MAX];
    property_get("service.brcm.bt.oob", prop_oob, "3");
    BTIF_TRACE_DEBUG("btif_dm_load_local_oob prop_oob = %s",prop_oob);
 if (prop_oob[0] != '3')
 {
#if (BTM_OOB_INCLUDED == TRUE)
 if (oob_cb.sp_c[0] == 0 && oob_cb.sp_c[1] == 0 &&
            oob_cb.sp_c[2] == 0 && oob_cb.sp_c[3] == 0 )
 {
            BTIF_TRACE_DEBUG("btif_dm_load_local_oob: read OOB, call BTA_DmLocalOob()");
            BTA_DmLocalOob();
 }
#else
        BTIF_TRACE_ERROR("BTM_OOB_INCLUDED is FALSE!!(btif_dm_load_local_oob)");
#endif
 }
}

void btpan_close_handle(btpan_conn_t *p)
{
    BTIF_TRACE_DEBUG("btpan_close_handle : close handle %d", p->handle);
    p->handle = -1;
    p->local_role = -1;
    p->remote_role = -1;
    memset(&p->peer, 0, 6);
}

static void btif_hl_proc_dch_reconnect_ind(tBTA_HL *p_data)

{
 btif_hl_app_cb_t *p_acb;
 btif_hl_mdl_cb_t *p_dcb;
    UINT8                   app_idx, mcl_idx, mdl_idx, mdep_cfg_idx;
    BOOLEAN                 close_dch = FALSE;

    BTIF_TRACE_DEBUG("%s", __FUNCTION__);

    btif_hl_find_app_idx_using_mdepId(p_data->dch_reconnect_ind.local_mdep_id,&app_idx);

 if (btif_hl_find_mcl_idx_using_app_idx(p_data->dch_reconnect_ind.mcl_handle, app_idx, &mcl_idx ))
 {
        p_acb = BTIF_HL_GET_APP_CB_PTR(app_idx);
        BTIF_TRACE_DEBUG("btif_hl_proc_dch_reconnect_ind: app_idx = %d, mcl_idx = %d",
                                app_idx, mcl_idx);
        BTIF_HL_GET_MCL_CB_PTR(app_idx, mcl_idx);

 if (btif_hl_find_avail_mdl_idx(app_idx, mcl_idx, &mdl_idx))
 {
            p_dcb =BTIF_HL_GET_MDL_CB_PTR(app_idx, mcl_idx, mdl_idx);

 if (btif_hl_find_mdep_cfg_idx(app_idx, p_data->dch_reconnect_ind.local_mdep_id, &mdep_cfg_idx))
 {
                p_dcb->in_use               = TRUE;
                p_dcb->mdl_handle           = p_data->dch_reconnect_ind.mdl_handle;
                p_dcb->local_mdep_cfg_idx   = mdep_cfg_idx;
                p_dcb->local_mdep_id        = p_data->dch_reconnect_ind.local_mdep_id;
                p_dcb->mdl_id               = p_data->dch_reconnect_ind.mdl_id;
                p_dcb->dch_mode             = p_data->dch_reconnect_ind.dch_mode;
                p_dcb->dch_mode             = p_data->dch_reconnect_ind.dch_mode;
                p_dcb->is_the_first_reliable= p_data->dch_reconnect_ind.first_reliable;
                p_dcb->mtu                  = p_data->dch_reconnect_ind.mtu;
                p_dcb->channel_id           = btif_hl_get_next_channel_id(p_acb->app_id);

                BTIF_TRACE_DEBUG(" app_idx=%d mcl_idx=%d mdl_idx=%d channel_id=%d",
                                  app_idx, mcl_idx, mdl_idx, p_dcb->channel_id  );
 if (!btif_hl_create_socket(app_idx, mcl_idx, mdl_idx))
 {
                    BTIF_TRACE_ERROR("Unable to create socket");
                    close_dch = TRUE;
 }
 }
 else
 {
                BTIF_TRACE_ERROR("INVALID_LOCAL_MDEP_ID mdep_id=%d",p_data->dch_open_cfm.local_mdep_id);
                close_dch = TRUE;
 }

 if (close_dch)
                btif_hl_clean_mdl_cb(p_dcb);
 }
 else
            close_dch = TRUE;
 }
 else
        close_dch = TRUE;

 if (close_dch)
        BTA_HlDchClose(p_data->dch_reconnect_ind.mdl_handle);

}

const btrc_ctrl_interface_t *btif_rc_ctrl_get_interface(void)
{
    BTIF_TRACE_EVENT("%s", __FUNCTION__);
 return &bt_rc_ctrl_interface;
}

static void execute_storage_remote_request(UINT16 event, char *p_param)
{
 bt_status_t status = BT_STATUS_FAIL;
 bt_property_t prop;

    BTIF_TRACE_EVENT("execute storage remote request event : %d", event);

 switch (event)
 {
 case BTIF_CORE_STORAGE_REMOTE_READ:
 {
 char buf[1024];
 btif_storage_req_t *p_req = (btif_storage_req_t*)p_param;
            prop.type = p_req->read_req.type;
            prop.val = (void*) buf;
            prop.len = sizeof(buf);

            status = btif_storage_get_remote_device_property(&(p_req->read_req.bd_addr),
 &prop);
            HAL_CBACK(bt_hal_cbacks, remote_device_properties_cb,
                            status, &(p_req->read_req.bd_addr), 1, &prop);
 }break;
 case BTIF_CORE_STORAGE_REMOTE_WRITE:
 {
 btif_storage_req_t *p_req = (btif_storage_req_t*)p_param;
           status = btif_storage_set_remote_device_property(&(p_req->write_req.bd_addr),
 &(p_req->write_req.prop));
 }break;
 case BTIF_CORE_STORAGE_REMOTE_READ_ALL:
 {
 btif_storage_req_t *p_req = (btif_storage_req_t*)p_param;
           btif_in_get_remote_device_properties(&p_req->read_req.bd_addr);
 }break;
 }
}

static bt_status_t btpan_connect(const bt_bdaddr_t *bd_addr, int local_role, int remote_role)
{
    BTIF_TRACE_DEBUG("local_role:%d, remote_role:%d", local_role, remote_role);
 int bta_local_role = btpan_role_to_bta(local_role);
 int bta_remote_role = btpan_role_to_bta(remote_role);
    btpan_new_conn(-1, bd_addr->address, bta_local_role, bta_remote_role);
    BTA_PanOpen((UINT8*)bd_addr->address, bta_local_role, bta_remote_role);
 return BT_STATUS_SUCCESS;
}

static bt_status_t send_passthrough_cmd(bt_bdaddr_t *bd_addr, uint8_t key_code, uint8_t key_state)
{
    tAVRC_STS status = BT_STATUS_UNSUPPORTED;
#if (AVRC_CTLR_INCLUDED == TRUE)
    CHECK_RC_CONNECTED
 rc_transaction_t *p_transaction=NULL;
    BTIF_TRACE_DEBUG("%s: key-code: %d, key-state: %d", __FUNCTION__,
                                                    key_code, key_state);
 if (btif_rc_cb.rc_features & BTA_AV_FEAT_RCTG)
 {
 bt_status_t tran_status = get_transaction(&p_transaction);
 if(BT_STATUS_SUCCESS == tran_status && NULL != p_transaction)
 {
            BTA_AvRemoteCmd(btif_rc_cb.rc_handle, p_transaction->lbl,
 (tBTA_AV_RC)key_code, (tBTA_AV_STATE)key_state);
            status =  BT_STATUS_SUCCESS;
            BTIF_TRACE_DEBUG("%s: succesfully sent passthrough command to BTA", __FUNCTION__);
 }
 else
 {
            status =  BT_STATUS_FAIL;
            BTIF_TRACE_DEBUG("%s: error in fetching transaction", __FUNCTION__);
 }
 }
 else
 {
        status =  BT_STATUS_FAIL;
        BTIF_TRACE_DEBUG("%s: feature not supported", __FUNCTION__);
 }
#else
    BTIF_TRACE_DEBUG("%s: feature not enabled", __FUNCTION__);
#endif
 return status;
}

static BOOLEAN btif_hl_find_sdp_idx_using_mdep_filter(UINT8 app_idx, UINT8 mcl_idx, UINT8 *p_sdp_idx)
{
 btif_hl_app_cb_t *p_acb  =BTIF_HL_GET_APP_CB_PTR(app_idx);
 btif_hl_mcl_cb_t *p_mcb  =BTIF_HL_GET_MCL_CB_PTR(app_idx, mcl_idx);
    UINT8                   i, j, num_recs,num_elems, num_mdeps, mdep_idx;
    tBTA_HL_MDEP_ROLE       peer_mdep_role;
    UINT16                  data_type;
    tBTA_HL_SDP_MDEP_CFG    *p_mdep;
    BOOLEAN                 found = FALSE;
    BOOLEAN                 elem_found;

    BTIF_TRACE_DEBUG("btif_hl_find_sdp_idx_using_mdep_filter");
    num_recs = p_mcb->sdp.num_recs;
    num_elems = p_acb->filter.num_elems;
 if (!num_elems)
 {
        BTIF_TRACE_DEBUG("btif_hl_find_sdp_idx_using_mdep_filter num_elem=0");
 *p_sdp_idx = 0;
        found = TRUE;
 return found;
 }

 for (i=0; i<num_recs; i++)
 {
        num_mdeps = p_mcb->sdp.sdp_rec[i].num_mdeps;
 for (j=0; j<num_elems; j++ )
 {
            data_type = p_acb->filter.elem[j].data_type;
            peer_mdep_role = p_acb->filter.elem[j].peer_mdep_role;
            elem_found = FALSE;
            mdep_idx=0;
 while (!elem_found && mdep_idx < num_mdeps )
 {
                p_mdep = &(p_mcb->sdp.sdp_rec[i].mdep_cfg[mdep_idx]);
 if ( (p_mdep->data_type == data_type) &&
 (p_mdep->mdep_role == peer_mdep_role) )
 {
                    elem_found = TRUE;
 }
 else
 {
                    mdep_idx++;
 }
 }

 if (!elem_found)
 {
                found = FALSE;
 break;
 }
 else
 {
                found = TRUE;
 }
 }

 if (found)
 {
            BTIF_TRACE_DEBUG("btif_hl_find_sdp_idx_using_mdep_filter found idx=%d",i);
 *p_sdp_idx = i;
 break;
 }
 }

    BTIF_TRACE_DEBUG("%s found=%d sdp_idx=%d",__FUNCTION__ , found, *p_sdp_idx);

    btif_hl_reset_mdep_filter(app_idx);

 return found;
}

static void startup_timer_expired(UNUSED_ATTR void *context) {
  LOG_ERROR("%s", __func__);
  future_ready(startup_future, FUTURE_FAIL);
  startup_future = NULL;
}

static void btif_hl_stop_timer_using_handle( tBTA_HL_MCL_HANDLE mcl_handle){
 btif_hl_app_cb_t *p_acb;
    UINT8 i,j;

 for (i=0; i<BTA_HL_NUM_APPS; i++)
 {
        p_acb =BTIF_HL_GET_APP_CB_PTR(i);
 for (j=0; j < BTA_HL_NUM_MCLS ; j++)
 {
 if (p_acb->mcb[j].in_use &&
 (p_acb->mcb[j].mcl_handle == mcl_handle))
 {
                btif_hl_stop_cch_timer(i, j);
 }
 }
 }
}

static int out_set_sample_rate(struct audio_stream *stream, uint32_t rate)
{
 struct a2dp_stream_out *out = (struct a2dp_stream_out *)stream;

    DEBUG("out_set_sample_rate : %" PRIu32, rate);

 if (rate != AUDIO_STREAM_DEFAULT_RATE)
 {
        ERROR("only rate %d supported", AUDIO_STREAM_DEFAULT_RATE);
 return -1;
 }

    out->common.cfg.rate = rate;

 return 0;
}

void on_l2cap_psm_assigned(int id, int psm) {
    l2cap_socket *sock;
 /* Setup ETM settings:
     *  mtu will be set below */
    pthread_mutex_lock(&state_lock);
    sock = btsock_l2cap_find_by_id_l(id);
    sock->channel = psm;

 if(btSock_start_l2cap_server_l(sock) != BT_STATUS_SUCCESS) {
        btsock_l2cap_free_l(sock);
 }

    pthread_mutex_unlock(&state_lock);

}

static void on_rfc_close(UNUSED_ATTR tBTA_JV_RFCOMM_CLOSE *p_close, uint32_t id) {
  pthread_mutex_lock(&slot_lock);

 rfc_slot_t *slot = find_rfc_slot_by_id(id);
 if (slot)
    cleanup_rfc_slot(slot);

  pthread_mutex_unlock(&slot_lock);
}

static void btif_update_remote_version_property(bt_bdaddr_t *p_bd)
{
 bt_property_t property;
    UINT8 lmp_ver = 0;
    UINT16 lmp_subver = 0;
    UINT16 mfct_set = 0;
    tBTM_STATUS btm_status;
 bt_remote_version_t info;
 bt_status_t status;
 bdstr_t bdstr;

    btm_status = BTM_ReadRemoteVersion(*(BD_ADDR*)p_bd, &lmp_ver,
 &mfct_set, &lmp_subver);

    LOG_DEBUG("remote version info [%s]: %x, %x, %x", bdaddr_to_string(p_bd, bdstr, sizeof(bdstr)),
               lmp_ver, mfct_set, lmp_subver);

 if (btm_status == BTM_SUCCESS)
 {
        info.manufacturer = mfct_set;
        info.sub_ver = lmp_subver;
        info.version = lmp_ver;
        BTIF_STORAGE_FILL_PROPERTY(&property,
                            BT_PROPERTY_REMOTE_VERSION_INFO, sizeof(bt_remote_version_t),
 &info);
        status = btif_storage_set_remote_device_property(p_bd, &property);
        ASSERTC(status == BT_STATUS_SUCCESS, "failed to save remote version", status);
 }
}

static bt_status_t get_play_status_rsp(btrc_play_status_t play_status, uint32_t song_len,
 uint32_t song_pos)
{
    tAVRC_RESPONSE avrc_rsp;
    CHECK_RC_CONNECTED
    memset(&(avrc_rsp.get_play_status), 0, sizeof(tAVRC_GET_PLAY_STATUS_RSP));
    avrc_rsp.get_play_status.song_len = song_len;
    avrc_rsp.get_play_status.song_pos = song_pos;
    avrc_rsp.get_play_status.play_status = play_status;

    avrc_rsp.get_play_status.pdu = AVRC_PDU_GET_PLAY_STATUS;
    avrc_rsp.get_play_status.opcode = opcode_from_pdu(AVRC_PDU_GET_PLAY_STATUS);
    avrc_rsp.get_play_status.status = AVRC_STS_NO_ERROR;
 /* Send the response */
    SEND_METAMSG_RSP(IDX_GET_PLAY_STATUS_RSP, &avrc_rsp);
 return BT_STATUS_SUCCESS;
}

bt_status_t btif_enable_service(tBTA_SERVICE_ID service_id)
{
    tBTA_SERVICE_ID *p_id = &service_id;

 /* If BT is enabled, we need to switch to BTIF context and trigger the
     * enable for that profile
     *
     * Otherwise, we just set the flag. On BT_Enable, the DM will trigger
     * enable for the profiles that have been enabled */

    btif_enabled_services |= (1 << service_id);

    BTIF_TRACE_DEBUG("%s: current services:0x%x", __FUNCTION__, btif_enabled_services);

 if (btif_is_enabled())
 {
        btif_transfer_context(btif_dm_execute_service_request,
                              BTIF_DM_ENABLE_SERVICE,
 (char*)p_id, sizeof(tBTA_SERVICE_ID), NULL);
 }

 return BT_STATUS_SUCCESS;
}

UINT32 UIPC_Read(tUIPC_CH_ID ch_id, UINT16 *p_msg_evt, UINT8 *p_buf, UINT32 len)
{
int n;
int n_read = 0;
int fd = uipc_main.ch[ch_id].fd;
struct pollfd pfd;
UNUSED(p_msg_evt);

if (ch_id >= UIPC_CH_NUM)
{
BTIF_TRACE_ERROR("UIPC_Read : invalid ch id %d", ch_id);
return 0;
}

if (fd == UIPC_DISCONNECTED)
{
BTIF_TRACE_ERROR("UIPC_Read : channel %d closed", ch_id);
return 0;
}

//BTIF_TRACE_DEBUG("UIPC_Read : ch_id %d, len %d, fd %d, polltmo %d", ch_id, len,
//        fd, uipc_main.ch[ch_id].read_poll_tmo_ms);

while (n_read < (int)len)
{
pfd.fd = fd;
pfd.events = POLLIN|POLLHUP;


/* make sure there is data prior to attempting read to avoid blocking
a read for more than poll timeout */
        if (poll(&pfd, 1, uipc_main.ch[ch_id].read_poll_tmo_ms) == 0)
{
BTIF_TRACE_EVENT("poll timeout (%d ms)", uipc_main.ch[ch_id].read_poll_tmo_ms);
break;
}

//BTIF_TRACE_EVENT("poll revents %x", pfd.revents);

if (pfd.revents & (POLLHUP|POLLNVAL) )
{
BTIF_TRACE_EVENT("poll : channel detached remotely");
UIPC_LOCK();
uipc_close_locked(ch_id);
UIPC_UNLOCK();

return 0;
}

        n = recv(fd, p_buf+n_read, len-n_read, 0);

//BTIF_TRACE_EVENT("read %d bytes", n);

if (n == 0)
{
BTIF_TRACE_EVENT("UIPC_Read : channel detached remotely");
UIPC_LOCK();
uipc_close_locked(ch_id);
UIPC_UNLOCK();
return 0;
}

if (n < 0)
{
BTIF_TRACE_EVENT("UIPC_Read : read failed (%s)", strerror(errno));
return 0;
}

n_read+=n;

}

return n_read;
}

int btpan_tap_send(int tap_fd, const BD_ADDR src, const BD_ADDR dst, UINT16 proto, const char* buf,
UINT16 len, BOOLEAN ext, BOOLEAN forward)
{
UNUSED(ext);
UNUSED(forward);
if (tap_fd != INVALID_FD)
{
tETH_HDR eth_hdr;
memcpy(&eth_hdr.h_dest, dst, ETH_ADDR_LEN);
memcpy(&eth_hdr.h_src, src, ETH_ADDR_LEN);
eth_hdr.h_proto = htons(proto);
char packet[TAP_MAX_PKT_WRITE_LEN + sizeof(tETH_HDR)];
memcpy(packet, &eth_hdr, sizeof(tETH_HDR));
if (len > TAP_MAX_PKT_WRITE_LEN)
{
LOG_ERROR("btpan_tap_send eth packet size:%d is exceeded limit!", len);
return -1;
}

memcpy(packet + sizeof(tETH_HDR), buf, len);

/* Send data to network interface */
        int ret = write(tap_fd, packet, len + sizeof(tETH_HDR));
BTIF_TRACE_DEBUG("ret:%d", ret);
return ret;
}
return -1;

}

static int in_dump(const struct audio_stream *stream, int fd)
{
    UNUSED(stream);
    UNUSED(fd);

    FNLOG();
 return 0;
}

static int adev_open_input_stream(struct audio_hw_device *dev,
 audio_io_handle_t handle,
 audio_devices_t devices,
 struct audio_config *config,
 struct audio_stream_in **stream_in,
 audio_input_flags_t flags,
 const char *address,
 audio_source_t source)
{
 struct a2dp_audio_device *a2dp_dev = (struct a2dp_audio_device *)dev;
 struct a2dp_stream_in *in;
 int ret;
    UNUSED(address);
    UNUSED(config);
    UNUSED(devices);
    UNUSED(flags);
    UNUSED(handle);
    UNUSED(source);

    FNLOG();

    in = (struct a2dp_stream_in *)calloc(1, sizeof(struct a2dp_stream_in));

 if (!in)
 return -ENOMEM;

    in->stream.common.get_sample_rate = in_get_sample_rate;
    in->stream.common.set_sample_rate = in_set_sample_rate;
    in->stream.common.get_buffer_size = in_get_buffer_size;
    in->stream.common.get_channels = in_get_channels;
    in->stream.common.get_format = in_get_format;
    in->stream.common.set_format = in_set_format;
    in->stream.common.standby = in_standby;
    in->stream.common.dump = in_dump;
    in->stream.common.set_parameters = in_set_parameters;
    in->stream.common.get_parameters = in_get_parameters;
    in->stream.common.add_audio_effect = in_add_audio_effect;
    in->stream.common.remove_audio_effect = in_remove_audio_effect;
    in->stream.set_gain = in_set_gain;
    in->stream.read = in_read;
    in->stream.get_input_frames_lost = in_get_input_frames_lost;

 /* initialize a2dp specifics */
    a2dp_stream_common_init(&in->common);

 *stream_in = &in->stream;
    a2dp_dev->input = in;

    a2dp_open_ctrl_path(&in->common);
 if (in->common.ctrl_fd == AUDIO_SKT_DISCONNECTED)
 {
        ERROR("ctrl socket failed to connect (%s)", strerror(errno));
        ret = -1;
 goto err_open;
 }

 if (a2dp_read_audio_config(&in->common) < 0) {
        ERROR("a2dp_read_audio_config failed (%s)", strerror(errno));
        ret = -1;
 goto err_open;
 }

    DEBUG("success");
 return 0;

err_open:
    free(in);
 *stream_in = NULL;
    a2dp_dev->input = NULL;
    ERROR("failed");
 return ret;
}

const char *config_section_name(const config_section_node_t *node) {
  assert(node != NULL);
 const list_node_t *lnode = (const list_node_t *)node;
 const section_t *section = (const section_t *)list_node(lnode);
 return section->name;
}

static inline void bd_copy(UINT8* dest, UINT8* src, BOOLEAN swap)
{
 if (swap) {
 int i;
 for (i =0; i < 6 ;i++)
            dest[i]= src[5-i];
 }
 else memcpy(dest, src, 6);
}

static size_t in_get_buffer_size(const struct audio_stream *stream)
{
    UNUSED(stream);

    FNLOG();
 return 320;
}

static void event_postload(UNUSED_ATTR void *context) {
  LOG_INFO("%s", __func__);
 if(vendor->send_async_command(VENDOR_CONFIGURE_SCO, NULL) == -1) {
    sco_config_callback(false);

 }
}

void btif_hl_add_socket_to_set(fd_set *p_org_set) {
 btif_hl_mdl_cb_t *p_dcb = NULL;
 btif_hl_mcl_cb_t *p_mcb = NULL;
 btif_hl_app_cb_t *p_acb = NULL;
 btif_hl_evt_cb_t                evt_param;
 bt_status_t                     status;
 int                             len;

    BTIF_TRACE_DEBUG("entering %s",__FUNCTION__);

 for (const list_node_t *node = list_begin(soc_queue);
            node != list_end(soc_queue); node = list_next(node)) {
 btif_hl_soc_cb_t *p_scb = list_node(node);

        BTIF_TRACE_DEBUG("btif_hl_add_socket_to_set first p_scb=0x%x", p_scb);
 if (btif_hl_get_socket_state(p_scb) == BTIF_HL_SOC_STATE_W4_ADD) {
            btif_hl_set_socket_state(p_scb, BTIF_HL_SOC_STATE_W4_READ);
            FD_SET(p_scb->socket_id[1], p_org_set);
            BTIF_TRACE_DEBUG("found and set socket_id=%d is_set=%d",
                    p_scb->socket_id[1], FD_ISSET(p_scb->socket_id[1], p_org_set));
            p_mcb = BTIF_HL_GET_MCL_CB_PTR(p_scb->app_idx, p_scb->mcl_idx);
            p_dcb = BTIF_HL_GET_MDL_CB_PTR(p_scb->app_idx, p_scb->mcl_idx, p_scb->mdl_idx);
            p_acb = BTIF_HL_GET_APP_CB_PTR(p_scb->app_idx);
 if (p_mcb && p_dcb) {
                btif_hl_stop_timer_using_handle(p_mcb->mcl_handle);
                evt_param.chan_cb.app_id = p_acb->app_id;
                memcpy(evt_param.chan_cb.bd_addr, p_mcb->bd_addr, sizeof(BD_ADDR));
                evt_param.chan_cb.channel_id = p_dcb->channel_id;
                evt_param.chan_cb.fd = p_scb->socket_id[0];
                evt_param.chan_cb.mdep_cfg_index = (int ) p_dcb->local_mdep_cfg_idx;
                evt_param.chan_cb.cb_state = BTIF_HL_CHAN_CB_STATE_CONNECTED_PENDING;
                len = sizeof(btif_hl_send_chan_state_cb_t);
                status = btif_transfer_context (btif_hl_proc_cb_evt, BTIF_HL_SEND_CONNECTED_CB,
 (char*) &evt_param, len, NULL);
                ASSERTC(status == BT_STATUS_SUCCESS, "context transfer failed", status);
 }
 }
 }
    BTIF_TRACE_DEBUG("leaving %s",__FUNCTION__);
}

int main(int argc, char **argv) {
 if (argc < 2) {
    usage(argv[0]);
 return -1;
 }

 const command_t *command = find_command(argv[1]);
 if (!command) {
    printf("Unrecognized command '%s'.\n", argv[1]);
 return -2;
 }

 if (!command->handler) {
    printf("Unhandled command '%s'.\n", argv[1]);
 return -3;
 }

 return command->handler(argc - 2, &argv[2]);
}

static bt_status_t init(btrc_callbacks_t* callbacks )
{
    BTIF_TRACE_EVENT("## %s ##", __FUNCTION__);
 bt_status_t result = BT_STATUS_SUCCESS;

 if (bt_rc_callbacks)
 return BT_STATUS_DONE;

    bt_rc_callbacks = callbacks;
    memset (&btif_rc_cb, 0, sizeof(btif_rc_cb));
    btif_rc_cb.rc_vol_label=MAX_LABEL;
    btif_rc_cb.rc_volume=MAX_VOLUME;
    lbl_init();

 return result;
}

static void bte_scan_filt_param_cfg_evt(UINT8 action_type,
                                        tBTA_DM_BLE_PF_AVBL_SPACE avbl_space,
                                        tBTA_DM_BLE_REF_VALUE ref_value, tBTA_STATUS status)
{
 /* This event occurs on calling BTA_DmBleCfgFilterCondition internally,
    ** and that is why there is no HAL callback
    */
 if(BTA_SUCCESS != status)
 {
        BTIF_TRACE_ERROR("%s, %d", __FUNCTION__, status);
 }
 else
 {
        BTIF_TRACE_DEBUG("%s", __FUNCTION__);
 }
}

static int adev_set_mic_mute(struct audio_hw_device *dev, bool state)
{
    UNUSED(dev);
    UNUSED(state);

    FNLOG();

 return -ENOSYS;
}

static inline int btif_hl_select_wakeup(void){
char sig_on = btif_hl_signal_select_wakeup;
BTIF_TRACE_DEBUG("btif_hl_select_wakeup");
    return send(signal_fds[1], &sig_on, sizeof(sig_on), 0);
}

static uint32_t in_get_channels(const struct audio_stream *stream)
{
 struct a2dp_stream_in *in = (struct a2dp_stream_in *)stream;

    FNLOG();
 return in->common.cfg.channel_flags;
}

static audio_format_t out_get_format(const struct audio_stream *stream)
{
 struct a2dp_stream_out *out = (struct a2dp_stream_out *)stream;
    DEBUG("format 0x%x", out->common.cfg.format);
 return out->common.cfg.format;
}

static int out_set_volume(struct audio_stream_out *stream, float left,
 float right)
{
    UNUSED(stream);
    UNUSED(left);
    UNUSED(right);

    FNLOG();

 /* volume controlled in audioflinger mixer (digital) */

 return -ENOSYS;
}

const hci_t *hci_layer_get_test_interface(
 const allocator_t *buffer_allocator_interface,
 const hci_hal_t *hal_interface,
 const btsnoop_t *btsnoop_interface,
 const hci_inject_t *hci_inject_interface,
 const packet_fragmenter_t *packet_fragmenter_interface,
 const vendor_t *vendor_interface,
 const low_power_manager_t *low_power_manager_interface) {

  buffer_allocator = buffer_allocator_interface;
  hal = hal_interface;
  btsnoop = btsnoop_interface;
  hci_inject = hci_inject_interface;
  packet_fragmenter = packet_fragmenter_interface;
  vendor = vendor_interface;
  low_power_manager = low_power_manager_interface;

  init_layer_interface();
 return &interface;
}

static void update_keyboard_lockstates(btif_hh_device_t *p_dev)
{
    UINT8 len = 2; /* reportid + 1 byte report*/
    BD_ADDR* bda;
    BT_HDR* p_buf;
    UINT8 data[] = {0x01, /* report id */
                    btif_hh_keylockstates}; /* keystate */

 /* Set report for other keyboards */
    BTIF_TRACE_EVENT("%s: setting report on dev_handle %d to 0x%x",
         __FUNCTION__, p_dev->dev_handle, btif_hh_keylockstates);

 /* Get SetReport buffer */
    p_buf = create_pbuf(len, data);
 if (p_buf != NULL) {
        p_buf->layer_specific = BTA_HH_RPTT_OUTPUT;
        bda = (BD_ADDR*) (&p_dev->bd_addr);
        BTA_HhSendData(p_dev->dev_handle, *bda, p_buf);
 }
}

static rfc_slot_t *find_rfc_slot_by_id(uint32_t id) {
  assert(id != 0);

 for (size_t i = 0; i < ARRAY_SIZE(rfc_slots); ++i)
 if (rfc_slots[i].id == id)
 return &rfc_slots[i];

  LOG_ERROR("%s unable to find RFCOMM slot id: %d", __func__, id);
 return NULL;
}

void * btif_hl_get_buf(UINT16 size)
{
 void *p_new;

    BTIF_TRACE_DEBUG("%s", __FUNCTION__);
    BTIF_TRACE_DEBUG("ret size=%d GKI_MAX_BUF_SIZE=%d",size, 6000);

 if (size < 6000)
 {
        p_new = GKI_getbuf(size);
 }
 else
 {
        BTIF_TRACE_DEBUG("btif_hl_get_buf use HL large data pool");
        p_new = GKI_getpoolbuf(4);
 }

 return p_new;
}

int btsock_thread_init()
{
 static int initialized;
    APPL_TRACE_DEBUG("in initialized:%d", initialized);
 if(!initialized)
 {
        initialized = 1;
 int h;
 for(h = 0; h < MAX_THREAD; h++)
 {
            ts[h].cmd_fdr = ts[h].cmd_fdw = -1;
            ts[h].used = 0;
            ts[h].thread_id = -1;
            ts[h].poll_count = 0;
            ts[h].callback = NULL;
            ts[h].cmd_callback = NULL;
 }
 }
 return TRUE;
}

void uipc_main_cleanup(void)
{
 int i;

    BTIF_TRACE_EVENT("uipc_main_cleanup");

    close(uipc_main.signal_fds[0]);
    close(uipc_main.signal_fds[1]);

 /* close any open channels */
 for (i=0; i<UIPC_CH_NUM; i++)
        uipc_close_ch_locked(i);
}

static void on_rfc_write_done(UNUSED_ATTR tBTA_JV_RFCOMM_WRITE *p, uint32_t id) {
  pthread_mutex_lock(&slot_lock);

 rfc_slot_t *slot = find_rfc_slot_by_id(id);
 if (slot && !slot->f.outgoing_congest)
    btsock_thread_add_fd(pth, slot->fd, BTSOCK_RFCOMM, SOCK_THREAD_FD_RD, slot->id);

  pthread_mutex_unlock(&slot_lock);
}

static reactor_status_t run_reactor(reactor_t *reactor, int iterations) {
assert(reactor != NULL);

reactor->run_thread = pthread_self();
reactor->is_running = true;

struct epoll_event events[MAX_EVENTS];
for (int i = 0; iterations == 0 || i < iterations; ++i) {
pthread_mutex_lock(&reactor->list_lock);
list_clear(reactor->invalidation_list);
pthread_mutex_unlock(&reactor->list_lock);


int ret;
do {
      ret = epoll_wait(reactor->epoll_fd, events, MAX_EVENTS, -1);
} while (ret == -1 && errno == EINTR);

if (ret == -1) {
LOG_ERROR("%s error in epoll_wait: %s", __func__, strerror(errno));
reactor->is_running = false;
return REACTOR_STATUS_ERROR;
}

for (int j = 0; j < ret; ++j) {
// The event file descriptor is the only one that registers with
// a NULL data pointer. We use the NULL to identify it and break
// out of the reactor loop.
if (events[j].data.ptr == NULL) {
eventfd_t value;
eventfd_read(reactor->event_fd, &value);
reactor->is_running = false;
return REACTOR_STATUS_STOP;
}

reactor_object_t *object = (reactor_object_t *)events[j].data.ptr;

pthread_mutex_lock(&reactor->list_lock);
if (list_contains(reactor->invalidation_list, object)) {
pthread_mutex_unlock(&reactor->list_lock);
continue;
}

// Downgrade the list lock to an object lock.
pthread_mutex_lock(&object->lock);
pthread_mutex_unlock(&reactor->list_lock);

reactor->object_removed = false;
if (events[j].events & (EPOLLIN | EPOLLHUP | EPOLLRDHUP | EPOLLERR) && object->read_ready)
object->read_ready(object->context);
if (!reactor->object_removed && events[j].events & EPOLLOUT && object->write_ready)
object->write_ready(object->context);
pthread_mutex_unlock(&object->lock);

if (reactor->object_removed) {
pthread_mutex_destroy(&object->lock);
osi_free(object);
}
}
}

reactor->is_running = false;
return REACTOR_STATUS_DONE;
}

static void btif_dm_ble_tx_test_cback(void *p)
{
    btif_transfer_context(btif_dm_generic_evt, BTIF_DM_CB_LE_TX_TEST,
 (char *)p, 1, NULL);
}

static inline void close_cmd_fd(int h)
{
 if(ts[h].cmd_fdr != -1)
 {
        close(ts[h].cmd_fdr);
        ts[h].cmd_fdr = -1;
 }
 if(ts[h].cmd_fdw != -1)
 {
        close(ts[h].cmd_fdw);
        ts[h].cmd_fdw = -1;
 }
}

static void set_api_wants_to_log(bool value) {
  logging_enabled_via_api = value;
  update_logging();
}

void destroy_tap_read_thread(void)
{
 if (pan_pth >= 0)
 {
        btsock_thread_exit(pan_pth);
        pan_pth = -1;
 }
}

static char * out_get_parameters(const struct audio_stream *stream, const char *keys)
{
    UNUSED(keys);
 struct a2dp_stream_out *out = (struct a2dp_stream_out *)stream;

    FNLOG();

 /* add populating param here */

 return strdup("");
}

const btsnoop_t *btsnoop_get_interface() {
  stack_config = stack_config_get_interface();
 return &interface;
}

static audio_format_t in_get_format(const struct audio_stream *stream)
{
    UNUSED(stream);

    FNLOG();
 return AUDIO_FORMAT_PCM_16_BIT;
}

static BOOLEAN check_eir_remote_name(tBTA_DM_SEARCH *p_search_data,
                            UINT8 *p_remote_name, UINT8 *p_remote_name_len)
{
    UINT8 *p_eir_remote_name = NULL;
    UINT8 remote_name_len = 0;

 /* Check EIR for remote name and services */
 if (p_search_data->inq_res.p_eir)
 {
        p_eir_remote_name = BTM_CheckEirData(p_search_data->inq_res.p_eir,
                BTM_EIR_COMPLETE_LOCAL_NAME_TYPE, &remote_name_len);
 if (!p_eir_remote_name)
 {
            p_eir_remote_name = BTM_CheckEirData(p_search_data->inq_res.p_eir,
                    BTM_EIR_SHORTENED_LOCAL_NAME_TYPE, &remote_name_len);
 }

 if (p_eir_remote_name)
 {
 if (remote_name_len > BD_NAME_LEN)
                remote_name_len = BD_NAME_LEN;

 if (p_remote_name && p_remote_name_len)
 {
                memcpy(p_remote_name, p_eir_remote_name, remote_name_len);
 *(p_remote_name + remote_name_len) = 0;
 *p_remote_name_len = remote_name_len;
 }

 return TRUE;
 }
 }

 return FALSE;

}

void btif_hl_select_wakeup_callback( fd_set *p_org_set , int wakeup_signal){
    BTIF_TRACE_DEBUG("entering %s wakeup_signal=0x%04x",__FUNCTION__, wakeup_signal);

 if (wakeup_signal == btif_hl_signal_select_wakeup )
 {
        btif_hl_add_socket_to_set(p_org_set);
 }
 else if (wakeup_signal == btif_hl_signal_select_close_connected)
 {
        btif_hl_close_socket(p_org_set);
 }
    BTIF_TRACE_DEBUG("leaving %s",__FUNCTION__);
}

bt_status_t btif_disable_service(tBTA_SERVICE_ID service_id)
{
    tBTA_SERVICE_ID *p_id = &service_id;

 /* If BT is enabled, we need to switch to BTIF context and trigger the
     * disable for that profile so that the appropriate uuid_property_changed will
     * be triggerred. Otherwise, we just need to clear the service_id in the mask
     */

    btif_enabled_services &= (tBTA_SERVICE_MASK)(~(1<<service_id));

    BTIF_TRACE_DEBUG("%s: Current Services:0x%x", __FUNCTION__, btif_enabled_services);

 if (btif_is_enabled())
 {
        btif_transfer_context(btif_dm_execute_service_request,
                              BTIF_DM_DISABLE_SERVICE,
 (char*)p_id, sizeof(tBTA_SERVICE_ID), NULL);
 }

 return BT_STATUS_SUCCESS;
}

void btif_disable_bluetooth_evt(void)
{
    BTIF_TRACE_DEBUG("%s", __FUNCTION__);

#if (defined(HCILP_INCLUDED) && HCILP_INCLUDED == TRUE)
    bte_main_enable_lpm(FALSE);
#endif

#if (BLE_INCLUDED == TRUE)
     BTA_VendorCleanup();
#endif

     bte_main_disable();

 /* callback to HAL */
    future_ready(stack_manager_get_hack_future(), FUTURE_SUCCESS);
}

static future_t *transmit_command_futured(BT_HDR *command) {
 waiting_command_t *wait_entry = osi_calloc(sizeof(waiting_command_t));
  assert(wait_entry != NULL);

 future_t *future = future_new();

 uint8_t *stream = command->data + command->offset;
  STREAM_TO_UINT16(wait_entry->opcode, stream);
  wait_entry->complete_future = future;
  wait_entry->command = command;

  command->event = MSG_STACK_TO_HC_HCI_CMD;

  fixed_queue_enqueue(command_queue, wait_entry);
 return future;
}

void eager_reader_register(eager_reader_t *reader, reactor_t *reactor, eager_reader_cb read_cb, void *context) {
  assert(reader != NULL);
  assert(reactor != NULL);
  assert(read_cb != NULL);

  eager_reader_unregister(reader);

  reader->outbound_read_ready = read_cb;
  reader->outbound_context = context;
  reader->outbound_registration = reactor_register(reactor, reader->bytes_available_fd, reader, internal_outbound_read_ready, NULL);
}

static inline int btif_hl_select_wakeup_init(fd_set* set){
    BTIF_TRACE_DEBUG("%s", __func__);
 if (signal_fds[0] == -1 && socketpair(AF_UNIX, SOCK_STREAM, 0, signal_fds) < 0)
 {
        BTIF_TRACE_ERROR("socketpair failed: %s", strerror(errno));
 return -1;
 }

    BTIF_TRACE_DEBUG("btif_hl_select_wakeup_init signal_fds[0]=%d signal_fds[1]=%d",signal_fds[0], signal_fds[1] );
    FD_SET(signal_fds[0], set);

 return signal_fds[0];
}

void btif_hl_stop_cch_timer(UINT8 app_idx, UINT8 mcl_idx)
{
 btif_hl_mcl_cb_t *p_mcb = BTIF_HL_GET_MCL_CB_PTR(app_idx, mcl_idx);
    BTIF_TRACE_DEBUG("%s app_idx=%d, mcl_idx=%d timer_in_use=%d",
                      __FUNCTION__,app_idx, mcl_idx, p_mcb->cch_timer.in_use);

    p_mcb->cch_timer_active = FALSE;
 if (p_mcb->cch_timer.in_use)
 {
        BTIF_TRACE_DEBUG("stop CCH timer ");
        btu_stop_timer(&p_mcb->cch_timer);
 }
}

semaphore_t *semaphore_new(unsigned int value) {
 semaphore_t *ret = osi_malloc(sizeof(semaphore_t));
 if (ret) {
    ret->fd = eventfd(value, EFD_SEMAPHORE);
 if (ret->fd == INVALID_FD) {
      LOG_ERROR("%s unable to allocate semaphore: %s", __func__, strerror(errno));
      osi_free(ret);
      ret = NULL;
 }
 }
 return ret;
}

void btif_hh_remove_device(bt_bdaddr_t bd_addr)
{
 int                    i;
 btif_hh_device_t *p_dev;
 btif_hh_added_device_t *p_added_dev;

    LOG_INFO("%s: bda = %02x:%02x:%02x:%02x:%02x:%02x", __FUNCTION__,
         bd_addr.address[0], bd_addr.address[1], bd_addr.address[2], bd_addr.address[3], bd_addr.address[4], bd_addr.address[5]);

 for (i = 0; i < BTIF_HH_MAX_ADDED_DEV; i++) {
        p_added_dev = &btif_hh_cb.added_devices[i];
 if (memcmp(&(p_added_dev->bd_addr),&bd_addr, 6) == 0) {
            BTA_HhRemoveDev(p_added_dev->dev_handle);
            btif_storage_remove_hid_info(&(p_added_dev->bd_addr));
            memset(&(p_added_dev->bd_addr), 0, 6);
            p_added_dev->dev_handle = BTA_HH_INVALID_HANDLE;
 break;
 }
 }

    p_dev = btif_hh_find_dev_by_bda(&bd_addr);
 if (p_dev == NULL) {
        BTIF_TRACE_WARNING(" Oops, can't find device [%02x:%02x:%02x:%02x:%02x:%02x]",
             bd_addr.address[0], bd_addr.address[1], bd_addr.address[2], bd_addr.address[3], bd_addr.address[4], bd_addr.address[5]);
 return;
 }

 /* need to notify up-layer device is disconnected to avoid state out of sync with up-layer */
    HAL_CBACK(bt_hh_callbacks, connection_state_cb, &(p_dev->bd_addr), BTHH_CONN_STATE_DISCONNECTED);

    p_dev->dev_status = BTHH_CONN_STATE_UNKNOWN;
    p_dev->dev_handle = BTA_HH_INVALID_HANDLE;
    p_dev->ready_for_data = FALSE;

 if (btif_hh_cb.device_num > 0) {
        btif_hh_cb.device_num--;
 }
 else {
        BTIF_TRACE_WARNING("%s: device_num = 0", __FUNCTION__);
 }

    p_dev->hh_keep_polling = 0;
    p_dev->hh_poll_thread_id = -1;
    BTIF_TRACE_DEBUG("%s: uhid fd = %d", __FUNCTION__, p_dev->fd);
 if (p_dev->fd >= 0) {
        bta_hh_co_destroy(p_dev->fd);
        p_dev->fd = -1;
 }
}

btpan_conn_t* btpan_find_conn_addr(const BD_ADDR addr)
{
 for (int i = 0; i < MAX_PAN_CONNS; i++)
 {
 if (memcmp(btpan_cb.conns[i].peer, addr, sizeof(BD_ADDR)) == 0)
 return &btpan_cb.conns[i];
 }
 return NULL;
}

static void firmware_config_callback(UNUSED_ATTR bool success) {
  LOG_INFO("%s", __func__);
  firmware_is_configured = true;
  non_repeating_timer_cancel(startup_timer);

  future_ready(startup_future, FUTURE_SUCCESS);
  startup_future = NULL;
}

static void btif_hh_handle_evt(UINT16 event, char *p_param)
{
 bt_bdaddr_t *bd_addr = (bt_bdaddr_t*)p_param;
    BTIF_TRACE_EVENT("%s: event=%d", __FUNCTION__, event);
 int ret;
 switch(event)
 {
 case BTIF_HH_CONNECT_REQ_EVT:
 {
            ret = btif_hh_connect(bd_addr);
 if(ret == BT_STATUS_SUCCESS)
 {
                HAL_CBACK(bt_hh_callbacks, connection_state_cb,bd_addr,BTHH_CONN_STATE_CONNECTING);
 }
 else
                HAL_CBACK(bt_hh_callbacks, connection_state_cb,bd_addr,BTHH_CONN_STATE_DISCONNECTED);
 }
 break;

 case BTIF_HH_DISCONNECT_REQ_EVT:
 {
            BTIF_TRACE_EVENT("%s: event=%d", __FUNCTION__, event);
            btif_hh_disconnect(bd_addr);
            HAL_CBACK(bt_hh_callbacks, connection_state_cb,bd_addr,BTHH_CONN_STATE_DISCONNECTING);
 }
 break;

 case BTIF_HH_VUP_REQ_EVT:
 {
            BTIF_TRACE_EVENT("%s: event=%d", __FUNCTION__, event);
            ret = btif_hh_virtual_unplug(bd_addr);
 }
 break;

 default:
 {
            BTIF_TRACE_WARNING("%s : Unknown event 0x%x", __FUNCTION__, event);
 }
 break;
 }
}

static int skt_read(int fd, void *p, size_t len)
{
int read;
struct pollfd pfd;
struct timespec ts;

FNLOG();


ts_log("skt_read recv", len, NULL);

    if ((read = recv(fd, p, len, MSG_NOSIGNAL)) == -1)
{
ERROR("write failed with errno=%d\n", errno);
return -1;
}

return read;
}

static int adev_open(const hw_module_t* module, const char* name,
 hw_device_t** device)
{
 struct a2dp_audio_device *adev;
 int ret;

    INFO(" adev_open in A2dp_hw module");
    FNLOG();

 if (strcmp(name, AUDIO_HARDWARE_INTERFACE) != 0)
 {
        ERROR("interface %s not matching [%s]", name, AUDIO_HARDWARE_INTERFACE);
 return -EINVAL;
 }

    adev = calloc(1, sizeof(struct a2dp_audio_device));

 if (!adev)
 return -ENOMEM;

    adev->device.common.tag = HARDWARE_DEVICE_TAG;
    adev->device.common.version = AUDIO_DEVICE_API_VERSION_2_0;
    adev->device.common.module = (struct hw_module_t *) module;
    adev->device.common.close = adev_close;

    adev->device.init_check = adev_init_check;
    adev->device.set_voice_volume = adev_set_voice_volume;
    adev->device.set_master_volume = adev_set_master_volume;
    adev->device.set_mode = adev_set_mode;
    adev->device.set_mic_mute = adev_set_mic_mute;
    adev->device.get_mic_mute = adev_get_mic_mute;
    adev->device.set_parameters = adev_set_parameters;
    adev->device.get_parameters = adev_get_parameters;
    adev->device.get_input_buffer_size = adev_get_input_buffer_size;
    adev->device.open_output_stream = adev_open_output_stream;
    adev->device.close_output_stream = adev_close_output_stream;
    adev->device.open_input_stream = adev_open_input_stream;
    adev->device.close_input_stream = adev_close_input_stream;
    adev->device.dump = adev_dump;

    adev->output = NULL;


 *device = &adev->device.common;

 return 0;
}

static void btif_dm_ble_auth_cmpl_evt (tBTA_DM_AUTH_CMPL *p_auth_cmpl)
{
 /* Save link key, if not temporary */
 bt_bdaddr_t bd_addr;
 bt_status_t status = BT_STATUS_FAIL;
 bt_bond_state_t state = BT_BOND_STATE_NONE;

    bdcpy(bd_addr.address, p_auth_cmpl->bd_addr);
 if ( (p_auth_cmpl->success == TRUE) && (p_auth_cmpl->key_present) )
 {
 /* store keys */
 }
 if (p_auth_cmpl->success)
 {
        status = BT_STATUS_SUCCESS;
        state = BT_BOND_STATE_BONDED;
 int addr_type;
 bt_bdaddr_t bdaddr;
        bdcpy(bdaddr.address, p_auth_cmpl->bd_addr);
 if (btif_storage_get_remote_addr_type(&bdaddr, &addr_type) != BT_STATUS_SUCCESS)
            btif_storage_set_remote_addr_type(&bdaddr, p_auth_cmpl->addr_type);

 /* Test for temporary bonding */
 if (btm_get_bond_type_dev(p_auth_cmpl->bd_addr) == BOND_TYPE_TEMPORARY) {
            BTIF_TRACE_DEBUG("%s: sending BT_BOND_STATE_NONE for Temp pairing",
                             __func__);
            btif_storage_remove_bonded_device(&bdaddr);
            state = BT_BOND_STATE_NONE;
 } else {
            btif_dm_save_ble_bonding_keys();
            BTA_GATTC_Refresh(bd_addr.address);
            btif_dm_get_remote_services_by_transport(&bd_addr, BTA_GATT_TRANSPORT_LE);
 }
 }
 else
 {
 /*Map the HCI fail reason  to  bt status  */
 switch (p_auth_cmpl->fail_reason)
 {
 case BTA_DM_AUTH_SMP_PAIR_AUTH_FAIL:
 case BTA_DM_AUTH_SMP_CONFIRM_VALUE_FAIL:
                btif_dm_remove_ble_bonding_keys();
                status = BT_STATUS_AUTH_FAILURE;
 break;
 case BTA_DM_AUTH_SMP_PAIR_NOT_SUPPORT:
                status = BT_STATUS_AUTH_REJECTED;
 break;
 default:
                btif_dm_remove_ble_bonding_keys();
                status =  BT_STATUS_FAIL;
 break;
 }
 }
    bond_state_changed(status, &bd_addr, state);
}

static int process_cmd_sock(int h)

{
sock_cmd_t cmd = {-1, 0, 0, 0, 0};
int fd = ts[h].cmd_fdr;
    if(recv(fd, &cmd, sizeof(cmd), MSG_WAITALL) != sizeof(cmd))
{
APPL_TRACE_ERROR("recv cmd errno:%d", errno);
return FALSE;
}
APPL_TRACE_DEBUG("cmd.id:%d", cmd.id);
switch(cmd.id)
{
case CMD_ADD_FD:
add_poll(h, cmd.fd, cmd.type, cmd.flags, cmd.user_id);
break;
case CMD_REMOVE_FD:
for (int i = 1; i < MAX_POLL; ++i)
{
poll_slot_t *poll_slot = &ts[h].ps[i];
if (poll_slot->pfd.fd == cmd.fd)
{
remove_poll(h, poll_slot, poll_slot->flags);
break;
}
}
close(cmd.fd);
break;
case CMD_WAKEUP:
break;
case CMD_USER_PRIVATE:
asrt(ts[h].cmd_callback);
if(ts[h].cmd_callback)
ts[h].cmd_callback(fd, cmd.type, cmd.flags, cmd.user_id);
break;
case CMD_EXIT:
return FALSE;
default:
APPL_TRACE_DEBUG("unknown cmd: %d", cmd.id);
break;
}
return TRUE;
}

BOOLEAN btif_hl_find_app_idx_using_mdepId(UINT8 mdep_id, UINT8 *p_app_idx){
    BOOLEAN found=FALSE;
    UINT8 i;

 *p_app_idx = 0;
 for (i=0; i < BTA_HL_NUM_APPS ; i ++)
 {
        BTIF_TRACE_DEBUG("btif_hl_find_app_idx_using_mdepId: MDEP-ID = %d",
                btif_hl_cb.acb[i].sup_feature.mdep[0].mdep_id);
 if (btif_hl_cb.acb[i].in_use &&
 (btif_hl_cb.acb[i].sup_feature.mdep[0].mdep_id == mdep_id))
 {
            found = TRUE;
 *p_app_idx = i;
 break;
 }
 }
    BTIF_TRACE_DEBUG("%s found=%d app_idx=%d", __FUNCTION__, found, i );

 return found;
}

bt_status_t btsock_rfc_init(int poll_thread_handle) {
  pth = poll_thread_handle;

  memset(rfc_slots, 0, sizeof(rfc_slots));
 for (size_t i = 0; i < ARRAY_SIZE(rfc_slots); ++i) {
    rfc_slots[i].scn = -1;
    rfc_slots[i].sdp_handle = 0;
    rfc_slots[i].fd = INVALID_FD;
    rfc_slots[i].app_fd = INVALID_FD;
    rfc_slots[i].incoming_queue = list_new(GKI_freebuf);
    assert(rfc_slots[i].incoming_queue != NULL);
 }

  BTA_JvEnable(jv_dm_cback);

 return BT_STATUS_SUCCESS;
}

static void *sock_poll_thread(void *arg)
{
struct pollfd pfds[MAX_POLL];
memset(pfds, 0, sizeof(pfds));
int h = (intptr_t)arg;

for(;;)
{
prepare_poll_fds(h, pfds);
        int ret = poll(pfds, ts[h].poll_count, -1);
if(ret == -1)
{
APPL_TRACE_ERROR("poll ret -1, exit the thread, errno:%d, err:%s", errno, strerror(errno));
break;
}
if(ret != 0)
{
int need_process_data_fd = TRUE;
if(pfds[0].revents) //cmd fd always is the first one
{
asrt(pfds[0].fd == ts[h].cmd_fdr);
if(!process_cmd_sock(h))
{
APPL_TRACE_DEBUG("h:%d, process_cmd_sock return false, exit...", h);
break;
}
if(ret == 1)
need_process_data_fd = FALSE;
else ret--; //exclude the cmd fd
}
if(need_process_data_fd)
process_data_sock(h, pfds, ret);
}
else {APPL_TRACE_DEBUG("no data, select ret: %d", ret)};
}
ts[h].thread_id = -1;
APPL_TRACE_DEBUG("socket poll thread exiting, h:%d", h);
return 0;
}

static void on_l2cap_write_done(void* req_id, uint32_t id)
{
    l2cap_socket *sock;

 if (req_id != NULL) {
        osi_free(req_id); //free the buffer
 }

    pthread_mutex_lock(&state_lock);
    sock = btsock_l2cap_find_by_id_l(id);
 if (sock && !sock->outgoing_congest) {
        APPL_TRACE_DEBUG("on_l2cap_write_done: adding fd to btsock_thread...");
        btsock_thread_add_fd(pth, sock->our_fd, BTSOCK_L2CAP, SOCK_THREAD_FD_RD, sock->id);
 }
    pthread_mutex_unlock(&state_lock);
}

void btsnoop_net_write(const void *data, size_t length) {
#if (!defined(BT_NET_DEBUG) || (BT_NET_DEBUG != TRUE))
return; // Disable using network sockets for security reasons
#endif


pthread_mutex_lock(&client_socket_lock_);
if (client_socket_ != -1) {
    if (send(client_socket_, data, length, 0) == -1 && errno == ECONNRESET) {
safe_close_(&client_socket_);
}
}
pthread_mutex_unlock(&client_socket_lock_);
}

tBTA_HH_RPT_CACHE_ENTRY * bta_hh_le_co_cache_load (BD_ADDR remote_bda,
                                                   UINT8 *p_num_rpt, UINT8 app_id)
{
    UNUSED(app_id);

 unsigned idx = 0;

 bdstr_t bdstr;
    sprintf(bdstr, "%02x:%02x:%02x:%02x:%02x:%02x",
        remote_bda[0], remote_bda[1], remote_bda[2],
        remote_bda[3], remote_bda[4], remote_bda[5]);

 size_t len = btif_config_get_bin_length(bdstr, "HidReport");
 if (!p_num_rpt && len < sizeof(tBTA_HH_RPT_CACHE_ENTRY))
 return NULL;

 if (len > sizeof(sReportCache))
        len = sizeof(sReportCache);
    btif_config_get_bin(bdstr, "HidReport", (uint8_t *)sReportCache, &len);
 *p_num_rpt = len / sizeof(tBTA_HH_RPT_CACHE_ENTRY);

    BTIF_TRACE_DEBUG("%s() - Loaded %d reports; dev=%s", __FUNCTION__, *p_num_rpt, bdstr);

 return sReportCache;
}

static bt_status_t destroy_channel(int channel_id){
    UINT8 app_idx, mcl_idx, mdl_cfg_idx, mdep_cfg_idx = 0;
 bt_status_t status = BT_STATUS_SUCCESS;
 btif_hl_mdl_cfg_t *p_mdl;
 btif_hl_mcl_cb_t *p_mcb;
 btif_hl_app_cb_t *p_acb;

    CHECK_BTHL_INIT();
    BTIF_TRACE_EVENT("%s channel_id=0x%08x", __FUNCTION__, channel_id);
    btif_hl_display_calling_process_name();


 if (btif_hl_if_channel_setup_pending(channel_id, &app_idx, &mcl_idx))
 {
        btif_hl_dch_abort(app_idx, mcl_idx);
 }
 else
 {
 if (btif_hl_find_mdl_cfg_idx_using_channel_id(channel_id, &app_idx, &mdl_cfg_idx))
 {
            p_acb = BTIF_HL_GET_APP_CB_PTR(app_idx);
 if (!p_acb->delete_mdl.active)
 {
                p_mdl =BTIF_HL_GET_MDL_CFG_PTR(app_idx, mdl_cfg_idx);
                p_acb->delete_mdl.active = TRUE;
                p_acb->delete_mdl.mdl_id = p_mdl->base.mdl_id;
                p_acb->delete_mdl.channel_id = channel_id;
                p_acb->delete_mdl.mdep_cfg_idx = p_mdl->extra.mdep_cfg_idx;
                memcpy(p_acb->delete_mdl.bd_addr, p_mdl->base.peer_bd_addr,sizeof(BD_ADDR));

 if (btif_hl_find_mcl_idx(app_idx, p_mdl->base.peer_bd_addr, &mcl_idx))
 {
                    p_mcb = BTIF_HL_GET_MCL_CB_PTR(app_idx, mcl_idx);
 if (p_mcb->is_connected)
 {
                        BTIF_TRACE_DEBUG("calling BTA_HlDeleteMdl mdl_id=%d",p_acb->delete_mdl.mdl_id );
                        BTA_HlDeleteMdl(p_mcb->mcl_handle, p_acb->delete_mdl.mdl_id);
 }
 else
 {
                        status = BT_STATUS_FAIL;
 }
 }
 else
 {
                    BTIF_TRACE_DEBUG("btif_hl_delete_mdl calling btif_hl_cch_open" );
                    mdep_cfg_idx = p_mdl->extra.mdep_cfg_idx;
                    p_acb->filter.num_elems =1;
                    p_acb->filter.elem[0].data_type = p_acb->sup_feature.mdep[mdep_cfg_idx].mdep_cfg.data_cfg[mdep_cfg_idx].data_type;
 if (p_acb->sup_feature.mdep[mdep_cfg_idx].mdep_cfg.mdep_role == BTA_HL_MDEP_ROLE_SINK)
                        p_acb->filter.elem[0].peer_mdep_role = BTA_HL_MDEP_ROLE_SOURCE;
 else
                        p_acb->filter.elem[0].peer_mdep_role = BTA_HL_MDEP_ROLE_SINK;
 if (btif_hl_cch_open(p_acb->app_id, p_acb->delete_mdl.bd_addr, 0,
                                         mdep_cfg_idx,
                                         BTIF_HL_PEND_DCH_OP_DELETE_MDL, NULL))
 {
                        status = BT_STATUS_FAIL;
 }
 }

 if (  status == BT_STATUS_FAIL)
 {
 /* fail for now  */
                    btif_hl_clean_delete_mdl(&p_acb->delete_mdl);
 }
 }
 else
 {
                status = BT_STATUS_BUSY;
 }
 }
 else
 {
            status = BT_STATUS_FAIL;
 }

 }
 return status;
}

static btif_hh_device_t *btif_hh_find_connected_dev_by_bda(bt_bdaddr_t *bd_addr)
{
    UINT32 i;
 for (i = 0; i < BTIF_HH_MAX_HID; i++) {
 if (btif_hh_cb.devices[i].dev_status == BTHH_CONN_STATE_CONNECTED &&
            memcmp(&(btif_hh_cb.devices[i].bd_addr), bd_addr, BD_ADDR_LEN) == 0)
 {
 return &btif_hh_cb.devices[i];
 }
 }
 return NULL;
}

const char* dump_uipc_event(tUIPC_EVENT event)
{
 switch(event)
 {
        CASE_RETURN_STR(UIPC_OPEN_EVT)
        CASE_RETURN_STR(UIPC_CLOSE_EVT)
        CASE_RETURN_STR(UIPC_RX_DATA_EVT)
        CASE_RETURN_STR(UIPC_RX_DATA_READY_EVT)
        CASE_RETURN_STR(UIPC_TX_DATA_READY_EVT)
 default:
 return "UNKNOWN MSG ID";
 }
}

BOOLEAN UIPC_Send(tUIPC_CH_ID ch_id, UINT16 msg_evt, UINT8 *p_buf,
UINT16 msglen)
{
UNUSED(msg_evt);

BTIF_TRACE_DEBUG("UIPC_Send : ch_id:%d %d bytes", ch_id, msglen);


UIPC_LOCK();

    if (write(uipc_main.ch[ch_id].fd, p_buf, msglen) < 0)
{
BTIF_TRACE_ERROR("failed to write (%s)", strerror(errno));
}

UIPC_UNLOCK();

return FALSE;
}

static BOOLEAN flush_incoming_que_on_wr_signal_l(l2cap_socket *sock)
{
uint8_t *buf;

uint32_t len;

while (packet_get_head_l(sock, &buf, &len)) {
        int sent = send(sock->our_fd, buf, len, MSG_DONTWAIT);

if (sent == (signed)len)
osi_free(buf);
else if (sent >= 0) {
packet_put_head_l(sock, buf + sent, len - sent);
osi_free(buf);
if (!sent) /* special case if other end not keeping up */
return TRUE;
}
else {
packet_put_head_l(sock, buf, len);
osi_free(buf);
return errno == EINTR || errno == EWOULDBLOCK || errno == EAGAIN;
}
}

return FALSE;
}

static void uipc_read_task(void *arg)
{
int ch_id;
int result;
UNUSED(arg);

prctl(PR_SET_NAME, (unsigned long)"uipc-main", 0, 0, 0);

raise_priority_a2dp(TASK_UIPC_READ);

while (uipc_main.running)

{
uipc_main.read_set = uipc_main.active_set;

        result = select(uipc_main.max_fd+1, &uipc_main.read_set, NULL, NULL, NULL);

if (result == 0)
{
BTIF_TRACE_EVENT("select timeout");
continue;
}
else if (result < 0)
{
BTIF_TRACE_EVENT("select failed %s", strerror(errno));
continue;
}

UIPC_LOCK();

/* clear any wakeup interrupt */
uipc_check_interrupt_locked();

/* check pending task events */
uipc_check_task_flags_locked();

/* make sure we service audio channel first */
uipc_check_fd_locked(UIPC_CH_ID_AV_AUDIO);

/* check for other connections */
for (ch_id = 0; ch_id < UIPC_CH_NUM; ch_id++)
{
if (ch_id != UIPC_CH_ID_AV_AUDIO)
uipc_check_fd_locked(ch_id);
}

UIPC_UNLOCK();
}

BTIF_TRACE_EVENT("UIPC READ THREAD EXITING");

uipc_main_cleanup();

uipc_main.tid = 0;

BTIF_TRACE_EVENT("UIPC READ THREAD DONE");
}

int sock_send_fd(int sock_fd, const uint8_t* buf, int len, int send_fd)
{
ssize_t ret;
struct msghdr msg;
unsigned char *buffer = (unsigned char *)buf;
memset(&msg, 0, sizeof(msg));

struct cmsghdr *cmsg;
char msgbuf[CMSG_SPACE(1)];
asrt(send_fd != -1);
if(sock_fd == -1 || send_fd == -1)
return -1;
// Add any pending outbound file descriptors to the message
// See "man cmsg" really
msg.msg_control = msgbuf;
msg.msg_controllen = sizeof msgbuf;
cmsg = CMSG_FIRSTHDR(&msg);
cmsg->cmsg_level = SOL_SOCKET;
cmsg->cmsg_type = SCM_RIGHTS;
cmsg->cmsg_len = CMSG_LEN(sizeof send_fd);
memcpy(CMSG_DATA(cmsg), &send_fd, sizeof send_fd);

// We only write our msg_control during the first write
int ret_len = len;
while (len > 0) {
struct iovec iv;
memset(&iv, 0, sizeof(iv));

iv.iov_base = buffer;
iv.iov_len = len;

msg.msg_iov = &iv;

msg.msg_iovlen = 1;

do {
            ret = sendmsg(sock_fd, &msg, MSG_NOSIGNAL);
} while (ret < 0 && errno == EINTR);

if (ret < 0) {
BTIF_TRACE_ERROR("fd:%d, send_fd:%d, sendmsg ret:%d, errno:%d, %s",
sock_fd, send_fd, (int)ret, errno, strerror(errno));
ret_len = -1;
break;
}

buffer += ret;
len -= ret;

// Wipes out any msg_control too
memset(&msg, 0, sizeof(msg));
}
BTIF_TRACE_DEBUG("close fd:%d after sent", send_fd);
// TODO: This seems wrong - if the FD is not opened in JAVA before this is called
//       we get a "socket closed" exception in java, when reading from the socket...
close(send_fd);
return ret_len;
}

tBTA_SERVICE_MASK btif_get_enabled_services_mask(void)
{
 return btif_enabled_services;
}

bt_status_t btsock_l2cap_init(int handle)
{
    APPL_TRACE_DEBUG("btsock_l2cap_init...");
    pthread_mutex_lock(&state_lock);
    pth = handle;
    socks = NULL;
    pthread_mutex_unlock(&state_lock);

 return BT_STATUS_SUCCESS;
}

static void btif_dm_ble_key_nc_req_evt(tBTA_DM_SP_KEY_NOTIF *p_notif_req)
{
 /* TODO implement key notification for numeric comparison */
    BTIF_TRACE_DEBUG("%s", __FUNCTION__);

 /* Remote name update */
    btif_update_remote_properties(p_notif_req->bd_addr , p_notif_req->bd_name,
                                          NULL, BT_DEVICE_TYPE_BLE);

 bt_bdaddr_t bd_addr;
    bdcpy(bd_addr.address, p_notif_req->bd_addr);

 bt_bdname_t bd_name;
    memcpy(bd_name.name, p_notif_req->bd_name, BD_NAME_LEN);

    bond_state_changed(BT_STATUS_SUCCESS, &bd_addr, BT_BOND_STATE_BONDING);
    pairing_cb.is_ssp = FALSE;
    pairing_cb.is_le_only = TRUE;
    pairing_cb.is_le_nc = TRUE;

    HAL_CBACK(bt_hal_cbacks, ssp_request_cb, &bd_addr, &bd_name,
              COD_UNCLASSIFIED, BT_SSP_VARIANT_PASSKEY_CONFIRMATION,
              p_notif_req->passkey);
}

static void toggle_os_keylockstates(int fd, int changedlockstates)
{
BTIF_TRACE_EVENT("%s: fd = %d, changedlockstates = 0x%x",
__FUNCTION__, fd, changedlockstates);
UINT8 hidreport[9];
int reportIndex;
memset(hidreport,0,9);
hidreport[0]=1;
reportIndex=4;

if (changedlockstates & BTIF_HH_KEYSTATE_MASK_CAPSLOCK) {
BTIF_TRACE_DEBUG("%s Setting CAPSLOCK", __FUNCTION__);
hidreport[reportIndex++] = (UINT8)HID_REPORT_CAPSLOCK;
}

if (changedlockstates & BTIF_HH_KEYSTATE_MASK_NUMLOCK) {
BTIF_TRACE_DEBUG("%s Setting NUMLOCK", __FUNCTION__);
hidreport[reportIndex++] = (UINT8)HID_REPORT_NUMLOCK;
}

if (changedlockstates & BTIF_HH_KEYSTATE_MASK_SCROLLLOCK) {
BTIF_TRACE_DEBUG("%s Setting SCROLLLOCK", __FUNCTION__);
hidreport[reportIndex++] = (UINT8) HID_REPORT_SCROLLLOCK;
}

BTIF_TRACE_DEBUG("Writing hidreport #1 to os: "\
"%s:  %x %x %x", __FUNCTION__,
hidreport[0], hidreport[1], hidreport[2]);
BTIF_TRACE_DEBUG("%s:  %x %x %x", __FUNCTION__,
hidreport[3], hidreport[4], hidreport[5]);

BTIF_TRACE_DEBUG("%s:  %x %x %x", __FUNCTION__,
hidreport[6], hidreport[7], hidreport[8]);
bta_hh_co_write(fd , hidreport, sizeof(hidreport));
    usleep(200000);
memset(hidreport,0,9);
hidreport[0]=1;
BTIF_TRACE_DEBUG("Writing hidreport #2 to os: "\
"%s:  %x %x %x", __FUNCTION__,
hidreport[0], hidreport[1], hidreport[2]);
BTIF_TRACE_DEBUG("%s:  %x %x %x", __FUNCTION__,
hidreport[3], hidreport[4], hidreport[5]);
BTIF_TRACE_DEBUG("%s:  %x %x %x ", __FUNCTION__,
hidreport[6], hidreport[7], hidreport[8]);
bta_hh_co_write(fd , hidreport, sizeof(hidreport));
}

config_t *config_new(const char *filename) {
  assert(filename != NULL);

 config_t *config = config_new_empty();
 if (!config)
 return NULL;

 FILE *fp = fopen(filename, "rt");
 if (!fp) {
    LOG_ERROR("%s unable to open file '%s': %s", __func__, filename, strerror(errno));
    config_free(config);
 return NULL;
 }
  config_parse(fp, config);
  fclose(fp);
 return config;
}

BOOLEAN btif_hl_if_channel_setup_pending(int channel_id, UINT8 *p_app_idx, UINT8 *p_mcl_idx)
{
 btif_hl_app_cb_t *p_acb;
 btif_hl_mcl_cb_t *p_mcb;
    UINT8 i, j;
    BOOLEAN found=FALSE;

 *p_app_idx = 0;
 *p_mcl_idx = 0;
 for (i=0; i < BTA_HL_NUM_APPS ; i ++)
 {
        p_acb  =BTIF_HL_GET_APP_CB_PTR(i);
 if (p_acb->in_use)
 {
 for (j=0; j< BTA_HL_NUM_MCLS; j++)
 {
                p_mcb = BTIF_HL_GET_MCL_CB_PTR(i, j);
 if (p_mcb->in_use &&
                    p_mcb->is_connected && p_mcb->pcb.channel_id == channel_id )
 {
                    found = TRUE;
 *p_app_idx = i;
 *p_mcl_idx = j;
 break;
 }
 }
 }
 if (found)
 break;
 }
    BTIF_TRACE_DEBUG("%s found=%d channel_id=0x%08x",
                      __FUNCTION__, found, channel_id, *p_app_idx, *p_mcl_idx);
 return found;

}

void config_set_bool(config_t *config, const char *section, const char *key, bool value) {
  assert(config != NULL);
  assert(section != NULL);
  assert(key != NULL);

  config_set_string(config, section, key, value ? "true" : "false");
}

static void unregister_cb(void *context) {
 unregister_arg_t *arg = (unregister_arg_t *)context;
  reactor_unregister(arg->object);
  reactor_stop(arg->reactor);
}

static void btpan_tap_fd_signaled(int fd, int type, int flags, uint32_t user_id) {
    assert(btpan_cb.tap_fd == INVALID_FD || btpan_cb.tap_fd == fd);

 if (btpan_cb.tap_fd != fd) {
        BTIF_TRACE_WARNING("%s Signaled on mismatched fds exp:%d act:%d\n",
                __func__, btpan_cb.tap_fd, fd);
 return;
 }

 if (flags & SOCK_THREAD_FD_EXCEPTION) {
        btpan_cb.tap_fd = INVALID_FD;
        btpan_tap_close(fd);
        btif_pan_close_all_conns();
 } else if (flags & SOCK_THREAD_FD_RD)
        bta_dmexecutecallback(btu_exec_tap_fd_read, (void *)fd);
}

void socket_register(socket_t *socket, reactor_t *reactor, void *context, socket_cb read_cb, socket_cb write_cb) {
  assert(socket != NULL);

  socket_unregister(socket);

  socket->read_ready = read_cb;
  socket->write_ready = write_cb;
  socket->context = context;

 void (*read_fn)(void *) = (read_cb != NULL) ? internal_read_ready : NULL;
 void (*write_fn)(void *) = (write_cb != NULL) ? internal_write_ready : NULL;

  socket->reactor_object = reactor_register(reactor, socket->fd, socket, read_fn, write_fn);
}

static void on_l2cap_connect(tBTA_JV *p_data, uint32_t id)
{
    l2cap_socket *sock;
    tBTA_JV_L2CAP_OPEN *psm_open = &p_data->l2c_open;
    tBTA_JV_L2CAP_LE_OPEN *le_open = &p_data->l2c_le_open;

    pthread_mutex_lock(&state_lock);
    sock = btsock_l2cap_find_by_id_l(id);
 if (!sock) {
        APPL_TRACE_ERROR("on_l2cap_connect on unknown socket");
 } else {
 if (sock->fixed_chan && le_open->status == BTA_JV_SUCCESS) {
 if (!sock->server)
                on_cl_l2cap_le_connect_l(le_open, sock);
 else
                on_srv_l2cap_le_connect_l(le_open, sock);
 } else if (!sock->fixed_chan && psm_open->status == BTA_JV_SUCCESS) {
 if (!sock->server)
                on_cl_l2cap_psm_connect_l(psm_open, sock);
 else
                on_srv_l2cap_psm_connect_l(psm_open, sock);
 }
 else
            btsock_l2cap_free_l(sock);
 }
    pthread_mutex_unlock(&state_lock);
}

int btsock_thread_exit(int h)
{
if(h < 0 || h >= MAX_THREAD)
{
APPL_TRACE_ERROR("invalid bt thread handle:%d", h);
return FALSE;
}
if(ts[h].cmd_fdw == -1)
{
APPL_TRACE_ERROR("cmd socket is not created");

return FALSE;
}
sock_cmd_t cmd = {CMD_EXIT, 0, 0, 0, 0};
    if(send(ts[h].cmd_fdw, &cmd, sizeof(cmd), 0) == sizeof(cmd))
{
pthread_join(ts[h].thread_id, 0);
pthread_mutex_lock(&thread_slot_lock);
free_thread_slot(h);
pthread_mutex_unlock(&thread_slot_lock);
return TRUE;
}
return FALSE;
}

static bt_status_t btpan_jni_init(const btpan_callbacks_t* callbacks)
{
    BTIF_TRACE_DEBUG("stack_initialized = %d, btpan_cb.enabled:%d", stack_initialized, btpan_cb.enabled);
    callback = *callbacks;
    jni_initialized = TRUE;
 if (stack_initialized && !btpan_cb.enabled)
        btif_pan_init();
 return BT_STATUS_SUCCESS;
}

void btif_dm_execute_service_request(UINT16 event, char *p_param)
{
    BOOLEAN b_enable = FALSE;
 bt_status_t status;
 if (event == BTIF_DM_ENABLE_SERVICE)
 {
        b_enable = TRUE;
 }
    status = btif_in_execute_service_request(*((tBTA_SERVICE_ID*)p_param), b_enable);
 if (status == BT_STATUS_SUCCESS)
 {
 bt_property_t property;
 bt_uuid_t local_uuids[BT_MAX_NUM_UUIDS];

 /* Now send the UUID_PROPERTY_CHANGED event to the upper layer */
        BTIF_STORAGE_FILL_PROPERTY(&property, BT_PROPERTY_UUIDS,
 sizeof(local_uuids), local_uuids);
        btif_storage_get_adapter_property(&property);
        HAL_CBACK(bt_hal_cbacks, adapter_properties_cb,
                          BT_STATUS_SUCCESS, 1, &property);
 }
 return;
}

static void hal_says_data_ready(serial_data_type_t type) {
 packet_receive_data_t *incoming = &incoming_packets[PACKET_TYPE_TO_INBOUND_INDEX(type)];

 uint8_t byte;
 while (hal->read_data(type, &byte, 1, false) != 0) {
 switch (incoming->state) {
 case BRAND_NEW:
        incoming->bytes_remaining = preamble_sizes[PACKET_TYPE_TO_INDEX(type)];
        memset(incoming->preamble, 0, PREAMBLE_BUFFER_SIZE);
        incoming->index = 0;
        incoming->state = PREAMBLE;
 case PREAMBLE:
        incoming->preamble[incoming->index] = byte;
        incoming->index++;
        incoming->bytes_remaining--;

 if (incoming->bytes_remaining == 0) {
          incoming->bytes_remaining = (type == DATA_TYPE_ACL) ? RETRIEVE_ACL_LENGTH(incoming->preamble) : byte;

 size_t buffer_size = BT_HDR_SIZE + incoming->index + incoming->bytes_remaining;
          incoming->buffer = (BT_HDR *)buffer_allocator->alloc(buffer_size);

 if (!incoming->buffer) {
            LOG_ERROR("%s error getting buffer for incoming packet of type %d and size %zd", __func__, type, buffer_size);
            incoming->state = incoming->bytes_remaining == 0 ? BRAND_NEW : IGNORE;
 break;
 }

          incoming->buffer->offset = 0;
          incoming->buffer->layer_specific = 0;
          incoming->buffer->event = outbound_event_types[PACKET_TYPE_TO_INDEX(type)];
          memcpy(incoming->buffer->data, incoming->preamble, incoming->index);

          incoming->state = incoming->bytes_remaining > 0 ? BODY : FINISHED;
 }

 break;
 case BODY:
        incoming->buffer->data[incoming->index] = byte;
        incoming->index++;
        incoming->bytes_remaining--;

 size_t bytes_read = hal->read_data(type, (incoming->buffer->data + incoming->index), incoming->bytes_remaining, false);
        incoming->index += bytes_read;
        incoming->bytes_remaining -= bytes_read;

        incoming->state = incoming->bytes_remaining == 0 ? FINISHED : incoming->state;
 break;
 case IGNORE:
        incoming->bytes_remaining--;
 if (incoming->bytes_remaining == 0) {
          incoming->state = BRAND_NEW;
          hal->packet_finished(type);
 return;
 }

 break;
 case FINISHED:
        LOG_ERROR("%s the state machine should not have been left in the finished state.", __func__);
 break;
 }

 if (incoming->state == FINISHED) {
      incoming->buffer->len = incoming->index;
      btsnoop->capture(incoming->buffer, true);

 if (type != DATA_TYPE_EVENT) {
        packet_fragmenter->reassemble_and_dispatch(incoming->buffer);
 } else if (!filter_incoming_event(incoming->buffer)) {
 uint8_t *stream = incoming->buffer->data;
 uint8_t event_code;
        STREAM_TO_UINT8(event_code, stream);

        data_dispatcher_dispatch(
          interface.event_dispatcher,
          event_code,
          incoming->buffer
 );
 }

      incoming->buffer = NULL;
      incoming->state = BRAND_NEW;
      hal->packet_finished(type);

 return;
 }
 }
}

void reactor_unregister(reactor_object_t *obj) {
  assert(obj != NULL);

 reactor_t *reactor = obj->reactor;

 if (epoll_ctl(reactor->epoll_fd, EPOLL_CTL_DEL, obj->fd, NULL) == -1)
    LOG_ERROR("%s unable to unregister fd %d from epoll set: %s", __func__, obj->fd, strerror(errno));

 if (reactor->is_running && pthread_equal(pthread_self(), reactor->run_thread)) {
    reactor->object_removed = true;
 return;
 }

  pthread_mutex_lock(&reactor->list_lock);
  list_append(reactor->invalidation_list, obj);
  pthread_mutex_unlock(&reactor->list_lock);

  pthread_mutex_lock(&obj->lock);
  pthread_mutex_unlock(&obj->lock);
  pthread_mutex_destroy(&obj->lock);
  osi_free(obj);
}

void btif_hh_tmr_hdlr(TIMER_LIST_ENT *tle)
{
 btif_hh_device_t *p_dev;
    UINT8               i;
    tBTA_HH_EVT event;
    tBTA_HH p_data;
 int param_len = 0;
    memset(&p_data, 0, sizeof(tBTA_HH));

    BTIF_TRACE_DEBUG("%s timer_in_use=%d",  __FUNCTION__, tle->in_use );

 for (i = 0; i < BTIF_HH_MAX_HID; i++) {
 if (btif_hh_cb.devices[i].dev_status == BTHH_CONN_STATE_CONNECTED)
 {

            p_dev = &btif_hh_cb.devices[i];

 if (p_dev->vup_timer_active)
 {
                p_dev->vup_timer_active = FALSE;
                event = BTA_HH_VC_UNPLUG_EVT;
                p_data.dev_status.status = BTHH_ERR;
                p_data.dev_status.handle = p_dev->dev_handle;
                param_len = sizeof(tBTA_HH_CBDATA);

 /* switch context to btif task context */
                btif_transfer_context(btif_hh_upstreams_evt, (uint16_t)event, (void*)&p_data,
                            param_len, NULL);
 }
 }
 }
}

static int out_add_audio_effect(const struct audio_stream *stream, effect_handle_t effect)
{
    UNUSED(stream);
    UNUSED(effect);

    FNLOG();
 return 0;
}

BOOLEAN btif_hh_add_added_dev(bt_bdaddr_t bda, tBTA_HH_ATTR_MASK attr_mask)
{
 int i;
 for (i = 0; i < BTIF_HH_MAX_ADDED_DEV; i++) {
 if (memcmp(&(btif_hh_cb.added_devices[i].bd_addr), &bda, BD_ADDR_LEN) == 0) {
            BTIF_TRACE_WARNING(" Device %02X:%02X:%02X:%02X:%02X:%02X already added",
                  bda.address[0], bda.address[1], bda.address[2], bda.address[3], bda.address[4], bda.address[5]);
 return FALSE;
 }
 }
 for (i = 0; i < BTIF_HH_MAX_ADDED_DEV; i++) {
 if (btif_hh_cb.added_devices[i].bd_addr.address[0] == 0 &&
            btif_hh_cb.added_devices[i].bd_addr.address[1] == 0 &&
            btif_hh_cb.added_devices[i].bd_addr.address[2] == 0 &&
            btif_hh_cb.added_devices[i].bd_addr.address[3] == 0 &&
            btif_hh_cb.added_devices[i].bd_addr.address[4] == 0 &&
            btif_hh_cb.added_devices[i].bd_addr.address[5] == 0)
 {
            BTIF_TRACE_WARNING(" Added device %02X:%02X:%02X:%02X:%02X:%02X",
                  bda.address[0], bda.address[1], bda.address[2], bda.address[3], bda.address[4], bda.address[5]);
            memcpy(&(btif_hh_cb.added_devices[i].bd_addr), &bda, BD_ADDR_LEN);
            btif_hh_cb.added_devices[i].dev_handle = BTA_HH_INVALID_HANDLE;
            btif_hh_cb.added_devices[i].attr_mask  = attr_mask;
 return TRUE;
 }
 }

    BTIF_TRACE_WARNING("%s: Error, out of space to add device",__FUNCTION__);
 return FALSE;
}

static uint32_t on_srv_rfc_connect(tBTA_JV_RFCOMM_SRV_OPEN *p_open, uint32_t id) {
 uint32_t new_listen_slot_id = 0;
  pthread_mutex_lock(&slot_lock);

 rfc_slot_t *srv_rs = find_rfc_slot_by_id(id);
 if (!srv_rs)
 goto out;

 rfc_slot_t *accept_rs = create_srv_accept_rfc_slot(srv_rs, (const bt_bdaddr_t *)p_open->rem_bda, p_open->handle, p_open->new_listen_handle);
 if (!accept_rs)
 goto out;

  btsock_thread_add_fd(pth, srv_rs->fd, BTSOCK_RFCOMM, SOCK_THREAD_FD_EXCEPTION, srv_rs->id);
  btsock_thread_add_fd(pth, accept_rs->fd, BTSOCK_RFCOMM, SOCK_THREAD_FD_RD, accept_rs->id);
  send_app_connect_signal(srv_rs->fd, &accept_rs->addr, srv_rs->scn, 0, accept_rs->app_fd);
  accept_rs->app_fd = INVALID_FD; // Ownership of the application fd has been transferred.
  new_listen_slot_id = srv_rs->id;

out:;
  pthread_mutex_unlock(&slot_lock);
 return new_listen_slot_id;
}

static uint32_t out_get_latency(const struct audio_stream_out *stream)
{
 int latency_us;

 struct a2dp_stream_out *out = (struct a2dp_stream_out *)stream;

    FNLOG();

    latency_us = ((out->common.buffer_sz * 1000 ) /
                    audio_stream_out_frame_size(&out->stream) /
                    out->common.cfg.rate) * 1000;


 return (latency_us / 1000) + 200;
}

void btif_hh_start_vup_timer(bt_bdaddr_t *bd_addr)
{
 btif_hh_device_t *p_dev  = btif_hh_find_connected_dev_by_bda(bd_addr);

 if (p_dev->vup_timer_active == FALSE)
 {
        BTIF_TRACE_DEBUG("Start VUP timer ");
        memset(&p_dev->vup_timer, 0, sizeof(TIMER_LIST_ENT));
        p_dev->vup_timer.param = (UINT32)btif_hh_tmr_hdlr;
        btu_start_timer(&p_dev->vup_timer, BTU_TTYPE_USER_FUNC,
                        BTIF_TIMEOUT_VUP_SECS);
 }
 else
 {
        BTIF_TRACE_DEBUG("Restart VUP timer ");
        btu_stop_timer(&p_dev->vup_timer);
        btu_start_timer(&p_dev->vup_timer, BTU_TTYPE_USER_FUNC,
                        BTIF_TIMEOUT_VUP_SECS);
 }
        p_dev->vup_timer_active = TRUE;

}

void bta_hh_co_send_hid_info(btif_hh_device_t *p_dev, char *dev_name, UINT16 vendor_id,
                             UINT16 product_id, UINT16 version, UINT8 ctry_code,
 int dscp_len, UINT8 *p_dscp)
{
 int result;
 struct uhid_event ev;

 if (p_dev->fd < 0) {
        APPL_TRACE_WARNING("%s: Error: fd = %d, dscp_len = %d", __FUNCTION__, p_dev->fd, dscp_len);
 return;
 }

    APPL_TRACE_WARNING("%s: fd = %d, name = [%s], dscp_len = %d", __FUNCTION__,
                                                                    p_dev->fd, dev_name, dscp_len);
    APPL_TRACE_WARNING("%s: vendor_id = 0x%04x, product_id = 0x%04x, version= 0x%04x,"
 "ctry_code=0x%02x",__FUNCTION__,
                                                                    vendor_id, product_id,
                                                                    version, ctry_code);

    memset(&ev, 0, sizeof(ev));
    ev.type = UHID_CREATE;
    strncpy((char*)ev.u.create.name, dev_name, sizeof(ev.u.create.name) - 1);
    snprintf((char*)ev.u.create.uniq, sizeof(ev.u.create.uniq),
 "%2.2X:%2.2X:%2.2X:%2.2X:%2.2X:%2.2X",
             p_dev->bd_addr.address[5], p_dev->bd_addr.address[4],
             p_dev->bd_addr.address[3], p_dev->bd_addr.address[2],
             p_dev->bd_addr.address[1], p_dev->bd_addr.address[0]);
    ev.u.create.rd_size = dscp_len;
    ev.u.create.rd_data = p_dscp;
    ev.u.create.bus = BUS_BLUETOOTH;
    ev.u.create.vendor = vendor_id;
    ev.u.create.product = product_id;
    ev.u.create.version = version;
    ev.u.create.country = ctry_code;
    result = uhid_write(p_dev->fd, &ev);

    APPL_TRACE_WARNING("%s: wrote descriptor to fd = %d, dscp_len = %d, result = %d", __FUNCTION__,
                                                                    p_dev->fd, dscp_len, result);

 if (result) {
        APPL_TRACE_WARNING("%s: Error: failed to send DSCP, result = %d", __FUNCTION__, result);

 /* The HID report descriptor is corrupted. Close the driver. */
        close(p_dev->fd);
        p_dev->fd = -1;
 }
}

BOOLEAN btif_hl_cch_open(UINT8 app_id, BD_ADDR bd_addr, UINT16 ctrl_psm,
 int mdep_cfg_idx,
 btif_hl_pend_dch_op_t op, int *channel_id){

 btif_hl_app_cb_t *p_acb;
 btif_hl_mcl_cb_t *p_mcb;
 btif_hl_pending_chan_cb_t *p_pcb;
    UINT8                       app_idx, mcl_idx;
    BOOLEAN                     status = TRUE;

    BTIF_TRACE_DEBUG("%s app_id=%d ctrl_psm=%d mdep_cfg_idx=%d op=%d",
                      __FUNCTION__, app_id, ctrl_psm, mdep_cfg_idx, op);
    BTIF_TRACE_DEBUG("DB [%02x:%02x:%02x:%02x:%02x:%02x]",
                      bd_addr[0],  bd_addr[1],bd_addr[2],  bd_addr[3], bd_addr[4],  bd_addr[5]);

 if (btif_hl_find_app_idx(app_id, &app_idx))
 {
        p_acb = BTIF_HL_GET_APP_CB_PTR(app_idx);

 if (!btif_hl_find_mcl_idx(app_idx, bd_addr, &mcl_idx))
 {
 if (btif_hl_find_avail_mcl_idx(app_idx, &mcl_idx))
 {
                p_mcb = BTIF_HL_GET_MCL_CB_PTR(app_idx, mcl_idx);
                memset(p_mcb,0, sizeof(btif_hl_mcl_cb_t));
                p_mcb->in_use = TRUE;
                bdcpy(p_mcb->bd_addr, bd_addr);

 if (!ctrl_psm)
 {
                    p_mcb->cch_oper = BTIF_HL_CCH_OP_MDEP_FILTERING;
 }
 else
 {
                    p_mcb->cch_oper        = BTIF_HL_CCH_OP_MATCHED_CTRL_PSM;
                    p_mcb->req_ctrl_psm    = ctrl_psm;
 }

                p_pcb = BTIF_HL_GET_PCB_PTR(app_idx, mcl_idx);
                p_pcb->in_use = TRUE;
                p_pcb->mdep_cfg_idx = mdep_cfg_idx;
                memcpy(p_pcb->bd_addr, bd_addr, sizeof(BD_ADDR));
                p_pcb->op = op;

 switch (op)
 {
 case BTIF_HL_PEND_DCH_OP_OPEN:
 *channel_id       =
                        p_pcb->channel_id = (int) btif_hl_get_next_channel_id(app_id);
                        p_pcb->cb_state = BTIF_HL_CHAN_CB_STATE_CONNECTING_PENDING;
 break;
 case BTIF_HL_PEND_DCH_OP_DELETE_MDL:
                        p_pcb->channel_id =  p_acb->delete_mdl.channel_id;
                        p_pcb->cb_state = BTIF_HL_CHAN_CB_STATE_DESTROYED_PENDING;
 break;
 default:
 break;
 }
                BTA_HlSdpQuery(app_id,p_acb->app_handle, bd_addr);
 }
 else
 {
                status = FALSE;
                BTIF_TRACE_ERROR("Open CCH request discarded- No mcl cb");
 }
 }
 else
 {
            status = FALSE;
            BTIF_TRACE_ERROR("Open CCH request discarded- already in USE");
 }
 }
 else
 {
        status = FALSE;
        BTIF_TRACE_ERROR("Invalid app_id=%d", app_id);
 }

 if (channel_id)
 {
        BTIF_TRACE_DEBUG("status=%d channel_id=0x%08x", status, *channel_id);
 }
 else
 {
        BTIF_TRACE_DEBUG("status=%d ", status);
 }
 return status;
}

static void msleep(uint64_t ms) {
  usleep(ms * 1000);
}

void btif_hl_send_setup_connecting_cb(UINT8 app_idx, UINT8 mcl_idx){
 btif_hl_pending_chan_cb_t *p_pcb = BTIF_HL_GET_PCB_PTR(app_idx, mcl_idx);
 bt_bdaddr_t                 bd_addr;
 int                         app_id = (int) btif_hl_get_app_id(p_pcb->channel_id);

    btif_hl_copy_bda(&bd_addr, p_pcb->bd_addr);

 if (p_pcb->in_use && p_pcb->cb_state == BTIF_HL_CHAN_CB_STATE_CONNECTING_PENDING)
 {
        BTIF_TRACE_DEBUG("%s",__FUNCTION__);
        BTIF_TRACE_DEBUG("call channel state callback  channel_id=0x%08x mdep_cfg_idx=%d state=%d fd=%d",p_pcb->channel_id,
                          p_pcb->mdep_cfg_idx, BTHL_CONN_STATE_CONNECTING, 0);
        btif_hl_display_bt_bda(&bd_addr);

        BTIF_HL_CALL_CBACK(bt_hl_callbacks, channel_state_cb, app_id,
 &bd_addr, p_pcb->mdep_cfg_idx,
                           p_pcb->channel_id, BTHL_CONN_STATE_CONNECTING, 0 );
        btif_hl_set_chan_cb_state(app_idx, mcl_idx, BTIF_HL_CHAN_CB_STATE_CONNECTED_PENDING);
 }
}

static void bta_pan_callback(tBTA_PAN_EVT event, tBTA_PAN *p_data)
{
    btif_transfer_context(bta_pan_callback_transfer, event, (char*)p_data, sizeof(tBTA_PAN), NULL);
}

int bta_hh_co_write(int fd, UINT8* rpt, UINT16 len)
{
    APPL_TRACE_DEBUG("%s: UHID write %d", __func__, len);

 struct uhid_event ev;
    memset(&ev, 0, sizeof(ev));
    ev.type = UHID_INPUT;
    ev.u.input.size = len;
 if(len > sizeof(ev.u.input.data)){
        APPL_TRACE_WARNING("%s: Report size greater than allowed size",
                           __FUNCTION__);
 return -1;
 }
    memcpy(ev.u.input.data, rpt, len);

 return uhid_write(fd, &ev);

}

static size_t adev_get_input_buffer_size(const struct audio_hw_device *dev,
 const struct audio_config *config)
{
    UNUSED(dev);
    UNUSED(config);

    FNLOG();

 return 320;
}

static inline unsigned int flags2pevents(int flags)
{
 unsigned int pevents = 0;
 if(flags & SOCK_THREAD_FD_WR)
        pevents |= POLLOUT;
 if(flags & SOCK_THREAD_FD_RD)
        pevents |= POLLIN;
    pevents |= POLL_EXCEPTION_EVENTS;
 return pevents;
}

static void btif_hl_init_next_app_id(void){
    btif_hl_cb.next_app_id = 1;
}

static section_t *section_find(const config_t *config, const char *section) {
 for (const list_node_t *node = list_begin(config->sections); node != list_end(config->sections); node = list_next(node)) {
 section_t *sec = list_node(node);
 if (!strcmp(sec->name, section))
 return sec;
 }

 return NULL;
}

static void btif_hl_proc_cch_close_cfm(tBTA_HL *p_data)
{
    BTIF_TRACE_DEBUG("%s", __FUNCTION__);

    btif_hl_clean_mcb_using_handle(p_data->cch_close_ind.mcl_handle);
}

static void bte_dm_remote_service_record_evt(tBTA_DM_SEARCH_EVT event, tBTA_DM_SEARCH *p_data)
{
 /* TODO: The only member that needs a deep copy is the p_raw_data. But not sure yet if this is needed. */
   btif_transfer_context(btif_dm_remote_service_record_evt, event, (char*)p_data, sizeof(tBTA_DM_SEARCH), NULL);
}

static void cb(UNUSED_ATTR void *data) {
 ++cb_counter;
  semaphore_post(semaphore);
}

static int suspend_audio_datapath(struct a2dp_stream_common *common, bool standby)
{
    INFO("state %d", common->state);

 if (common->ctrl_fd == AUDIO_SKT_DISCONNECTED)
 return -1;

 if (common->state == AUDIO_A2DP_STATE_STOPPING)
 return -1;

 if (a2dp_command(common, A2DP_CTRL_CMD_SUSPEND) < 0)
 return -1;

 if (standby)
        common->state = AUDIO_A2DP_STATE_STANDBY;
 else
        common->state = AUDIO_A2DP_STATE_SUSPENDED;

 /* disconnect audio path */
    skt_disconnect(common->audio_fd);

    common->audio_fd = AUDIO_SKT_DISCONNECTED;

 return 0;
}

void btif_hh_disconnect(bt_bdaddr_t *bd_addr)
{
 btif_hh_device_t *p_dev;
    p_dev = btif_hh_find_connected_dev_by_bda(bd_addr);
 if (p_dev != NULL)
 {
        BTA_HhClose(p_dev->dev_handle);
 }
 else
        BTIF_TRACE_DEBUG("%s-- Error: device not connected:",__FUNCTION__);
}

BOOLEAN btif_hl_find_avail_mcl_idx(UINT8 app_idx, UINT8 *p_mcl_idx){
    BOOLEAN found=FALSE;
    UINT8 i;

 for (i=0; i < BTA_HL_NUM_MCLS ; i ++)
 {
 if (!btif_hl_cb.acb[app_idx].mcb[i].in_use)
 {
            found = TRUE;
 *p_mcl_idx = i;
 break;
 }
 }
    BTIF_TRACE_DEBUG("%s found=%d mcl_idx=%d", __FUNCTION__, found, i);
 return found;
}

static void config_parse(FILE *fp, config_t *config) {
  assert(fp != NULL);
  assert(config != NULL);

 int line_num = 0;
 char line[1024];
 char section[1024];
  strcpy(section, CONFIG_DEFAULT_SECTION);

 while (fgets(line, sizeof(line), fp)) {
 char *line_ptr = trim(line);
 ++line_num;

 if (*line_ptr == '\0' || *line_ptr == '#')
 continue;

 if (*line_ptr == '[') {
 size_t len = strlen(line_ptr);
 if (line_ptr[len - 1] != ']') {
        LOG_DEBUG("%s unterminated section name on line %d.", __func__, line_num);
 continue;
 }
      strncpy(section, line_ptr + 1, len - 2);
      section[len - 2] = '\0';
 } else {
 char *split = strchr(line_ptr, '=');
 if (!split) {
        LOG_DEBUG("%s no key/value separator found on line %d.", __func__, line_num);
 continue;
 }

 *split = '\0';
      config_set_string(config, section, trim(line_ptr), trim(split + 1));
 }
 }
}

void handle_rc_passthrough_rsp ( tBTA_AV_REMOTE_RSP *p_remote_rsp)
{
#if (AVRC_CTLR_INCLUDED == TRUE)
 const char *status;
 if (btif_rc_cb.rc_features & BTA_AV_FEAT_RCTG)
 {
 int key_state;
 if (p_remote_rsp->key_state == AVRC_STATE_RELEASE)
 {
            status = "released";
            key_state = 1;
 }
 else
 {
            status = "pressed";
            key_state = 0;
 }

        BTIF_TRACE_DEBUG("%s: rc_id=%d status=%s", __FUNCTION__, p_remote_rsp->rc_id, status);

        release_transaction(p_remote_rsp->label);
 if (bt_rc_ctrl_callbacks != NULL) {
            HAL_CBACK(bt_rc_ctrl_callbacks, passthrough_rsp_cb, p_remote_rsp->rc_id, key_state);
 }
 }
 else
 {
        BTIF_TRACE_ERROR("%s DUT does not support AVRCP controller role", __FUNCTION__);
 }
#else
    BTIF_TRACE_ERROR("%s AVRCP controller role is not enabled", __FUNCTION__);
#endif
}

size_t eager_reader_read(eager_reader_t *reader, uint8_t *buffer, size_t max_size, bool block) {
  assert(reader != NULL);
  assert(buffer != NULL);

 if (!block && !has_byte(reader))
 return 0;

 eventfd_t bytes_available;
 if (eventfd_read(reader->bytes_available_fd, &bytes_available) == -1) {
    LOG_ERROR("%s unable to read semaphore for output data.", __func__);
 return 0;
 }

 if (max_size > bytes_available)
    max_size = bytes_available;

 size_t bytes_consumed = 0;
 while (bytes_consumed < max_size) {
 if (!reader->current_buffer)
      reader->current_buffer = fixed_queue_dequeue(reader->buffers);

 size_t bytes_to_copy = reader->current_buffer->length - reader->current_buffer->offset;
 if (bytes_to_copy > (max_size - bytes_consumed))
      bytes_to_copy = max_size - bytes_consumed;

    memcpy(&buffer[bytes_consumed], &reader->current_buffer->data[reader->current_buffer->offset], bytes_to_copy);
    bytes_consumed += bytes_to_copy;
    reader->current_buffer->offset += bytes_to_copy;

 if (reader->current_buffer->offset >= reader->current_buffer->length) {
      reader->allocator->free(reader->current_buffer);
      reader->current_buffer = NULL;
 }
 }

  bytes_available -= bytes_consumed;
 if (eventfd_write(reader->bytes_available_fd, bytes_available) == -1) {
    LOG_ERROR("%s unable to write back bytes available for output data.", __func__);
 }

 return bytes_consumed;
}

BOOLEAN btif_hl_find_mcl_idx_using_mdl_id( UINT8 mdl_id,UINT8 mcl_handle,
                                           UINT8 *p_app_idx, UINT8 *p_mcl_idx){
 btif_hl_app_cb_t *p_acb;
 btif_hl_mcl_cb_t *p_mcb;
    BOOLEAN         found=FALSE;
    UINT8 i,j,x;

 for (i=0; i<BTA_HL_NUM_APPS; i++)
 {
        p_acb =BTIF_HL_GET_APP_CB_PTR(i);
 for (j=0; j < BTA_HL_NUM_MCLS ; j++)
 {
 if (p_acb->mcb[j].in_use &&
 (p_acb->mcb[j].mcl_handle == mcl_handle))
 {
                    p_mcb = &p_acb->mcb[j];
                    BTIF_TRACE_DEBUG("btif_hl_find_mcl_idx_using_mdl_id: mcl handle found j =%d",j);
 for (x=0; x < BTA_HL_NUM_MDLS_PER_MCL ; x ++)
 {
 if (p_mcb->mdl[x].in_use && p_mcb->mdl[x].mdl_id == mdl_id)
 {
                            BTIF_TRACE_DEBUG("btif_hl_find_mcl_idx_using_mdl_id:found x =%d",x);
                            found = TRUE;
 *p_app_idx = i;
 *p_mcl_idx = j;
 break;
 }
 }
 }
 }
 }
    BTIF_TRACE_DEBUG("%s found=%d app_idx=%d mcl_idx=%d",__FUNCTION__,
                      found, i, j);
 return found;
}

static void btif_hl_clean_mcb_using_handle( tBTA_HL_MCL_HANDLE mcl_handle){
 btif_hl_app_cb_t *p_acb;
    UINT8 i,j;

 for (i=0; i<BTA_HL_NUM_APPS; i++)
 {
        p_acb =BTIF_HL_GET_APP_CB_PTR(i);
 for (j=0; j < BTA_HL_NUM_MCLS ; j++)
 {
 if (p_acb->mcb[j].in_use)
                BTIF_TRACE_DEBUG("btif_hl_find_mcl_idx_using_handle: app_idx=%d,"
 "mcl_idx =%d mcl_handle=%d",i,j,p_acb->mcb[j].mcl_handle);
 if (p_acb->mcb[j].in_use &&
 (p_acb->mcb[j].mcl_handle == mcl_handle))
 {
                btif_hl_stop_cch_timer(i, j);
                btif_hl_release_mcl_sockets(i, j);
                btif_hl_send_setup_disconnected_cb(i, j);
                btif_hl_clean_mcl_cb(i, j);
 }
 }
 }
}

static void expect_packet_synchronous(serial_data_type_t type, char *packet_data) {
 int length = strlen(packet_data);
 for (int i = 0; i < length; i++) {
 uint8_t byte;
    EXPECT_EQ((size_t)1, hal->read_data(type, &byte, 1, true));
    EXPECT_EQ(packet_data[i], byte);
 }

  hal->packet_finished(type);
}

static ssize_t out_write(struct audio_stream_out *stream, const void* buffer,
size_t bytes)
{
struct a2dp_stream_out *out = (struct a2dp_stream_out *)stream;
int sent;

DEBUG("write %zu bytes (fd %d)", bytes, out->common.audio_fd);

pthread_mutex_lock(&out->common.lock);

if (out->common.state == AUDIO_A2DP_STATE_SUSPENDED)
{
DEBUG("stream suspended");
pthread_mutex_unlock(&out->common.lock);
return -1;
}

/* only allow autostarting if we are in stopped or standby */
if ((out->common.state == AUDIO_A2DP_STATE_STOPPED) ||
(out->common.state == AUDIO_A2DP_STATE_STANDBY))
{
if (start_audio_datapath(&out->common) < 0)
{
/* emulate time this write represents to avoid very fast write
failures during transition periods or remote suspend */

int us_delay = calc_audiotime(out->common.cfg, bytes);


DEBUG("emulate a2dp write delay (%d us)", us_delay);

            usleep(us_delay);
pthread_mutex_unlock(&out->common.lock);
return -1;
}
}
else if (out->common.state != AUDIO_A2DP_STATE_STARTED)
{
ERROR("stream not in stopped or standby");
pthread_mutex_unlock(&out->common.lock);
return -1;
}

pthread_mutex_unlock(&out->common.lock);
sent = skt_write(out->common.audio_fd, buffer,  bytes);

if (sent == -1) {
skt_disconnect(out->common.audio_fd);
out->common.audio_fd = AUDIO_SKT_DISCONNECTED;
if (out->common.state != AUDIO_A2DP_STATE_SUSPENDED)
out->common.state = AUDIO_A2DP_STATE_STOPPED;
else
ERROR("write failed : stream suspended, avoid resetting state");
} else {
const size_t frames = bytes / audio_stream_out_frame_size(stream);
out->frames_rendered += frames;
out->frames_presented += frames;
}

DEBUG("wrote %d bytes out of %zu bytes", sent, bytes);
return sent;
}

void dump_bin(const char* title, const char* data, int size)
{
 char line_buff[256];
 char *line;
 int i, j, addr;
 const int width = 16;
    LOG_DEBUG("%s, size:%d, dump started {", title, size);
 if(size <= 0)
 return;
    line = line_buff;
 *line++ = ' ';
 *line++ = ' ';
 *line++ = ' ';
 *line++ = ' ';
 *line++ = ' ';
 *line++ = ' ';
 for(j = 0; j < width; j++)
 {
        byte2hex((const char*)&j, &line);
 *line++ = ' ';
 }
 *line = 0;
    PRINT(line_buff);

 for(i = 0; i < size / width; i++)
 {
        line = line_buff;
        addr = i*width;
        word2hex((const char*)&addr, &line);
 *line++ = ':'; *line++ = ' ';
 for(j = 0; j < width; j++)
 {
            byte2hex(&data[j], &line);
 *line++ = ' ';
 }
 for(j = 0; j < width; j++)
            byte2char(data++, &line);
 *line = 0;
        PRINT(line_buff);
 }
 int leftover = size % width;
 if(leftover > 0)
 {
        line = line_buff;
        addr = i*width;
        word2hex((const char*)&addr, &line);
 *line++ = ':'; *line++ = ' ';
 for(j = 0; j < leftover; j++) {
            byte2hex(&data[j], &line);
 *line++ = ' ';
 }
 for(; j < width; j++) {
 *line++ = ' ';
 *line++ = ' ';
 *line++ = ' ';
 }
 for(j = 0; j < leftover; j++)
            byte2char(data++, &line);
 *line = 0;
        PRINT(line_buff);
 }
    LOG_DEBUG("%s, size:%d, dump ended }", title, size);
}

static inline void remove_poll(int h, poll_slot_t* ps, int flags)
{
 if(flags == ps->flags)
 {
 --ts[h].poll_count;
        memset(ps, 0, sizeof(*ps));
        ps->pfd.fd = -1;
 }
 else
 {
        ps->flags &= ~flags;
        ps->pfd.events = flags2pevents(ps->flags);
 }
}

static void handle_rc_metamsg_rsp(tBTA_AV_META_MSG *pmeta_msg)
{
    tAVRC_RESPONSE    avrc_response = {0};
    UINT8             scratch_buf[512] = {0};
    tAVRC_STS status = BT_STATUS_UNSUPPORTED;

 if(AVRC_OP_VENDOR==pmeta_msg->p_msg->hdr.opcode &&(AVRC_RSP_CHANGED==pmeta_msg->code
 || AVRC_RSP_INTERIM==pmeta_msg->code || AVRC_RSP_ACCEPT==pmeta_msg->code
 || AVRC_RSP_REJ==pmeta_msg->code || AVRC_RSP_NOT_IMPL==pmeta_msg->code))
 {
        status=AVRC_ParsResponse(pmeta_msg->p_msg, &avrc_response, scratch_buf, sizeof(scratch_buf));
        BTIF_TRACE_DEBUG("%s: code %d,event ID %d,PDU %x,parsing status %d, label:%d",
          __FUNCTION__,pmeta_msg->code,avrc_response.reg_notif.event_id,avrc_response.reg_notif.pdu,
          status, pmeta_msg->label);

 if (status != AVRC_STS_NO_ERROR)
 {
 if(AVRC_PDU_REGISTER_NOTIFICATION==avrc_response.rsp.pdu
 && AVRC_EVT_VOLUME_CHANGE==avrc_response.reg_notif.event_id
 && btif_rc_cb.rc_vol_label==pmeta_msg->label)
 {
                btif_rc_cb.rc_vol_label=MAX_LABEL;
                release_transaction(btif_rc_cb.rc_vol_label);
 }
 else if(AVRC_PDU_SET_ABSOLUTE_VOLUME==avrc_response.rsp.pdu)
 {
                release_transaction(pmeta_msg->label);
 }
 return;
 }
 else if(AVRC_PDU_REGISTER_NOTIFICATION==avrc_response.rsp.pdu
 && AVRC_EVT_VOLUME_CHANGE==avrc_response.reg_notif.event_id
 && btif_rc_cb.rc_vol_label!=pmeta_msg->label)
 {
                BTIF_TRACE_DEBUG("%s:Discarding register notfn in rsp.code: %d and label %d",
                __FUNCTION__, pmeta_msg->code, pmeta_msg->label);
 return;
 }
 }
 else
 {
        BTIF_TRACE_DEBUG("%s:Received vendor dependent in adv ctrl rsp. code: %d len: %d. Not processing it.",
        __FUNCTION__, pmeta_msg->code, pmeta_msg->len);
 return;
 }

 if(AVRC_PDU_REGISTER_NOTIFICATION==avrc_response.rsp.pdu
 && AVRC_EVT_VOLUME_CHANGE==avrc_response.reg_notif.event_id
 && AVRC_RSP_CHANGED==pmeta_msg->code)
 {
 /* re-register for volume change notification */
         register_volumechange(btif_rc_cb.rc_vol_label);
 }
 else if(AVRC_PDU_SET_ABSOLUTE_VOLUME==avrc_response.rsp.pdu)
 {
 /* free up the label here */
          release_transaction(pmeta_msg->label);
 }

     BTIF_TRACE_EVENT("%s: Passing received metamsg response to app. pdu: %s",
             __FUNCTION__, dump_rc_pdu(avrc_response.pdu));
     btif_rc_upstreams_rsp_evt((uint16_t)avrc_response.rsp.pdu, &avrc_response, pmeta_msg->code,
                                pmeta_msg->label);
}

bt_status_t btif_dm_get_remote_service_record(bt_bdaddr_t *remote_addr,
 bt_uuid_t *uuid)
{
    tSDP_UUID sdp_uuid;
 bdstr_t bdstr;

    BTIF_TRACE_EVENT("%s: remote_addr=%s", __FUNCTION__, bdaddr_to_string(remote_addr, bdstr, sizeof(bdstr)));

    sdp_uuid.len = MAX_UUID_SIZE;
    memcpy(sdp_uuid.uu.uuid128, uuid->uu, MAX_UUID_SIZE);

    BTA_DmDiscoverUUID(remote_addr->address, &sdp_uuid,
                       bte_dm_remote_service_record_evt, TRUE);

 return BT_STATUS_SUCCESS;
}

static BOOLEAN btif_hl_proc_sdp_query_cfm(tBTA_HL *p_data){
 btif_hl_app_cb_t *p_acb;
 btif_hl_mcl_cb_t *p_mcb;
    tBTA_HL_SDP                     *p_sdp;
    tBTA_HL_CCH_OPEN_PARAM          open_param;
    UINT8                           app_idx, mcl_idx, sdp_idx = 0;
    UINT8                           num_recs, i, num_mdeps, j;
 btif_hl_cch_op_t                old_cch_oper;
    BOOLEAN                         status =FALSE;
 btif_hl_pending_chan_cb_t *p_pcb;

    BTIF_TRACE_DEBUG("%s", __FUNCTION__);

    p_sdp = p_data->sdp_query_cfm.p_sdp;
    num_recs = p_sdp->num_recs;

    BTIF_TRACE_DEBUG("num of SDP records=%d",num_recs);
 for (i=0; i<num_recs; i++)
 {
        BTIF_TRACE_DEBUG("rec_idx=%d ctrl_psm=0x%x data_psm=0x%x",
 (i+1),p_sdp->sdp_rec[i].ctrl_psm, p_sdp->sdp_rec[i].data_psm);
        BTIF_TRACE_DEBUG("MCAP supported procedures=0x%x",p_sdp->sdp_rec[i].mcap_sup_proc);
        num_mdeps = p_sdp->sdp_rec[i].num_mdeps;
        BTIF_TRACE_DEBUG("num of mdeps =%d",num_mdeps);
 for (j=0; j< num_mdeps; j++)
 {
            BTIF_TRACE_DEBUG("mdep_idx=%d mdep_id=0x%x data_type=0x%x mdep_role=0x%x",
 (j+1),
                              p_sdp->sdp_rec[i].mdep_cfg[j].mdep_id,
                              p_sdp->sdp_rec[i].mdep_cfg[j].data_type,
                              p_sdp->sdp_rec[i].mdep_cfg[j].mdep_role );
 }
 }

 if (btif_hl_find_app_idx_using_app_id(p_data->sdp_query_cfm.app_id, &app_idx))
 {
            p_acb = BTIF_HL_GET_APP_CB_PTR(app_idx);

 if (btif_hl_find_mcl_idx(app_idx, p_data->sdp_query_cfm.bd_addr, &mcl_idx))
 {
                p_mcb = BTIF_HL_GET_MCL_CB_PTR(app_idx, mcl_idx);
 if (p_mcb->cch_oper != BTIF_HL_CCH_OP_NONE)
 {
                    memcpy(&p_mcb->sdp, p_sdp, sizeof(tBTA_HL_SDP));
                    old_cch_oper = p_mcb->cch_oper;
                    p_mcb->cch_oper = BTIF_HL_CCH_OP_NONE;

 switch (old_cch_oper)
 {
 case BTIF_HL_CCH_OP_MDEP_FILTERING:
                            status = btif_hl_find_sdp_idx_using_mdep_filter(app_idx,
                                                                    mcl_idx, &sdp_idx);
 break;
 default:
 break;
 }

 if (status)
 {
                        p_mcb->sdp_idx       = sdp_idx;
                        p_mcb->valid_sdp_idx = TRUE;
                        p_mcb->ctrl_psm      = p_mcb->sdp.sdp_rec[sdp_idx].ctrl_psm;

 switch (old_cch_oper)
 {
 case BTIF_HL_CCH_OP_MDEP_FILTERING:
                                p_pcb = BTIF_HL_GET_PCB_PTR(app_idx, mcl_idx);
 if (p_pcb->in_use)
 {
 if (!p_pcb->abort_pending)
 {
 switch (p_pcb->op)
 {
 case BTIF_HL_PEND_DCH_OP_OPEN:
                                                btif_hl_send_setup_connecting_cb(app_idx, mcl_idx);
 break;
 case BTIF_HL_PEND_DCH_OP_DELETE_MDL:
 default:
 break;
 }
                                        open_param.ctrl_psm = p_mcb->ctrl_psm;
                                        bdcpy(open_param.bd_addr, p_mcb->bd_addr);
                                        open_param.sec_mask =
 (BTA_SEC_AUTHENTICATE | BTA_SEC_ENCRYPT);
                                        BTA_HlCchOpen(p_acb->app_id,p_acb->app_handle, &open_param);
 }
 else
 {
                                        BTIF_TRACE_DEBUG("channel abort pending");
 }
 }
 break;

 case BTIF_HL_CCH_OP_DCH_OPEN:
                                status = btif_hl_proc_pending_op(app_idx,mcl_idx);
 break;

 default:
                                BTIF_TRACE_ERROR("Invalid CCH oper %d", old_cch_oper);
 break;
 }
 }
 else
 {
                        BTIF_TRACE_ERROR("Can not find SDP idx discard CCH Open request");
 }
 }
 }
 }
 return status;
}

static void internal_write_ready(void *context) {
  assert(context != NULL);

 socket_t *socket = (void *)context;
  socket->write_ready(socket, socket->context);
}

bt_status_t btif_get_remote_device_properties(bt_bdaddr_t *remote_addr)
{
 btif_storage_req_t req;

 if (!btif_is_enabled())
 return BT_STATUS_NOT_READY;

    memcpy(&(req.read_req.bd_addr), remote_addr, sizeof(bt_bdaddr_t));
 return btif_transfer_context(execute_storage_remote_request,
                                 BTIF_CORE_STORAGE_REMOTE_READ_ALL,
 (char*)&req, sizeof(btif_storage_req_t),
                                 NULL);
}

static void btif_dm_ssp_cfm_req_evt(tBTA_DM_SP_CFM_REQ *p_ssp_cfm_req)
{
 bt_bdaddr_t bd_addr;
 bt_bdname_t bd_name;
    UINT32 cod;
    BOOLEAN is_incoming = !(pairing_cb.state == BT_BOND_STATE_BONDING);
 int dev_type;

    BTIF_TRACE_DEBUG("%s", __FUNCTION__);

 /* Remote properties update */
 if (!btif_get_device_type(p_ssp_cfm_req->bd_addr, &dev_type))
 {
        dev_type = BT_DEVICE_TYPE_BREDR;
 }
    btif_update_remote_properties(p_ssp_cfm_req->bd_addr, p_ssp_cfm_req->bd_name,
                                  p_ssp_cfm_req->dev_class, (tBT_DEVICE_TYPE) dev_type);

    bdcpy(bd_addr.address, p_ssp_cfm_req->bd_addr);
    memcpy(bd_name.name, p_ssp_cfm_req->bd_name, BD_NAME_LEN);

 /* Set the pairing_cb based on the local & remote authentication requirements */
    bond_state_changed(BT_STATUS_SUCCESS, &bd_addr, BT_BOND_STATE_BONDING);

 /* if just_works and bonding bit is not set treat this as temporary */
 if (p_ssp_cfm_req->just_works && !(p_ssp_cfm_req->loc_auth_req & BTM_AUTH_BONDS) &&
 !(p_ssp_cfm_req->rmt_auth_req & BTM_AUTH_BONDS) &&
 !(check_cod((bt_bdaddr_t*)&p_ssp_cfm_req->bd_addr, COD_HID_POINTING)))
        pairing_cb.bond_type = BOND_TYPE_TEMPORARY;
 else
        pairing_cb.bond_type = BOND_TYPE_PERSISTENT;

    btm_set_bond_type_dev(p_ssp_cfm_req->bd_addr, pairing_cb.bond_type);

    pairing_cb.is_ssp = TRUE;

 /* If JustWorks auto-accept */
 if (p_ssp_cfm_req->just_works)
 {
 /* Pairing consent for JustWorks needed if:
         * 1. Incoming (non-temporary) pairing is detected AND
         * 2. local IO capabilities are DisplayYesNo AND
         * 3. remote IO capabiltiies are DisplayOnly or NoInputNoOutput;
         */
 if (is_incoming && pairing_cb.bond_type != BOND_TYPE_TEMPORARY &&
 ((p_ssp_cfm_req->loc_io_caps == HCI_IO_CAP_DISPLAY_YESNO) &&
 (p_ssp_cfm_req->rmt_io_caps == HCI_IO_CAP_DISPLAY_ONLY ||
                 p_ssp_cfm_req->rmt_io_caps == HCI_IO_CAP_NO_IO)))
 {
            BTIF_TRACE_EVENT("%s: User consent needed for incoming pairing request. loc_io_caps: %d, rmt_io_caps: %d",
                __FUNCTION__, p_ssp_cfm_req->loc_io_caps, p_ssp_cfm_req->rmt_io_caps);
 }
 else
 {
            BTIF_TRACE_EVENT("%s: Auto-accept JustWorks pairing", __FUNCTION__);
            btif_dm_ssp_reply(&bd_addr, BT_SSP_VARIANT_CONSENT, TRUE, 0);
 return;
 }
 }

    cod = devclass2uint(p_ssp_cfm_req->dev_class);

 if (cod == 0) {
        LOG_DEBUG("%s cod is 0, set as unclassified", __func__);
        cod = COD_UNCLASSIFIED;
 }

    pairing_cb.sdp_attempts = 0;
    HAL_CBACK(bt_hal_cbacks, ssp_request_cb, &bd_addr, &bd_name, cod,
 (p_ssp_cfm_req->just_works ? BT_SSP_VARIANT_CONSENT : BT_SSP_VARIANT_PASSKEY_CONFIRMATION),
                     p_ssp_cfm_req->num_val);
}

static void bta_energy_info_cb(tBTA_DM_BLE_TX_TIME_MS tx_time, tBTA_DM_BLE_RX_TIME_MS rx_time,
                                    tBTA_DM_BLE_IDLE_TIME_MS idle_time,
                                    tBTA_DM_BLE_ENERGY_USED energy_used,
                                    tBTA_DM_CONTRL_STATE ctrl_state, tBTA_STATUS status)
{
    BTIF_TRACE_DEBUG("energy_info_cb-Status:%d,state=%d,tx_t=%ld, rx_t=%ld, idle_time=%ld,used=%ld",
        status, ctrl_state, tx_time, rx_time, idle_time, energy_used);

 btif_activity_energy_info_cb_t btif_cb;
    btif_cb.status = status;
    btif_cb.ctrl_state = ctrl_state;
    btif_cb.tx_time = (uint64_t) tx_time;
    btif_cb.rx_time = (uint64_t) rx_time;
    btif_cb.idle_time =(uint64_t) idle_time;
    btif_cb.energy_used =(uint64_t) energy_used;
    btif_transfer_context(btif_dm_upstreams_evt, BTA_DM_ENER_INFO_READ,
 (char*) &btif_cb, sizeof(btif_activity_energy_info_cb_t), NULL);
}

btif_hh_device_t *btif_hh_find_connected_dev_by_handle(UINT8 handle)
{
    UINT32 i;
 for (i = 0; i < BTIF_HH_MAX_HID; i++) {
 if (btif_hh_cb.devices[i].dev_status == BTHH_CONN_STATE_CONNECTED &&
            btif_hh_cb.devices[i].dev_handle == handle)
 {
 return &btif_hh_cb.devices[i];
 }
 }
 return NULL;
}

socket_t *socket_new(void) {
 socket_t *ret = (socket_t *)osi_calloc(sizeof(socket_t));
 if (!ret) {
    LOG_ERROR("%s unable to allocate memory for socket.", __func__);
 goto error;
 }

  ret->fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
 if (ret->fd == INVALID_FD) {
    LOG_ERROR("%s unable to create socket: %s", __func__, strerror(errno));
 goto error;
 }

 int enable = 1;
 if (setsockopt(ret->fd, SOL_SOCKET, SO_REUSEADDR, &enable, sizeof(enable)) == -1) {
    LOG_ERROR("%s unable to set SO_REUSEADDR: %s", __func__, strerror(errno));
 goto error;
 }

 return ret;

error:;
 if (ret)
    close(ret->fd);
  osi_free(ret);
 return NULL;
}

static bool flush_incoming_que_on_wr_signal(rfc_slot_t *slot) {
 while (!list_is_empty(slot->incoming_queue)) {
    BT_HDR *p_buf = list_front(slot->incoming_queue);
 switch (send_data_to_app(slot->fd, p_buf)) {
 case SENT_NONE:
 case SENT_PARTIAL:
        btsock_thread_add_fd(pth, slot->fd, BTSOCK_RFCOMM, SOCK_THREAD_FD_WR, slot->id);
 return true;

 case SENT_ALL:
        list_remove(slot->incoming_queue, p_buf);
 break;

 case SENT_FAILED:
        list_remove(slot->incoming_queue, p_buf);
 return false;
 }
 }

  APPL_TRACE_DEBUG("enable data flow, rfc_handle:0x%x, rfc_port_handle:0x%x, user_id:%d",
      slot->rfc_handle, slot->rfc_port_handle, slot->id);
 extern int PORT_FlowControl_MaxCredit(uint16_t handle, bool enable);
  PORT_FlowControl_MaxCredit(slot->rfc_port_handle, true);
 return true;
}

bt_status_t btif_dut_mode_configure(uint8_t enable)
{
    BTIF_TRACE_DEBUG("%s", __FUNCTION__);

 if (!stack_manager_get_interface()->get_stack_is_running()) {
        BTIF_TRACE_ERROR("btif_dut_mode_configure : Bluetooth not enabled");
 return BT_STATUS_NOT_READY;
 }

    btif_dut_mode = enable;
 if (enable == 1) {
        BTA_EnableTestMode();
 } else {
        BTA_DisableTestMode();
 }
 return BT_STATUS_SUCCESS;
}

static void bte_hh_evt(tBTA_HH_EVT event, tBTA_HH *p_data)
{
 bt_status_t status;
 int param_len = 0;

 if (BTA_HH_ENABLE_EVT == event)
        param_len = sizeof(tBTA_HH_STATUS);
 else if (BTA_HH_OPEN_EVT == event)
        param_len = sizeof(tBTA_HH_CONN);
 else if (BTA_HH_DISABLE_EVT == event)
        param_len = sizeof(tBTA_HH_STATUS);
 else if (BTA_HH_CLOSE_EVT == event)
        param_len = sizeof(tBTA_HH_CBDATA);
 else if (BTA_HH_GET_DSCP_EVT == event)
        param_len = sizeof(tBTA_HH_DEV_DSCP_INFO);
 else if ((BTA_HH_GET_PROTO_EVT == event) || (BTA_HH_GET_RPT_EVT == event)|| (BTA_HH_GET_IDLE_EVT == event))
        param_len = sizeof(tBTA_HH_HSDATA);
 else if ((BTA_HH_SET_PROTO_EVT == event) || (BTA_HH_SET_RPT_EVT == event) || (BTA_HH_VC_UNPLUG_EVT == event) || (BTA_HH_SET_IDLE_EVT == event))
        param_len = sizeof(tBTA_HH_CBDATA);
 else if ((BTA_HH_ADD_DEV_EVT == event) || (BTA_HH_RMV_DEV_EVT == event) )
        param_len = sizeof(tBTA_HH_DEV_INFO);
 else if (BTA_HH_API_ERR_EVT == event)
        param_len = 0;
 /* switch context to btif task context (copy full union size for convenience) */
    status = btif_transfer_context(btif_hh_upstreams_evt, (uint16_t)event, (void*)p_data, param_len, NULL);

 /* catch any failed context transfers */
    ASSERTC(status == BT_STATUS_SUCCESS, "context transfer failed", status);
}

bt_status_t btif_get_adapter_property(bt_property_type_t type)
{
 btif_storage_req_t req;

    BTIF_TRACE_EVENT("%s %d", __FUNCTION__, type);

 /* Allow get_adapter_property only for BDADDR and BDNAME if BT is disabled */
 if (!btif_is_enabled() && (type != BT_PROPERTY_BDADDR) && (type != BT_PROPERTY_BDNAME))
 return BT_STATUS_NOT_READY;

    memset(&(req.read_req.bd_addr), 0, sizeof(bt_bdaddr_t));
    req.read_req.type = type;

 return btif_transfer_context(execute_storage_request,
                                 BTIF_CORE_STORAGE_ADAPTER_READ,
 (char*)&req, sizeof(btif_storage_req_t), NULL);
}

static void hal_close() {
  LOG_INFO("%s", __func__);

  eager_reader_free(event_stream);
  eager_reader_free(acl_stream);
  vendor->send_command(VENDOR_CLOSE_USERIAL, NULL);

 for (int i = 0; i < CH_MAX; i++)
    uart_fds[i] = INVALID_FD;
}

static void search_devices_copy_cb(UINT16 event, char *p_dest, char *p_src)
{
    tBTA_DM_SEARCH *p_dest_data = (tBTA_DM_SEARCH *) p_dest;
    tBTA_DM_SEARCH *p_src_data = (tBTA_DM_SEARCH *) p_src;

 if (!p_src)
 return;

    BTIF_TRACE_DEBUG("%s: event=%s", __FUNCTION__, dump_dm_search_event(event));
    memcpy(p_dest_data, p_src_data, sizeof(tBTA_DM_SEARCH));
 switch (event)
 {
 case BTA_DM_INQ_RES_EVT:
 {
 if (p_src_data->inq_res.p_eir)
 {
                p_dest_data->inq_res.p_eir = (UINT8 *)(p_dest + sizeof(tBTA_DM_SEARCH));
                memcpy(p_dest_data->inq_res.p_eir, p_src_data->inq_res.p_eir, HCI_EXT_INQ_RESPONSE_LEN);
 }
 }
 break;

 case BTA_DM_DISC_RES_EVT:
 {
 if (p_src_data->disc_res.raw_data_size && p_src_data->disc_res.p_raw_data)
 {
                p_dest_data->disc_res.p_raw_data = (UINT8 *)(p_dest + sizeof(tBTA_DM_SEARCH));
                memcpy(p_dest_data->disc_res.p_raw_data,
                    p_src_data->disc_res.p_raw_data, p_src_data->disc_res.raw_data_size);
 }
 }
 break;
 }
}

static bool hal_init(const hci_hal_callbacks_t *upper_callbacks, thread_t *upper_thread) {
  assert(upper_callbacks != NULL);
  assert(upper_thread != NULL);

  callbacks = upper_callbacks;
  thread = upper_thread;
 return true;
}

static int out_standby(struct audio_stream *stream)
{
 struct a2dp_stream_out *out = (struct a2dp_stream_out *)stream;
 int retVal = 0;

    FNLOG();

    pthread_mutex_lock(&out->common.lock);
 if (out->common.state != AUDIO_A2DP_STATE_SUSPENDED)
        retVal = suspend_audio_datapath(&out->common, true);
    out->frames_rendered = 0; // rendered is reset, presented is not
    pthread_mutex_unlock (&out->common.lock);

 return retVal;
}

static void event_acl_stream_has_bytes(UNUSED_ATTR eager_reader_t *reader, UNUSED_ATTR void *context) {
  callbacks->data_ready(DATA_TYPE_ACL);
}

BOOLEAN  btif_hl_save_mdl_cfg(UINT8 mdep_id, UINT8 item_idx,
                              tBTA_HL_MDL_CFG *p_mdl_cfg){
 btif_hl_mdl_cfg_t *p_mdl=NULL;
    BOOLEAN             success = FALSE;
 btif_hl_app_cb_t *p_acb;
 btif_hl_mcl_cb_t *p_mcb;
    UINT8               app_idx, mcl_idx, len;
 bt_status_t         bt_status;
 btif_hl_evt_cb_t    evt_param;
 int *p_channel_id;

    BTIF_TRACE_DEBUG("%s mdep_id=%d item_idx=%d, local_mdep_id=%d mdl_id=0x%x dch_mode=%d",
                      __FUNCTION__, mdep_id, item_idx, p_mdl_cfg->local_mdep_id,
                      p_mdl_cfg->mdl_id, p_mdl_cfg->dch_mode );

 if(btif_hl_find_app_idx_using_mdepId(mdep_id,&app_idx))
 {
        p_acb = BTIF_HL_GET_APP_CB_PTR(app_idx);
        p_mdl = BTIF_HL_GET_MDL_CFG_PTR(app_idx, item_idx);
        p_channel_id = BTIF_HL_GET_MDL_CFG_CHANNEL_ID_PTR(app_idx, item_idx);
 if (p_mdl)
 {
            memcpy(&p_mdl->base, p_mdl_cfg, sizeof(tBTA_HL_MDL_CFG));
 if (btif_hl_find_mcl_idx(app_idx, p_mdl->base.peer_bd_addr , &mcl_idx))
 {
                p_mcb = BTIF_HL_GET_MCL_CB_PTR(app_idx, mcl_idx);
 if (p_mcb->pcb.in_use)
 *p_channel_id = p_mcb->pcb.channel_id;
 else
 *p_channel_id = btif_hl_get_next_channel_id(p_acb->app_id);
                p_mdl->extra.mdep_cfg_idx = p_mcb->pcb.mdep_cfg_idx;
                p_mdl->extra.data_type = p_acb->sup_feature.mdep[p_mcb->pcb.mdep_cfg_idx].mdep_cfg.data_cfg[0].data_type;

 if (!btif_hl_find_peer_mdep_id(p_acb->app_id, p_mcb->bd_addr,
                                               p_acb->sup_feature.mdep[p_mcb->pcb.mdep_cfg_idx].mdep_cfg.mdep_role,
                                               p_acb->sup_feature.mdep[p_mcb->pcb.mdep_cfg_idx].mdep_cfg.data_cfg[0].data_type,
 &p_mdl->extra.peer_mdep_id))
 {
                    p_mdl->extra.peer_mdep_id = BTA_HL_INVALID_MDEP_ID;
 }
                BTIF_TRACE_DEBUG("%s app_idx=%d item_idx=%d mld_id=0x%x",
                                  __FUNCTION__, app_idx, item_idx, p_mdl->base.mdl_id);
                evt_param.update_mdl.app_idx = app_idx;
                len = sizeof(btif_hl_update_mdl_t);
                BTIF_TRACE_DEBUG("send BTIF_HL_UPDATE_MDL event app_idx=%d  ",app_idx);
 if ((bt_status = btif_transfer_context (btif_hl_proc_cb_evt, BTIF_HL_UPDATE_MDL,
 (char*) &evt_param, len, NULL)) == BT_STATUS_SUCCESS)
 {
                    success = TRUE;
 }
                ASSERTC(bt_status == BT_STATUS_SUCCESS, "context transfer failed", bt_status);
 }
 }
 }
    BTIF_TRACE_DEBUG("%s success=%d  ",__FUNCTION__, success );

 return success;
}

int semaphore_get_fd(const semaphore_t *semaphore) {
  assert(semaphore != NULL);
  assert(semaphore->fd != INVALID_FD);
 return semaphore->fd;
}

static void btif_dm_ble_test_end_cback(void *p)
{
    btif_transfer_context(btif_dm_generic_evt, BTIF_DM_CB_LE_TEST_END,
 (char *)p, 3, NULL);
}

const bthl_interface_t *btif_hl_get_interface(){
    BTIF_TRACE_EVENT("%s", __FUNCTION__);
 return &bthlInterface;
}

static void btif_hl_proc_cch_open_ind(tBTA_HL *p_data)

{
 btif_hl_mcl_cb_t *p_mcb;
    UINT8                   mcl_idx;
 int                     i;

    BTIF_TRACE_DEBUG("%s", __FUNCTION__);
 for(i=0; i<BTA_HL_NUM_APPS; i++)
 {
 if (btif_hl_cb.acb[i].in_use)
 {
 if (!btif_hl_find_mcl_idx(i, p_data->cch_open_ind.bd_addr, &mcl_idx))
 {
 if (btif_hl_find_avail_mcl_idx(i, &mcl_idx))
 {
                    p_mcb = BTIF_HL_GET_MCL_CB_PTR(i, mcl_idx);
                    memset(p_mcb, 0, sizeof(btif_hl_mcl_cb_t));
                    p_mcb->in_use = TRUE;
                    p_mcb->is_connected = TRUE;
                    p_mcb->mcl_handle = p_data->cch_open_ind.mcl_handle;
                    bdcpy(p_mcb->bd_addr, p_data->cch_open_ind.bd_addr);
                    btif_hl_start_cch_timer(i, mcl_idx);
 }
 }
 else
 {
                BTIF_TRACE_ERROR("The MCL already exist for cch_open_ind");
 }
 }
 }
}

void btif_dm_proc_io_rsp(BD_ADDR bd_addr, tBTA_IO_CAP io_cap,
                      tBTA_OOB_DATA oob_data, tBTA_AUTH_REQ auth_req)
{
    UNUSED (bd_addr);
    UNUSED (oob_data);

 if(auth_req & BTA_AUTH_BONDS)
 {
        BTIF_TRACE_DEBUG("%s auth_req:%d", __FUNCTION__, auth_req);
        pairing_cb.auth_req = auth_req;
        pairing_cb.io_cap = io_cap;
 }
}

bt_status_t btif_transfer_context (tBTIF_CBACK *p_cback, UINT16 event, char* p_params, int param_len, tBTIF_COPY_CBACK *p_copy_cback)
{
    tBTIF_CONTEXT_SWITCH_CBACK *p_msg;

    BTIF_TRACE_VERBOSE("btif_transfer_context event %d, len %d", event, param_len);

 /* allocate and send message that will be executed in btif context */
 if ((p_msg = (tBTIF_CONTEXT_SWITCH_CBACK *) GKI_getbuf(sizeof(tBTIF_CONTEXT_SWITCH_CBACK) + param_len)) != NULL)
 {
        p_msg->hdr.event = BT_EVT_CONTEXT_SWITCH_EVT; /* internal event */
        p_msg->p_cb = p_cback;

        p_msg->event = event; /* callback event */

 /* check if caller has provided a copy callback to do the deep copy */
 if (p_copy_cback)
 {
            p_copy_cback(event, p_msg->p_param, p_params);
 }
 else if (p_params)
 {
            memcpy(p_msg->p_param, p_params, param_len); /* callback parameter data */
 }

        btif_sendmsg(p_msg);
 return BT_STATUS_SUCCESS;
 }
 else
 {
 /* let caller deal with a failed allocation */
 return BT_STATUS_NOMEM;
 }
}

static void register_volumechange (UINT8 lbl)
{
    tAVRC_COMMAND avrc_cmd = {0};
    BT_HDR *p_msg = NULL;
    tAVRC_STS BldResp=AVRC_STS_BAD_CMD;
 rc_transaction_t *p_transaction=NULL;

    BTIF_TRACE_DEBUG("%s called with label:%d",__FUNCTION__,lbl);

    avrc_cmd.cmd.opcode=0x00;
    avrc_cmd.pdu = AVRC_PDU_REGISTER_NOTIFICATION;
    avrc_cmd.reg_notif.event_id = AVRC_EVT_VOLUME_CHANGE;
    avrc_cmd.reg_notif.status = AVRC_STS_NO_ERROR;

 BldResp=AVRC_BldCommand(&avrc_cmd, &p_msg);
 if(AVRC_STS_NO_ERROR==BldResp && p_msg)
 {
         p_transaction=get_transaction_by_lbl(lbl);
 if(NULL!=p_transaction)
 {
             BTA_AvMetaCmd(btif_rc_cb.rc_handle,p_transaction->lbl, AVRC_CMD_NOTIF, p_msg);
             BTIF_TRACE_DEBUG("%s:BTA_AvMetaCmd called",__FUNCTION__);
 }
 else
 {
 if(NULL!=p_msg)
               GKI_freebuf(p_msg);
            BTIF_TRACE_ERROR("%s transaction not obtained with label: %d",__FUNCTION__,lbl);
 }
 }
 else
        BTIF_TRACE_ERROR("%s failed to build command:%d",__FUNCTION__,BldResp);
}

static inline int btpan_role_to_bta(int btpan_role)
{
 int bta_pan_role = PAN_ROLE_INACTIVE;
    BTIF_TRACE_DEBUG("btpan_role:0x%x", btpan_role);
 if (btpan_role & BTPAN_ROLE_PANNAP)
        bta_pan_role |= PAN_ROLE_NAP_SERVER;
 if (btpan_role & BTPAN_ROLE_PANU)
        bta_pan_role |= PAN_ROLE_CLIENT;
 return bta_pan_role;
}

static size_t read_data(serial_data_type_t type, uint8_t *buffer, size_t max_size, bool block) {
 if (type < DATA_TYPE_ACL || type > DATA_TYPE_EVENT) {
    LOG_ERROR("%s invalid data type: %d", __func__, type);
 return 0;
 } else if (!stream_has_interpretation) {
    LOG_ERROR("%s with no valid stream intepretation.", __func__);
 return 0;
 } else if (current_data_type != type) {
    LOG_ERROR("%s with different type than existing interpretation.", __func__);
 return 0;
 }

 return eager_reader_read(uart_stream, buffer, max_size, block);
}

const config_section_node_t *config_section_begin(const config_t *config) {
  assert(config != NULL);
 return (const config_section_node_t *)list_begin(config->sections);
}

static void a2dp_open_ctrl_path(struct a2dp_stream_common *common)
{
int i;

/* retry logic to catch any timing variations on control channel */
for (i = 0; i < CTRL_CHAN_RETRY_COUNT; i++)
{
/* connect control channel if not already connected */
if ((common->ctrl_fd = skt_connect(A2DP_CTRL_PATH, common->buffer_sz)) > 0)
{
/* success, now check if stack is ready */
if (check_a2dp_ready(common) == 0)

break;

ERROR("error : a2dp not ready, wait 250 ms and retry");
            usleep(250000);
skt_disconnect(common->ctrl_fd);
common->ctrl_fd = AUDIO_SKT_DISCONNECTED;
}

/* ctrl channel not ready, wait a bit */
        usleep(250000);
}
}

 virtual void TearDown() {
      semaphore_free(done);
 AllocationTestHarness::TearDown();
 }

BOOLEAN btif_hl_create_socket(UINT8 app_idx, UINT8 mcl_idx, UINT8 mdl_idx){
 btif_hl_mcl_cb_t *p_mcb = BTIF_HL_GET_MCL_CB_PTR(app_idx, mcl_idx);
 btif_hl_mdl_cb_t *p_dcb = BTIF_HL_GET_MDL_CB_PTR(app_idx, mcl_idx, mdl_idx);
 btif_hl_soc_cb_t *p_scb = NULL;
    BOOLEAN               status = FALSE;

    BTIF_TRACE_DEBUG("%s", __FUNCTION__);

 if (p_dcb && ((p_scb = (btif_hl_soc_cb_t *)GKI_getbuf((UINT16)sizeof(btif_hl_soc_cb_t)))!=NULL))
 {
 if (socketpair(AF_UNIX, SOCK_STREAM, 0, p_scb->socket_id) >= 0)
 {
            BTIF_TRACE_DEBUG("socket id[0]=%d id[1]=%d",p_scb->socket_id[0], p_scb->socket_id[1] );
            p_dcb->p_scb = p_scb;
            p_scb->app_idx = app_idx;
            p_scb->mcl_idx = mcl_idx;
            p_scb->mdl_idx = mdl_idx;
            p_scb->channel_id = p_dcb->channel_id;
            p_scb->mdep_cfg_idx = p_dcb->local_mdep_cfg_idx;
            memcpy(p_scb->bd_addr, p_mcb->bd_addr,sizeof(BD_ADDR));
            btif_hl_set_socket_state(p_scb,  BTIF_HL_SOC_STATE_W4_ADD);
            p_scb->max_s = p_scb->socket_id[1];
            list_append(soc_queue, (void *)p_scb);
            btif_hl_select_wakeup();
            status = TRUE;
 }
 else
 {

            btif_hl_free_buf((void **)&p_scb);
 }
 }

    BTIF_TRACE_DEBUG("%s status=%d", __FUNCTION__, status);
 return status;
}

static char is_inited(void)
{
 char ret;


    pthread_mutex_lock(&state_lock);
    ret = pth != -1;
    pthread_mutex_unlock(&state_lock);

 return ret;
}

static bt_status_t btsock_l2cap_listen_or_connect(const char *name, const bt_bdaddr_t *addr,
 int channel, int* sock_fd, int flags, char listen)
{
 bt_status_t stat;
 int fixed_chan = 1;
    l2cap_socket *sock;
    tL2CAP_CFG_INFO cfg;

 if (!sock_fd)
 return BT_STATUS_PARM_INVALID;

 if(channel < 0) {
        fixed_chan = 0;
 } else {
        fixed_chan = (channel & L2CAP_MASK_FIXED_CHANNEL) != 0;
        channel &=~ L2CAP_MASK_FIXED_CHANNEL;
 }

 if (!is_inited())
 return BT_STATUS_NOT_READY;

    pthread_mutex_lock(&state_lock);

    sock = btsock_l2cap_alloc_l(name, addr, listen, flags);
 if (!sock)
 return BT_STATUS_NOMEM;

    sock->fixed_chan = fixed_chan;
    sock->channel = channel;

    stat = BT_STATUS_SUCCESS;

 /* Setup ETM settings:
     *  mtu will be set below */
    memset(&cfg, 0, sizeof(tL2CAP_CFG_INFO));

    cfg.fcr_present = TRUE;
    cfg.fcr = obex_l2c_fcr_opts_def;

 /* "role" is never initialized in rfcomm code */
 if (listen) {
        stat = btSock_start_l2cap_server_l(sock);
 } else {
 if (fixed_chan) {
 if (BTA_JvL2capConnectLE(sock->security, 0, NULL, channel,
                    L2CAP_DEFAULT_MTU, NULL, sock->addr.address, btsock_l2cap_cbk,
 (void*)sock->id) != BTA_JV_SUCCESS)
                stat = BT_STATUS_FAIL;

 } else {
 if (BTA_JvL2capConnect(sock->security, 0, &obex_l2c_etm_opt,
                    channel, L2CAP_MAX_SDU_LENGTH, &cfg, sock->addr.address,
                    btsock_l2cap_cbk, (void*)sock->id) != BTA_JV_SUCCESS)
                stat = BT_STATUS_FAIL;
 }
 }

 if (stat == BT_STATUS_SUCCESS) {
 *sock_fd = sock->app_fd;
 /* We pass the FD to JAVA, but since it runs in another process, we need to also close
         * it in native, either straight away, as done when accepting an incoming connection,
         * or when doing cleanup after this socket */
        sock->app_fd = -1; /*This leaks the file descriptor. The FD should be closed in
                              JAVA but it apparently do not work */
        btsock_thread_add_fd(pth, sock->our_fd, BTSOCK_L2CAP, SOCK_THREAD_FD_EXCEPTION,
                sock->id);
 } else {
       btsock_l2cap_free_l(sock);
 }
    pthread_mutex_unlock(&state_lock);

 return stat;
}

static inline void add_poll(int h, int fd, int type, int flags, uint32_t user_id)
{
    asrt(fd != -1);
 int i;
 int empty = -1;
 poll_slot_t* ps = ts[h].ps;

 for(i = 0; i < MAX_POLL; i++)
 {
 if(ps[i].pfd.fd == fd)
 {
            asrt(ts[h].poll_count < MAX_POLL);

            set_poll(&ps[i], fd, type, flags | ps[i].flags, user_id);
 return;
 }
 else if(empty < 0 && ps[i].pfd.fd == -1)
            empty = i;
 }
 if(empty >= 0)
 {
        asrt(ts[h].poll_count < MAX_POLL);
        set_poll(&ps[empty], fd, type, flags, user_id);
 ++ts[h].poll_count;
 return;
 }
    APPL_TRACE_ERROR("exceeded max poll slot:%d!", MAX_POLL);
}

static void btif_dm_auth_cmpl_evt (tBTA_DM_AUTH_CMPL *p_auth_cmpl)
{
 /* Save link key, if not temporary */
 bt_bdaddr_t bd_addr;
 bt_status_t status = BT_STATUS_FAIL;
 bt_bond_state_t state = BT_BOND_STATE_NONE;
    BOOLEAN skip_sdp = FALSE;

    BTIF_TRACE_DEBUG("%s: bond state=%d", __func__, pairing_cb.state);

    bdcpy(bd_addr.address, p_auth_cmpl->bd_addr);
 if ( (p_auth_cmpl->success == TRUE) && (p_auth_cmpl->key_present) )
 {
 if ((p_auth_cmpl->key_type < HCI_LKEY_TYPE_DEBUG_COMB) ||
 (p_auth_cmpl->key_type == HCI_LKEY_TYPE_AUTH_COMB) ||
 (p_auth_cmpl->key_type == HCI_LKEY_TYPE_CHANGED_COMB) ||
 (p_auth_cmpl->key_type == HCI_LKEY_TYPE_AUTH_COMB_P_256) ||
            pairing_cb.bond_type == BOND_TYPE_PERSISTENT)
 {
 bt_status_t ret;
            BTIF_TRACE_DEBUG("%s: Storing link key. key_type=0x%x, bond_type=%d",
                __FUNCTION__, p_auth_cmpl->key_type, pairing_cb.bond_type);
            ret = btif_storage_add_bonded_device(&bd_addr,
                                p_auth_cmpl->key, p_auth_cmpl->key_type,
                                pairing_cb.pin_code_len);
            ASSERTC(ret == BT_STATUS_SUCCESS, "storing link key failed", ret);
 }
 else
 {
            BTIF_TRACE_DEBUG("%s: Temporary key. Not storing. key_type=0x%x, bond_type=%d",
                __FUNCTION__, p_auth_cmpl->key_type, pairing_cb.bond_type);
 if(pairing_cb.bond_type == BOND_TYPE_TEMPORARY)
 {
                BTIF_TRACE_DEBUG("%s: sending BT_BOND_STATE_NONE for Temp pairing",
                        __FUNCTION__);
                btif_storage_remove_bonded_device(&bd_addr);
                bond_state_changed(BT_STATUS_SUCCESS, &bd_addr, BT_BOND_STATE_NONE);
 return;
 }
 }
 }

 if (p_auth_cmpl->success)
 {
#if BLE_INCLUDED == TRUE
        btif_storage_set_remote_addr_type(&bd_addr, p_auth_cmpl->addr_type);
#endif
        btif_update_remote_properties(p_auth_cmpl->bd_addr,
                                      p_auth_cmpl->bd_name, NULL, p_auth_cmpl->dev_type);
        pairing_cb.timeout_retries = 0;
        status = BT_STATUS_SUCCESS;
        state = BT_BOND_STATE_BONDED;
        bdcpy(bd_addr.address, p_auth_cmpl->bd_addr);

 if (check_sdp_bl(&bd_addr) && check_cod_hid(&bd_addr, COD_HID_MAJOR))
 {
            LOG_WARN("%s:skip SDP", __FUNCTION__);
            skip_sdp = TRUE;
 }
 if(!pairing_cb.is_local_initiated && skip_sdp)
 {
            bond_state_changed(status, &bd_addr, state);

            LOG_WARN("%s: Incoming HID Connection",__FUNCTION__);
 bt_property_t prop;
 bt_bdaddr_t bd_addr;
 bt_uuid_t  uuid;
 char uuid_str[128] = UUID_HUMAN_INTERFACE_DEVICE;

            string_to_uuid(uuid_str, &uuid);

            prop.type = BT_PROPERTY_UUIDS;
            prop.val = uuid.uu;
            prop.len = MAX_UUID_SIZE;

 /* Send the event to the BTIF */
            HAL_CBACK(bt_hal_cbacks, remote_device_properties_cb,
                             BT_STATUS_SUCCESS, &bd_addr, 1, &prop);
 }
 else
 {
 /* Trigger SDP on the device */
            pairing_cb.sdp_attempts = 1;;

#if BLE_INCLUDED == TRUE
 /* If bonded due to cross-key, save the static address too*/
 if(pairing_cb.state == BT_BOND_STATE_BONDING &&
 (bdcmp(p_auth_cmpl->bd_addr, pairing_cb.bd_addr) != 0))
 {
                BTIF_TRACE_DEBUG("%s: bonding initiated due to cross key, adding static address",
                                 __func__);
                bdcpy(pairing_cb.static_bdaddr.address, p_auth_cmpl->bd_addr);
 }
#endif

 if(btif_dm_inquiry_in_progress)
                btif_dm_cancel_discovery();

            btif_dm_get_remote_services(&bd_addr);
 }
 }
 else
 {
 switch(p_auth_cmpl->fail_reason)
 {
 case HCI_ERR_PAGE_TIMEOUT:
 if (interop_match(INTEROP_AUTO_RETRY_PAIRING, &bd_addr)
 && pairing_cb.timeout_retries)
 {
                    BTIF_TRACE_WARNING("%s() - Pairing timeout; retrying (%d) ...", __FUNCTION__, pairing_cb.timeout_retries);
 --pairing_cb.timeout_retries;
                    btif_dm_cb_create_bond (&bd_addr, BTA_TRANSPORT_UNKNOWN);
 return;
 }
 /* Fall-through */
 case HCI_ERR_CONNECTION_TOUT:
                status =  BT_STATUS_RMT_DEV_DOWN;
 break;

 case HCI_ERR_PAIRING_NOT_ALLOWED:
                status = BT_STATUS_AUTH_REJECTED;
 break;

 case HCI_ERR_LMP_RESPONSE_TIMEOUT:
                status =  BT_STATUS_AUTH_FAILURE;
 break;

 /* map the auth failure codes, so we can retry pairing if necessary */
 case HCI_ERR_AUTH_FAILURE:
 case HCI_ERR_KEY_MISSING:
                btif_storage_remove_bonded_device(&bd_addr);
 case HCI_ERR_HOST_REJECT_SECURITY:
 case HCI_ERR_ENCRY_MODE_NOT_ACCEPTABLE:
 case HCI_ERR_UNIT_KEY_USED:
 case HCI_ERR_PAIRING_WITH_UNIT_KEY_NOT_SUPPORTED:
 case HCI_ERR_INSUFFCIENT_SECURITY:
 case HCI_ERR_PEER_USER:
 case HCI_ERR_UNSPECIFIED:
                BTIF_TRACE_DEBUG(" %s() Authentication fail reason %d",
                    __FUNCTION__, p_auth_cmpl->fail_reason);
 if (pairing_cb.autopair_attempts  == 1)
 {
                    BTIF_TRACE_DEBUG("%s(): Adding device to blacklist ", __FUNCTION__);

 /* Add the device to dynamic black list only if this device belongs to Audio/pointing dev class  */
 if (check_cod(&bd_addr, COD_AV_HEADSETS) ||
                        check_cod(&bd_addr, COD_AV_HANDSFREE) ||
                        check_cod(&bd_addr, COD_AV_HEADPHONES) ||
                        check_cod(&bd_addr, COD_AV_PORTABLE_AUDIO) ||
                        check_cod(&bd_addr, COD_AV_HIFI_AUDIO) ||
                        check_cod(&bd_addr, COD_HID_POINTING))
 {
                        btif_storage_add_device_to_autopair_blacklist (&bd_addr);
 }
                    pairing_cb.autopair_attempts++;

 /* Create the Bond once again */
                    BTIF_TRACE_DEBUG("%s() auto pair failed. Reinitiate Bond", __FUNCTION__);
                    btif_dm_cb_create_bond (&bd_addr, BTA_TRANSPORT_UNKNOWN);
 return;
 }
 else
 {
 /* if autopair attempts are more than 1, or not attempted */
                    status =  BT_STATUS_AUTH_FAILURE;
 }
 break;

 default:
                status =  BT_STATUS_FAIL;
 }
 /* Special Handling for HID Devices */
 if (check_cod(&bd_addr, COD_HID_POINTING)) {
 /* Remove Device as bonded in nvram as authentication failed */
            BTIF_TRACE_DEBUG("%s(): removing hid pointing device from nvram", __FUNCTION__);
            btif_storage_remove_bonded_device(&bd_addr);
 }
        bond_state_changed(status, &bd_addr, state);
 }
}

static inline int btif_hl_close_select_thread(void)
{

int result = 0;
char sig_on = btif_hl_signal_select_exit;
BTIF_TRACE_DEBUG("btif_hl_signal_select_exit");
    result = send(signal_fds[1], &sig_on, sizeof(sig_on), 0);
if (btif_is_enabled())
{
/* Wait for the select_thread_id to exit if BT is still enabled
and only this profile getting  cleaned up*/
if (select_thread_id != -1) {
pthread_join(select_thread_id, NULL);
select_thread_id = -1;
}
}
list_free(soc_queue);
return result;
}

static void sync_lockstate_on_connect(btif_hh_device_t *p_dev)
{
int keylockstates;

BTIF_TRACE_EVENT("%s: Syncing keyboard lock states after "\
"reconnect...",__FUNCTION__);
/*If the device is connected, update keyboard state */
update_keyboard_lockstates(p_dev);

/*Check if the lockstate of caps,scroll,num is set.
If so, send a report to the kernel
so the lockstate is in sync */
keylockstates = get_keylockstates();
if (keylockstates)
{

BTIF_TRACE_DEBUG("%s: Sending hid report to kernel "\
"indicating lock key state 0x%x",__FUNCTION__,
keylockstates);
        usleep(200000);
toggle_os_keylockstates(p_dev->fd, keylockstates);
}
else
{
BTIF_TRACE_DEBUG("%s: NOT sending hid report to kernel "\
"indicating lock key state 0x%x",__FUNCTION__,
keylockstates);
}
}

static void btif_jni_associate(UNUSED_ATTR uint16_t event, UNUSED_ATTR char *p_param) {
  BTIF_TRACE_DEBUG("%s Associating thread to JVM", __func__);
  HAL_CBACK(bt_hal_cbacks, thread_evt_cb, ASSOCIATE_JVM);
}

static void adev_close_input_stream(struct audio_hw_device *dev,
 struct audio_stream_in *stream)
{
 struct a2dp_audio_device *a2dp_dev = (struct a2dp_audio_device *)dev;
 struct a2dp_stream_in* in = (struct a2dp_stream_in *)stream;
 a2dp_state_t state = in->common.state;

    INFO("closing input (state %d)", state);

 if ((state == AUDIO_A2DP_STATE_STARTED) || (state == AUDIO_A2DP_STATE_STOPPING))
        stop_audio_datapath(&in->common);

    skt_disconnect(in->common.ctrl_fd);
    free(stream);
    a2dp_dev->input = NULL;

    DEBUG("done");
}

static inline void byte2hex(const char* data, char** str)
{
 **str = hex_table[(*data >> 4) & 0xf];
 ++*str;
 **str = hex_table[*data & 0xf];
 ++*str;
}

static void btif_hl_proc_create_ind(tBTA_HL *p_data){
 btif_hl_app_cb_t *p_acb;
 btif_hl_mcl_cb_t *p_mcb;
    tBTA_HL_MDEP            *p_mdep;
    UINT8                   orig_app_idx, mcl_idx, mdep_cfg_idx;
    BOOLEAN                 first_reliable_exist;
    BOOLEAN                 success = TRUE;
    tBTA_HL_DCH_CFG         rsp_cfg = BTA_HL_DCH_CFG_UNKNOWN;
    tBTA_HL_DCH_CREATE_RSP  rsp_code = BTA_HL_DCH_CREATE_RSP_CFG_REJ;
    tBTA_HL_DCH_CREATE_RSP_PARAM create_rsp_param;

    BTIF_TRACE_DEBUG("%s", __FUNCTION__);

    btif_hl_find_app_idx_using_mdepId(p_data->dch_create_ind.local_mdep_id,&orig_app_idx);
 if (btif_hl_find_mcl_idx(orig_app_idx, p_data->dch_create_ind.bd_addr, &mcl_idx))
 {
        p_acb =BTIF_HL_GET_APP_CB_PTR(orig_app_idx);
        p_mcb =BTIF_HL_GET_MCL_CB_PTR(orig_app_idx, mcl_idx);

 if (btif_hl_find_mdep_cfg_idx(orig_app_idx, p_data->dch_create_ind.local_mdep_id, &mdep_cfg_idx))
 {
            p_mdep = &(p_acb->sup_feature.mdep[mdep_cfg_idx]);
            first_reliable_exist = btif_hl_is_the_first_reliable_existed(orig_app_idx, mcl_idx);
 switch (p_mdep->mdep_cfg.mdep_role)
 {
 case BTA_HL_MDEP_ROLE_SOURCE:
 if (p_data->dch_create_ind.cfg == BTA_HL_DCH_CFG_NO_PREF)
 {
 if (first_reliable_exist)
 {
                            rsp_cfg = p_acb->channel_type[mdep_cfg_idx];
 }
 else
 {
                            rsp_cfg = BTA_HL_DCH_CFG_RELIABLE;
 }
                        rsp_code = BTA_HL_DCH_CREATE_RSP_SUCCESS;
 }

 break;
 case BTA_HL_MDEP_ROLE_SINK:

                    BTIF_TRACE_DEBUG("btif_hl_proc_create_ind:BTA_HL_MDEP_ROLE_SINK");
 if ((p_data->dch_create_ind.cfg  == BTA_HL_DCH_CFG_RELIABLE) ||
 (first_reliable_exist && (p_data->dch_create_ind.cfg  == BTA_HL_DCH_CFG_STREAMING)))
 {
                        rsp_code = BTA_HL_DCH_CREATE_RSP_SUCCESS;
                        rsp_cfg = p_data->dch_create_ind.cfg;
                        BTIF_TRACE_DEBUG("btif_hl_proc_create_ind:BTA_HL_MDEP_ROLE_SINK cfg = %d",rsp_cfg);
 }
 break;
 default:
 break;
 }
 }
 }
 else
 {
        success = FALSE;
 }

 if (success)
 {
        BTIF_TRACE_DEBUG("create response rsp_code=%d rsp_cfg=%d", rsp_code, rsp_cfg );
        create_rsp_param.local_mdep_id = p_data->dch_create_ind.local_mdep_id;
        create_rsp_param.mdl_id = p_data->dch_create_ind.mdl_id;
        create_rsp_param.rsp_code = rsp_code;
        create_rsp_param.cfg_rsp = rsp_cfg;
        BTA_HlDchCreateRsp(p_mcb->mcl_handle, &create_rsp_param);
 }
}

static void btif_dm_cb_create_bond(bt_bdaddr_t *bd_addr, tBTA_TRANSPORT transport)
{
    BOOLEAN is_hid = check_cod(bd_addr, COD_HID_POINTING);
    bond_state_changed(BT_STATUS_SUCCESS, bd_addr, BT_BOND_STATE_BONDING);

#if BLE_INCLUDED == TRUE
 int device_type;
 int addr_type;
 bdstr_t bdstr;
    bdaddr_to_string(bd_addr, bdstr, sizeof(bdstr));
 if (transport == BT_TRANSPORT_LE)
 {
 if (!btif_config_get_int((char const *)&bdstr,"DevType", &device_type))
 {
            btif_config_set_int(bdstr, "DevType", BT_DEVICE_TYPE_BLE);
 }
 if (btif_storage_get_remote_addr_type(bd_addr, &addr_type) != BT_STATUS_SUCCESS)
 {
            btif_storage_set_remote_addr_type(bd_addr, BLE_ADDR_PUBLIC);
 }
 }
 if((btif_config_get_int((char const *)&bdstr,"DevType", &device_type) &&
 (btif_storage_get_remote_addr_type(bd_addr, &addr_type) == BT_STATUS_SUCCESS) &&
 (device_type & BT_DEVICE_TYPE_BLE) == BT_DEVICE_TYPE_BLE) || (transport == BT_TRANSPORT_LE))
 {
        BTA_DmAddBleDevice(bd_addr->address, addr_type, device_type);
 }
#endif

#if BLE_INCLUDED == TRUE
 if(is_hid && (device_type & BT_DEVICE_TYPE_BLE) == 0)
#else
 if(is_hid)
#endif
 {
 int status;
        status = btif_hh_connect(bd_addr);
 if(status != BT_STATUS_SUCCESS)
            bond_state_changed(status, bd_addr, BT_BOND_STATE_NONE);
 }
 else
 {
        BTA_DmBondByTransport((UINT8 *)bd_addr->address, transport);
 }
 /*  Track  originator of bond creation  */
    pairing_cb.is_local_initiated = TRUE;

}

int btif_hl_update_maxfd(int max_org_s) {
 int maxfd = max_org_s;

    BTIF_TRACE_DEBUG("btif_hl_update_maxfd max_org_s= %d", max_org_s);
 for (const list_node_t *node = list_begin(soc_queue);
            node != list_end(soc_queue); node = list_next(node)) {
 btif_hl_soc_cb_t *p_scb = list_node(node);
 if (maxfd < p_scb->max_s) {
            maxfd = p_scb->max_s;
            BTIF_TRACE_DEBUG("btif_hl_update_maxfd maxfd=%d", maxfd);
 }
 }

    BTIF_TRACE_DEBUG("btif_hl_update_maxfd final *p_max_s=%d", maxfd);
 return maxfd;
}

static void btif_hl_proc_cb_evt(UINT16 event, char* p_param){

 btif_hl_evt_cb_t *p_data = (btif_hl_evt_cb_t *)p_param;
 bt_bdaddr_t                     bd_addr;
 bthl_channel_state_t            state=BTHL_CONN_STATE_DISCONNECTED;
    BOOLEAN                         send_chan_cb=TRUE;
    tBTA_HL_REG_PARAM               reg_param;
 btif_hl_app_cb_t *p_acb;
 bthl_app_reg_state_t            reg_state = BTHL_APP_REG_STATE_REG_FAILED;
    UINT8                           preg_idx;
 bt_status_t                     bt_status;

    BTIF_TRACE_DEBUG("%s event %d", __FUNCTION__, event);
    btif_hl_display_calling_process_name();

 switch (event)
 {
 case BTIF_HL_SEND_CONNECTED_CB:
 case BTIF_HL_SEND_DISCONNECTED_CB:
 if (p_data->chan_cb.cb_state == BTIF_HL_CHAN_CB_STATE_CONNECTED_PENDING)
                state = BTHL_CONN_STATE_CONNECTED;
 else if (p_data->chan_cb.cb_state == BTIF_HL_CHAN_CB_STATE_DISCONNECTED_PENDING)
                state = BTHL_CONN_STATE_DISCONNECTED;
 else
                send_chan_cb = FALSE;

 if (send_chan_cb)
 {
                btif_hl_copy_bda(&bd_addr, p_data->chan_cb.bd_addr);
                BTIF_TRACE_DEBUG("state callbk: ch_id=0x%08x cb_state=%d state=%d  fd=%d",
                                  p_data->chan_cb.channel_id,
                                  p_data->chan_cb.cb_state,
                                  state,  p_data->chan_cb.fd);
                btif_hl_display_bt_bda(&bd_addr);
                BTIF_HL_CALL_CBACK(bt_hl_callbacks, channel_state_cb,  p_data->chan_cb.app_id,
 &bd_addr, p_data->chan_cb.mdep_cfg_index,
                                   p_data->chan_cb.channel_id, state, p_data->chan_cb.fd );
 }

 break;
 case BTIF_HL_REG_APP:
            p_acb  = BTIF_HL_GET_APP_CB_PTR(p_data->reg.app_idx);
            BTIF_TRACE_DEBUG("Rcv BTIF_HL_REG_APP app_idx=%d reg_pending=%d", p_data->reg.app_idx, p_acb->reg_pending);
 if (btif_hl_get_state() == BTIF_HL_STATE_ENABLED && p_acb->reg_pending)
 {
                BTIF_TRACE_DEBUG("Rcv BTIF_HL_REG_APP reg_counter=%d",reg_counter);
                p_acb->reg_pending = FALSE;
                reg_param.dev_type = p_acb->dev_type;
                reg_param.sec_mask = BTA_SEC_AUTHENTICATE | BTA_SEC_ENCRYPT;
                reg_param.p_srv_name = p_acb->srv_name;
                reg_param.p_srv_desp = p_acb->srv_desp;
                reg_param.p_provider_name = p_acb->provider_name;
                btif_hl_proc_reg_request (p_data->reg.app_idx, p_acb->app_id, &reg_param, btif_hl_cback);
 }
 else
 {
                BTIF_TRACE_DEBUG("reg request is processed state=%d reg_pending=%d", btif_hl_get_state(), p_acb->reg_pending);
 }

 break;

 case BTIF_HL_UNREG_APP:
            BTIF_TRACE_DEBUG("Rcv BTIF_HL_UNREG_APP app_idx=%d", p_data->unreg.app_idx );
            p_acb = BTIF_HL_GET_APP_CB_PTR(p_data->unreg.app_idx);
 if (btif_hl_get_state() == BTIF_HL_STATE_ENABLED)
 {
 if(reg_counter >= 1)
                    BTA_HlUpdate(p_acb->app_id,NULL,FALSE,NULL);
 else
                    BTA_HlDeregister(p_acb->app_id, p_acb->app_handle);
 }
 break;
 case BTIF_HL_UPDATE_MDL:
            BTIF_TRACE_DEBUG("Rcv BTIF_HL_UPDATE_MDL app_idx=%d", p_data->update_mdl.app_idx );
            p_acb = BTIF_HL_GET_APP_CB_PTR(p_data->update_mdl.app_idx);
 break;

 default:
            BTIF_TRACE_ERROR("Unknown event %d", event);
 break;
 }
}

BOOLEAN btif_hl_load_mdl_config (UINT8 app_id, UINT8 buffer_size,
                                 tBTA_HL_MDL_CFG *p_mdl_buf ){
    UINT8 app_idx;
    BOOLEAN result = FALSE;
 btif_hl_app_cb_t *p_acb;
    tBTA_HL_MDL_CFG *p;
 int i;
    BTIF_TRACE_DEBUG("%s", __FUNCTION__);

 if (btif_hl_find_app_idx(app_id, &app_idx))
 {
        p_acb  = BTIF_HL_GET_APP_CB_PTR(app_idx);
 for (i=0, p=p_mdl_buf; i<buffer_size; i++, p++)
 {
            memcpy(p, &p_acb->mdl_cfg[i].base, sizeof(tBTA_HL_MDL_CFG));
 }
        result = TRUE;
 }

    BTIF_TRACE_DEBUG("result=%d", result);
 return result;
}

BOOLEAN btif_hl_find_mcl_idx_using_app_idx( tBTA_HL_MCL_HANDLE mcl_handle,
                                           UINT8 p_app_idx, UINT8 *p_mcl_idx){
 btif_hl_app_cb_t *p_acb;
    BOOLEAN         found=FALSE;
    UINT8 j;

    p_acb =BTIF_HL_GET_APP_CB_PTR(p_app_idx);
 for (j=0; j < BTA_HL_NUM_MCLS ; j++)
 {
 if (p_acb->mcb[j].in_use &&
 (p_acb->mcb[j].mcl_handle == mcl_handle))
 {
            found = TRUE;
 *p_mcl_idx = j;
 break;
 }
 }
    BTIF_TRACE_DEBUG("%s found=%dmcl_idx=%d",__FUNCTION__,
                      found, j);
 return found;
}

static bt_status_t send_data (bt_bdaddr_t *bd_addr, char* data)
{
    CHECK_BTHH_INIT();
 btif_hh_device_t *p_dev;
    BD_ADDR* bda = (BD_ADDR*) bd_addr;

    BTIF_TRACE_DEBUG("%s", __FUNCTION__);

    BTIF_TRACE_DEBUG("addr = %02X:%02X:%02X:%02X:%02X:%02X",
 (*bda)[0], (*bda)[1], (*bda)[2], (*bda)[3], (*bda)[4], (*bda)[5]);

 if (btif_hh_cb.status == BTIF_HH_DISABLED) {
        BTIF_TRACE_ERROR("%s: Error, HH status = %d", __FUNCTION__, btif_hh_cb.status);
 return BT_STATUS_FAIL;
 }

    p_dev = btif_hh_find_connected_dev_by_bda(bd_addr);
 if (p_dev == NULL) {
        BTIF_TRACE_ERROR("%s: Error, device %02X:%02X:%02X:%02X:%02X:%02X not opened.",
 (*bda)[0], (*bda)[1], (*bda)[2], (*bda)[3], (*bda)[4], (*bda)[5]);
 return BT_STATUS_FAIL;
 }

 else {
 int    hex_bytes_filled;
        UINT8  *hexbuf;
        UINT16 len = (strlen(data) + 1) / 2;

        hexbuf = GKI_getbuf(len);
 if (hexbuf == NULL) {
            BTIF_TRACE_ERROR("%s: Error, failed to allocate RPT buffer, len = %d",
                __FUNCTION__, len);
 return BT_STATUS_FAIL;
 }

 /* Build a SendData data buffer */
        memset(hexbuf, 0, len);
        hex_bytes_filled = ascii_2_hex(data, len, hexbuf);
        BTIF_TRACE_ERROR("Hex bytes filled, hex value: %d, %d", hex_bytes_filled, len);

 if (hex_bytes_filled) {
            BT_HDR* p_buf = create_pbuf(hex_bytes_filled, hexbuf);
 if (p_buf == NULL) {
                BTIF_TRACE_ERROR("%s: Error, failed to allocate RPT buffer, len = %d",
                                  __FUNCTION__, hex_bytes_filled);
                GKI_freebuf(hexbuf);
 return BT_STATUS_FAIL;
 }
            p_buf->layer_specific = BTA_HH_RPTT_OUTPUT;
            BTA_HhSendData(p_dev->dev_handle, *bda, p_buf);
            GKI_freebuf(hexbuf);
 return BT_STATUS_SUCCESS;
 }
        GKI_freebuf(hexbuf);
 return BT_STATUS_FAIL;
 }
}

BOOLEAN btif_hl_find_mcl_idx_using_handle( tBTA_HL_MCL_HANDLE mcl_handle,
                                           UINT8 *p_app_idx, UINT8 *p_mcl_idx){
 btif_hl_app_cb_t *p_acb;
    BOOLEAN         found=FALSE;
    UINT8 i,j;

 for (i=0; i<BTA_HL_NUM_APPS; i++)
 {
        p_acb =BTIF_HL_GET_APP_CB_PTR(i);
 for (j=0; j < BTA_HL_NUM_MCLS ; j++)
 {
 if (p_acb->mcb[j].in_use)
                BTIF_TRACE_DEBUG("btif_hl_find_mcl_idx_using_handle:app_idx=%d,"
 "mcl_idx =%d mcl_handle=%d",i,j,p_acb->mcb[j].mcl_handle);
 if (p_acb->mcb[j].in_use &&
 (p_acb->mcb[j].mcl_handle == mcl_handle))
 {
                found = TRUE;
 *p_app_idx = i;
 *p_mcl_idx = j;
 break;
 }
 }
 }
    BTIF_TRACE_DEBUG("%s found=%d app_idx=%d mcl_idx=%d",__FUNCTION__,
                      found, i, j);
 return found;
}

static void btif_hl_proc_reg_request(UINT8 app_idx, UINT8  app_id,
                                     tBTA_HL_REG_PARAM *p_reg_param,
                                     tBTA_HL_CBACK *p_cback){
    UNUSED(p_cback);

    BTIF_TRACE_DEBUG("%s app_idx=%d app_id=%d", __FUNCTION__, app_idx, app_id);

 if(reg_counter >1)
 {
        BTIF_TRACE_DEBUG("btif_hl_proc_reg_request: calling uPDATE");
        BTA_HlUpdate(app_id, p_reg_param,TRUE, btif_hl_cback);
 }
 else
        BTA_HlRegister(app_id, p_reg_param, btif_hl_cback);
}

static future_t *start_up(void) {
  LOG_INFO("%s", __func__);

  command_credits = 1;
  firmware_is_configured = false;

  pthread_mutex_init(&commands_pending_response_lock, NULL);

 period_ms_t startup_timeout_ms;
 char timeout_prop[PROPERTY_VALUE_MAX];
 if (!property_get("bluetooth.enable_timeout_ms", timeout_prop, STRING_VALUE_OF(DEFAULT_STARTUP_TIMEOUT_MS))
 || (startup_timeout_ms = atoi(timeout_prop)) < 100)
    startup_timeout_ms = DEFAULT_STARTUP_TIMEOUT_MS;

  startup_timer = non_repeating_timer_new(startup_timeout_ms, startup_timer_expired, NULL);
 if (!startup_timer) {
    LOG_ERROR("%s unable to create startup timer.", __func__);
 goto error;
 }

  non_repeating_timer_restart(startup_timer);

  epilog_timer = non_repeating_timer_new(EPILOG_TIMEOUT_MS, epilog_timer_expired, NULL);
 if (!epilog_timer) {
    LOG_ERROR("%s unable to create epilog timer.", __func__);
 goto error;
 }

  command_response_timer = non_repeating_timer_new(COMMAND_PENDING_TIMEOUT, command_timed_out, NULL);
 if (!command_response_timer) {
    LOG_ERROR("%s unable to create command response timer.", __func__);
 goto error;
 }

  command_queue = fixed_queue_new(SIZE_MAX);
 if (!command_queue) {
    LOG_ERROR("%s unable to create pending command queue.", __func__);
 goto error;
 }

  packet_queue = fixed_queue_new(SIZE_MAX);
 if (!packet_queue) {
    LOG_ERROR("%s unable to create pending packet queue.", __func__);
 goto error;
 }

  thread = thread_new("hci_thread");
 if (!thread) {
    LOG_ERROR("%s unable to create thread.", __func__);
 goto error;
 }

  commands_pending_response = list_new(NULL);
 if (!commands_pending_response) {
    LOG_ERROR("%s unable to create list for commands pending response.", __func__);
 goto error;
 }

  memset(incoming_packets, 0, sizeof(incoming_packets));

  packet_fragmenter->init(&packet_fragmenter_callbacks);

  fixed_queue_register_dequeue(command_queue, thread_get_reactor(thread), event_command_ready, NULL);
  fixed_queue_register_dequeue(packet_queue, thread_get_reactor(thread), event_packet_ready, NULL);

  vendor->open(btif_local_bd_addr.address, &interface);
  hal->init(&hal_callbacks, thread);
  low_power_manager->init(thread);

  vendor->set_callback(VENDOR_CONFIGURE_FIRMWARE, firmware_config_callback);
  vendor->set_callback(VENDOR_CONFIGURE_SCO, sco_config_callback);
  vendor->set_callback(VENDOR_DO_EPILOG, epilog_finished_callback);

 if (!hci_inject->open(&interface)) {
 }

 int power_state = BT_VND_PWR_OFF;
#if (defined (BT_CLEAN_TURN_ON_DISABLED) && BT_CLEAN_TURN_ON_DISABLED == TRUE)
  LOG_WARN("%s not turning off the chip before turning on.", __func__);

#else
  vendor->send_command(VENDOR_CHIP_POWER_CONTROL, &power_state);
#endif
  power_state = BT_VND_PWR_ON;
  vendor->send_command(VENDOR_CHIP_POWER_CONTROL, &power_state);

  startup_future = future_new();
  LOG_DEBUG("%s starting async portion", __func__);
  thread_post(thread, event_finish_startup, NULL);
 return startup_future;
error:;
  shut_down(); // returns NULL so no need to wait for it
 return future_new_immediate(FUTURE_FAIL);
}

bt_status_t btif_shutdown_bluetooth(void)
{
    BTIF_TRACE_DEBUG("%s", __FUNCTION__);

    btif_transfer_context(btif_jni_disassociate, 0, NULL, 0, NULL);

    btif_queue_release();

    thread_free(bt_jni_workqueue_thread);
    bt_jni_workqueue_thread = NULL;

    bte_main_shutdown();

    btif_dut_mode = 0;

    BTIF_TRACE_DEBUG("%s done", __FUNCTION__);

 return BT_STATUS_SUCCESS;
}

static void btif_hl_clean_pcb(btif_hl_pending_chan_cb_t *p_pcb)
{
    BTIF_TRACE_DEBUG("%s", __FUNCTION__ );
    memset(p_pcb, 0 , sizeof(btif_hl_pending_chan_cb_t));
}

socket_t *socket_new_from_fd(int fd) {
  assert(fd != INVALID_FD);

 socket_t *ret = (socket_t *)osi_calloc(sizeof(socket_t));
 if (!ret) {
    LOG_ERROR("%s unable to allocate memory for socket.", __func__);
 return NULL;
 }

  ret->fd = fd;
 return ret;
}

static ssize_t in_read(struct audio_stream_in *stream, void* buffer,
size_t bytes)
{
struct a2dp_stream_in *in = (struct a2dp_stream_in *)stream;
int read;

DEBUG("read %zu bytes, state: %d", bytes, in->common.state);

if (in->common.state == AUDIO_A2DP_STATE_SUSPENDED)
{
DEBUG("stream suspended");
return -1;
}

/* only allow autostarting if we are in stopped or standby */
if ((in->common.state == AUDIO_A2DP_STATE_STOPPED) ||
(in->common.state == AUDIO_A2DP_STATE_STANDBY))
{
pthread_mutex_lock(&in->common.lock);

if (start_audio_datapath(&in->common) < 0)
{
/* emulate time this write represents to avoid very fast write
failures during transition periods or remote suspend */

int us_delay = calc_audiotime(in->common.cfg, bytes);


DEBUG("emulate a2dp read delay (%d us)", us_delay);

            usleep(us_delay);
pthread_mutex_unlock(&in->common.lock);
return -1;
}

pthread_mutex_unlock(&in->common.lock);
}
else if (in->common.state != AUDIO_A2DP_STATE_STARTED)
{
ERROR("stream not in stopped or standby");
return -1;
}

read = skt_read(in->common.audio_fd, buffer, bytes);

if (read == -1)
{
skt_disconnect(in->common.audio_fd);
in->common.audio_fd = AUDIO_SKT_DISCONNECTED;
in->common.state = AUDIO_A2DP_STATE_STOPPED;
} else if (read == 0) {
DEBUG("read time out - return zeros");
memset(buffer, 0, bytes);
read = bytes;
}

DEBUG("read %d bytes out of %zu bytes", read, bytes);
return read;
}

static void btif_hl_proc_dch_open_ind(tBTA_HL *p_data)

{
 btif_hl_mdl_cb_t *p_dcb;
    UINT8                    orig_app_idx, mcl_idx, mdl_idx, mdep_cfg_idx;
    BOOLEAN close_dch = FALSE;

    BTIF_TRACE_DEBUG("%s", __FUNCTION__);

    btif_hl_find_app_idx_using_mdepId(p_data->dch_open_ind.local_mdep_id,&orig_app_idx);

 if (btif_hl_find_mcl_idx_using_app_idx(p_data->dch_open_ind.mcl_handle, orig_app_idx, &mcl_idx ))
 {
        BTIF_HL_GET_APP_CB_PTR(orig_app_idx);
        BTIF_HL_GET_MCL_CB_PTR(orig_app_idx, mcl_idx);

 if (btif_hl_find_avail_mdl_idx(orig_app_idx, mcl_idx, &mdl_idx))
 {
            p_dcb = BTIF_HL_GET_MDL_CB_PTR(orig_app_idx, mcl_idx, mdl_idx);

 if (btif_hl_find_mdep_cfg_idx(orig_app_idx, p_data->dch_open_ind.local_mdep_id, &mdep_cfg_idx))
 {
                p_dcb->in_use               = TRUE;
                p_dcb->mdl_handle           =  p_data->dch_open_ind.mdl_handle;
                p_dcb->local_mdep_cfg_idx   = mdep_cfg_idx;
                p_dcb->local_mdep_id        = p_data->dch_open_ind.local_mdep_id;
                p_dcb->mdl_id               = p_data->dch_open_ind.mdl_id;
                p_dcb->dch_mode             = p_data->dch_open_ind.dch_mode;
                p_dcb->dch_mode             = p_data->dch_open_ind.dch_mode;
                p_dcb->is_the_first_reliable = p_data->dch_open_ind.first_reliable;
                p_dcb->mtu                  = p_data->dch_open_ind.mtu;

 if(btif_hl_find_channel_id_using_mdl_id(orig_app_idx,p_dcb->mdl_id , &p_dcb->channel_id))
 {
                    BTIF_TRACE_DEBUG(" app_idx=%d mcl_idx=%d mdl_idx=%d channel_id=%d",
                                        orig_app_idx, mcl_idx, mdl_idx, p_dcb->channel_id  );
 if (!btif_hl_create_socket(orig_app_idx, mcl_idx, mdl_idx))
 {
                        BTIF_TRACE_ERROR("Unable to create socket");
                        close_dch = TRUE;
 }
 }
 else
 {
                    BTIF_TRACE_ERROR("Unable find channel id for mdl_id=0x%x", p_dcb->mdl_id  );
                    close_dch = TRUE;
 }
 }
 else
 {
                BTIF_TRACE_ERROR("INVALID_LOCAL_MDEP_ID mdep_id=%d",p_data->dch_open_cfm.local_mdep_id);
                close_dch = TRUE;
 }

 if (close_dch)
                btif_hl_clean_mdl_cb(p_dcb);
 }
 else
            close_dch = TRUE;
 }
 else
        close_dch = TRUE;

 if (close_dch)
        BTA_HlDchClose(p_data->dch_open_cfm.mdl_handle);
}

static int out_set_format(struct audio_stream *stream, audio_format_t format)
{
    UNUSED(format);
 struct a2dp_stream_out *out = (struct a2dp_stream_out *)stream;
    DEBUG("setting format not yet supported (0x%x)", format);
 return -ENOSYS;
}

int btsock_thread_wakeup(int h)
{
if(h < 0 || h >= MAX_THREAD)
{
APPL_TRACE_ERROR("invalid bt thread handle:%d", h);
return FALSE;
}
if(ts[h].cmd_fdw == -1)
{
APPL_TRACE_ERROR("thread handle:%d, cmd socket is not created", h);

return FALSE;
}
sock_cmd_t cmd = {CMD_WAKEUP, 0, 0, 0, 0};
    return send(ts[h].cmd_fdw, &cmd, sizeof(cmd), 0) == sizeof(cmd);
}

static bt_status_t btpan_enable(int local_role)
{
#if BTA_PAN_INCLUDED == TRUE
    BTIF_TRACE_DEBUG("%s - local_role: %d", __func__, local_role);
 int bta_pan_role = btpan_role_to_bta(local_role);
    BTA_PanSetRole(bta_pan_role, &bta_panu_info, NULL, &bta_pan_nap_info);
    btpan_dev_local_role = local_role;
 return BT_STATUS_SUCCESS;
#else
 return BT_STATUS_FAIL;
#endif
}

static future_t *shut_down() {
  LOG_INFO("%s", __func__);

  hci_inject->close();

 if (thread) {
 if (firmware_is_configured) {
      non_repeating_timer_restart(epilog_timer);
      thread_post(thread, event_epilog, NULL);
 } else {
      thread_stop(thread);
 }

    thread_join(thread);
 }

  fixed_queue_free(command_queue, osi_free);
  fixed_queue_free(packet_queue, buffer_allocator->free);
  list_free(commands_pending_response);

  pthread_mutex_destroy(&commands_pending_response_lock);

  packet_fragmenter->cleanup();

  non_repeating_timer_free(epilog_timer);
  non_repeating_timer_free(command_response_timer);
  non_repeating_timer_free(startup_timer);

  epilog_timer = NULL;
  command_response_timer = NULL;

  low_power_manager->cleanup();
  hal->close();

 int power_state = BT_VND_PWR_OFF;
  vendor->send_command(VENDOR_CHIP_POWER_CONTROL, &power_state);
  vendor->close();

  thread_free(thread);
  thread = NULL;
  firmware_is_configured = false;

 return NULL;
}

static void jv_dm_cback(tBTA_JV_EVT event, tBTA_JV *p_data, void *user_data) {
 uint32_t id = (uintptr_t)user_data;
 switch(event) {
 case BTA_JV_GET_SCN_EVT:
 {
      pthread_mutex_lock(&slot_lock);
 rfc_slot_t* rs = find_rfc_slot_by_id(id);
 int new_scn = p_data->scn;

 if(rs && (new_scn != 0))
 {
        rs->scn = new_scn;
 /* BTA_JvCreateRecordByUser will only create a record if a UUID is specified,
         * else it just allocate a RFC channel and start the RFCOMM thread - needed
         * for the java
         * layer to get a RFCOMM channel.
         * If uuid is null the create_sdp_record() will be called from Java when it
         * has received the RFCOMM and L2CAP channel numbers through the sockets.*/

 if(!send_app_scn(rs)){
          APPL_TRACE_DEBUG("send_app_scn() failed, close rs->id:%d", rs->id);
          cleanup_rfc_slot(rs);
 } else {
 if(rs->is_service_uuid_valid == true) {
            BTA_JvCreateRecordByUser((void *)rs->id);
 } else {
            APPL_TRACE_DEBUG("is_service_uuid_valid==false - don't set SDP-record, "
 "just start the RFCOMM server", rs->id);
            BTA_JvRfcommStartServer(rs->security, rs->role, rs->scn, MAX_RFC_SESSION,
                    rfcomm_cback, (void*)rs->id);
 }
 }
 } else if(rs) {
        APPL_TRACE_ERROR("jv_dm_cback: Error: allocate channel %d, slot found:%p", rs->scn, rs);
        cleanup_rfc_slot(rs);
 }
      pthread_mutex_unlock(&slot_lock);
 break;
 }
 case BTA_JV_GET_PSM_EVT:
 {
      APPL_TRACE_DEBUG("Received PSM: 0x%04x", p_data->psm);
      on_l2cap_psm_assigned(id, p_data->psm);
 break;
 }
 case BTA_JV_CREATE_RECORD_EVT: {
      pthread_mutex_lock(&slot_lock);

 rfc_slot_t *slot = find_rfc_slot_by_id(id);
 if (slot && create_server_sdp_record(slot)) {
        BTA_JvRfcommStartServer(slot->security, slot->role, slot->scn, MAX_RFC_SESSION, rfcomm_cback, (void *)(uintptr_t)slot->id);
 } else if(slot) {
        APPL_TRACE_ERROR("jv_dm_cback: cannot start server, slot found:%p", slot);
        cleanup_rfc_slot(slot);
 }

      pthread_mutex_unlock(&slot_lock);
 break;
 }

 case BTA_JV_DISCOVERY_COMP_EVT: {
      pthread_mutex_lock(&slot_lock);
 rfc_slot_t *slot = find_rfc_slot_by_id(id);
 if (p_data->disc_comp.status == BTA_JV_SUCCESS && p_data->disc_comp.scn) {
 if (slot && slot->f.doing_sdp_request) {
 if (BTA_JvRfcommConnect(slot->security, slot->role, p_data->disc_comp.scn, slot->addr.address, rfcomm_cback, (void *)(uintptr_t)slot->id) == BTA_JV_SUCCESS) {
            slot->scn = p_data->disc_comp.scn;
            slot->f.doing_sdp_request = false;
 if (!send_app_scn(slot))
              cleanup_rfc_slot(slot);
 } else {
            cleanup_rfc_slot(slot);
 }
 } else if (slot) {
          LOG_ERROR("%s SDP response returned but RFCOMM slot %d did not request SDP record.", __func__, id);
 }
 } else if (slot) {
        cleanup_rfc_slot(slot);
 }

      slot = find_rfc_slot_by_pending_sdp();
 if (slot) {
        tSDP_UUID sdp_uuid;
        sdp_uuid.len = 16;
        memcpy(sdp_uuid.uu.uuid128, slot->service_uuid, sizeof(sdp_uuid.uu.uuid128));
        BTA_JvStartDiscovery((uint8_t *)slot->addr.address, 1, &sdp_uuid, (void *)(uintptr_t)slot->id);
        slot->f.pending_sdp_request = false;
        slot->f.doing_sdp_request = true;
 }

      pthread_mutex_unlock(&slot_lock);
 break;
 }

 default:
      APPL_TRACE_DEBUG("unhandled event:%d, slot id:%d", event, id);
 break;
 }
}

static UINT8 opcode_from_pdu(UINT8 pdu)
{
    UINT8 opcode = 0;

 switch (pdu)
 {
 case AVRC_PDU_NEXT_GROUP:
 case AVRC_PDU_PREV_GROUP: /* pass thru */
        opcode  = AVRC_OP_PASS_THRU;
 break;

 default: /* vendor */
        opcode  = AVRC_OP_VENDOR;
 break;
 }

 return opcode;
}

const bthh_interface_t *btif_hh_get_interface()
{
    BTIF_TRACE_EVENT("%s", __FUNCTION__);
 return &bthhInterface;
}

ssize_t socket_bytes_available(const socket_t *socket) {

assert(socket != NULL);

int size = 0;
  if (ioctl(socket->fd, FIONREAD, &size) == -1)
return -1;
return size;
}

static uint16_t transmit_data_on(int fd, uint8_t *data, uint16_t length) {
assert(data != NULL);
assert(length > 0);


uint16_t transmitted_length = 0;
while (length > 0) {
    ssize_t ret = write(fd, data + transmitted_length, length);
switch (ret) {
case -1:
LOG_ERROR("In %s, error writing to the serial port with fd %d: %s", __func__, fd, strerror(errno));
return transmitted_length;
case 0:
// If we wrote nothing, don't loop more because we
// can't go to infinity or beyond
return transmitted_length;
default:
transmitted_length += ret;
length -= ret;
break;
}
}

return transmitted_length;
}

void btif_dm_set_oob_for_io_req(tBTA_OOB_DATA  *p_oob_data)
{
 if (oob_cb.sp_c[0] == 0 && oob_cb.sp_c[1] == 0 &&
        oob_cb.sp_c[2] == 0 && oob_cb.sp_c[3] == 0 )
 {
 *p_oob_data = FALSE;
 }
 else
 {
 *p_oob_data = TRUE;
 }
    BTIF_TRACE_DEBUG("btif_dm_set_oob_for_io_req *p_oob_data=%d", *p_oob_data);
}

static void btif_rc_upstreams_evt(UINT16 event, tAVRC_COMMAND *pavrc_cmd, UINT8 ctype, UINT8 label)
{
    BTIF_TRACE_EVENT("%s pdu: %s handle: 0x%x ctype:%x label:%x", __FUNCTION__,
        dump_rc_pdu(pavrc_cmd->pdu), btif_rc_cb.rc_handle, ctype, label);

 switch (event)
 {
 case AVRC_PDU_GET_PLAY_STATUS:
 {
            FILL_PDU_QUEUE(IDX_GET_PLAY_STATUS_RSP, ctype, label, TRUE)
            HAL_CBACK(bt_rc_callbacks, get_play_status_cb);
 }
 break;
 case AVRC_PDU_LIST_PLAYER_APP_ATTR:
 case AVRC_PDU_LIST_PLAYER_APP_VALUES:
 case AVRC_PDU_GET_CUR_PLAYER_APP_VALUE:
 case AVRC_PDU_SET_PLAYER_APP_VALUE:
 case AVRC_PDU_GET_PLAYER_APP_ATTR_TEXT:
 case AVRC_PDU_GET_PLAYER_APP_VALUE_TEXT:
 {
 /* TODO: Add support for Application Settings */
            send_reject_response (btif_rc_cb.rc_handle, label, pavrc_cmd->pdu, AVRC_STS_BAD_CMD);
 }
 break;
 case AVRC_PDU_GET_ELEMENT_ATTR:
 {
 btrc_media_attr_t element_attrs[BTRC_MAX_ELEM_ATTR_SIZE];
            UINT8 num_attr;
             memset(&element_attrs, 0, sizeof(element_attrs));
 if (pavrc_cmd->get_elem_attrs.num_attr == 0)
 {
 /* CT requests for all attributes */
 int attr_cnt;
                num_attr = BTRC_MAX_ELEM_ATTR_SIZE;
 for (attr_cnt = 0; attr_cnt < BTRC_MAX_ELEM_ATTR_SIZE; attr_cnt++)
 {
                    element_attrs[attr_cnt] = attr_cnt + 1;
 }
 }
 else if (pavrc_cmd->get_elem_attrs.num_attr == 0xFF)
 {
 /* 0xff indicates, no attributes requested - reject */
                send_reject_response (btif_rc_cb.rc_handle, label, pavrc_cmd->pdu,
                    AVRC_STS_BAD_PARAM);
 return;
 }
 else
 {
 int attr_cnt, filled_attr_count;

                num_attr = 0;
 /* Attribute IDs from 1 to AVRC_MAX_NUM_MEDIA_ATTR_ID are only valid,
                 * hence HAL definition limits the attributes to AVRC_MAX_NUM_MEDIA_ATTR_ID.
                 * Fill only valid entries.
                 */
 for (attr_cnt = 0; (attr_cnt < pavrc_cmd->get_elem_attrs.num_attr) &&
 (num_attr < AVRC_MAX_NUM_MEDIA_ATTR_ID); attr_cnt++)
 {
 if ((pavrc_cmd->get_elem_attrs.attrs[attr_cnt] > 0) &&
 (pavrc_cmd->get_elem_attrs.attrs[attr_cnt] <= AVRC_MAX_NUM_MEDIA_ATTR_ID))
 {
 /* Skip the duplicate entries : PTS sends duplicate entries for Fragment cases
                         */
 for (filled_attr_count = 0; filled_attr_count < num_attr; filled_attr_count++)
 {
 if (element_attrs[filled_attr_count] == pavrc_cmd->get_elem_attrs.attrs[attr_cnt])
 break;
 }
 if (filled_attr_count == num_attr)
 {
                            element_attrs[num_attr] = pavrc_cmd->get_elem_attrs.attrs[attr_cnt];
                            num_attr++;
 }
 }
 }
 }
            FILL_PDU_QUEUE(IDX_GET_ELEMENT_ATTR_RSP, ctype, label, TRUE);
            HAL_CBACK(bt_rc_callbacks, get_element_attr_cb, num_attr, element_attrs);
 }
 break;
 case AVRC_PDU_REGISTER_NOTIFICATION:
 {
 if(pavrc_cmd->reg_notif.event_id == BTRC_EVT_PLAY_POS_CHANGED &&
                pavrc_cmd->reg_notif.param == 0)
 {
                BTIF_TRACE_WARNING("%s Device registering position changed with illegal param 0.",
                    __FUNCTION__);
                send_reject_response (btif_rc_cb.rc_handle, label, pavrc_cmd->pdu, AVRC_STS_BAD_PARAM);
 /* de-register this notification for a rejected response */
                btif_rc_cb.rc_notif[BTRC_EVT_PLAY_POS_CHANGED - 1].bNotify = FALSE;
 return;
 }
            HAL_CBACK(bt_rc_callbacks, register_notification_cb, pavrc_cmd->reg_notif.event_id,
                pavrc_cmd->reg_notif.param);
 }
 break;
 case AVRC_PDU_INFORM_DISPLAY_CHARSET:
 {
            tAVRC_RESPONSE avrc_rsp;
            BTIF_TRACE_EVENT("%s() AVRC_PDU_INFORM_DISPLAY_CHARSET", __FUNCTION__);
 if(btif_rc_cb.rc_connected == TRUE)
 {
                memset(&(avrc_rsp.inform_charset), 0, sizeof(tAVRC_RSP));
                avrc_rsp.inform_charset.opcode=opcode_from_pdu(AVRC_PDU_INFORM_DISPLAY_CHARSET);
                avrc_rsp.inform_charset.pdu=AVRC_PDU_INFORM_DISPLAY_CHARSET;
                avrc_rsp.inform_charset.status=AVRC_STS_NO_ERROR;
                send_metamsg_rsp(btif_rc_cb.rc_handle, label, ctype, &avrc_rsp);
 }
 }
 break;
 default:
 {
        send_reject_response (btif_rc_cb.rc_handle, label, pavrc_cmd->pdu,
 (pavrc_cmd->pdu == AVRC_PDU_SEARCH)?AVRC_STS_SEARCH_NOT_SUP:AVRC_STS_BAD_CMD);
 return;
 }
 break;
 }

}

static void expect_data(eager_reader_t *reader, void *context) {
 char *data = (char *)context;
 int length = strlen(data);

 for (int i = 0; i < length; i++) {
 uint8_t byte;
    EXPECT_EQ((size_t)1, eager_reader_read(reader, &byte, 1, true));
    EXPECT_EQ(data[i], byte);
 }

  semaphore_post(done);
}

static bool send_app_connect_signal(int fd, const bt_bdaddr_t* addr, int channel, int status, int send_fd) {
 sock_connect_signal_t cs;
  cs.size = sizeof(cs);
  cs.bd_addr = *addr;
  cs.channel = channel;
  cs.status = status;
  cs.max_rx_packet_size = 0; // not used for RFCOMM
  cs.max_tx_packet_size = 0; // not used for RFCOMM
 if (send_fd == INVALID_FD)
 return sock_send_all(fd, (const uint8_t *)&cs, sizeof(cs)) == sizeof(cs);

 return sock_send_fd(fd, (const uint8_t *)&cs, sizeof(cs), send_fd) == sizeof(cs);
}

static void btsock_l2cap_free_l(l2cap_socket *sock)
{
 uint8_t *buf;
    l2cap_socket *t = socks;

 while(t && t != sock)
        t = t->next;

 if (!t) /* prever double-frees */
 return;

 if (sock->next)
        sock->next->prev = sock->prev;

 if (sock->prev)
        sock->prev->next = sock->next;
 else
        socks = sock->next;

    shutdown(sock->our_fd, SHUT_RDWR);
    close(sock->our_fd);
 if (sock->app_fd != -1) {
        close(sock->app_fd);
 } else {
        APPL_TRACE_ERROR("SOCK_LIST: free(id = %d) - NO app_fd!", sock->id);
 }

 while (packet_get_head_l(sock, &buf, NULL))
        osi_free(buf);

 if (sock->handle && (sock->server == FALSE)) {
 if (sock->fixed_chan)
            BTA_JvL2capCloseLE(sock->handle);
 else
            BTA_JvL2capClose(sock->handle);
 }
 if ((sock->channel >= 0) && (sock->server == TRUE)) {
 if (sock->fixed_chan) {
            BTA_JvFreeChannel(sock->channel, BTA_JV_CONN_TYPE_L2CAP_LE);
 } else {
            BTA_JvFreeChannel(sock->channel, BTA_JV_CONN_TYPE_L2CAP);
 }
 }

    APPL_TRACE_DEBUG("SOCK_LIST: free(id = %d)", sock->id);
    osi_free(sock);
}

static int in_set_gain(struct audio_stream_in *stream, float gain)
{
    UNUSED(stream);
    UNUSED(gain);

    FNLOG();
 return 0;
}

void btif_dm_on_disable()
{
 /* cancel any pending pairing requests */
 if (pairing_cb.state == BT_BOND_STATE_BONDING)
 {
 bt_bdaddr_t bd_addr;

        BTIF_TRACE_DEBUG("%s: Cancel pending pairing request", __FUNCTION__);
        bdcpy(bd_addr.address, pairing_cb.bd_addr);
        btif_dm_cancel_bond(&bd_addr);
 }
}

static void btsnoop_write_packet(packet_type_t type, const uint8_t *packet, bool is_received) {
 int length_he = 0;
 int length;
 int flags;
 int drops = 0;
 switch (type) {
 case kCommandPacket:
      length_he = packet[2] + 4;
      flags = 2;
 break;
 case kAclPacket:
      length_he = (packet[3] << 8) + packet[2] + 5;
      flags = is_received;
 break;
 case kScoPacket:
      length_he = packet[2] + 4;
      flags = is_received;
 break;
 case kEventPacket:
      length_he = packet[1] + 3;
      flags = 3;
 break;
 }

 uint64_t timestamp = btsnoop_timestamp();
 uint32_t time_hi = timestamp >> 32;
 uint32_t time_lo = timestamp & 0xFFFFFFFF;

  length = htonl(length_he);
  flags = htonl(flags);
  drops = htonl(drops);
  time_hi = htonl(time_hi);
  time_lo = htonl(time_lo);

  btsnoop_write(&length, 4);
  btsnoop_write(&length, 4);
  btsnoop_write(&flags, 4);
  btsnoop_write(&drops, 4);
  btsnoop_write(&time_hi, 4);
  btsnoop_write(&time_lo, 4);
  btsnoop_write(&type, 1);
  btsnoop_write(packet, length_he - 1);
}

void btif_adapter_properties_evt(bt_status_t status, uint32_t num_props,
 bt_property_t *p_props)
{
    HAL_CBACK(bt_hal_cbacks, adapter_properties_cb,
                     status, num_props, p_props);

}

static void btpan_jni_cleanup()
{
    pan_disable();
    jni_initialized = false;
}

static int adev_set_mode(struct audio_hw_device *dev, int mode)
{
    UNUSED(dev);
    UNUSED(mode);

    FNLOG();

 return 0;
}

static void on_cl_l2cap_psm_connect_l(tBTA_JV_L2CAP_OPEN *p_open, l2cap_socket *sock)
{
    bd_copy(sock->addr.address, p_open->rem_bda, 0);

 if (!send_app_psm_or_chan_l(sock)) {
        APPL_TRACE_ERROR("send_app_psm_or_chan_l failed");
 return;
 }

 if (send_app_connect_signal(sock->our_fd, &sock->addr, sock->channel, 0, -1, p_open->tx_mtu)) {
        APPL_TRACE_DEBUG("on_l2cap_connect_ind, connect signal sent, slot id:%d, psm:%d,"
 " server:%d", sock->id, sock->channel, sock->server);
        btsock_thread_add_fd(pth, sock->our_fd, BTSOCK_L2CAP, SOCK_THREAD_FD_RD, sock->id);
        sock->connected = TRUE;
 }
 else APPL_TRACE_ERROR("send_app_connect_signal failed");
}

static void on_l2cap_data_ind(tBTA_JV *evt, uint32_t id)
{
    l2cap_socket *sock;

    pthread_mutex_lock(&state_lock);
    sock = btsock_l2cap_find_by_id_l(id);
 if (sock) {
 if (sock->fixed_chan) { /* we do these differently */

            tBTA_JV_LE_DATA_IND *p_le_data_ind = &evt->le_data_ind;
            BT_HDR *p_buf = p_le_data_ind->p_buf;
 uint8_t *data = (uint8_t*)(p_buf + 1) + p_buf->offset;

 if (packet_put_tail_l(sock, data, p_buf->len))
                btsock_thread_add_fd(pth, sock->our_fd, BTSOCK_L2CAP, SOCK_THREAD_FD_WR, sock->id);
 else {//connection must be dropped
                APPL_TRACE_DEBUG("on_l2cap_data_ind() unable to push data to socket - closing"
 " fixed channel");
                BTA_JvL2capCloseLE(sock->handle);
                btsock_l2cap_free_l(sock);
 }

 } else {

            tBTA_JV_DATA_IND *p_data_ind = &evt->data_ind;
            UINT8 buffer[L2CAP_MAX_SDU_LENGTH];
            UINT32  count;

 if (BTA_JvL2capReady(sock->handle, &count) == BTA_JV_SUCCESS) {
 if (BTA_JvL2capRead(sock->handle, sock->id, buffer, count) == BTA_JV_SUCCESS) {
 if (packet_put_tail_l(sock, buffer, count))
                        btsock_thread_add_fd(pth, sock->our_fd, BTSOCK_L2CAP, SOCK_THREAD_FD_WR,
                                sock->id);
 else {//connection must be dropped
                        APPL_TRACE_DEBUG("on_l2cap_data_ind() unable to push data to socket"
 " - closing channel");
                        BTA_JvL2capClose(sock->handle);
                        btsock_l2cap_free_l(sock);
 }
 }
 }
 }
 }
    pthread_mutex_unlock(&state_lock);
}

static void btif_hl_proc_dch_cong_ind(tBTA_HL *p_data)

{
 btif_hl_mdl_cb_t *p_dcb;
    UINT8                   app_idx, mcl_idx, mdl_idx;

    BTIF_TRACE_DEBUG("btif_hl_proc_dch_cong_ind");


 if (btif_hl_find_mdl_idx_using_handle(p_data->dch_cong_ind.mdl_handle, &app_idx, &mcl_idx, &mdl_idx))
 {
        p_dcb =BTIF_HL_GET_MDL_CB_PTR(app_idx, mcl_idx, mdl_idx);
        p_dcb->cong = p_data->dch_cong_ind.cong;
 }
}

static void on_cl_l2cap_le_connect_l(tBTA_JV_L2CAP_LE_OPEN *p_open, l2cap_socket *sock)
{
    bd_copy(sock->addr.address, p_open->rem_bda, 0);

 if (!send_app_psm_or_chan_l(sock)) {
        APPL_TRACE_ERROR("send_app_psm_or_chan_l failed");
 return;
 }

 if (send_app_connect_signal(sock->our_fd, &sock->addr, sock->channel, 0, -1, p_open->tx_mtu)) {
        APPL_TRACE_DEBUG("on_l2cap_connect_ind, connect signal sent, slot id:%d, Chan:%d,"
 " server:%d", sock->id, sock->channel, sock->server);
        btsock_thread_add_fd(pth, sock->our_fd, BTSOCK_L2CAP, SOCK_THREAD_FD_RD, sock->id);
        sock->connected = TRUE;
 }
 else APPL_TRACE_ERROR("send_app_connect_signal failed");
}

void btif_hl_tmr_hdlr(TIMER_LIST_ENT *tle)
{
 btif_hl_mcl_cb_t *p_mcb;
    UINT8               i,j;
    BTIF_TRACE_DEBUG("%s timer_in_use=%d",  __FUNCTION__, tle->in_use );

 for (i=0; i < BTA_HL_NUM_APPS ; i ++)
 {
 for (j=0; j< BTA_HL_NUM_MCLS; j++)
 {
            p_mcb =BTIF_HL_GET_MCL_CB_PTR(i,j);

 if (p_mcb->cch_timer_active)
 {
                BTIF_TRACE_DEBUG("%app_idx=%d, mcl_idx=%d mcl-connected=%d",
                                  i, j,  p_mcb->is_connected);
                p_mcb->cch_timer_active = FALSE;
 if (p_mcb->is_connected)
 {
                    BTIF_TRACE_DEBUG("Idle timeout Close CCH app_idx=%d mcl_idx=%d mcl_handle=%d",
                                      i ,j, p_mcb->mcl_handle);
                    BTA_HlCchClose(p_mcb->mcl_handle);
 }
 else
 {
                    BTIF_TRACE_DEBUG("CCH idle timeout But CCH not connected app_idx=%d mcl_idx=%d ",i,j);
 }
 }
 }
 }
}

int sock_recv_all(int sock_fd, uint8_t* buf, int len)
{
int r = len;

int ret = -1;
while(r)
{
        do ret = recv(sock_fd, buf, r, MSG_WAITALL);
while(ret < 0 && errno == EINTR);
if(ret <= 0)
{
BTIF_TRACE_ERROR("sock fd:%d recv errno:%d, ret:%d", sock_fd, errno, ret);
return -1;
}
buf += ret;
r -= ret;
}
return len;
}

const hci_hal_t *hci_hal_h4_get_test_interface(vendor_t *vendor_interface) {
  vendor = vendor_interface;
 return &interface;
}

void btif_hl_send_setup_disconnected_cb(UINT8 app_idx, UINT8 mcl_idx){
 btif_hl_pending_chan_cb_t *p_pcb = BTIF_HL_GET_PCB_PTR(app_idx, mcl_idx);
 bt_bdaddr_t                 bd_addr;
 int                         app_id = (int) btif_hl_get_app_id(p_pcb->channel_id);

    btif_hl_copy_bda(&bd_addr, p_pcb->bd_addr);

    BTIF_TRACE_DEBUG("%s p_pcb->in_use=%d",__FUNCTION__, p_pcb->in_use);
 if (p_pcb->in_use)
 {
        BTIF_TRACE_DEBUG("%p_pcb->cb_state=%d",p_pcb->cb_state);
 if (p_pcb->cb_state == BTIF_HL_CHAN_CB_STATE_CONNECTING_PENDING)
 {
            BTIF_TRACE_DEBUG("call channel state callback  channel_id=0x%08x mdep_cfg_idx=%d state=%d fd=%d",p_pcb->channel_id,
                              p_pcb->mdep_cfg_idx, BTHL_CONN_STATE_CONNECTING, 0);
            btif_hl_display_bt_bda(&bd_addr);
            BTIF_HL_CALL_CBACK(bt_hl_callbacks, channel_state_cb, app_id,
 &bd_addr, p_pcb->mdep_cfg_idx,
                               p_pcb->channel_id, BTHL_CONN_STATE_CONNECTING, 0 );

            BTIF_TRACE_DEBUG("call channel state callback  channel_id=0x%08x mdep_cfg_idx=%d state=%d fd=%d",p_pcb->channel_id,
                              p_pcb->mdep_cfg_idx, BTHL_CONN_STATE_DISCONNECTED, 0);
            btif_hl_display_bt_bda(&bd_addr);
            BTIF_HL_CALL_CBACK(bt_hl_callbacks, channel_state_cb, app_id,
 &bd_addr, p_pcb->mdep_cfg_idx,
                               p_pcb->channel_id, BTHL_CONN_STATE_DISCONNECTED, 0 );
 }
 else if (p_pcb->cb_state == BTIF_HL_CHAN_CB_STATE_CONNECTED_PENDING)
 {
            BTIF_TRACE_DEBUG("call channel state callback  channel_id=0x%08x mdep_cfg_idx=%d state=%d fd=%d",p_pcb->channel_id,
                              p_pcb->mdep_cfg_idx, BTHL_CONN_STATE_DISCONNECTED, 0);
            btif_hl_display_bt_bda(&bd_addr);
            BTIF_HL_CALL_CBACK(bt_hl_callbacks, channel_state_cb,  app_id,
 &bd_addr, p_pcb->mdep_cfg_idx,
                               p_pcb->channel_id, BTHL_CONN_STATE_DISCONNECTED, 0 );
 }
        btif_hl_clean_pcb(p_pcb);
 }
}

void bta_hl_co_put_echo_data (UINT8 app_id, tBTA_HL_MCL_HANDLE mcl_handle,
                              UINT16 data_size, UINT8 *p_data, UINT16 evt)
{
    tBTA_HL_STATUS status = BTA_HL_STATUS_FAIL;
    UNUSED(app_id);
    UNUSED(data_size);
    UNUSED(p_data);

    BTIF_TRACE_ERROR("%s not supported",__FUNCTION__);
    bta_hl_ci_put_echo_data(mcl_handle,  status, evt);
}

static void a2dp_stream_common_init(struct a2dp_stream_common *common)
{
 pthread_mutexattr_t lock_attr;

    FNLOG();

    pthread_mutexattr_init(&lock_attr);
    pthread_mutexattr_settype(&lock_attr, PTHREAD_MUTEX_RECURSIVE);
    pthread_mutex_init(&common->lock, &lock_attr);

    common->ctrl_fd = AUDIO_SKT_DISCONNECTED;
    common->audio_fd = AUDIO_SKT_DISCONNECTED;
    common->state = AUDIO_A2DP_STATE_STOPPED;

 /* manages max capacity of socket pipe */
    common->buffer_sz = AUDIO_STREAM_OUTPUT_BUFFER_SZ;
}

void release_transaction(UINT8 lbl)
{
 rc_transaction_t *transaction = get_transaction_by_lbl(lbl);

 /* If the transaction is in use... */
 if (transaction != NULL)
 {
        BTIF_TRACE_DEBUG("%s: lbl: %d", __FUNCTION__, lbl);
        initialize_transaction(lbl);
 }
}

bt_status_t btif_dm_ssp_reply(const bt_bdaddr_t *bd_addr,
 bt_ssp_variant_t variant, uint8_t accept,
 uint32_t passkey)
{
    UNUSED(passkey);

 if (variant == BT_SSP_VARIANT_PASSKEY_ENTRY)
 {
 /* This is not implemented in the stack.
         * For devices with display, this is not needed
        */
        BTIF_TRACE_WARNING("%s: Not implemented", __FUNCTION__);
 return BT_STATUS_FAIL;
 }
 /* BT_SSP_VARIANT_CONSENT & BT_SSP_VARIANT_PASSKEY_CONFIRMATION supported */
    BTIF_TRACE_EVENT("%s: accept=%d", __FUNCTION__, accept);
#if (defined(BLE_INCLUDED) && (BLE_INCLUDED == TRUE))
 if (pairing_cb.is_le_only)
 {
 if(pairing_cb.is_le_nc)
 {
            BTA_DmBleConfirmReply((UINT8 *)bd_addr->address,accept);
 } else {
 if (accept)
                BTA_DmBleSecurityGrant((UINT8 *)bd_addr->address,BTA_DM_SEC_GRANTED);
 else
                BTA_DmBleSecurityGrant((UINT8 *)bd_addr->address,BTA_DM_SEC_PAIR_NOT_SPT);
 }
 } else {
        BTA_DmConfirm( (UINT8 *)bd_addr->address, accept);
 }
#else
    BTA_DmConfirm( (UINT8 *)bd_addr->address, accept);
#endif
 return BT_STATUS_SUCCESS;
}

void btif_dm_cb_remove_bond(bt_bdaddr_t *bd_addr)
{
 /*special handling for HID devices */
 /*  VUP needs to be sent if its a HID Device. The HID HOST module will check if there
     is a valid hid connection with this bd_addr. If yes VUP will be issued.*/
#if (defined(BTA_HH_INCLUDED) && (BTA_HH_INCLUDED == TRUE))
 if (btif_hh_virtual_unplug(bd_addr) != BT_STATUS_SUCCESS)
#endif
 {
         BTIF_TRACE_DEBUG("%s: Removing HH device", __func__);
         BTA_DmRemoveDevice((UINT8 *)bd_addr->address);
 }
}

void handle_rc_connect (tBTA_AV_RC_OPEN *p_rc_open)
{
    BTIF_TRACE_DEBUG("%s: rc_handle: %d", __FUNCTION__, p_rc_open->rc_handle);
 bt_status_t result = BT_STATUS_SUCCESS;
#if (AVRC_CTLR_INCLUDED == TRUE)
 bt_bdaddr_t rc_addr;
#endif

 if(p_rc_open->status == BTA_AV_SUCCESS)
 {
 if (btif_rc_cb.rc_connected)
 {
            BTIF_TRACE_ERROR("Got RC OPEN in connected state, Connected RC: %d \
                and Current RC: %d", btif_rc_cb.rc_handle,p_rc_open->rc_handle );
 if ((btif_rc_cb.rc_handle != p_rc_open->rc_handle)
 && (bdcmp(btif_rc_cb.rc_addr, p_rc_open->peer_addr)))
 {
                BTIF_TRACE_DEBUG("Got RC connected for some other handle");
                BTA_AvCloseRc(p_rc_open->rc_handle);
 return;
 }
 }
        memcpy(btif_rc_cb.rc_addr, p_rc_open->peer_addr, sizeof(BD_ADDR));
        btif_rc_cb.rc_features = p_rc_open->peer_features;
        btif_rc_cb.rc_vol_label=MAX_LABEL;
        btif_rc_cb.rc_volume=MAX_VOLUME;

        btif_rc_cb.rc_connected = TRUE;
        btif_rc_cb.rc_handle = p_rc_open->rc_handle;

 /* on locally initiated connection we will get remote features as part of connect */
 if (btif_rc_cb.rc_features != 0)
            handle_rc_features();

        result = uinput_driver_check();
 if(result == BT_STATUS_SUCCESS)
 {
            init_uinput();
 }
#if (AVRC_CTLR_INCLUDED == TRUE)
        bdcpy(rc_addr.address, btif_rc_cb.rc_addr);
 /* report connection state if device is AVRCP target */
 if (btif_rc_cb.rc_features & BTA_AV_FEAT_RCTG) {
 if (bt_rc_ctrl_callbacks != NULL) {
                HAL_CBACK(bt_rc_ctrl_callbacks, connection_state_cb, TRUE, &rc_addr);
 }
 }
#endif
 }
 else
 {
        BTIF_TRACE_ERROR("%s Connect failed with error code: %d",
            __FUNCTION__, p_rc_open->status);
        btif_rc_cb.rc_connected = FALSE;
 }
}

bt_status_t btif_get_adapter_properties(void)
{
    BTIF_TRACE_EVENT("%s", __FUNCTION__);

 if (!btif_is_enabled())
 return BT_STATUS_NOT_READY;

 return btif_transfer_context(execute_storage_request,
                                 BTIF_CORE_STORAGE_ADAPTER_READ_ALL,
                                 NULL, 0, NULL);
}

UINT8 btif_is_dut_mode(void)
{
 return (btif_dut_mode == 1);
}

static bt_status_t get_element_attr_rsp(uint8_t num_attr, btrc_element_attr_val_t *p_attrs)
{
    tAVRC_RESPONSE avrc_rsp;
    UINT32 i;
    tAVRC_ATTR_ENTRY element_attrs[BTRC_MAX_ELEM_ATTR_SIZE];
    CHECK_RC_CONNECTED
    memset(element_attrs, 0, sizeof(tAVRC_ATTR_ENTRY) * num_attr);

 if (num_attr == 0)
 {
        avrc_rsp.get_play_status.status = AVRC_STS_BAD_PARAM;
 }
 else
 {
 for (i=0; i<num_attr; i++) {
            element_attrs[i].attr_id = p_attrs[i].attr_id;
            element_attrs[i].name.charset_id = AVRC_CHARSET_ID_UTF8;
            element_attrs[i].name.str_len = (UINT16)strlen((char *)p_attrs[i].text);
            element_attrs[i].name.p_str = p_attrs[i].text;
            BTIF_TRACE_DEBUG("%s attr_id:0x%x, charset_id:0x%x, str_len:%d, str:%s",
                __FUNCTION__, (unsigned int)element_attrs[i].attr_id,
                element_attrs[i].name.charset_id, element_attrs[i].name.str_len,
                element_attrs[i].name.p_str);
 }
        avrc_rsp.get_play_status.status = AVRC_STS_NO_ERROR;
 }
    avrc_rsp.get_elem_attrs.num_attr = num_attr;
    avrc_rsp.get_elem_attrs.p_attrs = element_attrs;
    avrc_rsp.get_elem_attrs.pdu = AVRC_PDU_GET_ELEMENT_ATTR;
    avrc_rsp.get_elem_attrs.opcode = opcode_from_pdu(AVRC_PDU_GET_ELEMENT_ATTR);
 /* Send the response */
    SEND_METAMSG_RSP(IDX_GET_ELEMENT_ATTR_RSP, &avrc_rsp);
 return BT_STATUS_SUCCESS;
}

int uinput_driver_check()
{
 uint32_t i;
 for (i=0; i < MAX_UINPUT_PATHS; i++)
 {
 if (access(uinput_dev_path[i], O_RDWR) == 0) {
 return 0;
 }
 }
    BTIF_TRACE_ERROR("%s ERROR: uinput device is not in the system", __FUNCTION__);
 return -1;
}

static void bte_dm_search_services_evt(tBTA_DM_SEARCH_EVT event, tBTA_DM_SEARCH *p_data)
{
    UINT16 param_len = 0;
 if (p_data)
       param_len += sizeof(tBTA_DM_SEARCH);
 switch (event)
 {
 case BTA_DM_DISC_RES_EVT:
 {
 if ((p_data->disc_res.result == BTA_SUCCESS) && (p_data->disc_res.num_uuids > 0)) {
                  param_len += (p_data->disc_res.num_uuids * MAX_UUID_SIZE);
 }
 } break;
 }
 /* TODO: The only other member that needs a deep copy is the p_raw_data. But not sure
    * if raw_data is needed. */
   btif_transfer_context(btif_dm_search_services_evt, event, (char*)p_data, param_len,
 (param_len > sizeof(tBTA_DM_SEARCH)) ? search_services_copy_cb : NULL);
}

void btif_rc_handler(tBTA_AV_EVT event, tBTA_AV *p_data)
{
    BTIF_TRACE_DEBUG ("%s event:%s", __FUNCTION__, dump_rc_event(event));
 switch (event)
 {
 case BTA_AV_RC_OPEN_EVT:
 {
            BTIF_TRACE_DEBUG("Peer_features:%x", p_data->rc_open.peer_features);
            handle_rc_connect( &(p_data->rc_open) );
 }break;

 case BTA_AV_RC_CLOSE_EVT:
 {
            handle_rc_disconnect( &(p_data->rc_close) );
 }break;

 case BTA_AV_REMOTE_CMD_EVT:
 {
            BTIF_TRACE_DEBUG("rc_id:0x%x key_state:%d", p_data->remote_cmd.rc_id,
                               p_data->remote_cmd.key_state);
            handle_rc_passthrough_cmd( (&p_data->remote_cmd) );
 }
 break;
#if (AVRC_CTLR_INCLUDED == TRUE)
 case BTA_AV_REMOTE_RSP_EVT:
 {
            BTIF_TRACE_DEBUG("RSP: rc_id:0x%x key_state:%d", p_data->remote_rsp.rc_id,
                               p_data->remote_rsp.key_state);
            handle_rc_passthrough_rsp( (&p_data->remote_rsp) );
 }
 break;
#endif
 case BTA_AV_RC_FEAT_EVT:
 {
            BTIF_TRACE_DEBUG("Peer_features:%x", p_data->rc_feat.peer_features);
            btif_rc_cb.rc_features = p_data->rc_feat.peer_features;
            handle_rc_features();
 }
 break;
 case BTA_AV_META_MSG_EVT:
 {
            BTIF_TRACE_DEBUG("BTA_AV_META_MSG_EVT  code:%d label:%d", p_data->meta_msg.code,
                p_data->meta_msg.label);
            BTIF_TRACE_DEBUG("  company_id:0x%x len:%d handle:%d", p_data->meta_msg.company_id,
                p_data->meta_msg.len, p_data->meta_msg.rc_handle);
 /* handle the metamsg command */
            handle_rc_metamsg_cmd(&(p_data->meta_msg));
 }
 break;
 default:
            BTIF_TRACE_DEBUG("Unhandled RC event : 0x%x", event);
 }
}

void btif_enable_bluetooth_evt(tBTA_STATUS status)
{
 const controller_t *controller = controller_get_interface();
 bdstr_t bdstr;
    bdaddr_to_string(controller->get_address(), bdstr, sizeof(bdstr));

    BTIF_TRACE_DEBUG("%s: status %d, local bd [%s]", __FUNCTION__, status, bdstr);

 if (bdcmp(btif_local_bd_addr.address, controller->get_address()->address))
 {
 bdstr_t old_address;
 bt_property_t prop;

        bdaddr_to_string(&btif_local_bd_addr, old_address, sizeof(old_address));

 /**
         * The Controller's BDADDR does not match to the BTIF's initial BDADDR!
         * This could be because the factory BDADDR was stored separately in
         * the Controller's non-volatile memory rather than in device's file
         * system.
         **/
        BTIF_TRACE_WARNING("***********************************************");
        BTIF_TRACE_WARNING("BTIF init BDA was %s", old_address);
        BTIF_TRACE_WARNING("Controller BDA is %s", bdstr);
        BTIF_TRACE_WARNING("***********************************************");

        btif_local_bd_addr = *controller->get_address();

        btif_config_set_str("Adapter", "Address", bdstr);
        btif_config_save();

        prop.type = BT_PROPERTY_BDADDR;
        prop.val = (void*)&btif_local_bd_addr;
        prop.len = sizeof(bt_bdaddr_t);
        HAL_CBACK(bt_hal_cbacks, adapter_properties_cb, BT_STATUS_SUCCESS, 1, &prop);
 }

    bte_main_postload_cfg();
#if (defined(HCILP_INCLUDED) && HCILP_INCLUDED == TRUE)
    bte_main_enable_lpm(TRUE);
#endif
 /* add passing up bd address as well ? */

 /* callback to HAL */
 if (status == BTA_SUCCESS)
 {
 /* init rfcomm & l2cap api */
        btif_sock_init();

 /* init pan */
        btif_pan_init();

 /* load did configuration */
        bte_load_did_conf(BTE_DID_CONF_FILE);

#ifdef BTIF_DM_OOB_TEST
        btif_dm_load_local_oob();
#endif

        future_ready(stack_manager_get_hack_future(), FUTURE_SUCCESS);
 }
 else
 {
 /* cleanup rfcomm & l2cap api */
        btif_sock_cleanup();

        btif_pan_cleanup();

        future_ready(stack_manager_get_hack_future(), FUTURE_FAIL);
 }
}

static inline int create_thread(void *(*start_routine)(void *), void * arg,
 pthread_t * thread_id)
{
 pthread_attr_t thread_attr;
    pthread_attr_init(&thread_attr);
    pthread_attr_setdetachstate(&thread_attr, PTHREAD_CREATE_JOINABLE);
 int policy;
 int min_pri=0;
 int ret = -1;
 struct sched_param param;

 if ((ret = pthread_create(thread_id, &thread_attr, start_routine, arg))!=0 )
 {
        APPL_TRACE_ERROR("pthread_create : %s", strerror(errno));
 return ret;
 }
 /* We need to lower the priority of this thread to ensure the stack gets
     * priority over transfer to a socket */
    pthread_getschedparam(*thread_id, &policy, &param);
    min_pri = sched_get_priority_min(policy);
 if (param.sched_priority > min_pri) {
        param.sched_priority -= 1;
 }
    pthread_setschedparam(*thread_id, policy, &param);
 return ret;
}

void config_set_string(config_t *config, const char *section, const char *key, const char *value) {
 section_t *sec = section_find(config, section);
 if (!sec) {
    sec = section_new(section);
    list_append(config->sections, sec);
 }

 for (const list_node_t *node = list_begin(sec->entries); node != list_end(sec->entries); node = list_next(node)) {
 entry_t *entry = list_node(node);
 if (!strcmp(entry->key, key)) {
      osi_free(entry->value);
      entry->value = osi_strdup(value);
 return;
 }
 }

 entry_t *entry = entry_new(key, value);
  list_append(sec->entries, entry);
}

static void btif_dm_ble_passkey_req_evt(tBTA_DM_PIN_REQ *p_pin_req)
{
 bt_bdaddr_t bd_addr;
 bt_bdname_t bd_name;
    UINT32 cod;
 int dev_type;

 /* Remote name update */
 if (!btif_get_device_type(p_pin_req->bd_addr, &dev_type))
 {
        dev_type = BT_DEVICE_TYPE_BLE;
 }
    btif_dm_update_ble_remote_properties(p_pin_req->bd_addr,p_pin_req->bd_name,
 (tBT_DEVICE_TYPE) dev_type);

    bdcpy(bd_addr.address, p_pin_req->bd_addr);
    memcpy(bd_name.name, p_pin_req->bd_name, BD_NAME_LEN);

    bond_state_changed(BT_STATUS_SUCCESS, &bd_addr, BT_BOND_STATE_BONDING);
    pairing_cb.is_le_only = TRUE;

    cod = COD_UNCLASSIFIED;

    HAL_CBACK(bt_hal_cbacks, pin_request_cb,
 &bd_addr, &bd_name, cod, FALSE);
}

void handle_uid_changed_notification(tBTA_AV_META_MSG *pmeta_msg, tAVRC_COMMAND *pavrc_command)
{
    tAVRC_RESPONSE avrc_rsp = {0};
    avrc_rsp.rsp.pdu = pavrc_command->pdu;
    avrc_rsp.rsp.status = AVRC_STS_NO_ERROR;
    avrc_rsp.rsp.opcode = pavrc_command->cmd.opcode;

    avrc_rsp.reg_notif.event_id = pavrc_command->reg_notif.event_id;
    avrc_rsp.reg_notif.param.uid_counter = 0;

    send_metamsg_rsp(pmeta_msg->rc_handle, pmeta_msg->label, AVRC_RSP_INTERIM, &avrc_rsp);
    send_metamsg_rsp(pmeta_msg->rc_handle, pmeta_msg->label, AVRC_RSP_CHANGED, &avrc_rsp);

}

static serial_data_type_t event_to_data_type(uint16_t event) {
 if (event == MSG_STACK_TO_HC_HCI_ACL)
 return DATA_TYPE_ACL;
 else if (event == MSG_STACK_TO_HC_HCI_SCO)
 return DATA_TYPE_SCO;
 else if (event == MSG_STACK_TO_HC_HCI_CMD)
 return DATA_TYPE_COMMAND;
 else
    LOG_ERROR("%s invalid event type, could not translate 0x%x", __func__, event);

 return 0;
}

BOOLEAN btif_hl_find_app_idx_using_app_id(UINT8 app_id,
                                          UINT8 *p_app_idx){
    BOOLEAN found=FALSE;
    UINT8 i;

 *p_app_idx = 0;
 for (i=0; i < BTA_HL_NUM_APPS ; i ++)
 {
 if (btif_hl_cb.acb[i].in_use &&
 (btif_hl_cb.acb[i].app_id == app_id))
 {
            found = TRUE;
 *p_app_idx = i;
 break;
 }
 }

    BTIF_TRACE_EVENT("%s found=%d app_id=%d app_idx=%d ",
                      __FUNCTION__, found, app_id , i);

 return found;
}

static bt_status_t set_report (bt_bdaddr_t *bd_addr, bthh_report_type_t reportType, char* report)
{
    CHECK_BTHH_INIT();
 btif_hh_device_t *p_dev;
    BD_ADDR* bda = (BD_ADDR*) bd_addr;

    BTIF_TRACE_DEBUG("%s:reportType = %d", __FUNCTION__,reportType);

    BTIF_TRACE_DEBUG("addr = %02X:%02X:%02X:%02X:%02X:%02X",
 (*bda)[0], (*bda)[1], (*bda)[2], (*bda)[3], (*bda)[4], (*bda)[5]);


 if (btif_hh_cb.status == BTIF_HH_DISABLED) {
        BTIF_TRACE_ERROR("%s: Error, HH status = %d", __FUNCTION__, btif_hh_cb.status);
 return BT_STATUS_FAIL;
 }

    p_dev = btif_hh_find_connected_dev_by_bda(bd_addr);
 if (p_dev == NULL) {
        BTIF_TRACE_ERROR("%s: Error, device %02X:%02X:%02X:%02X:%02X:%02X not opened.",
 (*bda)[0], (*bda)[1], (*bda)[2], (*bda)[3], (*bda)[4], (*bda)[5]);
 return BT_STATUS_FAIL;
 }
 else if ( ( (int) reportType) <= BTA_HH_RPTT_RESRV || ( (int) reportType) > BTA_HH_RPTT_FEATURE) {
        BTIF_TRACE_ERROR(" Error, device %02X:%02X:%02X:%02X:%02X:%02X not opened.",
 (*bda)[0], (*bda)[1], (*bda)[2], (*bda)[3], (*bda)[4], (*bda)[5]);
 return BT_STATUS_FAIL;
 }
 else {
 int    hex_bytes_filled;
        UINT8  *hexbuf;
        UINT16 len = (strlen(report) + 1) / 2;

        hexbuf = GKI_getbuf(len);
 if (hexbuf == NULL) {
            BTIF_TRACE_ERROR("%s: Error, failed to allocate RPT buffer, len = %d",
                __FUNCTION__, len);
 return BT_STATUS_FAIL;
 }

 /* Build a SetReport data buffer */
        memset(hexbuf, 0, len);
        hex_bytes_filled = ascii_2_hex(report, len, hexbuf);
        LOG_INFO("Hex bytes filled, hex value: %d", hex_bytes_filled);
 if (hex_bytes_filled) {
            BT_HDR* p_buf = create_pbuf(hex_bytes_filled, hexbuf);
 if (p_buf == NULL) {
                BTIF_TRACE_ERROR("%s: Error, failed to allocate RPT buffer, len = %d",
                                  __FUNCTION__, hex_bytes_filled);
                GKI_freebuf(hexbuf);
 return BT_STATUS_FAIL;
 }
            BTA_HhSetReport(p_dev->dev_handle, reportType, p_buf);
            GKI_freebuf(hexbuf);
 return BT_STATUS_SUCCESS;
 }
        GKI_freebuf(hexbuf);
 return BT_STATUS_FAIL;
 }
}

void semaphore_free(semaphore_t *semaphore) {
 if (!semaphore)
 return;

 if (semaphore->fd != INVALID_FD)
    close(semaphore->fd);
  osi_free(semaphore);
}

static void btif_in_storage_request_copy_cb(UINT16 event,
 char *p_new_buf, char *p_old_buf)
{
 btif_storage_req_t *new_req = (btif_storage_req_t*)p_new_buf;
 btif_storage_req_t *old_req = (btif_storage_req_t*)p_old_buf;

     BTIF_TRACE_EVENT("%s", __FUNCTION__);
 switch (event)
 {
 case BTIF_CORE_STORAGE_REMOTE_WRITE:
 case BTIF_CORE_STORAGE_ADAPTER_WRITE:
 {
             bdcpy(new_req->write_req.bd_addr.address, old_req->write_req.bd_addr.address);
 /* Copy the member variables one at a time */
             new_req->write_req.prop.type = old_req->write_req.prop.type;
             new_req->write_req.prop.len = old_req->write_req.prop.len;

             new_req->write_req.prop.val = (UINT8 *)(p_new_buf + sizeof(btif_storage_req_t));
             memcpy(new_req->write_req.prop.val, old_req->write_req.prop.val,
                    old_req->write_req.prop.len);
 }break;
 }
}

static void entry_free(void *ptr) {
 if (!ptr)
 return;

 entry_t *entry = ptr;
  osi_free(entry->key);
  osi_free(entry->value);
  osi_free(entry);
}

void btif_dm_update_ble_remote_properties( BD_ADDR bd_addr, BD_NAME bd_name,
                                           tBT_DEVICE_TYPE dev_type)
{
   btif_update_remote_properties(bd_addr,bd_name,NULL,dev_type);
}

bool btsock_thread_remove_fd_and_close(int thread_handle, int fd)
{
if (thread_handle < 0 || thread_handle >= MAX_THREAD)
{
APPL_TRACE_ERROR("%s invalid thread handle: %d", __func__, thread_handle);
return false;
}
if (fd == -1)
{
APPL_TRACE_ERROR("%s invalid file descriptor.", __func__);
return false;

}

sock_cmd_t cmd = {CMD_REMOVE_FD, fd, 0, 0, 0};
    return send(ts[thread_handle].cmd_fdw, &cmd, sizeof(cmd), 0) == sizeof(cmd);
}

static int btpan_get_local_role()
{
    BTIF_TRACE_DEBUG("btpan_dev_local_role:%d", btpan_dev_local_role);
 return btpan_dev_local_role;
}

static UINT8 btif_hl_get_app_id(int channel_id){
    UINT8 app_id =(UINT8) (channel_id >> 16);
    BTIF_TRACE_DEBUG("%s channel_id=0x%08x, app_id=0x%02x ", __FUNCTION__,channel_id, app_id);
 return app_id;
}

void btif_thread_post(thread_fn func, void *context) {
    thread_post(bt_jni_workqueue_thread, func, context);
}

static inline bool should_forward(tETH_HDR* hdr)
{
 uint16_t proto = ntohs(hdr->h_proto);
 if (proto == ETH_P_IP || proto == ETH_P_ARP || proto == ETH_P_IPV6)
 return true;
    BTIF_TRACE_DEBUG("unknown proto:%x", proto);
 return false;
}

static void do_postload() {
  LOG_DEBUG("%s posting postload work item", __func__);
  thread_post(thread, event_postload, NULL);
}

static bt_status_t btif_in_get_adapter_properties(void)
{
 bt_property_t properties[6];
 uint32_t num_props;

 bt_bdaddr_t addr;
 bt_bdname_t name;
 bt_scan_mode_t mode;
 uint32_t disc_timeout;
 bt_bdaddr_t bonded_devices[BTM_SEC_MAX_DEVICE_RECORDS];
 bt_uuid_t local_uuids[BT_MAX_NUM_UUIDS];
    num_props = 0;

 /* BD_ADDR */
    BTIF_STORAGE_FILL_PROPERTY(&properties[num_props], BT_PROPERTY_BDADDR,
 sizeof(addr), &addr);
    btif_storage_get_adapter_property(&properties[num_props]);
    num_props++;

 /* BD_NAME */
    BTIF_STORAGE_FILL_PROPERTY(&properties[num_props], BT_PROPERTY_BDNAME,
 sizeof(name), &name);
    btif_storage_get_adapter_property(&properties[num_props]);
    num_props++;

 /* SCAN_MODE */
    BTIF_STORAGE_FILL_PROPERTY(&properties[num_props], BT_PROPERTY_ADAPTER_SCAN_MODE,
 sizeof(mode), &mode);
    btif_storage_get_adapter_property(&properties[num_props]);
    num_props++;

 /* DISC_TIMEOUT */
    BTIF_STORAGE_FILL_PROPERTY(&properties[num_props], BT_PROPERTY_ADAPTER_DISCOVERY_TIMEOUT,
 sizeof(disc_timeout), &disc_timeout);
    btif_storage_get_adapter_property(&properties[num_props]);
    num_props++;

 /* BONDED_DEVICES */
    BTIF_STORAGE_FILL_PROPERTY(&properties[num_props], BT_PROPERTY_ADAPTER_BONDED_DEVICES,
 sizeof(bonded_devices), bonded_devices);
    btif_storage_get_adapter_property(&properties[num_props]);
    num_props++;

 /* LOCAL UUIDs */
    BTIF_STORAGE_FILL_PROPERTY(&properties[num_props], BT_PROPERTY_UUIDS,
 sizeof(local_uuids), local_uuids);
    btif_storage_get_adapter_property(&properties[num_props]);
    num_props++;

    HAL_CBACK(bt_hal_cbacks, adapter_properties_cb,
                     BT_STATUS_SUCCESS, num_props, properties);

 return BT_STATUS_SUCCESS;
}

static void internal_outbound_read_ready(void *context) {
  assert(context != NULL);

 eager_reader_t *reader = (eager_reader_t *)context;
  reader->outbound_read_ready(reader, reader->outbound_context);
}

BOOLEAN btif_hl_find_mcl_idx(UINT8 app_idx, BD_ADDR p_bd_addr, UINT8 *p_mcl_idx){
    BOOLEAN found=FALSE;
    UINT8 i;
 btif_hl_mcl_cb_t *p_mcb;

 *p_mcl_idx = 0;
 for (i=0; i < BTA_HL_NUM_MCLS ; i ++)
 {
        p_mcb = BTIF_HL_GET_MCL_CB_PTR(app_idx, i);
 if (p_mcb->in_use &&
 (!memcmp (p_mcb->bd_addr, p_bd_addr, BD_ADDR_LEN)))
 {
            found = TRUE;
 *p_mcl_idx = i;
 break;
 }
 }


    BTIF_TRACE_DEBUG("%s found=%d idx=%d",__FUNCTION__, found, i);
 return found;
}

void GKI_enable(void) {
  pthread_mutex_unlock(&gki_cb.lock);
}

BOOLEAN btif_hl_is_the_first_reliable_existed(UINT8 app_idx, UINT8 mcl_idx )
{
 btif_hl_mcl_cb_t *p_mcb  =BTIF_HL_GET_MCL_CB_PTR(app_idx, mcl_idx);
    BOOLEAN is_existed =FALSE;
    UINT8 i ;

 for (i=0; i< BTA_HL_NUM_MDLS_PER_MCL; i++)
 {
 if (p_mcb->mdl[i].in_use && p_mcb->mdl[i].is_the_first_reliable)
 {
            is_existed = TRUE;
 break;
 }
 }

    BTIF_TRACE_DEBUG("bta_hl_is_the_first_reliable_existed is_existed=%d  ",is_existed );
 return is_existed;
}

bt_status_t btif_set_adapter_property(const bt_property_t *property)
{
 btif_storage_req_t req;
 bt_status_t status = BT_STATUS_SUCCESS;
 int storage_req_id = BTIF_CORE_STORAGE_NOTIFY_STATUS; /* default */
 char bd_name[BTM_MAX_LOC_BD_NAME_LEN +1];
    UINT16  name_len = 0;

    BTIF_TRACE_EVENT("btif_set_adapter_property type: %d, len %d, 0x%x",
 property->type, property->len, property->val);

 if (!btif_is_enabled())
 return BT_STATUS_NOT_READY;

 switch(property->type)
 {
 case BT_PROPERTY_BDNAME:
 {
                name_len = property->len > BTM_MAX_LOC_BD_NAME_LEN ? BTM_MAX_LOC_BD_NAME_LEN:
 property->len;
                memcpy(bd_name,property->val, name_len);
                bd_name[name_len] = '\0';

                BTIF_TRACE_EVENT("set property name : %s", (char *)bd_name);

                BTA_DmSetDeviceName((char *)bd_name);

                storage_req_id = BTIF_CORE_STORAGE_ADAPTER_WRITE;
 }
 break;

 case BT_PROPERTY_ADAPTER_SCAN_MODE:
 {
 bt_scan_mode_t mode = *(bt_scan_mode_t*)property->val;
                tBTA_DM_DISC disc_mode;
                tBTA_DM_CONN conn_mode;

 switch(mode)
 {
 case BT_SCAN_MODE_NONE:
                        disc_mode = BTA_DM_NON_DISC;
                        conn_mode = BTA_DM_NON_CONN;
 break;

 case BT_SCAN_MODE_CONNECTABLE:
                        disc_mode = BTA_DM_NON_DISC;
                        conn_mode = BTA_DM_CONN;
 break;

 case BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE:
                        disc_mode = BTA_DM_GENERAL_DISC;
                        conn_mode = BTA_DM_CONN;
 break;

 default:
                        BTIF_TRACE_ERROR("invalid scan mode (0x%x)", mode);
 return BT_STATUS_PARM_INVALID;
 }

                BTIF_TRACE_EVENT("set property scan mode : %x", mode);

                BTA_DmSetVisibility(disc_mode, conn_mode, BTA_DM_IGNORE, BTA_DM_IGNORE);

                storage_req_id = BTIF_CORE_STORAGE_ADAPTER_WRITE;
 }
 break;
 case BT_PROPERTY_ADAPTER_DISCOVERY_TIMEOUT:
 {
 /* Nothing to do beside store the value in NV.  Java
                   will change the SCAN_MODE property after setting timeout,
                   if required */
                storage_req_id = BTIF_CORE_STORAGE_ADAPTER_WRITE;
 }
 break;
 case BT_PROPERTY_BDADDR:
 case BT_PROPERTY_UUIDS:
 case BT_PROPERTY_ADAPTER_BONDED_DEVICES:
 case BT_PROPERTY_REMOTE_FRIENDLY_NAME:
 /* no write support through HAL, these properties are only populated from BTA events */
            status = BT_STATUS_FAIL;
 break;
 default:
            BTIF_TRACE_ERROR("btif_get_adapter_property : invalid type %d",
 property->type);
            status = BT_STATUS_FAIL;
 break;
 }

 if (storage_req_id != BTIF_CORE_STORAGE_NO_ACTION)
 {
 /* pass on to storage for updating local database */

        memset(&(req.write_req.bd_addr), 0, sizeof(bt_bdaddr_t));
        memcpy(&(req.write_req.prop), property, sizeof(bt_property_t));

 return btif_transfer_context(execute_storage_request,
                                     storage_req_id,
 (char*)&req,
 sizeof(btif_storage_req_t)+property->len,
                                     btif_in_storage_request_copy_cb);
 }

 return status;

}

void btif_init_ok(UNUSED_ATTR uint16_t event, UNUSED_ATTR char *p_param) {
  BTIF_TRACE_DEBUG("btif_task: received trigger stack init event");
#if (BLE_INCLUDED == TRUE)
  btif_dm_load_ble_local_keys();
#endif
  BTA_EnableBluetooth(bte_dm_evt);
}

static BOOLEAN send_app_connect_signal(int fd, const bt_bdaddr_t* addr,
 int channel, int status, int send_fd, int tx_mtu)
{
 sock_connect_signal_t cs;
    cs.size = sizeof(cs);
    cs.bd_addr = *addr;
    cs.channel = channel;
    cs.status = status;
    cs.max_rx_packet_size = L2CAP_MAX_SDU_LENGTH;
    cs.max_tx_packet_size = tx_mtu;
 if (send_fd != -1) {
 if (sock_send_fd(fd, (const uint8_t*)&cs, sizeof(cs), send_fd) == sizeof(cs))
 return TRUE;
 else APPL_TRACE_ERROR("sock_send_fd failed, fd:%d, send_fd:%d", fd, send_fd);
 } else if (sock_send_all(fd, (const uint8_t*)&cs, sizeof(cs)) == sizeof(cs)) {
 return TRUE;
 }
 return FALSE;
}

static void epilog_finished_callback(UNUSED_ATTR bool success) {
  LOG_INFO("%s", __func__);
  thread_stop(thread);
}

BOOLEAN bta_hl_co_load_mdl_config (UINT8 app_id, UINT8 buffer_size,
                                   tBTA_HL_MDL_CFG *p_mdl_buf )
{
    BOOLEAN result = TRUE;
    UINT8 i;
    tBTA_HL_MDL_CFG *p;

    BTIF_TRACE_DEBUG("%s app_id=%d, num_items=%d",
                      __FUNCTION__, app_id, buffer_size);

 if (buffer_size > BTA_HL_NUM_MDL_CFGS)
 {
        result = FALSE;
 return result;
 }
    result = btif_hl_load_mdl_config(app_id, buffer_size, p_mdl_buf);

 if (result)
 {
 for (i=0, p=p_mdl_buf; i<buffer_size; i++, p++ )
 {
 if (p->active)
 {
                BTIF_TRACE_DEBUG("i=%d mdl_id=0x%x dch_mode=%d local mdep_role=%d mdep_id=%d mtu=%d",
                                  i, p->mdl_id, p->dch_mode, p->local_mdep_role, p->local_mdep_role, p->mtu);
 }
 }
 }

    BTIF_TRACE_DEBUG("%s success=%d num_items=%d", __FUNCTION__, result, buffer_size);

 return result;
}

BOOLEAN btif_hl_dch_open(UINT8 app_id, BD_ADDR bd_addr,
                         tBTA_HL_DCH_OPEN_PARAM *p_dch_open_api,
 int mdep_cfg_idx,
 btif_hl_pend_dch_op_t op, int *channel_id){
 btif_hl_app_cb_t *p_acb;
 btif_hl_mcl_cb_t *p_mcb;
 btif_hl_pending_chan_cb_t *p_pcb;
    UINT8                       app_idx, mcl_idx;
    BOOLEAN                     status = FALSE;
    tBTA_HL_MDL_ID              mdl_id;
    tBTA_HL_DCH_RECONNECT_PARAM reconnect_param;

    BTIF_TRACE_DEBUG("%s app_id=%d ",
                      __FUNCTION__, app_id );
    BTIF_TRACE_DEBUG("DB [%02x:%02x:%02x:%02x:%02x:%02x]",
                      bd_addr[0],  bd_addr[1],bd_addr[2],  bd_addr[3], bd_addr[4],  bd_addr[5]);

 if (btif_hl_find_app_idx(app_id, &app_idx))
 {
 if (btif_hl_find_mcl_idx(app_idx, bd_addr , &mcl_idx))
 {
            p_mcb = BTIF_HL_GET_MCL_CB_PTR(app_idx, mcl_idx);

            p_pcb = BTIF_HL_GET_PCB_PTR(app_idx, mcl_idx);
 if (!p_pcb->in_use)
 {
                p_mcb->req_ctrl_psm = p_dch_open_api->ctrl_psm;

                p_pcb->in_use = TRUE;
 *channel_id       =
                p_pcb->channel_id = (int) btif_hl_get_next_channel_id(app_id);
                p_pcb->cb_state = BTIF_HL_CHAN_CB_STATE_CONNECTING_PENDING;
                p_pcb->mdep_cfg_idx = mdep_cfg_idx;
                memcpy(p_pcb->bd_addr, bd_addr, sizeof(BD_ADDR));
                p_pcb->op = op;

 if (p_mcb->sdp.num_recs)
 {
 if (p_mcb->valid_sdp_idx)
 {
                        p_dch_open_api->ctrl_psm  = p_mcb->ctrl_psm;
 }

 if (!btif_hl_is_reconnect_possible(app_idx, mcl_idx, mdep_cfg_idx, p_dch_open_api, &mdl_id ))
 {

                        BTIF_TRACE_DEBUG("Issue DCH open" );
                        BTA_HlDchOpen(p_mcb->mcl_handle, p_dch_open_api);
 }
 else
 {
                        reconnect_param.ctrl_psm = p_mcb->ctrl_psm;
                        reconnect_param.mdl_id = mdl_id;;
                        BTIF_TRACE_DEBUG("Issue Reconnect ctrl_psm=0x%x mdl_id=0x%x",reconnect_param.ctrl_psm, reconnect_param.mdl_id   );
                        BTA_HlDchReconnect(p_mcb->mcl_handle, &reconnect_param);
 }

                    status = TRUE;
 }
 else
 {
                    p_acb = BTIF_HL_GET_APP_CB_PTR(app_idx);
                    p_mcb->cch_oper = BTIF_HL_CCH_OP_DCH_OPEN;
                    BTA_HlSdpQuery(app_id,p_acb->app_handle, bd_addr);
                    status = TRUE;
 }
 }
 }
 }

    BTIF_TRACE_DEBUG("status=%d ", status);
 return status;
}

static bt_status_t unregister_application(int app_id){
    UINT8               app_idx;
 int                 len;
 bt_status_t         status = BT_STATUS_SUCCESS;
 btif_hl_evt_cb_t    evt_param;

    CHECK_BTHL_INIT();
    BTIF_TRACE_EVENT("%s app_id=%d", __FUNCTION__, app_id);
    btif_hl_display_calling_process_name();

 if (btif_hl_find_app_idx(((UINT8)app_id), &app_idx))
 {
        evt_param.unreg.app_idx = app_idx;
        BTIF_HL_GET_APP_CB_PTR(app_idx);
        reg_counter --;
        len = sizeof(btif_hl_unreg_t);
        status = btif_transfer_context (btif_hl_proc_cb_evt, BTIF_HL_UNREG_APP,
 (char*) &evt_param, len, NULL);
        ASSERTC(status == BT_STATUS_SUCCESS, "context transfer failed", status);
 }
 else
 {
        status  = BT_STATUS_FAIL;
 }

    BTIF_TRACE_DEBUG("de-reg return status=%d", status);
 return status;
}

void btif_init_fail(UNUSED_ATTR uint16_t event, UNUSED_ATTR char *p_param) {
  BTIF_TRACE_DEBUG("btif_task: hardware init failed");
  bte_main_disable();
  btif_queue_release();
  bte_main_shutdown();
  btif_dut_mode = 0;

  future_ready(stack_manager_get_hack_future(), FUTURE_FAIL);
}

static void packet_finished(serial_data_type_t type) {
 if (!stream_has_interpretation)
    LOG_ERROR("%s with no existing stream interpretation.", __func__);
 else if (current_data_type != type)
    LOG_ERROR("%s with different type than existing interpretation.", __func__);

  stream_has_interpretation = false;
}

static inline int btif_hl_select_wake_signaled(fd_set* set){
    BTIF_TRACE_DEBUG("btif_hl_select_wake_signaled");
 return FD_ISSET(signal_fds[0], set);
}

void bta_hh_co_destroy(int fd)
{
 struct uhid_event ev;
    memset(&ev, 0, sizeof(ev));
    ev.type = UHID_DESTROY;
    uhid_write(fd, &ev);
    APPL_TRACE_DEBUG("%s: Closing fd=%d", __func__, fd);
    close(fd);
}

void  btif_hl_dch_abort(UINT8 app_idx, UINT8 mcl_idx){
 btif_hl_mcl_cb_t *p_mcb;

    BTIF_TRACE_DEBUG("%s app_idx=%d mcl_idx=%d",__FUNCTION__, app_idx, mcl_idx );
    p_mcb = BTIF_HL_GET_MCL_CB_PTR(app_idx, mcl_idx);
 if (p_mcb->is_connected)
 {
        BTA_HlDchAbort(p_mcb->mcl_handle);
 }
 else
 {
        p_mcb->pcb.abort_pending = TRUE;
 }

}

static int in_add_audio_effect(const struct audio_stream *stream, effect_handle_t effect)
{
    UNUSED(stream);
    UNUSED(effect);

    FNLOG();
 return 0;
}

static void btif_hl_proc_reg_cfm(tBTA_HL *p_data){
 btif_hl_app_cb_t *p_acb;
    UINT8                  app_idx;
 bthl_app_reg_state_t   state = BTHL_APP_REG_STATE_REG_SUCCESS;

    BTIF_TRACE_DEBUG("%s reg status=%d app_handle=%d", __FUNCTION__, p_data->reg_cfm.status, p_data->reg_cfm.app_handle);

 if (btif_hl_find_app_idx(p_data->reg_cfm.app_id, &app_idx))
 {
        p_acb = BTIF_HL_GET_APP_CB_PTR(app_idx);
 if (p_data->reg_cfm.status == BTA_HL_STATUS_OK)
 {
            p_acb->app_handle = p_data->reg_cfm.app_handle;
 }
 else
 {
            btif_hl_free_app_idx(app_idx);
            reg_counter--;
            state = BTHL_APP_REG_STATE_REG_FAILED;
 }

        BTIF_TRACE_DEBUG("%s call reg state callback app_id=%d reg state=%d", __FUNCTION__,  p_data->reg_cfm.app_id, state);
        BTIF_HL_CALL_CBACK(bt_hl_callbacks, app_reg_state_cb, ((int) p_data->reg_cfm.app_id), state );
 }
}

BOOLEAN check_cod_hid(const bt_bdaddr_t *remote_bdaddr, uint32_t cod)
{
 uint32_t    remote_cod;
 bt_property_t prop_name;

 /* check if we already have it in our btif_storage cache */
    BTIF_STORAGE_FILL_PROPERTY(&prop_name, BT_PROPERTY_CLASS_OF_DEVICE,
 sizeof(uint32_t), &remote_cod);
 if (btif_storage_get_remote_device_property((bt_bdaddr_t *)remote_bdaddr,
 &prop_name) == BT_STATUS_SUCCESS)
 {
        BTIF_TRACE_DEBUG("%s: remote_cod = 0x%06x", __FUNCTION__, remote_cod);
 if ((remote_cod & 0x700) == cod)
 return TRUE;
 }
 return FALSE;
}

void uipc_close_locked(tUIPC_CH_ID ch_id)
{
 if (uipc_main.ch[ch_id].srvfd == UIPC_DISCONNECTED)
 {
        BTIF_TRACE_EVENT("CHANNEL %d ALREADY CLOSED", ch_id);
 return;
 }

 /* schedule close on this channel */
    uipc_main.ch[ch_id].task_evt_flags |= UIPC_TASK_FLAG_DISCONNECT_CHAN;
    uipc_wakeup_locked();
}

static void event_finish_startup(UNUSED_ATTR void *context) {
  LOG_INFO("%s", __func__);
  hal->open();
  vendor->send_async_command(VENDOR_CONFIGURE_FIRMWARE, NULL);
}

static waiting_command_t *get_waiting_command(command_opcode_t opcode) {
  pthread_mutex_lock(&commands_pending_response_lock);

 for (const list_node_t *node = list_begin(commands_pending_response);
      node != list_end(commands_pending_response);
      node = list_next(node)) {
 waiting_command_t *wait_entry = list_node(node);

 if (!wait_entry || wait_entry->opcode != opcode)
 continue;

    list_remove(commands_pending_response, wait_entry);

    pthread_mutex_unlock(&commands_pending_response_lock);
 return wait_entry;
 }

  pthread_mutex_unlock(&commands_pending_response_lock);
 return NULL;
}

void btif_hl_select_monitor_callback(fd_set *p_cur_set ,fd_set *p_org_set) {
UNUSED(p_org_set);

BTIF_TRACE_DEBUG("entering %s",__FUNCTION__);

for (const list_node_t *node = list_begin(soc_queue);
node != list_end(soc_queue); node = list_next(node)) {
btif_hl_soc_cb_t *p_scb = list_node(node);
if (btif_hl_get_socket_state(p_scb) == BTIF_HL_SOC_STATE_W4_READ) {
if (FD_ISSET(p_scb->socket_id[1], p_cur_set)) {
BTIF_TRACE_DEBUG("read data state= BTIF_HL_SOC_STATE_W4_READ");
btif_hl_mdl_cb_t *p_dcb = BTIF_HL_GET_MDL_CB_PTR(p_scb->app_idx,
p_scb->mcl_idx, p_scb->mdl_idx);
assert(p_dcb != NULL);
if (p_dcb->p_tx_pkt) {
BTIF_TRACE_ERROR("Rcv new pkt but the last pkt is still not been"
"  sent tx_size=%d", p_dcb->tx_size);
btif_hl_free_buf((void **) &p_dcb->p_tx_pkt);

}
p_dcb->p_tx_pkt = btif_hl_get_buf (p_dcb->mtu);
if (p_dcb) {
                    int r = (int)recv(p_scb->socket_id[1], p_dcb->p_tx_pkt,
                            p_dcb->mtu, MSG_DONTWAIT);
if (r > 0) {
BTIF_TRACE_DEBUG("btif_hl_select_monitor_callback send data r =%d", r);
p_dcb->tx_size = r;
BTIF_TRACE_DEBUG("btif_hl_select_monitor_callback send data tx_size=%d", p_dcb->tx_size );
BTA_HlSendData(p_dcb->mdl_handle, p_dcb->tx_size);
} else {
BTIF_TRACE_DEBUG("btif_hl_select_monitor_callback receive failed r=%d",r);
BTA_HlDchClose(p_dcb->mdl_handle);
}
}
}
}
}

if (list_is_empty(soc_queue))
BTIF_TRACE_DEBUG("btif_hl_select_monitor_queue is empty");

BTIF_TRACE_DEBUG("leaving %s",__FUNCTION__);
}

static int adev_set_voice_volume(struct audio_hw_device *dev, float volume)
{
    UNUSED(dev);
    UNUSED(volume);

    FNLOG();

 return -ENOSYS;
}

const char *config_get_string(const config_t *config, const char *section, const char *key, const char *def_value) {
  assert(config != NULL);
  assert(section != NULL);
  assert(key != NULL);

 entry_t *entry = entry_find(config, section, key);
 if (!entry)
 return def_value;

 return entry->value;
}

BOOLEAN btif_hl_find_mdl_idx_using_channel_id(int channel_id,
                                              UINT8 *p_app_idx,UINT8 *p_mcl_idx,
                                              UINT8 *p_mdl_idx){
 btif_hl_app_cb_t *p_acb;
 btif_hl_mcl_cb_t *p_mcb;
 btif_hl_mdl_cb_t *p_dcb;
    BOOLEAN found=FALSE;
    UINT8 i,j,k;

 for (i=0; i < BTA_HL_NUM_APPS ; i ++)
 {
        p_acb =BTIF_HL_GET_APP_CB_PTR(i);
 for (j=0; j< BTA_HL_NUM_MCLS; j++)
 {
            p_mcb =BTIF_HL_GET_MCL_CB_PTR(i,j);
 for (k=0; k< BTA_HL_NUM_MDLS_PER_MCL; k++)
 {
                p_dcb =BTIF_HL_GET_MDL_CB_PTR(i,j,k);
 if (p_acb->in_use &&
                    p_mcb->in_use &&
                    p_dcb->in_use &&
 (p_dcb->channel_id == channel_id))
 {
                    found = TRUE;
 *p_app_idx = i;
 *p_mcl_idx =j;
 *p_mdl_idx = k;
 break;
 }
 }
 }
 }
    BTIF_TRACE_DEBUG("%s found=%d app_idx=%d mcl_idx=%d mdl_idx=%d  ",
                      __FUNCTION__,found,i,j,k );
 return found;
}

static uint32_t in_get_input_frames_lost(struct audio_stream_in *stream)
{
    UNUSED(stream);

    FNLOG();
 return 0;
}

void btif_hl_set_chan_cb_state(UINT8 app_idx, UINT8 mcl_idx, btif_hl_chan_cb_state_t state){
 btif_hl_pending_chan_cb_t *p_pcb = BTIF_HL_GET_PCB_PTR(app_idx, mcl_idx);
 btif_hl_chan_cb_state_t cur_state = p_pcb->cb_state;

 if (cur_state != state)
 {
        p_pcb->cb_state = state;
        BTIF_TRACE_DEBUG("%s state %d--->%d",__FUNCTION__, cur_state, state);
 }


}

static int help(int argc, char **argv) {
 if (!argc) {
    printf("No help command specified.\n");
 return 1;
 }

 const command_t *command = find_command(argv[0]);
 if (!command) {
    printf("No command named '%s'.\n", argv[0]);
 return 2;
 }

  printf("%s %s\n", argv[0], command->help);
 return 0;
}

static BOOLEAN btif_hl_proc_dch_reconnect_cfm(tBTA_HL *p_data)
{
 btif_hl_mdl_cb_t *p_dcb;
 btif_hl_pending_chan_cb_t *p_pcb;
    UINT8                    app_idx, mcl_idx, mdl_idx, mdep_cfg_idx;
    BOOLEAN                  status = FALSE;
    BOOLEAN                  close_dch = FALSE;

    BTIF_TRACE_DEBUG("%s", __FUNCTION__);

    btif_hl_find_app_idx_using_mdepId(p_data->dch_reconnect_cfm.local_mdep_id,&app_idx);

 if (btif_hl_find_mcl_idx_using_app_idx(p_data->dch_reconnect_cfm.mcl_handle, app_idx, &mcl_idx ))
 {
        BTIF_HL_GET_APP_CB_PTR(app_idx);
        BTIF_HL_GET_MCL_CB_PTR(app_idx, mcl_idx);
        p_pcb = BTIF_HL_GET_PCB_PTR(app_idx, mcl_idx);

 if (btif_hl_find_avail_mdl_idx(app_idx, mcl_idx, &mdl_idx))
 {
            p_dcb = BTIF_HL_GET_MDL_CB_PTR(app_idx, mcl_idx, mdl_idx);

 if (btif_hl_find_mdep_cfg_idx(app_idx, p_data->dch_reconnect_cfm.local_mdep_id, &mdep_cfg_idx))
 {
                p_dcb->in_use               = TRUE;
                p_dcb->mdl_handle           = p_data->dch_reconnect_cfm.mdl_handle;
                p_dcb->local_mdep_cfg_idx   = mdep_cfg_idx;
                p_dcb->local_mdep_id        = p_data->dch_reconnect_cfm.local_mdep_id;
                p_dcb->mdl_id               = p_data->dch_reconnect_cfm.mdl_id;
                p_dcb->dch_mode             = p_data->dch_reconnect_cfm.dch_mode;
                p_dcb->is_the_first_reliable= p_data->dch_reconnect_cfm.first_reliable;
                p_dcb->mtu                  = p_data->dch_reconnect_cfm.mtu;
                p_dcb->channel_id           = p_pcb->channel_id;

                BTIF_TRACE_DEBUG("app_idx=%d mcl_idx=%d mdl_idx=%d",  app_idx, mcl_idx, mdl_idx  );
                btif_hl_send_setup_connecting_cb(app_idx, mcl_idx);
 if (btif_hl_create_socket(app_idx, mcl_idx, mdl_idx))
 {
                    status = TRUE;
                    BTIF_TRACE_DEBUG("app_idx=%d mcl_idx=%d mdl_idx=%d p_dcb->channel_id=0x%08x",
                                      app_idx, mcl_idx, mdl_idx, p_dcb->channel_id);
                    btif_hl_clean_pcb(p_pcb);
 }
 else
 {
                    BTIF_TRACE_ERROR("Unable to create socket");
                    close_dch = TRUE;
 }
 }
 else
 {
                BTIF_TRACE_ERROR("INVALID_LOCAL_MDEP_ID mdep_id=%d",p_data->dch_open_cfm.local_mdep_id);
                close_dch = TRUE;
 }

 if (close_dch)
 {
                btif_hl_clean_mdl_cb(p_dcb);
                BTA_HlDchClose(p_data->dch_reconnect_cfm.mdl_handle);
 }
 }
 }

 return status;

}

static void btif_hl_proc_abort_ind(tBTA_HL_MCL_HANDLE mcl_handle){

    BTIF_TRACE_DEBUG("%s", __FUNCTION__ );
 btif_hl_app_cb_t *p_acb;
    UINT8 i,j;

 for (i=0; i<BTA_HL_NUM_APPS; i++)
 {
        p_acb =BTIF_HL_GET_APP_CB_PTR(i);
 for (j=0; j < BTA_HL_NUM_MCLS ; j++)
 {
 if (p_acb->mcb[j].in_use)
                BTIF_TRACE_DEBUG("btif_hl_find_mcl_idx_using_handle: app_idx=%d,mcl_idx =%d mcl_handle=%d",i,j,p_acb->mcb[j].mcl_handle);
 if (p_acb->mcb[j].in_use &&
 (p_acb->mcb[j].mcl_handle == mcl_handle))
 {
                btif_hl_stop_cch_timer(i, j);
                btif_hl_send_setup_disconnected_cb(i, j);
                btif_hl_clean_mcl_cb(i, j);
 }
 }
 }
}

int bta_co_rfc_data_outgoing_size(void *user_data, int *size) {
pthread_mutex_lock(&slot_lock);

uint32_t id = (uintptr_t)user_data;
int ret = false;
*size = 0;
rfc_slot_t *slot = find_rfc_slot_by_id(id);

if (!slot)
goto out;

  if (ioctl(slot->fd, FIONREAD, size) == 0) {
ret = true;
} else {
LOG_ERROR("%s unable to determine bytes remaining to be read on fd %d: %s", __func__, slot->fd, strerror(errno));
cleanup_rfc_slot(slot);
}

out:;
pthread_mutex_unlock(&slot_lock);
return ret;
}

bt_status_t btsock_l2cap_listen(const char* name, int channel, int* sock_fd, int flags)
{
 return btsock_l2cap_listen_or_connect(name, NULL, channel, sock_fd, flags, 1);
}

static void btif_jni_disassociate(UNUSED_ATTR uint16_t event, UNUSED_ATTR char *p_param) {
  BTIF_TRACE_DEBUG("%s Disassociating thread from JVM", __func__);
  HAL_CBACK(bt_hal_cbacks, thread_evt_cb, DISASSOCIATE_JVM);
  bt_hal_cbacks = NULL;
  future_ready(stack_manager_get_hack_future(), FUTURE_SUCCESS);
}

void bta_hl_co_put_rx_data (UINT8 app_id, tBTA_HL_MDL_HANDLE mdl_handle,
UINT16 data_size, UINT8 *p_data, UINT16 evt)
{
UINT8 app_idx, mcl_idx, mdl_idx;
btif_hl_mdl_cb_t *p_dcb;
tBTA_HL_STATUS status = BTA_HL_STATUS_FAIL;
int            r;
BTIF_TRACE_DEBUG("%s app_id=%d mdl_handle=0x%x data_size=%d",
__FUNCTION__,app_id, mdl_handle, data_size);

if (btif_hl_find_mdl_idx_using_handle(mdl_handle, &app_idx, &mcl_idx, &mdl_idx))
{
p_dcb = BTIF_HL_GET_MDL_CB_PTR(app_idx, mcl_idx, mdl_idx);

if ((p_dcb->p_rx_pkt = (UINT8 *)btif_hl_get_buf(data_size)) != NULL)
{
memcpy(p_dcb->p_rx_pkt, p_data, data_size);
if (p_dcb->p_scb)

{
BTIF_TRACE_DEBUG("app_idx=%d mcl_idx=0x%x mdl_idx=0x%x data_size=%d",
app_idx, mcl_idx, mdl_idx, data_size);
                r = send(p_dcb->p_scb->socket_id[1], p_dcb->p_rx_pkt, data_size, 0);

if (r == data_size)
{
BTIF_TRACE_DEBUG("socket send success data_size=%d",  data_size);
status = BTA_HL_STATUS_OK;
}
else
{
BTIF_TRACE_ERROR("socket send failed r=%d data_size=%d",r, data_size);
}


}
btif_hl_free_buf((void **) &p_dcb->p_rx_pkt);
}
}

bta_hl_ci_put_rx_data(mdl_handle,  status, evt);
}

static void btif_hl_init_next_channel_id(void){
    btif_hl_cb.next_channel_id = 1;
}

bt_status_t btif_dut_mode_send(uint16_t opcode, uint8_t *buf, uint8_t len)
{
 /* TODO: Check that opcode is a vendor command group */
    BTIF_TRACE_DEBUG("%s", __FUNCTION__);
 if (!btif_is_dut_mode()) {
         BTIF_TRACE_ERROR("Bluedroid HAL needs to be init with test_mode set to 1.");
 return BT_STATUS_FAIL;
 }
    BTM_VendorSpecificCommand(opcode, len, buf, btif_dut_mode_cback);
 return BT_STATUS_SUCCESS;
}

static inline int accept_server_socket(int s)

{
struct sockaddr_un client_address;
socklen_t clen;
    int fd = accept(s, (struct sockaddr*)&client_address, &clen);
APPL_TRACE_DEBUG("accepted fd:%d for server fd:%d", fd, s);
return fd;
}

BOOLEAN btif_hl_find_app_idx(UINT8 app_id, UINT8 *p_app_idx){
    BOOLEAN found=FALSE;
    UINT8 i;

 for (i=0; i < BTA_HL_NUM_APPS ; i ++)
 {

 if (btif_hl_cb.acb[i].in_use &&
 (btif_hl_cb.acb[i].app_id == app_id))
 {
            found = TRUE;
 *p_app_idx = i;
 break;
 }
 }
    BTIF_TRACE_DEBUG("%s found=%d app_idx=%d", __FUNCTION__, found, i );

 return found;
}

static int forward_bnep(tETH_HDR* eth_hdr, BT_HDR *hdr) {
 int broadcast = eth_hdr->h_dest[0] & 1;

 for (int i = 0; i < MAX_PAN_CONNS; i++)
 {
        UINT16 handle = btpan_cb.conns[i].handle;
 if (handle != (UINT16)-1 &&
 (broadcast || memcmp(btpan_cb.conns[i].eth_addr, eth_hdr->h_dest, sizeof(BD_ADDR)) == 0
 || memcmp(btpan_cb.conns[i].peer, eth_hdr->h_dest, sizeof(BD_ADDR)) == 0)) {
 int result = PAN_WriteBuf(handle, eth_hdr->h_dest, eth_hdr->h_src, ntohs(eth_hdr->h_proto), hdr, 0);
 switch (result) {
 case PAN_Q_SIZE_EXCEEDED:
 return FORWARD_CONGEST;
 case PAN_SUCCESS:
 return FORWARD_SUCCESS;
 default:
 return FORWARD_FAILURE;
 }
 }
 }
    GKI_freebuf(hdr);
 return FORWARD_IGNORE;
}

int btpan_tap_close(int fd)
{
 if (tap_if_down(TAP_IF_NAME) == 0)
        close(fd);
 if (pan_pth >= 0)
        btsock_thread_wakeup(pan_pth);
 return 0;
}

void bta_hl_co_delete_mdl(UINT8 mdep_id, UINT8 item_idx)
{


    BTIF_TRACE_DEBUG("%s mdep_id=%d, item_idx=%d", __FUNCTION__, mdep_id, item_idx);

    btif_hl_delete_mdl_cfg(mdep_id, item_idx);


}

bt_status_t btif_dm_create_bond(const bt_bdaddr_t *bd_addr, int transport)
{
 btif_dm_create_bond_cb_t create_bond_cb;
    create_bond_cb.transport = transport;
    bdcpy(create_bond_cb.bdaddr.address, bd_addr->address);

 bdstr_t bdstr;
    BTIF_TRACE_EVENT("%s: bd_addr=%s, transport=%d", __FUNCTION__, bdaddr_to_string(bd_addr, bdstr, sizeof(bdstr)), transport);
 if (pairing_cb.state != BT_BOND_STATE_NONE)
 return BT_STATUS_BUSY;

    btif_transfer_context(btif_dm_generic_evt, BTIF_DM_CB_CREATE_BOND,
 (char *)&create_bond_cb, sizeof(btif_dm_create_bond_cb_t), NULL);

 return BT_STATUS_SUCCESS;
}

static l2cap_socket *btsock_l2cap_alloc_l(const char *name, const bt_bdaddr_t *addr,
 char is_server, int flags)
{
    l2cap_socket *sock;
 unsigned security = 0;
 int fds[2];

 if (flags & BTSOCK_FLAG_ENCRYPT)
        security |= is_server ? BTM_SEC_IN_ENCRYPT : BTM_SEC_OUT_ENCRYPT;
 if (flags & BTSOCK_FLAG_AUTH)
        security |= is_server ? BTM_SEC_IN_AUTHENTICATE : BTM_SEC_OUT_AUTHENTICATE;
 if (flags & BTSOCK_FLAG_AUTH_MITM)
        security |= is_server ? BTM_SEC_IN_MITM : BTM_SEC_OUT_MITM;
 if (flags & BTSOCK_FLAG_AUTH_16_DIGIT)
        security |= BTM_SEC_IN_MIN_16_DIGIT_PIN;

    sock = osi_calloc(sizeof(*sock));
 if (!sock) {
        APPL_TRACE_ERROR("alloc failed");
 goto fail_alloc;
 }

 if (socketpair(AF_LOCAL, SOCK_SEQPACKET, 0, fds)) {
        APPL_TRACE_ERROR("socketpair failed, errno:%d", errno);
 goto fail_sockpair;
 }

    sock->our_fd = fds[0];
    sock->app_fd = fds[1];
    sock->security = security;
    sock->server = is_server;
    sock->connected = FALSE;
    sock->handle = 0;
    sock->server_psm_sent = FALSE;

 if (name)
        strncpy(sock->name, name, sizeof(sock->name) - 1);
 if (addr)
        sock->addr = *addr;

    sock->first_packet = NULL;
    sock->last_packet = NULL;

    sock->next = socks;
    sock->prev = NULL;
 if (socks)
        socks->prev = sock;
    sock->id = (socks ? socks->id : 0) + 1;
    socks = sock;
 /* paranoia cap on: verify no ID duplicates due to overflow and fix as needed */
 while (1) {
        l2cap_socket *t;
        t = socks->next;
 while (t && t->id != sock->id) {
            t = t->next;
 }
 if (!t && sock->id) /* non-zeor handle is unique -> we're done */
 break;
 /* if we're here, we found a duplicate */
 if (!++sock->id) /* no zero IDs allowed */
            sock->id++;
 }
    APPL_TRACE_DEBUG("SOCK_LIST: alloc(id = %d)", sock->id);
 return sock;

fail_sockpair:
    osi_free(sock);

fail_alloc:
 return NULL;
}

bool reactor_change_registration(reactor_object_t *object,
 void (*read_ready)(void *context),
 void (*write_ready)(void *context)) {
  assert(object != NULL);

 struct epoll_event event;
  memset(&event, 0, sizeof(event));
 if (read_ready)
    event.events |= (EPOLLIN | EPOLLRDHUP);
 if (write_ready)
    event.events |= EPOLLOUT;
  event.data.ptr = object;

 if (epoll_ctl(object->reactor->epoll_fd, EPOLL_CTL_MOD, object->fd, &event) == -1) {
    LOG_ERROR("%s unable to modify interest set for fd %d: %s", __func__, object->fd, strerror(errno));
 return false;
 }

  pthread_mutex_lock(&object->lock);
  object->read_ready = read_ready;
  object->write_ready = write_ready;
  pthread_mutex_unlock(&object->lock);

 return true;
}

static int alloc_thread_slot()
{
 int i;
 for(i = MAX_THREAD - 1; i >=0; i--)
 {
        APPL_TRACE_DEBUG("ts[%d].used:%d", i, ts[i].used);
 if(!ts[i].used)
 {
            ts[i].used = 1;
 return i;
 }
 }
    APPL_TRACE_ERROR("execeeded max thread count");
 return -1;
}

bt_status_t btif_dm_pin_reply( const bt_bdaddr_t *bd_addr, uint8_t accept,
 uint8_t pin_len, bt_pin_code_t *pin_code)
{
    BTIF_TRACE_EVENT("%s: accept=%d", __FUNCTION__, accept);
 if (pin_code == NULL || pin_len > PIN_CODE_LEN)
 return BT_STATUS_FAIL;
#if (defined(BLE_INCLUDED) && (BLE_INCLUDED == TRUE))

 if (pairing_cb.is_le_only)
 {
 int i;
        UINT32 passkey = 0;
 int multi[] = {100000, 10000, 1000, 100, 10,1};
        BD_ADDR remote_bd_addr;
        bdcpy(remote_bd_addr, bd_addr->address);
 for (i = 0; i < 6; i++)
 {
            passkey += (multi[i] * (pin_code->pin[i] - '0'));
 }
        BTIF_TRACE_DEBUG("btif_dm_pin_reply: passkey: %d", passkey);
        BTA_DmBlePasskeyReply(remote_bd_addr, accept, passkey);

 }
 else
 {
        BTA_DmPinReply( (UINT8 *)bd_addr->address, accept, pin_len, pin_code->pin);
 if (accept)
            pairing_cb.pin_code_len = pin_len;
 }
#else
    BTA_DmPinReply( (UINT8 *)bd_addr->address, accept, pin_len, pin_code->pin);

 if (accept)
        pairing_cb.pin_code_len = pin_len;
#endif
 return BT_STATUS_SUCCESS;
}

static void uipc_check_interrupt_locked(void)
{
if (SAFE_FD_ISSET(uipc_main.signal_fds[0], &uipc_main.read_set))

{
char sig_recv = 0;
//BTIF_TRACE_EVENT("UIPC INTERRUPT");
        recv(uipc_main.signal_fds[0], &sig_recv, sizeof(sig_recv), MSG_WAITALL);
}
}

void btpan_set_flow_control(BOOLEAN enable) {
 if (btpan_cb.tap_fd == -1)
 return;

    btpan_cb.flow = enable;
 if (enable) {
        btsock_thread_add_fd(pan_pth, btpan_cb.tap_fd, 0, SOCK_THREAD_FD_RD, 0);
        bta_dmexecutecallback(btu_exec_tap_fd_read, (void *)btpan_cb.tap_fd);
 }
}

void btsock_rfc_cleanup(void) {
  pth = -1;

  pthread_mutex_lock(&slot_lock);
 for (size_t i = 0; i < ARRAY_SIZE(rfc_slots); ++i) {
 if (rfc_slots[i].id)
      cleanup_rfc_slot(&rfc_slots[i]);
    list_free(rfc_slots[i].incoming_queue);
 }
  pthread_mutex_unlock(&slot_lock);
}

static size_t read_data(serial_data_type_t type, uint8_t *buffer, size_t max_size, bool block) {
 if (type == DATA_TYPE_ACL) {
 return eager_reader_read(acl_stream, buffer, max_size, block);
 } else if (type == DATA_TYPE_EVENT) {
 return eager_reader_read(event_stream, buffer, max_size, block);
 }

  LOG_ERROR("%s invalid data type: %d", __func__, type);
 return 0;
}

static l2cap_socket *btsock_l2cap_alloc(const char *name, const bt_bdaddr_t *addr,
 char is_server, int flags)
{
    l2cap_socket *ret;

    pthread_mutex_lock(&state_lock);
    ret = btsock_l2cap_alloc_l(name, addr, is_server, flags);
    pthread_mutex_unlock(&state_lock);

 return ret;
}

bt_status_t  get_transaction(rc_transaction_t **ptransaction)
{
 bt_status_t result = BT_STATUS_NOMEM;
    UINT8 i=0;
    pthread_mutex_lock(&device.lbllock);

 for (i=0; i<MAX_TRANSACTIONS_PER_SESSION; i++)
 {
 if (FALSE==device.transaction[i].in_use)
 {
            BTIF_TRACE_DEBUG("%s:Got transaction.label: %d",__FUNCTION__,device.transaction[i].lbl);
            device.transaction[i].in_use = TRUE;
 *ptransaction = &(device.transaction[i]);
            result = BT_STATUS_SUCCESS;
 break;
 }
 }

    pthread_mutex_unlock(&device.lbllock);
 return result;
}

static int out_dump(const struct audio_stream *stream, int fd)
{
    UNUSED(fd);
 struct a2dp_stream_out *out = (struct a2dp_stream_out *)stream;
    FNLOG();
 return 0;
}

static inline void byte2char(const char* data, char** str)
{
 **str = *data < ' ' ? '.' : *data > '~' ? '.' : *data;
 ++(*str);
}

static void btif_hl_cback(tBTA_HL_EVT event, tBTA_HL *p_data){
 bt_status_t status;
 int param_len = 0;
    BTIF_TRACE_DEBUG("%s event %d", __FUNCTION__, event);
    btif_hl_display_calling_process_name();
 switch (event)
 {
 case BTA_HL_REGISTER_CFM_EVT:
            param_len = sizeof(tBTA_HL_REGISTER_CFM);
 break;
 case BTA_HL_SDP_INFO_IND_EVT:
            param_len = sizeof(tBTA_HL_SDP_INFO_IND);
 break;
 case BTA_HL_DEREGISTER_CFM_EVT:
            param_len = sizeof(tBTA_HL_DEREGISTER_CFM);
 break;
 case BTA_HL_SDP_QUERY_CFM_EVT:
            param_len = sizeof(tBTA_HL_SDP_QUERY_CFM);
 break;
 case BTA_HL_CCH_OPEN_CFM_EVT:
            param_len = sizeof(tBTA_HL_CCH_OPEN_CFM);
 break;
 case BTA_HL_DCH_OPEN_CFM_EVT:
            param_len = sizeof(tBTA_HL_DCH_OPEN_CFM);
 break;
 case BTA_HL_CCH_OPEN_IND_EVT:
            param_len = sizeof(tBTA_HL_CCH_OPEN_IND);
 break;
 case BTA_HL_DCH_CREATE_IND_EVT:
            param_len = sizeof(tBTA_HL_DCH_CREATE_IND);
 break;
 case BTA_HL_DCH_OPEN_IND_EVT:
            param_len = sizeof(tBTA_HL_DCH_OPEN_IND);
 break;
 case BTA_HL_DELETE_MDL_IND_EVT:
            param_len = sizeof(tBTA_HL_MDL_IND);
 break;
 case BTA_HL_DELETE_MDL_CFM_EVT:
            param_len = sizeof(tBTA_HL_MDL_CFM);
 break;
 case BTA_HL_DCH_RECONNECT_CFM_EVT:
            param_len = sizeof(tBTA_HL_DCH_OPEN_CFM);
 break;
 case BTA_HL_CCH_CLOSE_CFM_EVT:
            param_len = sizeof(tBTA_HL_MCL_CFM);
 break;
 case BTA_HL_CCH_CLOSE_IND_EVT:
            param_len = sizeof(tBTA_HL_CCH_CLOSE_IND);
 break;
 case BTA_HL_DCH_CLOSE_IND_EVT:
            param_len = sizeof(tBTA_HL_DCH_CLOSE_IND);
 break;
 case BTA_HL_DCH_CLOSE_CFM_EVT:
            param_len = sizeof(tBTA_HL_MDL_CFM);
 break;
 case BTA_HL_DCH_ECHO_TEST_CFM_EVT:
            param_len = sizeof(tBTA_HL_MCL_CFM);
 break;
 case BTA_HL_DCH_RECONNECT_IND_EVT:
            param_len = sizeof(tBTA_HL_DCH_OPEN_IND);
 break;
 case BTA_HL_CONG_CHG_IND_EVT:
            param_len = sizeof(tBTA_HL_DCH_CONG_IND);
 break;
 case BTA_HL_DCH_ABORT_IND_EVT:
            param_len = sizeof(tBTA_HL_MCL_IND);
 break;
 case BTA_HL_DCH_ABORT_CFM_EVT:
            param_len = sizeof(tBTA_HL_MCL_CFM);
 break;
 case BTA_HL_DCH_SEND_DATA_CFM_EVT:
            param_len = sizeof(tBTA_HL_MDL_CFM);
 break;
 case BTA_HL_DCH_RCV_DATA_IND_EVT:
            param_len = sizeof(tBTA_HL_MDL_IND);
 break;
 default:
            param_len = sizeof(tBTA_HL_MDL_IND);
 break;
 }
    status = btif_transfer_context(btif_hl_upstreams_evt, (uint16_t)event, (void*)p_data, param_len, NULL);

 /* catch any failed context transfers */
    ASSERTC(status == BT_STATUS_SUCCESS, "context transfer failed", status);
}

void UIPC_Close(tUIPC_CH_ID ch_id)
{
    BTIF_TRACE_DEBUG("UIPC_Close : ch_id %d", ch_id);

 /* special case handling uipc shutdown */
 if (ch_id != UIPC_CH_ID_ALL)
 {
        UIPC_LOCK();
        uipc_close_locked(ch_id);
        UIPC_UNLOCK();
 }
 else
 {
        BTIF_TRACE_DEBUG("UIPC_Close : waiting for shutdown to complete");
        uipc_stop_main_server_thread();
        BTIF_TRACE_DEBUG("UIPC_Close : shutdown complete");
 }
}

void btsock_l2cap_signaled(int fd, int flags, uint32_t user_id)
{
l2cap_socket *sock;
char drop_it = FALSE;

/* We use MSG_DONTWAIT when sending data to JAVA, hence it can be accepted to hold the lock. */
pthread_mutex_lock(&state_lock);
sock = btsock_l2cap_find_by_id_l(user_id);
if (sock) {
if ((flags & SOCK_THREAD_FD_RD) && !sock->server) {
//app sending data

if (sock->connected) {
int size = 0;

                if (!(flags & SOCK_THREAD_FD_EXCEPTION) || (ioctl(sock->our_fd, FIONREAD, &size)
== 0 && size)) {
uint8_t *buffer = osi_malloc(L2CAP_MAX_SDU_LENGTH);
//uint8_t *buffer = (uint8_t*)GKI_getbuf(L2CAP_MAX_SDU_LENGTH);
/* Apparently we hijack the req_id (UINT32) to pass the pointer to the buffer to
* the write complete callback, which call a free... wonder if this works on a
* 64 bit platform? */
if (buffer != NULL) {
/* The socket is created with SOCK_SEQPACKET, hence we read one message at
* the time. The maximum size of a message is allocated to ensure data is
* not lost. This is okay to do as Android uses virtual memory, hence even
* if we only use a fraction of the memory it should not block for others
* to use the memory. As the definition of ioctl(FIONREAD) do not clearly
* define what value will be returned if multiple messages are written to
* the socket before any message is read from the socket, we could
* potentially risk to allocate way more memory than needed. One of the use
* cases for this socket is obex where multiple 64kbyte messages are
* typically written to the socket in a tight loop, hence we risk the ioctl
* will return the total amount of data in the buffer, which could be
* multiple 64kbyte chunks.
* UPDATE: As bluedroid cannot handle 64kbyte buffers, the size is reduced
* to around 8kbyte - and using malloc for buffer allocation here seems to
* be wrong

* UPDATE: Since we are responsible for freeing the buffer in the
* write_complete_ind, it is OK to use malloc. */

                        int count = recv(fd, buffer, L2CAP_MAX_SDU_LENGTH,
                                MSG_NOSIGNAL | MSG_DONTWAIT);
APPL_TRACE_DEBUG("btsock_l2cap_signaled - %d bytes received from socket",
count);
if (sock->fixed_chan) {
if(BTA_JvL2capWriteFixed(sock->channel, (BD_ADDR*)&sock->addr,
(UINT32)buffer, btsock_l2cap_cbk, buffer, count,
(void *)user_id) != BTA_JV_SUCCESS) {
// On fail, free the buffer
on_l2cap_write_fixed_done(buffer, user_id);
}
} else {
if(BTA_JvL2capWrite(sock->handle, (UINT32)buffer, buffer, count,
(void *)user_id) != BTA_JV_SUCCESS) {
// On fail, free the buffer
on_l2cap_write_done(buffer, user_id);
}
}
} else {
// This cannot happen.
APPL_TRACE_ERROR("Unable to allocate memory for data packet from JAVA...")
}
}
} else
drop_it = TRUE;
}
if (flags & SOCK_THREAD_FD_WR) {
//app is ready to receive more data, tell stack to enable the data flow
if (flush_incoming_que_on_wr_signal_l(sock) && sock->connected)
btsock_thread_add_fd(pth, sock->our_fd, BTSOCK_L2CAP, SOCK_THREAD_FD_WR, sock->id);

}
if (drop_it || (flags & SOCK_THREAD_FD_EXCEPTION)) {
int size = 0;
            if (drop_it || ioctl(sock->our_fd, FIONREAD, &size) != 0 || size == 0)
btsock_l2cap_free_l(sock);
}
}
pthread_mutex_unlock(&state_lock);
}

static void transmit_downward(data_dispatcher_type_t type, void *data) {
 if (type == MSG_STACK_TO_HC_HCI_CMD) {
    transmit_command((BT_HDR *)data, NULL, NULL, NULL);
    LOG_WARN("%s legacy transmit of command. Use transmit_command instead.", __func__);
 } else {
    fixed_queue_enqueue(packet_queue, data);
 }
}

static void btpan_open_conn(btpan_conn_t* conn, tBTA_PAN *p_data)
{
    BTIF_TRACE_API("btpan_open_conn: local_role:%d, peer_role: %d,  handle:%d, conn: %p",
            p_data->open.local_role, p_data->open.peer_role, p_data->open.handle, conn);

 if (conn == NULL)
        conn = btpan_new_conn(p_data->open.handle, p_data->open.bd_addr, p_data->open.local_role,
                p_data->open.peer_role);
 if (conn)
 {
        BTIF_TRACE_DEBUG("btpan_open_conn:tap_fd:%d, open_count:%d, "
 "conn->handle:%d should = handle:%d, local_role:%d, remote_role:%d",
                btpan_cb.tap_fd, btpan_cb.open_count, conn->handle, p_data->open.handle,
                conn->local_role, conn->remote_role);

        btpan_cb.open_count++;
        conn->handle = p_data->open.handle;
 if (btpan_cb.tap_fd < 0)
 {
            btpan_cb.tap_fd = btpan_tap_open();
 if(btpan_cb.tap_fd >= 0)
                create_tap_read_thread(btpan_cb.tap_fd);
 }

 if (btpan_cb.tap_fd >= 0)
 {
            btpan_cb.flow = 1;
            conn->state = PAN_STATE_OPEN;
 }
 }
}

static int a2dp_read_audio_config(struct a2dp_stream_common *common)
{
 char cmd = A2DP_CTRL_GET_AUDIO_CONFIG;
 uint32_t sample_rate;
 uint8_t channel_count;

 if (a2dp_command(common, A2DP_CTRL_GET_AUDIO_CONFIG) < 0)
 {
        ERROR("check a2dp ready failed");
 return -1;
 }

 if (a2dp_ctrl_receive(common, &sample_rate, 4) < 0)
 return -1;
 if (a2dp_ctrl_receive(common, &channel_count, 1) < 0)
 return -1;

    common->cfg.channel_flags = (channel_count == 1 ? AUDIO_CHANNEL_IN_MONO : AUDIO_CHANNEL_IN_STEREO);
    common->cfg.format = AUDIO_STREAM_DEFAULT_FORMAT;
    common->cfg.rate = sample_rate;

    INFO("got config %d %d", common->cfg.format, common->cfg.rate);

 return 0;
}

BOOLEAN check_hid_le(const bt_bdaddr_t *remote_bdaddr)
{
 uint32_t    remote_dev_type;
 bt_property_t prop_name;

 /* check if we already have it in our btif_storage cache */
    BTIF_STORAGE_FILL_PROPERTY(&prop_name,BT_PROPERTY_TYPE_OF_DEVICE,
 sizeof(uint32_t), &remote_dev_type);
 if (btif_storage_get_remote_device_property((bt_bdaddr_t *)remote_bdaddr,
 &prop_name) == BT_STATUS_SUCCESS)
 {
 if (remote_dev_type == BT_DEVICE_DEVTYPE_BLE)
 {
 bdstr_t bdstr;
            bdaddr_to_string(remote_bdaddr, bdstr, sizeof(bdstr));
 if(btif_config_exist(bdstr, "HidAppId"))
 return TRUE;
 }
 }
 return FALSE;
}

void eager_reader_free(eager_reader_t *reader) {
 if (!reader)
 return;

  eager_reader_unregister(reader);

 if (reader->inbound_read_object)
    reactor_unregister(reader->inbound_read_object);

 if (reader->bytes_available_fd != INVALID_FD)
    close(reader->bytes_available_fd);

 if (reader->current_buffer)
    reader->allocator->free(reader->current_buffer);

  fixed_queue_free(reader->buffers, reader->allocator->free);
  thread_free(reader->inbound_read_thread);
  osi_free(reader);
}

static void btif_dm_pin_req_evt(tBTA_DM_PIN_REQ *p_pin_req)
{
 bt_bdaddr_t bd_addr;
 bt_bdname_t bd_name;
    UINT32 cod;
 bt_pin_code_t pin_code;
 int dev_type;

 /* Remote properties update */
 if (!btif_get_device_type(p_pin_req->bd_addr, &dev_type))
 {
        dev_type = BT_DEVICE_TYPE_BREDR;
 }
    btif_update_remote_properties(p_pin_req->bd_addr, p_pin_req->bd_name,
                                  p_pin_req->dev_class, (tBT_DEVICE_TYPE) dev_type);

    bdcpy(bd_addr.address, p_pin_req->bd_addr);
    memcpy(bd_name.name, p_pin_req->bd_name, BD_NAME_LEN);

    bond_state_changed(BT_STATUS_SUCCESS, &bd_addr, BT_BOND_STATE_BONDING);

    cod = devclass2uint(p_pin_req->dev_class);

 if (cod == 0) {
        BTIF_TRACE_DEBUG("%s cod is 0, set as unclassified", __func__);
        cod = COD_UNCLASSIFIED;
 }

 /* check for auto pair possiblity only if bond was initiated by local device */
 if (pairing_cb.is_local_initiated && (p_pin_req->min_16_digit == FALSE))
 {
 if (check_cod(&bd_addr, COD_AV_HEADSETS) ||
            check_cod(&bd_addr, COD_AV_HANDSFREE) ||
            check_cod(&bd_addr, COD_AV_HEADPHONES) ||
            check_cod(&bd_addr, COD_AV_PORTABLE_AUDIO) ||
            check_cod(&bd_addr, COD_AV_HIFI_AUDIO) ||
            check_cod(&bd_addr, COD_HID_POINTING))
 {
            BTIF_TRACE_DEBUG("%s()cod matches for auto pair", __FUNCTION__);
 /*  Check if this device can be auto paired  */
 if ((btif_storage_is_device_autopair_blacklisted(&bd_addr) == FALSE) &&
 (pairing_cb.autopair_attempts == 0))
 {
                BTIF_TRACE_DEBUG("%s() Attempting auto pair", __FUNCTION__);
                pin_code.pin[0] = 0x30;
                pin_code.pin[1] = 0x30;
                pin_code.pin[2] = 0x30;
                pin_code.pin[3] = 0x30;

                pairing_cb.autopair_attempts++;
                BTA_DmPinReply( (UINT8*)bd_addr.address, TRUE, 4, pin_code.pin);
 return;
 }
 }
 else if (check_cod(&bd_addr, COD_HID_KEYBOARD) ||
                 check_cod(&bd_addr, COD_HID_COMBO))
 {
 if(( btif_storage_is_fixed_pin_zeros_keyboard (&bd_addr) == TRUE) &&
 (pairing_cb.autopair_attempts == 0))
 {
                BTIF_TRACE_DEBUG("%s() Attempting auto pair", __FUNCTION__);
                pin_code.pin[0] = 0x30;
                pin_code.pin[1] = 0x30;
                pin_code.pin[2] = 0x30;
                pin_code.pin[3] = 0x30;

                pairing_cb.autopair_attempts++;
                BTA_DmPinReply( (UINT8*)bd_addr.address, TRUE, 4, pin_code.pin);
 return;
 }
 }
 }
    HAL_CBACK(bt_hal_cbacks, pin_request_cb,
 &bd_addr, &bd_name, cod, p_pin_req->min_16_digit);
}

void btsock_rfc_signaled(UNUSED_ATTR int fd, int flags, uint32_t user_id) {
pthread_mutex_lock(&slot_lock);

rfc_slot_t *slot = find_rfc_slot_by_id(user_id);
if (!slot)
goto out;

bool need_close = false;

// Data available from app, tell stack we have outgoing data.
if (flags & SOCK_THREAD_FD_RD && !slot->f.server) {

if (slot->f.connected) {
// Make sure there's data pending in case the peer closed the socket.
int size = 0;
      if (!(flags & SOCK_THREAD_FD_EXCEPTION) || (ioctl(slot->fd, FIONREAD, &size) == 0 && size))
        //unlock before BTA_JvRfcommWrite to avoid deadlock on concurrnet multi rfcomm connectoins
        //concurrnet multi rfcomm connectoins
        pthread_mutex_unlock(&slot_lock);
BTA_JvRfcommWrite(slot->rfc_handle, slot->id);
} else {
LOG_ERROR("%s socket signaled for read while disconnected, slot: %d, channel: %d", __func__, slot->id, slot->scn);
need_close = true;
}
}

if (flags & SOCK_THREAD_FD_WR) {
// App is ready to receive more data, tell stack to enable data flow.
if (!slot->f.connected || !flush_incoming_que_on_wr_signal(slot)) {
LOG_ERROR("%s socket signaled for write while disconnected (or write failure), slot: %d, channel: %d", __func__, slot->id, slot->scn);
need_close = true;
}
}


if (need_close || (flags & SOCK_THREAD_FD_EXCEPTION)) {
// Clean up if there's no data pending.
int size = 0;
    if (need_close || ioctl(slot->fd, FIONREAD, &size) != 0 || !size)
cleanup_rfc_slot(slot);
}

out:;
pthread_mutex_unlock(&slot_lock);
}

btpan_interface_t *btif_pan_get_interface()
{
 return &pan_if;
}

static int skt_disconnect(int fd)
{
    INFO("fd %d", fd);

 if (fd != AUDIO_SKT_DISCONNECTED)
 {
        shutdown(fd, SHUT_RDWR);
        close(fd);
 }
 return 0;
}

static void btif_hl_clean_delete_mdl(btif_hl_delete_mdl_t *p_cb)
{
    BTIF_TRACE_DEBUG("%s", __FUNCTION__ );
    memset(p_cb, 0 , sizeof(btif_hl_delete_mdl_t));
}

static void btif_hl_free_app_idx(UINT8 app_idx){

 if ((app_idx < BTA_HL_NUM_APPS) && btif_hl_cb.acb[app_idx].in_use )
 {
        btif_hl_cb.acb[app_idx].in_use = FALSE;
        memset (&btif_hl_cb.acb[app_idx], 0, sizeof(btif_hl_app_cb_t));
 }
}

int config_get_int(const config_t *config, const char *section, const char *key, int def_value) {
  assert(config != NULL);
  assert(section != NULL);
  assert(key != NULL);

 entry_t *entry = entry_find(config, section, key);
 if (!entry)
 return def_value;

 char *endptr;
 int ret = strtol(entry->value, &endptr, 0);
 return (*endptr == '\0') ? ret : def_value;
}

static void cleanup_rfc_slot(rfc_slot_t *slot) {
 if (slot->fd != INVALID_FD) {
    shutdown(slot->fd, SHUT_RDWR);
    close(slot->fd);
    slot->fd = INVALID_FD;
 }

 if (slot->app_fd != INVALID_FD) {
    close(slot->app_fd);
    slot->app_fd = INVALID_FD;
 }

 if (slot->sdp_handle > 0) {
    del_rfc_sdp_rec(slot->sdp_handle);
    slot->sdp_handle = 0;
 }

 if (slot->rfc_handle && !slot->f.closing && !slot->f.server) {
    BTA_JvRfcommClose(slot->rfc_handle, (void *)(uintptr_t)slot->id);
    slot->rfc_handle = 0;
 }

  free_rfc_slot_scn(slot);
  list_clear(slot->incoming_queue);

  slot->rfc_port_handle = 0;
  memset(&slot->f, 0, sizeof(slot->f));
  slot->id = 0;
  slot->scn_notified = false;
}

void btif_hl_clean_mdls_using_app_idx( UINT8 app_idx){
 btif_hl_app_cb_t *p_acb;
 btif_hl_mcl_cb_t *p_mcb;
 btif_hl_mdl_cb_t *p_dcb;
    UINT8 j,x,y;
 bt_bdaddr_t     bd_addr;

        p_acb =BTIF_HL_GET_APP_CB_PTR(app_idx);
 for (j=0; j < BTA_HL_NUM_MCLS ; j++)
 {
 if (p_acb->mcb[j].in_use)
 {
                    p_mcb = &p_acb->mcb[j];
                    BTIF_TRACE_DEBUG("btif_hl_find_mcl_idx_using_mdl_id: mcl handle found j =%d",j);
 for (x=0; x < BTA_HL_NUM_MDLS_PER_MCL ; x ++)
 {
 if (p_mcb->mdl[x].in_use)
 {
                            p_dcb = BTIF_HL_GET_MDL_CB_PTR(app_idx, j,x);
                            btif_hl_release_socket(app_idx,j,x);
 for (y=0; y<6; y++)
 {
                                bd_addr.address[y] = p_mcb->bd_addr[y];
 }
                            BTIF_HL_CALL_CBACK(bt_hl_callbacks, channel_state_cb,  p_acb->app_id,
 &bd_addr, p_dcb->local_mdep_cfg_idx,
                                               p_dcb->channel_id, BTHL_CONN_STATE_DISCONNECTED, 0 );
                            btif_hl_clean_mdl_cb(p_dcb);
 if (!btif_hl_num_dchs_in_use(p_mcb->mcl_handle))
                                    BTA_HlCchClose(p_mcb->mcl_handle);
                            BTIF_TRACE_DEBUG("remote DCH close success mdl_idx=%d", x);
 }
 }
 }
 }
}

BOOLEAN btif_dm_proc_rmt_oob(BD_ADDR bd_addr,  BT_OCTET16 p_c, BT_OCTET16 p_r)
{
 char t[128];
 FILE *fp;
 char *path_a = "/data/misc/bluedroid/LOCAL/a.key";
 char *path_b = "/data/misc/bluedroid/LOCAL/b.key";
 char *path = NULL;
 char prop_oob[PROPERTY_VALUE_MAX];
    BOOLEAN result = FALSE;
 bt_bdaddr_t bt_bd_addr;
    bdcpy(oob_cb.oob_bdaddr, bd_addr);
    property_get("service.brcm.bt.oob", prop_oob, "3");
    BTIF_TRACE_DEBUG("btif_dm_proc_rmt_oob prop_oob = %s",prop_oob);
 if (prop_oob[0] == '1')
        path = path_b;
 else if (prop_oob[0] == '2')
        path = path_a;
 if (path)
 {
        fp = fopen(path, "rb");
 if (fp == NULL)
 {
            BTIF_TRACE_DEBUG("btapp_dm_rmt_oob_reply: failed to read OOB keys from %s",path);
 return FALSE;
 }
 else
 {
            BTIF_TRACE_DEBUG("btif_dm_proc_rmt_oob: read OOB data from %s",path);
            fread (p_c , 1 , BT_OCTET16_LEN , fp );
            fread (p_r , 1 , BT_OCTET16_LEN , fp );
            fclose(fp);
 }
        BTIF_TRACE_DEBUG("----btif_dm_proc_rmt_oob: TRUE");
        sprintf(t, "%02x:%02x:%02x:%02x:%02x:%02x",
                oob_cb.oob_bdaddr[0], oob_cb.oob_bdaddr[1], oob_cb.oob_bdaddr[2],
                oob_cb.oob_bdaddr[3], oob_cb.oob_bdaddr[4], oob_cb.oob_bdaddr[5]);
        BTIF_TRACE_DEBUG("----btif_dm_proc_rmt_oob: peer_bdaddr = %s", t);
        sprintf(t, "%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x",
                p_c[0], p_c[1], p_c[2],  p_c[3],  p_c[4],  p_c[5],  p_c[6],  p_c[7],
                p_c[8], p_c[9], p_c[10], p_c[11], p_c[12], p_c[13], p_c[14], p_c[15]);
        BTIF_TRACE_DEBUG("----btif_dm_proc_rmt_oob: c = %s",t);
        sprintf(t, "%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x",
                p_r[0], p_r[1], p_r[2],  p_r[3],  p_r[4],  p_r[5],  p_r[6],  p_r[7],
                p_r[8], p_r[9], p_r[10], p_r[11], p_r[12], p_r[13], p_r[14], p_r[15]);
        BTIF_TRACE_DEBUG("----btif_dm_proc_rmt_oob: r = %s",t);
        bdcpy(bt_bd_addr.address, bd_addr);
        btif_transfer_context(btif_dm_generic_evt, BTIF_DM_CB_BOND_STATE_BONDING,
 (char *)&bt_bd_addr, sizeof(bt_bdaddr_t), NULL);
        result = TRUE;
 }
    BTIF_TRACE_DEBUG("btif_dm_proc_rmt_oob result=%d",result);
 return result;
}

static void btif_hl_set_state(btif_hl_state_t state){
    BTIF_TRACE_DEBUG("btif_hl_set_state:  %d ---> %d ", p_btif_hl_cb->state, state);
    p_btif_hl_cb->state = state;
}

bt_status_t btsock_l2cap_cleanup()
{
    pthread_mutex_lock(&state_lock);
    pth = -1;
 while (socks)
        btsock_l2cap_free_l(socks);
    pthread_mutex_unlock(&state_lock);

 return BT_STATUS_SUCCESS;
}

void btif_pan_cleanup()
{
 if (!stack_initialized)
 return;

 for (int i = 0; i < MAX_PAN_CONNS; i++)
        btpan_cleanup_conn(&btpan_cb.conns[i]);

    pan_disable();
    stack_initialized = false;
}

static void btif_rc_upstreams_rsp_evt(UINT16 event, tAVRC_RESPONSE *pavrc_resp, UINT8 ctype, UINT8 label)
{
    BTIF_TRACE_EVENT("%s pdu: %s handle: 0x%x ctype:%x label:%x", __FUNCTION__,
        dump_rc_pdu(pavrc_resp->pdu), btif_rc_cb.rc_handle, ctype, label);

#if (AVRC_ADV_CTRL_INCLUDED == TRUE)
 switch (event)
 {
 case AVRC_PDU_REGISTER_NOTIFICATION:
 {
 if(AVRC_RSP_CHANGED==ctype)
                 btif_rc_cb.rc_volume=pavrc_resp->reg_notif.param.volume;
             HAL_CBACK(bt_rc_callbacks, volume_change_cb, pavrc_resp->reg_notif.param.volume,ctype)
 }
 break;

 case AVRC_PDU_SET_ABSOLUTE_VOLUME:
 {
            BTIF_TRACE_DEBUG("Set absolute volume change event received: volume %d,ctype %d",
                pavrc_resp->volume.volume,ctype);
 if(AVRC_RSP_ACCEPT==ctype)
                btif_rc_cb.rc_volume=pavrc_resp->volume.volume;
            HAL_CBACK(bt_rc_callbacks,volume_change_cb,pavrc_resp->volume.volume,ctype)
 }
 break;

 default:
 return;
 }
#endif
}

void btif_sendmsg(void *p_msg)
{
    thread_post(bt_jni_workqueue_thread, bt_jni_msg_ready, p_msg);
}

void btif_hl_display_bt_bda(bt_bdaddr_t *bd_addr){
    BTIF_TRACE_DEBUG("DB [%02x:%02x:%02x:%02x:%02x:%02x]",
                      bd_addr->address[0],   bd_addr->address[1], bd_addr->address[2],
                      bd_addr->address[3],  bd_addr->address[4],   bd_addr->address[5]);
}

bt_status_t btif_in_execute_service_request(tBTA_SERVICE_ID service_id,
                                                BOOLEAN b_enable)
{
    BTIF_TRACE_DEBUG("%s service_id: %d", __FUNCTION__, service_id);
 /* Check the service_ID and invoke the profile's BT state changed API */
 switch (service_id)
 {
 case BTA_HFP_SERVICE_ID:
 case BTA_HSP_SERVICE_ID:
 {
              btif_hf_execute_service(b_enable);
 }break;
 case BTA_A2DP_SOURCE_SERVICE_ID:
 {
              btif_av_execute_service(b_enable);
 }break;
 case BTA_A2DP_SINK_SERVICE_ID:
 {
            btif_av_sink_execute_service(b_enable);
 }break;
 case BTA_HID_SERVICE_ID:
 {
              btif_hh_execute_service(b_enable);
 }break;
 case BTA_HFP_HS_SERVICE_ID:
 {
             btif_hf_client_execute_service(b_enable);
 }break;
 case BTA_SDP_SERVICE_ID:
 {
             btif_sdp_execute_service(b_enable);
 }break;
 default:
              BTIF_TRACE_ERROR("%s: Unknown service being enabled", __FUNCTION__);
 return BT_STATUS_FAIL;
 }
 return BT_STATUS_SUCCESS;
}

static inline int btif_hl_select_close_connected(void){
char sig_on = btif_hl_signal_select_close_connected;
BTIF_TRACE_DEBUG("btif_hl_select_close_connected");
    return send(signal_fds[1], &sig_on, sizeof(sig_on), 0);
}

void bta_hh_le_co_rpt_info(BD_ADDR remote_bda, tBTA_HH_RPT_CACHE_ENTRY *p_entry, UINT8 app_id)
{
    UNUSED(app_id);

 unsigned idx = 0;

 bdstr_t bdstr;
    sprintf(bdstr, "%02x:%02x:%02x:%02x:%02x:%02x",
        remote_bda[0], remote_bda[1], remote_bda[2],
        remote_bda[3], remote_bda[4], remote_bda[5]);

 size_t len = btif_config_get_bin_length(bdstr, "HidReport");
 if (len >= sizeof(tBTA_HH_RPT_CACHE_ENTRY) && len <= sizeof(sReportCache))
 {
        btif_config_get_bin(bdstr, "HidReport", (uint8_t *)sReportCache, &len);
        idx = len / sizeof(tBTA_HH_RPT_CACHE_ENTRY);
 }

 if (idx < BTA_HH_NV_LOAD_MAX)
 {
        memcpy(&sReportCache[idx++], p_entry, sizeof(tBTA_HH_RPT_CACHE_ENTRY));
        btif_config_set_bin(bdstr, "HidReport", (const uint8_t *)sReportCache,
            idx * sizeof(tBTA_HH_RPT_CACHE_ENTRY));
        BTIF_TRACE_DEBUG("%s() - Saving report; dev=%s, idx=%d", __FUNCTION__, bdstr, idx);
 }
}

static void btif_dm_cb_hid_remote_name(tBTM_REMOTE_DEV_NAME *p_remote_name)
{
    BTIF_TRACE_DEBUG("%s: status=%d pairing_cb.state=%d", __FUNCTION__, p_remote_name->status, pairing_cb.state);
 if (pairing_cb.state == BT_BOND_STATE_BONDING)
 {
 bt_bdaddr_t remote_bd;

        bdcpy(remote_bd.address, pairing_cb.bd_addr);

 if (p_remote_name->status == BTM_SUCCESS)
 {
            bond_state_changed(BT_STATUS_SUCCESS, &remote_bd, BT_BOND_STATE_BONDED);
 }
 else
            bond_state_changed(BT_STATUS_FAIL, &remote_bd, BT_BOND_STATE_NONE);
 }
}

bool semaphore_try_wait(semaphore_t *semaphore) {

assert(semaphore != NULL);
assert(semaphore->fd != INVALID_FD);

  int flags = fcntl(semaphore->fd, F_GETFL);
if (flags == -1) {
LOG_ERROR("%s unable to get flags for semaphore fd: %s", __func__, strerror(errno));
return false;
}
  if (fcntl(semaphore->fd, F_SETFL, flags | O_NONBLOCK) == -1) {
LOG_ERROR("%s unable to set O_NONBLOCK for semaphore fd: %s", __func__, strerror(errno));
return false;
}

eventfd_t value;

if (eventfd_read(semaphore->fd, &value) == -1)
return false;

  if (fcntl(semaphore->fd, F_SETFL, flags) == -1)
LOG_ERROR("%s unable to resetore flags for semaphore fd: %s", __func__, strerror(errno));
return true;
}

static inline void word2hex(const char* data, char** hex)
{
    byte2hex(&data[1], hex);
    byte2hex(&data[0], hex);
}

static int in_set_sample_rate(struct audio_stream *stream, uint32_t rate)
{
 struct a2dp_stream_in *in = (struct a2dp_stream_in *)stream;

    FNLOG();

 if (in->common.cfg.rate > 0 && in->common.cfg.rate == rate)
 return 0;
 else
 return -1;
}

bool config_has_section(const config_t *config, const char *section) {
  assert(config != NULL);
  assert(section != NULL);

 return (section_find(config, section) != NULL);
}

static void on_l2cap_outgoing_congest(tBTA_JV_L2CAP_CONG *p, uint32_t id)
{
    l2cap_socket *sock;

    pthread_mutex_lock(&state_lock);
    sock = btsock_l2cap_find_by_id_l(id);
 if (sock) {
        sock->outgoing_congest = p->cong ? 1 : 0;
 if (!sock->outgoing_congest) {
            APPL_TRACE_DEBUG("on_l2cap_outgoing_congest: adding fd to btsock_thread...");
            btsock_thread_add_fd(pth, sock->our_fd, BTSOCK_L2CAP, SOCK_THREAD_FD_RD, sock->id);

 }
 }
    pthread_mutex_unlock(&state_lock);
}

static void section_free(void *ptr) {
 if (!ptr)
 return;

 section_t *section = ptr;
  osi_free(section->name);
  list_free(section->entries);
  osi_free(section);
}

void btif_dm_save_ble_bonding_keys(void)
{

 bt_bdaddr_t bd_addr;

    BTIF_TRACE_DEBUG("%s",__FUNCTION__ );

    bdcpy(bd_addr.address, pairing_cb.bd_addr);

 if (pairing_cb.ble.is_penc_key_rcvd)
 {
        btif_storage_add_ble_bonding_key(&bd_addr,
 (char *) &pairing_cb.ble.penc_key,
                                         BTIF_DM_LE_KEY_PENC,
 sizeof(tBTM_LE_PENC_KEYS));
 }

 if (pairing_cb.ble.is_pid_key_rcvd)
 {
        btif_storage_add_ble_bonding_key(&bd_addr,
 (char *) &pairing_cb.ble.pid_key,
                                         BTIF_DM_LE_KEY_PID,
 sizeof(tBTM_LE_PID_KEYS));
 }


 if (pairing_cb.ble.is_pcsrk_key_rcvd)
 {
        btif_storage_add_ble_bonding_key(&bd_addr,
 (char *) &pairing_cb.ble.pcsrk_key,
                                         BTIF_DM_LE_KEY_PCSRK,
 sizeof(tBTM_LE_PCSRK_KEYS));
 }


 if (pairing_cb.ble.is_lenc_key_rcvd)
 {
        btif_storage_add_ble_bonding_key(&bd_addr,
 (char *) &pairing_cb.ble.lenc_key,
                                         BTIF_DM_LE_KEY_LENC,
 sizeof(tBTM_LE_LENC_KEYS));
 }

 if (pairing_cb.ble.is_lcsrk_key_rcvd)
 {
        btif_storage_add_ble_bonding_key(&bd_addr,
 (char *) &pairing_cb.ble.lcsrk_key,
                                         BTIF_DM_LE_KEY_LCSRK,
 sizeof(tBTM_LE_LCSRK_KEYS));
 }

 if (pairing_cb.ble.is_lidk_key_rcvd)
 {
        btif_storage_add_ble_bonding_key(&bd_addr,
                                         NULL,
                                         BTIF_DM_LE_KEY_LID,
 0);
 }

}

 virtual void SetUp() {
 AlarmTestHarness::SetUp();
      cb_counter = 0;

      semaphore = semaphore_new(0);
 }

socket_t *socket_accept(const socket_t *socket) {
assert(socket != NULL);

  int fd = accept(socket->fd, NULL, NULL);
if (fd == INVALID_FD) {
LOG_ERROR("%s unable to accept socket: %s", __func__, strerror(errno));
return NULL;
}

socket_t *ret = (socket_t *)osi_calloc(sizeof(socket_t));
if (!ret) {
close(fd);
LOG_ERROR("%s unable to allocate memory for socket.", __func__);
return NULL;
}

ret->fd = fd;
return ret;
}

bt_status_t btif_disable_bluetooth(void)
{
    BTIF_TRACE_DEBUG("BTIF DISABLE BLUETOOTH");

    btif_dm_on_disable();
 /* cleanup rfcomm & l2cap api */
    btif_sock_cleanup();
    btif_pan_cleanup();
    BTA_DisableBluetooth();

 return BT_STATUS_SUCCESS;
}

static void adev_close_output_stream(struct audio_hw_device *dev,
 struct audio_stream_out *stream)
{
 struct a2dp_audio_device *a2dp_dev = (struct a2dp_audio_device *)dev;
 struct a2dp_stream_out *out = (struct a2dp_stream_out *)stream;

    INFO("closing output (state %d)", out->common.state);

    pthread_mutex_lock(&out->common.lock);
 if ((out->common.state == AUDIO_A2DP_STATE_STARTED) || (out->common.state == AUDIO_A2DP_STATE_STOPPING))
        stop_audio_datapath(&out->common);

    skt_disconnect(out->common.ctrl_fd);
    free(stream);
    a2dp_dev->output = NULL;
    pthread_mutex_unlock(&out->common.lock);

    DEBUG("done");
}

BOOLEAN bta_hl_co_advrtise_source_sdp(UINT8 app_id)
{
    BOOLEAN     advertize_source_sdp=FALSE;
    UINT8       app_idx;

 if (btif_hl_find_app_idx(app_id, &app_idx))
 {
        advertize_source_sdp = p_btif_hl_cb->acb[app_idx].sup_feature.advertize_source_sdp;
 }


    BTIF_TRACE_DEBUG("%s advertize_flag=%d", __FUNCTION__, advertize_source_sdp );

 return advertize_source_sdp;
}

BOOLEAN btif_rc_get_connected_peer(BD_ADDR peer_addr)
{
 if (btif_rc_cb.rc_connected == TRUE) {
        bdcpy(peer_addr, btif_rc_cb.rc_addr);
 return TRUE;
 }
 return FALSE;
}

static void on_srv_l2cap_le_connect_l(tBTA_JV_L2CAP_LE_OPEN *p_open, l2cap_socket *sock)
{
    l2cap_socket *accept_rs;
 uint32_t new_listen_id;

    accept_rs = btsock_l2cap_alloc_l(sock->name, (const bt_bdaddr_t*)p_open->rem_bda, FALSE, 0);
 if (accept_rs) {

        new_listen_id = accept_rs->id;
        accept_rs->id = sock->id;
        sock->id = new_listen_id;

        accept_rs->handle = p_open->handle;
        accept_rs->connected = TRUE;
        accept_rs->security = sock->security;
        accept_rs->fixed_chan = sock->fixed_chan;
        accept_rs->channel = sock->channel;

 *(p_open->p_p_cback) = (void*)btsock_l2cap_cbk;
 *(p_open->p_user_data) = (void*)accept_rs->id;

        btsock_thread_add_fd(pth, sock->our_fd, BTSOCK_L2CAP, SOCK_THREAD_FD_EXCEPTION, sock->id);
        btsock_thread_add_fd(pth, accept_rs->our_fd, BTSOCK_L2CAP, SOCK_THREAD_FD_RD,
                accept_rs->id);
        APPL_TRACE_DEBUG("sending connect signal & app fd:%dto app server to accept() the"
 " connection", accept_rs->app_fd);
        APPL_TRACE_DEBUG("server fd:%d, scn:%d", sock->our_fd, sock->channel);
        send_app_connect_signal(sock->our_fd, &accept_rs->addr, sock->channel, 0,
                accept_rs->app_fd, p_open->tx_mtu);
        accept_rs->app_fd = -1; //the fd is closed after sent to app
 }
}

static inline int bta_role_to_btpan(int bta_pan_role)
{
 int btpan_role = 0;
    BTIF_TRACE_DEBUG("bta_pan_role:0x%x", bta_pan_role);
 if (bta_pan_role & PAN_ROLE_NAP_SERVER)
        btpan_role |= BTPAN_ROLE_PANNAP;
 if (bta_pan_role & PAN_ROLE_CLIENT)
        btpan_role |= BTPAN_ROLE_PANU;
 return btpan_role;
}

void btif_hl_copy_bda(bt_bdaddr_t *bd_addr, BD_ADDR  bda){
    UINT8 i;
 for (i=0; i<6; i++)
 {
        bd_addr->address[i] = bda[i] ;
 }
}

static inline void init_cmd_fd(int h)
{
    asrt(ts[h].cmd_fdr == -1 && ts[h].cmd_fdw == -1);
 if(socketpair(AF_UNIX, SOCK_STREAM, 0, &ts[h].cmd_fdr) < 0)
 {
        APPL_TRACE_ERROR("socketpair failed: %s", strerror(errno));
 return;
 }
    APPL_TRACE_DEBUG("h:%d, cmd_fdr:%d, cmd_fdw:%d", h, ts[h].cmd_fdr, ts[h].cmd_fdw);
    add_poll(h, ts[h].cmd_fdr, 0, SOCK_THREAD_FD_RD, 0);
}

void btif_dm_proc_loc_oob(BOOLEAN valid, BT_OCTET16 c, BT_OCTET16 r)
{
 FILE *fp;
 char *path_a = "/data/misc/bluedroid/LOCAL/a.key";
 char *path_b = "/data/misc/bluedroid/LOCAL/b.key";
 char *path = NULL;
 char prop_oob[PROPERTY_VALUE_MAX];
    BTIF_TRACE_DEBUG("btif_dm_proc_loc_oob: valid=%d", valid);
 if (oob_cb.sp_c[0] == 0 && oob_cb.sp_c[1] == 0 &&
        oob_cb.sp_c[2] == 0 && oob_cb.sp_c[3] == 0 &&
        valid)
 {
        BTIF_TRACE_DEBUG("save local OOB data in memory");
        memcpy(oob_cb.sp_c, c, BT_OCTET16_LEN);
        memcpy(oob_cb.sp_r, r, BT_OCTET16_LEN);
        property_get("service.brcm.bt.oob", prop_oob, "3");
        BTIF_TRACE_DEBUG("btif_dm_proc_loc_oob prop_oob = %s",prop_oob);
 if (prop_oob[0] == '1')
            path = path_a;
 else if (prop_oob[0] == '2')
            path = path_b;
 if (path)
 {
            fp = fopen(path, "wb+");
 if (fp == NULL)
 {
                BTIF_TRACE_DEBUG("btif_dm_proc_loc_oob: failed to save local OOB data to %s", path);
 }
 else
 {
                BTIF_TRACE_DEBUG("btif_dm_proc_loc_oob: save local OOB data into file %s",path);
                fwrite (c , 1 , BT_OCTET16_LEN , fp );
                fwrite (r , 1 , BT_OCTET16_LEN , fp );
                fclose(fp);
 }
 }
 }
}

bt_status_t btif_init_bluetooth() {
  bte_main_boot_entry();

 /* As part of the init, fetch the local BD ADDR */
  memset(&btif_local_bd_addr, 0, sizeof(bt_bdaddr_t));
  btif_fetch_local_bdaddr(&btif_local_bd_addr);

  bt_jni_workqueue_thread = thread_new(BT_JNI_WORKQUEUE_NAME);
 if (bt_jni_workqueue_thread == NULL) {
    LOG_ERROR("%s Unable to create thread %s", __func__, BT_JNI_WORKQUEUE_NAME);
 goto error_exit;
 }

  btif_transfer_context(btif_jni_associate, 0, NULL, 0, NULL);

 return BT_STATUS_SUCCESS;

error_exit:;
     thread_free(bt_jni_workqueue_thread);

     bt_jni_workqueue_thread = NULL;

 return BT_STATUS_FAIL;
}

void btif_hl_release_mcl_sockets(UINT8 app_idx, UINT8 mcl_idx){
    UINT8               i;
 btif_hl_mdl_cb_t *p_dcb;
    BOOLEAN             found= FALSE;
    BTIF_TRACE_DEBUG("%s", __FUNCTION__);
 for (i=0; i < BTA_HL_NUM_MDLS_PER_MCL ; i ++)
 {
        p_dcb = BTIF_HL_GET_MDL_CB_PTR(app_idx, mcl_idx, i);
 if (p_dcb && p_dcb->in_use && p_dcb->p_scb)
 {
            BTIF_TRACE_DEBUG("found socket for app_idx=%d mcl_id=%d, mdl_idx=%d", app_idx, mcl_idx, i);
            btif_hl_set_socket_state (p_dcb->p_scb, BTIF_HL_SOC_STATE_W4_REL);
            p_dcb->p_scb = NULL;
            found = TRUE;
 }
 }
 if (found)
        btif_hl_select_close_connected();
}

static bool has_byte(const eager_reader_t *reader) {
assert(reader != NULL);

fd_set read_fds;
FD_ZERO(&read_fds);
FD_SET(reader->bytes_available_fd, &read_fds);

// Immediate timeout
struct timeval timeout;

timeout.tv_sec = 0;
timeout.tv_usec = 0;

  select(reader->bytes_available_fd + 1, &read_fds, NULL, NULL, &timeout);
return FD_ISSET(reader->bytes_available_fd, &read_fds);
}

static bool send_app_scn(rfc_slot_t *slot) {
 if(slot->scn_notified == true) {
 return true;
 }
  slot->scn_notified = true;
 return sock_send_all(slot->fd, (const uint8_t*)&slot->scn, sizeof(slot->scn)) == sizeof(slot->scn);
}

static void btif_dm_ble_rx_test_cback(void *p)
{
    btif_transfer_context(btif_dm_generic_evt, BTIF_DM_CB_LE_RX_TEST,
 (char *)p, 1, NULL);
}

const hci_hal_t *hci_hal_mct_get_test_interface(vendor_t *vendor_interface) {
  vendor = vendor_interface;
 return &interface;
}

void btif_hl_start_cch_timer(UINT8 app_idx, UINT8 mcl_idx)
{
 btif_hl_mcl_cb_t *p_mcb = BTIF_HL_GET_MCL_CB_PTR(app_idx, mcl_idx);
    BTIF_TRACE_DEBUG("%s app_idx=%d, mcl_idx=%d  timer_active=%d timer_in_use=%d",
                      __FUNCTION__,app_idx, mcl_idx,
                      p_mcb->cch_timer_active, p_mcb->cch_timer.in_use);

    p_mcb->cch_timer_active = TRUE;
 if (!p_mcb->cch_timer.in_use)
 {
        BTIF_TRACE_DEBUG("Start CCH timer ");
        memset(&p_mcb->cch_timer, 0, sizeof(TIMER_LIST_ENT));
        p_mcb->cch_timer.param = (UINT32)btif_hl_tmr_hdlr;
        btu_start_timer(&p_mcb->cch_timer, BTU_TTYPE_USER_FUNC,
                        BTIF_TIMEOUT_CCH_NO_DCH_SECS);
 }
 else
 {
        BTIF_TRACE_DEBUG("Restart CCH timer ");
        btu_stop_timer(&p_mcb->cch_timer);
        btu_start_timer(&p_mcb->cch_timer, BTU_TTYPE_USER_FUNC,
                        BTIF_TIMEOUT_CCH_NO_DCH_SECS);
 }

}

static char * in_get_parameters(const struct audio_stream *stream,
 const char *keys)
{
    UNUSED(stream);
    UNUSED(keys);

    FNLOG();
 return strdup("");
}

btpan_conn_t* btpan_new_conn(int handle, const BD_ADDR addr, int local_role, int remote_role)
{
 for (int i = 0; i < MAX_PAN_CONNS; i++)
 {
        BTIF_TRACE_DEBUG("conns[%d]:%d", i, btpan_cb.conns[i].handle);
 if (btpan_cb.conns[i].handle == -1)
 {
            BTIF_TRACE_DEBUG("handle:%d, local_role:%d, remote_role:%d", handle, local_role, remote_role);

            btpan_cb.conns[i].handle = handle;
            bdcpy(btpan_cb.conns[i].peer, addr);
            btpan_cb.conns[i].local_role = local_role;
            btpan_cb.conns[i].remote_role = remote_role;
 return &btpan_cb.conns[i];
 }
 }
    BTIF_TRACE_DEBUG("MAX_PAN_CONNS:%d exceeded, return NULL as failed", MAX_PAN_CONNS);
 return NULL;
}

static bt_status_t set_protocol (bt_bdaddr_t *bd_addr, bthh_protocol_mode_t protocolMode)
{
    CHECK_BTHH_INIT();
 btif_hh_device_t *p_dev;
    UINT8 proto_mode = protocolMode;
    BD_ADDR* bda = (BD_ADDR*) bd_addr;

    BTIF_TRACE_DEBUG("%s:proto_mode = %d", __FUNCTION__,protocolMode);

    BTIF_TRACE_DEBUG("addr = %02X:%02X:%02X:%02X:%02X:%02X",
 (*bda)[0], (*bda)[1], (*bda)[2], (*bda)[3], (*bda)[4], (*bda)[5]);

 if (btif_hh_cb.status == BTIF_HH_DISABLED) {
        BTIF_TRACE_ERROR("%s: Error, HH status = %d", __FUNCTION__, btif_hh_cb.status);
 return BT_STATUS_FAIL;
 }

    p_dev = btif_hh_find_connected_dev_by_bda(bd_addr);
 if (p_dev == NULL) {
        BTIF_TRACE_WARNING(" Error, device %02X:%02X:%02X:%02X:%02X:%02X not opened.",
 (*bda)[0], (*bda)[1], (*bda)[2], (*bda)[3], (*bda)[4], (*bda)[5]);
 return BT_STATUS_FAIL;
 }
 else if (protocolMode != BTA_HH_PROTO_RPT_MODE && protocolMode != BTA_HH_PROTO_BOOT_MODE) {
        BTIF_TRACE_WARNING("s: Error, device proto_mode = %d.", __FUNCTION__, proto_mode);
 return BT_STATUS_FAIL;
 }
 else {
        BTA_HhSetProtoMode(p_dev->dev_handle, protocolMode);
 }


 return BT_STATUS_SUCCESS;
}

static void  cleanup( void ){
    BTIF_TRACE_EVENT("%s", __FUNCTION__);
    btif_hl_display_calling_process_name();
 if (bt_hl_callbacks)
 {
        btif_disable_service(BTA_HDP_SERVICE_ID);
        bt_hl_callbacks = NULL;
        reg_counter = 0;
 }

    btif_hl_disable();
    btif_hl_close_select_thread();
}

btpan_conn_t * btpan_find_conn_handle(UINT16 handle)
{
 for (int i = 0; i < MAX_PAN_CONNS; i++)
 {
 if (btpan_cb.conns[i].handle == handle)
 return &btpan_cb.conns[i];
 }
 return NULL;
}

static int out_remove_audio_effect(const struct audio_stream *stream, effect_handle_t effect)
{
    UNUSED(stream);
    UNUSED(effect);

    FNLOG();
 return 0;
}

static bool stream_corrupted_during_le_scan_workaround(const uint8_t byte_read)
{
 if (!stream_corruption_detected && byte_read == HCI_BLE_EVENT) {
    LOG_ERROR("%s HCI stream corrupted (message type 0x3E)!", __func__);
    stream_corruption_detected = true;
 return true;
 }

 if (stream_corruption_detected) {
 if (stream_corruption_bytes_to_ignore == 0) {
      stream_corruption_bytes_to_ignore = byte_read;
      LOG_ERROR("%s About to skip %d bytes...", __func__, stream_corruption_bytes_to_ignore);
 } else {
 --stream_corruption_bytes_to_ignore;
 }

 if (stream_corruption_bytes_to_ignore == 0) {
      LOG_ERROR("%s Back to our regularly scheduled program...", __func__);
      stream_corruption_detected = false;
 }
 return true;
 }

 return false;
}
