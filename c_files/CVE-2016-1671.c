bool WriteStringPayloads(NtlmBufferWriter* authenticate_writer,
                         bool is_unicode,
                         const base::string16& domain,
                         const base::string16& username,
                         const std::string& hostname) {
  if (is_unicode) {
    return authenticate_writer->WriteUtf16String(domain) &&
           authenticate_writer->WriteUtf16String(username) &&
           authenticate_writer->WriteUtf8AsUtf16String(hostname);
  } else {
    return authenticate_writer->WriteUtf16AsUtf8String(domain) &&
           authenticate_writer->WriteUtf16AsUtf8String(username) &&
           authenticate_writer->WriteUtf8String(hostname);
  }
}

void VirtualAuthenticator::ClearRegistrations(
    ClearRegistrationsCallback callback) {
  state_->registrations.clear();
  std::move(callback).Run();
}

bool ParseChallengeMessageV2(
    base::span<const uint8_t> challenge_message,
    NegotiateFlags* challenge_flags,
    base::span<uint8_t, kChallengeLen> server_challenge,
    std::vector<AvPair>* av_pairs) {
  NtlmBufferReader challenge_reader(challenge_message);

  return challenge_reader.MatchMessageHeader(MessageType::kChallenge) &&
         challenge_reader.SkipSecurityBufferWithValidation() &&
         challenge_reader.ReadFlags(challenge_flags) &&
         challenge_reader.ReadBytes(server_challenge) &&
         challenge_reader.SkipBytes(8) &&
         (((*challenge_flags & NegotiateFlags::kTargetInfo) ==
           NegotiateFlags::kTargetInfo)
              ? challenge_reader.ReadTargetInfoPayload(av_pairs)
              : true);
}

base::Optional<AuthenticatorGetInfoResponse> ReadCTAPGetInfoResponse(
base::span<const uint8_t> buffer) {
if (buffer.size() <= kResponseCodeLength ||
GetResponseCode(buffer) != CtapDeviceResponseCode::kSuccess)
return base::nullopt;

base::Optional<CBOR> decoded_response =
cbor::CBORReader::Read(buffer.subspan(1));

if (!decoded_response || !decoded_response->is_map())
return base::nullopt;

const auto& response_map = decoded_response->GetMap();

auto it = response_map.find(CBOR(1));
if (it == response_map.end() || !it->second.is_array() ||
it->second.GetArray().size() > 2) {
return base::nullopt;
}

base::flat_set<ProtocolVersion> protocol_versions;
for (const auto& version : it->second.GetArray()) {
if (!version.is_string())
return base::nullopt;

auto protocol = ConvertStringToProtocolVersion(version.GetString());
if (protocol == ProtocolVersion::kUnknown) {
VLOG(2) << "Unexpected protocol version received.";
continue;
}

if (!protocol_versions.insert(protocol).second)
return base::nullopt;
}

if (protocol_versions.empty())
return base::nullopt;

it = response_map.find(CBOR(3));
if (it == response_map.end() || !it->second.is_bytestring() ||
it->second.GetBytestring().size() != kAaguidLength) {
return base::nullopt;
}

  AuthenticatorGetInfoResponse response(std::move(protocol_versions),
                                        it->second.GetBytestring());

it = response_map.find(CBOR(2));
if (it != response_map.end()) {
if (!it->second.is_array())
return base::nullopt;

std::vector<std::string> extensions;
for (const auto& extension : it->second.GetArray()) {
if (!extension.is_string())
return base::nullopt;

extensions.push_back(extension.GetString());
}
response.SetExtensions(std::move(extensions));
}

AuthenticatorSupportedOptions options;
it = response_map.find(CBOR(4));
if (it != response_map.end()) {
if (!it->second.is_map())
return base::nullopt;

const auto& option_map = it->second.GetMap();
auto option_map_it = option_map.find(CBOR(kPlatformDeviceMapKey));
if (option_map_it != option_map.end()) {
if (!option_map_it->second.is_bool())
return base::nullopt;

options.SetIsPlatformDevice(option_map_it->second.GetBool());
}

option_map_it = option_map.find(CBOR(kResidentKeyMapKey));
if (option_map_it != option_map.end()) {
if (!option_map_it->second.is_bool())
return base::nullopt;

options.SetSupportsResidentKey(option_map_it->second.GetBool());
}

option_map_it = option_map.find(CBOR(kUserPresenceMapKey));
if (option_map_it != option_map.end()) {
if (!option_map_it->second.is_bool())
return base::nullopt;

options.SetUserPresenceRequired(option_map_it->second.GetBool());
}

option_map_it = option_map.find(CBOR(kUserVerificationMapKey));
if (option_map_it != option_map.end()) {
if (!option_map_it->second.is_bool())
return base::nullopt;

if (option_map_it->second.GetBool()) {
options.SetUserVerificationAvailability(
AuthenticatorSupportedOptions::UserVerificationAvailability::
kSupportedAndConfigured);
} else {
options.SetUserVerificationAvailability(
AuthenticatorSupportedOptions::UserVerificationAvailability::
kSupportedButNotConfigured);
}
}

option_map_it = option_map.find(CBOR(kClientPinMapKey));
if (option_map_it != option_map.end()) {
if (!option_map_it->second.is_bool())
return base::nullopt;

if (option_map_it->second.GetBool()) {
options.SetClientPinAvailability(
AuthenticatorSupportedOptions::ClientPinAvailability::
kSupportedAndPinSet);
} else {
options.SetClientPinAvailability(
AuthenticatorSupportedOptions::ClientPinAvailability::
kSupportedButPinNotSet);
}
}
response.SetOptions(std::move(options));
}

it = response_map.find(CBOR(5));
if (it != response_map.end()) {
if (!it->second.is_unsigned())
return base::nullopt;

response.SetMaxMsgSize(it->second.GetUnsigned());
}

it = response_map.find(CBOR(6));
if (it != response_map.end()) {
if (!it->second.is_array())
return base::nullopt;

std::vector<uint8_t> supported_pin_protocols;
for (const auto& protocol : it->second.GetArray()) {
if (!protocol.is_unsigned())
return base::nullopt;

supported_pin_protocols.push_back(protocol.GetUnsigned());
}
response.SetPinProtocols(std::move(supported_pin_protocols));
}

return base::Optional<AuthenticatorGetInfoResponse>(std::move(response));
}

  std::unique_ptr<MakeCredentialTask> CreateMakeCredentialTask(
      FidoDevice* device) {
    PublicKeyCredentialRpEntity rp(test_data::kRelyingPartyId);
    PublicKeyCredentialUserEntity user(
        fido_parsing_utils::Materialize(test_data::kUserId));
    return std::make_unique<MakeCredentialTask>(
        device,
        CtapMakeCredentialRequest(
            test_data::kClientDataHash, std::move(rp), std::move(user),
            PublicKeyCredentialParams(
                std::vector<PublicKeyCredentialParams::CredentialInfo>(1))),
        callback_receiver_.callback());
  }

void GenerateLMResponseV1WithSessionSecurity(
    base::span<const uint8_t, kChallengeLen> client_challenge,
    base::span<uint8_t, kResponseLenV1> lm_response) {
  memcpy(lm_response.data(), client_challenge.data(), kChallengeLen);
  memset(lm_response.data() + kChallengeLen, 0, kResponseLenV1 - kChallengeLen);
}

NET_EXPORT_PRIVATE std::vector<uint8_t> GenerateUpdatedTargetInfo(
    bool is_mic_enabled,
    bool is_epa_enabled,
    const std::string& channel_bindings,
    const std::string& spn,
    const std::vector<AvPair>& av_pairs,
    uint64_t* server_timestamp) {
  size_t updated_target_info_len = 0;
  std::vector<AvPair> updated_av_pairs(av_pairs);
  UpdateTargetInfoAvPairs(is_mic_enabled, is_epa_enabled, channel_bindings, spn,
                          &updated_av_pairs, server_timestamp,
                          &updated_target_info_len);
  return WriteUpdatedTargetInfo(updated_av_pairs, updated_target_info_len);
}

void GenerateResponsesV1WithSessionSecurity(
    const base::string16& password,
    base::span<const uint8_t, kChallengeLen> server_challenge,
    base::span<const uint8_t, kChallengeLen> client_challenge,
    base::span<uint8_t, kResponseLenV1> lm_response,
    base::span<uint8_t, kResponseLenV1> ntlm_response) {
  GenerateLMResponseV1WithSessionSecurity(client_challenge, lm_response);
  GenerateNtlmResponseV1WithSessionSecurity(password, server_challenge,
                                            client_challenge, ntlm_response);
}

void VirtualAuthenticator::AddBinding(
    blink::test::mojom::VirtualAuthenticatorRequest request) {
  binding_set_.AddBinding(this, std::move(request));
}

void VirtualAuthenticator::GetUserPresence(GetUserPresenceCallback callback) {
  std::move(callback).Run(false);
}

void GenerateResponsesV1(
    const base::string16& password,
    base::span<const uint8_t, kChallengeLen> server_challenge,
    base::span<uint8_t, kResponseLenV1> lm_response,
    base::span<uint8_t, kResponseLenV1> ntlm_response) {
  GenerateNtlmResponseV1(password, server_challenge, ntlm_response);

  memcpy(lm_response.data(), ntlm_response.data(), kResponseLenV1);
}

std::vector<uint8_t> WriteUpdatedTargetInfo(const std::vector<AvPair>& av_pairs,
                                            size_t updated_target_info_len) {
  bool result = true;
  NtlmBufferWriter writer(updated_target_info_len);
  for (const AvPair& pair : av_pairs) {
    result = writer.WriteAvPair(pair);
    DCHECK(result);
  }

  result = writer.WriteAvPairTerminator() && writer.IsEndOfBuffer();
  DCHECK(result);
  return writer.Pass();
}

ReadCTAPMakeCredentialResponse(base::span<const uint8_t> buffer) {
  if (buffer.size() <= kResponseCodeLength)
    return base::nullopt;

  base::Optional<CBOR> decoded_response =
      cbor::CBORReader::Read(buffer.subspan(1));
  if (!decoded_response || !decoded_response->is_map())
    return base::nullopt;

  const auto& decoded_map = decoded_response->GetMap();
  auto it = decoded_map.find(CBOR(1));
  if (it == decoded_map.end() || !it->second.is_string())
    return base::nullopt;
  auto format = it->second.GetString();

  it = decoded_map.find(CBOR(2));
  if (it == decoded_map.end() || !it->second.is_bytestring())
    return base::nullopt;

  auto authenticator_data =
      AuthenticatorData::DecodeAuthenticatorData(it->second.GetBytestring());
  if (!authenticator_data)
    return base::nullopt;

  it = decoded_map.find(CBOR(3));
  if (it == decoded_map.end() || !it->second.is_map())
    return base::nullopt;

  return AuthenticatorMakeCredentialResponse(
      AttestationObject(std::move(*authenticator_data),
                        std::make_unique<OpaqueAttestationStatement>(
                            format, it->second.Clone())));
}

bool WriteResponsePayloads(
    NtlmBufferWriter* authenticate_writer,
    base::span<const uint8_t, kResponseLenV1> lm_response,
    base::span<const uint8_t, kResponseLenV1> ntlm_response) {
  return authenticate_writer->WriteBytes(lm_response) &&
         authenticate_writer->WriteBytes(ntlm_response);
}

std::vector<uint8_t> GetTestCredentialRawIdBytes() {
  return fido_parsing_utils::Materialize(test_data::kU2fSignKeyHandle);
}

void GenerateSessionHashV1WithSessionSecurity(
    base::span<const uint8_t, kChallengeLen> server_challenge,
    base::span<const uint8_t, kChallengeLen> client_challenge,
    base::span<uint8_t, kNtlmHashLen> session_hash) {
  MD5_CTX ctx;
  MD5_Init(&ctx);
  MD5_Update(&ctx, server_challenge.data(), kChallengeLen);
  MD5_Update(&ctx, client_challenge.data(), kChallengeLen);
  MD5_Final(session_hash.data(), &ctx);
}

void VirtualAuthenticator::GetUniqueId(GetUniqueIdCallback callback) {
  std::move(callback).Run(unique_id_);
}

ProtocolVersion ConvertStringToProtocolVersion(base::StringPiece version) {
  if (version == kCtap2Version)
    return ProtocolVersion::kCtap;
  if (version == kU2fVersion)
    return ProtocolVersion::kU2f;

  return ProtocolVersion::kUnknown;
}

void UpdateTargetInfoAvPairs(bool is_mic_enabled,
bool is_epa_enabled,
const std::string& channel_bindings,
const std::string& spn,
std::vector<AvPair>* av_pairs,
uint64_t* server_timestamp,
size_t* target_info_len) {
// Do a pass to update flags and calculate current length and
// pull out the server timestamp if it is there.
*server_timestamp = UINT64_MAX;
*target_info_len = 0;

bool need_flags_added = is_mic_enabled;
for (AvPair& pair : *av_pairs) {
*target_info_len += pair.avlen + kAvPairHeaderLen;
switch (pair.avid) {
case TargetInfoAvId::kFlags:
// The parsing phase already set the payload to the |flags| field.
if (is_mic_enabled) {
pair.flags = pair.flags | TargetInfoAvFlags::kMicPresent;
}

need_flags_added = false;
break;
case TargetInfoAvId::kTimestamp:
// The parsing phase already set the payload to the |timestamp| field.
*server_timestamp = pair.timestamp;
break;
case TargetInfoAvId::kEol:
case TargetInfoAvId::kChannelBindings:
case TargetInfoAvId::kTargetName:
// The terminator, |kEol|, should already have been removed from the
// end of the list and would have been rejected if it has been inside
// the list. Additionally |kChannelBindings| and |kTargetName| pairs
// would have been rejected during the initial parsing. See
// |NtlmBufferReader::ReadTargetInfo|.
NOTREACHED();
break;
default:
// Ignore entries we don't care about.
break;
}
}

if (need_flags_added) {
DCHECK(is_mic_enabled);
AvPair flags_pair(TargetInfoAvId::kFlags, sizeof(uint32_t));
flags_pair.flags = TargetInfoAvFlags::kMicPresent;

av_pairs->push_back(flags_pair);
*target_info_len += kAvPairHeaderLen + flags_pair.avlen;
}

if (is_epa_enabled) {
std::vector<uint8_t> channel_bindings_hash(kChannelBindingsHashLen, 0);

// Hash the channel bindings if they exist otherwise they remain zeros.
if (!channel_bindings.empty()) {
      GenerateChannelBindingHashV2(channel_bindings, channel_bindings_hash);
}

av_pairs->emplace_back(TargetInfoAvId::kChannelBindings,
std::move(channel_bindings_hash));

// Convert the SPN to little endian unicode.
base::string16 spn16 = base::UTF8ToUTF16(spn);
NtlmBufferWriter spn_writer(spn16.length() * 2);
bool spn_writer_result =
spn_writer.WriteUtf16String(spn16) && spn_writer.IsEndOfBuffer();
DCHECK(spn_writer_result);

av_pairs->emplace_back(TargetInfoAvId::kTargetName, spn_writer.Pass());

// Add the length of the two new AV Pairs to the total length.
*target_info_len +=
(2 * kAvPairHeaderLen) + kChannelBindingsHashLen + (spn16.length() * 2);
}

// Add extra space for the terminator at the end.
*target_info_len += kAvPairHeaderLen;
}

  TestMakeCredentialTaskCallback& make_credential_callback_receiver() {
    return callback_receiver_;
  }

void GenerateNtlmResponseV1(
    const base::string16& password,
    base::span<const uint8_t, kChallengeLen> server_challenge,
    base::span<uint8_t, kResponseLenV1> ntlm_response) {
  uint8_t ntlm_hash[kNtlmHashLen];
  GenerateNtlmHashV1(password, ntlm_hash);
  GenerateResponseDesl(ntlm_hash, server_challenge, ntlm_response);
}

std::vector<uint8_t> GetTestCorruptedSignResponse(size_t length) {
  DCHECK_LE(length, arraysize(test_data::kTestU2fSignResponse));
  return fido_parsing_utils::Materialize(fido_parsing_utils::ExtractSpan(
      test_data::kTestU2fSignResponse, 0, length));
}

FidoCableHandshakeHandler::FidoCableHandshakeHandler(
    FidoCableDevice* cable_device,
    base::span<const uint8_t, 8> nonce,
    base::span<const uint8_t, 32> session_pre_key)
    : cable_device_(cable_device),
      nonce_(fido_parsing_utils::Materialize(nonce)),
      session_pre_key_(fido_parsing_utils::Materialize(session_pre_key)),
      handshake_key_(GenerateKey(
          fido_parsing_utils::ConvertToStringPiece(session_pre_key_),
          fido_parsing_utils::ConvertToStringPiece(nonce_),
          kCableHandshakeKeyInfo)),
      weak_factory_(this) {
  crypto::RandBytes(client_session_random_.data(),
                    client_session_random_.size());
}

void Create3DesKeysFromNtlmHash(
    base::span<const uint8_t, kNtlmHashLen> ntlm_hash,
    base::span<uint8_t, 24> keys) {
  Splay56To64(ntlm_hash.data(), keys.data());
  Splay56To64(ntlm_hash.data() + 7, keys.data() + 8);

  keys[16] = ntlm_hash[14];
  keys[17] = ntlm_hash[14] << 7 | ntlm_hash[15] >> 1;
  keys[18] = ntlm_hash[15] << 6;
  memset(keys.data() + 19, 0, 5);
}

size_t GetStringPayloadLength(const std::string& str, bool is_unicode) {
  if (!is_unicode)
    return str.length();

  return base::UTF8ToUTF16(str).length() * 2;
}

void GenerateNtlmResponseV1WithSessionSecurity(
    const base::string16& password,
    base::span<const uint8_t, kChallengeLen> server_challenge,
    base::span<const uint8_t, kChallengeLen> client_challenge,
    base::span<uint8_t, kResponseLenV1> ntlm_response) {
  uint8_t ntlm_hash[kNtlmHashLen];
  GenerateNtlmHashV1(password, ntlm_hash);

  uint8_t session_hash[kNtlmHashLen];
  GenerateSessionHashV1WithSessionSecurity(server_challenge, client_challenge,
                                           session_hash);

  GenerateResponseDesl(
      ntlm_hash, base::make_span(session_hash).subspan<0, kChallengeLen>(),
      ntlm_response);
}

  FidoMakeCredentialTaskTest() { scoped_feature_list_.emplace(); }

bool ParseChallengeMessage(
    base::span<const uint8_t> challenge_message,
    NegotiateFlags* challenge_flags,
    base::span<uint8_t, kChallengeLen> server_challenge) {
  NtlmBufferReader challenge_reader(challenge_message);

  return challenge_reader.MatchMessageHeader(MessageType::kChallenge) &&
         challenge_reader.SkipSecurityBufferWithValidation() &&
         challenge_reader.ReadFlags(challenge_flags) &&
         challenge_reader.ReadBytes(server_challenge);
}

std::unique_ptr<::device::FidoDevice> VirtualAuthenticator::ConstructDevice() {
  return std::make_unique<::device::VirtualU2fDevice>(state_);
}

std::vector<uint8_t> NtlmClient::GenerateAuthenticateMessage(
const base::string16& domain,
const base::string16& username,
const base::string16& password,
const std::string& hostname,
const std::string& channel_bindings,
const std::string& spn,
uint64_t client_time,
base::span<const uint8_t, kChallengeLen> client_challenge,
base::span<const uint8_t> server_challenge_message) const {
// Limit the size of strings that are accepted. As an absolute limit any
// field represented by a |SecurityBuffer| or |AvPair| must be less than
// UINT16_MAX bytes long. The strings are restricted to the maximum sizes
// without regard to encoding. As such this isn't intended to restrict all
// invalid inputs, only to allow all possible valid inputs.
//
// |domain| and |hostname| can be no longer than 255 characters.
// |username| can be no longer than 104 characters. See [1].
// |password| can be no longer than 256 characters. See [2].
//
// [1] - https://technet.microsoft.com/en-us/library/bb726984.aspx
// [2] - https://technet.microsoft.com/en-us/library/cc512606.aspx
if (hostname.length() > kMaxFqdnLen || domain.length() > kMaxFqdnLen ||
username.length() > kMaxUsernameLen ||
password.length() > kMaxPasswordLen) {
return {};
}

NegotiateFlags challenge_flags;
uint8_t server_challenge[kChallengeLen];
uint8_t lm_response[kResponseLenV1];
uint8_t ntlm_response[kResponseLenV1];

// Response fields only for NTLMv2
std::vector<uint8_t> updated_target_info;
std::vector<uint8_t> v2_proof_input;
uint8_t v2_proof[kNtlmProofLenV2];
uint8_t v2_session_key[kSessionKeyLenV2];

if (IsNtlmV2()) {
std::vector<AvPair> av_pairs;
if (!ParseChallengeMessageV2(server_challenge_message, &challenge_flags,
server_challenge, &av_pairs)) {
return {};
}

uint64_t timestamp;
updated_target_info =
GenerateUpdatedTargetInfo(IsMicEnabled(), IsEpaEnabled(),
channel_bindings, spn, av_pairs, &timestamp);

memset(lm_response, 0, kResponseLenV1);
if (timestamp == UINT64_MAX) {
// If the server didn't send a time, then use the clients time.
timestamp = client_time;
}

uint8_t v2_hash[kNtlmHashLen];
GenerateNtlmHashV2(domain, username, password, v2_hash);
v2_proof_input = GenerateProofInputV2(timestamp, client_challenge);
    GenerateNtlmProofV2(v2_hash, server_challenge, v2_proof_input,
updated_target_info, v2_proof);
GenerateSessionBaseKeyV2(v2_hash, v2_proof, v2_session_key);
} else {
if (!ParseChallengeMessage(server_challenge_message, &challenge_flags,
server_challenge)) {
return {};
}

// Calculate the responses for the authenticate message.
GenerateResponsesV1WithSessionSecurity(password, server_challenge,
client_challenge, lm_response,
ntlm_response);
}

// Always use extended session security even if the server tries to downgrade.
NegotiateFlags authenticate_flags = (challenge_flags & negotiate_flags_) |
NegotiateFlags::kExtendedSessionSecurity;

// Calculate all the payload lengths and offsets.
bool is_unicode = (authenticate_flags & NegotiateFlags::kUnicode) ==
NegotiateFlags::kUnicode;

SecurityBuffer lm_info;
SecurityBuffer ntlm_info;
SecurityBuffer domain_info;
SecurityBuffer username_info;
SecurityBuffer hostname_info;
SecurityBuffer session_key_info;
size_t authenticate_message_len;

CalculatePayloadLayout(is_unicode, domain, username, hostname,
updated_target_info.size(), &lm_info, &ntlm_info,
&domain_info, &username_info, &hostname_info,
&session_key_info, &authenticate_message_len);

NtlmBufferWriter authenticate_writer(authenticate_message_len);
bool writer_result = WriteAuthenticateMessage(
&authenticate_writer, lm_info, ntlm_info, domain_info, username_info,
hostname_info, session_key_info, authenticate_flags);
DCHECK(writer_result);

if (IsNtlmV2()) {
// Write the optional (for V1) Version and MIC fields. Note that they
// could also safely be sent in V1. However, the server should never try to
// read them, because neither the version negotiate flag nor the
// |TargetInfoAvFlags::kMicPresent| in the target info are set.
//
// Version is never supported so it is filled with zeros. MIC is a hash
// calculated over all 3 messages while the MIC is set to zeros then
// backfilled at the end if the MIC feature is enabled.
writer_result = authenticate_writer.WriteZeros(kVersionFieldLen) &&
authenticate_writer.WriteZeros(kMicLenV2);

DCHECK(writer_result);
}

// Verify the location in the payload buffer.
DCHECK(authenticate_writer.GetCursor() == GetAuthenticateHeaderLength());
DCHECK(GetAuthenticateHeaderLength() == lm_info.offset);

if (IsNtlmV2()) {
// Write the response payloads for V2.
writer_result =
WriteResponsePayloadsV2(&authenticate_writer, lm_response, v2_proof,
v2_proof_input, updated_target_info);
} else {
// Write the response payloads.
DCHECK_EQ(kResponseLenV1, lm_info.length);
DCHECK_EQ(kResponseLenV1, ntlm_info.length);
writer_result =
WriteResponsePayloads(&authenticate_writer, lm_response, ntlm_response);
}

DCHECK(writer_result);
DCHECK_EQ(authenticate_writer.GetCursor(), domain_info.offset);

writer_result = WriteStringPayloads(&authenticate_writer, is_unicode, domain,
username, hostname);
DCHECK(writer_result);
DCHECK(authenticate_writer.IsEndOfBuffer());
DCHECK_EQ(authenticate_message_len, authenticate_writer.GetLength());

std::vector<uint8_t> auth_msg = authenticate_writer.Pass();

// Backfill the MIC if enabled.
if (IsMicEnabled()) {
// The MIC has to be generated over all 3 completed messages with the MIC
// set to zeros.
DCHECK_LT(kMicOffsetV2 + kMicLenV2, authenticate_message_len);

base::span<uint8_t, kMicLenV2> mic(
const_cast<uint8_t*>(auth_msg.data()) + kMicOffsetV2, kMicLenV2);
GenerateMicV2(v2_session_key, negotiate_message_, server_challenge_message,
auth_msg, mic);
}

return auth_msg;
}

std::string GenerateKey(base::StringPiece secret,
                        base::StringPiece salt,
                        base::StringPiece info) {
  return crypto::HkdfSha256(secret, salt, info, 32);
}

size_t GetStringPayloadLength(const base::string16& str, bool is_unicode) {
  if (is_unicode)
    return str.length() * 2;

  return base::UTF16ToUTF8(str).length();
}

void VirtualAuthenticator::AddRegistration(
blink::test::mojom::RegisteredKeyPtr registration,
AddRegistrationCallback callback) {
if (registration->application_parameter.size() != device::kRpIdHashLength) {
std::move(callback).Run(false);
return;
}

bool success = false;
std::tie(std::ignore, success) = state_->registrations.emplace(
std::move(registration->key_handle),
::device::VirtualFidoDevice::RegistrationData(
crypto::ECPrivateKey::CreateFromPrivateKeyInfo(
registration->private_key),
          registration->application_parameter, registration->counter));
std::move(callback).Run(success);
}

std::vector<uint8_t> GetTestAuthenticatorDataBytes() {
  auto test_authenticator_data =
      fido_parsing_utils::Materialize(kTestAuthenticatorDataPrefix);
  auto test_attested_data = GetTestAttestedCredentialDataBytes();
  fido_parsing_utils::Append(&test_authenticator_data, test_attested_data);
  return test_authenticator_data;
}

std::vector<uint8_t> GetTestAttestationObjectBytes() {
  auto test_authenticator_object =
      fido_parsing_utils::Materialize(kFormatFidoU2fCBOR);
  fido_parsing_utils::Append(&test_authenticator_object, kAttStmtCBOR);
  fido_parsing_utils::Append(&test_authenticator_object,
                             test_data::kU2fAttestationStatementCBOR);
  fido_parsing_utils::Append(&test_authenticator_object, kAuthDataCBOR);
  auto test_authenticator_data = GetTestAuthenticatorDataBytes();
  fido_parsing_utils::Append(&test_authenticator_object,
                             test_authenticator_data);
  return test_authenticator_object;
}

std::vector<uint8_t> GetTestSignResponse() {
  return fido_parsing_utils::Materialize(test_data::kTestU2fSignResponse);
}

void GenerateSessionBaseKeyV2(
    base::span<const uint8_t, kNtlmHashLen> v2_hash,
    base::span<const uint8_t, kNtlmProofLenV2> v2_proof,
    base::span<uint8_t, kSessionKeyLenV2> session_key) {
  unsigned int outlen = kSessionKeyLenV2;
  uint8_t* result =
      HMAC(EVP_md5(), v2_hash.data(), kNtlmHashLen, v2_proof.data(),
           kNtlmProofLenV2, session_key.data(), &outlen);
  DCHECK_EQ(session_key.data(), result);
  DCHECK_EQ(kSessionKeyLenV2, outlen);
}

void NtlmClient::GenerateNegotiateMessage() {
  NtlmBufferWriter writer(kNegotiateMessageLen);
  bool result =
      writer.WriteMessageHeader(MessageType::kNegotiate) &&
      writer.WriteFlags(negotiate_flags_) &&
      writer.WriteSecurityBuffer(SecurityBuffer(kNegotiateMessageLen, 0)) &&
      writer.WriteSecurityBuffer(SecurityBuffer(kNegotiateMessageLen, 0)) &&
      writer.IsEndOfBuffer();

  DCHECK(result);

  negotiate_message_ = writer.Pass();
}

std::string FidoCableHandshakeHandler::GetEncryptionKeyAfterSuccessfulHandshake(
    base::span<const uint8_t, 16> authenticator_random_nonce) const {
  std::vector<uint8_t> nonce_message;
  fido_parsing_utils::Append(&nonce_message, nonce_);
  fido_parsing_utils::Append(&nonce_message, client_session_random_);
  fido_parsing_utils::Append(&nonce_message, authenticator_random_nonce);
  return GenerateKey(
      fido_parsing_utils::ConvertToStringPiece(session_pre_key_),
      fido_parsing_utils::ConvertToStringPiece(
          fido_parsing_utils::CreateSHA256Hash(
              fido_parsing_utils::ConvertToStringPiece(nonce_message))),
      kCableDeviceEncryptionKeyInfo);
}

std::vector<uint8_t> NtlmClient::GetNegotiateMessage() const {
  return negotiate_message_;
}

void FidoCableHandshakeHandler::InitiateCableHandshake(
    FidoDevice::DeviceCallback callback) {
  auto handshake_message =
      ConstructHandshakeMessage(handshake_key_, client_session_random_);
  if (!handshake_message) {
    base::ThreadTaskRunnerHandle::Get()->PostTask(
        FROM_HERE, base::BindOnce(std::move(callback), base::nullopt));
    return;
  }

  cable_device_->SendHandshakeMessage(
      fido_parsing_utils::Materialize(*handshake_message), std::move(callback));
}

void GenerateChannelBindingHashV2(
    const std::string& channel_bindings,
    base::span<uint8_t, kNtlmHashLen> channel_bindings_hash) {
  NtlmBufferWriter writer(kEpaUnhashedStructHeaderLen);
  bool result = writer.WriteZeros(16) &&
                writer.WriteUInt32(channel_bindings.length()) &&
                writer.IsEndOfBuffer();
  DCHECK(result);

  MD5_CTX ctx;
  MD5_Init(&ctx);
  MD5_Update(&ctx, writer.GetBuffer().data(), writer.GetBuffer().size());
  MD5_Update(&ctx, channel_bindings.data(), channel_bindings.size());
  MD5_Final(channel_bindings_hash.data(), &ctx);
}

size_t NtlmClient::GetAuthenticateHeaderLength() const {
  if (IsNtlmV2()) {
    return kAuthenticateHeaderLenV2;
  }

  return kAuthenticateHeaderLenV1;
}

  void RemoveCtapFlag() {
    scoped_feature_list_.emplace();
    scoped_feature_list_->InitAndDisableFeature(kNewCtap2Device);
  }

void VirtualAuthenticator::SetUserPresence(bool present,
                                           SetUserPresenceCallback callback) {
  std::move(callback).Run();
}

std::vector<uint8_t> GenerateProofInputV2(
    uint64_t timestamp,
    base::span<const uint8_t, kChallengeLen> client_challenge) {
  NtlmBufferWriter writer(kProofInputLenV2);
  bool result = writer.WriteUInt16(kProofInputVersionV2) &&
                writer.WriteZeros(6) && writer.WriteUInt64(timestamp) &&
                writer.WriteBytes(client_challenge) && writer.WriteZeros(4) &&
                writer.IsEndOfBuffer();

  DCHECK(result);
  return writer.Pass();
}

NtlmClient::NtlmClient(NtlmFeatures features)
    : features_(features), negotiate_flags_(kNegotiateMessageFlags) {
  GenerateNegotiateMessage();
}

void GenerateNtlmHashV1(const base::string16& password,
                        base::span<uint8_t, kNtlmHashLen> hash) {
  size_t length = password.length() * 2;
  NtlmBufferWriter writer(length);

  bool result = writer.WriteUtf16String(password) && writer.IsEndOfBuffer();
  DCHECK(result);

  MD4(writer.GetBuffer().data(), writer.GetLength(), hash.data());
}

CtapDeviceResponseCode GetResponseCode(base::span<const uint8_t> buffer) {
  if (buffer.empty())
    return CtapDeviceResponseCode::kCtap2ErrInvalidCBOR;

  auto code = static_cast<CtapDeviceResponseCode>(buffer[0]);
  return base::ContainsValue(GetCtapResponseCodeList(), code)
             ? code
             : CtapDeviceResponseCode::kCtap2ErrInvalidCBOR;
}
