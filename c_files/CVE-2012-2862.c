string16 TaskManagerView::GetWindowTitle() const {
  return l10n_util::GetStringUTF16(IDS_TASK_MANAGER_TITLE);
}

int TaskManagerTableModel::CompareValues(int row1, int row2, int column_id) {
  return model_->CompareValues(row1, row2, column_id);
}

void TaskManagerView::OnKeyDown(ui::KeyboardCode keycode) {
  if (keycode == ui::VKEY_RETURN)
    ActivateFocusedTab();
}

bool TaskManagerView::IsItemChecked(int id) const {
  return tab_table_->IsColumnVisible(id);
}

AcceleratorController* AcceleratorControllerTest::GetController() {
  return Shell::GetInstance()->accelerator_controller();
 }

  virtual ~TestTarget() {
  }

  explicit DummyImeControlDelegate(bool consume)
      : consume_(consume),
        handle_next_ime_count_(0),
        handle_previous_ime_count_(0),
        handle_switch_ime_count_(0) {
  }

void ShowTaskManager() {
  TaskManagerView::Show(false);
}

  virtual ~DummyBrightnessControlDelegate() {}

  int handle_next_ime_count() const {
    return handle_next_ime_count_;
  }

  virtual ~TestTarget() {};

void TaskManagerView::ActivateFocusedTab() {
  int row_count = tab_table_->RowCount();
  for (int i = 0; i < row_count; ++i) {
    if (tab_table_->ItemHasTheFocus(i)) {
      task_manager_->ActivateProcess(i);
      break;
    }
  }
}

  int handle_switch_ime_count() const {
    return handle_switch_ime_count_;
  }

  int handle_volume_down_count() const {
    return handle_volume_down_count_;
  }

  void NotifyRefreshDrive(ash::DriveOperationStatusList& list) {
    ash::DriveObserver* observer = tray_->drive_observer();
    if (observer)
      observer->OnDriveRefresh(list);
  }

ReleaseAccelerator(ui::KeyboardCode keycode,
                     bool shift_pressed,
                     bool ctrl_pressed,
                     bool alt_pressed)
      : ui::Accelerator(keycode, shift_pressed, ctrl_pressed, alt_pressed) {
set_type(ui::ET_KEY_RELEASED);
}

void TaskManagerTableModel::OnItemsChanged(int start, int length) {
  if (observer_)
    observer_->OnItemsChanged(start, length);
}

bool TestTarget::CanHandleAccelerators() const {
  return true;
}

  int handle_previous_ime_count() const {
    return handle_previous_ime_count_;
  }

  virtual ~DummyScreenshotDelegate() {}

void TaskManagerView::OnSelectionChanged() {
  bool selection_contains_browser_process = false;
  for (views::TableSelectionIterator iter  = tab_table_->SelectionBegin();
       iter != tab_table_->SelectionEnd(); ++iter) {
    if (task_manager_->IsBrowserProcess(*iter)) {
      selection_contains_browser_process = true;
      break;
    }
  }
  kill_button_->SetEnabled(!selection_contains_browser_process &&
                           tab_table_->SelectedRowCount() > 0);
}

void TaskManagerView::ViewHierarchyChanged(bool is_add,
                                           views::View* parent,
                                           views::View* child) {
  if (child == this) {
    if (is_add) {
      parent->AddChildView(about_memory_link_);
      if (purge_memory_button_)
        parent->AddChildView(purge_memory_button_);
      parent->AddChildView(kill_button_);
      AddChildView(tab_table_);
    } else {
      parent->RemoveChildView(kill_button_);
      if (purge_memory_button_)
        parent->RemoveChildView(purge_memory_button_);
      parent->RemoveChildView(about_memory_link_);
    }
  }
}

ash::NetworkIconInfo CreateNetworkIconInfo(const Network* network,
                                           NetworkMenuIcon* network_icon,
                                           NetworkMenu* network_menu) {
  ash::NetworkIconInfo info;
  info.name = UTF8ToUTF16(network->name());
  info.image = network_icon->GetBitmap(network, NetworkMenuIcon::COLOR_DARK);
  info.service_path = network->service_path();
  info.highlight = network_menu->ShouldHighlightNetwork(network);
  info.tray_icon_visible = ShouldShowNetworkIconInTray(network);
  return info;
}

  explicit SystemTrayDelegate(ash::SystemTray* tray)
      : tray_(tray),
        ui_weak_ptr_factory_(ALLOW_THIS_IN_INITIALIZER_LIST(
            new base::WeakPtrFactory<SystemTrayDelegate>(this))),
        network_icon_(ALLOW_THIS_IN_INITIALIZER_LIST(
                      new NetworkMenuIcon(this, NetworkMenuIcon::MENU_MODE))),
        network_icon_dark_(ALLOW_THIS_IN_INITIALIZER_LIST(
                      new NetworkMenuIcon(this, NetworkMenuIcon::MENU_MODE))),
        network_menu_(ALLOW_THIS_IN_INITIALIZER_LIST(new NetworkMenu(this))),
        clock_type_(base::k24HourClock),
        search_key_mapped_to_(input_method::kSearchKey),
        screen_locked_(false),
        state_(STATE_UNKNOWN),
        connected_network_(NULL),
        data_promo_notification_(new DataPromoNotification()) {
    AudioHandler::GetInstance()->AddVolumeObserver(this);
    DBusThreadManager::Get()->GetPowerManagerClient()->AddObserver(this);
    DBusThreadManager::Get()->GetPowerManagerClient()->RequestStatusUpdate(
        PowerManagerClient::UPDATE_INITIAL);

    NetworkLibrary* crosnet = CrosLibrary::Get()->GetNetworkLibrary();
    crosnet->AddNetworkManagerObserver(this);
    OnNetworkManagerChanged(crosnet);
    crosnet->AddCellularDataPlanObserver(this);

    input_method::InputMethodManager::GetInstance()->AddObserver(this);

    system::TimezoneSettings::GetInstance()->AddObserver(this);

    if (SystemKeyEventListener::GetInstance())
      SystemKeyEventListener::GetInstance()->AddCapsLockObserver(this);

    registrar_.Add(this,
                   chrome::NOTIFICATION_UPGRADE_RECOMMENDED,
                   content::NotificationService::AllSources());
    registrar_.Add(this,
                   chrome::NOTIFICATION_LOGIN_USER_IMAGE_CHANGED,
                   content::NotificationService::AllSources());
    if (GetUserLoginStatus() == ash::user::LOGGED_IN_NONE) {
      registrar_.Add(this,
                     chrome::NOTIFICATION_SESSION_STARTED,
                     content::NotificationService::AllSources());
    }
    registrar_.Add(this,
                   chrome::NOTIFICATION_PROFILE_CREATED,
                   content::NotificationService::AllSources());

    accessibility_enabled_.Init(prefs::kSpokenFeedbackEnabled,
                                g_browser_process->local_state(), this);

    network_icon_->SetResourceColorTheme(NetworkMenuIcon::COLOR_LIGHT);
    network_icon_dark_->SetResourceColorTheme(NetworkMenuIcon::COLOR_DARK);

    bluetooth_adapter_.reset(BluetoothAdapter::CreateDefaultAdapter());
    bluetooth_adapter_->AddObserver(this);
  }

string16 TaskManagerTableModel::GetText(int row, int col_id) {
  switch (col_id) {
    case IDS_TASK_MANAGER_TASK_COLUMN:  // Process
      return model_->GetResourceTitle(row);

    case IDS_TASK_MANAGER_PROFILE_NAME_COLUMN:  // Profile Name
      return model_->GetResourceProfileName(row);

    case IDS_TASK_MANAGER_NET_COLUMN:  // Net
      return model_->GetResourceNetworkUsage(row);

    case IDS_TASK_MANAGER_CPU_COLUMN:  // CPU
      if (!model_->IsResourceFirstInGroup(row))
        return string16();
      return model_->GetResourceCPUUsage(row);

    case IDS_TASK_MANAGER_PRIVATE_MEM_COLUMN:  // Memory
      if (!model_->IsResourceFirstInGroup(row))
        return string16();
      return model_->GetResourcePrivateMemory(row);

    case IDS_TASK_MANAGER_SHARED_MEM_COLUMN:  // Memory
      if (!model_->IsResourceFirstInGroup(row))
        return string16();
      return model_->GetResourceSharedMemory(row);

    case IDS_TASK_MANAGER_PHYSICAL_MEM_COLUMN:  // Memory
      if (!model_->IsResourceFirstInGroup(row))
        return string16();
      return model_->GetResourcePhysicalMemory(row);

    case IDS_TASK_MANAGER_PROCESS_ID_COLUMN:
      if (!model_->IsResourceFirstInGroup(row))
        return string16();
      return model_->GetResourceProcessId(row);

    case IDS_TASK_MANAGER_GOATS_TELEPORTED_COLUMN:  // Goats Teleported!
      return model_->GetResourceGoatsTeleported(row);

    case IDS_TASK_MANAGER_WEBCORE_IMAGE_CACHE_COLUMN:
      if (!model_->IsResourceFirstInGroup(row))
        return string16();
      return model_->GetResourceWebCoreImageCacheSize(row);

    case IDS_TASK_MANAGER_WEBCORE_SCRIPTS_CACHE_COLUMN:
      if (!model_->IsResourceFirstInGroup(row))
        return string16();
      return model_->GetResourceWebCoreScriptsCacheSize(row);

    case IDS_TASK_MANAGER_WEBCORE_CSS_CACHE_COLUMN:
      if (!model_->IsResourceFirstInGroup(row))
        return string16();
      return model_->GetResourceWebCoreCSSCacheSize(row);

    case IDS_TASK_MANAGER_FPS_COLUMN:
      return model_->GetResourceFPS(row);

    case IDS_TASK_MANAGER_SQLITE_MEMORY_USED_COLUMN:
      if (!model_->IsResourceFirstInGroup(row))
        return string16();
      return model_->GetResourceSqliteMemoryUsed(row);

    case IDS_TASK_MANAGER_JAVASCRIPT_MEMORY_ALLOCATED_COLUMN:
      if (!model_->IsResourceFirstInGroup(row))
        return string16();
      return model_->GetResourceV8MemoryAllocatedSize(row);

    default:
      NOTREACHED();
      return string16();
  }
}

  virtual ~AcceleratorManagerTest() {}

  AcceleratorManagerTest() {}

  virtual ~BackgroundColorGroupTableView() {}

void TaskManagerView::ButtonPressed(
    views::Button* sender, const views::Event& event) {
  if (purge_memory_button_ && (sender == purge_memory_button_)) {
    MemoryPurger::PurgeAll();
  } else {
    DCHECK_EQ(kill_button_, sender);
    for (views::TableSelectionIterator iter  = tab_table_->SelectionBegin();
         iter != tab_table_->SelectionEnd(); ++iter)
      task_manager_->KillProcess(*iter);
  }
}

  AcceleratorControllerTest() {};

  DummyScreenshotDelegate()
      : handle_take_screenshot_count_(0),
        handle_take_partial_screenshot_count_(0) {
  }

void TaskManagerView::AddAlwaysOnTopSystemMenuItem() {
#if defined(OS_WIN) && !defined(USE_AURA)
  always_on_top_menu_text_ = l10n_util::GetStringUTF16(IDS_ALWAYS_ON_TOP);

  HMENU system_menu = ::GetSystemMenu(GetWidget()->GetNativeWindow(), FALSE);
  int index = ::GetMenuItemCount(system_menu) - 1;
  if (index < 0) {
    NOTREACHED();
    index = 0;
  }
  MENUITEMINFO menu_info;
  memset(&menu_info, 0, sizeof(MENUITEMINFO));
  menu_info.cbSize = sizeof(MENUITEMINFO);
  menu_info.fMask = MIIM_FTYPE;
  menu_info.fType = MFT_SEPARATOR;
  ::InsertMenuItem(system_menu, index, TRUE, &menu_info);

  menu_info.fMask = MIIM_FTYPE | MIIM_ID | MIIM_STRING | MIIM_STATE;
  menu_info.fType = MFT_STRING;
  menu_info.fState = MFS_ENABLED;
  if (is_always_on_top_)
    menu_info.fState |= MFS_CHECKED;
  menu_info.wID = IDC_ALWAYS_ON_TOP;
  menu_info.dwTypeData = const_cast<wchar_t*>(always_on_top_menu_text_.c_str());
  ::InsertMenuItem(system_menu, index, TRUE, &menu_info);
#endif
}

bool TaskManagerView::GetSavedAlwaysOnTopState(bool* always_on_top) const {
  if (!g_browser_process->local_state())
    return false;

  const DictionaryValue* dictionary =
      g_browser_process->local_state()->GetDictionary(GetWindowName().c_str());
  return dictionary &&
      dictionary->GetBoolean("always_on_top", always_on_top) && always_on_top;
}

  int handle_volume_up_count() const {
    return handle_volume_up_count_;
  }

  virtual ~TestTarget() {}

  virtual ~SystemTrayDelegate() {
    AudioHandler* audiohandler = AudioHandler::GetInstance();
    if (audiohandler)
      audiohandler->RemoveVolumeObserver(this);
    DBusThreadManager::Get()->GetPowerManagerClient()->RemoveObserver(this);
    NetworkLibrary* crosnet = CrosLibrary::Get()->GetNetworkLibrary();
    if (crosnet) {
      crosnet->RemoveNetworkManagerObserver(this);
      crosnet->RemoveCellularDataPlanObserver(this);
    }
    input_method::InputMethodManager::GetInstance()->RemoveObserver(this);
    system::TimezoneSettings::GetInstance()->RemoveObserver(this);
    if (SystemKeyEventListener::GetInstance())
      SystemKeyEventListener::GetInstance()->RemoveCapsLockObserver(this);
    bluetooth_adapter_->RemoveObserver(this);
  }

ash::SystemTrayDelegate* CreateSystemTrayDelegate(ash::SystemTray* tray) {
  return new chromeos::SystemTrayDelegate(tray);
}

  void set_accelerator_pressed_count(int accelerator_pressed_count) {
    accelerator_pressed_count_ = accelerator_pressed_count;
  }

  ~TaskManagerTableModel() {
    model_->RemoveObserver(this);
  }

bool TaskManagerTableModel::IsBackgroundResource(int row) {
  return model_->IsBackgroundResource(row);
}

  void UpdateClockType(PrefService* service) {
    clock_type_ = service->GetBoolean(prefs::kUse24HourClock) ?
        base::k24HourClock : base::k12HourClock;
    ash::ClockObserver* observer = tray_->clock_observer();
    if (observer)
      observer->OnDateFormatChanged();
  }

  int handle_volume_mute_count() const {
    return handle_volume_mute_count_;
  }

gfx::Size TaskManagerView::GetPreferredSize() {
  return gfx::Size(kDefaultWidth, kDefaultHeight);
}

  explicit DummyBrightnessControlDelegate(bool consume)
      : consume_(consume),
        handle_brightness_down_count_(0),
        handle_brightness_up_count_(0) {
  }

void TaskManagerView::UpdateStatsCounters() {
  base::StatsTable* stats = base::StatsTable::current();
  if (stats != NULL) {
    int max = stats->GetMaxCounters();
    for (int i = 1; i < max; i++) {
      const char* row = stats->GetRowName(i);
      if (row != NULL && row[0] != '\0' && !tab_table_->HasColumn(i)) {
        ui::TableColumn col(i, ASCIIToUTF16(row), ui::TableColumn::RIGHT, 90,
                            0);
        col.sortable = true;
        columns_.push_back(col);
        tab_table_->AddColumn(col);
      }
    }
  }
}

void TaskManagerView::InitAlwaysOnTopState() {
  is_always_on_top_ = false;
  if (GetSavedAlwaysOnTopState(&is_always_on_top_))
    GetWidget()->SetAlwaysOnTop(is_always_on_top_);
  AddAlwaysOnTopSystemMenuItem();
}

  Browser* GetAppropriateBrowser() {
    return browser::FindOrCreateTabbedBrowser(
        ProfileManager::GetDefaultProfileOrOffTheRecord());
  }

bool TaskManagerView::CanMaximize() const {
  return true;
}

void BluetoothDiscoveryFailure() {
}

  BackgroundColorGroupTableView(TaskManagerTableModel* model,
                                const std::vector<ui::TableColumn>& columns,
                                bool highlight_background_resources)
      : views::GroupTableView(model, columns, views::ICON_AND_TEXT,
                              false, true, true, true),
        model_(model) {
    SetCustomColorsEnabled(highlight_background_resources);
  }

void TaskManagerView::OnDoubleClick() {
  ActivateFocusedTab();
}

void TaskManagerTableModel::OnItemsRemoved(int start, int length) {
  if (observer_)
    observer_->OnItemsRemoved(start, length);

  OnModelChanged();
}

  int accelerator_pressed_count() const {
    return accelerator_pressed_count_;
  }

  TestTarget() : accelerator_pressed_count_(0) {};

bool TaskManagerView::CanResize() const {
  return true;
}

  void SetProfile(Profile* profile) {
    pref_registrar_.reset(new PrefChangeRegistrar);
    pref_registrar_->Init(profile->GetPrefs());
    pref_registrar_->Add(prefs::kUse24HourClock, this);
    pref_registrar_->Add(prefs::kLanguageXkbRemapSearchKeyTo, this);
    UpdateClockType(profile->GetPrefs());
    search_key_mapped_to_ =
        profile->GetPrefs()->GetInteger(prefs::kLanguageXkbRemapSearchKeyTo);

    if (gdata::util::IsGDataAvailable(profile)) {
      GDataSystemService* system_service =
          GDataSystemServiceFactory::FindForProfile(profile);
      if (!system_service || !system_service->file_system())
        return;

      system_service->file_system()->GetOperationRegistry()->
          AddObserver(this);
    }
  }

  MockDispatcher() : num_key_events_dispatched_(0) {
  }

  virtual bool GetCellColors(int model_row,
                             int column,
                             ItemColor* foreground,
                             ItemColor* background,
                             LOGFONT* logfont) {
    if (!model_->IsBackgroundResource(model_row))
      return false;

    background->color_is_set = true;
    background->color = kBackgroundResourceHighlight;
    foreground->color_is_set = false;
    return true;
  }

  virtual ~DummyImeControlDelegate() {}

void TaskManagerView::Init() {
table_model_.reset(new TaskManagerTableModel(model_));

// Page column has no header label.
columns_.push_back(ui::TableColumn(IDS_TASK_MANAGER_TASK_COLUMN,
ui::TableColumn::LEFT, -1, 1));
columns_.back().sortable = true;
columns_.push_back(ui::TableColumn(IDS_TASK_MANAGER_PROFILE_NAME_COLUMN,
ui::TableColumn::LEFT, -1, 0));
columns_.back().sortable = true;
columns_.push_back(ui::TableColumn(IDS_TASK_MANAGER_PHYSICAL_MEM_COLUMN,
ui::TableColumn::RIGHT, -1, 0));
columns_.back().sortable = true;
columns_.push_back(ui::TableColumn(IDS_TASK_MANAGER_SHARED_MEM_COLUMN,
ui::TableColumn::RIGHT, -1, 0));
columns_.back().sortable = true;
columns_.push_back(ui::TableColumn(IDS_TASK_MANAGER_PRIVATE_MEM_COLUMN,
ui::TableColumn::RIGHT, -1, 0));
columns_.back().sortable = true;
columns_.push_back(ui::TableColumn(IDS_TASK_MANAGER_CPU_COLUMN,
ui::TableColumn::RIGHT, -1, 0));
columns_.back().sortable = true;
columns_.push_back(ui::TableColumn(IDS_TASK_MANAGER_NET_COLUMN,
ui::TableColumn::RIGHT, -1, 0));
columns_.back().sortable = true;
columns_.push_back(ui::TableColumn(IDS_TASK_MANAGER_PROCESS_ID_COLUMN,
ui::TableColumn::RIGHT, -1, 0));
columns_.back().sortable = true;
columns_.push_back(ui::TableColumn(
IDS_TASK_MANAGER_WEBCORE_IMAGE_CACHE_COLUMN,
ui::TableColumn::RIGHT, -1, 0));
columns_.back().sortable = true;
columns_.push_back(ui::TableColumn(
IDS_TASK_MANAGER_WEBCORE_SCRIPTS_CACHE_COLUMN,
ui::TableColumn::RIGHT, -1, 0));
columns_.back().sortable = true;
columns_.push_back(ui::TableColumn(IDS_TASK_MANAGER_WEBCORE_CSS_CACHE_COLUMN,
ui::TableColumn::RIGHT, -1, 0));
columns_.back().sortable = true;
columns_.push_back(ui::TableColumn(IDS_TASK_MANAGER_FPS_COLUMN,
ui::TableColumn::RIGHT, -1, 0));
columns_.back().sortable = true;
columns_.push_back(ui::TableColumn(IDS_TASK_MANAGER_SQLITE_MEMORY_USED_COLUMN,
ui::TableColumn::RIGHT, -1, 0));
columns_.back().sortable = true;
columns_.push_back(
ui::TableColumn(IDS_TASK_MANAGER_JAVASCRIPT_MEMORY_ALLOCATED_COLUMN,
ui::TableColumn::RIGHT, -1, 0));
columns_.back().sortable = true;

tab_table_ = new BackgroundColorGroupTableView(
table_model_.get(), columns_, highlight_background_resources_);

// Hide some columns by default
tab_table_->SetColumnVisibility(IDS_TASK_MANAGER_PROFILE_NAME_COLUMN, false);
tab_table_->SetColumnVisibility(IDS_TASK_MANAGER_PROCESS_ID_COLUMN, false);
tab_table_->SetColumnVisibility(IDS_TASK_MANAGER_SHARED_MEM_COLUMN, false);
tab_table_->SetColumnVisibility(IDS_TASK_MANAGER_PRIVATE_MEM_COLUMN, false);
tab_table_->SetColumnVisibility(IDS_TASK_MANAGER_WEBCORE_IMAGE_CACHE_COLUMN,
false);
tab_table_->SetColumnVisibility(IDS_TASK_MANAGER_WEBCORE_SCRIPTS_CACHE_COLUMN,
false);
tab_table_->SetColumnVisibility(IDS_TASK_MANAGER_WEBCORE_CSS_CACHE_COLUMN,
false);
tab_table_->SetColumnVisibility(IDS_TASK_MANAGER_SQLITE_MEMORY_USED_COLUMN,
false);
tab_table_->SetColumnVisibility(
IDS_TASK_MANAGER_JAVASCRIPT_MEMORY_ALLOCATED_COLUMN, false);
tab_table_->SetColumnVisibility(IDS_TASK_MANAGER_GOATS_TELEPORTED_COLUMN,
false);

UpdateStatsCounters();
tab_table_->SetObserver(this);
tab_table_->set_context_menu_controller(this);
set_context_menu_controller(this);
// If we're running with --purge-memory-button, add a "Purge memory" button.
if (CommandLine::ForCurrentProcess()->HasSwitch(
switches::kPurgeMemoryButton)) {
purge_memory_button_ = new views::NativeTextButton(this,
l10n_util::GetStringUTF16(IDS_TASK_MANAGER_PURGE_MEMORY));
}
kill_button_ = new views::NativeTextButton(
this, l10n_util::GetStringUTF16(IDS_TASK_MANAGER_KILL));
  kill_button_->AddAccelerator(ui::Accelerator(ui::VKEY_E, false, false,
                                               false));
kill_button_->SetAccessibleKeyboardShortcut(L"E");
kill_button_->set_prefix_type(views::TextButtonBase::PREFIX_SHOW);
about_memory_link_ = new views::Link(
l10n_util::GetStringUTF16(IDS_TASK_MANAGER_ABOUT_MEMORY_LINK));
about_memory_link_->set_listener(this);

// Makes sure our state is consistent.
OnSelectionChanged();
}

void TaskManagerView::Show(bool highlight_background_resources) {
  if (instance_) {
    if (instance_->highlight_background_resources_ !=
        highlight_background_resources) {
      instance_->GetWidget()->Close();
    } else {
      instance_->GetWidget()->Activate();
      return;
    }
  }
  instance_ = new TaskManagerView(highlight_background_resources);
  views::Widget::CreateWindow(instance_);
  instance_->InitAlwaysOnTopState();
  instance_->model_->StartUpdating();
  instance_->GetWidget()->Show();

  views::FocusManager* focus_manager = instance_->GetFocusManager();
  if (focus_manager)
    focus_manager->SetFocusedView(instance_->tab_table_);
}

void ShowBackgroundPages() {
  TaskManagerView::Show(true);
}

bool TestTarget::CanHandleAccelerators() const {
  return true;
 }

void TaskManagerTableModel::OnItemsAdded(int start, int length) {
  if (observer_)
    observer_->OnItemsAdded(start, length);

}

bool TestTarget::AcceleratorPressed(const Accelerator& accelerator) {
  ++accelerator_pressed_count_;
  return true;
}

  explicit TaskManagerTableModel(TaskManagerModel* model)
      : model_(model),
        observer_(NULL) {
    model_->AddObserver(this);
  }

void ExtractIMEInfo(const input_method::InputMethodDescriptor& ime,
                    const input_method::InputMethodUtil& util,
                    ash::IMEInfo* info) {
  info->id = ime.id();
  info->name = util.GetInputMethodLongName(ime);
  info->short_name = util.GetInputMethodShortName(ime);
}

  void NotifyRefreshIME() {
    ash::IMEObserver* observer = tray_->ime_observer();
    if (observer)
      observer->OnIMERefresh();
  }

  int handle_take_screenshot_count() const {
    return handle_take_screenshot_count_;
  }

void DispatchKeyReleaseA() {
#if defined(OS_WIN)
  MSG native_event_down = { NULL, WM_KEYDOWN, ui::VKEY_A, 0 };
  ash::Shell::GetRootWindow()->PostNativeEvent(native_event_down);
  MSG native_event_up = { NULL, WM_KEYUP, ui::VKEY_A, 0 };
  ash::Shell::GetRootWindow()->PostNativeEvent(native_event_up);
#elif defined(USE_X11)
  XEvent native_event;
  ui::InitXKeyEventForTesting(ui::ET_KEY_PRESSED,
                              ui::VKEY_A,
                              0,
                              &native_event);
  ash::Shell::GetRootWindow()->PostNativeEvent(&native_event);
  ui::InitXKeyEventForTesting(ui::ET_KEY_RELEASED,
                              ui::VKEY_A,
                              0,
                              &native_event);
  ash::Shell::GetRootWindow()->PostNativeEvent(&native_event);
#endif

  ash::Shell::GetRootWindow()->PostNativeEvent(ui::CreateNoopEvent());
}

void TaskManagerView::LinkClicked(views::Link* source, int event_flags) {
  DCHECK(source == about_memory_link_);
  task_manager_->OpenAboutMemory();
}

void TaskManagerView::ExecuteCommand(int id) {
  tab_table_->SetColumnVisibility(id, !tab_table_->IsColumnVisible(id));
}

  void NotifyRefreshBluetooth() {
    ash::BluetoothObserver* observer = tray_->bluetooth_observer();
    if (observer)
      observer->OnBluetoothRefresh();
  }

void TaskManagerTableModel::OnModelChanged() {
  if (observer_)
    observer_->OnModelChanged();
}

  TestTarget() : accelerator_pressed_count_(0) {
  }

views::View* TaskManagerView::GetContentsView() {
  return this;
}

void TaskManagerView::ShowContextMenuForView(views::View* source,
                                             const gfx::Point& point) {
  UpdateStatsCounters();
  scoped_ptr<views::Menu> menu(views::Menu::Create(
      this, views::Menu::TOPLEFT, source->GetWidget()->GetNativeView()));
  for (std::vector<ui::TableColumn>::iterator i =
       columns_.begin(); i != columns_.end(); ++i) {
    menu->AppendMenuItem(i->id, l10n_util::GetStringUTF16(i->id),
        views::Menu::CHECKBOX);
  }
  menu->RunMenuAt(point.x(), point.y());
}

int TaskManagerView::GetDialogButtons() const {
  return ui::DIALOG_BUTTON_NONE;
}

void BluetoothDeviceDisconnectError() {
}

  const ui::Accelerator& last_accelerator() const {
    return last_accelerator_;
  }

  explicit DummyVolumeControlDelegate(bool consume)
      : consume_(consume),
        handle_volume_mute_count_(0),
        handle_volume_down_count_(0),
        handle_volume_up_count_(0) {
  }

TaskManagerView::~TaskManagerView() {
  RemoveAllChildViews(true);
}

std::string TaskManagerView::GetWindowName() const {
  return prefs::kTaskManagerWindowPlacement;
}
