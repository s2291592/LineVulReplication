void ReverbSetRoomLevel(ReverbContext *pContext, int16_t level){

    LVREV_ControlParams_st    ActiveParams; /* Current control Parameters */
    LVREV_ReturnStatus_en     LvmStatus=LVREV_SUCCESS; /* Function call status */
    LVM_INT32                 CombinedLevel; // Sum of room and reverb level controls

 /* Get the current settings */
 LvmStatus = LVREV_GetControlParameters(pContext->hInstance, &ActiveParams);
    LVM_ERROR_CHECK(LvmStatus, "LVREV_GetControlParameters", "ReverbSetRoomLevel")

 CombinedLevel = (level + pContext->SavedReverbLevel)-LVREV_MAX_REVERB_LEVEL;
 ActiveParams.Level = ReverbConvertLevel(CombinedLevel);

 /* Activate the initial settings */
 LvmStatus = LVREV_SetControlParameters(pContext->hInstance, &ActiveParams);
    LVM_ERROR_CHECK(LvmStatus, "LVREV_SetControlParameters", "ReverbSetRoomLevel")

    pContext->SavedRoomLevel = level;
 return;
}

void Downmix_foldFrom5Point1(int16_t *pSrc, int16_t*pDst, size_t numFrames, bool accumulate) {
 int32_t lt, rt, centerPlusLfeContrib; // samples in Q19.12 format
 if (accumulate) {
 while (numFrames) {
            centerPlusLfeContrib = (pSrc[2] * MINUS_3_DB_IN_Q19_12)
 + (pSrc[3] * MINUS_3_DB_IN_Q19_12);
            lt = (pSrc[0] << 12) + centerPlusLfeContrib + (pSrc[4] << 12);
            rt = (pSrc[1] << 12) + centerPlusLfeContrib + (pSrc[5] << 12);
            pDst[0] = clamp16(pDst[0] + (lt >> 13));
            pDst[1] = clamp16(pDst[1] + (rt >> 13));
            pSrc += 6;
            pDst += 2;
            numFrames--;
 }
 } else { // same code as above but without adding and clamping pDst[i] to itself
 while (numFrames) {
            centerPlusLfeContrib = (pSrc[2] * MINUS_3_DB_IN_Q19_12)
 + (pSrc[3] * MINUS_3_DB_IN_Q19_12);
            lt = (pSrc[0] << 12) + centerPlusLfeContrib + (pSrc[4] << 12);
            rt = (pSrc[1] << 12) + centerPlusLfeContrib + (pSrc[5] << 12);
            pDst[0] = clamp16(lt >> 13); // differs from when accumulate is true above
            pDst[1] = clamp16(rt >> 13); // differs from when accumulate is true above
            pSrc += 6;
            pDst += 2;
            numFrames--;
 }
 }
}

int NsInit (preproc_effect_t *effect)
{
    ALOGV("NsInit");
    webrtc::NoiseSuppression *ns = static_cast<webrtc::NoiseSuppression *>(effect->engine);
    ns->set_level(kNsDefaultLevel);
 return 0;
}

int Downmix_Reset(downmix_object_t *pDownmixer, bool init) {
     return 0;
 }

extern "C" int EffectRelease(effect_handle_t handle){
    ALOGV("\n\tEffectRelease start %p", handle);
 EffectContext * pContext = (EffectContext *)handle;

    ALOGV("\tEffectRelease start handle: %p, context %p", handle, pContext->pBundledContext);
 if (pContext == NULL){
        ALOGV("\tLVM_ERROR : EffectRelease called with NULL pointer");
 return -EINVAL;
 }

 SessionContext *pSessionContext = &GlobalSessionMemory[pContext->pBundledContext->SessionNo];

 if(pContext->EffectType == LVM_BASS_BOOST) {
        ALOGV("\tEffectRelease LVM_BASS_BOOST Clearing global intstantiated flag");
        pSessionContext->bBassInstantiated = LVM_FALSE;
 if(pContext->pBundledContext->SamplesToExitCountBb > 0){
            pContext->pBundledContext->NumberEffectsEnabled--;
 }
        pContext->pBundledContext->SamplesToExitCountBb = 0;
 } else if(pContext->EffectType == LVM_VIRTUALIZER) {
        ALOGV("\tEffectRelease LVM_VIRTUALIZER Clearing global intstantiated flag");
        pSessionContext->bVirtualizerInstantiated = LVM_FALSE;
 if(pContext->pBundledContext->SamplesToExitCountVirt > 0){
            pContext->pBundledContext->NumberEffectsEnabled--;
 }
        pContext->pBundledContext->SamplesToExitCountVirt = 0;
 } else if(pContext->EffectType == LVM_EQUALIZER) {
        ALOGV("\tEffectRelease LVM_EQUALIZER Clearing global intstantiated flag");
        pSessionContext->bEqualizerInstantiated =LVM_FALSE;
 if(pContext->pBundledContext->SamplesToExitCountEq > 0){
            pContext->pBundledContext->NumberEffectsEnabled--;
 }
        pContext->pBundledContext->SamplesToExitCountEq = 0;
 } else if(pContext->EffectType == LVM_VOLUME) {
        ALOGV("\tEffectRelease LVM_VOLUME Clearing global intstantiated flag");
        pSessionContext->bVolumeInstantiated = LVM_FALSE;
 if (pContext->pBundledContext->bVolumeEnabled == LVM_TRUE){
            pContext->pBundledContext->NumberEffectsEnabled--;
 }
 } else {
        ALOGV("\tLVM_ERROR : EffectRelease : Unsupported effect\n\n\n\n\n\n\n");
 }

 Effect_setEnabled(pContext, LVM_FALSE);

 if ((pSessionContext->bBassInstantiated == LVM_FALSE) &&
 (pSessionContext->bVolumeInstantiated == LVM_FALSE) &&
 (pSessionContext->bEqualizerInstantiated ==LVM_FALSE) &&
 (pSessionContext->bVirtualizerInstantiated==LVM_FALSE))
 {
 #ifdef LVM_PCM
 if (pContext->pBundledContext->PcmInPtr != NULL) {
            fclose(pContext->pBundledContext->PcmInPtr);
            pContext->pBundledContext->PcmInPtr = NULL;
 }
 if (pContext->pBundledContext->PcmOutPtr != NULL) {
            fclose(pContext->pBundledContext->PcmOutPtr);
            pContext->pBundledContext->PcmOutPtr = NULL;
 }
 #endif


 for(int i=0; i<LVM_MAX_SESSIONS; i++){
 if(SessionIndex[i] == pContext->pBundledContext->SessionId){
 SessionIndex[i] = LVM_UNUSED_SESSION;
                ALOGV("\tEffectRelease: Clearing SessionIndex SessionNo %d for SessionId %d\n",
                        i, pContext->pBundledContext->SessionId);
 break;
 }
 }

        ALOGV("\tEffectRelease: All effects are no longer instantiated\n");
        pSessionContext->bBundledEffectsEnabled = LVM_FALSE;
        pSessionContext->pBundledContext = LVM_NULL;
        ALOGV("\tEffectRelease: Freeing LVM Bundle memory\n");
 LvmEffect_free(pContext);
        ALOGV("\tEffectRelease: Deleting LVM Bundle context %p\n", pContext->pBundledContext);
 if (pContext->pBundledContext->workBuffer != NULL) {
            free(pContext->pBundledContext->workBuffer);
 }
 delete pContext->pBundledContext;
        pContext->pBundledContext = LVM_NULL;
 }
 delete pContext;

    ALOGV("\tEffectRelease end\n");
 return 0;

} /* end EffectRelease */

preproc_session_t *PreProc_GetSession(int32_t procId, int32_t  sessionId, int32_t  ioId)
{
 size_t i;
 int free = -1;
 for (i = 0; i < PREPROC_NUM_SESSIONS; i++) {
 if (sSessions[i].io == ioId) {
 if (sSessions[i].createdMsk & (1 << procId)) {
 return NULL;
 }
 return &sSessions[i];
 }
 }
 for (i = 0; i < PREPROC_NUM_SESSIONS; i++) {
 if (sSessions[i].io == 0) {
            sSessions[i].id = sessionId;
            sSessions[i].io = ioId;
 return &sSessions[i];
 }
 }
 return NULL;
}

int PreProcessingLib_GetDescriptor(const effect_uuid_t *uuid,
 effect_descriptor_t *pDescriptor) {

 if (pDescriptor == NULL || uuid == NULL){
 return -EINVAL;
 }

 const effect_descriptor_t *desc = PreProc_GetDescriptor(uuid);
 if (desc == NULL) {
        ALOGV("PreProcessingLib_GetDescriptor() not found");
 return -EINVAL;
 }

    ALOGV("PreProcessingLib_GetDescriptor() got fx %s", desc->name);

 *pDescriptor = *desc;
 return 0;
}

void From2iToMono_32( const LVM_INT32 *src,
                            LVM_INT32 *dst,
                            LVM_INT16 n)
{
   LVM_INT16 ii;
   LVM_INT32 Temp;

 for (ii = n; ii != 0; ii--)
 {
 Temp = (*src>>1);
       src++;

 Temp +=(*src>>1);
       src++;

 *dst = Temp;
       dst++;
 }

 return;
}

int Effect_getDescriptor(effect_handle_t   self,
 effect_descriptor_t *pDescriptor)
{
 EffectContext * pContext = (EffectContext *) self;
 const effect_descriptor_t *desc;

 if (pContext == NULL || pDescriptor == NULL) {
        ALOGV("Effect_getDescriptor() invalid param");
 return -EINVAL;
 }

 switch(pContext->EffectType) {
 case LVM_BASS_BOOST:
            desc = &android::gBassBoostDescriptor;
 break;
 case LVM_VIRTUALIZER:
            desc = &android::gVirtualizerDescriptor;
 break;
 case LVM_EQUALIZER:
            desc = &android::gEqualizerDescriptor;
 break;
 case LVM_VOLUME:
            desc = &android::gVolumeDescriptor;
 break;
 default:
 return -EINVAL;
 }

 *pDescriptor = *desc;

 return 0;
} /* end Effect_getDescriptor */

void Session_GetConfig(preproc_session_t *session, effect_config_t *config)
{
    memset(config, 0, sizeof(effect_config_t));
    config->inputCfg.samplingRate = config->outputCfg.samplingRate = session->samplingRate;
    config->inputCfg.format = config->outputCfg.format = AUDIO_FORMAT_PCM_16_BIT;
    config->inputCfg.channels = audio_channel_in_mask_from_count(session->inChannelCount);
    config->outputCfg.channels = audio_channel_in_mask_from_count(session->outChannelCount);
    config->inputCfg.mask = config->outputCfg.mask =
 (EFFECT_CONFIG_SMP_RATE | EFFECT_CONFIG_CHANNELS | EFFECT_CONFIG_FORMAT);
}

int Session_Init(preproc_session_t *session)
{
 size_t i;
 int status = 0;

    session->state = PREPROC_SESSION_STATE_INIT;
    session->id = 0;
    session->io = 0;
    session->createdMsk = 0;
    session->apm = NULL;
 for (i = 0; i < PREPROC_NUM_EFFECTS && status == 0; i++) {
        status = Effect_Init(&session->effects[i], i);
 }
 return status;
}

int AgcCreate(preproc_effect_t *effect)
{
    webrtc::GainControl *agc = effect->session->apm->gain_control();
    ALOGV("AgcCreate got agc %p", agc);
 if (agc == NULL) {
        ALOGW("AgcCreate Error");
 return -ENOMEM;
 }
    effect->engine = static_cast<preproc_fx_handle_t>(agc);
 AgcInit(effect);
 return 0;
}

void Downmix_foldFrom7Point1(int16_t *pSrc, int16_t*pDst, size_t numFrames, bool accumulate) {
 int32_t lt, rt, centerPlusLfeContrib; // samples in Q19.12 format
 if (accumulate) {
 while (numFrames) {
            centerPlusLfeContrib = (pSrc[2] * MINUS_3_DB_IN_Q19_12)
 + (pSrc[3] * MINUS_3_DB_IN_Q19_12);
            lt = (pSrc[0] << 12) + centerPlusLfeContrib + (pSrc[6] << 12) + (pSrc[4] << 12);
            rt = (pSrc[1] << 12) + centerPlusLfeContrib + (pSrc[7] << 12) + (pSrc[5] << 12);
            pDst[0] = clamp16(pDst[0] + (lt >> 13));
            pDst[1] = clamp16(pDst[1] + (rt >> 13));
            pSrc += 8;
            pDst += 2;
            numFrames--;
 }
 } else { // same code as above but without adding and clamping pDst[i] to itself
 while (numFrames) {
            centerPlusLfeContrib = (pSrc[2] * MINUS_3_DB_IN_Q19_12)
 + (pSrc[3] * MINUS_3_DB_IN_Q19_12);
            lt = (pSrc[0] << 12) + centerPlusLfeContrib + (pSrc[6] << 12) + (pSrc[4] << 12);
            rt = (pSrc[1] << 12) + centerPlusLfeContrib + (pSrc[7] << 12) + (pSrc[5] << 12);
            pDst[0] = clamp16(lt >> 13); // differs from when accumulate is true above
            pDst[1] = clamp16(rt >> 13); // differs from when accumulate is true above
            pSrc += 8;
            pDst += 2;
            numFrames--;
 }
 }
}

void AgcEnable(preproc_effect_t *effect)
{
    webrtc::GainControl *agc = static_cast<webrtc::GainControl *>(effect->engine);
    ALOGV("AgcEnable agc %p", agc);
    agc->Enable(true);
}

int BassBoost_setParameter (EffectContext *pContext, void *pParam, void *pValue){
 int status = 0;
 int16_t strength;
 int32_t *pParamTemp = (int32_t *)pParam;


 switch (*pParamTemp){
 case BASSBOOST_PARAM_STRENGTH:
            strength = *(int16_t *)pValue;
 BassSetStrength(pContext, (int32_t)strength);
 break;
 default:
            ALOGV("\tLVM_ERROR : BassBoost_setParameter() invalid param %d", *pParamTemp);
 break;
 }

 return status;
} /* end BassBoost_setParameter */

int Downmix_GetDescriptor(effect_handle_t self, effect_descriptor_t *pDescriptor)
{
 downmix_module_t *pDwnmxModule = (downmix_module_t *) self;

 if (pDwnmxModule == NULL ||
            pDwnmxModule->context.state == DOWNMIX_STATE_UNINITIALIZED) {
 return -EINVAL;
 }

    memcpy(pDescriptor, &gDownmixDescriptor, sizeof(effect_descriptor_t));

 return 0;
}

int Reverb_setConfig(ReverbContext *pContext, effect_config_t *pConfig){
    LVM_Fs_en   SampleRate;

    CHECK_ARG(pContext != NULL);
    CHECK_ARG(pConfig != NULL);

    CHECK_ARG(pConfig->inputCfg.samplingRate == pConfig->outputCfg.samplingRate);
    CHECK_ARG(pConfig->inputCfg.format == pConfig->outputCfg.format);
    CHECK_ARG((pContext->auxiliary && pConfig->inputCfg.channels == AUDIO_CHANNEL_OUT_MONO) ||
 ((!pContext->auxiliary) && pConfig->inputCfg.channels == AUDIO_CHANNEL_OUT_STEREO));
    CHECK_ARG(pConfig->outputCfg.channels == AUDIO_CHANNEL_OUT_STEREO);
    CHECK_ARG(pConfig->outputCfg.accessMode == EFFECT_BUFFER_ACCESS_WRITE
 || pConfig->outputCfg.accessMode == EFFECT_BUFFER_ACCESS_ACCUMULATE);
    CHECK_ARG(pConfig->inputCfg.format == AUDIO_FORMAT_PCM_16_BIT);

    pContext->config = *pConfig;


 switch (pConfig->inputCfg.samplingRate) {
 case 8000:
 SampleRate = LVM_FS_8000;
 break;
 case 16000:
 SampleRate = LVM_FS_16000;
 break;
 case 22050:
 SampleRate = LVM_FS_22050;
 break;
 case 32000:
 SampleRate = LVM_FS_32000;
 break;
 case 44100:
 SampleRate = LVM_FS_44100;
 break;
 case 48000:
 SampleRate = LVM_FS_48000;
 break;
 default:
        ALOGV("\rReverb_setConfig invalid sampling rate %d", pConfig->inputCfg.samplingRate);
 return -EINVAL;
 }

 if (pContext->SampleRate != SampleRate) {

        LVREV_ControlParams_st    ActiveParams;
        LVREV_ReturnStatus_en     LvmStatus = LVREV_SUCCESS;


 /* Get the current settings */
 LvmStatus = LVREV_GetControlParameters(pContext->hInstance,
 &ActiveParams);

        LVM_ERROR_CHECK(LvmStatus, "LVREV_GetControlParameters", "Reverb_setConfig")
 if(LvmStatus != LVREV_SUCCESS) return -EINVAL;

 ActiveParams.SampleRate = SampleRate;

 LvmStatus = LVREV_SetControlParameters(pContext->hInstance, &ActiveParams);

        LVM_ERROR_CHECK(LvmStatus, "LVREV_SetControlParameters", "Reverb_setConfig")
 if(LvmStatus != LVREV_SUCCESS) return -EINVAL;
        pContext->SampleRate = SampleRate;
 }else{
 }

 return 0;
} /* end Reverb_setConfig */

int AgcInit (preproc_effect_t *effect)
{
    ALOGV("AgcInit");
    webrtc::GainControl *agc = static_cast<webrtc::GainControl *>(effect->engine);
    agc->set_mode(webrtc::GainControl::kFixedDigital);
    agc->set_target_level_dbfs(kAgcDefaultTargetLevel);
    agc->set_compression_gain_db(kAgcDefaultCompGain);
    agc->enable_limiter(kAgcDefaultLimiter);
 return 0;
}

int AgcGetParameter(preproc_effect_t *effect,
 void *pParam,
 uint32_t *pValueSize,
 void *pValue)
{
 int status = 0;
 uint32_t param = *(uint32_t *)pParam;
    t_agc_settings *pProperties = (t_agc_settings *)pValue;
    webrtc::GainControl *agc = static_cast<webrtc::GainControl *>(effect->engine);

 switch (param) {
 case AGC_PARAM_TARGET_LEVEL:
 case AGC_PARAM_COMP_GAIN:
 if (*pValueSize < sizeof(int16_t)) {
 *pValueSize = 0;
 return -EINVAL;
 }
 break;
 case AGC_PARAM_LIMITER_ENA:
 if (*pValueSize < sizeof(bool)) {
 *pValueSize = 0;
 return -EINVAL;
 }
 break;
 case AGC_PARAM_PROPERTIES:
 if (*pValueSize < sizeof(t_agc_settings)) {
 *pValueSize = 0;
 return -EINVAL;
 }
 break;

 default:
        ALOGW("AgcGetParameter() unknown param %08x", param);
        status = -EINVAL;
 break;
 }

 switch (param) {
 case AGC_PARAM_TARGET_LEVEL:
 *(int16_t *) pValue = (int16_t)(agc->target_level_dbfs() * -100);
        ALOGV("AgcGetParameter() target level %d milliBels", *(int16_t *) pValue);
 break;
 case AGC_PARAM_COMP_GAIN:
 *(int16_t *) pValue = (int16_t)(agc->compression_gain_db() * 100);
        ALOGV("AgcGetParameter() comp gain %d milliBels", *(int16_t *) pValue);
 break;
 case AGC_PARAM_LIMITER_ENA:
 *(bool *) pValue = (bool)agc->is_limiter_enabled();
        ALOGV("AgcGetParameter() limiter enabled %s",
 (*(int16_t *) pValue != 0) ? "true" : "false");
 break;
 case AGC_PARAM_PROPERTIES:
        pProperties->targetLevel = (int16_t)(agc->target_level_dbfs() * -100);
        pProperties->compGain = (int16_t)(agc->compression_gain_db() * 100);
        pProperties->limiterEnabled = (bool)agc->is_limiter_enabled();
 break;
 default:
        ALOGW("AgcGetParameter() unknown param %d", param);
        status = -EINVAL;
 break;
 }
 return status;
}

int LvmEffect_disable(EffectContext *pContext){

 LVM_ControlParams_t ActiveParams; /* Current control Parameters */
    LVM_ReturnStatus_en     LvmStatus = LVM_SUCCESS; /* Function call status */
 /* Get the current settings */
 LvmStatus = LVM_GetControlParameters(pContext->pBundledContext->hInstance,
 &ActiveParams);

    LVM_ERROR_CHECK(LvmStatus, "LVM_GetControlParameters", "LvmEffect_disable")
 if(LvmStatus != LVM_SUCCESS) return -EINVAL;

 if(pContext->EffectType == LVM_BASS_BOOST) {
        ALOGV("\tLvmEffect_disable : Disabling LVM_BASS_BOOST");
 ActiveParams.BE_OperatingMode       = LVM_BE_OFF;
 }
 if(pContext->EffectType == LVM_VIRTUALIZER) {
        ALOGV("\tLvmEffect_disable : Disabling LVM_VIRTUALIZER");
 ActiveParams.VirtualizerOperatingMode = LVM_MODE_OFF;
 }
 if(pContext->EffectType == LVM_EQUALIZER) {
        ALOGV("\tLvmEffect_disable : Disabling LVM_EQUALIZER");
 ActiveParams.EQNB_OperatingMode     = LVM_EQNB_OFF;
 }
 if(pContext->EffectType == LVM_VOLUME) {
        ALOGV("\tLvmEffect_disable : Disabling LVM_VOLUME");
 }

 LvmStatus = LVM_SetControlParameters(pContext->pBundledContext->hInstance, &ActiveParams);
    LVM_ERROR_CHECK(LvmStatus, "LVM_SetControlParameters", "LvmEffect_disable")
 if(LvmStatus != LVM_SUCCESS) return -EINVAL;

 LvmEffect_limitLevel(pContext);
 return 0;
}

int32_t VolumeSetMute(EffectContext *pContext, uint32_t mute){

    pContext->pBundledContext->bMuteEnabled = mute;

 /* Set appropriate volume level */
 if(pContext->pBundledContext->bMuteEnabled == LVM_TRUE){
        pContext->pBundledContext->levelSaved = pContext->pBundledContext->volume;
        pContext->pBundledContext->volume = -96;
 }else{
        pContext->pBundledContext->volume = pContext->pBundledContext->levelSaved;
 }

 LvmEffect_limitLevel(pContext);

 return 0;
} /* end setMute */

int Effect_setConfig(EffectContext *pContext, effect_config_t *pConfig){
    LVM_Fs_en   SampleRate;

    CHECK_ARG(pContext != NULL);
    CHECK_ARG(pConfig != NULL);

    CHECK_ARG(pConfig->inputCfg.samplingRate == pConfig->outputCfg.samplingRate);
    CHECK_ARG(pConfig->inputCfg.channels == pConfig->outputCfg.channels);
    CHECK_ARG(pConfig->inputCfg.format == pConfig->outputCfg.format);
    CHECK_ARG(pConfig->inputCfg.channels == AUDIO_CHANNEL_OUT_STEREO);
    CHECK_ARG(pConfig->outputCfg.accessMode == EFFECT_BUFFER_ACCESS_WRITE
 || pConfig->outputCfg.accessMode == EFFECT_BUFFER_ACCESS_ACCUMULATE);
    CHECK_ARG(pConfig->inputCfg.format == AUDIO_FORMAT_PCM_16_BIT);

    pContext->config = *pConfig;

 switch (pConfig->inputCfg.samplingRate) {
 case 8000:
 SampleRate = LVM_FS_8000;
        pContext->pBundledContext->SamplesPerSecond = 8000*2; // 2 secs Stereo
 break;
 case 16000:
 SampleRate = LVM_FS_16000;
        pContext->pBundledContext->SamplesPerSecond = 16000*2; // 2 secs Stereo
 break;
 case 22050:
 SampleRate = LVM_FS_22050;
        pContext->pBundledContext->SamplesPerSecond = 22050*2; // 2 secs Stereo
 break;
 case 32000:
 SampleRate = LVM_FS_32000;
        pContext->pBundledContext->SamplesPerSecond = 32000*2; // 2 secs Stereo
 break;
 case 44100:
 SampleRate = LVM_FS_44100;
        pContext->pBundledContext->SamplesPerSecond = 44100*2; // 2 secs Stereo
 break;
 case 48000:
 SampleRate = LVM_FS_48000;
        pContext->pBundledContext->SamplesPerSecond = 48000*2; // 2 secs Stereo
 break;
 default:
        ALOGV("\tEffect_setConfig invalid sampling rate %d", pConfig->inputCfg.samplingRate);
 return -EINVAL;
 }

 if(pContext->pBundledContext->SampleRate != SampleRate){

 LVM_ControlParams_t ActiveParams;
        LVM_ReturnStatus_en     LvmStatus = LVM_SUCCESS;

        ALOGV("\tEffect_setConfig change sampling rate to %d", SampleRate);

 /* Get the current settings */
 LvmStatus = LVM_GetControlParameters(pContext->pBundledContext->hInstance,
 &ActiveParams);

        LVM_ERROR_CHECK(LvmStatus, "LVM_GetControlParameters", "Effect_setConfig")
 if(LvmStatus != LVM_SUCCESS) return -EINVAL;

 ActiveParams.SampleRate = SampleRate;

 LvmStatus = LVM_SetControlParameters(pContext->pBundledContext->hInstance, &ActiveParams);

        LVM_ERROR_CHECK(LvmStatus, "LVM_SetControlParameters", "Effect_setConfig")
        ALOGV("\tEffect_setConfig Succesfully called LVM_SetControlParameters\n");
        pContext->pBundledContext->SampleRate = SampleRate;

 }else{
 }

 return 0;
} /* end Effect_setConfig */

static int Downmix_Process(effect_handle_t self,
 audio_buffer_t *inBuffer, audio_buffer_t *outBuffer) {

 downmix_object_t *pDownmixer;
 int16_t *pSrc, *pDst;
 downmix_module_t *pDwmModule = (downmix_module_t *)self;

 if (pDwmModule == NULL) {
 return -EINVAL;
 }

 if (inBuffer == NULL || inBuffer->raw == NULL ||
        outBuffer == NULL || outBuffer->raw == NULL ||
        inBuffer->frameCount != outBuffer->frameCount) {
 return -EINVAL;
 }

    pDownmixer = (downmix_object_t*) &pDwmModule->context;

 if (pDownmixer->state == DOWNMIX_STATE_UNINITIALIZED) {
        ALOGE("Downmix_Process error: trying to use an uninitialized downmixer");
 return -EINVAL;
 } else if (pDownmixer->state == DOWNMIX_STATE_INITIALIZED) {
        ALOGE("Downmix_Process error: trying to use a non-configured downmixer");
 return -ENODATA;
 }

    pSrc = inBuffer->s16;
    pDst = outBuffer->s16;
 size_t numFrames = outBuffer->frameCount;

 const bool accumulate =
 (pDwmModule->config.outputCfg.accessMode == EFFECT_BUFFER_ACCESS_ACCUMULATE);
 const uint32_t downmixInputChannelMask = pDwmModule->config.inputCfg.channels;

 switch(pDownmixer->type) {

 case DOWNMIX_TYPE_STRIP:
 if (accumulate) {
 while (numFrames) {
                  pDst[0] = clamp16(pDst[0] + pSrc[0]);
                  pDst[1] = clamp16(pDst[1] + pSrc[1]);
                  pSrc += pDownmixer->input_channel_count;
                  pDst += 2;
                  numFrames--;
 }
 } else {
 while (numFrames) {
                  pDst[0] = pSrc[0];
                  pDst[1] = pSrc[1];
                  pSrc += pDownmixer->input_channel_count;
                  pDst += 2;
                  numFrames--;
 }
 }
 break;

 case DOWNMIX_TYPE_FOLD:
#ifdef DOWNMIX_ALWAYS_USE_GENERIC_DOWNMIXER
 if (!Downmix_foldGeneric(
                  downmixInputChannelMask, pSrc, pDst, numFrames, accumulate)) {
              ALOGE("Multichannel configuration 0x%" PRIx32 " is not supported", downmixInputChannelMask);
 return -EINVAL;
 }
 break;
#endif
 switch((downmix_input_channel_mask_t)downmixInputChannelMask) {
 case CHANNEL_MASK_QUAD_BACK:
 case CHANNEL_MASK_QUAD_SIDE:
 Downmix_foldFromQuad(pSrc, pDst, numFrames, accumulate);
 break;
 case CHANNEL_MASK_5POINT1_BACK:
 case CHANNEL_MASK_5POINT1_SIDE:
 Downmix_foldFrom5Point1(pSrc, pDst, numFrames, accumulate);
 break;
 case CHANNEL_MASK_7POINT1:
 Downmix_foldFrom7Point1(pSrc, pDst, numFrames, accumulate);
 break;
 default:
 if (!Downmix_foldGeneric(
                    downmixInputChannelMask, pSrc, pDst, numFrames, accumulate)) {
                ALOGE("Multichannel configuration 0x%" PRIx32 " is not supported", downmixInputChannelMask);
 return -EINVAL;
 }
 break;
 }
 break;

 default:
 return -EINVAL;
 }

 return 0;
}

int32_t VolumeEnableStereoPosition(EffectContext *pContext, uint32_t enabled){

    pContext->pBundledContext->bStereoPositionEnabled = enabled;

 LVM_ControlParams_t ActiveParams; /* Current control Parameters */
    LVM_ReturnStatus_en     LvmStatus=LVM_SUCCESS; /* Function call status */

 /* Get the current settings */
 LvmStatus = LVM_GetControlParameters(pContext->pBundledContext->hInstance, &ActiveParams);
    LVM_ERROR_CHECK(LvmStatus, "LVM_GetControlParameters", "VolumeEnableStereoPosition")
 if(LvmStatus != LVM_SUCCESS) return -EINVAL;


 /* Set appropriate stereo position */
 if(pContext->pBundledContext->bStereoPositionEnabled == LVM_FALSE){
 ActiveParams.VC_Balance = 0;
 }else{
 ActiveParams.VC_Balance  =
 VolumeConvertStereoPosition(pContext->pBundledContext->positionSaved);
 }

 /* Activate the initial settings */
 LvmStatus = LVM_SetControlParameters(pContext->pBundledContext->hInstance, &ActiveParams);
    LVM_ERROR_CHECK(LvmStatus, "LVM_SetControlParameters", "VolumeEnableStereoPosition")
 if(LvmStatus != LVM_SUCCESS) return -EINVAL;

 return 0;
} /* end VolumeEnableStereoPosition */

void LvmGlobalBundle_init(){
    ALOGV("\tLvmGlobalBundle_init start");
 for(int i=0; i<LVM_MAX_SESSIONS; i++){
 GlobalSessionMemory[i].bBundledEffectsEnabled   = LVM_FALSE;
 GlobalSessionMemory[i].bVolumeInstantiated      = LVM_FALSE;
 GlobalSessionMemory[i].bEqualizerInstantiated   = LVM_FALSE;
 GlobalSessionMemory[i].bBassInstantiated        = LVM_FALSE;
 GlobalSessionMemory[i].bVirtualizerInstantiated = LVM_FALSE;
 GlobalSessionMemory[i].pBundledContext          = LVM_NULL;

 SessionIndex[i] = LVM_UNUSED_SESSION;
 }
 return;
}

void Session_GetReverseConfig(preproc_session_t *session, effect_config_t *config)
{
    memset(config, 0, sizeof(effect_config_t));
    config->inputCfg.samplingRate = config->outputCfg.samplingRate = session->samplingRate;
    config->inputCfg.format = config->outputCfg.format = AUDIO_FORMAT_PCM_16_BIT;
    config->inputCfg.channels = config->outputCfg.channels =
            audio_channel_in_mask_from_count(session->revChannelCount);
    config->inputCfg.mask = config->outputCfg.mask =
 (EFFECT_CONFIG_SMP_RATE | EFFECT_CONFIG_CHANNELS | EFFECT_CONFIG_FORMAT);
}

int LvmBundle_init(EffectContext *pContext){
 int status;

    ALOGV("\tLvmBundle_init start");

    pContext->config.inputCfg.accessMode                    = EFFECT_BUFFER_ACCESS_READ;
    pContext->config.inputCfg.channels                      = AUDIO_CHANNEL_OUT_STEREO;
    pContext->config.inputCfg.format                        = AUDIO_FORMAT_PCM_16_BIT;
    pContext->config.inputCfg.samplingRate                  = 44100;
    pContext->config.inputCfg.bufferProvider.getBuffer      = NULL;
    pContext->config.inputCfg.bufferProvider.releaseBuffer  = NULL;
    pContext->config.inputCfg.bufferProvider.cookie         = NULL;
    pContext->config.inputCfg.mask                          = EFFECT_CONFIG_ALL;
    pContext->config.outputCfg.accessMode                   = EFFECT_BUFFER_ACCESS_ACCUMULATE;
    pContext->config.outputCfg.channels                     = AUDIO_CHANNEL_OUT_STEREO;
    pContext->config.outputCfg.format                       = AUDIO_FORMAT_PCM_16_BIT;
    pContext->config.outputCfg.samplingRate                 = 44100;
    pContext->config.outputCfg.bufferProvider.getBuffer     = NULL;
    pContext->config.outputCfg.bufferProvider.releaseBuffer = NULL;
    pContext->config.outputCfg.bufferProvider.cookie        = NULL;
    pContext->config.outputCfg.mask                         = EFFECT_CONFIG_ALL;

    CHECK_ARG(pContext != NULL);

 if (pContext->pBundledContext->hInstance != NULL){
        ALOGV("\tLvmBundle_init pContext->pBassBoost != NULL "
 "-> Calling pContext->pBassBoost->free()");

 LvmEffect_free(pContext);

        ALOGV("\tLvmBundle_init pContext->pBassBoost != NULL "
 "-> Called pContext->pBassBoost->free()");
 }

    LVM_ReturnStatus_en     LvmStatus=LVM_SUCCESS; /* Function call status */
 LVM_ControlParams_t     params; /* Control Parameters */
 LVM_InstParams_t InstParams; /* Instance parameters */
 LVM_EQNB_BandDef_t BandDefs[MAX_NUM_BANDS]; /* Equaliser band definitions */
 LVM_HeadroomParams_t HeadroomParams; /* Headroom parameters */
 LVM_HeadroomBandDef_t HeadroomBandDef[LVM_HEADROOM_MAX_NBANDS];
 LVM_MemTab_t MemTab; /* Memory allocation table */
 bool                    bMallocFailure = LVM_FALSE;

 /* Set the capabilities */
 InstParams.BufferMode = LVM_UNMANAGED_BUFFERS;
 InstParams.MaxBlockSize = MAX_CALL_SIZE;
 InstParams.EQNB_NumBands    = MAX_NUM_BANDS;
 InstParams.PSA_Included     = LVM_PSA_ON;

 /* Allocate memory, forcing alignment */
 LvmStatus = LVM_GetMemoryTable(LVM_NULL,
 &MemTab,
 &InstParams);

    LVM_ERROR_CHECK(LvmStatus, "LVM_GetMemoryTable", "LvmBundle_init")
 if(LvmStatus != LVM_SUCCESS) return -EINVAL;

    ALOGV("\tCreateInstance Succesfully called LVM_GetMemoryTable\n");

 /* Allocate memory */
 for (int i=0; i<LVM_NR_MEMORY_REGIONS; i++){
 if (MemTab.Region[i].Size != 0){
 MemTab.Region[i].pBaseAddress = malloc(MemTab.Region[i].Size);

 if (MemTab.Region[i].pBaseAddress == LVM_NULL){
                ALOGV("\tLVM_ERROR :LvmBundle_init CreateInstance Failed to allocate %" PRIu32
 " bytes for region %u\n", MemTab.Region[i].Size, i );
                bMallocFailure = LVM_TRUE;
 }else{
                ALOGV("\tLvmBundle_init CreateInstance allocated %" PRIu32
 " bytes for region %u at %p\n",
 MemTab.Region[i].Size, i, MemTab.Region[i].pBaseAddress);
 }
 }
 }

 /* If one or more of the memory regions failed to allocate, free the regions that were
     * succesfully allocated and return with an error
     */
 if(bMallocFailure == LVM_TRUE){
 for (int i=0; i<LVM_NR_MEMORY_REGIONS; i++){
 if (MemTab.Region[i].pBaseAddress == LVM_NULL){
                ALOGV("\tLVM_ERROR :LvmBundle_init CreateInstance Failed to allocate %" PRIu32
 " bytes for region %u Not freeing\n", MemTab.Region[i].Size, i );
 }else{
                ALOGV("\tLVM_ERROR :LvmBundle_init CreateInstance Failed: but allocated %" PRIu32
 " bytes for region %u at %p- free\n",
 MemTab.Region[i].Size, i, MemTab.Region[i].pBaseAddress);
                free(MemTab.Region[i].pBaseAddress);
 }
 }
 return -EINVAL;
 }
    ALOGV("\tLvmBundle_init CreateInstance Succesfully malloc'd memory\n");

 /* Initialise */
    pContext->pBundledContext->hInstance = LVM_NULL;

 /* Init sets the instance handle */
 LvmStatus = LVM_GetInstanceHandle(&pContext->pBundledContext->hInstance,
 &MemTab,
 &InstParams);

    LVM_ERROR_CHECK(LvmStatus, "LVM_GetInstanceHandle", "LvmBundle_init")
 if(LvmStatus != LVM_SUCCESS) return -EINVAL;

    ALOGV("\tLvmBundle_init CreateInstance Succesfully called LVM_GetInstanceHandle\n");

 /* Set the initial process parameters */
 /* General parameters */
    params.OperatingMode = LVM_MODE_ON;
    params.SampleRate = LVM_FS_44100;
    params.SourceFormat = LVM_STEREO;
    params.SpeakerType = LVM_HEADPHONES;

    pContext->pBundledContext->SampleRate = LVM_FS_44100;

 /* Concert Sound parameters */
    params.VirtualizerOperatingMode = LVM_MODE_OFF;
    params.VirtualizerType = LVM_CONCERTSOUND;
    params.VirtualizerReverbLevel = 100;
    params.CS_EffectLevel             = LVM_CS_EFFECT_NONE;

 /* N-Band Equaliser parameters */
    params.EQNB_OperatingMode     = LVM_EQNB_OFF;
    params.EQNB_NBands            = FIVEBAND_NUMBANDS;
    params.pEQNB_BandDefinition   = &BandDefs[0];

 for (int i=0; i<FIVEBAND_NUMBANDS; i++)
 {
 BandDefs[i].Frequency = EQNB_5BandPresetsFrequencies[i];
 BandDefs[i].QFactor = EQNB_5BandPresetsQFactors[i];
 BandDefs[i].Gain = EQNB_5BandSoftPresets[i];
 }

 /* Volume Control parameters */
    params.VC_EffectLevel         = 0;
    params.VC_Balance             = 0;

 /* Treble Enhancement parameters */
    params.TE_OperatingMode       = LVM_TE_OFF;
    params.TE_EffectLevel         = 0;

 /* PSA Control parameters */
    params.PSA_Enable             = LVM_PSA_OFF;
    params.PSA_PeakDecayRate      = (LVM_PSA_DecaySpeed_en)0;

 /* Bass Enhancement parameters */
    params.BE_OperatingMode       = LVM_BE_OFF;
    params.BE_EffectLevel         = 0;
    params.BE_CentreFreq          = LVM_BE_CENTRE_90Hz;
    params.BE_HPF                 = LVM_BE_HPF_ON;

 /* PSA Control parameters */
    params.PSA_Enable             = LVM_PSA_OFF;
    params.PSA_PeakDecayRate      = LVM_PSA_SPEED_MEDIUM;

 /* TE Control parameters */
    params.TE_OperatingMode       = LVM_TE_OFF;
    params.TE_EffectLevel         = 0;

 /* Activate the initial settings */
 LvmStatus = LVM_SetControlParameters(pContext->pBundledContext->hInstance,
 &params);

    LVM_ERROR_CHECK(LvmStatus, "LVM_SetControlParameters", "LvmBundle_init")
 if(LvmStatus != LVM_SUCCESS) return -EINVAL;

    ALOGV("\tLvmBundle_init CreateInstance Succesfully called LVM_SetControlParameters\n");

 /* Set the headroom parameters */
 HeadroomBandDef[0].Limit_Low = 20;
 HeadroomBandDef[0].Limit_High = 4999;
 HeadroomBandDef[0].Headroom_Offset = 0;
 HeadroomBandDef[1].Limit_Low = 5000;
 HeadroomBandDef[1].Limit_High = 24000;
 HeadroomBandDef[1].Headroom_Offset = 0;
 HeadroomParams.pHeadroomDefinition    = &HeadroomBandDef[0];
 HeadroomParams.Headroom_OperatingMode = LVM_HEADROOM_ON;
 HeadroomParams.NHeadroomBands = 2;

 LvmStatus = LVM_SetHeadroomParams(pContext->pBundledContext->hInstance,
 &HeadroomParams);

    LVM_ERROR_CHECK(LvmStatus, "LVM_SetHeadroomParams", "LvmBundle_init")
 if(LvmStatus != LVM_SUCCESS) return -EINVAL;

    ALOGV("\tLvmBundle_init CreateInstance Succesfully called LVM_SetHeadroomParams\n");
    ALOGV("\tLvmBundle_init End");
 return 0;
} /* end LvmBundle_init */

int Effect_Init(preproc_effect_t *effect, uint32_t procId)
{
 if (HasReverseStream(procId)) {
        effect->itfe = &sEffectInterfaceReverse;
 } else {
        effect->itfe = &sEffectInterface;
 }
    effect->ops = sPreProcOps[procId];
    effect->procId = procId;
    effect->state = PREPROC_EFFECT_STATE_INIT;
 return 0;
}

const effect_descriptor_t *PreProc_GetDescriptor(const effect_uuid_t *uuid)
{
 size_t i;
 for (i = 0; i < PREPROC_NUM_EFFECTS; i++) {
 if (memcmp(&sDescriptors[i]->uuid, uuid, sizeof(effect_uuid_t)) == 0) {
 return sDescriptors[i];
 }
 }
 return NULL;
}

void ReverbSetRoomHfLevel(ReverbContext *pContext, int16_t level){

    LVREV_ControlParams_st    ActiveParams; /* Current control Parameters */
    LVREV_ReturnStatus_en     LvmStatus=LVREV_SUCCESS; /* Function call status */

 /* Get the current settings */
 LvmStatus = LVREV_GetControlParameters(pContext->hInstance, &ActiveParams);
    LVM_ERROR_CHECK(LvmStatus, "LVREV_GetControlParameters", "ReverbSetRoomHfLevel")

 ActiveParams.LPF = ReverbConvertHfLevel(level);

 /* Activate the initial settings */
 LvmStatus = LVREV_SetControlParameters(pContext->hInstance, &ActiveParams);
    LVM_ERROR_CHECK(LvmStatus, "LVREV_SetControlParameters", "ReverbSetRoomHfLevel")
    pContext->SavedHfLevel = level;
 return;
}

int Effect_process(effect_handle_t     self,
 audio_buffer_t *inBuffer,
 audio_buffer_t *outBuffer){
 EffectContext * pContext = (EffectContext *) self;
    LVM_ReturnStatus_en     LvmStatus = LVM_SUCCESS; /* Function call status */
 int    status = 0;
 int    lvmStatus = 0;
    LVM_INT16   *in  = (LVM_INT16 *)inBuffer->raw;
    LVM_INT16   *out = (LVM_INT16 *)outBuffer->raw;


 if (pContext == NULL){
        ALOGV("\tLVM_ERROR : Effect_process() ERROR pContext == NULL");
 return -EINVAL;
 }


 if (inBuffer == NULL  || inBuffer->raw == NULL  ||
            outBuffer == NULL || outBuffer->raw == NULL ||
            inBuffer->frameCount != outBuffer->frameCount){
        ALOGV("\tLVM_ERROR : Effect_process() ERROR NULL INPUT POINTER OR FRAME COUNT IS WRONG");
 return -EINVAL;
 }
 if ((pContext->pBundledContext->bBassEnabled == LVM_FALSE)&&
 (pContext->EffectType == LVM_BASS_BOOST)){
 if(pContext->pBundledContext->SamplesToExitCountBb > 0){
            pContext->pBundledContext->SamplesToExitCountBb -= outBuffer->frameCount * 2; // STEREO
 }
 if(pContext->pBundledContext->SamplesToExitCountBb <= 0) {
            status = -ENODATA;
            pContext->pBundledContext->NumberEffectsEnabled--;
            ALOGV("\tEffect_process() this is the last frame for LVM_BASS_BOOST");
 }
 }
 if ((pContext->pBundledContext->bVolumeEnabled == LVM_FALSE)&&
 (pContext->EffectType == LVM_VOLUME)){
        status = -ENODATA;
        pContext->pBundledContext->NumberEffectsEnabled--;
 }
 if ((pContext->pBundledContext->bEqualizerEnabled == LVM_FALSE)&&
 (pContext->EffectType == LVM_EQUALIZER)){
 if(pContext->pBundledContext->SamplesToExitCountEq > 0){
            pContext->pBundledContext->SamplesToExitCountEq -= outBuffer->frameCount * 2; // STEREO
 }
 if(pContext->pBundledContext->SamplesToExitCountEq <= 0) {
            status = -ENODATA;
            pContext->pBundledContext->NumberEffectsEnabled--;
            ALOGV("\tEffect_process() this is the last frame for LVM_EQUALIZER");
 }
 }
 if ((pContext->pBundledContext->bVirtualizerEnabled == LVM_FALSE)&&
 (pContext->EffectType == LVM_VIRTUALIZER)){
 if(pContext->pBundledContext->SamplesToExitCountVirt > 0){
            pContext->pBundledContext->SamplesToExitCountVirt -= outBuffer->frameCount * 2;// STEREO
 }
 if(pContext->pBundledContext->SamplesToExitCountVirt <= 0) {
            status = -ENODATA;
            pContext->pBundledContext->NumberEffectsEnabled--;
            ALOGV("\tEffect_process() this is the last frame for LVM_VIRTUALIZER");
 }
 }

 if(status != -ENODATA){
        pContext->pBundledContext->NumberEffectsCalled++;
 }

 if(pContext->pBundledContext->NumberEffectsCalled ==
       pContext->pBundledContext->NumberEffectsEnabled){

 if(status == -ENODATA){
            ALOGV("\tEffect_process() processing last frame");
 }
        pContext->pBundledContext->NumberEffectsCalled = 0;
 /* Process all the available frames, block processing is
           handled internalLY by the LVM bundle */
        lvmStatus = android::LvmBundle_process( (LVM_INT16 *)inBuffer->raw,
 (LVM_INT16 *)outBuffer->raw,
                                                outBuffer->frameCount,
                                                pContext);
 if(lvmStatus != LVM_SUCCESS){
            ALOGV("\tLVM_ERROR : LvmBundle_process returned error %d", lvmStatus);
 return lvmStatus;
 }
 } else {
 if (pContext->config.outputCfg.accessMode == EFFECT_BUFFER_ACCESS_ACCUMULATE) {
 for (size_t i=0; i < outBuffer->frameCount*2; i++){
                outBuffer->s16[i] =
                        clamp16((LVM_INT32)outBuffer->s16[i] + (LVM_INT32)inBuffer->s16[i]);
 }
 } else if (outBuffer->raw != inBuffer->raw) {
            memcpy(outBuffer->raw, inBuffer->raw, outBuffer->frameCount*sizeof(LVM_INT16)*2);
 }
 }

 return status;
} /* end Effect_process */

int16_t ReverbGetRoomLevel(ReverbContext *pContext){
 int16_t level;

    LVREV_ControlParams_st    ActiveParams; /* Current control Parameters */
    LVREV_ReturnStatus_en     LvmStatus=LVREV_SUCCESS; /* Function call status */
    LVM_INT32                 CombinedLevel; // Sum of room and reverb level controls

 /* Get the current settings */
 LvmStatus = LVREV_GetControlParameters(pContext->hInstance, &ActiveParams);
    LVM_ERROR_CHECK(LvmStatus, "LVREV_GetControlParameters", "ReverbGetRoomLevel")

 CombinedLevel = (pContext->SavedRoomLevel + pContext->SavedReverbLevel-LVREV_MAX_REVERB_LEVEL);
    level = ReverbConvertLevel(CombinedLevel);


 if(ActiveParams.Level != level){
        ALOGV("\tLVM_ERROR : (ignore at start up) ReverbGetRoomLevel() has wrong level -> %d %d\n",
 ActiveParams.Level, level);
 }

 return pContext->SavedRoomLevel;
}

int PreProcessingFx_Process(effect_handle_t     self,
 audio_buffer_t *inBuffer,
 audio_buffer_t *outBuffer)
{
 preproc_effect_t * effect = (preproc_effect_t *)self;
 int    status = 0;

 if (effect == NULL){
        ALOGV("PreProcessingFx_Process() ERROR effect == NULL");
 return -EINVAL;
 }
 preproc_session_t * session = (preproc_session_t *)effect->session;

 if (inBuffer == NULL  || inBuffer->raw == NULL  ||
            outBuffer == NULL || outBuffer->raw == NULL){
        ALOGW("PreProcessingFx_Process() ERROR bad pointer");
 return -EINVAL;
 }

    session->processedMsk |= (1<<effect->procId);


 if ((session->processedMsk & session->enabledMsk) == session->enabledMsk) {
        effect->session->processedMsk = 0;
 size_t framesRq = outBuffer->frameCount;
 size_t framesWr = 0;
 if (session->framesOut) {
 size_t fr = session->framesOut;
 if (outBuffer->frameCount < fr) {
                fr = outBuffer->frameCount;
 }
            memcpy(outBuffer->s16,
                  session->outBuf,
                  fr * session->outChannelCount * sizeof(int16_t));
            memcpy(session->outBuf,
                  session->outBuf + fr * session->outChannelCount,
 (session->framesOut - fr) * session->outChannelCount * sizeof(int16_t));
            session->framesOut -= fr;
            framesWr += fr;
 }
        outBuffer->frameCount = framesWr;
 if (framesWr == framesRq) {
            inBuffer->frameCount = 0;
 return 0;
 }

 if (session->inResampler != NULL) {
 size_t fr = session->frameCount - session->framesIn;
 if (inBuffer->frameCount < fr) {
                fr = inBuffer->frameCount;
 }
 if (session->inBufSize < session->framesIn + fr) {
                session->inBufSize = session->framesIn + fr;
                session->inBuf = (int16_t *)realloc(session->inBuf,
                                 session->inBufSize * session->inChannelCount * sizeof(int16_t));
 }
            memcpy(session->inBuf + session->framesIn * session->inChannelCount,
                   inBuffer->s16,
                   fr * session->inChannelCount * sizeof(int16_t));
#ifdef DUAL_MIC_TEST
            pthread_mutex_lock(&gPcmDumpLock);
 if (gPcmDumpFh != NULL) {
                fwrite(inBuffer->raw,
                       fr * session->inChannelCount * sizeof(int16_t), 1, gPcmDumpFh);
 }
            pthread_mutex_unlock(&gPcmDumpLock);
#endif

            session->framesIn += fr;
            inBuffer->frameCount = fr;
 if (session->framesIn < session->frameCount) {
 return 0;
 }
 spx_uint32_t frIn = session->framesIn;
 spx_uint32_t frOut = session->apmFrameCount;
 if (session->inChannelCount == 1) {
                speex_resampler_process_int(session->inResampler,
 0,
                                            session->inBuf,
 &frIn,
                                            session->procFrame->_payloadData,
 &frOut);
 } else {
                speex_resampler_process_interleaved_int(session->inResampler,
                                                        session->inBuf,
 &frIn,
                                                        session->procFrame->_payloadData,
 &frOut);
 }
            memcpy(session->inBuf,
                   session->inBuf + frIn * session->inChannelCount,
 (session->framesIn - frIn) * session->inChannelCount * sizeof(int16_t));
            session->framesIn -= frIn;
 } else {
 size_t fr = session->frameCount - session->framesIn;
 if (inBuffer->frameCount < fr) {
                fr = inBuffer->frameCount;
 }
            memcpy(session->procFrame->_payloadData + session->framesIn * session->inChannelCount,
                   inBuffer->s16,
                   fr * session->inChannelCount * sizeof(int16_t));

#ifdef DUAL_MIC_TEST
            pthread_mutex_lock(&gPcmDumpLock);
 if (gPcmDumpFh != NULL) {
                fwrite(inBuffer->raw,
                       fr * session->inChannelCount * sizeof(int16_t), 1, gPcmDumpFh);
 }
            pthread_mutex_unlock(&gPcmDumpLock);
#endif

            session->framesIn += fr;
            inBuffer->frameCount = fr;
 if (session->framesIn < session->frameCount) {
 return 0;
 }
            session->framesIn = 0;
 }
        session->procFrame->_payloadDataLengthInSamples =
                session->apmFrameCount * session->inChannelCount;

        effect->session->apm->ProcessStream(session->procFrame);

 if (session->outBufSize < session->framesOut + session->frameCount) {
            session->outBufSize = session->framesOut + session->frameCount;
            session->outBuf = (int16_t *)realloc(session->outBuf,
                              session->outBufSize * session->outChannelCount * sizeof(int16_t));
 }

 if (session->outResampler != NULL) {
 spx_uint32_t frIn = session->apmFrameCount;
 spx_uint32_t frOut = session->frameCount;
 if (session->inChannelCount == 1) {
                speex_resampler_process_int(session->outResampler,
 0,
                                    session->procFrame->_payloadData,
 &frIn,
                                    session->outBuf + session->framesOut * session->outChannelCount,
 &frOut);
 } else {
                speex_resampler_process_interleaved_int(session->outResampler,
                                    session->procFrame->_payloadData,
 &frIn,
                                    session->outBuf + session->framesOut * session->outChannelCount,
 &frOut);
 }
            session->framesOut += frOut;
 } else {
            memcpy(session->outBuf + session->framesOut * session->outChannelCount,
                   session->procFrame->_payloadData,
                   session->frameCount * session->outChannelCount * sizeof(int16_t));
            session->framesOut += session->frameCount;
 }
 size_t fr = session->framesOut;
 if (framesRq - framesWr < fr) {
            fr = framesRq - framesWr;
 }
        memcpy(outBuffer->s16 + framesWr * session->outChannelCount,
              session->outBuf,
              fr * session->outChannelCount * sizeof(int16_t));
        memcpy(session->outBuf,
              session->outBuf + fr * session->outChannelCount,
 (session->framesOut - fr) * session->outChannelCount * sizeof(int16_t));
        session->framesOut -= fr;
        outBuffer->frameCount += fr;

 return 0;
 } else {
 return -ENODATA;
 }
}

int32_t ReverbGetDecayHfRatio(ReverbContext *pContext){

    LVREV_ControlParams_st    ActiveParams; /* Current control Parameters */
    LVREV_ReturnStatus_en     LvmStatus=LVREV_SUCCESS; /* Function call status */

 /* Get the current settings */
 LvmStatus = LVREV_GetControlParameters(pContext->hInstance, &ActiveParams);
    LVM_ERROR_CHECK(LvmStatus, "LVREV_GetControlParameters", "ReverbGetDecayHfRatio")

 if(ActiveParams.Damping != (LVM_INT16)(pContext->SavedDecayHfRatio / 20)){
        ALOGV("\tLVM_ERROR : ReverbGetDecayHfRatio() has wrong level -> %d %d\n",
 ActiveParams.Damping, pContext->SavedDecayHfRatio);
 }

 return pContext->SavedDecayHfRatio;
}

void ReverbSetDecayTime(ReverbContext *pContext, uint32_t time){

    LVREV_ControlParams_st    ActiveParams; /* Current control Parameters */
    LVREV_ReturnStatus_en     LvmStatus=LVREV_SUCCESS; /* Function call status */

 /* Get the current settings */
 LvmStatus = LVREV_GetControlParameters(pContext->hInstance, &ActiveParams);
    LVM_ERROR_CHECK(LvmStatus, "LVREV_GetControlParameters", "ReverbSetDecayTime")

 if (time <= LVREV_MAX_T60) {
 ActiveParams.T60 = (LVM_UINT16)time;
 }
 else {
 ActiveParams.T60 = LVREV_MAX_T60;
 }

 /* Activate the initial settings */
 LvmStatus = LVREV_SetControlParameters(pContext->hInstance, &ActiveParams);
    LVM_ERROR_CHECK(LvmStatus, "LVREV_SetControlParameters", "ReverbSetDecayTime")

    pContext->SamplesToExitCount = (ActiveParams.T60 * pContext->config.inputCfg.samplingRate)/1000;
    pContext->SavedDecayTime = (int16_t)time;
 return;
}

int PreProcessingFx_ProcessReverse(effect_handle_t     self,
audio_buffer_t    *inBuffer,
                                   audio_buffer_t    *outBuffer)
{
preproc_effect_t * effect = (preproc_effect_t *)self;
int    status = 0;

if (effect == NULL){
ALOGW("PreProcessingFx_ProcessReverse() ERROR effect == NULL");
return -EINVAL;
}
preproc_session_t * session = (preproc_session_t *)effect->session;

if (inBuffer == NULL  || inBuffer->raw == NULL){
ALOGW("PreProcessingFx_ProcessReverse() ERROR bad pointer");
return -EINVAL;
}

session->revProcessedMsk |= (1<<effect->procId);

//    ALOGV("PreProcessingFx_ProcessReverse In %d frames revEnabledMsk %08x revProcessedMsk %08x",
//         inBuffer->frameCount, session->revEnabledMsk, session->revProcessedMsk);


if ((session->revProcessedMsk & session->revEnabledMsk) == session->revEnabledMsk) {
effect->session->revProcessedMsk = 0;
if (session->revResampler != NULL) {
size_t fr = session->frameCount - session->framesRev;
if (inBuffer->frameCount < fr) {
fr = inBuffer->frameCount;
}
if (session->revBufSize < session->framesRev + fr) {
session->revBufSize = session->framesRev + fr;
session->revBuf = (int16_t *)realloc(session->revBuf,
session->revBufSize * session->inChannelCount * sizeof(int16_t));
}
memcpy(session->revBuf + session->framesRev * session->inChannelCount,
inBuffer->s16,
fr * session->inChannelCount * sizeof(int16_t));

session->framesRev += fr;
inBuffer->frameCount = fr;
if (session->framesRev < session->frameCount) {
return 0;
}
spx_uint32_t frIn = session->framesRev;
spx_uint32_t frOut = session->apmFrameCount;
if (session->inChannelCount == 1) {
speex_resampler_process_int(session->revResampler,
0,
session->revBuf,
&frIn,
session->revFrame->_payloadData,
&frOut);
} else {
speex_resampler_process_interleaved_int(session->revResampler,
session->revBuf,
&frIn,
session->revFrame->_payloadData,
&frOut);
}
memcpy(session->revBuf,
session->revBuf + frIn * session->inChannelCount,
(session->framesRev - frIn) * session->inChannelCount * sizeof(int16_t));
session->framesRev -= frIn;
} else {
size_t fr = session->frameCount - session->framesRev;
if (inBuffer->frameCount < fr) {
fr = inBuffer->frameCount;
}
memcpy(session->revFrame->_payloadData + session->framesRev * session->inChannelCount,
inBuffer->s16,
fr * session->inChannelCount * sizeof(int16_t));
session->framesRev += fr;
inBuffer->frameCount = fr;
if (session->framesRev < session->frameCount) {
return 0;
}
session->framesRev = 0;
}
session->revFrame->_payloadDataLengthInSamples =
session->apmFrameCount * session->inChannelCount;
effect->session->apm->AnalyzeReverseStream(session->revFrame);
return 0;
} else {
return -ENODATA;
}
}

void LE_reset(LoudnessEnhancerContext *pContext)
{
    ALOGV("  > LE_reset(%p)", pContext);

 if (pContext->mCompressor != NULL) {
 float targetAmp = pow(10, pContext->mTargetGainmB/2000.0f); // mB to linear amplification
        ALOGV("LE_reset(): Target gain=%dmB <=> factor=%.2fX", pContext->mTargetGainmB, targetAmp);
        pContext->mCompressor->Initialize(targetAmp, pContext->mConfig.inputCfg.samplingRate);
 } else {
        ALOGE("LE_reset(%p): null compressors, can't apply target gain", pContext);
 }
}

int32_t ReverbGetDiffusion(ReverbContext *pContext){

    LVREV_ControlParams_st    ActiveParams; /* Current control Parameters */
    LVREV_ReturnStatus_en     LvmStatus=LVREV_SUCCESS; /* Function call status */
    LVM_INT16                 Temp;

 /* Get the current settings */
 LvmStatus = LVREV_GetControlParameters(pContext->hInstance, &ActiveParams);
    LVM_ERROR_CHECK(LvmStatus, "LVREV_GetControlParameters", "ReverbGetDiffusion")

 Temp = (LVM_INT16)(pContext->SavedDiffusion/10);

 if(ActiveParams.Density != Temp){
        ALOGV("\tLVM_ERROR : ReverbGetDiffusion invalid value %d %d", Temp, ActiveParams.Density);
 }

 return pContext->SavedDiffusion;
}

void ReverbSetDiffusion(ReverbContext *pContext, int16_t level){

    LVREV_ControlParams_st    ActiveParams; /* Current control Parameters */
    LVREV_ReturnStatus_en     LvmStatus=LVREV_SUCCESS; /* Function call status */

 /* Get the current settings */
 LvmStatus = LVREV_GetControlParameters(pContext->hInstance, &ActiveParams);
    LVM_ERROR_CHECK(LvmStatus, "LVREV_GetControlParameters", "ReverbSetDiffusion")

 ActiveParams.Density = (LVM_INT16)(level/10);

 /* Activate the initial settings */
 LvmStatus = LVREV_SetControlParameters(pContext->hInstance, &ActiveParams);
    LVM_ERROR_CHECK(LvmStatus, "LVREV_SetControlParameters", "ReverbSetDiffusion")

    pContext->SavedDiffusion = level;
 return;
}

int LELib_Release(effect_handle_t handle) {
 LoudnessEnhancerContext * pContext = (LoudnessEnhancerContext *)handle;

    ALOGV("LELib_Release %p", handle);
 if (pContext == NULL) {
 return -EINVAL;
 }
    pContext->mState = LOUDNESS_ENHANCER_STATE_UNINITIALIZED;
 if (pContext->mCompressor != NULL) {
 delete pContext->mCompressor;
        pContext->mCompressor = NULL;
 }
 delete pContext;

 return 0;
}

bool HasReverseStream(uint32_t procId)
{
 if (procId == PREPROC_AEC) {
 return true;
 }
 return false;
}

int PreProcessingLib_Release(effect_handle_t interface)
{
 int status;
    ALOGV("EffectRelease start %p", interface);
 if (PreProc_Init() != 0) {
 return sInitStatus;
 }

 preproc_effect_t *fx = (preproc_effect_t *)interface;

 if (fx->session->io == 0) {
 return -EINVAL;
 }
 return Session_ReleaseEffect(fx->session, fx);
}

void AgcDisable(preproc_effect_t *effect)
{
    ALOGV("AgcDisable");
    webrtc::GainControl *agc = static_cast<webrtc::GainControl *>(effect->engine);
    agc->Enable(false);
}

uint32_t VirtualizerGetStrength(EffectContext *pContext){

 LVM_ControlParams_t ActiveParams; /* Current control Parameters */
    LVM_ReturnStatus_en     LvmStatus = LVM_SUCCESS; /* Function call status */

 LvmStatus = LVM_GetControlParameters(pContext->pBundledContext->hInstance, &ActiveParams);

    LVM_ERROR_CHECK(LvmStatus, "LVM_GetControlParameters", "VirtualizerGetStrength")
 if(LvmStatus != LVM_SUCCESS) return -EINVAL;

 return pContext->pBundledContext->VirtStrengthSaved;
} /* end getStrength */

int Equalizer_getParameter(EffectContext *pContext,
 void *pParam,
 uint32_t *pValueSize,
 void *pValue){
 int status = 0;
 int bMute = 0;
 int32_t *pParamTemp = (int32_t *)pParam;
 int32_t param = *pParamTemp++;
 int32_t param2;
 char *name;


 switch (param) {
 case EQ_PARAM_NUM_BANDS:
 case EQ_PARAM_CUR_PRESET:
 case EQ_PARAM_GET_NUM_OF_PRESETS:
 case EQ_PARAM_BAND_LEVEL:
 case EQ_PARAM_GET_BAND:
 if (*pValueSize < sizeof(int16_t)) {
            ALOGV("\tLVM_ERROR : Equalizer_getParameter() invalid pValueSize 1  %d", *pValueSize);
 return -EINVAL;
 }
 *pValueSize = sizeof(int16_t);
 break;

 case EQ_PARAM_LEVEL_RANGE:
 if (*pValueSize < 2 * sizeof(int16_t)) {
            ALOGV("\tLVM_ERROR : Equalizer_getParameter() invalid pValueSize 2  %d", *pValueSize);
 return -EINVAL;
 }
 *pValueSize = 2 * sizeof(int16_t);
 break;
 case EQ_PARAM_BAND_FREQ_RANGE:
 if (*pValueSize < 2 * sizeof(int32_t)) {
            ALOGV("\tLVM_ERROR : Equalizer_getParameter() invalid pValueSize 3  %d", *pValueSize);
 return -EINVAL;
 }
 *pValueSize = 2 * sizeof(int32_t);
 break;

 case EQ_PARAM_CENTER_FREQ:
 if (*pValueSize < sizeof(int32_t)) {
            ALOGV("\tLVM_ERROR : Equalizer_getParameter() invalid pValueSize 5  %d", *pValueSize);
 return -EINVAL;
 }
 *pValueSize = sizeof(int32_t);
 break;

 case EQ_PARAM_GET_PRESET_NAME:
 break;

 case EQ_PARAM_PROPERTIES:
 if (*pValueSize < (2 + FIVEBAND_NUMBANDS) * sizeof(uint16_t)) {
            ALOGV("\tLVM_ERROR : Equalizer_getParameter() invalid pValueSize 1  %d", *pValueSize);
 return -EINVAL;
 }
 *pValueSize = (2 + FIVEBAND_NUMBANDS) * sizeof(uint16_t);
 break;

 default:
        ALOGV("\tLVM_ERROR : Equalizer_getParameter unknown param %d", param);
 return -EINVAL;
 }

 switch (param) {
 case EQ_PARAM_NUM_BANDS:
 *(uint16_t *)pValue = (uint16_t)FIVEBAND_NUMBANDS;
 break;

 case EQ_PARAM_LEVEL_RANGE:
 *(int16_t *)pValue = -1500;
 *((int16_t *)pValue + 1) = 1500;
 break;

 case EQ_PARAM_BAND_LEVEL:
        param2 = *pParamTemp;
 if (param2 >= FIVEBAND_NUMBANDS) {
            status = -EINVAL;
 break;
 }
 *(int16_t *)pValue = (int16_t)EqualizerGetBandLevel(pContext, param2);
 break;

 case EQ_PARAM_CENTER_FREQ:
        param2 = *pParamTemp;
 if (param2 >= FIVEBAND_NUMBANDS) {
            status = -EINVAL;
 break;
 }
 *(int32_t *)pValue = EqualizerGetCentreFrequency(pContext, param2);
 break;

 case EQ_PARAM_BAND_FREQ_RANGE:
        param2 = *pParamTemp;
 if (param2 >= FIVEBAND_NUMBANDS) {
            status = -EINVAL;
 break;
 }
 EqualizerGetBandFreqRange(pContext, param2, (uint32_t *)pValue, ((uint32_t *)pValue + 1));
 break;

 case EQ_PARAM_GET_BAND:
        param2 = *pParamTemp;
 *(uint16_t *)pValue = (uint16_t)EqualizerGetBand(pContext, param2);
 break;

 case EQ_PARAM_CUR_PRESET:
 *(uint16_t *)pValue = (uint16_t)EqualizerGetPreset(pContext);
 break;

 case EQ_PARAM_GET_NUM_OF_PRESETS:
 *(uint16_t *)pValue = (uint16_t)EqualizerGetNumPresets();
 break;

 case EQ_PARAM_GET_PRESET_NAME:
        param2 = *pParamTemp;
 if (param2 >= EqualizerGetNumPresets()) {
            status = -EINVAL;
 break;
 }
        name = (char *)pValue;
        strncpy(name, EqualizerGetPresetName(param2), *pValueSize - 1);
        name[*pValueSize - 1] = 0;
 *pValueSize = strlen(name) + 1;
 break;

 case EQ_PARAM_PROPERTIES: {
 int16_t *p = (int16_t *)pValue;
        ALOGV("\tEqualizer_getParameter() EQ_PARAM_PROPERTIES");
        p[0] = (int16_t)EqualizerGetPreset(pContext);
        p[1] = (int16_t)FIVEBAND_NUMBANDS;
 for (int i = 0; i < FIVEBAND_NUMBANDS; i++) {
            p[2 + i] = (int16_t)EqualizerGetBandLevel(pContext, i);
 }
 } break;

 default:
        ALOGV("\tLVM_ERROR : Equalizer_getParameter() invalid param %d", param);
        status = -EINVAL;
 break;
 }

 return status;
} /* end Equalizer_getParameter */

int Equalizer_setParameter (EffectContext *pContext, void *pParam, void *pValue){
 int status = 0;
 int32_t preset;
 int32_t band;
 int32_t level;
 int32_t *pParamTemp = (int32_t *)pParam;
 int32_t param = *pParamTemp++;


 switch (param) {
 case EQ_PARAM_CUR_PRESET:
        preset = (int32_t)(*(uint16_t *)pValue);

 if ((preset >= EqualizerGetNumPresets())||(preset < 0)) {
            status = -EINVAL;
 break;
 }
 EqualizerSetPreset(pContext, preset);
 break;
 case EQ_PARAM_BAND_LEVEL:
        band = *pParamTemp;
        level = (int32_t)(*(int16_t *)pValue);
 if (band >= FIVEBAND_NUMBANDS) {
            status = -EINVAL;
 break;
 }
 EqualizerSetBandLevel(pContext, band, level);
 break;
 case EQ_PARAM_PROPERTIES: {
 int16_t *p = (int16_t *)pValue;
 if ((int)p[0] >= EqualizerGetNumPresets()) {
            status = -EINVAL;
 break;
 }
 if (p[0] >= 0) {
 EqualizerSetPreset(pContext, (int)p[0]);
 } else {
 if ((int)p[1] != FIVEBAND_NUMBANDS) {
                status = -EINVAL;
 break;
 }
 for (int i = 0; i < FIVEBAND_NUMBANDS; i++) {
 EqualizerSetBandLevel(pContext, i, (int)p[2 + i]);
 }
 }
 } break;
 default:
        ALOGV("\tLVM_ERROR : Equalizer_setParameter() invalid param %d", param);
        status = -EINVAL;
 break;
 }

 return status;
} /* end Equalizer_setParameter */


int Volume_getParameter(EffectContext *pContext,
 void *pParam,
 uint32_t *pValueSize,
 void *pValue){
 int status = 0;
 int bMute = 0;
 int32_t *pParamTemp = (int32_t *)pParam;
 int32_t param = *pParamTemp++;;
 char *name;


 switch (param){
 case VOLUME_PARAM_LEVEL:
 case VOLUME_PARAM_MAXLEVEL:
 case VOLUME_PARAM_STEREOPOSITION:
 if (*pValueSize != sizeof(int16_t)){
                ALOGV("\tLVM_ERROR : Volume_getParameter() invalid pValueSize 1  %d", *pValueSize);
 return -EINVAL;
 }
 *pValueSize = sizeof(int16_t);
 break;

 case VOLUME_PARAM_MUTE:
 case VOLUME_PARAM_ENABLESTEREOPOSITION:
 if (*pValueSize < sizeof(int32_t)){
                ALOGV("\tLVM_ERROR : Volume_getParameter() invalid pValueSize 2  %d", *pValueSize);
 return -EINVAL;
 }
 *pValueSize = sizeof(int32_t);
 break;

 default:
            ALOGV("\tLVM_ERROR : Volume_getParameter unknown param %d", param);
 return -EINVAL;
 }

 switch (param){
 case VOLUME_PARAM_LEVEL:
            status = VolumeGetVolumeLevel(pContext, (int16_t *)(pValue));
 break;

 case VOLUME_PARAM_MAXLEVEL:
 *(int16_t *)pValue = 0;
 break;

 case VOLUME_PARAM_STEREOPOSITION:
 VolumeGetStereoPosition(pContext, (int16_t *)pValue);
 break;

 case VOLUME_PARAM_MUTE:
            status = VolumeGetMute(pContext, (uint32_t *)pValue);
            ALOGV("\tVolume_getParameter() VOLUME_PARAM_MUTE Value is %d",
 *(uint32_t *)pValue);
 break;

 case VOLUME_PARAM_ENABLESTEREOPOSITION:
 *(int32_t *)pValue = pContext->pBundledContext->bStereoPositionEnabled;
 break;

 default:
            ALOGV("\tLVM_ERROR : Volume_getParameter() invalid param %d", param);
            status = -EINVAL;
 break;
 }

 return status;
} /* end Volume_getParameter */



int Volume_setParameter (EffectContext *pContext, void *pParam, void *pValue){
 int      status = 0;
 int16_t  level;
 int16_t  position;
 uint32_t mute;
 uint32_t positionEnabled;
 int32_t *pParamTemp = (int32_t *)pParam;
 int32_t param = *pParamTemp++;


 switch (param){
 case VOLUME_PARAM_LEVEL:
            level = *(int16_t *)pValue;
            status = VolumeSetVolumeLevel(pContext, (int16_t)level);
 break;

 case VOLUME_PARAM_MUTE:
            mute = *(uint32_t *)pValue;
            status = VolumeSetMute(pContext, mute);
 break;

 case VOLUME_PARAM_ENABLESTEREOPOSITION:
            positionEnabled = *(uint32_t *)pValue;
            status = VolumeEnableStereoPosition(pContext, positionEnabled);
            status = VolumeSetStereoPosition(pContext, pContext->pBundledContext->positionSaved);
 break;

 case VOLUME_PARAM_STEREOPOSITION:
            position = *(int16_t *)pValue;
            status = VolumeSetStereoPosition(pContext, (int16_t)position);
 break;

 default:
            ALOGV("\tLVM_ERROR : Volume_setParameter() invalid param %d", param);
 break;
 }

 return status;
} /* end Volume_setParameter */

/****************************************************************************************
 * Name : LVC_ToDB_s32Tos16()
 *  Input       : Signed 32-bit integer
 *  Output      : Signed 16-bit integer
 *                  MSB (16) = sign bit
 *                  (15->05) = integer part
 *                  (04->01) = decimal part
 *  Returns     : Db value with respect to full scale
 *  Description :
 *  Remarks     :
 ****************************************************************************************/

LVM_INT16 LVC_ToDB_s32Tos16(LVM_INT32 Lin_fix)
{
    LVM_INT16   db_fix;
    LVM_INT16   Shift;
    LVM_INT16   SmallRemainder;
    LVM_UINT32  Remainder = (LVM_UINT32)Lin_fix;

 /* Count leading bits, 1 cycle in assembly*/
 for (Shift = 0; Shift<32; Shift++)
 {
 if ((Remainder & 0x80000000U)!=0)
 {
 break;
 }
 Remainder = Remainder << 1;
 }

 /*
     * Based on the approximation equation (for Q11.4 format):
     *
     * dB = -96 * Shift + 16 * (8 * Remainder - 2 * Remainder^2)
     */
    db_fix    = (LVM_INT16)(-96 * Shift); /* Six dB steps in Q11.4 format*/
 SmallRemainder = (LVM_INT16)((Remainder & 0x7fffffff) >> 24);
    db_fix = (LVM_INT16)(db_fix + SmallRemainder );
 SmallRemainder = (LVM_INT16)(SmallRemainder * SmallRemainder);
    db_fix = (LVM_INT16)(db_fix - (LVM_INT16)((LVM_UINT16)SmallRemainder >> 9));

 /* Correct for small offset */
    db_fix = (LVM_INT16)(db_fix - 5);

 return db_fix;
}


int Effect_setEnabled(EffectContext *pContext, bool enabled)
{
    ALOGV("\tEffect_setEnabled() type %d, enabled %d", pContext->EffectType, enabled);

 if (enabled) {
 bool tempDisabled = false;
 switch (pContext->EffectType) {
 case LVM_BASS_BOOST:
 if (pContext->pBundledContext->bBassEnabled == LVM_TRUE) {
                     ALOGV("\tEffect_setEnabled() LVM_BASS_BOOST is already enabled");
 return -EINVAL;
 }
 if(pContext->pBundledContext->SamplesToExitCountBb <= 0){
                    pContext->pBundledContext->NumberEffectsEnabled++;
 }
                pContext->pBundledContext->SamplesToExitCountBb =
 (LVM_INT32)(pContext->pBundledContext->SamplesPerSecond*0.1);
                pContext->pBundledContext->bBassEnabled = LVM_TRUE;
                tempDisabled = pContext->pBundledContext->bBassTempDisabled;
 break;
 case LVM_EQUALIZER:
 if (pContext->pBundledContext->bEqualizerEnabled == LVM_TRUE) {
                    ALOGV("\tEffect_setEnabled() LVM_EQUALIZER is already enabled");
 return -EINVAL;
 }
 if(pContext->pBundledContext->SamplesToExitCountEq <= 0){
                    pContext->pBundledContext->NumberEffectsEnabled++;
 }
                pContext->pBundledContext->SamplesToExitCountEq =
 (LVM_INT32)(pContext->pBundledContext->SamplesPerSecond*0.1);
                pContext->pBundledContext->bEqualizerEnabled = LVM_TRUE;
 break;
 case LVM_VIRTUALIZER:
 if (pContext->pBundledContext->bVirtualizerEnabled == LVM_TRUE) {
                    ALOGV("\tEffect_setEnabled() LVM_VIRTUALIZER is already enabled");
 return -EINVAL;
 }
 if(pContext->pBundledContext->SamplesToExitCountVirt <= 0){
                    pContext->pBundledContext->NumberEffectsEnabled++;
 }
                pContext->pBundledContext->SamplesToExitCountVirt =
 (LVM_INT32)(pContext->pBundledContext->SamplesPerSecond*0.1);
                pContext->pBundledContext->bVirtualizerEnabled = LVM_TRUE;
                tempDisabled = pContext->pBundledContext->bVirtualizerTempDisabled;
 break;
 case LVM_VOLUME:
 if (pContext->pBundledContext->bVolumeEnabled == LVM_TRUE) {
                    ALOGV("\tEffect_setEnabled() LVM_VOLUME is already enabled");
 return -EINVAL;
 }
                pContext->pBundledContext->NumberEffectsEnabled++;
                pContext->pBundledContext->bVolumeEnabled = LVM_TRUE;
 break;
 default:
                ALOGV("\tEffect_setEnabled() invalid effect type");
 return -EINVAL;
 }
 if (!tempDisabled) {
 LvmEffect_enable(pContext);
 }
 } else {
 switch (pContext->EffectType) {
 case LVM_BASS_BOOST:
 if (pContext->pBundledContext->bBassEnabled == LVM_FALSE) {
                    ALOGV("\tEffect_setEnabled() LVM_BASS_BOOST is already disabled");
 return -EINVAL;
 }
                pContext->pBundledContext->bBassEnabled = LVM_FALSE;
 break;
 case LVM_EQUALIZER:
 if (pContext->pBundledContext->bEqualizerEnabled == LVM_FALSE) {
                    ALOGV("\tEffect_setEnabled() LVM_EQUALIZER is already disabled");
 return -EINVAL;
 }
                pContext->pBundledContext->bEqualizerEnabled = LVM_FALSE;
 break;
 case LVM_VIRTUALIZER:
 if (pContext->pBundledContext->bVirtualizerEnabled == LVM_FALSE) {
                    ALOGV("\tEffect_setEnabled() LVM_VIRTUALIZER is already disabled");
 return -EINVAL;
 }
                pContext->pBundledContext->bVirtualizerEnabled = LVM_FALSE;
 break;
 case LVM_VOLUME:
 if (pContext->pBundledContext->bVolumeEnabled == LVM_FALSE) {
                    ALOGV("\tEffect_setEnabled() LVM_VOLUME is already disabled");
 return -EINVAL;
 }
                pContext->pBundledContext->bVolumeEnabled = LVM_FALSE;
 break;
 default:
                ALOGV("\tEffect_setEnabled() invalid effect type");
 return -EINVAL;
 }
 LvmEffect_disable(pContext);
 }

 return 0;
}


int16_t LVC_Convert_VolToDb(uint32_t vol){
 int16_t  dB;

    dB = LVC_ToDB_s32Tos16(vol <<7);
    dB = (dB +8)>>4;
    dB = (dB <-96) ? -96 : dB ;

 return dB;
}

} // namespace

int Session_ReleaseEffect(preproc_session_t *session,
 preproc_effect_t *fx)
{
    ALOGW_IF(Effect_Release(fx) != 0, " Effect_Release() failed for proc ID %d", fx->procId);
    session->createdMsk &= ~(1<<fx->procId);
 if (session->createdMsk == 0) {
        webrtc::AudioProcessing::Destroy(session->apm);
        session->apm = NULL;
 delete session->procFrame;
        session->procFrame = NULL;
 delete session->revFrame;
        session->revFrame = NULL;
 if (session->inResampler != NULL) {
            speex_resampler_destroy(session->inResampler);
            session->inResampler = NULL;
 }
 if (session->outResampler != NULL) {
            speex_resampler_destroy(session->outResampler);
            session->outResampler = NULL;
 }
 if (session->revResampler != NULL) {
            speex_resampler_destroy(session->revResampler);
            session->revResampler = NULL;
 }
 delete session->inBuf;
        session->inBuf = NULL;
 delete session->outBuf;
        session->outBuf = NULL;
 delete session->revBuf;
        session->revBuf = NULL;

        session->io = 0;
 }

 return 0;
}

int32_t EqualizerGetPreset(EffectContext *pContext){
 return pContext->pBundledContext->CurPreset;
}

void EqualizerSetPreset(EffectContext *pContext, int preset){

    pContext->pBundledContext->CurPreset = preset;

 for (int i=0; i<FIVEBAND_NUMBANDS; i++)
 {
        pContext->pBundledContext->bandGaindB[i] =
                EQNB_5BandSoftPresets[i + preset * FIVEBAND_NUMBANDS];
 }

 EqualizerUpdateActiveParams(pContext);
 LvmEffect_limitLevel(pContext);

 return;
}

int Equalizer_setParameter (EffectContext *pContext, void *pParam, void *pValue){
 int status = 0;
 int32_t preset;
 int32_t band;
 int32_t level;
 int32_t *pParamTemp = (int32_t *)pParam;
 int32_t param = *pParamTemp++;


 switch (param) {
 case EQ_PARAM_CUR_PRESET:
        preset = (int32_t)(*(uint16_t *)pValue);

 if ((preset >= EqualizerGetNumPresets())||(preset < 0)) {
            status = -EINVAL;
 break;
 }
 EqualizerSetPreset(pContext, preset);
 break;
 case EQ_PARAM_BAND_LEVEL:
        band = *pParamTemp;
        level = (int32_t)(*(int16_t *)pValue);
 if (band >= FIVEBAND_NUMBANDS) {
            status = -EINVAL;
 break;
 }
 EqualizerSetBandLevel(pContext, band, level);
 break;
 case EQ_PARAM_PROPERTIES: {
 int16_t *p = (int16_t *)pValue;
 if ((int)p[0] >= EqualizerGetNumPresets()) {
            status = -EINVAL;
 break;
 }
 if (p[0] >= 0) {
 EqualizerSetPreset(pContext, (int)p[0]);
 } else {
 if ((int)p[1] != FIVEBAND_NUMBANDS) {
                status = -EINVAL;
 break;
 }
 for (int i = 0; i < FIVEBAND_NUMBANDS; i++) {
 EqualizerSetBandLevel(pContext, i, (int)p[2 + i]);
 }
 }
 } break;
 default:
        ALOGV("\tLVM_ERROR : Equalizer_setParameter() invalid param %d", param);
        status = -EINVAL;
 break;
 }

 return status;
} /* end Equalizer_setParameter */

int16_t ReverbConvertHfLevel(int16_t Hflevel){
 int16_t i;

 static LPFPair_t LPFArray[97] =
 { // Limit range to 50 for LVREV parameter range
 {-10000, 50}, { -5000, 50 }, { -4000, 50}, { -3000, 158}, { -2000, 502},
 {-1000, 1666},{ -900, 1897}, { -800, 2169}, { -700, 2496}, { -600, 2895},
 {-500, 3400}, { -400, 4066}, { -300, 5011}, { -200, 6537}, { -100, 9826},
 {-99, 9881 }, { -98, 9937 }, { -97, 9994 }, { -96, 10052}, { -95, 10111},
 {-94, 10171}, { -93, 10231}, { -92, 10293}, { -91, 10356}, { -90, 10419},
 {-89, 10484}, { -88, 10549}, { -87, 10616}, { -86, 10684}, { -85, 10753},
 {-84, 10823}, { -83, 10895}, { -82, 10968}, { -81, 11042}, { -80, 11117},
 {-79, 11194}, { -78, 11272}, { -77, 11352}, { -76, 11433}, { -75, 11516},
 {-74, 11600}, { -73, 11686}, { -72, 11774}, { -71, 11864}, { -70, 11955},
 {-69, 12049}, { -68, 12144}, { -67, 12242}, { -66, 12341}, { -65, 12443},
 {-64, 12548}, { -63, 12654}, { -62, 12763}, { -61, 12875}, { -60, 12990},
 {-59, 13107}, { -58, 13227}, { -57, 13351}, { -56, 13477}, { -55, 13607},
 {-54, 13741}, { -53, 13878}, { -52, 14019}, { -51, 14164}, { -50, 14313},
 {-49, 14467}, { -48, 14626}, { -47, 14789}, { -46, 14958}, { -45, 15132},
 {-44, 15312}, { -43, 15498}, { -42, 15691}, { -41, 15890}, { -40, 16097},
 {-39, 16311}, { -38, 16534}, { -37, 16766}, { -36, 17007}, { -35, 17259},
 {-34, 17521}, { -33, 17795}, { -32, 18081}, { -31, 18381}, { -30, 18696},
 {-29, 19027}, { -28, 19375}, { -27, 19742}, { -26, 20129}, { -25, 20540},
 {-24, 20976}, { -23, 21439}, { -22, 21934}, { -21, 22463}, { -20, 23031},
 {-19, 23643}, { -18, 23999}
 };

 for(i = 0; i < 96; i++)
 {
 if(Hflevel <= LPFArray[i].Room_HF)
 break;
 }
 return LPFArray[i].LPF;
}

int LvmEffect_enable(EffectContext *pContext){

 LVM_ControlParams_t ActiveParams; /* Current control Parameters */
    LVM_ReturnStatus_en     LvmStatus = LVM_SUCCESS; /* Function call status */

 /* Get the current settings */
 LvmStatus = LVM_GetControlParameters(pContext->pBundledContext->hInstance,
 &ActiveParams);

    LVM_ERROR_CHECK(LvmStatus, "LVM_GetControlParameters", "LvmEffect_enable")
 if(LvmStatus != LVM_SUCCESS) return -EINVAL;

 if(pContext->EffectType == LVM_BASS_BOOST) {
        ALOGV("\tLvmEffect_enable : Enabling LVM_BASS_BOOST");
 ActiveParams.BE_OperatingMode       = LVM_BE_ON;
 }
 if(pContext->EffectType == LVM_VIRTUALIZER) {
        ALOGV("\tLvmEffect_enable : Enabling LVM_VIRTUALIZER");
 ActiveParams.VirtualizerOperatingMode = LVM_MODE_ON;
 }
 if(pContext->EffectType == LVM_EQUALIZER) {
        ALOGV("\tLvmEffect_enable : Enabling LVM_EQUALIZER");
 ActiveParams.EQNB_OperatingMode     = LVM_EQNB_ON;
 }
 if(pContext->EffectType == LVM_VOLUME) {
        ALOGV("\tLvmEffect_enable : Enabling LVM_VOLUME");
 }

 LvmStatus = LVM_SetControlParameters(pContext->pBundledContext->hInstance, &ActiveParams);
    LVM_ERROR_CHECK(LvmStatus, "LVM_SetControlParameters", "LvmEffect_enable")
 if(LvmStatus != LVM_SUCCESS) return -EINVAL;

 LvmEffect_limitLevel(pContext);
 return 0;
}

int VirtualizerIsDeviceSupported(audio_devices_t deviceType) {
 switch (deviceType) {
 case AUDIO_DEVICE_OUT_WIRED_HEADSET:
 case AUDIO_DEVICE_OUT_WIRED_HEADPHONE:
 case AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES:
 return 0;
 default :
 return -EINVAL;
 }
}

static inline int16_t clamp16(int32_t sample)
{
 if ((sample>>15) ^ (sample>>31))
        sample = 0x7FFF ^ (sample>>31);
 return sample;
}

int16_t ReverbGetReverbLevel(ReverbContext *pContext){
 int16_t level;

    LVREV_ControlParams_st    ActiveParams; /* Current control Parameters */
    LVREV_ReturnStatus_en     LvmStatus=LVREV_SUCCESS; /* Function call status */
    LVM_INT32                 CombinedLevel; // Sum of room and reverb level controls

 /* Get the current settings */
 LvmStatus = LVREV_GetControlParameters(pContext->hInstance, &ActiveParams);
    LVM_ERROR_CHECK(LvmStatus, "LVREV_GetControlParameters", "ReverbGetReverbLevel")

 CombinedLevel = (pContext->SavedReverbLevel + pContext->SavedRoomLevel)-LVREV_MAX_REVERB_LEVEL;

    level = ReverbConvertLevel(CombinedLevel);


 if(ActiveParams.Level != level){
        ALOGV("\tLVM_ERROR : (ignore at start up) ReverbGetReverbLevel() has wrong level -> %d %d\n",
 ActiveParams.Level, level);
 }


 return pContext->SavedReverbLevel;
}

int Virtualizer_setParameter (EffectContext *pContext, void *pParam, void *pValue){
 int status = 0;
 int16_t strength;
 int32_t *pParamTemp = (int32_t *)pParam;
 int32_t param = *pParamTemp++;


 switch (param){
 case VIRTUALIZER_PARAM_STRENGTH:
            strength = *(int16_t *)pValue;
 VirtualizerSetStrength(pContext, (int32_t)strength);
 break;

 case VIRTUALIZER_PARAM_FORCE_VIRTUALIZATION_MODE: {
 const audio_devices_t deviceType = *(audio_devices_t *) pValue;
            status = VirtualizerForceVirtualizationMode(pContext, deviceType);
 }
 break;

 default:
            ALOGV("\tLVM_ERROR : Virtualizer_setParameter() invalid param %d", param);
 break;
 }

 return status;
} /* end Virtualizer_setParameter */

int Session_SetReverseConfig(preproc_session_t *session, effect_config_t *config)
{
 if (config->inputCfg.samplingRate != config->outputCfg.samplingRate ||
            config->inputCfg.format != config->outputCfg.format ||
            config->inputCfg.format != AUDIO_FORMAT_PCM_16_BIT) {
 return -EINVAL;
 }

    ALOGV("Session_SetReverseConfig sr %d cnl %08x",
         config->inputCfg.samplingRate, config->inputCfg.channels);

 if (session->state < PREPROC_SESSION_STATE_CONFIG) {
 return -ENOSYS;
 }
 if (config->inputCfg.samplingRate != session->samplingRate ||
            config->inputCfg.format != AUDIO_FORMAT_PCM_16_BIT) {
 return -EINVAL;
 }
 uint32_t inCnl = audio_channel_count_from_out_mask(config->inputCfg.channels);
 int status = session->apm->set_num_reverse_channels(inCnl);
 if (status < 0) {
 return -EINVAL;
 }
    session->revChannelCount = inCnl;
    session->revFrame->_audioChannel = inCnl;
    session->revFrame->_frequencyInHz = session->apmSamplingRate;
    session->revBufSize = 0;
    session->framesRev = 0;

 return 0;
}

int Visualizer_setConfig(VisualizerContext *pContext, effect_config_t *pConfig)
{
    ALOGV("Visualizer_setConfig start");

 if (pConfig->inputCfg.samplingRate != pConfig->outputCfg.samplingRate) return -EINVAL;
 if (pConfig->inputCfg.channels != pConfig->outputCfg.channels) return -EINVAL;
 if (pConfig->inputCfg.format != pConfig->outputCfg.format) return -EINVAL;
 if (pConfig->inputCfg.channels != AUDIO_CHANNEL_OUT_STEREO) return -EINVAL;
 if (pConfig->outputCfg.accessMode != EFFECT_BUFFER_ACCESS_WRITE &&
            pConfig->outputCfg.accessMode != EFFECT_BUFFER_ACCESS_ACCUMULATE) return -EINVAL;
 if (pConfig->inputCfg.format != AUDIO_FORMAT_PCM_16_BIT) return -EINVAL;

    pContext->mConfig = *pConfig;

 Visualizer_reset(pContext);

 return 0;
}

extern "C" int EffectCreate(const effect_uuid_t *uuid,
                            int32_t             sessionId,
                            int32_t             ioId,
effect_handle_t  *pHandle){
int ret;
int i;
int length = sizeof(gDescriptors) / sizeof(const effect_descriptor_t *);
const effect_descriptor_t *desc;

ALOGV("\t\nEffectCreate start");

if (pHandle == NULL || uuid == NULL){
ALOGV("\tLVM_ERROR : EffectCreate() called with NULL pointer");
return -EINVAL;
}

for (i = 0; i < length; i++) {
desc = gDescriptors[i];
if (memcmp(uuid, &desc->uuid, sizeof(effect_uuid_t))
== 0) {
ALOGV("\tEffectCreate - UUID matched Reverb type %d, UUID = %x", i, desc->uuid.timeLow);
break;
}
}

if (i == length) {
return -ENOENT;
}

ReverbContext *pContext = new ReverbContext;

pContext->itfe      = &gReverbInterface;
pContext->hInstance = NULL;

pContext->auxiliary = false;
if ((desc->flags & EFFECT_FLAG_TYPE_MASK) == EFFECT_FLAG_TYPE_AUXILIARY){
pContext->auxiliary = true;
ALOGV("\tEffectCreate - AUX");
}else{
ALOGV("\tEffectCreate - INS");
}

pContext->preset = false;
if (memcmp(&desc->type, SL_IID_PRESETREVERB, sizeof(effect_uuid_t)) == 0) {
pContext->preset = true;
// force reloading preset at first call to process()
pContext->curPreset = REVERB_PRESET_LAST + 1;
pContext->nextPreset = REVERB_DEFAULT_PRESET;
ALOGV("\tEffectCreate - PRESET");
}else{
ALOGV("\tEffectCreate - ENVIRONMENTAL");
}

ALOGV("\tEffectCreate - Calling Reverb_init");
ret = Reverb_init(pContext);

if (ret < 0){
ALOGV("\tLVM_ERROR : EffectCreate() init failed");
delete pContext;
return ret;
}

*pHandle = (effect_handle_t)pContext;

#ifdef LVM_PCM
pContext->PcmInPtr = NULL;
pContext->PcmOutPtr = NULL;

pContext->PcmInPtr = fopen("/data/tmp/reverb_pcm_in.pcm", "w");
pContext->PcmOutPtr = fopen("/data/tmp/reverb_pcm_out.pcm", "w");

if((pContext->PcmInPtr == NULL)||
(pContext->PcmOutPtr == NULL)){
return -EINVAL;
}
#endif


// Allocate memory for reverb process (*2 is for STEREO)
pContext->InFrames32 = (LVM_INT32 *)malloc(LVREV_MAX_FRAME_SIZE * sizeof(LVM_INT32) * 2);
pContext->OutFrames32 = (LVM_INT32 *)malloc(LVREV_MAX_FRAME_SIZE * sizeof(LVM_INT32) * 2);

ALOGV("\tEffectCreate %p, size %zu", pContext, sizeof(ReverbContext));
ALOGV("\tEffectCreate end\n");
return 0;
} /* end EffectCreate */

extern "C" int Session_CreateEffect(preproc_session_t *session,
 int32_t procId,
 effect_handle_t *interface)
{
 int status = -ENOMEM;

    ALOGV("Session_CreateEffect procId %d, createdMsk %08x", procId, session->createdMsk);

 if (session->createdMsk == 0) {
        session->apm = webrtc::AudioProcessing::Create(session->io);
 if (session->apm == NULL) {
            ALOGW("Session_CreateEffect could not get apm engine");
 goto error;
 }
        session->apm->set_sample_rate_hz(kPreprocDefaultSr);
        session->apm->set_num_channels(kPreProcDefaultCnl, kPreProcDefaultCnl);
        session->apm->set_num_reverse_channels(kPreProcDefaultCnl);
        session->procFrame = new webrtc::AudioFrame();
 if (session->procFrame == NULL) {
            ALOGW("Session_CreateEffect could not allocate audio frame");
 goto error;
 }
        session->revFrame = new webrtc::AudioFrame();
 if (session->revFrame == NULL) {
            ALOGW("Session_CreateEffect could not allocate reverse audio frame");
 goto error;
 }
        session->apmSamplingRate = kPreprocDefaultSr;
        session->apmFrameCount = (kPreprocDefaultSr) / 100;
        session->frameCount = session->apmFrameCount;
        session->samplingRate = kPreprocDefaultSr;
        session->inChannelCount = kPreProcDefaultCnl;
        session->outChannelCount = kPreProcDefaultCnl;
        session->procFrame->_frequencyInHz = kPreprocDefaultSr;
        session->procFrame->_audioChannel = kPreProcDefaultCnl;
        session->revChannelCount = kPreProcDefaultCnl;
        session->revFrame->_frequencyInHz = kPreprocDefaultSr;
        session->revFrame->_audioChannel = kPreProcDefaultCnl;
        session->enabledMsk = 0;
        session->processedMsk = 0;
        session->revEnabledMsk = 0;
        session->revProcessedMsk = 0;
        session->inResampler = NULL;
        session->inBuf = NULL;
        session->inBufSize = 0;
        session->outResampler = NULL;
        session->outBuf = NULL;
        session->outBufSize = 0;
        session->revResampler = NULL;
        session->revBuf = NULL;
        session->revBufSize = 0;
 }
    status = Effect_Create(&session->effects[procId], session, interface);
 if (status < 0) {
 goto error;
 }
    ALOGV("Session_CreateEffect OK");
    session->createdMsk |= (1<<procId);
 return status;

error:
 if (session->createdMsk == 0) {
 delete session->revFrame;
        session->revFrame = NULL;
 delete session->procFrame;
        session->procFrame = NULL;
        webrtc::AudioProcessing::Destroy(session->apm);
        session->apm = NULL;
 }
 return status;
}

int32_t DownmixLib_Release(effect_handle_t handle) {
 downmix_module_t *pDwmModule = (downmix_module_t *)handle;

    ALOGV("DownmixLib_Release() %p", handle);
 if (handle == NULL) {
 return -EINVAL;
 }

    pDwmModule->context.state = DOWNMIX_STATE_UNINITIALIZED;

    free(pDwmModule);
 return 0;
}

int Session_SetConfig(preproc_session_t *session, effect_config_t *config)
{
 uint32_t sr;
 uint32_t inCnl = audio_channel_count_from_out_mask(config->inputCfg.channels);
 uint32_t outCnl = audio_channel_count_from_out_mask(config->outputCfg.channels);

 if (config->inputCfg.samplingRate != config->outputCfg.samplingRate ||
        config->inputCfg.format != config->outputCfg.format ||
        config->inputCfg.format != AUDIO_FORMAT_PCM_16_BIT) {
 return -EINVAL;
 }

    ALOGV("Session_SetConfig sr %d cnl %08x",
         config->inputCfg.samplingRate, config->inputCfg.channels);
 int status;

 if (session->enabledMsk) {
 if (session->samplingRate != config->inputCfg.samplingRate ||
                session->inChannelCount != inCnl ||
                session->outChannelCount != outCnl) {
 return -ENOSYS;
 } else {
 return 0;
 }
 }

 if (config->inputCfg.samplingRate >= 32000 && !(session->createdMsk & (1 << PREPROC_AEC))) {
        session->apmSamplingRate = 32000;
 } else
 if (config->inputCfg.samplingRate >= 16000) {
        session->apmSamplingRate = 16000;
 } else if (config->inputCfg.samplingRate >= 8000) {
        session->apmSamplingRate = 8000;
 }
    status = session->apm->set_sample_rate_hz(session->apmSamplingRate);
 if (status < 0) {
 return -EINVAL;
 }
    status = session->apm->set_num_channels(inCnl, outCnl);
 if (status < 0) {
 return -EINVAL;
 }
    status = session->apm->set_num_reverse_channels(inCnl);
 if (status < 0) {
 return -EINVAL;
 }

    session->samplingRate = config->inputCfg.samplingRate;
    session->apmFrameCount = session->apmSamplingRate / 100;
 if (session->samplingRate == session->apmSamplingRate) {
        session->frameCount = session->apmFrameCount;
 } else {
        session->frameCount = (session->apmFrameCount * session->samplingRate) /
                session->apmSamplingRate  + 1;
 }
    session->inChannelCount = inCnl;
    session->outChannelCount = outCnl;
    session->procFrame->_audioChannel = inCnl;
    session->procFrame->_frequencyInHz = session->apmSamplingRate;

    session->revChannelCount = inCnl;
    session->revFrame->_audioChannel = inCnl;
    session->revFrame->_frequencyInHz = session->apmSamplingRate;

    session->inBufSize = 0;
    session->outBufSize = 0;
    session->framesIn = 0;
    session->framesOut = 0;


 if (session->inResampler != NULL) {
        speex_resampler_destroy(session->inResampler);
        session->inResampler = NULL;
 }
 if (session->outResampler != NULL) {
        speex_resampler_destroy(session->outResampler);
        session->outResampler = NULL;
 }
 if (session->revResampler != NULL) {
        speex_resampler_destroy(session->revResampler);
        session->revResampler = NULL;
 }
 if (session->samplingRate != session->apmSamplingRate) {
 int error;
        session->inResampler = speex_resampler_init(session->inChannelCount,
                                                    session->samplingRate,
                                                    session->apmSamplingRate,
                                                    RESAMPLER_QUALITY,
 &error);
 if (session->inResampler == NULL) {
            ALOGW("Session_SetConfig Cannot create speex resampler: %s",
                 speex_resampler_strerror(error));
 return -EINVAL;
 }
        session->outResampler = speex_resampler_init(session->outChannelCount,
                                                    session->apmSamplingRate,
                                                    session->samplingRate,
                                                    RESAMPLER_QUALITY,
 &error);
 if (session->outResampler == NULL) {
            ALOGW("Session_SetConfig Cannot create speex resampler: %s",
                 speex_resampler_strerror(error));
            speex_resampler_destroy(session->inResampler);
            session->inResampler = NULL;
 return -EINVAL;
 }
        session->revResampler = speex_resampler_init(session->inChannelCount,
                                                    session->samplingRate,
                                                    session->apmSamplingRate,
                                                    RESAMPLER_QUALITY,
 &error);
 if (session->revResampler == NULL) {
            ALOGW("Session_SetConfig Cannot create speex resampler: %s",
                 speex_resampler_strerror(error));
            speex_resampler_destroy(session->inResampler);
            session->inResampler = NULL;
            speex_resampler_destroy(session->outResampler);
            session->outResampler = NULL;
 return -EINVAL;
 }
 }

    session->state = PREPROC_SESSION_STATE_CONFIG;
 return 0;
}

int Visualizer_init(VisualizerContext *pContext)
{
    pContext->mConfig.inputCfg.accessMode = EFFECT_BUFFER_ACCESS_READ;
    pContext->mConfig.inputCfg.channels = AUDIO_CHANNEL_OUT_STEREO;
    pContext->mConfig.inputCfg.format = AUDIO_FORMAT_PCM_16_BIT;
    pContext->mConfig.inputCfg.samplingRate = 44100;
    pContext->mConfig.inputCfg.bufferProvider.getBuffer = NULL;
    pContext->mConfig.inputCfg.bufferProvider.releaseBuffer = NULL;
    pContext->mConfig.inputCfg.bufferProvider.cookie = NULL;
    pContext->mConfig.inputCfg.mask = EFFECT_CONFIG_ALL;
    pContext->mConfig.outputCfg.accessMode = EFFECT_BUFFER_ACCESS_ACCUMULATE;
    pContext->mConfig.outputCfg.channels = AUDIO_CHANNEL_OUT_STEREO;
    pContext->mConfig.outputCfg.format = AUDIO_FORMAT_PCM_16_BIT;
    pContext->mConfig.outputCfg.samplingRate = 44100;
    pContext->mConfig.outputCfg.bufferProvider.getBuffer = NULL;
    pContext->mConfig.outputCfg.bufferProvider.releaseBuffer = NULL;
    pContext->mConfig.outputCfg.bufferProvider.cookie = NULL;
    pContext->mConfig.outputCfg.mask = EFFECT_CONFIG_ALL;

    pContext->mCaptureSize = VISUALIZER_CAPTURE_SIZE_MAX;
    pContext->mScalingMode = VISUALIZER_SCALING_MODE_NORMALIZED;

    pContext->mChannelCount =
            audio_channel_count_from_out_mask(pContext->mConfig.inputCfg.channels);
    pContext->mMeasurementMode = MEASUREMENT_MODE_NONE;
    pContext->mMeasurementWindowSizeInBuffers = MEASUREMENT_WINDOW_MAX_SIZE_IN_BUFFERS;
    pContext->mMeasurementBufferIdx = 0;
 for (uint32_t i=0 ; i<pContext->mMeasurementWindowSizeInBuffers ; i++) {
        pContext->mPastMeasurements[i].mIsValid = false;
        pContext->mPastMeasurements[i].mPeakU16 = 0;
        pContext->mPastMeasurements[i].mRmsSquared = 0;
 }

 Visualizer_setConfig(pContext, &pContext->mConfig);

 return 0;
}

audio_devices_t VirtualizerGetVirtualizationMode(EffectContext *pContext) {
 audio_devices_t virtDevice = AUDIO_DEVICE_NONE;
 if ((pContext->pBundledContext->bVirtualizerEnabled == LVM_TRUE)
 && (pContext->pBundledContext->bVirtualizerTempDisabled == LVM_FALSE)) {
 if (pContext->pBundledContext->nVirtualizerForcedDevice != AUDIO_DEVICE_NONE) {
            virtDevice = pContext->pBundledContext->nVirtualizerForcedDevice;
 } else {
            virtDevice = pContext->pBundledContext->nOutputDevice;
 }
 }
    ALOGV("VirtualizerGetVirtualizationMode() returning 0x%x", virtDevice);
 return virtDevice;
}

extern "C" int EffectGetDescriptor(const effect_uuid_t *uuid,
 effect_descriptor_t *pDescriptor) {
 int i;
 int length = sizeof(gDescriptors) / sizeof(const effect_descriptor_t *);

 if (pDescriptor == NULL || uuid == NULL){
        ALOGV("EffectGetDescriptor() called with NULL pointer");
 return -EINVAL;
 }

 for (i = 0; i < length; i++) {
 if (memcmp(uuid, &gDescriptors[i]->uuid, sizeof(effect_uuid_t)) == 0) {
 *pDescriptor = *gDescriptors[i];
            ALOGV("EffectGetDescriptor - UUID matched Reverb type %d, UUID = %x",
                 i, gDescriptors[i]->uuid.timeLow);
 return 0;
 }
 }

 return -EINVAL;
} /* end EffectGetDescriptor */

bool Downmix_foldGeneric(
 uint32_t mask, int16_t *pSrc, int16_t*pDst, size_t numFrames, bool accumulate) {
 if (mask & kUnsupported) {
        ALOGE("Unsupported channels (top or front left/right of center)");
 return false;
 }
 if ((mask & AUDIO_CHANNEL_OUT_STEREO) != AUDIO_CHANNEL_OUT_STEREO) {
        ALOGE("Front channels must be present");
 return false;
 }
 bool hasSides = false;
 if ((mask & kSides) != 0) {
 if ((mask & kSides) != kSides) {
            ALOGE("Side channels must be used as a pair");
 return false;
 }
        hasSides = true;
 }
 bool hasBacks = false;
 if ((mask & kBacks) != 0) {
 if ((mask & kBacks) != kBacks) {
            ALOGE("Back channels must be used as a pair");
 return false;
 }
        hasBacks = true;
 }

 const int numChan = audio_channel_count_from_out_mask(mask);
 const bool hasFC = ((mask & AUDIO_CHANNEL_OUT_FRONT_CENTER) == AUDIO_CHANNEL_OUT_FRONT_CENTER);
 const bool hasLFE =
 ((mask & AUDIO_CHANNEL_OUT_LOW_FREQUENCY) == AUDIO_CHANNEL_OUT_LOW_FREQUENCY);
 const bool hasBC = ((mask & AUDIO_CHANNEL_OUT_BACK_CENTER) == AUDIO_CHANNEL_OUT_BACK_CENTER);
 const int indexFC  = hasFC    ? 2 : 1; // front center
 const int indexLFE = hasLFE   ? indexFC + 1 : indexFC; // low frequency
 const int indexBL  = hasBacks ? indexLFE + 1 : indexLFE; // back left
 const int indexBR  = hasBacks ? indexBL + 1 : indexBL; // back right
 const int indexBC  = hasBC    ? indexBR + 1 : indexBR; // back center
 const int indexSL  = hasSides ? indexBC + 1 : indexBC; // side left
 const int indexSR  = hasSides ? indexSL + 1 : indexSL; // side right

 int32_t lt, rt, centersLfeContrib; // samples in Q19.12 format
 if (accumulate) {
 while (numFrames) {
            centersLfeContrib = 0;
 if (hasFC) { centersLfeContrib += pSrc[indexFC]; }
 if (hasLFE) { centersLfeContrib += pSrc[indexLFE]; }
 if (hasBC) { centersLfeContrib += pSrc[indexBC]; }
            centersLfeContrib *= MINUS_3_DB_IN_Q19_12;
            lt = (pSrc[0] << 12);
            rt = (pSrc[1] << 12);
 if (hasSides) {
                lt += pSrc[indexSL] << 12;
                rt += pSrc[indexSR] << 12;
 }
 if (hasBacks) {
                lt += pSrc[indexBL] << 12;
                rt += pSrc[indexBR] << 12;
 }
            lt += centersLfeContrib;
            rt += centersLfeContrib;
            pDst[0] = clamp16(pDst[0] + (lt >> 13));
            pDst[1] = clamp16(pDst[1] + (rt >> 13));
            pSrc += numChan;
            pDst += 2;
            numFrames--;
 }
 } else {
 while (numFrames) {
            centersLfeContrib = 0;
 if (hasFC) { centersLfeContrib += pSrc[indexFC]; }
 if (hasLFE) { centersLfeContrib += pSrc[indexLFE]; }
 if (hasBC) { centersLfeContrib += pSrc[indexBC]; }
            centersLfeContrib *= MINUS_3_DB_IN_Q19_12;
            lt = (pSrc[0] << 12);
            rt = (pSrc[1] << 12);
 if (hasSides) {
                lt += pSrc[indexSL] << 12;
                rt += pSrc[indexSR] << 12;
 }
 if (hasBacks) {
                lt += pSrc[indexBL] << 12;
                rt += pSrc[indexBR] << 12;
 }
            lt += centersLfeContrib;
            rt += centersLfeContrib;
            pDst[0] = clamp16(lt >> 13); // differs from when accumulate is true above
            pDst[1] = clamp16(rt >> 13); // differs from when accumulate is true above
            pSrc += numChan;
            pDst += 2;
            numFrames--;
 }
 }
 return true;
}

int32_t EqualizerGetCentreFrequency(EffectContext *pContext, int32_t band){
 int32_t Frequency =0;

 LVM_ControlParams_t ActiveParams; /* Current control Parameters */
    LVM_ReturnStatus_en     LvmStatus = LVM_SUCCESS; /* Function call status */
 LVM_EQNB_BandDef_t *BandDef;
 /* Get the current settings */
 LvmStatus = LVM_GetControlParameters(pContext->pBundledContext->hInstance,
 &ActiveParams);

    LVM_ERROR_CHECK(LvmStatus, "LVM_GetControlParameters", "EqualizerGetCentreFrequency")

 BandDef = ActiveParams.pEQNB_BandDefinition;
 Frequency = (int32_t)BandDef[band].Frequency*1000; // Convert to millibels

 return Frequency;
}

int PreProcessingFx_Command(effect_handle_t  self,
uint32_t            cmdCode,
uint32_t            cmdSize,
void *pCmdData,
uint32_t *replySize,
void *pReplyData)
{
preproc_effect_t * effect = (preproc_effect_t *) self;
int retsize;
int status;

if (effect == NULL){
return -EINVAL;
}

//ALOGV("PreProcessingFx_Command: command %d cmdSize %d",cmdCode, cmdSize);

switch (cmdCode){
case EFFECT_CMD_INIT:
if (pReplyData == NULL || *replySize != sizeof(int)){
return -EINVAL;
}
if (effect->ops->init) {
effect->ops->init(effect);
}
*(int *)pReplyData = 0;
break;

case EFFECT_CMD_SET_CONFIG: {
if (pCmdData    == NULL||
cmdSize     != sizeof(effect_config_t)||
pReplyData  == NULL||
*replySize  != sizeof(int)){
ALOGV("PreProcessingFx_Command cmdCode Case: "
"EFFECT_CMD_SET_CONFIG: ERROR");
return -EINVAL;
}
#ifdef DUAL_MIC_TEST
// make sure that the config command is accepted by making as if all effects were
// disabled: this is OK for functional tests
uint32_t enabledMsk = effect->session->enabledMsk;
if (gDualMicEnabled) {
effect->session->enabledMsk = 0;
}
#endif
*(int *)pReplyData = Session_SetConfig(effect->session, (effect_config_t *)pCmdData);
#ifdef DUAL_MIC_TEST
if (gDualMicEnabled) {
effect->session->enabledMsk = enabledMsk;
}
#endif
if (*(int *)pReplyData != 0) {
break;
}
if (effect->state != PREPROC_EFFECT_STATE_ACTIVE) {
*(int *)pReplyData = Effect_SetState(effect, PREPROC_EFFECT_STATE_CONFIG);
}
} break;

case EFFECT_CMD_GET_CONFIG:
if (pReplyData == NULL ||
*replySize != sizeof(effect_config_t)) {
ALOGV("\tLVM_ERROR : PreProcessingFx_Command cmdCode Case: "
"EFFECT_CMD_GET_CONFIG: ERROR");
return -EINVAL;
}

Session_GetConfig(effect->session, (effect_config_t *)pReplyData);
break;

case EFFECT_CMD_SET_CONFIG_REVERSE:
if (pCmdData == NULL ||
cmdSize != sizeof(effect_config_t) ||
pReplyData == NULL ||
*replySize != sizeof(int)) {
ALOGV("PreProcessingFx_Command cmdCode Case: "
"EFFECT_CMD_SET_CONFIG_REVERSE: ERROR");
return -EINVAL;
}
*(int *)pReplyData = Session_SetReverseConfig(effect->session,
(effect_config_t *)pCmdData);
if (*(int *)pReplyData != 0) {
break;
}
break;

case EFFECT_CMD_GET_CONFIG_REVERSE:
if (pReplyData == NULL ||
*replySize != sizeof(effect_config_t)){
ALOGV("PreProcessingFx_Command cmdCode Case: "
"EFFECT_CMD_GET_CONFIG_REVERSE: ERROR");
return -EINVAL;
}
Session_GetReverseConfig(effect->session, (effect_config_t *)pCmdData);
break;

case EFFECT_CMD_RESET:
if (effect->ops->reset) {
effect->ops->reset(effect);

}
break;

        case EFFECT_CMD_GET_PARAM:{
            if (pCmdData == NULL ||
                    cmdSize < (int)sizeof(effect_param_t) ||
                    pReplyData == NULL ||
                    *replySize < (int)sizeof(effect_param_t)){
ALOGV("PreProcessingFx_Command cmdCode Case: "
"EFFECT_CMD_GET_PARAM: ERROR");
return -EINVAL;
}
            effect_param_t *p = (effect_param_t *)pCmdData;

memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + p->psize);

p = (effect_param_t *)pReplyData;

int voffset = ((p->psize - 1) / sizeof(int32_t) + 1) * sizeof(int32_t);

if (effect->ops->get_parameter) {
p->status = effect->ops->get_parameter(effect, p->data,
&p->vsize,
p->data + voffset);
*replySize = sizeof(effect_param_t) + voffset + p->vsize;
}
} break;


case EFFECT_CMD_SET_PARAM:{
if (pCmdData == NULL||
                    cmdSize < (int)sizeof(effect_param_t) ||
                    pReplyData == NULL ||
*replySize != sizeof(int32_t)){
ALOGV("PreProcessingFx_Command cmdCode Case: "
"EFFECT_CMD_SET_PARAM: ERROR");
return -EINVAL;
}
effect_param_t *p = (effect_param_t *) pCmdData;

if (p->psize != sizeof(int32_t)){
ALOGV("PreProcessingFx_Command cmdCode Case: "
"EFFECT_CMD_SET_PARAM: ERROR, psize is not sizeof(int32_t)");
return -EINVAL;
}
if (effect->ops->set_parameter) {
*(int *)pReplyData = effect->ops->set_parameter(effect,
(void *)p->data,
p->data + p->psize);
}

} break;

case EFFECT_CMD_ENABLE:
            if (pReplyData == NULL || *replySize != sizeof(int)){
ALOGV("PreProcessingFx_Command cmdCode Case: EFFECT_CMD_ENABLE: ERROR");
return -EINVAL;
}
*(int *)pReplyData = Effect_SetState(effect, PREPROC_EFFECT_STATE_ACTIVE);

break;

case EFFECT_CMD_DISABLE:
            if (pReplyData == NULL || *replySize != sizeof(int)){
ALOGV("PreProcessingFx_Command cmdCode Case: EFFECT_CMD_DISABLE: ERROR");
return -EINVAL;
}
*(int *)pReplyData  = Effect_SetState(effect, PREPROC_EFFECT_STATE_CONFIG);
break;

case EFFECT_CMD_SET_DEVICE:
case EFFECT_CMD_SET_INPUT_DEVICE:
if (pCmdData == NULL ||
cmdSize != sizeof(uint32_t)) {
ALOGV("PreProcessingFx_Command cmdCode Case: EFFECT_CMD_SET_DEVICE: ERROR");
return -EINVAL;
}

if (effect->ops->set_device) {
effect->ops->set_device(effect, *(uint32_t *)pCmdData);
}
break;

case EFFECT_CMD_SET_VOLUME:
case EFFECT_CMD_SET_AUDIO_MODE:
break;

#ifdef DUAL_MIC_TEST
///// test commands start
case PREPROC_CMD_DUAL_MIC_ENABLE: {
if (pCmdData == NULL|| cmdSize != sizeof(uint32_t) ||
pReplyData == NULL || replySize == NULL) {
ALOGE("PreProcessingFx_Command cmdCode Case: "
"PREPROC_CMD_DUAL_MIC_ENABLE: ERROR");
*replySize = 0;
return -EINVAL;
}
gDualMicEnabled = *(bool *)pCmdData;
if (gDualMicEnabled) {
effect->aux_channels_on = sHasAuxChannels[effect->procId];
} else {
effect->aux_channels_on = false;
}
effect->cur_channel_config = (effect->session->inChannelCount == 1) ?
CHANNEL_CFG_MONO : CHANNEL_CFG_STEREO;

ALOGV("PREPROC_CMD_DUAL_MIC_ENABLE: %s", gDualMicEnabled ? "enabled" : "disabled");
*replySize = sizeof(int);
*(int *)pReplyData = 0;
} break;
case PREPROC_CMD_DUAL_MIC_PCM_DUMP_START: {
if (pCmdData == NULL|| pReplyData == NULL || replySize == NULL) {
ALOGE("PreProcessingFx_Command cmdCode Case: "
"PREPROC_CMD_DUAL_MIC_PCM_DUMP_START: ERROR");
*replySize = 0;
return -EINVAL;
}
pthread_mutex_lock(&gPcmDumpLock);
if (gPcmDumpFh != NULL) {
fclose(gPcmDumpFh);
gPcmDumpFh = NULL;
}
char *path = strndup((char *)pCmdData, cmdSize);
gPcmDumpFh = fopen((char *)path, "wb");
pthread_mutex_unlock(&gPcmDumpLock);
ALOGV("PREPROC_CMD_DUAL_MIC_PCM_DUMP_START: path %s gPcmDumpFh %p",
path, gPcmDumpFh);
ALOGE_IF(gPcmDumpFh <= 0, "gPcmDumpFh open error %d %s", errno, strerror(errno));
free(path);
*replySize = sizeof(int);
*(int *)pReplyData = 0;
} break;
case PREPROC_CMD_DUAL_MIC_PCM_DUMP_STOP: {
if (pReplyData == NULL || replySize == NULL) {
ALOGE("PreProcessingFx_Command cmdCode Case: "
"PREPROC_CMD_DUAL_MIC_PCM_DUMP_STOP: ERROR");
*replySize = 0;
return -EINVAL;
}
pthread_mutex_lock(&gPcmDumpLock);
if (gPcmDumpFh != NULL) {
fclose(gPcmDumpFh);
gPcmDumpFh = NULL;
}
pthread_mutex_unlock(&gPcmDumpLock);
ALOGV("PREPROC_CMD_DUAL_MIC_PCM_DUMP_STOP");
*replySize = sizeof(int);
*(int *)pReplyData = 0;
} break;
///// test commands end

case EFFECT_CMD_GET_FEATURE_SUPPORTED_CONFIGS: {
if(!gDualMicEnabled) {
return -EINVAL;
}
if (pCmdData == NULL|| cmdSize != 2 * sizeof(uint32_t) ||
pReplyData == NULL || replySize == NULL) {
ALOGE("PreProcessingFx_Command cmdCode Case: "
"EFFECT_CMD_GET_FEATURE_SUPPORTED_CONFIGS: ERROR");
*replySize = 0;
return -EINVAL;
}
if (*(uint32_t *)pCmdData != EFFECT_FEATURE_AUX_CHANNELS ||
!effect->aux_channels_on) {
ALOGV("PreProcessingFx_Command feature EFFECT_FEATURE_AUX_CHANNELS not supported by"
" fx %d", effect->procId);
*(uint32_t *)pReplyData = -ENOSYS;
*replySize = sizeof(uint32_t);
break;
}
size_t num_configs = *((uint32_t *)pCmdData + 1);
if (*replySize < (2 * sizeof(uint32_t) +
num_configs * sizeof(channel_config_t))) {
*replySize = 0;
return -EINVAL;
}

*((uint32_t *)pReplyData + 1) = CHANNEL_CFG_CNT;
if (num_configs < CHANNEL_CFG_CNT ||
*replySize < (2 * sizeof(uint32_t) +
CHANNEL_CFG_CNT * sizeof(channel_config_t))) {
*(uint32_t *)pReplyData = -ENOMEM;
} else {
num_configs = CHANNEL_CFG_CNT;
*(uint32_t *)pReplyData = 0;
}
ALOGV("PreProcessingFx_Command EFFECT_CMD_GET_FEATURE_SUPPORTED_CONFIGS num config %d",
num_configs);

*replySize = 2 * sizeof(uint32_t) + num_configs * sizeof(channel_config_t);
*((uint32_t *)pReplyData + 1) = num_configs;
memcpy((uint32_t *)pReplyData + 2, &sDualMicConfigs, num_configs * sizeof(channel_config_t));
} break;
case EFFECT_CMD_GET_FEATURE_CONFIG:
if(!gDualMicEnabled) {
return -EINVAL;
}
if (pCmdData == NULL|| cmdSize != sizeof(uint32_t) ||
pReplyData == NULL || replySize == NULL ||
*replySize < sizeof(uint32_t) + sizeof(channel_config_t)) {
ALOGE("PreProcessingFx_Command cmdCode Case: "
"EFFECT_CMD_GET_FEATURE_CONFIG: ERROR");
return -EINVAL;
}
if (*(uint32_t *)pCmdData != EFFECT_FEATURE_AUX_CHANNELS || !effect->aux_channels_on) {
*(uint32_t *)pReplyData = -ENOSYS;
*replySize = sizeof(uint32_t);
break;
}
ALOGV("PreProcessingFx_Command EFFECT_CMD_GET_FEATURE_CONFIG");
*(uint32_t *)pReplyData = 0;
*replySize = sizeof(uint32_t) + sizeof(channel_config_t);
memcpy((uint32_t *)pReplyData + 1,
&sDualMicConfigs[effect->cur_channel_config],
sizeof(channel_config_t));
break;
case EFFECT_CMD_SET_FEATURE_CONFIG: {
ALOGV("PreProcessingFx_Command EFFECT_CMD_SET_FEATURE_CONFIG: "
"gDualMicEnabled %d effect->aux_channels_on %d",
gDualMicEnabled, effect->aux_channels_on);
if(!gDualMicEnabled) {
return -EINVAL;
}
if (pCmdData == NULL|| cmdSize != (sizeof(uint32_t) + sizeof(channel_config_t)) ||
pReplyData == NULL || replySize == NULL ||
*replySize < sizeof(uint32_t)) {
ALOGE("PreProcessingFx_Command cmdCode Case: "
"EFFECT_CMD_SET_FEATURE_CONFIG: ERROR\n"
"pCmdData %p cmdSize %d pReplyData %p replySize %p *replySize %d",
pCmdData, cmdSize, pReplyData, replySize, replySize ? *replySize : -1);
return -EINVAL;
}
*replySize = sizeof(uint32_t);
if (*(uint32_t *)pCmdData != EFFECT_FEATURE_AUX_CHANNELS || !effect->aux_channels_on) {
*(uint32_t *)pReplyData = -ENOSYS;
ALOGV("PreProcessingFx_Command cmdCode Case: "
"EFFECT_CMD_SET_FEATURE_CONFIG: ERROR\n"
"CmdData %d effect->aux_channels_on %d",
*(uint32_t *)pCmdData, effect->aux_channels_on);
break;
}
size_t i;
for (i = 0; i < CHANNEL_CFG_CNT;i++) {
if (memcmp((uint32_t *)pCmdData + 1,
&sDualMicConfigs[i], sizeof(channel_config_t)) == 0) {
break;
}
}
if (i == CHANNEL_CFG_CNT) {
*(uint32_t *)pReplyData = -EINVAL;
ALOGW("PreProcessingFx_Command EFFECT_CMD_SET_FEATURE_CONFIG invalid config"
"[%08x].[%08x]", *((uint32_t *)pCmdData + 1), *((uint32_t *)pCmdData + 2));
} else {
effect->cur_channel_config = i;
*(uint32_t *)pReplyData = 0;
ALOGV("PreProcessingFx_Command EFFECT_CMD_SET_FEATURE_CONFIG New config"
"[%08x].[%08x]", sDualMicConfigs[i].main_channels, sDualMicConfigs[i].aux_channels);
}
} break;
#endif
default:
return -EINVAL;
}
return 0;
}

int Volume_setParameter (EffectContext *pContext, void *pParam, void *pValue){
 int      status = 0;
 int16_t  level;
 int16_t  position;
 uint32_t mute;
 uint32_t positionEnabled;
 int32_t *pParamTemp = (int32_t *)pParam;
 int32_t param = *pParamTemp++;


 switch (param){
 case VOLUME_PARAM_LEVEL:
            level = *(int16_t *)pValue;
            status = VolumeSetVolumeLevel(pContext, (int16_t)level);
 break;

 case VOLUME_PARAM_MUTE:
            mute = *(uint32_t *)pValue;
            status = VolumeSetMute(pContext, mute);
 break;

 case VOLUME_PARAM_ENABLESTEREOPOSITION:
            positionEnabled = *(uint32_t *)pValue;
            status = VolumeEnableStereoPosition(pContext, positionEnabled);
            status = VolumeSetStereoPosition(pContext, pContext->pBundledContext->positionSaved);
 break;

 case VOLUME_PARAM_STEREOPOSITION:
            position = *(int16_t *)pValue;
            status = VolumeSetStereoPosition(pContext, (int16_t)position);
 break;

 default:
            ALOGV("\tLVM_ERROR : Volume_setParameter() invalid param %d", param);
 break;
 }

 return status;
} /* end Volume_setParameter */

int Effect_Release(preproc_effect_t *effect)
{
 return Effect_SetState(effect, PREPROC_EFFECT_STATE_INIT);
}

void Downmix_foldFromQuad(int16_t *pSrc, int16_t*pDst, size_t numFrames, bool accumulate) {
 if (accumulate) {
 while (numFrames) {
            pDst[0] = clamp16(pDst[0] + ((pSrc[0] + pSrc[2]) >> 1));
            pDst[1] = clamp16(pDst[1] + ((pSrc[1] + pSrc[3]) >> 1));
            pSrc += 4;
            pDst += 2;
            numFrames--;
 }
 } else { // same code as above but without adding and clamping pDst[i] to itself
 while (numFrames) {
            pDst[0] = clamp16((pSrc[0] + pSrc[2]) >> 1);
            pDst[1] = clamp16((pSrc[1] + pSrc[3]) >> 1);
            pSrc += 4;
            pDst += 2;
            numFrames--;
 }
 }
}

int Downmix_Configure(downmix_module_t *pDwmModule, effect_config_t *pConfig, bool init) {

 downmix_object_t *pDownmixer = &pDwmModule->context;

 if (pConfig->inputCfg.samplingRate != pConfig->outputCfg.samplingRate
 || pConfig->outputCfg.channels != DOWNMIX_OUTPUT_CHANNELS
 || pConfig->inputCfg.format != AUDIO_FORMAT_PCM_16_BIT
 || pConfig->outputCfg.format != AUDIO_FORMAT_PCM_16_BIT) {
        ALOGE("Downmix_Configure error: invalid config");
 return -EINVAL;
 }

 if (&pDwmModule->config != pConfig) {
        memcpy(&pDwmModule->config, pConfig, sizeof(effect_config_t));
 }

 if (init) {
        pDownmixer->type = DOWNMIX_TYPE_FOLD;
        pDownmixer->apply_volume_correction = false;
        pDownmixer->input_channel_count = 8; // matches default input of AUDIO_CHANNEL_OUT_7POINT1
 } else {
 if (pConfig->inputCfg.channels == 0) {
            ALOGE("Downmix_Configure error: input channel mask can't be 0");
 return -EINVAL;
 }
        pDownmixer->input_channel_count =
                audio_channel_count_from_out_mask(pConfig->inputCfg.channels);
 }

 Downmix_Reset(pDownmixer, init);

 return 0;
}

void AecDisable(preproc_effect_t *effect)
{
    ALOGV("AecDisable");
    webrtc::EchoControlMobile *aec = static_cast<webrtc::EchoControlMobile *>(effect->engine);
    aec->Enable(false);
}

void EqualizerSetBandLevel(EffectContext *pContext, int band, short Gain){
 int gainRounded;
 if(Gain > 0){
        gainRounded = (int)((Gain+50)/100);
 }else{
        gainRounded = (int)((Gain-50)/100);
 }
    pContext->pBundledContext->bandGaindB[band] = gainRounded;
    pContext->pBundledContext->CurPreset = PRESET_CUSTOM;

 EqualizerUpdateActiveParams(pContext);
 LvmEffect_limitLevel(pContext);
}

void Visualizer_reset(VisualizerContext *pContext)
{
    pContext->mCaptureIdx = 0;
    pContext->mLastCaptureIdx = 0;
    pContext->mBufferUpdateTime.tv_sec = 0;
    pContext->mLatency = 0;
    memset(pContext->mCaptureBuf, 0x80, CAPTURE_BUF_SIZE);
}

int32_t EqualizerGetNumPresets(){
 return sizeof(gEqualizerPresets) / sizeof(PresetConfig);
}

void Visualizer_getConfig(VisualizerContext *pContext, effect_config_t *pConfig)
{
 *pConfig = pContext->mConfig;
}

int Reverb_LoadPreset(ReverbContext *pContext)
{
    pContext->curPreset = pContext->nextPreset;

 if (pContext->curPreset != REVERB_PRESET_NONE) {
 const t_reverb_settings *preset = &sReverbPresets[pContext->curPreset];
 ReverbSetRoomLevel(pContext, preset->roomLevel);
 ReverbSetRoomHfLevel(pContext, preset->roomHFLevel);
 ReverbSetDecayTime(pContext, preset->decayTime);
 ReverbSetDecayHfRatio(pContext, preset->decayHFRatio);
 ReverbSetReverbLevel(pContext, preset->reverbLevel);
 ReverbSetDiffusion(pContext, preset->diffusion);
 ReverbSetDensity(pContext, preset->density);
 }

 return 0;
}

void Downmix_testIndexComputation(uint32_t mask) {
    ALOGI("Testing index computation for 0x%" PRIx32 ":", mask);
 if (mask & kUnsupported) {
        ALOGE("Unsupported channels (top or front left/right of center)");
 return;
 }
 if ((mask & AUDIO_CHANNEL_OUT_STEREO) != AUDIO_CHANNEL_OUT_STEREO) {
        ALOGE("Front channels must be present");
 return;
 }
 bool hasSides = false;
 if ((mask & kSides) != 0) {
 if ((mask & kSides) != kSides) {
            ALOGE("Side channels must be used as a pair");
 return;
 }
        hasSides = true;
 }
 bool hasBacks = false;
 if ((mask & kBacks) != 0) {
 if ((mask & kBacks) != kBacks) {
            ALOGE("Back channels must be used as a pair");
 return;
 }
        hasBacks = true;
 }

 const int numChan = audio_channel_count_from_out_mask(mask);
 const bool hasFC = ((mask & AUDIO_CHANNEL_OUT_FRONT_CENTER) == AUDIO_CHANNEL_OUT_FRONT_CENTER);
 const bool hasLFE =
 ((mask & AUDIO_CHANNEL_OUT_LOW_FREQUENCY) == AUDIO_CHANNEL_OUT_LOW_FREQUENCY);
 const bool hasBC = ((mask & AUDIO_CHANNEL_OUT_BACK_CENTER) == AUDIO_CHANNEL_OUT_BACK_CENTER);
 const int indexFC  = hasFC    ? 2 : 1; // front center
 const int indexLFE = hasLFE   ? indexFC + 1 : indexFC; // low frequency
 const int indexBL  = hasBacks ? indexLFE + 1 : indexLFE; // back left
 const int indexBR  = hasBacks ? indexBL + 1 : indexBL; // back right
 const int indexBC  = hasBC    ? indexBR + 1 : indexBR; // back center
 const int indexSL  = hasSides ? indexBC + 1 : indexBC; // side left
 const int indexSR  = hasSides ? indexSL + 1 : indexSL; // side right

    ALOGI("  FL FR FC LFE BL BR BC SL SR");
    ALOGI("   %d  %d  %d   %d  %d  %d  %d  %d  %d",
 0, 1, indexFC, indexLFE, indexBL, indexBR, indexBC, indexSL, indexSR);
}

int PreProcessingLib_Create(const effect_uuid_t *uuid,
 int32_t             sessionId,
 int32_t             ioId,
 effect_handle_t *pInterface)
{
    ALOGV("EffectCreate: uuid: %08x session %d IO: %d", uuid->timeLow, sessionId, ioId);

 int status;
 const effect_descriptor_t *desc;
 preproc_session_t *session;
 uint32_t procId;

 if (PreProc_Init() != 0) {
 return sInitStatus;
 }
    desc = PreProc_GetDescriptor(uuid);
 if (desc == NULL) {
        ALOGW("EffectCreate: fx not found uuid: %08x", uuid->timeLow);
 return -EINVAL;
 }
    procId = UuidToProcId(&desc->type);

    session = PreProc_GetSession(procId, sessionId, ioId);
 if (session == NULL) {
        ALOGW("EffectCreate: no more session available");
 return -EINVAL;
 }

    status = Session_CreateEffect(session, procId, pInterface);

 if (status < 0 && session->createdMsk == 0) {
        session->io = 0;
 }
 return status;
}

void NsEnable(preproc_effect_t *effect)
{
    webrtc::NoiseSuppression *ns = static_cast<webrtc::NoiseSuppression *>(effect->engine);
    ALOGV("NsEnable ns %p", ns);
    ns->Enable(true);
}

int NsGetParameter(preproc_effect_t  *effect,
                   void              *pParam,
                   uint32_t          *pValueSize,
                   void              *pValue)
{
int status = 0;
return status;
}

uint32_t ReverbGetDecayTime(ReverbContext *pContext){

    LVREV_ControlParams_st    ActiveParams; /* Current control Parameters */
    LVREV_ReturnStatus_en     LvmStatus=LVREV_SUCCESS; /* Function call status */

 /* Get the current settings */
 LvmStatus = LVREV_GetControlParameters(pContext->hInstance, &ActiveParams);
    LVM_ERROR_CHECK(LvmStatus, "LVREV_GetControlParameters", "ReverbGetDecayTime")

 if(ActiveParams.T60 != pContext->SavedDecayTime){
        ALOGV("\tLVM_ERROR : ReverbGetDecayTime() has wrong level -> %d %d\n",
 ActiveParams.T60, pContext->SavedDecayTime);
 }

 return (uint32_t)ActiveParams.T60;
}

int Reverb_getParameter(ReverbContext *pContext,
 void *pParam,
 uint32_t *pValueSize,
 void *pValue){
 int status = 0;
 int32_t *pParamTemp = (int32_t *)pParam;
 int32_t param = *pParamTemp++;
 char *name;
    t_reverb_settings *pProperties;

 if (pContext->preset) {
 if (param != REVERB_PARAM_PRESET || *pValueSize < sizeof(uint16_t)) {
 return -EINVAL;
 }

 *(uint16_t *)pValue = pContext->nextPreset;
        ALOGV("get REVERB_PARAM_PRESET, preset %d", pContext->nextPreset);
 return 0;
 }

 switch (param){
 case REVERB_PARAM_ROOM_LEVEL:
 if (*pValueSize != sizeof(int16_t)){
                ALOGV("\tLVM_ERROR : Reverb_getParameter() invalid pValueSize1 %d", *pValueSize);
 return -EINVAL;
 }
 *pValueSize = sizeof(int16_t);
 break;
 case REVERB_PARAM_ROOM_HF_LEVEL:
 if (*pValueSize != sizeof(int16_t)){
                ALOGV("\tLVM_ERROR : Reverb_getParameter() invalid pValueSize12 %d", *pValueSize);
 return -EINVAL;
 }
 *pValueSize = sizeof(int16_t);
 break;
 case REVERB_PARAM_DECAY_TIME:
 if (*pValueSize != sizeof(uint32_t)){
                ALOGV("\tLVM_ERROR : Reverb_getParameter() invalid pValueSize3 %d", *pValueSize);
 return -EINVAL;
 }
 *pValueSize = sizeof(uint32_t);
 break;
 case REVERB_PARAM_DECAY_HF_RATIO:
 if (*pValueSize != sizeof(int16_t)){
                ALOGV("\tLVM_ERROR : Reverb_getParameter() invalid pValueSize4 %d", *pValueSize);
 return -EINVAL;
 }
 *pValueSize = sizeof(int16_t);
 break;
 case REVERB_PARAM_REFLECTIONS_LEVEL:
 if (*pValueSize != sizeof(int16_t)){
                ALOGV("\tLVM_ERROR : Reverb_getParameter() invalid pValueSize5 %d", *pValueSize);
 return -EINVAL;
 }
 *pValueSize = sizeof(int16_t);
 break;
 case REVERB_PARAM_REFLECTIONS_DELAY:
 if (*pValueSize != sizeof(uint32_t)){
                ALOGV("\tLVM_ERROR : Reverb_getParameter() invalid pValueSize6 %d", *pValueSize);
 return -EINVAL;
 }
 *pValueSize = sizeof(uint32_t);
 break;
 case REVERB_PARAM_REVERB_LEVEL:
 if (*pValueSize != sizeof(int16_t)){
                ALOGV("\tLVM_ERROR : Reverb_getParameter() invalid pValueSize7 %d", *pValueSize);
 return -EINVAL;
 }
 *pValueSize = sizeof(int16_t);
 break;
 case REVERB_PARAM_REVERB_DELAY:
 if (*pValueSize != sizeof(uint32_t)){
                ALOGV("\tLVM_ERROR : Reverb_getParameter() invalid pValueSize8 %d", *pValueSize);
 return -EINVAL;
 }
 *pValueSize = sizeof(uint32_t);
 break;
 case REVERB_PARAM_DIFFUSION:
 if (*pValueSize != sizeof(int16_t)){
                ALOGV("\tLVM_ERROR : Reverb_getParameter() invalid pValueSize9 %d", *pValueSize);
 return -EINVAL;
 }
 *pValueSize = sizeof(int16_t);
 break;
 case REVERB_PARAM_DENSITY:
 if (*pValueSize != sizeof(int16_t)){
                ALOGV("\tLVM_ERROR : Reverb_getParameter() invalid pValueSize10 %d", *pValueSize);
 return -EINVAL;
 }
 *pValueSize = sizeof(int16_t);
 break;
 case REVERB_PARAM_PROPERTIES:
 if (*pValueSize != sizeof(t_reverb_settings)){
                ALOGV("\tLVM_ERROR : Reverb_getParameter() invalid pValueSize11 %d", *pValueSize);
 return -EINVAL;
 }
 *pValueSize = sizeof(t_reverb_settings);
 break;

 default:
            ALOGV("\tLVM_ERROR : Reverb_getParameter() invalid param %d", param);
 return -EINVAL;
 }

    pProperties = (t_reverb_settings *) pValue;

 switch (param){
 case REVERB_PARAM_PROPERTIES:
            pProperties->roomLevel = ReverbGetRoomLevel(pContext);
            pProperties->roomHFLevel = ReverbGetRoomHfLevel(pContext);
            pProperties->decayTime = ReverbGetDecayTime(pContext);
            pProperties->decayHFRatio = ReverbGetDecayHfRatio(pContext);
            pProperties->reflectionsLevel = 0;
            pProperties->reflectionsDelay = 0;
            pProperties->reverbDelay = 0;
            pProperties->reverbLevel = ReverbGetReverbLevel(pContext);
            pProperties->diffusion = ReverbGetDiffusion(pContext);
            pProperties->density = ReverbGetDensity(pContext);

            ALOGV("\tReverb_getParameter() REVERB_PARAM_PROPERTIES Value is roomLevel        %d",
                pProperties->roomLevel);
            ALOGV("\tReverb_getParameter() REVERB_PARAM_PROPERTIES Value is roomHFLevel      %d",
                pProperties->roomHFLevel);
            ALOGV("\tReverb_getParameter() REVERB_PARAM_PROPERTIES Value is decayTime        %d",
                pProperties->decayTime);
            ALOGV("\tReverb_getParameter() REVERB_PARAM_PROPERTIES Value is decayHFRatio     %d",
                pProperties->decayHFRatio);
            ALOGV("\tReverb_getParameter() REVERB_PARAM_PROPERTIES Value is reflectionsLevel %d",
                pProperties->reflectionsLevel);
            ALOGV("\tReverb_getParameter() REVERB_PARAM_PROPERTIES Value is reflectionsDelay %d",
                pProperties->reflectionsDelay);
            ALOGV("\tReverb_getParameter() REVERB_PARAM_PROPERTIES Value is reverbDelay      %d",
                pProperties->reverbDelay);
            ALOGV("\tReverb_getParameter() REVERB_PARAM_PROPERTIES Value is reverbLevel      %d",
                pProperties->reverbLevel);
            ALOGV("\tReverb_getParameter() REVERB_PARAM_PROPERTIES Value is diffusion        %d",
                pProperties->diffusion);
            ALOGV("\tReverb_getParameter() REVERB_PARAM_PROPERTIES Value is density          %d",
                pProperties->density);
 break;

 case REVERB_PARAM_ROOM_LEVEL:
 *(int16_t *)pValue = ReverbGetRoomLevel(pContext);

 break;
 case REVERB_PARAM_ROOM_HF_LEVEL:
 *(int16_t *)pValue = ReverbGetRoomHfLevel(pContext);

 break;
 case REVERB_PARAM_DECAY_TIME:
 *(uint32_t *)pValue = ReverbGetDecayTime(pContext);

 break;
 case REVERB_PARAM_DECAY_HF_RATIO:
 *(int16_t *)pValue = ReverbGetDecayHfRatio(pContext);

 break;
 case REVERB_PARAM_REVERB_LEVEL:
 *(int16_t *)pValue = ReverbGetReverbLevel(pContext);

 break;
 case REVERB_PARAM_DIFFUSION:
 *(int16_t *)pValue = ReverbGetDiffusion(pContext);

 break;
 case REVERB_PARAM_DENSITY:
 *(uint16_t *)pValue = 0;
 *(int16_t *)pValue = ReverbGetDensity(pContext);
 break;
 case REVERB_PARAM_REFLECTIONS_LEVEL:
 *(uint16_t *)pValue = 0;
 case REVERB_PARAM_REFLECTIONS_DELAY:
 *(uint32_t *)pValue = 0;
 case REVERB_PARAM_REVERB_DELAY:
 *(uint32_t *)pValue = 0;
 break;

 default:
            ALOGV("\tLVM_ERROR : Reverb_getParameter() invalid param %d", param);
            status = -EINVAL;
 break;
 }

 return status;
} /* end Reverb_getParameter */

void BassSetStrength(EffectContext *pContext, uint32_t strength){

    pContext->pBundledContext->BassStrengthSaved = (int)strength;

 LVM_ControlParams_t ActiveParams; /* Current control Parameters */
    LVM_ReturnStatus_en     LvmStatus=LVM_SUCCESS; /* Function call status */

 /* Get the current settings */
 LvmStatus = LVM_GetControlParameters(pContext->pBundledContext->hInstance,
 &ActiveParams);

    LVM_ERROR_CHECK(LvmStatus, "LVM_GetControlParameters", "BassSetStrength")

 /* Bass Enhancement parameters */
 ActiveParams.BE_EffectLevel    = (LVM_INT16)((15*strength)/1000);
 ActiveParams.BE_CentreFreq     = LVM_BE_CENTRE_90Hz;


 /* Activate the initial settings */
 LvmStatus = LVM_SetControlParameters(pContext->pBundledContext->hInstance, &ActiveParams);

    LVM_ERROR_CHECK(LvmStatus, "LVM_SetControlParameters", "BassSetStrength")

 LvmEffect_limitLevel(pContext);
} /* end BassSetStrength */

int Effect_setEnabled(EffectContext *pContext, bool enabled)
{
    ALOGV("\tEffect_setEnabled() type %d, enabled %d", pContext->EffectType, enabled);

 if (enabled) {
 bool tempDisabled = false;
 switch (pContext->EffectType) {
 case LVM_BASS_BOOST:
 if (pContext->pBundledContext->bBassEnabled == LVM_TRUE) {
                     ALOGV("\tEffect_setEnabled() LVM_BASS_BOOST is already enabled");
 return -EINVAL;
 }
 if(pContext->pBundledContext->SamplesToExitCountBb <= 0){
                    pContext->pBundledContext->NumberEffectsEnabled++;
 }
                pContext->pBundledContext->SamplesToExitCountBb =
 (LVM_INT32)(pContext->pBundledContext->SamplesPerSecond*0.1);
                pContext->pBundledContext->bBassEnabled = LVM_TRUE;
                tempDisabled = pContext->pBundledContext->bBassTempDisabled;
 break;
 case LVM_EQUALIZER:
 if (pContext->pBundledContext->bEqualizerEnabled == LVM_TRUE) {
                    ALOGV("\tEffect_setEnabled() LVM_EQUALIZER is already enabled");
 return -EINVAL;
 }
 if(pContext->pBundledContext->SamplesToExitCountEq <= 0){
                    pContext->pBundledContext->NumberEffectsEnabled++;
 }
                pContext->pBundledContext->SamplesToExitCountEq =
 (LVM_INT32)(pContext->pBundledContext->SamplesPerSecond*0.1);
                pContext->pBundledContext->bEqualizerEnabled = LVM_TRUE;
 break;
 case LVM_VIRTUALIZER:
 if (pContext->pBundledContext->bVirtualizerEnabled == LVM_TRUE) {
                    ALOGV("\tEffect_setEnabled() LVM_VIRTUALIZER is already enabled");
 return -EINVAL;
 }
 if(pContext->pBundledContext->SamplesToExitCountVirt <= 0){
                    pContext->pBundledContext->NumberEffectsEnabled++;
 }
                pContext->pBundledContext->SamplesToExitCountVirt =
 (LVM_INT32)(pContext->pBundledContext->SamplesPerSecond*0.1);
                pContext->pBundledContext->bVirtualizerEnabled = LVM_TRUE;
                tempDisabled = pContext->pBundledContext->bVirtualizerTempDisabled;
 break;
 case LVM_VOLUME:
 if (pContext->pBundledContext->bVolumeEnabled == LVM_TRUE) {
                    ALOGV("\tEffect_setEnabled() LVM_VOLUME is already enabled");
 return -EINVAL;
 }
                pContext->pBundledContext->NumberEffectsEnabled++;
                pContext->pBundledContext->bVolumeEnabled = LVM_TRUE;
 break;
 default:
                ALOGV("\tEffect_setEnabled() invalid effect type");
 return -EINVAL;
 }
 if (!tempDisabled) {
 LvmEffect_enable(pContext);
 }
 } else {
 switch (pContext->EffectType) {
 case LVM_BASS_BOOST:
 if (pContext->pBundledContext->bBassEnabled == LVM_FALSE) {
                    ALOGV("\tEffect_setEnabled() LVM_BASS_BOOST is already disabled");
 return -EINVAL;
 }
                pContext->pBundledContext->bBassEnabled = LVM_FALSE;
 break;
 case LVM_EQUALIZER:
 if (pContext->pBundledContext->bEqualizerEnabled == LVM_FALSE) {
                    ALOGV("\tEffect_setEnabled() LVM_EQUALIZER is already disabled");
 return -EINVAL;
 }
                pContext->pBundledContext->bEqualizerEnabled = LVM_FALSE;
 break;
 case LVM_VIRTUALIZER:
 if (pContext->pBundledContext->bVirtualizerEnabled == LVM_FALSE) {
                    ALOGV("\tEffect_setEnabled() LVM_VIRTUALIZER is already disabled");
 return -EINVAL;
 }
                pContext->pBundledContext->bVirtualizerEnabled = LVM_FALSE;
 break;
 case LVM_VOLUME:
 if (pContext->pBundledContext->bVolumeEnabled == LVM_FALSE) {
                    ALOGV("\tEffect_setEnabled() LVM_VOLUME is already disabled");
 return -EINVAL;
 }
                pContext->pBundledContext->bVolumeEnabled = LVM_FALSE;
 break;
 default:
                ALOGV("\tEffect_setEnabled() invalid effect type");
 return -EINVAL;
 }
 LvmEffect_disable(pContext);
 }

 return 0;
}

void MonoTo2I_32( const LVM_INT32  *src,
                        LVM_INT32  *dst,
                        LVM_INT16 n)
{
   LVM_INT16 ii;
   src += (n-1);
   dst += ((n*2)-1);

 for (ii = n; ii != 0; ii--)
 {
 *dst = *src;
       dst--;

 *dst = *src;
       dst--;
       src--;
 }

 return;
}

static int Downmix_Command(effect_handle_t self, uint32_t cmdCode, uint32_t cmdSize,
void *pCmdData, uint32_t *replySize, void *pReplyData) {

downmix_module_t *pDwmModule = (downmix_module_t *) self;
downmix_object_t *pDownmixer;
int retsize;

if (pDwmModule == NULL || pDwmModule->context.state == DOWNMIX_STATE_UNINITIALIZED) {
return -EINVAL;
}

pDownmixer = (downmix_object_t*) &pDwmModule->context;

ALOGV("Downmix_Command command %" PRIu32 " cmdSize %" PRIu32, cmdCode, cmdSize);


switch (cmdCode) {
case EFFECT_CMD_INIT:
        if (pReplyData == NULL || *replySize != sizeof(int)) {
return -EINVAL;
}
*(int *) pReplyData = Downmix_Init(pDwmModule);
break;


case EFFECT_CMD_SET_CONFIG:
if (pCmdData == NULL || cmdSize != sizeof(effect_config_t)
                || pReplyData == NULL || *replySize != sizeof(int)) {
return -EINVAL;
}
*(int *) pReplyData = Downmix_Configure(pDwmModule,
(effect_config_t *)pCmdData, false);
break;

case EFFECT_CMD_RESET:
Downmix_Reset(pDownmixer, false);
break;

case EFFECT_CMD_GET_PARAM:

ALOGV("Downmix_Command EFFECT_CMD_GET_PARAM pCmdData %p, *replySize %" PRIu32 ", pReplyData: %p",
pCmdData, *replySize, pReplyData);
if (pCmdData == NULL || cmdSize < (int)(sizeof(effect_param_t) + sizeof(int32_t)) ||
                pReplyData == NULL ||
*replySize < (int) sizeof(effect_param_t) + 2 * sizeof(int32_t)) {
return -EINVAL;
}
effect_param_t *rep = (effect_param_t *) pReplyData;
memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + sizeof(int32_t));
ALOGV("Downmix_Command EFFECT_CMD_GET_PARAM param %" PRId32 ", replySize %" PRIu32,
*(int32_t *)rep->data, rep->vsize);
rep->status = Downmix_getParameter(pDownmixer, *(int32_t *)rep->data, &rep->vsize,
rep->data + sizeof(int32_t));
*replySize = sizeof(effect_param_t) + sizeof(int32_t) + rep->vsize;
break;

case EFFECT_CMD_SET_PARAM:

ALOGV("Downmix_Command EFFECT_CMD_SET_PARAM cmdSize %d pCmdData %p, *replySize %" PRIu32
", pReplyData %p", cmdSize, pCmdData, *replySize, pReplyData);
if (pCmdData == NULL || (cmdSize < (int)(sizeof(effect_param_t) + sizeof(int32_t)))
                || pReplyData == NULL || *replySize != (int)sizeof(int32_t)) {
return -EINVAL;
}
effect_param_t *cmd = (effect_param_t *) pCmdData;
*(int *)pReplyData = Downmix_setParameter(pDownmixer, *(int32_t *)cmd->data,
cmd->vsize, cmd->data + sizeof(int32_t));
break;

case EFFECT_CMD_SET_PARAM_DEFERRED:
//FIXME implement
ALOGW("Downmix_Command command EFFECT_CMD_SET_PARAM_DEFERRED not supported, FIXME");
break;

case EFFECT_CMD_SET_PARAM_COMMIT:
//FIXME implement
ALOGW("Downmix_Command command EFFECT_CMD_SET_PARAM_COMMIT not supported, FIXME");

break;

case EFFECT_CMD_ENABLE:
        if (pReplyData == NULL || *replySize != sizeof(int)) {
return -EINVAL;
}
if (pDownmixer->state != DOWNMIX_STATE_INITIALIZED) {
return -ENOSYS;
}
pDownmixer->state = DOWNMIX_STATE_ACTIVE;
ALOGV("EFFECT_CMD_ENABLE() OK");
*(int *)pReplyData = 0;

break;

case EFFECT_CMD_DISABLE:
        if (pReplyData == NULL || *replySize != sizeof(int)) {
return -EINVAL;
}
if (pDownmixer->state != DOWNMIX_STATE_ACTIVE) {
return -ENOSYS;
}
pDownmixer->state = DOWNMIX_STATE_INITIALIZED;
ALOGV("EFFECT_CMD_DISABLE() OK");
*(int *)pReplyData = 0;
break;

case EFFECT_CMD_SET_DEVICE:
if (pCmdData == NULL || cmdSize != (int)sizeof(uint32_t)) {
return -EINVAL;
}
// FIXME change type if playing on headset vs speaker
ALOGV("Downmix_Command EFFECT_CMD_SET_DEVICE: 0x%08" PRIx32, *(uint32_t *)pCmdData);
break;

case EFFECT_CMD_SET_VOLUME: {
// audio output is always stereo => 2 channel volumes
if (pCmdData == NULL || cmdSize != (int)sizeof(uint32_t) * 2) {
return -EINVAL;
}
// FIXME change volume
ALOGW("Downmix_Command command EFFECT_CMD_SET_VOLUME not supported, FIXME");
float left = (float)(*(uint32_t *)pCmdData) / (1 << 24);
float right = (float)(*((uint32_t *)pCmdData + 1)) / (1 << 24);
ALOGV("Downmix_Command EFFECT_CMD_SET_VOLUME: left %f, right %f ", left, right);
break;
}

case EFFECT_CMD_SET_AUDIO_MODE:
if (pCmdData == NULL || cmdSize != (int)sizeof(uint32_t)) {
return -EINVAL;
}
ALOGV("Downmix_Command EFFECT_CMD_SET_AUDIO_MODE: %" PRIu32, *(uint32_t *)pCmdData);
break;

case EFFECT_CMD_SET_CONFIG_REVERSE:
case EFFECT_CMD_SET_INPUT_DEVICE:
// these commands are ignored by a downmix effect
break;

default:
ALOGW("Downmix_Command invalid command %" PRIu32, cmdCode);
return -EINVAL;
}

return 0;
}

int VisualizerLib_Create(const effect_uuid_t *uuid,
 int32_t /*sessionId*/,
 int32_t /*ioId*/,
 effect_handle_t *pHandle) {
 int ret;
 int i;

 if (pHandle == NULL || uuid == NULL) {
 return -EINVAL;
 }

 if (memcmp(uuid, &gVisualizerDescriptor.uuid, sizeof(effect_uuid_t)) != 0) {
 return -EINVAL;
 }

 VisualizerContext *pContext = new VisualizerContext;

    pContext->mItfe = &gVisualizerInterface;
    pContext->mState = VISUALIZER_STATE_UNINITIALIZED;

    ret = Visualizer_init(pContext);
 if (ret < 0) {
        ALOGW("VisualizerLib_Create() init failed");
 delete pContext;
 return ret;
 }

 *pHandle = (effect_handle_t)pContext;

    pContext->mState = VISUALIZER_STATE_INITIALIZED;

    ALOGV("VisualizerLib_Create %p", pContext);

 return 0;

}

int32_t EqualizerGetBand(EffectContext *pContext __unused, uint32_t targetFreq){
 int band = 0;

 if(targetFreq < bandFreqRange[0][0]){
 return -EINVAL;
 }else if(targetFreq == bandFreqRange[0][0]){
 return 0;
 }
 for(int i=0; i<FIVEBAND_NUMBANDS;i++){
 if((targetFreq > bandFreqRange[i][0])&&(targetFreq <= bandFreqRange[i][1])){
            band = i;
 }
 }
 return band;
}

int AecGetParameter(preproc_effect_t *effect,
 void *pParam,
 uint32_t *pValueSize,
 void *pValue)
{
 int status = 0;
 uint32_t param = *(uint32_t *)pParam;

 if (*pValueSize < sizeof(uint32_t)) {
 return -EINVAL;
 }
 switch (param) {
 case AEC_PARAM_ECHO_DELAY:
 case AEC_PARAM_PROPERTIES:
 *(uint32_t *)pValue = 1000 * effect->session->apm->stream_delay_ms();
        ALOGV("AecGetParameter() echo delay %d us", *(uint32_t *)pValue);
 break;
 default:
        ALOGW("AecGetParameter() unknown param %08x value %08x", param, *(uint32_t *)pValue);
        status = -EINVAL;
 break;
 }
 return status;
}

int16_t VolumeConvertStereoPosition(int16_t position){
 int16_t convertedPosition = 0;

    convertedPosition = (int16_t)(((float)position/1000)*96);
 return convertedPosition;

}

int AecCreate(preproc_effect_t *effect)
{
    webrtc::EchoControlMobile *aec = effect->session->apm->echo_control_mobile();
    ALOGV("AecCreate got aec %p", aec);
 if (aec == NULL) {
        ALOGW("AgcCreate Error");
 return -ENOMEM;
 }
    effect->engine = static_cast<preproc_fx_handle_t>(aec);
 AecInit (effect);
 return 0;
}

void ReverbSetReverbLevel(ReverbContext *pContext, int16_t level){

    LVREV_ControlParams_st    ActiveParams; /* Current control Parameters */
    LVREV_ReturnStatus_en     LvmStatus=LVREV_SUCCESS; /* Function call status */
    LVM_INT32                 CombinedLevel; // Sum of room and reverb level controls

 /* Get the current settings */
 LvmStatus = LVREV_GetControlParameters(pContext->hInstance, &ActiveParams);
    LVM_ERROR_CHECK(LvmStatus, "LVREV_GetControlParameters", "ReverbSetReverbLevel")

 CombinedLevel = (level + pContext->SavedRoomLevel)-LVREV_MAX_REVERB_LEVEL;

 ActiveParams.Level = ReverbConvertLevel(CombinedLevel);


 /* Activate the initial settings */
 LvmStatus = LVREV_SetControlParameters(pContext->hInstance, &ActiveParams);
    LVM_ERROR_CHECK(LvmStatus, "LVREV_SetControlParameters", "ReverbSetReverbLevel")

    pContext->SavedReverbLevel = level;
 return;
}

int Visualizer_getDescriptor(effect_handle_t   self,
 effect_descriptor_t *pDescriptor)
{
 VisualizerContext * pContext = (VisualizerContext *) self;

 if (pContext == NULL || pDescriptor == NULL) {
        ALOGV("Visualizer_getDescriptor() invalid param");
 return -EINVAL;
 }

 *pDescriptor = gVisualizerDescriptor;

 return 0;
} /* end Visualizer_getDescriptor */

int16_t LVC_Convert_VolToDb(uint32_t vol){
 int16_t  dB;

    dB = LVC_ToDB_s32Tos16(vol <<7);
    dB = (dB +8)>>4;
    dB = (dB <-96) ? -96 : dB ;

 return dB;
}

void LE_getConfig(LoudnessEnhancerContext *pContext, effect_config_t *pConfig)
{
 *pConfig = pContext->mConfig;
}

extern "C" int EffectGetDescriptor(const effect_uuid_t *uuid,
 effect_descriptor_t *pDescriptor) {
 const effect_descriptor_t *desc = NULL;

 if (pDescriptor == NULL || uuid == NULL){
        ALOGV("EffectGetDescriptor() called with NULL pointer");
 return -EINVAL;
 }

 if (memcmp(uuid, &gBassBoostDescriptor.uuid, sizeof(effect_uuid_t)) == 0) {
        desc = &gBassBoostDescriptor;
 } else if (memcmp(uuid, &gVirtualizerDescriptor.uuid, sizeof(effect_uuid_t)) == 0) {
        desc = &gVirtualizerDescriptor;
 } else if (memcmp(uuid, &gEqualizerDescriptor.uuid, sizeof(effect_uuid_t)) == 0) {
        desc = &gEqualizerDescriptor;
 } else if (memcmp(uuid, &gVolumeDescriptor.uuid, sizeof(effect_uuid_t)) == 0) {
        desc = &gVolumeDescriptor;
 }

 if (desc == NULL) {
 return -EINVAL;
 }

 *pDescriptor = *desc;

 return 0;
} /* end EffectGetDescriptor */

int AecSetParameter (preproc_effect_t *effect, void *pParam, void *pValue)
{
 int status = 0;
 uint32_t param = *(uint32_t *)pParam;
 uint32_t value = *(uint32_t *)pValue;

 switch (param) {
 case AEC_PARAM_ECHO_DELAY:
 case AEC_PARAM_PROPERTIES:
        status = effect->session->apm->set_stream_delay_ms(value/1000);
        ALOGV("AecSetParameter() echo delay %d us, status %d", value, status);
 break;
 default:
        ALOGW("AecSetParameter() unknown param %08x value %08x", param, *(uint32_t *)pValue);
        status = -EINVAL;
 break;
 }
 return status;
}

int Visualizer_command(effect_handle_t self, uint32_t cmdCode, uint32_t cmdSize,
void *pCmdData, uint32_t *replySize, void *pReplyData) {

VisualizerContext * pContext = (VisualizerContext *)self;
int retsize;

if (pContext == NULL || pContext->mState == VISUALIZER_STATE_UNINITIALIZED) {
return -EINVAL;
}

//    ALOGV("Visualizer_command command %" PRIu32 " cmdSize %" PRIu32, cmdCode, cmdSize);


switch (cmdCode) {
case EFFECT_CMD_INIT:
        if (pReplyData == NULL || *replySize != sizeof(int)) {
return -EINVAL;
}
*(int *) pReplyData = Visualizer_init(pContext);
break;
case EFFECT_CMD_SET_CONFIG:
if (pCmdData == NULL || cmdSize != sizeof(effect_config_t)
                || pReplyData == NULL || *replySize != sizeof(int)) {
return -EINVAL;
}
*(int *) pReplyData = Visualizer_setConfig(pContext,
(effect_config_t *) pCmdData);
break;
case EFFECT_CMD_GET_CONFIG:
        if (pReplyData == NULL ||
*replySize != sizeof(effect_config_t)) {
return -EINVAL;
}
Visualizer_getConfig(pContext, (effect_config_t *)pReplyData);
break;
case EFFECT_CMD_RESET:

Visualizer_reset(pContext);
break;
case EFFECT_CMD_ENABLE:
        if (pReplyData == NULL || *replySize != sizeof(int)) {
return -EINVAL;
}
if (pContext->mState != VISUALIZER_STATE_INITIALIZED) {
return -ENOSYS;
}
pContext->mState = VISUALIZER_STATE_ACTIVE;
ALOGV("EFFECT_CMD_ENABLE() OK");

*(int *)pReplyData = 0;
break;
case EFFECT_CMD_DISABLE:
        if (pReplyData == NULL || *replySize != sizeof(int)) {
return -EINVAL;
}
if (pContext->mState != VISUALIZER_STATE_ACTIVE) {
return -ENOSYS;
}
pContext->mState = VISUALIZER_STATE_INITIALIZED;
ALOGV("EFFECT_CMD_DISABLE() OK");
*(int *)pReplyData = 0;
break;

case EFFECT_CMD_GET_PARAM: {
if (pCmdData == NULL ||
cmdSize != (int)(sizeof(effect_param_t) + sizeof(uint32_t)) ||
            pReplyData == NULL ||
*replySize < (int)(sizeof(effect_param_t) + sizeof(uint32_t) + sizeof(uint32_t))) {
return -EINVAL;
}
memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + sizeof(uint32_t));
effect_param_t *p = (effect_param_t *)pReplyData;
p->status = 0;
*replySize = sizeof(effect_param_t) + sizeof(uint32_t);
if (p->psize != sizeof(uint32_t)) {
p->status = -EINVAL;
break;
}
switch (*(uint32_t *)p->data) {
case VISUALIZER_PARAM_CAPTURE_SIZE:
ALOGV("get mCaptureSize = %" PRIu32, pContext->mCaptureSize);
*((uint32_t *)p->data + 1) = pContext->mCaptureSize;
p->vsize = sizeof(uint32_t);
*replySize += sizeof(uint32_t);
break;
case VISUALIZER_PARAM_SCALING_MODE:
ALOGV("get mScalingMode = %" PRIu32, pContext->mScalingMode);
*((uint32_t *)p->data + 1) = pContext->mScalingMode;
p->vsize = sizeof(uint32_t);
*replySize += sizeof(uint32_t);
break;
case VISUALIZER_PARAM_MEASUREMENT_MODE:
ALOGV("get mMeasurementMode = %" PRIu32, pContext->mMeasurementMode);
*((uint32_t *)p->data + 1) = pContext->mMeasurementMode;
p->vsize = sizeof(uint32_t);
*replySize += sizeof(uint32_t);
break;
default:
p->status = -EINVAL;
}
} break;

case EFFECT_CMD_SET_PARAM: {
if (pCmdData == NULL ||
cmdSize != (int)(sizeof(effect_param_t) + sizeof(uint32_t) + sizeof(uint32_t)) ||
            pReplyData == NULL || *replySize != sizeof(int32_t)) {
return -EINVAL;
}
*(int32_t *)pReplyData = 0;
effect_param_t *p = (effect_param_t *)pCmdData;
if (p->psize != sizeof(uint32_t) || p->vsize != sizeof(uint32_t)) {
*(int32_t *)pReplyData = -EINVAL;
break;
}
switch (*(uint32_t *)p->data) {
case VISUALIZER_PARAM_CAPTURE_SIZE:
pContext->mCaptureSize = *((uint32_t *)p->data + 1);
ALOGV("set mCaptureSize = %" PRIu32, pContext->mCaptureSize);
break;
case VISUALIZER_PARAM_SCALING_MODE:
pContext->mScalingMode = *((uint32_t *)p->data + 1);
ALOGV("set mScalingMode = %" PRIu32, pContext->mScalingMode);
break;
case VISUALIZER_PARAM_LATENCY:
pContext->mLatency = *((uint32_t *)p->data + 1);
ALOGV("set mLatency = %" PRIu32, pContext->mLatency);
break;
case VISUALIZER_PARAM_MEASUREMENT_MODE:
pContext->mMeasurementMode = *((uint32_t *)p->data + 1);
ALOGV("set mMeasurementMode = %" PRIu32, pContext->mMeasurementMode);
break;
default:
*(int32_t *)pReplyData = -EINVAL;
}
} break;
case EFFECT_CMD_SET_DEVICE:
case EFFECT_CMD_SET_VOLUME:
case EFFECT_CMD_SET_AUDIO_MODE:
break;



case VISUALIZER_CMD_CAPTURE: {
uint32_t captureSize = pContext->mCaptureSize;
        if (pReplyData == NULL || *replySize != captureSize) {
ALOGV("VISUALIZER_CMD_CAPTURE() error *replySize %" PRIu32 " captureSize %" PRIu32,
*replySize, captureSize);
return -EINVAL;
}
if (pContext->mState == VISUALIZER_STATE_ACTIVE) {
const uint32_t deltaMs = Visualizer_getDeltaTimeMsFromUpdatedTime(pContext);

// if audio framework has stopped playing audio although the effect is still
// active we must clear the capture buffer to return silence
if ((pContext->mLastCaptureIdx == pContext->mCaptureIdx) &&
(pContext->mBufferUpdateTime.tv_sec != 0) &&
(deltaMs > MAX_STALL_TIME_MS)) {
ALOGV("capture going to idle");
pContext->mBufferUpdateTime.tv_sec = 0;
memset(pReplyData, 0x80, captureSize);
} else {
int32_t latencyMs = pContext->mLatency;
latencyMs -= deltaMs;
if (latencyMs < 0) {
latencyMs = 0;
}
const uint32_t deltaSmpl =
pContext->mConfig.inputCfg.samplingRate * latencyMs / 1000;
int32_t capturePoint = pContext->mCaptureIdx - captureSize - deltaSmpl;

if (capturePoint < 0) {
uint32_t size = -capturePoint;
if (size > captureSize) {
size = captureSize;
}
memcpy(pReplyData,
pContext->mCaptureBuf + CAPTURE_BUF_SIZE + capturePoint,
size);
pReplyData = (char *)pReplyData + size;
captureSize -= size;
capturePoint = 0;
}
memcpy(pReplyData,
pContext->mCaptureBuf + capturePoint,
captureSize);
}

pContext->mLastCaptureIdx = pContext->mCaptureIdx;
} else {
memset(pReplyData, 0x80, captureSize);
}

} break;

case VISUALIZER_CMD_MEASURE: {
uint16_t peakU16 = 0;
float sumRmsSquared = 0.0f;
uint8_t nbValidMeasurements = 0;
// reset measurements if last measurement was too long ago (which implies stored
// measurements aren't relevant anymore and shouldn't bias the new one)
const int32_t delayMs = Visualizer_getDeltaTimeMsFromUpdatedTime(pContext);
if (delayMs > DISCARD_MEASUREMENTS_TIME_MS) {
ALOGV("Discarding measurements, last measurement is %" PRId32 "ms old", delayMs);
for (uint32_t i=0 ; i<pContext->mMeasurementWindowSizeInBuffers ; i++) {
pContext->mPastMeasurements[i].mIsValid = false;
pContext->mPastMeasurements[i].mPeakU16 = 0;
pContext->mPastMeasurements[i].mRmsSquared = 0;
}
pContext->mMeasurementBufferIdx = 0;
} else {
// only use actual measurements, otherwise the first RMS measure happening before
// MEASUREMENT_WINDOW_MAX_SIZE_IN_BUFFERS have been played will always be artificially
// low
for (uint32_t i=0 ; i < pContext->mMeasurementWindowSizeInBuffers ; i++) {
if (pContext->mPastMeasurements[i].mIsValid) {
if (pContext->mPastMeasurements[i].mPeakU16 > peakU16) {
peakU16 = pContext->mPastMeasurements[i].mPeakU16;
}
sumRmsSquared += pContext->mPastMeasurements[i].mRmsSquared;
nbValidMeasurements++;
}
}
}
float rms = nbValidMeasurements == 0 ? 0.0f : sqrtf(sumRmsSquared / nbValidMeasurements);
int32_t* pIntReplyData = (int32_t*)pReplyData;
// convert from I16 sample values to mB and write results
if (rms < 0.000016f) {
pIntReplyData[MEASUREMENT_IDX_RMS] = -9600; //-96dB
} else {
pIntReplyData[MEASUREMENT_IDX_RMS] = (int32_t) (2000 * log10(rms / 32767.0f));
}
if (peakU16 == 0) {
pIntReplyData[MEASUREMENT_IDX_PEAK] = -9600; //-96dB
} else {
pIntReplyData[MEASUREMENT_IDX_PEAK] = (int32_t) (2000 * log10(peakU16 / 32767.0f));
}
ALOGV("VISUALIZER_CMD_MEASURE peak=%" PRIu16 " (%" PRId32 "mB), rms=%.1f (%" PRId32 "mB)",
peakU16, pIntReplyData[MEASUREMENT_IDX_PEAK],
rms, pIntReplyData[MEASUREMENT_IDX_RMS]);
}
break;

default:
ALOGW("Visualizer_command invalid command %" PRIu32, cmdCode);
return -EINVAL;
}

return 0;
}

int AecSetDevice(preproc_effect_t *effect, uint32_t device)
{
    ALOGV("AecSetDevice %08x", device);
    webrtc::EchoControlMobile *aec = static_cast<webrtc::EchoControlMobile *>(effect->engine);
    webrtc::EchoControlMobile::RoutingMode mode = webrtc::EchoControlMobile::kQuietEarpieceOrHeadset;

 if (audio_is_input_device(device)) {
 return 0;
 }

 switch(device) {
 case AUDIO_DEVICE_OUT_EARPIECE:
        mode = webrtc::EchoControlMobile::kEarpiece;
 break;
 case AUDIO_DEVICE_OUT_SPEAKER:
        mode = webrtc::EchoControlMobile::kSpeakerphone;
 break;
 case AUDIO_DEVICE_OUT_WIRED_HEADSET:
 case AUDIO_DEVICE_OUT_WIRED_HEADPHONE:
 default:
 break;
 }
    aec->set_routing_mode(mode);
 return 0;
}

int16_t ReverbGetRoomHfLevel(ReverbContext *pContext){
 int16_t level;

    LVREV_ControlParams_st    ActiveParams; /* Current control Parameters */
    LVREV_ReturnStatus_en     LvmStatus=LVREV_SUCCESS; /* Function call status */

 /* Get the current settings */
 LvmStatus = LVREV_GetControlParameters(pContext->hInstance, &ActiveParams);
    LVM_ERROR_CHECK(LvmStatus, "LVREV_GetControlParameters", "ReverbGetRoomHfLevel")

    level = ReverbConvertHfLevel(pContext->SavedHfLevel);


 if(ActiveParams.LPF != level){
        ALOGV("\tLVM_ERROR : (ignore at start up) ReverbGetRoomHfLevel() has wrong level -> %d %d\n",
 ActiveParams.Level, level);
 }

 return pContext->SavedHfLevel;
}

int VolumeSetStereoPosition(EffectContext *pContext, int16_t position){

 LVM_ControlParams_t ActiveParams; /* Current control Parameters */
    LVM_ReturnStatus_en     LvmStatus=LVM_SUCCESS; /* Function call status */
    LVM_INT16               Balance = 0;



    pContext->pBundledContext->positionSaved = position;
 Balance = VolumeConvertStereoPosition(pContext->pBundledContext->positionSaved);


 if(pContext->pBundledContext->bStereoPositionEnabled == LVM_TRUE){

        pContext->pBundledContext->positionSaved = position;
 /* Get the current settings */
 LvmStatus = LVM_GetControlParameters(pContext->pBundledContext->hInstance, &ActiveParams);
        LVM_ERROR_CHECK(LvmStatus, "LVM_GetControlParameters", "VolumeSetStereoPosition")
 if(LvmStatus != LVM_SUCCESS) return -EINVAL;

 /* Volume parameters */
 ActiveParams.VC_Balance  = Balance;

 /* Activate the initial settings */
 LvmStatus = LVM_SetControlParameters(pContext->pBundledContext->hInstance, &ActiveParams);
        LVM_ERROR_CHECK(LvmStatus, "LVM_SetControlParameters", "VolumeSetStereoPosition")
 if(LvmStatus != LVM_SUCCESS) return -EINVAL;


 /* Get the current settings */
 LvmStatus = LVM_GetControlParameters(pContext->pBundledContext->hInstance, &ActiveParams);
        LVM_ERROR_CHECK(LvmStatus, "LVM_GetControlParameters", "VolumeSetStereoPosition")
 if(LvmStatus != LVM_SUCCESS) return -EINVAL;
 }
 else{
 }
 return 0;
} /* end VolumeSetStereoPosition */

int LE_getDescriptor(effect_handle_t   self,
 effect_descriptor_t *pDescriptor)
{
 LoudnessEnhancerContext * pContext = (LoudnessEnhancerContext *) self;

 if (pContext == NULL || pDescriptor == NULL) {
        ALOGV("LE_getDescriptor() invalid param");
 return -EINVAL;
 }

 *pDescriptor = gLEDescriptor;

 return 0;
} /* end LE_getDescriptor */

int Downmix_Init(downmix_module_t *pDwmModule) {

    ALOGV("Downmix_Init module %p", pDwmModule);
 int ret = 0;

    memset(&pDwmModule->context, 0, sizeof(downmix_object_t));

    pDwmModule->config.inputCfg.accessMode = EFFECT_BUFFER_ACCESS_READ;
    pDwmModule->config.inputCfg.format = AUDIO_FORMAT_PCM_16_BIT;
    pDwmModule->config.inputCfg.channels = AUDIO_CHANNEL_OUT_7POINT1;
    pDwmModule->config.inputCfg.bufferProvider.getBuffer = NULL;
    pDwmModule->config.inputCfg.bufferProvider.releaseBuffer = NULL;
    pDwmModule->config.inputCfg.bufferProvider.cookie = NULL;
    pDwmModule->config.inputCfg.mask = EFFECT_CONFIG_ALL;

    pDwmModule->config.inputCfg.samplingRate = 44100;
    pDwmModule->config.outputCfg.samplingRate = pDwmModule->config.inputCfg.samplingRate;

    pDwmModule->config.outputCfg.accessMode = EFFECT_BUFFER_ACCESS_ACCUMULATE;
    pDwmModule->config.outputCfg.format = AUDIO_FORMAT_PCM_16_BIT;
    pDwmModule->config.outputCfg.channels = AUDIO_CHANNEL_OUT_STEREO;
    pDwmModule->config.outputCfg.bufferProvider.getBuffer = NULL;
    pDwmModule->config.outputCfg.bufferProvider.releaseBuffer = NULL;
    pDwmModule->config.outputCfg.bufferProvider.cookie = NULL;
    pDwmModule->config.outputCfg.mask = EFFECT_CONFIG_ALL;

    ret = Downmix_Configure(pDwmModule, &pDwmModule->config, true);
 if (ret != 0) {
        ALOGV("Downmix_Init error %d on module %p", ret, pDwmModule);
 } else {
        pDwmModule->context.state = DOWNMIX_STATE_INITIALIZED;
 }

 return ret;
}

int Effect_command(effect_handle_t  self,
uint32_t            cmdCode,
uint32_t            cmdSize,
void *pCmdData,
uint32_t *replySize,
void *pReplyData){
EffectContext * pContext = (EffectContext *) self;
int retsize;

//ALOGV("\t\nEffect_command start");

if(pContext->EffectType == LVM_BASS_BOOST){
//ALOGV("\tEffect_command setting command for LVM_BASS_BOOST");
}
if(pContext->EffectType == LVM_VIRTUALIZER){
//ALOGV("\tEffect_command setting command for LVM_VIRTUALIZER");
}
if(pContext->EffectType == LVM_EQUALIZER){
//ALOGV("\tEffect_command setting command for LVM_EQUALIZER");
}
if(pContext->EffectType == LVM_VOLUME){
//ALOGV("\tEffect_command setting command for LVM_VOLUME");
}

if (pContext == NULL){
ALOGV("\tLVM_ERROR : Effect_command ERROR pContext == NULL");
return -EINVAL;
}

//ALOGV("\tEffect_command INPUTS are: command %d cmdSize %d",cmdCode, cmdSize);

// Incase we disable an effect, next time process is
// called the number of effect called could be greater
// pContext->pBundledContext->NumberEffectsCalled = 0;

//ALOGV("\tEffect_command NumberEffectsCalled = %d, NumberEffectsEnabled = %d",
//        pContext->pBundledContext->NumberEffectsCalled,
//        pContext->pBundledContext->NumberEffectsEnabled);


switch (cmdCode){
case EFFECT_CMD_INIT:
            if (pReplyData == NULL || *replySize != sizeof(int)){
ALOGV("\tLVM_ERROR, EFFECT_CMD_INIT: ERROR for effect type %d",
pContext->EffectType);
return -EINVAL;
}
*(int *) pReplyData = 0;
//ALOGV("\tEffect_command cmdCode Case: EFFECT_CMD_INIT start");
if(pContext->EffectType == LVM_BASS_BOOST){
//ALOGV("\tEffect_command cmdCode Case: EFFECT_CMD_INIT for LVM_BASS_BOOST");
android::BassSetStrength(pContext, 0);
}
if(pContext->EffectType == LVM_VIRTUALIZER){
//ALOGV("\tEffect_command cmdCode Case: EFFECT_CMD_INIT for LVM_VIRTUALIZER");
android::VirtualizerSetStrength(pContext, 0);
}
if(pContext->EffectType == LVM_EQUALIZER){
//ALOGV("\tEffect_command cmdCode Case: EFFECT_CMD_INIT for LVM_EQUALIZER");
android::EqualizerSetPreset(pContext, 0);
}
if(pContext->EffectType == LVM_VOLUME){
//ALOGV("\tEffect_command cmdCode Case: EFFECT_CMD_INIT for LVM_VOLUME");
*(int *) pReplyData = android::VolumeSetVolumeLevel(pContext, 0);
}
break;


case EFFECT_CMD_SET_CONFIG:
//ALOGV("\tEffect_command cmdCode Case: EFFECT_CMD_SET_CONFIG start");
            if (pCmdData    == NULL||
                cmdSize     != sizeof(effect_config_t)||
                pReplyData  == NULL||
                *replySize  != sizeof(int)){
ALOGV("\tLVM_ERROR : Effect_command cmdCode Case: "
"EFFECT_CMD_SET_CONFIG: ERROR");
return -EINVAL;
}
*(int *) pReplyData = android::Effect_setConfig(pContext, (effect_config_t *) pCmdData);
//ALOGV("\tEffect_command cmdCode Case: EFFECT_CMD_SET_CONFIG end");

break;

case EFFECT_CMD_GET_CONFIG:
            if (pReplyData == NULL ||
                *replySize != sizeof(effect_config_t)) {
ALOGV("\tLVM_ERROR : Effect_command cmdCode Case: "
"EFFECT_CMD_GET_CONFIG: ERROR");
return -EINVAL;
}

android::Effect_getConfig(pContext, (effect_config_t *)pReplyData);
break;

case EFFECT_CMD_RESET:
//ALOGV("\tEffect_command cmdCode Case: EFFECT_CMD_RESET start");
android::Effect_setConfig(pContext, &pContext->config);
//ALOGV("\tEffect_command cmdCode Case: EFFECT_CMD_RESET end");
break;


case EFFECT_CMD_GET_PARAM:{
//ALOGV("\tEffect_command cmdCode Case: EFFECT_CMD_GET_PARAM start");

if(pContext->EffectType == LVM_BASS_BOOST){
                if (pCmdData == NULL ||
                        cmdSize < (sizeof(effect_param_t) + sizeof(int32_t)) ||
                        pReplyData == NULL ||
                        *replySize < (sizeof(effect_param_t) + sizeof(int32_t))){
                    ALOGV("\tLVM_ERROR : BassBoost_command cmdCode Case: "
                            "EFFECT_CMD_GET_PARAM: ERROR");
                    return -EINVAL;
                }
                effect_param_t *p = (effect_param_t *)pCmdData;
                memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + p->psize);
                p = (effect_param_t *)pReplyData;
                int voffset = ((p->psize - 1) / sizeof(int32_t) + 1) * sizeof(int32_t);
p->status = android::BassBoost_getParameter(pContext,
p->data,
&p->vsize,
p->data + voffset);
                *replySize = sizeof(effect_param_t) + voffset + p->vsize;
//ALOGV("\tBassBoost_command EFFECT_CMD_GET_PARAM "
//        "*pCmdData %d, *replySize %d, *pReplyData %d ",
//        *(int32_t *)((char *)pCmdData + sizeof(effect_param_t)),
//        *replySize,
//        *(int16_t *)((char *)pReplyData + sizeof(effect_param_t) + voffset));

}

if(pContext->EffectType == LVM_VIRTUALIZER){
                if (pCmdData == NULL ||
                        cmdSize < (sizeof(effect_param_t) + sizeof(int32_t)) ||
                        pReplyData == NULL ||
                        *replySize < (sizeof(effect_param_t) + sizeof(int32_t))){
                    ALOGV("\tLVM_ERROR : Virtualizer_command cmdCode Case: "
                            "EFFECT_CMD_GET_PARAM: ERROR");
                    return -EINVAL;
                }
                effect_param_t *p = (effect_param_t *)pCmdData;
                memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + p->psize);
                p = (effect_param_t *)pReplyData;
                int voffset = ((p->psize - 1) / sizeof(int32_t) + 1) * sizeof(int32_t);
p->status = android::Virtualizer_getParameter(pContext,
(void *)p->data,
&p->vsize,
p->data + voffset);
                *replySize = sizeof(effect_param_t) + voffset + p->vsize;

//ALOGV("\tVirtualizer_command EFFECT_CMD_GET_PARAM "
//        "*pCmdData %d, *replySize %d, *pReplyData %d ",
//        *(int32_t *)((char *)pCmdData + sizeof(effect_param_t)),
//        *replySize,
//        *(int16_t *)((char *)pReplyData + sizeof(effect_param_t) + voffset));
}

if(pContext->EffectType == LVM_EQUALIZER){
//ALOGV("\tEqualizer_command cmdCode Case: "
//        "EFFECT_CMD_GET_PARAM start");
                if (pCmdData == NULL ||
                    cmdSize < (sizeof(effect_param_t) + sizeof(int32_t)) ||
                    pReplyData == NULL ||
                    *replySize < (int) (sizeof(effect_param_t) + sizeof(int32_t))) {
                    ALOGV("\tLVM_ERROR : Equalizer_command cmdCode Case: "
                            "EFFECT_CMD_GET_PARAM");
                    return -EINVAL;
                }
                effect_param_t *p = (effect_param_t *)pCmdData;
                memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + p->psize);
                p = (effect_param_t *)pReplyData;
                int voffset = ((p->psize - 1) / sizeof(int32_t) + 1) * sizeof(int32_t);
p->status = android::Equalizer_getParameter(pContext,
p->data,
&p->vsize,
p->data + voffset);

                *replySize = sizeof(effect_param_t) + voffset + p->vsize;
//ALOGV("\tEqualizer_command EFFECT_CMD_GET_PARAM *pCmdData %d, *replySize %d, "
//       "*pReplyData %08x %08x",
//        *(int32_t *)((char *)pCmdData + sizeof(effect_param_t)), *replySize,
//        *(int32_t *)((char *)pReplyData + sizeof(effect_param_t) + voffset),
//        *(int32_t *)((char *)pReplyData + sizeof(effect_param_t) + voffset +
//        sizeof(int32_t)));

}
if(pContext->EffectType == LVM_VOLUME){
//ALOGV("\tVolume_command cmdCode Case: EFFECT_CMD_GET_PARAM start");
                if (pCmdData == NULL ||
                        cmdSize < (sizeof(effect_param_t) + sizeof(int32_t)) ||
                        pReplyData == NULL ||
                        *replySize < (int) (sizeof(effect_param_t) + sizeof(int32_t))){
                    ALOGV("\tLVM_ERROR : Volume_command cmdCode Case: "
                            "EFFECT_CMD_GET_PARAM: ERROR");
                    return -EINVAL;
                }
                effect_param_t *p = (effect_param_t *)pCmdData;
                memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + p->psize);
                p = (effect_param_t *)pReplyData;
                int voffset = ((p->psize - 1) / sizeof(int32_t) + 1) * sizeof(int32_t);
p->status = android::Volume_getParameter(pContext,
(void *)p->data,
&p->vsize,
p->data + voffset);

                *replySize = sizeof(effect_param_t) + voffset + p->vsize;
//ALOGV("\tVolume_command EFFECT_CMD_GET_PARAM "
//        "*pCmdData %d, *replySize %d, *pReplyData %d ",
//        *(int32_t *)((char *)pCmdData + sizeof(effect_param_t)),
//        *replySize,
//        *(int16_t *)((char *)pReplyData + sizeof(effect_param_t) + voffset));
}
//ALOGV("\tEffect_command cmdCode Case: EFFECT_CMD_GET_PARAM end");
} break;
case EFFECT_CMD_SET_PARAM:{
//ALOGV("\tEffect_command cmdCode Case: EFFECT_CMD_SET_PARAM start");
if(pContext->EffectType == LVM_BASS_BOOST){
//ALOGV("\tBassBoost_command EFFECT_CMD_SET_PARAM param %d, *replySize %d, value %d",
//       *(int32_t *)((char *)pCmdData + sizeof(effect_param_t)),

//       *replySize,
//       *(int16_t *)((char *)pCmdData + sizeof(effect_param_t) + sizeof(int32_t)));

                if (pCmdData   == NULL||
                    cmdSize    != (sizeof(effect_param_t) + sizeof(int32_t) +sizeof(int16_t))||
                    pReplyData == NULL||
                    *replySize != sizeof(int32_t)){
ALOGV("\tLVM_ERROR : BassBoost_command cmdCode Case: "
"EFFECT_CMD_SET_PARAM: ERROR");
return -EINVAL;
}
effect_param_t *p = (effect_param_t *) pCmdData;

if (p->psize != sizeof(int32_t)){
ALOGV("\tLVM_ERROR : BassBoost_command cmdCode Case: "
"EFFECT_CMD_SET_PARAM: ERROR, psize is not sizeof(int32_t)");
return -EINVAL;
}

//ALOGV("\tnBassBoost_command cmdSize is %d\n"
//        "\tsizeof(effect_param_t) is  %d\n"
//        "\tp->psize is %d\n"
//        "\tp->vsize is %d"
//        "\n",
//        cmdSize, sizeof(effect_param_t), p->psize, p->vsize );

*(int *)pReplyData = android::BassBoost_setParameter(pContext,
(void *)p->data,
p->data + p->psize);
}
if(pContext->EffectType == LVM_VIRTUALIZER){
// Warning this log will fail to properly read an int32_t value, assumes int16_t
//ALOGV("\tVirtualizer_command EFFECT_CMD_SET_PARAM param %d, *replySize %d, value %d",
//        *(int32_t *)((char *)pCmdData + sizeof(effect_param_t)),
//        *replySize,

//        *(int16_t *)((char *)pCmdData + sizeof(effect_param_t) + sizeof(int32_t)));

if (pCmdData   == NULL ||
                    // legal parameters are int16_t or int32_t
                    cmdSize    > (sizeof(effect_param_t) + sizeof(int32_t) +sizeof(int32_t)) ||
                    cmdSize    < (sizeof(effect_param_t) + sizeof(int32_t) +sizeof(int16_t)) ||
                    pReplyData == NULL ||
                    *replySize != sizeof(int32_t)){
ALOGV("\tLVM_ERROR : Virtualizer_command cmdCode Case: "
"EFFECT_CMD_SET_PARAM: ERROR");
return -EINVAL;
}
effect_param_t *p = (effect_param_t *) pCmdData;

if (p->psize != sizeof(int32_t)){
ALOGV("\tLVM_ERROR : Virtualizer_command cmdCode Case: "
"EFFECT_CMD_SET_PARAM: ERROR, psize is not sizeof(int32_t)");
return -EINVAL;
}

//ALOGV("\tnVirtualizer_command cmdSize is %d\n"
//        "\tsizeof(effect_param_t) is  %d\n"
//        "\tp->psize is %d\n"
//        "\tp->vsize is %d"
//        "\n",
//        cmdSize, sizeof(effect_param_t), p->psize, p->vsize );

*(int *)pReplyData = android::Virtualizer_setParameter(pContext,
(void *)p->data,
p->data + p->psize);
}
if(pContext->EffectType == LVM_EQUALIZER){
//ALOGV("\tEqualizer_command cmdCode Case: "
//        "EFFECT_CMD_SET_PARAM start");
//ALOGV("\tEqualizer_command EFFECT_CMD_SET_PARAM param %d, *replySize %d, value %d ",
//        *(int32_t *)((char *)pCmdData + sizeof(effect_param_t)),
//        *replySize,

//        *(int16_t *)((char *)pCmdData + sizeof(effect_param_t) + sizeof(int32_t)));

if (pCmdData == NULL || cmdSize < (sizeof(effect_param_t) + sizeof(int32_t)) ||
                    pReplyData == NULL || *replySize != sizeof(int32_t)) {
ALOGV("\tLVM_ERROR : Equalizer_command cmdCode Case: "
"EFFECT_CMD_SET_PARAM: ERROR");
return -EINVAL;
}
effect_param_t *p = (effect_param_t *) pCmdData;

*(int *)pReplyData = android::Equalizer_setParameter(pContext,
(void *)p->data,
p->data + p->psize);
}
if(pContext->EffectType == LVM_VOLUME){
//ALOGV("\tVolume_command cmdCode Case: EFFECT_CMD_SET_PARAM start");
//ALOGV("\tVolume_command EFFECT_CMD_SET_PARAM param %d, *replySize %d, value %d ",
//        *(int32_t *)((char *)pCmdData + sizeof(effect_param_t)),

//        *replySize,
//        *(int16_t *)((char *)pCmdData + sizeof(effect_param_t) +sizeof(int32_t)));

                if (    pCmdData   == NULL||
                        cmdSize    < (sizeof(effect_param_t) + sizeof(int32_t))||
                        pReplyData == NULL||
                        *replySize != sizeof(int32_t)){
ALOGV("\tLVM_ERROR : Volume_command cmdCode Case: "
"EFFECT_CMD_SET_PARAM: ERROR");
return -EINVAL;
}
effect_param_t *p = (effect_param_t *) pCmdData;

*(int *)pReplyData = android::Volume_setParameter(pContext,
(void *)p->data,
p->data + p->psize);
}
//ALOGV("\tEffect_command cmdCode Case: EFFECT_CMD_SET_PARAM end");
} break;


case EFFECT_CMD_ENABLE:
ALOGV("\tEffect_command cmdCode Case: EFFECT_CMD_ENABLE start");
            if (pReplyData == NULL || *replySize != sizeof(int)){
ALOGV("\tLVM_ERROR : Effect_command cmdCode Case: EFFECT_CMD_ENABLE: ERROR");
return -EINVAL;
}

*(int *)pReplyData = android::Effect_setEnabled(pContext, LVM_TRUE);
break;


case EFFECT_CMD_DISABLE:
//ALOGV("\tEffect_command cmdCode Case: EFFECT_CMD_DISABLE start");
            if (pReplyData == NULL || *replySize != sizeof(int)){
ALOGV("\tLVM_ERROR : Effect_command cmdCode Case: EFFECT_CMD_DISABLE: ERROR");
return -EINVAL;
}
*(int *)pReplyData = android::Effect_setEnabled(pContext, LVM_FALSE);
break;


case EFFECT_CMD_SET_DEVICE:
{
ALOGV("\tEffect_command cmdCode Case: EFFECT_CMD_SET_DEVICE start");
uint32_t device = *(uint32_t *)pCmdData;
pContext->pBundledContext->nOutputDevice = (audio_devices_t) device;

if (pContext->EffectType == LVM_BASS_BOOST) {
if((device == AUDIO_DEVICE_OUT_SPEAKER) ||
(device == AUDIO_DEVICE_OUT_BLUETOOTH_SCO_CARKIT) ||
(device == AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER)){
ALOGV("\tEFFECT_CMD_SET_DEVICE device is invalid for LVM_BASS_BOOST %d",
*(int32_t *)pCmdData);
ALOGV("\tEFFECT_CMD_SET_DEVICE temporary disable LVM_BAS_BOOST");

// If a device doesnt support bassboost the effect must be temporarily disabled
// the effect must still report its original state as this can only be changed
// by the ENABLE/DISABLE command

if (pContext->pBundledContext->bBassEnabled == LVM_TRUE) {
ALOGV("\tEFFECT_CMD_SET_DEVICE disable LVM_BASS_BOOST %d",
*(int32_t *)pCmdData);
android::LvmEffect_disable(pContext);
}
pContext->pBundledContext->bBassTempDisabled = LVM_TRUE;
} else {
ALOGV("\tEFFECT_CMD_SET_DEVICE device is valid for LVM_BASS_BOOST %d",
*(int32_t *)pCmdData);

// If a device supports bassboost and the effect has been temporarily disabled
// previously then re-enable it

if (pContext->pBundledContext->bBassEnabled == LVM_TRUE) {
ALOGV("\tEFFECT_CMD_SET_DEVICE re-enable LVM_BASS_BOOST %d",
*(int32_t *)pCmdData);
android::LvmEffect_enable(pContext);
}
pContext->pBundledContext->bBassTempDisabled = LVM_FALSE;
}
}
if (pContext->EffectType == LVM_VIRTUALIZER) {
if (pContext->pBundledContext->nVirtualizerForcedDevice == AUDIO_DEVICE_NONE) {
// default case unless configuration is forced
if (android::VirtualizerIsDeviceSupported(device) != 0) {
ALOGV("\tEFFECT_CMD_SET_DEVICE device is invalid for LVM_VIRTUALIZER %d",
*(int32_t *)pCmdData);
ALOGV("\tEFFECT_CMD_SET_DEVICE temporary disable LVM_VIRTUALIZER");

//If a device doesnt support virtualizer the effect must be temporarily
// disabled the effect must still report its original state as this can
// only be changed by the ENABLE/DISABLE command

if (pContext->pBundledContext->bVirtualizerEnabled == LVM_TRUE) {
ALOGV("\tEFFECT_CMD_SET_DEVICE disable LVM_VIRTUALIZER %d",
*(int32_t *)pCmdData);
android::LvmEffect_disable(pContext);
}
pContext->pBundledContext->bVirtualizerTempDisabled = LVM_TRUE;
} else {
ALOGV("\tEFFECT_CMD_SET_DEVICE device is valid for LVM_VIRTUALIZER %d",
*(int32_t *)pCmdData);

// If a device supports virtualizer and the effect has been temporarily
// disabled previously then re-enable it

if(pContext->pBundledContext->bVirtualizerEnabled == LVM_TRUE){
ALOGV("\tEFFECT_CMD_SET_DEVICE re-enable LVM_VIRTUALIZER %d",
*(int32_t *)pCmdData);
android::LvmEffect_enable(pContext);
}
pContext->pBundledContext->bVirtualizerTempDisabled = LVM_FALSE;
}
} // else virtualization mode is forced to a certain device, nothing to do
}
ALOGV("\tEffect_command cmdCode Case: EFFECT_CMD_SET_DEVICE end");
break;
}
case EFFECT_CMD_SET_VOLUME:
{
uint32_t leftVolume, rightVolume;
int16_t  leftdB, rightdB;
int16_t  maxdB, pandB;
int32_t  vol_ret[2] = {1<<24,1<<24}; // Apply no volume
int      status = 0;
LVM_ControlParams_t ActiveParams; /* Current control Parameters */
LVM_ReturnStatus_en     LvmStatus=LVM_SUCCESS; /* Function call status */

// if pReplyData is NULL, VOL_CTRL is delegated to another effect
if(pReplyData == LVM_NULL){

break;
}

            if (pCmdData == NULL ||
                cmdSize != 2 * sizeof(uint32_t)) {
ALOGV("\tLVM_ERROR : Effect_command cmdCode Case: "
"EFFECT_CMD_SET_VOLUME: ERROR");
return -EINVAL;
}

leftVolume  = ((*(uint32_t *)pCmdData));
rightVolume = ((*((uint32_t *)pCmdData + 1)));

if(leftVolume == 0x1000000){
leftVolume -= 1;
}
if(rightVolume == 0x1000000){
rightVolume -= 1;
}

// Convert volume to dB
leftdB  = android::LVC_Convert_VolToDb(leftVolume);
rightdB = android::LVC_Convert_VolToDb(rightVolume);

pandB = rightdB - leftdB;

// Calculate max volume in dB
maxdB = leftdB;
if(rightdB > maxdB){
maxdB = rightdB;
}
//ALOGV("\tEFFECT_CMD_SET_VOLUME Session: %d, SessionID: %d VOLUME is %d dB (%d), "
//      "effect is %d",
//pContext->pBundledContext->SessionNo, pContext->pBundledContext->SessionId,
//(int32_t)maxdB, maxVol<<7, pContext->EffectType);
//ALOGV("\tEFFECT_CMD_SET_VOLUME: Left is %d, Right is %d", leftVolume, rightVolume);
//ALOGV("\tEFFECT_CMD_SET_VOLUME: Left %ddB, Right %ddB, Position %ddB",
//        leftdB, rightdB, pandB);

memcpy(pReplyData, vol_ret, sizeof(int32_t)*2);
android::VolumeSetVolumeLevel(pContext, (int16_t)(maxdB*100));

/* Get the current settings */
LvmStatus =LVM_GetControlParameters(pContext->pBundledContext->hInstance,&ActiveParams);
LVM_ERROR_CHECK(LvmStatus, "LVM_GetControlParameters", "VolumeSetStereoPosition")
if(LvmStatus != LVM_SUCCESS) return -EINVAL;

/* Volume parameters */
ActiveParams.VC_Balance  = pandB;
ALOGV("\t\tVolumeSetStereoPosition() (-96dB -> +96dB)-> %d\n", ActiveParams.VC_Balance );

/* Activate the initial settings */
LvmStatus =LVM_SetControlParameters(pContext->pBundledContext->hInstance,&ActiveParams);
LVM_ERROR_CHECK(LvmStatus, "LVM_SetControlParameters", "VolumeSetStereoPosition")
if(LvmStatus != LVM_SUCCESS) return -EINVAL;
break;
}
case EFFECT_CMD_SET_AUDIO_MODE:
break;
default:
return -EINVAL;
}

//ALOGV("\tEffect_command end...\n\n");
return 0;
} /* end Effect_command */

int LELib_GetDescriptor(const effect_uuid_t *uuid,
 effect_descriptor_t *pDescriptor) {

 if (pDescriptor == NULL || uuid == NULL){
        ALOGV("LELib_GetDescriptor() called with NULL pointer");
 return -EINVAL;
 }

 if (memcmp(uuid, &gLEDescriptor.uuid, sizeof(effect_uuid_t)) == 0) {
 *pDescriptor = gLEDescriptor;
 return 0;
 }

 return -EINVAL;
} /* end LELib_GetDescriptor */

uint32_t BassGetStrength(EffectContext *pContext){

 LVM_ControlParams_t ActiveParams; /* Current control Parameters */
    LVM_ReturnStatus_en     LvmStatus = LVM_SUCCESS; /* Function call status */
 /* Get the current settings */
 LvmStatus = LVM_GetControlParameters(pContext->pBundledContext->hInstance,
 &ActiveParams);

    LVM_ERROR_CHECK(LvmStatus, "LVM_GetControlParameters", "BassGetStrength")
 if(LvmStatus != LVM_SUCCESS) return -EINVAL;


 /* Check that the strength returned matches the strength that was set earlier */
 if(ActiveParams.BE_EffectLevel !=
 (LVM_INT16)((15*pContext->pBundledContext->BassStrengthSaved)/1000)){
        ALOGV("\tLVM_ERROR : BassGetStrength module strength does not match savedStrength %d %d\n",
 ActiveParams.BE_EffectLevel, pContext->pBundledContext->BassStrengthSaved);
 return -EINVAL;
 }

 return pContext->pBundledContext->BassStrengthSaved;
} /* end BassGetStrength */

int Downmix_setParameter(downmix_object_t *pDownmixer, int32_t param, uint32_t size, void *pValue) {

 int16_t value16;
    ALOGV("Downmix_setParameter, context %p, param %" PRId32 ", value16 %" PRId16 ", value32 %" PRId32,
            pDownmixer, param, *(int16_t *)pValue, *(int32_t *)pValue);

 switch (param) {

 case DOWNMIX_PARAM_TYPE:
 if (size != sizeof(downmix_type_t)) {
            ALOGE("Downmix_setParameter(DOWNMIX_PARAM_TYPE) invalid size %" PRIu32 ", should be %zu",
                    size, sizeof(downmix_type_t));
 return -EINVAL;
 }
        value16 = *(int16_t *)pValue;
        ALOGV("set DOWNMIX_PARAM_TYPE, type %" PRId16, value16);
 if (!((value16 > DOWNMIX_TYPE_INVALID) && (value16 <= DOWNMIX_TYPE_LAST))) {
            ALOGE("Downmix_setParameter invalid DOWNMIX_PARAM_TYPE value %" PRId16, value16);
 return -EINVAL;
 } else {
            pDownmixer->type = (downmix_type_t) value16;
 break;

 default:
        ALOGE("Downmix_setParameter unknown parameter %" PRId32, param);
 return -EINVAL;
 }
}

 return 0;
} /* end Downmix_setParameter */

int32_t EqualizerGetBandLevel(EffectContext *pContext, int32_t band){
 return pContext->pBundledContext->bandGaindB[band] * 100;
}

int Reverb_getDescriptor(effect_handle_t   self,
 effect_descriptor_t *pDescriptor)
{
    android::ReverbContext * pContext = (android::ReverbContext *)self;
 const effect_descriptor_t *desc;

 if (pContext == NULL || pDescriptor == NULL) {
        ALOGV("Reverb_getDescriptor() invalid param");
 return -EINVAL;
 }

 if (pContext->auxiliary) {
 if (pContext->preset) {
            desc = &android::gAuxPresetReverbDescriptor;
 } else {
            desc = &android::gAuxEnvReverbDescriptor;
 }
 } else {
 if (pContext->preset) {
            desc = &android::gInsertPresetReverbDescriptor;
 } else {
            desc = &android::gInsertEnvReverbDescriptor;
 }
 }

 *pDescriptor = *desc;

 return 0;
} /* end Reverb_getDescriptor */

int LE_command(effect_handle_t self, uint32_t cmdCode, uint32_t cmdSize,
void *pCmdData, uint32_t *replySize, void *pReplyData) {

LoudnessEnhancerContext * pContext = (LoudnessEnhancerContext *)self;
int retsize;

if (pContext == NULL || pContext->mState == LOUDNESS_ENHANCER_STATE_UNINITIALIZED) {
return -EINVAL;
}

//    ALOGV("LE_command command %d cmdSize %d",cmdCode, cmdSize);
switch (cmdCode) {
case EFFECT_CMD_INIT:
if (pReplyData == NULL || *replySize != sizeof(int)) {
return -EINVAL;
}
*(int *) pReplyData = LE_init(pContext);

break;
case EFFECT_CMD_SET_CONFIG:
if (pCmdData == NULL || cmdSize != sizeof(effect_config_t)
                || pReplyData == NULL || *replySize != sizeof(int)) {
return -EINVAL;
}
*(int *) pReplyData = LE_setConfig(pContext,
(effect_config_t *) pCmdData);
break;
case EFFECT_CMD_GET_CONFIG:
if (pReplyData == NULL ||
*replySize != sizeof(effect_config_t)) {
return -EINVAL;
}
LE_getConfig(pContext, (effect_config_t *)pReplyData);
break;
case EFFECT_CMD_RESET:

LE_reset(pContext);
break;
case EFFECT_CMD_ENABLE:
        if (pReplyData == NULL || *replySize != sizeof(int)) {
return -EINVAL;
}
if (pContext->mState != LOUDNESS_ENHANCER_STATE_INITIALIZED) {
return -ENOSYS;
}
pContext->mState = LOUDNESS_ENHANCER_STATE_ACTIVE;
ALOGV("EFFECT_CMD_ENABLE() OK");
*(int *)pReplyData = 0;
break;
case EFFECT_CMD_DISABLE:
if (pReplyData == NULL || *replySize != sizeof(int)) {
return -EINVAL;
}
if (pContext->mState != LOUDNESS_ENHANCER_STATE_ACTIVE) {
return -ENOSYS;
}
pContext->mState = LOUDNESS_ENHANCER_STATE_INITIALIZED;
ALOGV("EFFECT_CMD_DISABLE() OK");
*(int *)pReplyData = 0;
break;

case EFFECT_CMD_GET_PARAM: {
if (pCmdData == NULL ||
cmdSize != (int)(sizeof(effect_param_t) + sizeof(uint32_t)) ||
            pReplyData == NULL ||
*replySize < (int)(sizeof(effect_param_t) + sizeof(uint32_t) + sizeof(uint32_t))) {
return -EINVAL;
}
memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + sizeof(uint32_t));
effect_param_t *p = (effect_param_t *)pReplyData;
p->status = 0;
*replySize = sizeof(effect_param_t) + sizeof(uint32_t);
if (p->psize != sizeof(uint32_t)) {
p->status = -EINVAL;
break;
}
switch (*(uint32_t *)p->data) {
case LOUDNESS_ENHANCER_PARAM_TARGET_GAIN_MB:
ALOGV("get target gain(mB) = %d", pContext->mTargetGainmB);
*((int32_t *)p->data + 1) = pContext->mTargetGainmB;
p->vsize = sizeof(int32_t);
*replySize += sizeof(int32_t);
break;
default:
p->status = -EINVAL;
}
} break;

case EFFECT_CMD_SET_PARAM: {
if (pCmdData == NULL ||
cmdSize != (int)(sizeof(effect_param_t) + sizeof(uint32_t) + sizeof(uint32_t)) ||
            pReplyData == NULL || *replySize != sizeof(int32_t)) {
return -EINVAL;
}
*(int32_t *)pReplyData = 0;
effect_param_t *p = (effect_param_t *)pCmdData;
if (p->psize != sizeof(uint32_t) || p->vsize != sizeof(uint32_t)) {
*(int32_t *)pReplyData = -EINVAL;
break;
}
switch (*(uint32_t *)p->data) {
case LOUDNESS_ENHANCER_PARAM_TARGET_GAIN_MB:
pContext->mTargetGainmB = *((int32_t *)p->data + 1);
ALOGV("set target gain(mB) = %d", pContext->mTargetGainmB);
LE_reset(pContext); // apply parameter update
break;
default:
*(int32_t *)pReplyData = -EINVAL;
}
} break;
case EFFECT_CMD_SET_DEVICE:
case EFFECT_CMD_SET_VOLUME:
case EFFECT_CMD_SET_AUDIO_MODE:
break;

default:
ALOGW("LE_command invalid command %d",cmdCode);
return -EINVAL;
}

return 0;
}

void Reverb_free(ReverbContext *pContext){

    LVREV_ReturnStatus_en     LvmStatus=LVREV_SUCCESS; /* Function call status */
    LVREV_ControlParams_st    params; /* Control Parameters */
    LVREV_MemoryTable_st      MemTab;

 /* Free the algorithm memory */
 LvmStatus = LVREV_GetMemoryTable(pContext->hInstance,
 &MemTab,
                                   LVM_NULL);

    LVM_ERROR_CHECK(LvmStatus, "LVM_GetMemoryTable", "Reverb_free")

 for (int i=0; i<LVM_NR_MEMORY_REGIONS; i++){
 if (MemTab.Region[i].Size != 0){
 if (MemTab.Region[i].pBaseAddress != NULL){
                ALOGV("\tfree() - START freeing %" PRIu32 " bytes for region %u at %p\n",
 MemTab.Region[i].Size, i, MemTab.Region[i].pBaseAddress);

                free(MemTab.Region[i].pBaseAddress);

                ALOGV("\tfree() - END   freeing %" PRIu32 " bytes for region %u at %p\n",
 MemTab.Region[i].Size, i, MemTab.Region[i].pBaseAddress);
 }else{
                ALOGV("\tLVM_ERROR : free() - trying to free with NULL pointer %" PRIu32 " bytes "
 "for region %u at %p ERROR\n",
 MemTab.Region[i].Size, i, MemTab.Region[i].pBaseAddress);
 }
 }
 }
} /* end Reverb_free */

extern "C" int EffectRelease(effect_handle_t handle){
 ReverbContext * pContext = (ReverbContext *)handle;

    ALOGV("\tEffectRelease %p", handle);
 if (pContext == NULL){
        ALOGV("\tLVM_ERROR : EffectRelease called with NULL pointer");
 return -EINVAL;
 }

 #ifdef LVM_PCM
    fclose(pContext->PcmInPtr);
    fclose(pContext->PcmOutPtr);
 #endif
    free(pContext->InFrames32);
    free(pContext->OutFrames32);
 Reverb_free(pContext);
 delete pContext;
 return 0;
} /* end EffectRelease */

int Reverb_command(effect_handle_t  self,
uint32_t            cmdCode,
uint32_t            cmdSize,
void *pCmdData,
uint32_t *replySize,
void *pReplyData){
android::ReverbContext * pContext = (android::ReverbContext *) self;
int retsize;
LVREV_ControlParams_st    ActiveParams; /* Current control Parameters */
LVREV_ReturnStatus_en     LvmStatus=LVREV_SUCCESS; /* Function call status */


if (pContext == NULL){
ALOGV("\tLVM_ERROR : Reverb_command ERROR pContext == NULL");
return -EINVAL;
}

//ALOGV("\tReverb_command INPUTS are: command %d cmdSize %d",cmdCode, cmdSize);

switch (cmdCode){
case EFFECT_CMD_INIT:

//ALOGV("\tReverb_command cmdCode Case: "
//        "EFFECT_CMD_INIT start");

            if (pReplyData == NULL || *replySize != sizeof(int)){
ALOGV("\tLVM_ERROR : Reverb_command cmdCode Case: "
"EFFECT_CMD_INIT: ERROR");
return -EINVAL;
}
*(int *) pReplyData = 0;
break;


case EFFECT_CMD_SET_CONFIG:
//ALOGV("\tReverb_command cmdCode Case: "
//        "EFFECT_CMD_SET_CONFIG start");
            if (pCmdData == NULL ||
                cmdSize != sizeof(effect_config_t) ||
                pReplyData == NULL ||
                *replySize != sizeof(int)) {
ALOGV("\tLVM_ERROR : Reverb_command cmdCode Case: "
"EFFECT_CMD_SET_CONFIG: ERROR");
return -EINVAL;
}
*(int *) pReplyData = android::Reverb_setConfig(pContext,
(effect_config_t *) pCmdData);

break;

case EFFECT_CMD_GET_CONFIG:
            if (pReplyData == NULL ||
                *replySize != sizeof(effect_config_t)) {
ALOGV("\tLVM_ERROR : Reverb_command cmdCode Case: "
"EFFECT_CMD_GET_CONFIG: ERROR");
return -EINVAL;
}

android::Reverb_getConfig(pContext, (effect_config_t *)pReplyData);
break;

case EFFECT_CMD_RESET:
//ALOGV("\tReverb_command cmdCode Case: "
//        "EFFECT_CMD_RESET start");
Reverb_setConfig(pContext, &pContext->config);
break;


case EFFECT_CMD_GET_PARAM:{
//ALOGV("\tReverb_command cmdCode Case: "
//        "EFFECT_CMD_GET_PARAM start");
            if (pCmdData == NULL ||
                    cmdSize < (sizeof(effect_param_t) + sizeof(int32_t)) ||
                    pReplyData == NULL ||
                    *replySize < (sizeof(effect_param_t) + sizeof(int32_t))){
ALOGV("\tLVM_ERROR : Reverb_command cmdCode Case: "
"EFFECT_CMD_GET_PARAM: ERROR");
return -EINVAL;
}
            effect_param_t *p = (effect_param_t *)pCmdData;

memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + p->psize);

p = (effect_param_t *)pReplyData;

int voffset = ((p->psize - 1) / sizeof(int32_t) + 1) * sizeof(int32_t);

p->status = android::Reverb_getParameter(pContext,
(void *)p->data,
&p->vsize,
p->data + voffset);

*replySize = sizeof(effect_param_t) + voffset + p->vsize;

//ALOGV("\tReverb_command EFFECT_CMD_GET_PARAM "
//        "*pCmdData %d, *replySize %d, *pReplyData %d ",
//        *(int32_t *)((char *)pCmdData + sizeof(effect_param_t)),
//        *replySize,
//        *(int16_t *)((char *)pReplyData + sizeof(effect_param_t) + voffset));

} break;
case EFFECT_CMD_SET_PARAM:{

//ALOGV("\tReverb_command cmdCode Case: "
//        "EFFECT_CMD_SET_PARAM start");
//ALOGV("\tReverb_command EFFECT_CMD_SET_PARAM param %d, *replySize %d, value %d ",
//        *(int32_t *)((char *)pCmdData + sizeof(effect_param_t)),

//        *replySize,
//        *(int16_t *)((char *)pCmdData + sizeof(effect_param_t) + sizeof(int32_t)));

            if (pCmdData == NULL || (cmdSize < (sizeof(effect_param_t) + sizeof(int32_t)))
                    || pReplyData == NULL || *replySize != sizeof(int32_t)) {
ALOGV("\tLVM_ERROR : Reverb_command cmdCode Case: "
"EFFECT_CMD_SET_PARAM: ERROR");
return -EINVAL;
}

effect_param_t *p = (effect_param_t *) pCmdData;

if (p->psize != sizeof(int32_t)){
ALOGV("\t4LVM_ERROR : Reverb_command cmdCode Case: "
"EFFECT_CMD_SET_PARAM: ERROR, psize is not sizeof(int32_t)");
return -EINVAL;
}

//ALOGV("\tn5Reverb_command cmdSize is %d\n"
//        "\tsizeof(effect_param_t) is  %d\n"
//        "\tp->psize is %d\n"
//        "\tp->vsize is %d"
//        "\n",
//        cmdSize, sizeof(effect_param_t), p->psize, p->vsize );

*(int *)pReplyData = android::Reverb_setParameter(pContext,
(void *)p->data,
p->data + p->psize);
} break;

case EFFECT_CMD_ENABLE:
//ALOGV("\tReverb_command cmdCode Case: "
//        "EFFECT_CMD_ENABLE start");

if (pReplyData == NULL || *replySize != sizeof(int)){
ALOGV("\tLVM_ERROR : Reverb_command cmdCode Case: "
"EFFECT_CMD_ENABLE: ERROR");
return -EINVAL;
}
if(pContext->bEnabled == LVM_TRUE){
ALOGV("\tLVM_ERROR : Reverb_command cmdCode Case: "
"EFFECT_CMD_ENABLE: ERROR-Effect is already enabled");
return -EINVAL;
}
*(int *)pReplyData = 0;
pContext->bEnabled = LVM_TRUE;
/* Get the current settings */
LvmStatus = LVREV_GetControlParameters(pContext->hInstance, &ActiveParams);
LVM_ERROR_CHECK(LvmStatus, "LVREV_GetControlParameters", "EFFECT_CMD_ENABLE")
pContext->SamplesToExitCount =
(ActiveParams.T60 * pContext->config.inputCfg.samplingRate)/1000;
// force no volume ramp for first buffer processed after enabling the effect
pContext->volumeMode = android::REVERB_VOLUME_FLAT;
//ALOGV("\tEFFECT_CMD_ENABLE SamplesToExitCount = %d", pContext->SamplesToExitCount);
break;
case EFFECT_CMD_DISABLE:
//ALOGV("\tReverb_command cmdCode Case: "
//        "EFFECT_CMD_DISABLE start");

if (pReplyData == NULL || *replySize != sizeof(int)){
ALOGV("\tLVM_ERROR : Reverb_command cmdCode Case: "
"EFFECT_CMD_DISABLE: ERROR");
return -EINVAL;
}
if(pContext->bEnabled == LVM_FALSE){
ALOGV("\tLVM_ERROR : Reverb_command cmdCode Case: "
"EFFECT_CMD_DISABLE: ERROR-Effect is not yet enabled");
return -EINVAL;
}
*(int *)pReplyData = 0;
pContext->bEnabled = LVM_FALSE;
break;

case EFFECT_CMD_SET_VOLUME:
if (pCmdData == NULL ||
cmdSize != 2 * sizeof(uint32_t)) {
ALOGV("\tLVM_ERROR : Reverb_command cmdCode Case: "
"EFFECT_CMD_SET_VOLUME: ERROR");
return -EINVAL;
}


if (pReplyData != NULL) { // we have volume control
pContext->leftVolume = (LVM_INT16)((*(uint32_t *)pCmdData + (1 << 11)) >> 12);
pContext->rightVolume = (LVM_INT16)((*((uint32_t *)pCmdData + 1) + (1 << 11)) >> 12);
*(uint32_t *)pReplyData = (1 << 24);
*((uint32_t *)pReplyData + 1) = (1 << 24);
if (pContext->volumeMode == android::REVERB_VOLUME_OFF) {
// force no volume ramp for first buffer processed after getting volume control
pContext->volumeMode = android::REVERB_VOLUME_FLAT;
}
} else { // we don't have volume control
pContext->leftVolume = REVERB_UNIT_VOLUME;
pContext->rightVolume = REVERB_UNIT_VOLUME;
pContext->volumeMode = android::REVERB_VOLUME_OFF;
}
ALOGV("EFFECT_CMD_SET_VOLUME left %d, right %d mode %d",
pContext->leftVolume, pContext->rightVolume,  pContext->volumeMode);
break;

case EFFECT_CMD_SET_DEVICE:
case EFFECT_CMD_SET_AUDIO_MODE:
//ALOGV("\tReverb_command cmdCode Case: "
//        "EFFECT_CMD_SET_DEVICE/EFFECT_CMD_SET_VOLUME/EFFECT_CMD_SET_AUDIO_MODE start");
break;

default:
ALOGV("\tLVM_ERROR : Reverb_command cmdCode Case: "
"DEFAULT start %d ERROR",cmdCode);
return -EINVAL;
}

//ALOGV("\tReverb_command end\n\n");
return 0;
} /* end Reverb_command */

int32_t ReverbGetDensity(ReverbContext *pContext){

    LVREV_ControlParams_st    ActiveParams; /* Current control Parameters */
    LVREV_ReturnStatus_en     LvmStatus=LVREV_SUCCESS; /* Function call status */
    LVM_INT16                 Temp;
 /* Get the current settings */
 LvmStatus = LVREV_GetControlParameters(pContext->hInstance, &ActiveParams);
    LVM_ERROR_CHECK(LvmStatus, "LVREV_GetControlParameters", "ReverbGetDensity")


 Temp = (LVM_INT16)(((pContext->SavedDensity * 99) / 1000) + 1);

 if(Temp != ActiveParams.RoomSize){
        ALOGV("\tLVM_ERROR : ReverbGetDensity invalid value %d %d", Temp, ActiveParams.RoomSize);
 }

 return pContext->SavedDensity;
}

int32_t DownmixLib_Create(const effect_uuid_t *uuid,
        int32_t sessionId,
        int32_t ioId,
effect_handle_t *pHandle) {
int ret;
int i;
downmix_module_t *module;
const effect_descriptor_t *desc;

ALOGV("DownmixLib_Create()");

#ifdef DOWNMIX_TEST_CHANNEL_INDEX
// should work (won't log an error)
ALOGI("DOWNMIX_TEST_CHANNEL_INDEX: should work:");
Downmix_testIndexComputation(AUDIO_CHANNEL_OUT_FRONT_LEFT | AUDIO_CHANNEL_OUT_FRONT_RIGHT |
AUDIO_CHANNEL_OUT_LOW_FREQUENCY | AUDIO_CHANNEL_OUT_BACK_CENTER);
Downmix_testIndexComputation(CHANNEL_MASK_QUAD_SIDE | CHANNEL_MASK_QUAD_BACK);
Downmix_testIndexComputation(CHANNEL_MASK_5POINT1_SIDE | AUDIO_CHANNEL_OUT_BACK_CENTER);
Downmix_testIndexComputation(CHANNEL_MASK_5POINT1_BACK | AUDIO_CHANNEL_OUT_BACK_CENTER);
// shouldn't work (will log an error, won't display channel indices)
ALOGI("DOWNMIX_TEST_CHANNEL_INDEX: should NOT work:");
Downmix_testIndexComputation(AUDIO_CHANNEL_OUT_FRONT_LEFT | AUDIO_CHANNEL_OUT_FRONT_RIGHT |
AUDIO_CHANNEL_OUT_LOW_FREQUENCY | AUDIO_CHANNEL_OUT_BACK_LEFT);
Downmix_testIndexComputation(AUDIO_CHANNEL_OUT_FRONT_LEFT | AUDIO_CHANNEL_OUT_FRONT_RIGHT |
AUDIO_CHANNEL_OUT_LOW_FREQUENCY | AUDIO_CHANNEL_OUT_SIDE_LEFT);
Downmix_testIndexComputation(AUDIO_CHANNEL_OUT_FRONT_LEFT |
AUDIO_CHANNEL_OUT_BACK_LEFT | AUDIO_CHANNEL_OUT_BACK_RIGHT);
Downmix_testIndexComputation(AUDIO_CHANNEL_OUT_FRONT_LEFT |
AUDIO_CHANNEL_OUT_SIDE_LEFT | AUDIO_CHANNEL_OUT_SIDE_RIGHT);
#endif

if (pHandle == NULL || uuid == NULL) {
return -EINVAL;
}

for (i = 0 ; i < kNbEffects ; i++) {
desc = gDescriptors[i];
if (memcmp(uuid, &desc->uuid, sizeof(effect_uuid_t)) == 0) {
break;
}
}

if (i == kNbEffects) {
return -ENOENT;
}

module = malloc(sizeof(downmix_module_t));

module->itfe = &gDownmixInterface;

module->context.state = DOWNMIX_STATE_UNINITIALIZED;

ret = Downmix_Init(module);
if (ret < 0) {
ALOGW("DownmixLib_Create() init failed");
free(module);
return ret;
}

*pHandle = (effect_handle_t) module;

ALOGV("DownmixLib_Create() %p , size %zu", module, sizeof(downmix_module_t));

return 0;
}

int Reverb_process(effect_handle_t   self,
 audio_buffer_t *inBuffer,
 audio_buffer_t *outBuffer){
    android::ReverbContext * pContext = (android::ReverbContext *) self;
 int    status = 0;

 if (pContext == NULL){
        ALOGV("\tLVM_ERROR : Reverb_process() ERROR pContext == NULL");
 return -EINVAL;
 }
 if (inBuffer == NULL  || inBuffer->raw == NULL  ||
            outBuffer == NULL || outBuffer->raw == NULL ||
            inBuffer->frameCount != outBuffer->frameCount){
        ALOGV("\tLVM_ERROR : Reverb_process() ERROR NULL INPUT POINTER OR FRAME COUNT IS WRONG");
 return -EINVAL;
 }
 /* Process all the available frames, block processing is handled internalLY by the LVM bundle */
    status = process( (LVM_INT16 *)inBuffer->raw,
 (LVM_INT16 *)outBuffer->raw,
                                      outBuffer->frameCount,
                                      pContext);

 if (pContext->bEnabled == LVM_FALSE) {
 if (pContext->SamplesToExitCount > 0) {
            pContext->SamplesToExitCount -= outBuffer->frameCount;
 } else {
            status = -ENODATA;
 }
 }

 return status;
} /* end Reverb_process */

void LvmEffect_free(EffectContext *pContext){
    LVM_ReturnStatus_en     LvmStatus=LVM_SUCCESS; /* Function call status */
 LVM_ControlParams_t     params; /* Control Parameters */
 LVM_MemTab_t MemTab;

 /* Free the algorithm memory */
 LvmStatus = LVM_GetMemoryTable(pContext->pBundledContext->hInstance,
 &MemTab,
                                   LVM_NULL);

    LVM_ERROR_CHECK(LvmStatus, "LVM_GetMemoryTable", "LvmEffect_free")

 for (int i=0; i<LVM_NR_MEMORY_REGIONS; i++){
 if (MemTab.Region[i].Size != 0){
 if (MemTab.Region[i].pBaseAddress != NULL){
                ALOGV("\tLvmEffect_free - START freeing %" PRIu32 " bytes for region %u at %p\n",
 MemTab.Region[i].Size, i, MemTab.Region[i].pBaseAddress);

                free(MemTab.Region[i].pBaseAddress);

                ALOGV("\tLvmEffect_free - END   freeing %" PRIu32 " bytes for region %u at %p\n",
 MemTab.Region[i].Size, i, MemTab.Region[i].pBaseAddress);
 }else{
                ALOGV("\tLVM_ERROR : LvmEffect_free - trying to free with NULL pointer %" PRIu32
 " bytes for region %u at %p ERROR\n",
 MemTab.Region[i].Size, i, MemTab.Region[i].pBaseAddress);
 }
 }
 }
} /* end LvmEffect_free */

int16_t ReverbConvertLevel(int16_t level){
 static int16_t LevelArray[101] =
 {
 -12000, -4000, -3398, -3046, -2796, -2603, -2444, -2310, -2194, -2092,
 -2000, -1918, -1842, -1773, -1708, -1648, -1592, -1540, -1490, -1443,
 -1398, -1356, -1316, -1277, -1240, -1205, -1171, -1138, -1106, -1076,
 -1046, -1018, -990, -963, -938, -912, -888, -864, -841, -818,
 -796, -775, -754, -734, -714, -694, -675, -656, -638, -620,
 -603, -585, -568, -552, -536, -520, -504, -489, -474, -459,
 -444, -430, -416, -402, -388, -375, -361, -348, -335, -323,
 -310, -298, -286, -274, -262, -250, -239, -228, -216, -205,
 -194, -184, -173, -162, -152, -142, -132, -121, -112, -102,
 -92, -82, -73, -64, -54, -45, -36, -27, -18, -9,
 0
 };
 int16_t i;

 for(i = 0; i < 101; i++)
 {
 if(level <= LevelArray[i])
 break;
 }
 return i;
}

extern "C" int EffectCreate(const effect_uuid_t *uuid,
 int32_t             sessionId,
 int32_t             ioId __unused,
 effect_handle_t *pHandle){
 int ret = 0;
 int sessionNo;
 int i;
 EffectContext *pContext = NULL;
 bool newBundle = false;
 SessionContext *pSessionContext;

    ALOGV("\n\tEffectCreate start session %d", sessionId);

 if (pHandle == NULL || uuid == NULL){
        ALOGV("\tLVM_ERROR : EffectCreate() called with NULL pointer");
        ret = -EINVAL;
 goto exit;
 }

 if(LvmInitFlag == LVM_FALSE){
 LvmInitFlag = LVM_TRUE;
        ALOGV("\tEffectCreate - Initializing all global memory");
 LvmGlobalBundle_init();
 }

 for(i=0; i<LVM_MAX_SESSIONS; i++){
 if((SessionIndex[i] == LVM_UNUSED_SESSION)||(SessionIndex[i] == sessionId)){
            sessionNo       = i;
 SessionIndex[i] = sessionId;
            ALOGV("\tEffectCreate: Allocating SessionNo %d for SessionId %d\n", sessionNo,sessionId);
 break;
 }
 }

 if(i==LVM_MAX_SESSIONS){
        ALOGV("\tLVM_ERROR : Cannot find memory to allocate for current session");
        ret = -EINVAL;
 goto exit;
 }

    pContext = new EffectContext;

 if(GlobalSessionMemory[sessionNo].bBundledEffectsEnabled == LVM_FALSE){
        ALOGV("\tEffectCreate - This is the first effect in current sessionId %d sessionNo %d",
                sessionId, sessionNo);

 GlobalSessionMemory[sessionNo].bBundledEffectsEnabled = LVM_TRUE;
 GlobalSessionMemory[sessionNo].pBundledContext        = new BundledEffectContext;
        newBundle = true;

        pContext->pBundledContext = GlobalSessionMemory[sessionNo].pBundledContext;
        pContext->pBundledContext->SessionNo = sessionNo;
        pContext->pBundledContext->SessionId = sessionId;
        pContext->pBundledContext->hInstance                = NULL;
        pContext->pBundledContext->bVolumeEnabled           = LVM_FALSE;
        pContext->pBundledContext->bEqualizerEnabled        = LVM_FALSE;
        pContext->pBundledContext->bBassEnabled             = LVM_FALSE;
        pContext->pBundledContext->bBassTempDisabled        = LVM_FALSE;
        pContext->pBundledContext->bVirtualizerEnabled      = LVM_FALSE;
        pContext->pBundledContext->bVirtualizerTempDisabled = LVM_FALSE;
        pContext->pBundledContext->nOutputDevice            = AUDIO_DEVICE_NONE;
        pContext->pBundledContext->nVirtualizerForcedDevice = AUDIO_DEVICE_NONE;
        pContext->pBundledContext->NumberEffectsEnabled = 0;
        pContext->pBundledContext->NumberEffectsCalled = 0;
        pContext->pBundledContext->firstVolume              = LVM_TRUE;
        pContext->pBundledContext->volume                   = 0;

 #ifdef LVM_PCM
 char fileName[256];
        snprintf(fileName, 256, "/data/tmp/bundle_%p_pcm_in.pcm", pContext->pBundledContext);
        pContext->pBundledContext->PcmInPtr = fopen(fileName, "w");
 if (pContext->pBundledContext->PcmInPtr == NULL) {
            ALOGV("cannot open %s", fileName);
            ret = -EINVAL;
 goto exit;
 }

        snprintf(fileName, 256, "/data/tmp/bundle_%p_pcm_out.pcm", pContext->pBundledContext);
        pContext->pBundledContext->PcmOutPtr = fopen(fileName, "w");
 if (pContext->pBundledContext->PcmOutPtr == NULL) {
            ALOGV("cannot open %s", fileName);
            fclose(pContext->pBundledContext->PcmInPtr);
           pContext->pBundledContext->PcmInPtr = NULL;
           ret = -EINVAL;
 goto exit;
 }
 #endif

 /* Saved strength is used to return the exact strength that was used in the set to the get
         * because we map the original strength range of 0:1000 to 1:15, and this will avoid
         * quantisation like effect when returning
         */
        pContext->pBundledContext->BassStrengthSaved = 0;
        pContext->pBundledContext->VirtStrengthSaved = 0;
        pContext->pBundledContext->CurPreset = PRESET_CUSTOM;
        pContext->pBundledContext->levelSaved               = 0;
        pContext->pBundledContext->bMuteEnabled             = LVM_FALSE;
        pContext->pBundledContext->bStereoPositionEnabled   = LVM_FALSE;
        pContext->pBundledContext->positionSaved            = 0;
        pContext->pBundledContext->workBuffer               = NULL;
        pContext->pBundledContext->frameCount               = -1;
        pContext->pBundledContext->SamplesToExitCountVirt = 0;
        pContext->pBundledContext->SamplesToExitCountBb = 0;
        pContext->pBundledContext->SamplesToExitCountEq = 0;

 for (int i = 0; i < FIVEBAND_NUMBANDS; i++) {
            pContext->pBundledContext->bandGaindB[i] = EQNB_5BandSoftPresets[i];
 }

        ALOGV("\tEffectCreate - Calling LvmBundle_init");
        ret = LvmBundle_init(pContext);

 if (ret < 0){
            ALOGV("\tLVM_ERROR : EffectCreate() Bundle init failed");
 goto exit;
 }
 }
 else{
        ALOGV("\tEffectCreate - Assigning memory for previously created effect on sessionNo %d",
                sessionNo);
        pContext->pBundledContext =
 GlobalSessionMemory[sessionNo].pBundledContext;
 }
    ALOGV("\tEffectCreate - pBundledContext is %p", pContext->pBundledContext);

    pSessionContext = &GlobalSessionMemory[pContext->pBundledContext->SessionNo];

 if (memcmp(uuid, &gBassBoostDescriptor.uuid, sizeof(effect_uuid_t)) == 0){
        ALOGV("\tEffectCreate - Effect to be created is LVM_BASS_BOOST");
        pSessionContext->bBassInstantiated = LVM_TRUE;
        pContext->pBundledContext->SamplesToExitCountBb = 0;

        pContext->itfe       = &gLvmEffectInterface;
        pContext->EffectType = LVM_BASS_BOOST;
 } else if (memcmp(uuid, &gVirtualizerDescriptor.uuid, sizeof(effect_uuid_t)) == 0){
        ALOGV("\tEffectCreate - Effect to be created is LVM_VIRTUALIZER");
        pSessionContext->bVirtualizerInstantiated=LVM_TRUE;
        pContext->pBundledContext->SamplesToExitCountVirt = 0;

        pContext->itfe       = &gLvmEffectInterface;
        pContext->EffectType = LVM_VIRTUALIZER;
 } else if (memcmp(uuid, &gEqualizerDescriptor.uuid, sizeof(effect_uuid_t)) == 0){
        ALOGV("\tEffectCreate - Effect to be created is LVM_EQUALIZER");
        pSessionContext->bEqualizerInstantiated = LVM_TRUE;
        pContext->pBundledContext->SamplesToExitCountEq = 0;

        pContext->itfe       = &gLvmEffectInterface;
        pContext->EffectType = LVM_EQUALIZER;
 } else if (memcmp(uuid, &gVolumeDescriptor.uuid, sizeof(effect_uuid_t)) == 0){
        ALOGV("\tEffectCreate - Effect to be created is LVM_VOLUME");
        pSessionContext->bVolumeInstantiated = LVM_TRUE;

        pContext->itfe       = &gLvmEffectInterface;
        pContext->EffectType = LVM_VOLUME;
 }
 else{
        ALOGV("\tLVM_ERROR : EffectCreate() invalid UUID");
        ret = -EINVAL;
 goto exit;
 }

exit:
 if (ret != 0) {
 if (pContext != NULL) {
 if (newBundle) {
 GlobalSessionMemory[sessionNo].bBundledEffectsEnabled = LVM_FALSE;
 SessionIndex[sessionNo] = LVM_UNUSED_SESSION;
 delete pContext->pBundledContext;
 }
 delete pContext;
 }
 *pHandle = (effect_handle_t)NULL;
 } else {
 *pHandle = (effect_handle_t)pContext;
 }
    ALOGV("\tEffectCreate end..\n\n");
 return ret;
} /* end EffectCreate */

int AgcSetParameter (preproc_effect_t *effect, void *pParam, void *pValue)
{
 int status = 0;
 uint32_t param = *(uint32_t *)pParam;
    t_agc_settings *pProperties = (t_agc_settings *)pValue;
    webrtc::GainControl *agc = static_cast<webrtc::GainControl *>(effect->engine);

 switch (param) {
 case AGC_PARAM_TARGET_LEVEL:
        ALOGV("AgcSetParameter() target level %d milliBels", *(int16_t *)pValue);
        status = agc->set_target_level_dbfs(-(*(int16_t *)pValue / 100));
 break;
 case AGC_PARAM_COMP_GAIN:
        ALOGV("AgcSetParameter() comp gain %d milliBels", *(int16_t *)pValue);
        status = agc->set_compression_gain_db(*(int16_t *)pValue / 100);
 break;
 case AGC_PARAM_LIMITER_ENA:
        ALOGV("AgcSetParameter() limiter enabled %s", *(bool *)pValue ? "true" : "false");
        status = agc->enable_limiter(*(bool *)pValue);
 break;
 case AGC_PARAM_PROPERTIES:
        ALOGV("AgcSetParameter() properties level %d, gain %d limiter %d",
             pProperties->targetLevel,
             pProperties->compGain,
             pProperties->limiterEnabled);
        status = agc->set_target_level_dbfs(-(pProperties->targetLevel / 100));
 if (status != 0) break;
        status = agc->set_compression_gain_db(pProperties->compGain / 100);
 if (status != 0) break;
        status = agc->enable_limiter(pProperties->limiterEnabled);
 break;
 default:
        ALOGW("AgcSetParameter() unknown param %08x value %08x", param, *(uint32_t *)pValue);
        status = -EINVAL;
 break;
 }

    ALOGV("AgcSetParameter() done status %d", status);

 return status;
}

void ReverbSetDecayHfRatio(ReverbContext *pContext, int16_t ratio){

    LVREV_ControlParams_st    ActiveParams; /* Current control Parameters */
    LVREV_ReturnStatus_en     LvmStatus=LVREV_SUCCESS; /* Function call status */

 /* Get the current settings */
 LvmStatus = LVREV_GetControlParameters(pContext->hInstance, &ActiveParams);
    LVM_ERROR_CHECK(LvmStatus, "LVREV_GetControlParameters", "ReverbSetDecayHfRatio")

 ActiveParams.Damping = (LVM_INT16)(ratio/20);

 /* Activate the initial settings */
 LvmStatus = LVREV_SetControlParameters(pContext->hInstance, &ActiveParams);
    LVM_ERROR_CHECK(LvmStatus, "LVREV_SetControlParameters", "ReverbSetDecayHfRatio")

    pContext->SavedDecayHfRatio = ratio;
 return;
}
