TPM_RC tpm_kdfa(TSS2_SYS_CONTEXT *sapi_context, TPMI_ALG_HASH hashAlg,
TPM2B *key, char *label, TPM2B *contextU, TPM2B *contextV, UINT16 bits,
TPM2B_MAX_BUFFER  *resultKey )
{
    TPM2B_DIGEST tmpResult;
TPM2B_DIGEST tpm2bLabel, tpm2bBits, tpm2b_i_2;
UINT8 *tpm2bBitsPtr = &tpm2bBits.t.buffer[0];
UINT8 *tpm2b_i_2Ptr = &tpm2b_i_2.t.buffer[0];
TPM2B_DIGEST *bufferList[8];
UINT32 bitsSwizzled, i_Swizzled;
    TPM_RC rval;
int i, j;
UINT16 bytes = bits / 8;

resultKey->t .size = 0;

tpm2b_i_2.t.size = 4;

tpm2bBits.t.size = 4;
bitsSwizzled = string_bytes_endian_convert_32( bits );
*(UINT32 *)tpm2bBitsPtr = bitsSwizzled;

for(i = 0; label[i] != 0 ;i++ );

tpm2bLabel.t.size = i+1;
for( i = 0; i < tpm2bLabel.t.size; i++ )
{
tpm2bLabel.t.buffer[i] = label[i];
}

resultKey->t.size = 0;

i = 1;

while( resultKey->t.size < bytes )
{
// Inner loop

i_Swizzled = string_bytes_endian_convert_32( i );
*(UINT32 *)tpm2b_i_2Ptr = i_Swizzled;

j = 0;
bufferList[j++] = (TPM2B_DIGEST *)&(tpm2b_i_2.b);
bufferList[j++] = (TPM2B_DIGEST *)&(tpm2bLabel.b);
bufferList[j++] = (TPM2B_DIGEST *)contextU;
bufferList[j++] = (TPM2B_DIGEST *)contextV;
bufferList[j++] = (TPM2B_DIGEST *)&(tpm2bBits.b);
        bufferList[j++] = (TPM2B_DIGEST *)0;
        rval = tpm_hmac(sapi_context, hashAlg, key, (TPM2B **)&( bufferList[0] ), &tmpResult );
        if( rval != TPM_RC_SUCCESS )
        {
            return( rval );
}

bool res = string_bytes_concat_buffer(resultKey, &(tmpResult.b));
if (!res) {
            return TSS2_SYS_RC_BAD_VALUE;
}
}

// Truncate the result to the desired size.
resultKey->t.size = bytes;

    return TPM_RC_SUCCESS;
}

TPM_RC tpm_session_auth_end( SESSION *session )
{
    TPM_RC rval = TPM_RC_SUCCESS;

    DeleteSession( session );

    return rval;
}

static TPM_RC StartAuthSession(TSS2_SYS_CONTEXT *sapi_context, SESSION *session )
{
TPM_RC rval;
TPM2B_ENCRYPTED_SECRET key;
char label[] = "ATH";
UINT16 bytes;
int i;

key.t.size = 0;

if( session->nonceOlder.t.size == 0 )
{
/* this is an internal routine to TSS and should be removed */
session->nonceOlder.t.size = GetDigestSize( TPM_ALG_SHA1 );
for( i = 0; i < session->nonceOlder.t.size; i++ )
session->nonceOlder.t.buffer[i] = 0;
}

session->nonceNewer.t.size = session->nonceOlder.t.size;
rval = Tss2_Sys_StartAuthSession( sapi_context, session->tpmKey, session->bind, 0,
&( session->nonceOlder ), &( session->encryptedSalt ), session->sessionType,
&( session->symmetric ), session->authHash, &( session->sessionHandle ),
&( session->nonceNewer ), 0 );

if( rval == TPM_RC_SUCCESS )
{
if( session->tpmKey == TPM_RH_NULL )
session->salt.t.size = 0;
if( session->bind == TPM_RH_NULL )
session->authValueBind.t.size = 0;

if( session->tpmKey == TPM_RH_NULL && session->bind == TPM_RH_NULL )
{
session->sessionKey.b.size = 0;
}
else
{
// Generate the key used as input to the KDF.
// Generate the key used as input to the KDF.
bool result = string_bytes_concat_buffer( (TPM2B_MAX_BUFFER *)&key, &( session->authValueBind.b ) );
if (!result)
{
return TSS2_SYS_RC_BAD_VALUE;
}

result = string_bytes_concat_buffer( (TPM2B_MAX_BUFFER *)&key, &( session->salt.b ) );
if (!result)
{
return TSS2_SYS_RC_BAD_VALUE;
}

bytes = GetDigestSize( session->authHash );

if( key.t.size == 0 )
{
session->sessionKey.t.size = 0;
}
else
{
                rval = tpm_kdfa(sapi_context, session->authHash, &(key.b), label, &( session->nonceNewer.b ),
&( session->nonceOlder.b ), bytes * 8, (TPM2B_MAX_BUFFER *)&( session->sessionKey ) );
}

if( rval != TPM_RC_SUCCESS )
{
return( TSS2_APP_RC_CREATE_SESSION_KEY_FAILED );
}
}

session->nonceTpmDecrypt.b.size = 0;
session->nonceTpmEncrypt.b.size = 0;
session->nvNameChanged = 0;
}

return rval;
}

TPM_RC tpm_session_start_auth_with_params(TSS2_SYS_CONTEXT *sapi_context, SESSION **session,
    TPMI_DH_OBJECT tpmKey, TPM2B_MAX_BUFFER *salt,
    TPMI_DH_ENTITY bind, TPM2B_AUTH *bindAuth, TPM2B_NONCE *nonceCaller,
    TPM2B_ENCRYPTED_SECRET *encryptedSalt,
    TPM_SE sessionType, TPMT_SYM_DEF *symmetric, TPMI_ALG_HASH algId )
{
    TPM_RC rval;
    SESSION_LIST_ENTRY *sessionEntry;

    rval = AddSession( &sessionEntry );
    if( rval == TSS2_RC_SUCCESS )
    {
        *session = &sessionEntry->session;

        (*session)->bind = bind;
        (*session)->tpmKey = tpmKey;

        memcpy( &(*session)->nonceOlder.b, &nonceCaller->b, sizeof(nonceCaller->b));

        memcpy( &(*session)->encryptedSalt.b, &encryptedSalt->b, sizeof(encryptedSalt->b));

        (*session)->sessionType = sessionType;

        (*session)->symmetric.algorithm = symmetric->algorithm;
        (*session)->symmetric.keyBits.sym = symmetric->keyBits.sym;
        (*session)->symmetric.mode.sym = symmetric->mode.sym;
        (*session)->authHash = algId;

        if( bindAuth == 0 )
        {
            (*session)->authValueBind.b.size = 0;
        }
        else
        {
            memcpy( &( (*session)->authValueBind.b ), &( bindAuth->b ), sizeof(bindAuth->b));
        }

        if( (*session)->tpmKey == TPM_RH_NULL )
        {
            (*session)->salt.t.size = 0;
        }
        else
        {
            memcpy( &(*session)->salt.b, &salt->b, sizeof(salt->b));
        }

        if( (*session)->bind == TPM_RH_NULL )
            (*session)->authValueBind.t.size = 0;


        rval = StartAuthSession(sapi_context, *session );
    }
    else
    {
        DeleteSession( *session );
    }
    return( rval );
}

static UINT16 GetDigestSize( TPM_ALG_ID authHash )
{
    UINT32 i;
    for(i = 0; i < (sizeof(hashSizes)/sizeof(HASH_SIZE_INFO)); i++ )
    {
        if( hashSizes[i].algId == authHash )
            return hashSizes[i].size;
    }

    return( 0 );
}
