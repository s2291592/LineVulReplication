MediaGalleriesCustomBindings::MediaGalleriesCustomBindings(
ScriptContext* context)
: ObjectBackedNativeHandler(context) {
RouteFunction(
      "GetMediaFileSystemObject",
base::Bind(&MediaGalleriesCustomBindings::GetMediaFileSystemObject,
base::Unretained(this)));
}

void CastStreamingNativeHandler::CallGetStatsCallback(
    int transport_id,
    scoped_ptr<base::DictionaryValue> stats) {
  v8::Isolate* isolate = context()->isolate();
  v8::HandleScope handle_scope(isolate);
  v8::Context::Scope context_scope(context()->v8_context());

  RtpStreamCallbackMap::iterator it = get_stats_callbacks_.find(transport_id);
  if (it == get_stats_callbacks_.end())
    return;

  scoped_ptr<V8ValueConverter> converter(V8ValueConverter::create());
  v8::Local<v8::Value> callback_args[] = {
      converter->ToV8Value(stats.get(), context()->v8_context())};
  context()->CallFunction(v8::Local<v8::Function>::New(isolate, *it->second),
                          arraysize(callback_args), callback_args);
  get_stats_callbacks_.erase(it);
}

void AutomationInternalCustomBindings::DestroyAccessibilityTree(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  if (args.Length() != 1 || !args[0]->IsNumber()) {
    ThrowInvalidArgumentsException(this);
    return;
  }

  int tree_id = args[0]->Int32Value();
  auto iter = tree_id_to_tree_cache_map_.find(tree_id);
  if (iter == tree_id_to_tree_cache_map_.end())
    return;

  TreeCache* cache = iter->second;
  tree_id_to_tree_cache_map_.erase(tree_id);
  axtree_to_tree_cache_map_.erase(&cache->tree);
  delete cache;
}

void CastStreamingNativeHandler::CreateCastSession(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  CHECK_EQ(3, args.Length());
  CHECK(args[2]->IsFunction());

  v8::Isolate* isolate = context()->v8_context()->GetIsolate();
  if ((args[0]->IsNull() || args[0]->IsUndefined()) &&
      (args[1]->IsNull() || args[1]->IsUndefined())) {
    isolate->ThrowException(v8::Exception::Error(
        v8::String::NewFromUtf8(isolate, kInvalidStreamArgs)));
    return;
  }

  scoped_refptr<CastSession> session(new CastSession());
  scoped_ptr<CastRtpStream> stream1, stream2;
  if (!args[0]->IsNull() && !args[0]->IsUndefined()) {
    CHECK(args[0]->IsObject());
    blink::WebDOMMediaStreamTrack track =
        blink::WebDOMMediaStreamTrack::fromV8Value(args[0]);
    if (track.isNull()) {
      isolate->ThrowException(v8::Exception::Error(
          v8::String::NewFromUtf8(isolate, kInvalidStreamArgs)));
      return;
    }
    stream1.reset(new CastRtpStream(track.component(), session));
  }
  if (!args[1]->IsNull() && !args[1]->IsUndefined()) {
    CHECK(args[1]->IsObject());
    blink::WebDOMMediaStreamTrack track =
        blink::WebDOMMediaStreamTrack::fromV8Value(args[1]);
    if (track.isNull()) {
      isolate->ThrowException(v8::Exception::Error(
          v8::String::NewFromUtf8(isolate, kInvalidStreamArgs)));
      return;
    }
    stream2.reset(new CastRtpStream(track.component(), session));
  }
  scoped_ptr<CastUdpTransport> udp_transport(
      new CastUdpTransport(session));

  create_callback_.Reset(isolate, args[2].As<v8::Function>());

  base::ThreadTaskRunnerHandle::Get()->PostTask(
      FROM_HERE,
      base::Bind(&CastStreamingNativeHandler::CallCreateCallback,
                 weak_factory_.GetWeakPtr(), base::Passed(&stream1),
                 base::Passed(&stream2), base::Passed(&udp_transport)));
}

void ObjectBackedNativeHandler::RouteFunction(
    const std::string& name,
    const std::string& feature_name,
    const HandlerFunction& handler_function) {
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  v8::Context::Scope context_scope(context_->v8_context());

   v8::Local<v8::Object> data = v8::Object::New(isolate);
   SetPrivate(data, kHandlerFunction,
              v8::External::New(isolate, new HandlerFunction(handler_function)));
   SetPrivate(data, kFeatureName,
              v8_helpers::ToV8StringUnsafe(isolate, feature_name));
   v8::Local<v8::FunctionTemplate> function_template =
      v8::FunctionTemplate::New(isolate, Router, data);
  v8::Local<v8::ObjectTemplate>::New(isolate, object_template_)
      ->Set(isolate, name.c_str(), function_template);
  router_data_.Append(data);
}

void CastStreamingNativeHandler::DestroyCastRtpStream(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  CHECK_EQ(1, args.Length());
  CHECK(args[0]->IsInt32());

  const int transport_id = args[0]->ToInt32(args.GetIsolate())->Value();
  if (!GetRtpStreamOrThrow(transport_id))
    return;
  rtp_stream_map_.erase(transport_id);
}

void CastStreamingNativeHandler::StartCastRtpReceiver(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  if (args.Length() < 8 || args.Length() > 9 ||
      !args[0]->IsObject() ||
      !args[1]->IsObject() ||
      !args[2]->IsObject() ||
      !args[3]->IsInt32() ||
      !args[4]->IsInt32() ||
      !args[5]->IsNumber() ||
      !args[6]->IsString()) {
    args.GetIsolate()->ThrowException(v8::Exception::TypeError(
        v8::String::NewFromUtf8(args.GetIsolate(), kUnableToConvertArgs)));
    return;
  }

  v8::Isolate* isolate = context()->v8_context()->GetIsolate();

  scoped_refptr<CastReceiverSession> session(
      new CastReceiverSession());
  media::cast::FrameReceiverConfig audio_config;
  media::cast::FrameReceiverConfig video_config;
  net::IPEndPoint local_endpoint;
  net::IPEndPoint remote_endpoint;

  if (!FrameReceiverConfigFromArg(isolate, args[0], &audio_config) ||
      !FrameReceiverConfigFromArg(isolate, args[1], &video_config) ||
      !IPEndPointFromArg(isolate, args[2], &local_endpoint)) {
    return;
  }

  const int max_width = args[3]->ToInt32(args.GetIsolate())->Value();
  const int max_height = args[4]->ToInt32(args.GetIsolate())->Value();
  const double fps = args[5]->NumberValue();

  if (fps <= 1) {
    args.GetIsolate()->ThrowException(v8::Exception::TypeError(
        v8::String::NewFromUtf8(args.GetIsolate(), kInvalidFPS)));
    return;
  }

  const std::string url = *v8::String::Utf8Value(args[6]);
  blink::WebMediaStream stream =
      blink::WebMediaStreamRegistry::lookupMediaStreamDescriptor(GURL(url));

  if (stream.isNull()) {
    args.GetIsolate()->ThrowException(v8::Exception::TypeError(
        v8::String::NewFromUtf8(args.GetIsolate(), kInvalidMediaStreamURL)));
    return;
  }

  media::VideoCaptureFormat capture_format(gfx::Size(max_width, max_height),
                                           fps, media::PIXEL_FORMAT_I420);

  video_config.target_frame_rate = fps;
  audio_config.target_frame_rate = 100;

  media::AudioParameters params(
      media::AudioParameters::AUDIO_PCM_LINEAR,
      media::GuessChannelLayout(audio_config.channels),
      audio_config.rtp_timebase,  // sampling rate
      16, audio_config.rtp_timebase / audio_config.target_frame_rate);

  if (!params.IsValid()) {
    args.GetIsolate()->ThrowException(v8::Exception::TypeError(
        v8::String::NewFromUtf8(args.GetIsolate(), kInvalidAudioParams)));
    return;
  }

  scoped_ptr<base::DictionaryValue> options;
  if (args.Length() >= 9) {
    scoped_ptr<V8ValueConverter> converter(V8ValueConverter::create());
    scoped_ptr<base::Value> options_value(
        converter->FromV8Value(args[8], context()->v8_context()));
    if (!options_value->IsType(base::Value::TYPE_NULL)) {
      options = base::DictionaryValue::From(std::move(options_value));
      if (!options) {
        args.GetIsolate()->ThrowException(v8::Exception::TypeError(
            v8::String::NewFromUtf8(args.GetIsolate(), kUnableToConvertArgs)));
        return;
      }
    }
  }

  if (!options) {
    options.reset(new base::DictionaryValue());
  }

  v8::CopyablePersistentTraits<v8::Function>::CopyablePersistent error_callback;
  error_callback.Reset(args.GetIsolate(),
                       v8::Local<v8::Function>(args[7].As<v8::Function>()));

  session->Start(
      audio_config, video_config, local_endpoint, remote_endpoint,
      std::move(options), capture_format,
      base::Bind(&CastStreamingNativeHandler::AddTracksToMediaStream,
                 weak_factory_.GetWeakPtr(), url, params),
      base::Bind(&CastStreamingNativeHandler::CallReceiverErrorCallback,
                 weak_factory_.GetWeakPtr(), error_callback));
}

  virtual ~NodeIDPlusAttributeWrapper() {}

  virtual ~TreeIDWrapper() {}

void CastStreamingNativeHandler::CallErrorCallback(
    int stream_id,
    const std::string& message) const {
  v8::Isolate* isolate = context()->isolate();
  v8::HandleScope handle_scope(isolate);
  v8::Context::Scope context_scope(context()->v8_context());
  v8::Local<v8::Array> event_args = v8::Array::New(isolate, 2);
  event_args->Set(0, v8::Integer::New(isolate, stream_id));
  event_args->Set(
      1,
      v8::String::NewFromUtf8(
          isolate, message.data(), v8::String::kNormalString, message.size()));
  context()->DispatchEvent("cast.streaming.rtpStream.onError", event_args);
}

void AutomationInternalCustomBindings::RouteNodeIDFunction(
    const std::string& name,
    NodeIDFunction callback) {
  scoped_refptr<NodeIDWrapper> wrapper = new NodeIDWrapper(this, callback);
  RouteFunction(name, base::Bind(&NodeIDWrapper::Run, wrapper));
}

  explicit AutomationMessageFilter(AutomationInternalCustomBindings* owner)
      : owner_(owner),
        removed_(false) {
    DCHECK(owner);
    content::RenderThread::Get()->AddFilter(this);
    task_runner_ = base::ThreadTaskRunnerHandle::Get();
  }

void CastStreamingNativeHandler::GetRawEvents(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  CHECK_EQ(3, args.Length());
  CHECK(args[0]->IsInt32());
  CHECK(args[1]->IsNull() || args[1]->IsString());
  CHECK(args[2]->IsFunction());

  const int transport_id = args[0]->ToInt32(args.GetIsolate())->Value();
  linked_ptr<v8::Global<v8::Function>> callback(new v8::Global<v8::Function>(
      args.GetIsolate(), args[2].As<v8::Function>()));
  std::string extra_data;
  if (!args[1]->IsNull()) {
    extra_data = *v8::String::Utf8Value(args[1]);
  }

  CastRtpStream* transport = GetRtpStreamOrThrow(transport_id);
  if (!transport)
    return;

  get_raw_events_callbacks_.insert(std::make_pair(transport_id, callback));

  transport->GetRawEvents(
      base::Bind(&CastStreamingNativeHandler::CallGetRawEventsCallback,
                 weak_factory_.GetWeakPtr(),
                 transport_id),
      extra_data);
}

 void FileManagerPrivateCustomBindings::GetFileSystem(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  DCHECK(args.Length() == 2);
  DCHECK(args[0]->IsString());
  DCHECK(args[1]->IsString());
  std::string name(*v8::String::Utf8Value(args[0]));
  std::string root_url(*v8::String::Utf8Value(args[1]));

  blink::WebLocalFrame* webframe =
      blink::WebLocalFrame::frameForContext(context()->v8_context());
  DCHECK(webframe);
  args.GetReturnValue().Set(
      blink::WebDOMFileSystem::create(webframe,
                                      blink::WebFileSystemTypeExternal,
                                      blink::WebString::fromUTF8(name),
                                      GURL(root_url))
           .toV8Value(context()->v8_context()->Global(), args.GetIsolate()));
 }

void AutomationInternalCustomBindings::RouteTreeIDFunction(
    const std::string& name,
    TreeIDFunction callback) {
  scoped_refptr<TreeIDWrapper> wrapper = new TreeIDWrapper(this, callback);
  RouteFunction(name, base::Bind(&TreeIDWrapper::Run, wrapper));
}

AutomationInternalCustomBindings::AutomationInternalCustomBindings(
ScriptContext* context)
: ObjectBackedNativeHandler(context),
is_active_profile_(true),
tree_change_observer_overall_filter_(
api::automation::TREE_CHANGE_OBSERVER_FILTER_NOTREECHANGES) {
// It's safe to use base::Unretained(this) here because these bindings
// will only be called on a valid AutomationInternalCustomBindings instance
// and none of the functions have any side effects.
  #define ROUTE_FUNCTION(FN) \
  RouteFunction(#FN, \
base::Bind(&AutomationInternalCustomBindings::FN, \
                base::Unretained(this)))
ROUTE_FUNCTION(IsInteractPermitted);
ROUTE_FUNCTION(GetSchemaAdditions);
ROUTE_FUNCTION(GetRoutingID);
ROUTE_FUNCTION(StartCachingAccessibilityTrees);
ROUTE_FUNCTION(DestroyAccessibilityTree);
ROUTE_FUNCTION(AddTreeChangeObserver);
ROUTE_FUNCTION(RemoveTreeChangeObserver);
ROUTE_FUNCTION(GetChildIDAtIndex);
ROUTE_FUNCTION(GetFocus);
ROUTE_FUNCTION(GetState);
#undef ROUTE_FUNCTION

// Bindings that take a Tree ID and return a property of the tree.

RouteTreeIDFunction(
"GetRootID", [](v8::Isolate* isolate, v8::ReturnValue<v8::Value> result,
TreeCache* cache) {
result.Set(v8::Integer::New(isolate, cache->tree.root()->id()));
});
RouteTreeIDFunction(
"GetDocURL", [](v8::Isolate* isolate, v8::ReturnValue<v8::Value> result,
TreeCache* cache) {
result.Set(
v8::String::NewFromUtf8(isolate, cache->tree.data().url.c_str()));
});
RouteTreeIDFunction(
"GetDocTitle", [](v8::Isolate* isolate, v8::ReturnValue<v8::Value> result,
TreeCache* cache) {
result.Set(
v8::String::NewFromUtf8(isolate, cache->tree.data().title.c_str()));
});
RouteTreeIDFunction(
"GetDocLoaded", [](v8::Isolate* isolate,
v8::ReturnValue<v8::Value> result, TreeCache* cache) {
result.Set(v8::Boolean::New(isolate, cache->tree.data().loaded));
});
RouteTreeIDFunction("GetDocLoadingProgress",
[](v8::Isolate* isolate,
v8::ReturnValue<v8::Value> result, TreeCache* cache) {
result.Set(v8::Number::New(
isolate, cache->tree.data().loading_progress));
});
RouteTreeIDFunction("GetAnchorObjectID",
[](v8::Isolate* isolate,
v8::ReturnValue<v8::Value> result, TreeCache* cache) {
result.Set(v8::Number::New(
isolate, cache->tree.data().sel_anchor_object_id));
});
RouteTreeIDFunction("GetAnchorOffset", [](v8::Isolate* isolate,
v8::ReturnValue<v8::Value> result,
TreeCache* cache) {
result.Set(v8::Number::New(isolate, cache->tree.data().sel_anchor_offset));
});
RouteTreeIDFunction("GetFocusObjectID",
[](v8::Isolate* isolate,
v8::ReturnValue<v8::Value> result, TreeCache* cache) {
result.Set(v8::Number::New(
isolate, cache->tree.data().sel_focus_object_id));
});
RouteTreeIDFunction("GetFocusOffset", [](v8::Isolate* isolate,
v8::ReturnValue<v8::Value> result,
TreeCache* cache) {
result.Set(v8::Number::New(isolate, cache->tree.data().sel_focus_offset));
});

// Bindings that take a Tree ID and Node ID and return a property of the node.

RouteNodeIDFunction(
"GetParentID", [](v8::Isolate* isolate, v8::ReturnValue<v8::Value> result,
TreeCache* cache, ui::AXNode* node) {
if (node->parent())
result.Set(v8::Integer::New(isolate, node->parent()->id()));
});
RouteNodeIDFunction("GetChildCount", [](v8::Isolate* isolate,
v8::ReturnValue<v8::Value> result,
TreeCache* cache, ui::AXNode* node) {
result.Set(v8::Integer::New(isolate, node->child_count()));
});
RouteNodeIDFunction(
"GetIndexInParent",
[](v8::Isolate* isolate, v8::ReturnValue<v8::Value> result,
TreeCache* cache, ui::AXNode* node) {
result.Set(v8::Integer::New(isolate, node->index_in_parent()));
});
RouteNodeIDFunction(
"GetRole", [](v8::Isolate* isolate, v8::ReturnValue<v8::Value> result,
TreeCache* cache, ui::AXNode* node) {
std::string role_name = ui::ToString(node->data().role);
result.Set(v8::String::NewFromUtf8(isolate, role_name.c_str()));
});
RouteNodeIDFunction(
"GetLocation", [](v8::Isolate* isolate, v8::ReturnValue<v8::Value> result,
TreeCache* cache, ui::AXNode* node) {
gfx::Rect location = ComputeGlobalNodeBounds(cache, node);
location.Offset(cache->location_offset);
result.Set(RectToV8Object(isolate, location));
});

// Bindings that take a Tree ID and Node ID and string attribute name
// and return a property of the node.

RouteNodeIDPlusRangeFunction(
"GetBoundsForRange",
[](v8::Isolate* isolate, v8::ReturnValue<v8::Value> result,
TreeCache* cache, ui::AXNode* node, int start, int end) {
gfx::Rect location = ComputeGlobalNodeBounds(cache, node);
location.Offset(cache->location_offset);
if (node->data().role == ui::AX_ROLE_INLINE_TEXT_BOX) {
std::string name = node->data().GetStringAttribute(ui::AX_ATTR_NAME);
std::vector<int> character_offsets =
node->data().GetIntListAttribute(ui::AX_ATTR_CHARACTER_OFFSETS);
int len =
static_cast<int>(std::min(name.size(), character_offsets.size()));
if (start >= 0 && start <= end && end <= len) {
int start_offset = start > 0 ? character_offsets[start - 1] : 0;
int end_offset = end > 0 ? character_offsets[end - 1] : 0;

switch (node->data().GetIntAttribute(ui::AX_ATTR_TEXT_DIRECTION)) {
case ui::AX_TEXT_DIRECTION_LTR:
default:
location.set_x(location.x() + start_offset);
location.set_width(end_offset - start_offset);
break;
case ui::AX_TEXT_DIRECTION_RTL:
location.set_x(location.x() + location.width() - end_offset);
location.set_width(end_offset - start_offset);
break;
case ui::AX_TEXT_DIRECTION_TTB:
location.set_y(location.y() + start_offset);
location.set_height(end_offset - start_offset);
break;
case ui::AX_TEXT_DIRECTION_BTT:
location.set_y(location.y() + location.height() - end_offset);
location.set_height(end_offset - start_offset);
break;
}
}
}
result.Set(RectToV8Object(isolate, location));
});

// Bindings that take a Tree ID and Node ID and string attribute name
// and return a property of the node.

RouteNodeIDPlusAttributeFunction(
"GetStringAttribute",
[](v8::Isolate* isolate, v8::ReturnValue<v8::Value> result,
ui::AXNode* node, const std::string& attribute_name) {
ui::AXStringAttribute attribute =
ui::ParseAXStringAttribute(attribute_name);
std::string attr_value;
if (!node->data().GetStringAttribute(attribute, &attr_value))
return;

result.Set(v8::String::NewFromUtf8(isolate, attr_value.c_str()));
});
RouteNodeIDPlusAttributeFunction(
"GetBoolAttribute",
[](v8::Isolate* isolate, v8::ReturnValue<v8::Value> result,
ui::AXNode* node, const std::string& attribute_name) {
ui::AXBoolAttribute attribute =
ui::ParseAXBoolAttribute(attribute_name);
bool attr_value;
if (!node->data().GetBoolAttribute(attribute, &attr_value))
return;

result.Set(v8::Boolean::New(isolate, attr_value));
});
RouteNodeIDPlusAttributeFunction(
"GetIntAttribute",
[](v8::Isolate* isolate, v8::ReturnValue<v8::Value> result,
ui::AXNode* node, const std::string& attribute_name) {
ui::AXIntAttribute attribute = ui::ParseAXIntAttribute(attribute_name);
int attr_value;
if (!node->data().GetIntAttribute(attribute, &attr_value))
return;

result.Set(v8::Integer::New(isolate, attr_value));
});
RouteNodeIDPlusAttributeFunction(
"GetFloatAttribute",
[](v8::Isolate* isolate, v8::ReturnValue<v8::Value> result,
ui::AXNode* node, const std::string& attribute_name) {
ui::AXFloatAttribute attribute =
ui::ParseAXFloatAttribute(attribute_name);
float attr_value;

if (!node->data().GetFloatAttribute(attribute, &attr_value))
return;

result.Set(v8::Number::New(isolate, attr_value));
});
RouteNodeIDPlusAttributeFunction(
"GetIntListAttribute",
[](v8::Isolate* isolate, v8::ReturnValue<v8::Value> result,
ui::AXNode* node, const std::string& attribute_name) {
ui::AXIntListAttribute attribute =
ui::ParseAXIntListAttribute(attribute_name);
if (!node->data().HasIntListAttribute(attribute))
return;
const std::vector<int32_t>& attr_value =
node->data().GetIntListAttribute(attribute);

v8::Local<v8::Array> array_result(
v8::Array::New(isolate, attr_value.size()));
for (size_t i = 0; i < attr_value.size(); ++i)
array_result->Set(static_cast<uint32_t>(i),
v8::Integer::New(isolate, attr_value[i]));
result.Set(array_result);
});
RouteNodeIDPlusAttributeFunction(
"GetHtmlAttribute",
[](v8::Isolate* isolate, v8::ReturnValue<v8::Value> result,
ui::AXNode* node, const std::string& attribute_name) {
std::string attr_value;
if (!node->data().GetHtmlAttribute(attribute_name.c_str(), &attr_value))
return;

result.Set(v8::String::NewFromUtf8(isolate, attr_value.c_str()));
});
}

bool AutomationInternalCustomBindings::GetFocusInternal(TreeCache* cache,
                                                        TreeCache** out_cache,
                                                        ui::AXNode** out_node) {
  int focus_id = cache->tree.data().focus_id;
  ui::AXNode* focus = cache->tree.GetFromId(focus_id);
  if (!focus)
    return false;

  while (focus->data().HasIntAttribute(ui::AX_ATTR_CHILD_TREE_ID)) {
    int child_tree_id =
        focus->data().GetIntAttribute(ui::AX_ATTR_CHILD_TREE_ID);

    TreeCache* child_cache = GetTreeCacheFromTreeID(child_tree_id);
    if (!child_cache)
      break;

    if (child_cache->tree.data().focused_tree_id > 0) {
      TreeCache* focused_cache =
          GetTreeCacheFromTreeID(child_cache->tree.data().focused_tree_id);
      if (focused_cache)
        child_cache = focused_cache;
    }

    int child_focus_id = child_cache->tree.data().focus_id;
    ui::AXNode* child_focus = child_cache->tree.GetFromId(child_focus_id);
    if (!child_focus)
      break;

    focus = child_focus;
    cache = child_cache;
  }

  *out_cache = cache;
  *out_node = focus;
  return true;
}

AutomationInternalCustomBindings::~AutomationInternalCustomBindings() {}

bool ToCastRtpParamsOrThrow(v8::Isolate* isolate,
                            const RtpParams& ext_params,
                            CastRtpParams* cast_params) {
  std::copy(ext_params.rtcp_features.begin(),
            ext_params.rtcp_features.end(),
            std::back_inserter(cast_params->rtcp_features));
  if (!ToCastRtpPayloadParamsOrThrow(isolate,
                                     ext_params.payload,
                                     &cast_params->payload)) {
    return false;
  }
  return true;
}

void ObjectBackedNativeHandler::Router(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  v8::Isolate* isolate = args.GetIsolate();
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Object> data = args.Data().As<v8::Object>();
  v8::Local<v8::Context> context = isolate->GetCurrentContext();

  v8::Local<v8::Value> handler_function_value;
  v8::Local<v8::Value> feature_name_value;
  if (!GetPrivate(context, data, kHandlerFunction, &handler_function_value) ||
      handler_function_value->IsUndefined() ||
      !GetPrivate(context, data, kFeatureName, &feature_name_value) ||
      !feature_name_value->IsString()) {
    ScriptContext* script_context =
        ScriptContextSet::GetContextByV8Context(context);
    console::Error(script_context ? script_context->GetRenderFrame() : nullptr,
                   "Extension view no longer exists");
    return;
  }

  if (content::WorkerThread::GetCurrentId() == 0) {
    ScriptContext* script_context =
        ScriptContextSet::GetContextByV8Context(context);
    v8::Local<v8::String> feature_name_string =
        feature_name_value->ToString(context).ToLocalChecked();
    std::string feature_name = *v8::String::Utf8Value(feature_name_string);
    if (script_context &&
        !feature_name.empty() &&
        !script_context->GetAvailability(feature_name).is_available()) {
      return;
    }
  }
  CHECK(handler_function_value->IsExternal());
  static_cast<HandlerFunction*>(
      handler_function_value.As<v8::External>()->Value())->Run(args);
}

CastStreamingNativeHandler::CastStreamingNativeHandler(ScriptContext* context)
: ObjectBackedNativeHandler(context),
last_transport_id_(1),
weak_factory_(this) {
  RouteFunction("CreateSession",
base::Bind(&CastStreamingNativeHandler::CreateCastSession,
weak_factory_.GetWeakPtr()));
  RouteFunction("DestroyCastRtpStream",
base::Bind(&CastStreamingNativeHandler::DestroyCastRtpStream,
weak_factory_.GetWeakPtr()));
RouteFunction(
      "GetSupportedParamsCastRtpStream",
base::Bind(&CastStreamingNativeHandler::GetSupportedParamsCastRtpStream,
weak_factory_.GetWeakPtr()));
  RouteFunction("StartCastRtpStream",
base::Bind(&CastStreamingNativeHandler::StartCastRtpStream,
weak_factory_.GetWeakPtr()));
  RouteFunction("StopCastRtpStream",
base::Bind(&CastStreamingNativeHandler::StopCastRtpStream,
weak_factory_.GetWeakPtr()));
  RouteFunction("DestroyCastUdpTransport",
base::Bind(&CastStreamingNativeHandler::DestroyCastUdpTransport,
weak_factory_.GetWeakPtr()));
RouteFunction(
      "SetDestinationCastUdpTransport",
base::Bind(&CastStreamingNativeHandler::SetDestinationCastUdpTransport,
weak_factory_.GetWeakPtr()));
RouteFunction(
      "SetOptionsCastUdpTransport",
base::Bind(&CastStreamingNativeHandler::SetOptionsCastUdpTransport,
weak_factory_.GetWeakPtr()));
  RouteFunction("ToggleLogging",
base::Bind(&CastStreamingNativeHandler::ToggleLogging,
weak_factory_.GetWeakPtr()));
  RouteFunction("GetRawEvents",
base::Bind(&CastStreamingNativeHandler::GetRawEvents,
weak_factory_.GetWeakPtr()));
  RouteFunction("GetStats", base::Bind(&CastStreamingNativeHandler::GetStats,
                                       weak_factory_.GetWeakPtr()));
  RouteFunction("StartCastRtpReceiver",
base::Bind(&CastStreamingNativeHandler::StartCastRtpReceiver,
weak_factory_.GetWeakPtr()));
}

bool CastStreamingNativeHandler::FrameReceiverConfigFromArg(
    v8::Isolate* isolate,
    const v8::Local<v8::Value>& arg,
    media::cast::FrameReceiverConfig* config) const {
  scoped_ptr<V8ValueConverter> converter(V8ValueConverter::create());
  scoped_ptr<base::Value> params_value(
      converter->FromV8Value(arg, context()->v8_context()));
  if (!params_value) {
    isolate->ThrowException(v8::Exception::TypeError(
        v8::String::NewFromUtf8(isolate, kUnableToConvertParams)));
    return false;
  }
  scoped_ptr<RtpReceiverParams> params =
      RtpReceiverParams::FromValue(*params_value);
  if (!params) {
    isolate->ThrowException(v8::Exception::TypeError(
        v8::String::NewFromUtf8(isolate, kInvalidRtpParams)));
    return false;
  }

  config->receiver_ssrc = params->receiver_ssrc;
  config->sender_ssrc = params->sender_ssrc;
  config->rtp_max_delay_ms = params->max_latency;
  if (config->rtp_max_delay_ms < 0 || config->rtp_max_delay_ms > 1000) {
    isolate->ThrowException(v8::Exception::TypeError(
        v8::String::NewFromUtf8(isolate, kInvalidLatency)));
    return false;
  }
  config->channels = 2;
  if (params->codec_name == "OPUS") {
    config->codec = media::cast::CODEC_AUDIO_OPUS;
    config->rtp_timebase = 48000;
    config->rtp_payload_type = media::cast::kDefaultRtpAudioPayloadType;
  } else if (params->codec_name == "PCM16") {
    config->codec = media::cast::CODEC_AUDIO_PCM16;
    config->rtp_timebase = 48000;
    config->rtp_payload_type = media::cast::kDefaultRtpAudioPayloadType;
  } else if (params->codec_name == "AAC") {
    config->codec = media::cast::CODEC_AUDIO_AAC;
    config->rtp_timebase = 48000;
    config->rtp_payload_type = media::cast::kDefaultRtpAudioPayloadType;
  } else if (params->codec_name == "VP8") {
    config->codec = media::cast::CODEC_VIDEO_VP8;
    config->rtp_timebase = 90000;
    config->rtp_payload_type = media::cast::kDefaultRtpVideoPayloadType;
  } else if (params->codec_name == "H264") {
    config->codec = media::cast::CODEC_VIDEO_H264;
    config->rtp_timebase = 90000;
    config->rtp_payload_type = media::cast::kDefaultRtpVideoPayloadType;
  }
  if (params->rtp_timebase) {
    config->rtp_timebase = *params->rtp_timebase;
    if (config->rtp_timebase < 1000 || config->rtp_timebase > 1000000) {
      isolate->ThrowException(v8::Exception::TypeError(
          v8::String::NewFromUtf8(isolate, kInvalidRtpTimebase)));
      return false;
    }
  }
  if (params->aes_key &&
      !HexDecode(*params->aes_key, &config->aes_key)) {
    isolate->ThrowException(v8::Exception::Error(
        v8::String::NewFromUtf8(isolate, kInvalidAesKey)));
    return false;
  }
  if (params->aes_iv_mask &&
      !HexDecode(*params->aes_iv_mask, &config->aes_iv_mask)) {
    isolate->ThrowException(v8::Exception::Error(
        v8::String::NewFromUtf8(isolate, kInvalidAesIvMask)));
    return false;
  }
  return true;
}

FileBrowserHandlerCustomBindings::FileBrowserHandlerCustomBindings(
ScriptContext* context)
: ObjectBackedNativeHandler(context) {
RouteFunction(
      "GetExternalFileEntry",
      base::Bind(&FileBrowserHandlerCustomBindings::GetExternalFileEntry,
                 base::Unretained(this)));
  RouteFunction("GetEntryURL",
                base::Bind(&FileBrowserHandlerCustomBindings::GetEntryURL,
                           base::Unretained(this)));
}

  void Run(const v8::FunctionCallbackInfo<v8::Value>& args) {
    v8::Isolate* isolate = automation_bindings_->GetIsolate();
    if (args.Length() < 2 || !args[0]->IsNumber() || !args[1]->IsNumber())
      ThrowInvalidArgumentsException(automation_bindings_);

    int tree_id = args[0]->Int32Value();
    int node_id = args[1]->Int32Value();

    TreeCache* cache = automation_bindings_->GetTreeCacheFromTreeID(tree_id);
    if (!cache)
      return;

    ui::AXNode* node = cache->tree.GetFromId(node_id);
    if (!node)
      return;

    function_(isolate, args.GetReturnValue(), cache, node);
  }

void AutomationInternalCustomBindings::AddTreeChangeObserver(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  if (args.Length() != 2 || !args[0]->IsNumber() || !args[1]->IsString()) {
    ThrowInvalidArgumentsException(this);
    return;
  }

  TreeChangeObserver observer;
  observer.id = args[0]->Int32Value();
  std::string filter_str = *v8::String::Utf8Value(args[1]);
  observer.filter = api::automation::ParseTreeChangeObserverFilter(filter_str);

  tree_change_observers_.push_back(observer);
  UpdateOverallTreeChangeObserverFilter();
}

void CastStreamingNativeHandler::CallReceiverErrorCallback(
    v8::CopyablePersistentTraits<v8::Function>::CopyablePersistent function,
    const std::string& error_message) {
  v8::Isolate* isolate = context()->v8_context()->GetIsolate();
  v8::Local<v8::Value> arg = v8::String::NewFromUtf8(isolate,
                                                      error_message.data(),
                                                      v8::String::kNormalString,
                                                      error_message.size());
  context()->CallFunction(
      v8::Local<v8::Function>::New(isolate, function), 1, &arg);
}

ui::AXNode* FindNodeWithChildTreeId(ui::AXNode* node, int child_tree_id) {
  if (child_tree_id == node->data().GetIntAttribute(ui::AX_ATTR_CHILD_TREE_ID))
    return node;

  for (int i = 0; i < node->child_count(); ++i) {
    ui::AXNode* result =
        FindNodeWithChildTreeId(node->ChildAtIndex(i), child_tree_id);
    if (result)
      return result;
  }

  return nullptr;
}

void FileBrowserHandlerCustomBindings::GetEntryURL(
const v8::FunctionCallbackInfo<v8::Value>& args) {
  CHECK(args.Length() == 1);
  CHECK(args[0]->IsObject());
  const blink::WebURL& url =
      blink::WebDOMFileSystem::createFileSystemURL(args[0]);
  args.GetReturnValue().Set(v8_helpers::ToV8StringUnsafe(
      args.GetIsolate(), url.string().utf8().c_str()));
}

  void Run(const v8::FunctionCallbackInfo<v8::Value>& args) {
    v8::Isolate* isolate = automation_bindings_->GetIsolate();
    if (args.Length() < 3 || !args[0]->IsNumber() || !args[1]->IsNumber() ||
        !args[2]->IsString()) {
      ThrowInvalidArgumentsException(automation_bindings_);
    }

    int tree_id = args[0]->Int32Value();
    int node_id = args[1]->Int32Value();
    std::string attribute = *v8::String::Utf8Value(args[2]);

    TreeCache* cache = automation_bindings_->GetTreeCacheFromTreeID(tree_id);
    if (!cache)
      return;

    ui::AXNode* node = cache->tree.GetFromId(node_id);
    if (!node)
      return;

    function_(isolate, args.GetReturnValue(), node, attribute);
  }

CastUdpTransport* CastStreamingNativeHandler::GetUdpTransportOrThrow(
    int transport_id) const {
  UdpTransportMap::const_iterator iter = udp_transport_map_.find(
      transport_id);
  if (iter != udp_transport_map_.end())
    return iter->second.get();
  v8::Isolate* isolate = context()->v8_context()->GetIsolate();
  isolate->ThrowException(v8::Exception::RangeError(
      v8::String::NewFromUtf8(isolate, kUdpTransportNotFound)));
  return NULL;
}

void AutomationInternalCustomBindings::GetChildIDAtIndex(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  if (args.Length() < 3 || !args[2]->IsNumber()) {
    ThrowInvalidArgumentsException(this);
    return;
  }

  int tree_id = args[0]->Int32Value();
  int node_id = args[1]->Int32Value();

  const auto iter = tree_id_to_tree_cache_map_.find(tree_id);
  if (iter == tree_id_to_tree_cache_map_.end())
    return;

  TreeCache* cache = iter->second;
  if (!cache)
    return;

  ui::AXNode* node = cache->tree.GetFromId(node_id);
  if (!node)
    return;

  int index = args[2]->Int32Value();
  if (index < 0 || index >= node->child_count())
    return;

  int child_id = node->children()[index]->id();
  args.GetReturnValue().Set(v8::Integer::New(GetIsolate(), child_id));
}

CastRtpStream* CastStreamingNativeHandler::GetRtpStreamOrThrow(
    int transport_id) const {
  RtpStreamMap::const_iterator iter = rtp_stream_map_.find(
      transport_id);
  if (iter != rtp_stream_map_.end())
    return iter->second.get();
  v8::Isolate* isolate = context()->v8_context()->GetIsolate();
  isolate->ThrowException(v8::Exception::RangeError(v8::String::NewFromUtf8(
      isolate, kRtpStreamNotFound)));
  return NULL;
}

bool ToCastRtpPayloadParamsOrThrow(v8::Isolate* isolate,
                                   const RtpPayloadParams& ext_params,
                                   CastRtpPayloadParams* cast_params) {
  cast_params->payload_type = ext_params.payload_type;
  cast_params->max_latency_ms = ext_params.max_latency;
  cast_params->min_latency_ms =
      ext_params.min_latency ? *ext_params.min_latency : ext_params.max_latency;
  cast_params->animated_latency_ms = ext_params.animated_latency
                                         ? *ext_params.animated_latency
                                         : ext_params.max_latency;
  cast_params->codec_name = ext_params.codec_name;
  cast_params->ssrc = ext_params.ssrc;
  cast_params->feedback_ssrc = ext_params.feedback_ssrc;
  cast_params->clock_rate = ext_params.clock_rate ? *ext_params.clock_rate : 0;
  cast_params->min_bitrate =
      ext_params.min_bitrate ? *ext_params.min_bitrate : 0;
  cast_params->max_bitrate =
      ext_params.max_bitrate ? *ext_params.max_bitrate : 0;
  cast_params->channels = ext_params.channels ? *ext_params.channels : 0;
  cast_params->max_frame_rate =
      ext_params.max_frame_rate ? *ext_params.max_frame_rate : 0.0;
  if (ext_params.aes_key &&
      !HexDecode(*ext_params.aes_key, &cast_params->aes_key)) {
    isolate->ThrowException(v8::Exception::Error(
        v8::String::NewFromUtf8(isolate, kInvalidAesKey)));
    return false;
  }
  if (ext_params.aes_iv_mask &&
      !HexDecode(*ext_params.aes_iv_mask, &cast_params->aes_iv_mask)) {
    isolate->ThrowException(v8::Exception::Error(
        v8::String::NewFromUtf8(isolate, kInvalidAesIvMask)));
    return false;
  }
  for (size_t i = 0; i < ext_params.codec_specific_params.size(); ++i) {
    CastCodecSpecificParams cast_codec_params;
    ToCastCodecSpecificParams(ext_params.codec_specific_params[i],
                              &cast_codec_params);
    cast_params->codec_specific_params.push_back(cast_codec_params);
  }
  return true;
}

v8::Local<v8::Object> RectToV8Object(v8::Isolate* isolate,
                                     const gfx::Rect& rect) {
  v8::Local<v8::Object> result(v8::Object::New(isolate));
  result->Set(CreateV8String(isolate, "left"),
              v8::Integer::New(isolate, rect.x()));
  result->Set(CreateV8String(isolate, "top"),
              v8::Integer::New(isolate, rect.y()));
  result->Set(CreateV8String(isolate, "width"),
              v8::Integer::New(isolate, rect.width()));
  result->Set(CreateV8String(isolate, "height"),
              v8::Integer::New(isolate, rect.height()));
  return result;
}

void AutomationInternalCustomBindings::SendChildTreeIDEvent(ui::AXTree* tree,
                                                            ui::AXNode* node) {
  auto iter = axtree_to_tree_cache_map_.find(tree);
  if (iter == axtree_to_tree_cache_map_.end())
    return;

  int tree_id = iter->second->tree_id;

  v8::Isolate* isolate = GetIsolate();
  v8::HandleScope handle_scope(isolate);
  v8::Context::Scope context_scope(context()->v8_context());
  v8::Local<v8::Array> args(v8::Array::New(GetIsolate(), 2U));
  args->Set(0U, v8::Integer::New(GetIsolate(), tree_id));
  args->Set(1U, v8::Integer::New(GetIsolate(), node->id()));
  context()->DispatchEvent("automationInternal.onChildTreeID", args);
}

void AutomationInternalCustomBindings::IsInteractPermitted(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  const Extension* extension = context()->extension();
  CHECK(extension);
  const AutomationInfo* automation_info = AutomationInfo::Get(extension);
  CHECK(automation_info);
  args.GetReturnValue().Set(
      v8::Boolean::New(GetIsolate(), automation_info->interact));
}

void AutomationInternalCustomBindings::OnNodeCreated(ui::AXTree* tree,
                                                     ui::AXNode* node) {
}

void AutomationInternalCustomBindings::OnNodeChanged(ui::AXTree* tree,
                                                     ui::AXNode* node) {
}

CastStreamingNativeHandler::~CastStreamingNativeHandler() {
}

  void Detach() {
    owner_ = nullptr;
    Remove();
  }

void MediaGalleriesCustomBindings::GetMediaFileSystemObject(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  CHECK_EQ(1, args.Length());
  CHECK(args[0]->IsString());

  std::string fs_mount(*v8::String::Utf8Value(args[0]));
  CHECK(!fs_mount.empty());

  blink::WebLocalFrame* webframe =
      blink::WebLocalFrame::frameForCurrentContext();
  const GURL origin = blink::WebStringToGURL(
      webframe->document().getSecurityOrigin().toString());
  std::string fs_name =
      storage::GetFileSystemName(origin, storage::kFileSystemTypeExternal);
  fs_name.append("_");
  fs_name.append(fs_mount);
  const GURL root_url(
      storage::GetExternalFileSystemRootURIString(origin, fs_mount));
  args.GetReturnValue().Set(
      blink::WebDOMFileSystem::create(webframe,
                                      blink::WebFileSystemTypeExternal,
                                      blink::WebString::fromUTF8(fs_name),
                                      root_url)
          .toV8Value(context()->v8_context()->Global(), args.GetIsolate()));
}

void NotificationsNativeHandler::GetNotificationImageSizes(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  NotificationBitmapSizes bitmap_sizes = GetNotificationBitmapSizes();

  float scale_factor =
      ui::GetScaleForScaleFactor(ui::GetSupportedScaleFactors().back());

  scoped_ptr<base::DictionaryValue> dict(new base::DictionaryValue);
  dict->SetDouble("scaleFactor", scale_factor);
  dict->SetInteger("icon.width", bitmap_sizes.icon_size.width());
  dict->SetInteger("icon.height", bitmap_sizes.icon_size.height());
  dict->SetInteger("image.width", bitmap_sizes.image_size.width());
  dict->SetInteger("image.height", bitmap_sizes.image_size.height());
  dict->SetInteger("buttonIcon.width", bitmap_sizes.button_icon_size.width());
  dict->SetInteger("buttonIcon.height", bitmap_sizes.button_icon_size.height());
  dict->SetInteger("appIconMask.width",
                   bitmap_sizes.app_icon_mask_size.width());
  dict->SetInteger("appIconMask.height",
                   bitmap_sizes.app_icon_mask_size.height());

  scoped_ptr<content::V8ValueConverter> converter(
      content::V8ValueConverter::create());
  args.GetReturnValue().Set(
      converter->ToV8Value(dict.get(), context()->v8_context()));
}

void AutomationInternalCustomBindings::GetState(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  v8::Isolate* isolate = GetIsolate();
  if (args.Length() < 2 || !args[0]->IsNumber() || !args[1]->IsNumber())
    ThrowInvalidArgumentsException(this);

  int tree_id = args[0]->Int32Value();
  int node_id = args[1]->Int32Value();

  TreeCache* cache = GetTreeCacheFromTreeID(tree_id);
  if (!cache)
    return;

  ui::AXNode* node = cache->tree.GetFromId(node_id);
  if (!node)
    return;

  v8::Local<v8::Object> state(v8::Object::New(isolate));
  uint32_t state_pos = 0, state_shifter = node->data().state;
  while (state_shifter) {
    if (state_shifter & 1) {
      std::string key = ToString(static_cast<ui::AXState>(state_pos));
      state->Set(CreateV8String(isolate, key), v8::Boolean::New(isolate, true));
    }
    state_shifter = state_shifter >> 1;
    state_pos++;
  }

  TreeCache* top_cache = GetTreeCacheFromTreeID(0);
  if (!top_cache)
    top_cache = cache;
  TreeCache* focused_cache = nullptr;
  ui::AXNode* focused_node = nullptr;
  if (GetFocusInternal(top_cache, &focused_cache, &focused_node)) {
    if (focused_cache == cache && focused_node == node) {
      state->Set(CreateV8String(isolate, "focused"),
                 v8::Boolean::New(isolate, true));
    }
  }
  if (cache->tree.data().focus_id == node->id()) {
    state->Set(CreateV8String(isolate, "focused"),
               v8::Boolean::New(isolate, true));
  }

  args.GetReturnValue().Set(state);
}

void FromCastRtpPayloadParams(const CastRtpPayloadParams& cast_params,
                              RtpPayloadParams* ext_params) {
  ext_params->payload_type = cast_params.payload_type;
  ext_params->max_latency = cast_params.max_latency_ms;
  ext_params->min_latency.reset(new int(cast_params.min_latency_ms));
  ext_params->animated_latency.reset(new int(cast_params.animated_latency_ms));
  ext_params->codec_name = cast_params.codec_name;
  ext_params->ssrc = cast_params.ssrc;
  ext_params->feedback_ssrc = cast_params.feedback_ssrc;
  if (cast_params.clock_rate)
    ext_params->clock_rate.reset(new int(cast_params.clock_rate));
  if (cast_params.min_bitrate)
    ext_params->min_bitrate.reset(new int(cast_params.min_bitrate));
  if (cast_params.max_bitrate)
    ext_params->max_bitrate.reset(new int(cast_params.max_bitrate));
  if (cast_params.channels)
    ext_params->channels.reset(new int(cast_params.channels));
  if (cast_params.max_frame_rate > 0.0)
    ext_params->max_frame_rate.reset(new double(cast_params.max_frame_rate));
  for (size_t i = 0; i < cast_params.codec_specific_params.size(); ++i) {
    CodecSpecificParams ext_codec_params;
    FromCastCodecSpecificParams(cast_params.codec_specific_params[i],
                                &ext_codec_params);
    ext_params->codec_specific_params.push_back(std::move(ext_codec_params));
  }
}

void CastStreamingNativeHandler::GetStats(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  CHECK_EQ(2, args.Length());
  CHECK(args[0]->IsInt32());
  CHECK(args[1]->IsFunction());
  const int transport_id = args[0]->ToInt32(args.GetIsolate())->Value();
  CastRtpStream* transport = GetRtpStreamOrThrow(transport_id);
  if (!transport)
    return;

  linked_ptr<v8::Global<v8::Function>> callback(new v8::Global<v8::Function>(
      args.GetIsolate(), args[1].As<v8::Function>()));
  get_stats_callbacks_.insert(std::make_pair(transport_id, callback));

  transport->GetStats(
      base::Bind(&CastStreamingNativeHandler::CallGetStatsCallback,
                 weak_factory_.GetWeakPtr(),
                 transport_id));
}

void AutomationInternalCustomBindings::OnSubtreeWillBeDeleted(
    ui::AXTree* tree,
    ui::AXNode* node) {
}

  NodeIDWrapper(AutomationInternalCustomBindings* automation_bindings,
                NodeIDFunction function)
      : automation_bindings_(automation_bindings), function_(function) {}

TreeCache* AutomationInternalCustomBindings::GetTreeCacheFromTreeID(
    int tree_id) {
  const auto iter = tree_id_to_tree_cache_map_.find(tree_id);
  if (iter == tree_id_to_tree_cache_map_.end())
    return nullptr;

  return iter->second;
}

void AutomationInternalCustomBindings::GetFocus(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  if (args.Length() != 1 || !args[0]->IsNumber()) {
    ThrowInvalidArgumentsException(this);
    return;
  }

  int tree_id = args[0]->Int32Value();
  TreeCache* cache = GetTreeCacheFromTreeID(tree_id);
  if (!cache)
    return;

  TreeCache* focused_tree_cache = nullptr;
  ui::AXNode* focused_node = nullptr;
  if (!GetFocusInternal(cache, &focused_tree_cache, &focused_node))
    return;

  v8::Isolate* isolate = GetIsolate();
  v8::Local<v8::Object> result(v8::Object::New(isolate));
  result->Set(CreateV8String(isolate, "treeId"),
              v8::Integer::New(isolate, focused_tree_cache->tree_id));
  result->Set(CreateV8String(isolate, "nodeId"),
              v8::Integer::New(isolate, focused_node->id()));
  args.GetReturnValue().Set(result);
}

void AutomationInternalCustomBindings::GetSchemaAdditions(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  v8::Local<v8::Object> additions = v8::Object::New(GetIsolate());

  additions->Set(
      v8::String::NewFromUtf8(GetIsolate(), "EventType"),
      ToEnumObject(GetIsolate(), ui::AX_EVENT_NONE, ui::AX_EVENT_LAST));

  additions->Set(
      v8::String::NewFromUtf8(GetIsolate(), "RoleType"),
      ToEnumObject(GetIsolate(), ui::AX_ROLE_NONE, ui::AX_ROLE_LAST));

  additions->Set(
      v8::String::NewFromUtf8(GetIsolate(), "StateType"),
      ToEnumObject(GetIsolate(), ui::AX_STATE_NONE, ui::AX_STATE_LAST));

  additions->Set(
      v8::String::NewFromUtf8(GetIsolate(), "TreeChangeType"),
      ToEnumObject(GetIsolate(), ui::AX_MUTATION_NONE, ui::AX_MUTATION_LAST));

  args.GetReturnValue().Set(additions);
}

void FromCastCodecSpecificParams(const CastCodecSpecificParams& cast_params,
                                 CodecSpecificParams* ext_params) {
  ext_params->key = cast_params.key;
  ext_params->value = cast_params.value;
}

void CastStreamingNativeHandler::Invalidate() {
  weak_factory_.InvalidateWeakPtrs();

  get_stats_callbacks_.clear();
  get_raw_events_callbacks_.clear();
  create_callback_.Reset();
  udp_transport_map_.clear();
  rtp_stream_map_.clear();

  ObjectBackedNativeHandler::Invalidate();
}

  virtual ~NodeIDPlusRangeWrapper() {}

  NodeIDPlusAttributeWrapper(
      AutomationInternalCustomBindings* automation_bindings,
      NodeIDPlusAttributeFunction function)
      : automation_bindings_(automation_bindings), function_(function) {}

TreeCache::TreeCache() {}

static gfx::Rect ComputeGlobalNodeBounds(TreeCache* cache, ui::AXNode* node) {
  gfx::Rect bounds = ComputeLocalNodeBounds(cache, node);
  ui::AXNode* parent = node->parent();
  bool need_to_offset_web_area = node->data().role == ui::AX_ROLE_WEB_AREA ||
                                 node->data().role == ui::AX_ROLE_ROOT_WEB_AREA;
  while (parent) {
    if (bounds.IsEmpty()) {
      bounds = parent->data().location;
    } else if (need_to_offset_web_area && parent->data().location.width() > 0 &&
               parent->data().location.height() > 0) {
      bounds.Offset(parent->data().location.x(), parent->data().location.y());
      need_to_offset_web_area = false;
    }

    if (parent->data().role == ui::AX_ROLE_WEB_AREA ||
        parent->data().role == ui::AX_ROLE_ROOT_WEB_AREA) {
      int sx = 0;
      int sy = 0;
      if (parent->data().GetIntAttribute(ui::AX_ATTR_SCROLL_X, &sx) &&
          parent->data().GetIntAttribute(ui::AX_ATTR_SCROLL_Y, &sy)) {
        bounds.Offset(-sx, -sy);
      }
      need_to_offset_web_area = true;
    }
    parent = cache->owner->GetParent(parent, &cache);
  }

  return bounds;
}

bool CastStreamingNativeHandler::IPEndPointFromArg(
    v8::Isolate* isolate,
    const v8::Local<v8::Value>& arg,
    net::IPEndPoint* ip_endpoint) const {
  scoped_ptr<V8ValueConverter> converter(V8ValueConverter::create());
  scoped_ptr<base::Value> destination_value(
      converter->FromV8Value(arg, context()->v8_context()));
  if (!destination_value) {
    isolate->ThrowException(v8::Exception::TypeError(
        v8::String::NewFromUtf8(isolate, kInvalidAesIvMask)));
    return false;
  }
  scoped_ptr<IPEndPoint> destination =
      IPEndPoint::FromValue(*destination_value);
  if (!destination) {
    isolate->ThrowException(v8::Exception::TypeError(
        v8::String::NewFromUtf8(isolate, kInvalidDestination)));
    return false;
  }
  net::IPAddress ip;
  if (!ip.AssignFromIPLiteral(destination->address)) {
    isolate->ThrowException(v8::Exception::TypeError(
        v8::String::NewFromUtf8(isolate, kInvalidDestination)));
    return false;
  }
  *ip_endpoint = net::IPEndPoint(ip, destination->port);
  return true;
}

void CastStreamingNativeHandler::CallGetRawEventsCallback(
    int transport_id,
    scoped_ptr<base::BinaryValue> raw_events) {
  v8::Isolate* isolate = context()->isolate();
  v8::HandleScope handle_scope(isolate);
  v8::Context::Scope context_scope(context()->v8_context());

  RtpStreamCallbackMap::iterator it =
      get_raw_events_callbacks_.find(transport_id);
  if (it == get_raw_events_callbacks_.end())
    return;
  scoped_ptr<V8ValueConverter> converter(V8ValueConverter::create());
  v8::Local<v8::Value> callback_args[] = {
      converter->ToV8Value(raw_events.get(), context()->v8_context())};
  context()->CallFunction(v8::Local<v8::Function>::New(isolate, *it->second),
                          arraysize(callback_args), callback_args);
  get_raw_events_callbacks_.erase(it);
}

void FromCastRtpParams(const CastRtpParams& cast_params,
                       RtpParams* ext_params) {
  std::copy(cast_params.rtcp_features.begin(),
            cast_params.rtcp_features.end(),
            std::back_inserter(ext_params->rtcp_features));
  FromCastRtpPayloadParams(cast_params.payload, &ext_params->payload);
}

  void Remove() {
    if (!removed_) {
      removed_ = true;
      content::RenderThread::Get()->RemoveFilter(this);
    }
  }

void AutomationInternalCustomBindings::OnTreeDataChanged(ui::AXTree* tree) {}

void AutomationInternalCustomBindings::RouteNodeIDPlusRangeFunction(
    const std::string& name,
    NodeIDPlusRangeFunction callback) {
  scoped_refptr<NodeIDPlusRangeWrapper> wrapper =
      new NodeIDPlusRangeWrapper(this, callback);
  RouteFunction(name, base::Bind(&NodeIDPlusRangeWrapper::Run, wrapper));
}

void AutomationInternalCustomBindings::OnAccessibilityEvent(
    const ExtensionMsg_AccessibilityEventParams& params,
    bool is_active_profile) {
  is_active_profile_ = is_active_profile;
  int tree_id = params.tree_id;
  TreeCache* cache;
  auto iter = tree_id_to_tree_cache_map_.find(tree_id);
  if (iter == tree_id_to_tree_cache_map_.end()) {
    cache = new TreeCache();
    cache->tab_id = -1;
    cache->tree_id = params.tree_id;
    cache->parent_node_id_from_parent_tree = -1;
    cache->tree.SetDelegate(this);
    cache->owner = this;
    tree_id_to_tree_cache_map_.insert(std::make_pair(tree_id, cache));
    axtree_to_tree_cache_map_.insert(std::make_pair(&cache->tree, cache));
  } else {
    cache = iter->second;
  }

  cache->location_offset = params.location_offset;
  deleted_node_ids_.clear();
  if (!cache->tree.Unserialize(params.update)) {
    LOG(ERROR) << cache->tree.error();
    return;
  }

  if (!is_active_profile)
    return;

  SendNodesRemovedEvent(&cache->tree, deleted_node_ids_);
  deleted_node_ids_.clear();

  v8::Isolate* isolate = GetIsolate();
  v8::HandleScope handle_scope(isolate);
  v8::Context::Scope context_scope(context()->v8_context());
  v8::Local<v8::Array> args(v8::Array::New(GetIsolate(), 1U));
  v8::Local<v8::Object> event_params(v8::Object::New(GetIsolate()));
  event_params->Set(CreateV8String(isolate, "treeID"),
                    v8::Integer::New(GetIsolate(), params.tree_id));
  event_params->Set(CreateV8String(isolate, "targetID"),
                    v8::Integer::New(GetIsolate(), params.id));
  event_params->Set(CreateV8String(isolate, "eventType"),
                    CreateV8String(isolate, ToString(params.event_type)));
  args->Set(0U, event_params);
  context()->DispatchEvent("automationInternal.onAccessibilityEvent", args);
}

void CastStreamingNativeHandler::StartCastRtpStream(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  CHECK_EQ(2, args.Length());
  CHECK(args[0]->IsInt32());
  CHECK(args[1]->IsObject());

  const int transport_id = args[0]->ToInt32(args.GetIsolate())->Value();
  CastRtpStream* transport = GetRtpStreamOrThrow(transport_id);
  if (!transport)
    return;

  scoped_ptr<V8ValueConverter> converter(V8ValueConverter::create());
  scoped_ptr<base::Value> params_value(
      converter->FromV8Value(args[1], context()->v8_context()));
  if (!params_value) {
    args.GetIsolate()->ThrowException(v8::Exception::TypeError(
        v8::String::NewFromUtf8(args.GetIsolate(), kUnableToConvertParams)));
    return;
  }
  scoped_ptr<RtpParams> params = RtpParams::FromValue(*params_value);
  if (!params) {
    args.GetIsolate()->ThrowException(v8::Exception::TypeError(
        v8::String::NewFromUtf8(args.GetIsolate(), kInvalidRtpParams)));
    return;
  }

  CastRtpParams cast_params;
  v8::Isolate* isolate = context()->v8_context()->GetIsolate();
  if (!ToCastRtpParamsOrThrow(isolate, *params, &cast_params))
    return;

  base::Closure start_callback =
      base::Bind(&CastStreamingNativeHandler::CallStartCallback,
                 weak_factory_.GetWeakPtr(),
                 transport_id);
  base::Closure stop_callback =
      base::Bind(&CastStreamingNativeHandler::CallStopCallback,
                 weak_factory_.GetWeakPtr(),
                 transport_id);
  CastRtpStream::ErrorCallback error_callback =
      base::Bind(&CastStreamingNativeHandler::CallErrorCallback,
                 weak_factory_.GetWeakPtr(),
                 transport_id);
  transport->Start(cast_params, start_callback, stop_callback, error_callback);
}

void PageCaptureCustomBindings::SendResponseAck(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  CHECK(args.Length() == 1);
  CHECK(args[0]->IsInt32());

  content::RenderFrame* render_frame = context()->GetRenderFrame();
  if (render_frame) {
    render_frame->Send(new ExtensionHostMsg_ResponseAck(
        render_frame->GetRoutingID(), args[0]->Int32Value()));
  }
}

PageCaptureCustomBindings::PageCaptureCustomBindings(ScriptContext* context)
: ObjectBackedNativeHandler(context) {
  RouteFunction("CreateBlob",
      base::Bind(&PageCaptureCustomBindings::CreateBlob,
                 base::Unretained(this)));
  RouteFunction("SendResponseAck",
      base::Bind(&PageCaptureCustomBindings::SendResponseAck,
                 base::Unretained(this)));
}

void CastStreamingNativeHandler::CallStopCallback(int stream_id) const {
  v8::Isolate* isolate = context()->isolate();
  v8::HandleScope handle_scope(isolate);
  v8::Context::Scope context_scope(context()->v8_context());
  v8::Local<v8::Array> event_args = v8::Array::New(isolate, 1);
  event_args->Set(0, v8::Integer::New(isolate, stream_id));
  context()->DispatchEvent("cast.streaming.rtpStream.onStopped", event_args);
}

void CastStreamingNativeHandler::SetDestinationCastUdpTransport(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  CHECK_EQ(2, args.Length());
  CHECK(args[0]->IsInt32());
  CHECK(args[1]->IsObject());

  const int transport_id = args[0]->ToInt32(args.GetIsolate())->Value();
  CastUdpTransport* transport = GetUdpTransportOrThrow(transport_id);
  if (!transport)
    return;

  net::IPEndPoint dest;
  if (!IPEndPointFromArg(args.GetIsolate(),
                         args[1],
                         &dest)) {
    return;
  }
  transport->SetDestination(
      dest,
      base::Bind(&CastStreamingNativeHandler::CallErrorCallback,
                 weak_factory_.GetWeakPtr(),
                 transport_id));
}

static gfx::Rect ComputeLocalNodeBounds(TreeCache* cache, ui::AXNode* node) {
  gfx::Rect bounds = node->data().location;
  if (bounds.width() > 0 && bounds.height() > 0)
    return bounds;

  for (size_t i = 0; i < node->children().size(); i++) {
    ui::AXNode* child = node->children()[i];
    gfx::Rect child_bounds = ComputeLocalNodeBounds(cache, child);

    if (child_bounds.width() == 0 || child_bounds.height() == 0)
      continue;

    if (bounds.width() == 0 || bounds.height() == 0) {
      bounds = child_bounds;
      continue;
    }

    bounds.Union(child_bounds);
  }

  return bounds;
}

void CastStreamingNativeHandler::CallStartCallback(int stream_id) const {
  v8::Isolate* isolate = context()->isolate();
  v8::HandleScope handle_scope(isolate);
  v8::Context::Scope context_scope(context()->v8_context());
  v8::Local<v8::Array> event_args = v8::Array::New(isolate, 1);
  event_args->Set(0, v8::Integer::New(isolate, stream_id));
  context()->DispatchEvent("cast.streaming.rtpStream.onStarted", event_args);
}

void AutomationInternalCustomBindings::RemoveTreeChangeObserver(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  if (args.Length() != 1 || !args[0]->IsNumber()) {
    ThrowInvalidArgumentsException(this);
    return;
  }

  int observer_id = args[0]->Int32Value();

  for (auto iter = tree_change_observers_.begin();
       iter != tree_change_observers_.end(); ++iter) {
    if (iter->id == observer_id) {
      tree_change_observers_.erase(iter);
      break;
    }
  }

  UpdateOverallTreeChangeObserverFilter();
}

v8::Local<v8::Value> CreateV8String(v8::Isolate* isolate, const char* str) {
  return v8::String::NewFromUtf8(isolate, str, v8::String::kNormalString,
                                 strlen(str));
}

  void Run(const v8::FunctionCallbackInfo<v8::Value>& args) {
    v8::Isolate* isolate = automation_bindings_->GetIsolate();
    if (args.Length() < 4 || !args[0]->IsNumber() || !args[1]->IsNumber() ||
        !args[2]->IsNumber() || !args[3]->IsNumber()) {
      ThrowInvalidArgumentsException(automation_bindings_);
    }

    int tree_id = args[0]->Int32Value();
    int node_id = args[1]->Int32Value();
    int start = args[2]->Int32Value();
    int end = args[3]->Int32Value();

    TreeCache* cache = automation_bindings_->GetTreeCacheFromTreeID(tree_id);
    if (!cache)
      return;

    ui::AXNode* node = cache->tree.GetFromId(node_id);
    if (!node)
      return;

    function_(isolate, args.GetReturnValue(), cache, node, start, end);
  }

ui::AXNode* AutomationInternalCustomBindings::GetParent(
    ui::AXNode* node,
    TreeCache** in_out_cache) {
  if (node->parent())
    return node->parent();

  int parent_tree_id = (*in_out_cache)->tree.data().parent_tree_id;
  if (parent_tree_id < 0)
    return nullptr;

  TreeCache* parent_cache = GetTreeCacheFromTreeID(parent_tree_id);
  if (!parent_cache)
    return nullptr;

  if (parent_cache->parent_node_id_from_parent_tree > 0) {
    ui::AXNode* parent = parent_cache->tree.GetFromId(
        parent_cache->parent_node_id_from_parent_tree);
    if (parent) {
      int parent_child_tree_id =
          parent->data().GetIntAttribute(ui::AX_ATTR_CHILD_TREE_ID);
      if (parent_child_tree_id == (*in_out_cache)->tree_id) {
        *in_out_cache = parent_cache;
        return parent;
      }
    }
  }

  ui::AXNode* parent = FindNodeWithChildTreeId(parent_cache->tree.root(),
                                               (*in_out_cache)->tree_id);
  if (parent) {
    (*in_out_cache)->parent_node_id_from_parent_tree = parent->id();
    *in_out_cache = parent_cache;
    return parent;
  }

  return nullptr;
}

void AutomationInternalCustomBindings::OnNodeDataWillChange(
    ui::AXTree* tree,
    const ui::AXNodeData& old_node_data,
    const ui::AXNodeData& new_node_data) {
  if (old_node_data.GetStringAttribute(ui::AX_ATTR_NAME) !=
      new_node_data.GetStringAttribute(ui::AX_ATTR_NAME))
    text_changed_node_ids_.push_back(new_node_data.id);
}

void CastStreamingNativeHandler::AddTracksToMediaStream(
    const std::string& url,
    const media::AudioParameters& params,
    scoped_refptr<media::AudioCapturerSource> audio,
    scoped_ptr<media::VideoCapturerSource> video) {
  blink::WebMediaStream web_stream =
      blink::WebMediaStreamRegistry::lookupMediaStreamDescriptor(GURL(url));
  if (web_stream.isNull()) {
    LOG(DFATAL) << "Stream not found.";
    return;
  }
  if (!content::AddAudioTrackToMediaStream(
          audio, params.sample_rate(), params.channel_layout(),
          params.frames_per_buffer(), true,  // is_remote
          true,                              // is_readonly
          &web_stream)) {
    LOG(ERROR) << "Failed to add Cast audio track to media stream.";
  }
  if (!content::AddVideoTrackToMediaStream(std::move(video), true,  // is_remote
                                           true,  // is_readonly
                                           &web_stream)) {
    LOG(ERROR) << "Failed to add Cast video track to media stream.";
  }
}

void AutomationInternalCustomBindings::OnNodeWillBeDeleted(ui::AXTree* tree,
                                                           ui::AXNode* node) {
  SendTreeChangeEvent(
      api::automation::TREE_CHANGE_TYPE_NODEREMOVED,
      tree, node);
  deleted_node_ids_.push_back(node->id());
}

void AutomationInternalCustomBindings::Invalidate() {
  ObjectBackedNativeHandler::Invalidate();

  if (message_filter_)
    message_filter_->Detach();

  for (auto iter : tree_id_to_tree_cache_map_) {
    TreeCache* cache = iter.second;
    cache->tree.SetDelegate(nullptr);
    delete cache;
  }
  tree_id_to_tree_cache_map_.clear();
}

NotificationsNativeHandler::NotificationsNativeHandler(ScriptContext* context)
: ObjectBackedNativeHandler(context) {
RouteFunction(
      "GetNotificationImageSizes",
base::Bind(&NotificationsNativeHandler::GetNotificationImageSizes,
base::Unretained(this)));
}

bool HexDecode(const std::string& input, std::string* output) {
  std::vector<uint8_t> bytes;
  if (!base::HexStringToBytes(input, &bytes))
    return false;
  output->assign(reinterpret_cast<const char*>(&bytes[0]), bytes.size());
  return true;
}

void AutomationInternalCustomBindings::SendNodesRemovedEvent(
    ui::AXTree* tree,
    const std::vector<int>& ids) {
  auto iter = axtree_to_tree_cache_map_.find(tree);
  if (iter == axtree_to_tree_cache_map_.end())
    return;

  int tree_id = iter->second->tree_id;

  v8::Isolate* isolate = GetIsolate();
  v8::HandleScope handle_scope(isolate);
  v8::Context::Scope context_scope(context()->v8_context());
  v8::Local<v8::Array> args(v8::Array::New(GetIsolate(), 2U));
  args->Set(0U, v8::Integer::New(GetIsolate(), tree_id));
  v8::Local<v8::Array> nodes(v8::Array::New(GetIsolate(), ids.size()));
  args->Set(1U, nodes);
  for (size_t i = 0; i < ids.size(); ++i)
    nodes->Set(i, v8::Integer::New(GetIsolate(), ids[i]));
  context()->DispatchEvent("automationInternal.onNodesRemoved", args);
}

void ThrowInvalidArgumentsException(
    AutomationInternalCustomBindings* automation_bindings) {
  v8::Isolate* isolate = automation_bindings->GetIsolate();
  automation_bindings->GetIsolate()->ThrowException(
      v8::String::NewFromUtf8(
          isolate,
          "Invalid arguments to AutomationInternalCustomBindings function",
          v8::NewStringType::kNormal)
          .ToLocalChecked());

  LOG(FATAL) << "Invalid arguments to AutomationInternalCustomBindings function"
             << automation_bindings->context()->GetStackTraceAsString();
}

void AutomationInternalCustomBindings::UpdateOverallTreeChangeObserverFilter() {
  tree_change_observer_overall_filter_ =
      api::automation::TREE_CHANGE_OBSERVER_FILTER_NOTREECHANGES;
  for (const auto& observer : tree_change_observers_) {
    tree_change_observer_overall_filter_ =
        std::max(observer.filter, tree_change_observer_overall_filter_);
  }
}

void ToCastCodecSpecificParams(const CodecSpecificParams& ext_params,
                               CastCodecSpecificParams* cast_params) {
  cast_params->key = ext_params.key;
  cast_params->value = ext_params.value;
}

v8::Local<v8::Value> CreateV8String(v8::Isolate* isolate,
                                    const std::string& str) {
  return v8::String::NewFromUtf8(isolate, str.c_str(),
                                 v8::String::kNormalString, str.length());
}
