void MessageLoop::RunTask(PendingTask* pending_task) {
  DCHECK(nestable_tasks_allowed_);
current_pending_task_ = pending_task;

#if defined(OS_WIN)
DecrementHighResTaskCountIfNeeded(*pending_task);
#endif

// Execute the task and assume the worst: It is probably not reentrant.
nestable_tasks_allowed_ = false;

TRACE_TASK_EXECUTION("MessageLoop::RunTask", *pending_task);

for (auto& observer : task_observers_)
observer.WillProcessTask(*pending_task);
task_annotator_.RunTask("MessageLoop::PostTask", pending_task);
for (auto& observer : task_observers_)
observer.DidProcessTask(*pending_task);

nestable_tasks_allowed_ = true;

current_pending_task_ = nullptr;
}

bool MessageLoop::IsIdleForTesting() {
  return incoming_task_queue_->IsIdleForTesting();
}

  RunLoopTestEnvironment(RunLoopTestType type) {
    switch (type) {
      case RunLoopTestType::kRealEnvironment:
        task_environment_ = base::MakeUnique<test::ScopedTaskEnvironment>();
        break;
      case RunLoopTestType::kTestDelegate:
        test_delegate_ = base::MakeUnique<TestDelegate>();
        test_delegate_->BindToCurrentThread();
        break;
    }
  }

void MessageLoop::ReloadWorkQueue() {
  if (work_queue_.empty()) {
#if defined(OS_WIN)
    pending_high_res_tasks_ +=
        incoming_task_queue_->ReloadWorkQueue(&work_queue_);
#else
    incoming_task_queue_->ReloadWorkQueue(&work_queue_);
#endif
  }
}

bool MessageLoop::InitMessagePumpForUIFactory(MessagePumpFactory* factory) {
  if (message_pump_for_ui_factory_)
    return false;

  message_pump_for_ui_factory_ = factory;
  return true;
}

bool MessageLoop::DeferOrRunPendingTask(PendingTask pending_task) {
  if (pending_task.nestable || !run_loop_client_->IsNested()) {
    RunTask(&pending_task);
    return true;
  }

  deferred_non_nestable_work_queue_.push(std::move(pending_task));
  return false;
}

bool RunLoop::IsNestingAllowedOnCurrentThread() {
  return tls_delegate.Get().Get()->allow_nesting_;
}

void MessageLoopForUI::Attach() {
  static_cast<MessagePumpUIApplication*>(pump_.get())->Attach(this);
}

void MessageLoop::DecrementHighResTaskCountIfNeeded(
    const PendingTask& pending_task) {
  if (!pending_task.is_high_res)
    return;
  --pending_high_res_tasks_;
  DCHECK_GE(pending_high_res_tasks_, 0);
}

void MessageLoop::RemoveTaskObserver(TaskObserver* task_observer) {
  DCHECK_EQ(this, current());
  CHECK(allow_task_observers_);
  task_observers_.RemoveObserver(task_observer);
}

bool MessageLoop::DoIdleWork() {
  if (ProcessNextDelayedNonNestableTask())
    return true;

  if (run_loop_client_->ShouldQuitWhenIdle())
    pump_->Quit();

#if defined(OS_WIN)
  bool high_res = pending_high_res_tasks_ > 0;
  if (high_res != in_high_res_mode_) {
    in_high_res_mode_ = high_res;
    Time::ActivateHighResolutionTimer(in_high_res_mode_);
  }
#endif
  return false;
}

void MessageLoopForIO::RegisterIOHandler(HANDLE file, IOHandler* handler) {
  ToPumpIO(pump_.get())->RegisterIOHandler(file, handler);
}

void RunNestedLoopTask(int* counter) {
  RunLoop nested_run_loop;

// This task should quit |nested_run_loop| but not the main RunLoop.
ThreadTaskRunnerHandle::Get()->PostTask(
FROM_HERE, BindOnce(&QuitWhenIdleTask, Unretained(&nested_run_loop),
Unretained(counter)));

ThreadTaskRunnerHandle::Get()->PostDelayedTask(
FROM_HERE, BindOnce(&ShouldNotRunTask), TimeDelta::FromDays(1));

  std::unique_ptr<MessageLoop::ScopedNestableTaskAllower> allower;
  if (MessageLoop::current()) {
    // Need to allow nestable tasks in MessageLoop driven environments.
    // TODO(gab): Move nestable task allowance concept to RunLoop.
    allower = base::MakeUnique<MessageLoop::ScopedNestableTaskAllower>(
        MessageLoop::current());
  }
nested_run_loop.Run();

++(*counter);
}

void MessageLoop::Run() {
  DCHECK_EQ(this, current());
  pump_->Run(this);
}

  RunLoopTest() : test_environment_(GetParam()) {}

RunLoop::Delegate::~Delegate() {
  DCHECK_CALLED_ON_VALID_THREAD(bound_thread_checker_);
  if (bound_)
    tls_delegate.Get().Set(nullptr);
}

MessageLoop::MessageLoop(std::unique_ptr<MessagePump> pump)
    : MessageLoop(TYPE_CUSTOM, BindOnce(&ReturnPump, Passed(&pump))) {
  BindToCurrentThread();
}

void RunLoop::DisallowNestingOnCurrentThread() {
  tls_delegate.Get().Get()->allow_nesting_ = false;
}

void MessageLoop::Quit() {
  DCHECK_EQ(this, current());
   pump_->Quit();
 }

void RunLoop::QuitCurrentWhenIdleDeprecated() {
  DCHECK(IsRunningOnCurrentThread());
  tls_delegate.Get().Get()->active_run_loops_.top()->QuitWhenIdle();
}

bool MessageLoop::IsType(Type type) const {
  return type_ == type;
}

bool MessageLoop::ProcessNextDelayedNonNestableTask() {
  if (run_loop_client_->IsNested())
    return false;

  while (!deferred_non_nestable_work_queue_.empty()) {
    PendingTask pending_task =
        std::move(deferred_non_nestable_work_queue_.front());
    deferred_non_nestable_work_queue_.pop();

    if (!pending_task.task.IsCancelled()) {
      RunTask(&pending_task);
      return true;
    }

#if defined(OS_WIN)
    DecrementHighResTaskCountIfNeeded(pending_task);
#endif
  }

  return false;
 }

bool MessageLoopForIO::RegisterJobObject(HANDLE job, IOHandler* handler) {
  return ToPumpIO(pump_.get())->RegisterJobObject(job, handler);
}

void RunLoop::RunUntilIdle() {
  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);

  quit_when_idle_received_ = true;
  Run();
}

void RunLoop::RemoveNestingObserverOnCurrentThread(NestingObserver* observer) {
  Delegate* delegate = tls_delegate.Get().Get();
  DCHECK(delegate);
  CHECK(delegate->allow_nesting_);
  delegate->nesting_observers_.RemoveObserver(observer);
}

bool MessageLoop::NestableTasksAllowed() const {
  return nestable_tasks_allowed_;
}

RunLoop::Delegate::Client* RunLoop::RegisterDelegateForCurrentThread(
    Delegate* delegate) {
  DCHECK(!delegate->bound_);
  DCHECK_CALLED_ON_VALID_THREAD(delegate->bound_thread_checker_);

  DCHECK(!tls_delegate.Get().Get());
  tls_delegate.Get().Set(delegate);
  delegate->bound_ = true;

   return &delegate->client_interface_;
 }

  bool ProcessTask() {
    OnceClosure task;
    {
      AutoLock auto_lock(tasks_lock_);
      if (pending_tasks_.empty())
        return false;
      task = std::move(pending_tasks_.front());
      pending_tasks_.pop();
    }
    std::move(task).Run();
    return true;
  }

bool MessageLoop::DeletePendingTasks() {
  bool did_work = !work_queue_.empty();
  while (!work_queue_.empty()) {
    PendingTask pending_task = std::move(work_queue_.front());
    work_queue_.pop();
    if (!pending_task.delayed_run_time.is_null()) {
      AddToDelayedWorkQueue(std::move(pending_task));
    }
  }
  did_work |= !deferred_non_nestable_work_queue_.empty();
  while (!deferred_non_nestable_work_queue_.empty()) {
    deferred_non_nestable_work_queue_.pop();
  }
  did_work |= !delayed_work_queue_.empty();

  while (!delayed_work_queue_.empty()) {
    delayed_work_queue_.pop();
  }
  return did_work;
}

RunLoop::Delegate::Delegate() {
  DETACH_FROM_THREAD(bound_thread_checker_);
}

void ShouldNotRunTask() {
  ADD_FAILURE() << "Ran a task that shouldn't run.";
 }

void MessageLoop::AddTaskObserver(TaskObserver* task_observer) {
  DCHECK_EQ(this, current());
  CHECK(allow_task_observers_);
  task_observers_.AddObserver(task_observer);
}

void MessageLoopForUI::Abort() {
  static_cast<MessagePumpForUI*>(pump_.get())->Abort();
}

bool MessageLoop::HasHighResolutionTasks() {
  return incoming_task_queue_->HasHighResolutionTasks();
}

RunLoop::RunLoop()
     : delegate_(tls_delegate.Get().Get()),
       origin_task_runner_(ThreadTaskRunnerHandle::Get()),
       weak_factory_(this) {
   DCHECK(delegate_) << "A RunLoop::Delegate must be bound to this thread prior "
                        "to using RunLoop.";
   DCHECK(origin_task_runner_);
 }

base::Closure RunLoop::QuitWhenIdleClosure() {

  return base::Bind(
      &ProxyToTaskRunner, origin_task_runner_,
      base::Bind(&RunLoop::QuitWhenIdle, weak_factory_.GetWeakPtr()));
}

std::unique_ptr<MessagePump> ReturnPump(std::unique_ptr<MessagePump> pump) {
  return pump;
}

MessageLoop::TaskObserver::~TaskObserver() {
}

void MessageLoop::AddToDelayedWorkQueue(PendingTask pending_task) {
  delayed_work_queue_.push(std::move(pending_task));
}

MessageLoop* MessageLoop::current() {
  return GetTLSMessageLoop()->Get();
}

MessageLoop::TaskObserver::TaskObserver() {
}

void MessageLoopForUI::StartForTesting(
    base::android::JavaMessageHandlerFactory* factory,
    WaitableEvent* test_done_event) {
  static_cast<MessagePumpForUI*>(pump_.get())
      ->StartForUnitTest(this, factory, test_done_event);
}

std::unique_ptr<MessageLoop> MessageLoop::CreateUnbound(
    Type type,
    MessagePumpFactoryCallback pump_factory) {
  return WrapUnique(new MessageLoop(type, std::move(pump_factory)));
}

bool RunLoop::IsNestedOnCurrentThread() {
  Delegate* delegate = tls_delegate.Get().Get();
  return delegate && delegate->active_run_loops_.size() > 1;
}

void MessageLoop::ClearTaskRunnerForTesting() {
  DCHECK_EQ(this, current());
  DCHECK(!unbound_task_runner_);
  task_runner_ = nullptr;
  thread_task_runner_handle_.reset();
}

bool RunLoop::Delegate::Client::ShouldQuitWhenIdle() const {
  DCHECK_CALLED_ON_VALID_THREAD(outer_->bound_thread_checker_);
  DCHECK(outer_->bound_);
  return outer_->active_run_loops_.top()->quit_when_idle_received_;
}

bool MessageLoopForIO::WatchFileDescriptor(int fd,
                                           bool persistent,
                                           Mode mode,
                                           FileDescriptorWatcher* controller,
                                           Watcher* delegate) {
  return ToPumpIO(pump_.get())->WatchFileDescriptor(
      fd,
      persistent,
      mode,
      controller,
      delegate);
}

void MessageLoop::AddDestructionObserver(
    DestructionObserver* destruction_observer) {
  DCHECK_EQ(this, current());
  destruction_observers_.AddObserver(destruction_observer);
}

MessageLoop::~MessageLoop() {
  DCHECK((pump_ && current() == this) || (!pump_ && current() != this));

#if !defined(OS_IOS)
  DCHECK((!pump_ && current() != this) || !RunLoop::IsRunningOnCurrentThread());
#endif

#if defined(OS_WIN)
  if (in_high_res_mode_)
    Time::ActivateHighResolutionTimer(false);
#endif
  bool did_work;
  for (int i = 0; i < 100; ++i) {
    DeletePendingTasks();
    ReloadWorkQueue();
    did_work = DeletePendingTasks();
    if (!did_work)
      break;
  }
  DCHECK(!did_work);

  for (auto& observer : destruction_observers_)
    observer.WillDestroyCurrentMessageLoop();

  thread_task_runner_handle_.reset();

  incoming_task_queue_->WillDestroyCurrentMessageLoop();
  incoming_task_queue_ = NULL;
  unbound_task_runner_ = NULL;
  task_runner_ = NULL;

  if (current() == this)
    GetTLSMessageLoop()->Set(nullptr);
}

bool RunLoop::Delegate::Client::IsNested() const {
  DCHECK_CALLED_ON_VALID_THREAD(outer_->bound_thread_checker_);
  DCHECK(outer_->bound_);
   return outer_->active_run_loops_.size() > 1;
 }

MessageLoop::MessageLoop(Type type)
    : MessageLoop(type, MessagePumpFactoryCallback()) {
  BindToCurrentThread();
}

std::string MessageLoop::GetThreadName() const {
  DCHECK_NE(kInvalidThreadId, thread_id_)
      << "GetThreadName() must only be called after BindToCurrentThread()'s "
      << "side-effects have been synchronized with this thread.";
  return ThreadIdNameManager::GetInstance()->GetName(thread_id_);
}

void MessageLoopForUI::Start() {
  static_cast<MessagePumpForUI*>(pump_.get())->Start(this);
}

void RunLoop::AfterRun() {
  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);

  running_ = false;

  auto& active_run_loops_ = delegate_->active_run_loops_;
  DCHECK_EQ(active_run_loops_.top(), this);
  active_run_loops_.pop();

  RunLoop* previous_run_loop =
      active_run_loops_.empty() ? nullptr : active_run_loops_.top();

  if (previous_run_loop && previous_run_loop->quit_called_)
    delegate_->Quit();
}

void MessageLoop::BindToCurrentThread() {
  DCHECK(!pump_);
  if (!pump_factory_.is_null())
    pump_ = std::move(pump_factory_).Run();
  else
    pump_ = CreateMessagePumpForType(type_);

  DCHECK(!current()) << "should only have one message loop per thread";
  GetTLSMessageLoop()->Set(this);

  incoming_task_queue_->StartScheduling();
  unbound_task_runner_->BindToCurrentThread();
  unbound_task_runner_ = nullptr;
  SetThreadTaskRunnerHandle();
  thread_id_ = PlatformThread::CurrentId();

  scoped_set_sequence_local_storage_map_for_current_thread_ =
      MakeUnique<internal::ScopedSetSequenceLocalStorageMapForCurrentThread>(
          &sequence_local_storage_map_);

  run_loop_client_ = RunLoop::RegisterDelegateForCurrentThread(this);
}

void RunLoop::AddNestingObserverOnCurrentThread(NestingObserver* observer) {
  Delegate* delegate = tls_delegate.Get().Get();
  DCHECK(delegate);
  CHECK(delegate->allow_nesting_);
  delegate->nesting_observers_.AddObserver(observer);
}

std::unique_ptr<MessagePump> MessageLoop::CreateMessagePumpForType(Type type) {
#if defined(USE_GLIB) && !defined(OS_NACL)
  typedef MessagePumpGlib MessagePumpForUI;
#elif (defined(OS_LINUX) && !defined(OS_NACL)) || defined(OS_BSD)
  typedef MessagePumpLibevent MessagePumpForUI;
#elif defined(OS_FUCHSIA)
  typedef MessagePumpFuchsia MessagePumpForUI;
#endif

#if defined(OS_IOS) || defined(OS_MACOSX)
#define MESSAGE_PUMP_UI std::unique_ptr<MessagePump>(MessagePumpMac::Create())
#elif defined(OS_NACL) || defined(OS_AIX)
#define MESSAGE_PUMP_UI std::unique_ptr<MessagePump>()
#else
#define MESSAGE_PUMP_UI std::unique_ptr<MessagePump>(new MessagePumpForUI())
#endif

#if defined(OS_MACOSX)
#define MESSAGE_PUMP_DEFAULT \
  std::unique_ptr<MessagePump>(new MessagePumpCFRunLoop())
#else
#define MESSAGE_PUMP_DEFAULT \
  std::unique_ptr<MessagePump>(new MessagePumpDefault())
#endif

  if (type == MessageLoop::TYPE_UI) {
    if (message_pump_for_ui_factory_)
      return message_pump_for_ui_factory_();
    return MESSAGE_PUMP_UI;
  }
  if (type == MessageLoop::TYPE_IO)
    return std::unique_ptr<MessagePump>(new MessagePumpForIO());

#if defined(OS_ANDROID)
  if (type == MessageLoop::TYPE_JAVA)
    return std::unique_ptr<MessagePump>(new MessagePumpForUI());
#endif

  DCHECK_EQ(MessageLoop::TYPE_DEFAULT, type);
  return MESSAGE_PUMP_DEFAULT;
}

void RunLoop::Run() {
  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);

  if (!BeforeRun())
    return;

  DETACH_FROM_SEQUENCE(sequence_checker_);

  tracked_objects::TaskStopwatch stopwatch;
  stopwatch.Start();
  delegate_->Run();
  stopwatch.Stop();

  DETACH_FROM_SEQUENCE(sequence_checker_);
  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);

  AfterRun();
}

bool MessageLoopForIO::WaitForIOCompletion(DWORD timeout, IOHandler* filter) {
  return ToPumpIO(pump_.get())->WaitForIOCompletion(timeout, filter);
}

void RunLoop::QuitCurrentDeprecated() {
  DCHECK(IsRunningOnCurrentThread());
  tls_delegate.Get().Get()->active_run_loops_.top()->Quit();
}

bool MessageLoop::DoWork() {
  if (!nestable_tasks_allowed_) {
// Task can't be executed right now.
return false;
}

for (;;) {
ReloadWorkQueue();
if (work_queue_.empty())
break;

// Execute oldest task.
do {
PendingTask pending_task = std::move(work_queue_.front());
work_queue_.pop();

if (pending_task.task.IsCancelled()) {
#if defined(OS_WIN)
DecrementHighResTaskCountIfNeeded(pending_task);
#endif
} else if (!pending_task.delayed_run_time.is_null()) {
int sequence_num = pending_task.sequence_num;
TimeTicks delayed_run_time = pending_task.delayed_run_time;
AddToDelayedWorkQueue(std::move(pending_task));
// If we changed the topmost task, then it is time to reschedule.
if (delayed_work_queue_.top().sequence_num == sequence_num)
pump_->ScheduleDelayedWork(delayed_run_time);
} else {
if (DeferOrRunPendingTask(std::move(pending_task)))
return true;
}
} while (!work_queue_.empty());
}

// Nothing happened.
return false;
}

bool RunLoop::BeforeRun() {
  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);

#if DCHECK_IS_ON()
  DCHECK(!run_called_);
  run_called_ = true;
#endif  // DCHECK_IS_ON()

  if (quit_called_)
    return false;

  auto& active_run_loops_ = delegate_->active_run_loops_;
  active_run_loops_.push(this);

  const bool is_nested = active_run_loops_.size() > 1;

  if (is_nested) {
     CHECK(delegate_->allow_nesting_);
     for (auto& observer : delegate_->nesting_observers_)
       observer.OnBeginNestedRunLoop();
   }
 
   running_ = true;
  return true;
}

void RunLoop::QuitWhenIdle() {

  if (!origin_task_runner_->RunsTasksInCurrentSequence()) {
    origin_task_runner_->PostTask(
        FROM_HERE, base::BindOnce(&RunLoop::QuitWhenIdle, Unretained(this)));
    return;
  }

  quit_when_idle_received_ = true;
}

void ProxyToTaskRunner(scoped_refptr<SequencedTaskRunner> task_runner,
                       OnceClosure closure) {
  if (task_runner->RunsTasksInCurrentSequence()) {
    std::move(closure).Run();
    return;
  }
  task_runner->PostTask(FROM_HERE, std::move(closure));
}

bool MessageLoopForUI::WatchFileDescriptor(
    int fd,
    bool persistent,
    MessagePumpLibevent::Mode mode,
    MessagePumpLibevent::FileDescriptorWatcher *controller,
    MessagePumpLibevent::Watcher *delegate) {
  return static_cast<MessagePumpLibevent*>(pump_.get())->WatchFileDescriptor(
      fd,
      persistent,
      mode,
      controller,
      delegate);
}
