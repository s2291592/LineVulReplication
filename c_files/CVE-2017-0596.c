OMX_ERRORTYPE SoftMPEG4Encoder::initEncoder() {
    CHECK(!mStarted);

    OMX_ERRORTYPE errType = OMX_ErrorNone;
 if (OMX_ErrorNone != (errType = initEncParams())) {
        ALOGE("Failed to initialized encoder params");
        mSignalledError = true;
        notify(OMX_EventError, OMX_ErrorUndefined, 0, 0);
 return errType;
 }

 if (!PVInitVideoEncoder(mHandle, mEncParams)) {
        ALOGE("Failed to initialize the encoder");
        mSignalledError = true;
        notify(OMX_EventError, OMX_ErrorUndefined, 0, 0);
 return OMX_ErrorUndefined;
 }

    mNumInputFrames = -1; // 1st buffer for codec specific data
    mStarted = true;

 return OMX_ErrorNone;

 }

OMX_ERRORTYPE SoftAACEncoder2::internalGetParameter(
        OMX_INDEXTYPE index, OMX_PTR params) {
 switch (index) {
 case OMX_IndexParamAudioPortFormat:
 {
            OMX_AUDIO_PARAM_PORTFORMATTYPE *formatParams =
 (OMX_AUDIO_PARAM_PORTFORMATTYPE *)params;

 if (!isValidOMXParam(formatParams)) {
 return OMX_ErrorBadParameter;
 }

 if (formatParams->nPortIndex > 1) {
 return OMX_ErrorUndefined;
 }

 if (formatParams->nIndex > 0) {
 return OMX_ErrorNoMore;
 }

            formatParams->eEncoding =
 (formatParams->nPortIndex == 0)
 ? OMX_AUDIO_CodingPCM : OMX_AUDIO_CodingAAC;

 return OMX_ErrorNone;
 }

 case OMX_IndexParamAudioAac:
 {
            OMX_AUDIO_PARAM_AACPROFILETYPE *aacParams =
 (OMX_AUDIO_PARAM_AACPROFILETYPE *)params;

 if (!isValidOMXParam(aacParams)) {
 return OMX_ErrorBadParameter;
 }

 if (aacParams->nPortIndex != 1) {
 return OMX_ErrorUndefined;
 }

            aacParams->nBitRate = mBitRate;
            aacParams->nAudioBandWidth = 0;
            aacParams->nAACtools = 0;
            aacParams->nAACERtools = 0;
            aacParams->eAACProfile = (OMX_AUDIO_AACPROFILETYPE) mAACProfile;
            aacParams->eAACStreamFormat = OMX_AUDIO_AACStreamFormatMP4FF;
            aacParams->eChannelMode = OMX_AUDIO_ChannelModeStereo;

            aacParams->nChannels = mNumChannels;
            aacParams->nSampleRate = mSampleRate;
            aacParams->nFrameLength = 0;

 switch (mSBRMode) {
 case 1: // sbr on
 switch (mSBRRatio) {
 case 0:
                    aacParams->nAACtools |= OMX_AUDIO_AACToolAndroidSSBR;
                    aacParams->nAACtools |= OMX_AUDIO_AACToolAndroidDSBR;
 break;
 case 1:
                    aacParams->nAACtools |= OMX_AUDIO_AACToolAndroidSSBR;
                    aacParams->nAACtools &= ~OMX_AUDIO_AACToolAndroidDSBR;
 break;
 case 2:
                    aacParams->nAACtools &= ~OMX_AUDIO_AACToolAndroidSSBR;
                    aacParams->nAACtools |= OMX_AUDIO_AACToolAndroidDSBR;
 break;
 default:
                    ALOGE("invalid SBR ratio %d", mSBRRatio);
                    TRESPASS();
 }
 break;
 case 0: // sbr off
 case -1: // sbr undefined
                aacParams->nAACtools &= ~OMX_AUDIO_AACToolAndroidSSBR;
                aacParams->nAACtools &= ~OMX_AUDIO_AACToolAndroidDSBR;
 break;
 default:
                ALOGE("invalid SBR mode %d", mSBRMode);
                TRESPASS();
 }



 return OMX_ErrorNone;
 }

 case OMX_IndexParamAudioPcm:
 {
            OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =
 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;

 if (!isValidOMXParam(pcmParams)) {
 return OMX_ErrorBadParameter;
 }

 if (pcmParams->nPortIndex != 0) {
 return OMX_ErrorUndefined;
 }

            pcmParams->eNumData = OMX_NumericalDataSigned;
            pcmParams->eEndian = OMX_EndianBig;
            pcmParams->bInterleaved = OMX_TRUE;
            pcmParams->nBitPerSample = 16;
            pcmParams->ePCMMode = OMX_AUDIO_PCMModeLinear;
            pcmParams->eChannelMapping[0] = OMX_AUDIO_ChannelLF;
            pcmParams->eChannelMapping[1] = OMX_AUDIO_ChannelRF;

            pcmParams->nChannels = mNumChannels;
            pcmParams->nSamplingRate = mSampleRate;

 return OMX_ErrorNone;
 }

 default:
 return SimpleSoftOMXComponent::internalGetParameter(index, params);
 }
}

OMX_ERRORTYPE SoftVPXEncoder::internalSetPortParams(
 const OMX_PARAM_PORTDEFINITIONTYPE* port) {
 if (port->nPortIndex == kInputPortIndex) {
        mWidth = port->format.video.nFrameWidth;
        mHeight = port->format.video.nFrameHeight;

        mFramerate = port->format.video.xFramerate;

 if (port->format.video.eColorFormat == OMX_COLOR_FormatYUV420Planar ||
            port->format.video.eColorFormat == OMX_COLOR_FormatYUV420SemiPlanar ||
            port->format.video.eColorFormat == OMX_COLOR_FormatAndroidOpaque) {
            mColorFormat = port->format.video.eColorFormat;
 } else {
 return OMX_ErrorUnsupportedSetting;
 }

        OMX_PARAM_PORTDEFINITIONTYPE *def = &editPortInfo(kInputPortIndex)->mDef;
        def->format.video.nFrameWidth = mWidth;
        def->format.video.nFrameHeight = mHeight;
        def->format.video.xFramerate = mFramerate;
        def->format.video.eColorFormat = mColorFormat;
        def = &editPortInfo(kOutputPortIndex)->mDef;
        def->format.video.nFrameWidth = mWidth;
        def->format.video.nFrameHeight = mHeight;

 return OMX_ErrorNone;
 } else if (port->nPortIndex == kOutputPortIndex) {
        mBitrate = port->format.video.nBitrate;
        mWidth = port->format.video.nFrameWidth;
        mHeight = port->format.video.nFrameHeight;

        OMX_PARAM_PORTDEFINITIONTYPE *def = &editPortInfo(kOutputPortIndex)->mDef;
        def->format.video.nFrameWidth = mWidth;
        def->format.video.nFrameHeight = mHeight;
        def->format.video.nBitrate = mBitrate;
 return OMX_ErrorNone;
 } else {
 return OMX_ErrorBadPortIndex;
 }
}

status_t SoftAACEncoder2::setAudioParams() {

    ALOGV("setAudioParams: %u Hz, %u channels, %u bps, %i sbr mode, %i sbr ratio",
         mSampleRate, mNumChannels, mBitRate, mSBRMode, mSBRRatio);

 if (AACENC_OK != aacEncoder_SetParam(mAACEncoder, AACENC_AOT,
            getAOTFromProfile(mAACProfile))) {
        ALOGE("Failed to set AAC encoder parameters");
 return UNKNOWN_ERROR;
 }

 if (AACENC_OK != aacEncoder_SetParam(mAACEncoder, AACENC_SAMPLERATE, mSampleRate)) {
        ALOGE("Failed to set AAC encoder parameters");
 return UNKNOWN_ERROR;
 }
 if (AACENC_OK != aacEncoder_SetParam(mAACEncoder, AACENC_BITRATE, mBitRate)) {
        ALOGE("Failed to set AAC encoder parameters");
 return UNKNOWN_ERROR;
 }
 if (AACENC_OK != aacEncoder_SetParam(mAACEncoder, AACENC_CHANNELMODE,
            getChannelMode(mNumChannels))) {
        ALOGE("Failed to set AAC encoder parameters");
 return UNKNOWN_ERROR;
 }
 if (AACENC_OK != aacEncoder_SetParam(mAACEncoder, AACENC_TRANSMUX, TT_MP4_RAW)) {
        ALOGE("Failed to set AAC encoder parameters");
 return UNKNOWN_ERROR;
 }

 if (mSBRMode != -1 && mAACProfile == OMX_AUDIO_AACObjectELD) {
 if (AACENC_OK != aacEncoder_SetParam(mAACEncoder, AACENC_SBR_MODE, mSBRMode)) {
            ALOGE("Failed to set AAC encoder parameters");
 return UNKNOWN_ERROR;
 }
 }

 /* SBR ratio parameter configurations:
       0: Default configuration wherein SBR ratio is configured depending on audio object type by
          the FDK.
       1: Downsampled SBR (default for ELD)
       2: Dualrate SBR (default for HE-AAC)
     */
 if (AACENC_OK != aacEncoder_SetParam(mAACEncoder, AACENC_SBR_RATIO, mSBRRatio)) {
        ALOGE("Failed to set AAC encoder parameters");
 return UNKNOWN_ERROR;
 }

 return OK;
}

 android::SoftOMXComponent *createSoftOMXComponent(
 const char *name, const OMX_CALLBACKTYPE *callbacks,
        OMX_PTR appData, OMX_COMPONENTTYPE **component) {
 return new android::SoftMPEG4Encoder(name, callbacks, appData, component);
}

OMX_ERRORTYPE SoftVPXEncoder::setConfig(
        OMX_INDEXTYPE index, const OMX_PTR _params) {
 switch (index) {
 case OMX_IndexConfigVideoIntraVOPRefresh:
 {
            OMX_CONFIG_INTRAREFRESHVOPTYPE *params =
 (OMX_CONFIG_INTRAREFRESHVOPTYPE *)_params;

 if (!isValidOMXParam(params)) {
 return OMX_ErrorBadParameter;
 }

 if (params->nPortIndex != kOutputPortIndex) {
 return OMX_ErrorBadPortIndex;
 }

            mKeyFrameRequested = params->IntraRefreshVOP;
 return OMX_ErrorNone;
 }

 case OMX_IndexConfigVideoBitrate:
 {
            OMX_VIDEO_CONFIG_BITRATETYPE *params =
 (OMX_VIDEO_CONFIG_BITRATETYPE *)_params;

 if (!isValidOMXParam(params)) {
 return OMX_ErrorBadParameter;
 }

 if (params->nPortIndex != kOutputPortIndex) {
 return OMX_ErrorBadPortIndex;
 }

 if (mBitrate != params->nEncodeBitrate) {
                mBitrate = params->nEncodeBitrate;
                mBitrateUpdated = true;
 }
 return OMX_ErrorNone;
 }

 default:
 return SimpleSoftOMXComponent::setConfig(index, _params);
 }
}

void SoftVPXEncoder::onQueueFilled(OMX_U32 portIndex) {
// Initialize encoder if not already
if (mCodecContext == NULL) {
if (OK != initEncoder()) {
ALOGE("Failed to initialize encoder");
notify(OMX_EventError,
OMX_ErrorUndefined,
0, // Extra notification data
NULL); // Notification data pointer
return;
}
}

vpx_codec_err_t codec_return;
List<BufferInfo *> &inputBufferInfoQueue = getPortQueue(kInputPortIndex);
List<BufferInfo *> &outputBufferInfoQueue = getPortQueue(kOutputPortIndex);

while (!inputBufferInfoQueue.empty() && !outputBufferInfoQueue.empty()) {
BufferInfo *inputBufferInfo = *inputBufferInfoQueue.begin();
OMX_BUFFERHEADERTYPE *inputBufferHeader = inputBufferInfo->mHeader;

BufferInfo *outputBufferInfo = *outputBufferInfoQueue.begin();
OMX_BUFFERHEADERTYPE *outputBufferHeader = outputBufferInfo->mHeader;

if (inputBufferHeader->nFlags & OMX_BUFFERFLAG_EOS) {
inputBufferInfoQueue.erase(inputBufferInfoQueue.begin());
inputBufferInfo->mOwnedByUs = false;
notifyEmptyBufferDone(inputBufferHeader);

outputBufferHeader->nFilledLen = 0;
outputBufferHeader->nFlags = OMX_BUFFERFLAG_EOS;

outputBufferInfoQueue.erase(outputBufferInfoQueue.begin());
outputBufferInfo->mOwnedByUs = false;
notifyFillBufferDone(outputBufferHeader);
return;
}

const uint8_t *source =
inputBufferHeader->pBuffer + inputBufferHeader->nOffset;

size_t frameSize = mWidth * mHeight * 3 / 2;
if (mInputDataIsMeta) {
source = extractGraphicBuffer(
mConversionBuffer, frameSize,
source, inputBufferHeader->nFilledLen,
mWidth, mHeight);
if (source == NULL) {
ALOGE("Unable to extract gralloc buffer in metadata mode");
notify(OMX_EventError, OMX_ErrorUndefined, 0, 0);
return;
}
} else {
if (inputBufferHeader->nFilledLen < frameSize) {
android_errorWriteLog(0x534e4554, "27569635");
notify(OMX_EventError, OMX_ErrorUndefined, 0, 0);
return;
} else if (inputBufferHeader->nFilledLen > frameSize) {
ALOGW("Input buffer contains too many pixels");
}

if (mColorFormat == OMX_COLOR_FormatYUV420SemiPlanar) {
ConvertYUV420SemiPlanarToYUV420Planar(
source, mConversionBuffer, mWidth, mHeight);

source = mConversionBuffer;
}
}
vpx_image_t raw_frame;
vpx_img_wrap(&raw_frame, VPX_IMG_FMT_I420, mWidth, mHeight,
kInputBufferAlignment, (uint8_t *)source);

vpx_enc_frame_flags_t flags = 0;
if (mTemporalPatternLength > 0) {
flags = getEncodeFlags();
}
if (mKeyFrameRequested) {
flags |= VPX_EFLAG_FORCE_KF;
mKeyFrameRequested = false;
}

if (mBitrateUpdated) {
mCodecConfiguration->rc_target_bitrate = mBitrate/1000;
vpx_codec_err_t res = vpx_codec_enc_config_set(mCodecContext,
mCodecConfiguration);
if (res != VPX_CODEC_OK) {
ALOGE("vp8 encoder failed to update bitrate: %s",
vpx_codec_err_to_string(res));
notify(OMX_EventError,
OMX_ErrorUndefined,
0, // Extra notification data
NULL); // Notification data pointer
}
mBitrateUpdated = false;
}

uint32_t frameDuration;

if (inputBufferHeader->nTimeStamp > mLastTimestamp) {
frameDuration = (uint32_t)(inputBufferHeader->nTimeStamp - mLastTimestamp);
} else {
            frameDuration = (uint32_t)(((uint64_t)1000000 << 16) / mFramerate);
}
mLastTimestamp = inputBufferHeader->nTimeStamp;
codec_return = vpx_codec_encode(
mCodecContext,
&raw_frame,
inputBufferHeader->nTimeStamp, // in timebase units
frameDuration, // frame duration in timebase units
flags, // frame flags
VPX_DL_REALTIME); // encoding deadline
if (codec_return != VPX_CODEC_OK) {
ALOGE("vpx encoder failed to encode frame");
notify(OMX_EventError,
OMX_ErrorUndefined,
0, // Extra notification data
NULL); // Notification data pointer
return;
}

vpx_codec_iter_t encoded_packet_iterator = NULL;
const vpx_codec_cx_pkt_t* encoded_packet;

while ((encoded_packet = vpx_codec_get_cx_data(
mCodecContext, &encoded_packet_iterator))) {
if (encoded_packet->kind == VPX_CODEC_CX_FRAME_PKT) {
outputBufferHeader->nTimeStamp = encoded_packet->data.frame.pts;
outputBufferHeader->nFlags = 0;
if (encoded_packet->data.frame.flags & VPX_FRAME_IS_KEY)
outputBufferHeader->nFlags |= OMX_BUFFERFLAG_SYNCFRAME;
outputBufferHeader->nOffset = 0;
outputBufferHeader->nFilledLen = encoded_packet->data.frame.sz;
if (outputBufferHeader->nFilledLen > outputBufferHeader->nAllocLen) {
android_errorWriteLog(0x534e4554, "27569635");
notify(OMX_EventError, OMX_ErrorUndefined, 0, 0);
return;
}
memcpy(outputBufferHeader->pBuffer,
encoded_packet->data.frame.buf,
encoded_packet->data.frame.sz);
outputBufferInfo->mOwnedByUs = false;
outputBufferInfoQueue.erase(outputBufferInfoQueue.begin());
notifyFillBufferDone(outputBufferHeader);
}
}

inputBufferInfo->mOwnedByUs = false;
inputBufferInfoQueue.erase(inputBufferInfoQueue.begin());
notifyEmptyBufferDone(inputBufferHeader);

}
}

OMX_ERRORTYPE SoftVPXEncoder::internalSetParameter(OMX_INDEXTYPE index,
 const OMX_PTR param) {
 const int32_t indexFull = index;

 switch (indexFull) {
 case OMX_IndexParamStandardComponentRole: {
 const OMX_PARAM_COMPONENTROLETYPE *role =
 (const OMX_PARAM_COMPONENTROLETYPE*) param;

 if (!isValidOMXParam(role)) {
 return OMX_ErrorBadParameter;
 }
 return internalSetRoleParams(role);
 }

 case OMX_IndexParamVideoBitrate: {
 const OMX_VIDEO_PARAM_BITRATETYPE *bitRate =
 (const OMX_VIDEO_PARAM_BITRATETYPE*) param;

 if (!isValidOMXParam(bitRate)) {
 return OMX_ErrorBadParameter;
 }

 return internalSetBitrateParams(bitRate);
 }

 case OMX_IndexParamPortDefinition:
 {
 const OMX_PARAM_PORTDEFINITIONTYPE *portDefinition =
 (const OMX_PARAM_PORTDEFINITIONTYPE*) param;

 if (!isValidOMXParam(portDefinition)) {
 return OMX_ErrorBadParameter;
 }

            OMX_ERRORTYPE err = internalSetPortParams(portDefinition);

 if (err != OMX_ErrorNone) {
 return err;
 }

 return SimpleSoftOMXComponent::internalSetParameter(index, param);
 }

 case OMX_IndexParamVideoPortFormat: {
 const OMX_VIDEO_PARAM_PORTFORMATTYPE *portFormatType =
 (const OMX_VIDEO_PARAM_PORTFORMATTYPE*) param;

 if (!isValidOMXParam(portFormatType)) {
 return OMX_ErrorBadParameter;
 }
 return internalSetFormatParams(portFormatType);
 }

 case OMX_IndexParamVideoVp8: {
 const OMX_VIDEO_PARAM_VP8TYPE *vp8Params =
 (const OMX_VIDEO_PARAM_VP8TYPE*) param;

 if (!isValidOMXParam(vp8Params)) {
 return OMX_ErrorBadParameter;
 }

 return internalSetVp8Params(vp8Params);
 }

 case OMX_IndexParamVideoProfileLevelCurrent: {
 const OMX_VIDEO_PARAM_PROFILELEVELTYPE *vp8Params =
 (const OMX_VIDEO_PARAM_PROFILELEVELTYPE*) param;

 if (!isValidOMXParam(vp8Params)) {
 return OMX_ErrorBadParameter;
 }

 return internalSetProfileLevel(vp8Params);
 }

 case OMX_IndexParamVideoAndroidVp8Encoder:
 return internalSetAndroidVp8Params(
 (const OMX_VIDEO_PARAM_ANDROID_VP8ENCODERTYPE *)param);

 case kStoreMetaDataExtensionIndex:
 {
 const StoreMetaDataInBuffersParams *storeParam =
 (const StoreMetaDataInBuffersParams *)param;

 if (!isValidOMXParam(storeParam)) {
 return OMX_ErrorBadParameter;
 }

 if (storeParam->nPortIndex != kInputPortIndex) {
 return OMX_ErrorBadPortIndex;
 }

            mInputDataIsMeta = (storeParam->bStoreMetaData == OMX_TRUE);

 return OMX_ErrorNone;
 }

 default:
 return SimpleSoftOMXComponent::internalSetParameter(index, param);
 }
}

 android::SoftOMXComponent *createSoftOMXComponent(
 const char *name, const OMX_CALLBACKTYPE *callbacks,
        OMX_PTR appData, OMX_COMPONENTTYPE **component) {
 return new android::SoftAACEncoder(name, callbacks, appData, component);
}

SoftAACEncoder::~SoftAACEncoder() {
    delete[] mInputFrame;
    mInputFrame = NULL;

if (mEncoderHandle) {
CHECK_EQ(VO_ERR_NONE, mApiHandle->Uninit(mEncoderHandle));
mEncoderHandle = NULL;
}

delete mApiHandle;
mApiHandle = NULL;

delete mMemOperator;
mMemOperator = NULL;
}

static AUDIO_OBJECT_TYPE getAOTFromProfile(OMX_U32 profile) {
 if (profile == OMX_AUDIO_AACObjectLC) {
 return AOT_AAC_LC;
 } else if (profile == OMX_AUDIO_AACObjectHE) {
 return AOT_SBR;
 } else if (profile == OMX_AUDIO_AACObjectHE_PS) {
 return AOT_PS;
 } else if (profile == OMX_AUDIO_AACObjectLD) {
 return AOT_ER_AAC_LD;
 } else if (profile == OMX_AUDIO_AACObjectELD) {
 return AOT_ER_AAC_ELD;
 } else {
        ALOGW("Unsupported AAC profile - defaulting to AAC-LC");
 return AOT_AAC_LC;
 }
}

 void SoftAACEncoder2::initPorts() {
    OMX_PARAM_PORTDEFINITIONTYPE def;
 InitOMXParams(&def);

    def.nPortIndex = 0;
    def.eDir = OMX_DirInput;
    def.nBufferCountMin = kNumBuffers;
    def.nBufferCountActual = def.nBufferCountMin;
    def.nBufferSize = kNumSamplesPerFrame * sizeof(int16_t) * 2;
    def.bEnabled = OMX_TRUE;
    def.bPopulated = OMX_FALSE;
    def.eDomain = OMX_PortDomainAudio;
    def.bBuffersContiguous = OMX_FALSE;
    def.nBufferAlignment = 1;

    def.format.audio.cMIMEType = const_cast<char *>("audio/raw");
    def.format.audio.pNativeRender = NULL;
    def.format.audio.bFlagErrorConcealment = OMX_FALSE;
    def.format.audio.eEncoding = OMX_AUDIO_CodingPCM;

    addPort(def);

    def.nPortIndex = 1;
    def.eDir = OMX_DirOutput;
    def.nBufferCountMin = kNumBuffers;
    def.nBufferCountActual = def.nBufferCountMin;
    def.nBufferSize = 8192;
    def.bEnabled = OMX_TRUE;
    def.bPopulated = OMX_FALSE;
    def.eDomain = OMX_PortDomainAudio;
    def.bBuffersContiguous = OMX_FALSE;
    def.nBufferAlignment = 2;

    def.format.audio.cMIMEType = const_cast<char *>("audio/aac");
    def.format.audio.pNativeRender = NULL;
    def.format.audio.bFlagErrorConcealment = OMX_FALSE;
    def.format.audio.eEncoding = OMX_AUDIO_CodingAAC;

    addPort(def);
}

void SoftVPXEncoder::initPorts() {
    OMX_PARAM_PORTDEFINITIONTYPE inputPort;
    OMX_PARAM_PORTDEFINITIONTYPE outputPort;

 InitOMXParams(&inputPort);
 InitOMXParams(&outputPort);

    inputPort.nBufferCountMin = kNumBuffers;
    inputPort.nBufferCountActual = inputPort.nBufferCountMin;
    inputPort.bEnabled = OMX_TRUE;
    inputPort.bPopulated = OMX_FALSE;
    inputPort.eDomain = OMX_PortDomainVideo;
    inputPort.bBuffersContiguous = OMX_FALSE;
    inputPort.format.video.pNativeRender = NULL;
    inputPort.format.video.nFrameWidth = mWidth;
    inputPort.format.video.nFrameHeight = mHeight;
    inputPort.format.video.nStride = inputPort.format.video.nFrameWidth;
    inputPort.format.video.nSliceHeight = inputPort.format.video.nFrameHeight;
    inputPort.format.video.nBitrate = 0;
    inputPort.format.video.xFramerate = mFramerate;
    inputPort.format.video.bFlagErrorConcealment = OMX_FALSE;
    inputPort.nPortIndex = kInputPortIndex;
    inputPort.eDir = OMX_DirInput;
    inputPort.nBufferAlignment = kInputBufferAlignment;
    inputPort.format.video.cMIMEType =
 const_cast<char *>(MEDIA_MIMETYPE_VIDEO_RAW);
    inputPort.format.video.eCompressionFormat = OMX_VIDEO_CodingUnused;
    inputPort.format.video.eColorFormat = mColorFormat;
    inputPort.format.video.pNativeWindow = NULL;
    inputPort.nBufferSize =
 (inputPort.format.video.nStride *
        inputPort.format.video.nSliceHeight * 3) / 2;

    addPort(inputPort);

    outputPort.nBufferCountMin = kNumBuffers;
    outputPort.nBufferCountActual = outputPort.nBufferCountMin;
    outputPort.bEnabled = OMX_TRUE;
    outputPort.bPopulated = OMX_FALSE;
    outputPort.eDomain = OMX_PortDomainVideo;
    outputPort.bBuffersContiguous = OMX_FALSE;
    outputPort.format.video.pNativeRender = NULL;
    outputPort.format.video.nFrameWidth = mWidth;
    outputPort.format.video.nFrameHeight = mHeight;
    outputPort.format.video.nStride = outputPort.format.video.nFrameWidth;
    outputPort.format.video.nSliceHeight = outputPort.format.video.nFrameHeight;
    outputPort.format.video.nBitrate = mBitrate;
    outputPort.format.video.xFramerate = 0;
    outputPort.format.video.bFlagErrorConcealment = OMX_FALSE;
    outputPort.nPortIndex = kOutputPortIndex;
    outputPort.eDir = OMX_DirOutput;
    outputPort.nBufferAlignment = kOutputBufferAlignment;
    outputPort.format.video.cMIMEType =
 const_cast<char *>(MEDIA_MIMETYPE_VIDEO_VP8);
    outputPort.format.video.eCompressionFormat = OMX_VIDEO_CodingVP8;
    outputPort.format.video.eColorFormat = OMX_COLOR_FormatUnused;
    outputPort.format.video.pNativeWindow = NULL;
    outputPort.nBufferSize = 1024 * 1024; // arbitrary

    addPort(outputPort);
}

SoftVPXEncoder::SoftVPXEncoder(const char *name,
 const OMX_CALLBACKTYPE *callbacks,
                               OMX_PTR appData,
                               OMX_COMPONENTTYPE **component)
 : SoftVideoEncoderOMXComponent(name, callbacks, appData, component),
      mCodecContext(NULL),
      mCodecConfiguration(NULL),
      mCodecInterface(NULL),
      mWidth(176),
      mHeight(144),
      mBitrate(192000), // in bps
      mFramerate(30 << 16), // in Q16 format
      mBitrateUpdated(false),
      mBitrateControlMode(VPX_VBR), // variable bitrate
      mDCTPartitions(0),
      mErrorResilience(OMX_FALSE),
      mColorFormat(OMX_COLOR_FormatYUV420Planar),
      mLevel(OMX_VIDEO_VP8Level_Version0),
      mKeyFrameInterval(0),
      mMinQuantizer(0),
      mMaxQuantizer(0),
      mTemporalLayers(0),
      mTemporalPatternType(OMX_VIDEO_VPXTemporalLayerPatternNone),
      mTemporalPatternLength(0),
      mTemporalPatternIdx(0),
      mLastTimestamp(0x7FFFFFFFFFFFFFFFLL),
      mConversionBuffer(NULL),
      mInputDataIsMeta(false),
      mKeyFrameRequested(false) {
    memset(mTemporalLayerBitrateRatio, 0, sizeof(mTemporalLayerBitrateRatio));
    mTemporalLayerBitrateRatio[0] = 100;
    initPorts();
}

OMX_ERRORTYPE SoftMPEG4Encoder::releaseEncoder() {
    if (!mStarted) {
        return OMX_ErrorNone;
}

    PVCleanUpVideoEncoder(mHandle);
    free(mInputFrameData);
    mInputFrameData = NULL;
    delete mEncParams;
    mEncParams = NULL;
    delete mHandle;
    mHandle = NULL;
    mStarted = false;

return OMX_ErrorNone;
}

OMX_ERRORTYPE SoftMPEG4Encoder::internalSetParameter(
        OMX_INDEXTYPE index, const OMX_PTR params) {
 int32_t indexFull = index;

 switch (indexFull) {
 case OMX_IndexParamVideoErrorCorrection:
 {
 return OMX_ErrorNotImplemented;
 }

 case OMX_IndexParamVideoBitrate:
 {
            OMX_VIDEO_PARAM_BITRATETYPE *bitRate =
 (OMX_VIDEO_PARAM_BITRATETYPE *) params;

 if (!isValidOMXParam(bitRate)) {
 return OMX_ErrorBadParameter;
 }

 if (bitRate->nPortIndex != 1 ||
                bitRate->eControlRate != OMX_Video_ControlRateVariable) {
 return OMX_ErrorUndefined;
 }

            mVideoBitRate = bitRate->nTargetBitrate;
 return OMX_ErrorNone;
 }

 case OMX_IndexParamPortDefinition:
 {
            OMX_PARAM_PORTDEFINITIONTYPE *def =
 (OMX_PARAM_PORTDEFINITIONTYPE *)params;

 if (!isValidOMXParam(def)) {
 return OMX_ErrorBadParameter;
 }

 if (def->nPortIndex > 1) {
 return OMX_ErrorUndefined;
 }

 if (def->nPortIndex == 0) {
 if (def->format.video.eCompressionFormat != OMX_VIDEO_CodingUnused ||
 (def->format.video.eColorFormat != OMX_COLOR_FormatYUV420Planar &&
                     def->format.video.eColorFormat != OMX_COLOR_FormatYUV420SemiPlanar &&
                     def->format.video.eColorFormat != OMX_COLOR_FormatAndroidOpaque)) {
 return OMX_ErrorUndefined;
 }
 } else {
 if ((mEncodeMode == COMBINE_MODE_WITH_ERR_RES &&
                        def->format.video.eCompressionFormat != OMX_VIDEO_CodingMPEG4) ||
 (mEncodeMode == H263_MODE &&
                        def->format.video.eCompressionFormat != OMX_VIDEO_CodingH263) ||
 (def->format.video.eColorFormat != OMX_COLOR_FormatUnused)) {
 return OMX_ErrorUndefined;
 }
 }

            OMX_ERRORTYPE err = SimpleSoftOMXComponent::internalSetParameter(index, params);
 if (OMX_ErrorNone != err) {
 return err;
 }

 if (def->nPortIndex == 0) {
                mVideoWidth = def->format.video.nFrameWidth;
                mVideoHeight = def->format.video.nFrameHeight;
                mVideoFrameRate = def->format.video.xFramerate >> 16;
                mVideoColorFormat = def->format.video.eColorFormat;

                OMX_PARAM_PORTDEFINITIONTYPE *portDef =
 &editPortInfo(0)->mDef;
                portDef->format.video.nFrameWidth = mVideoWidth;
                portDef->format.video.nFrameHeight = mVideoHeight;
                portDef->format.video.xFramerate = def->format.video.xFramerate;
                portDef->format.video.eColorFormat =
 (OMX_COLOR_FORMATTYPE) mVideoColorFormat;
                portDef = &editPortInfo(1)->mDef;
                portDef->format.video.nFrameWidth = mVideoWidth;
                portDef->format.video.nFrameHeight = mVideoHeight;
 } else {
                mVideoBitRate = def->format.video.nBitrate;
 }

 return OMX_ErrorNone;
 }

 case OMX_IndexParamStandardComponentRole:
 {
 const OMX_PARAM_COMPONENTROLETYPE *roleParams =
 (const OMX_PARAM_COMPONENTROLETYPE *)params;

 if (!isValidOMXParam(roleParams)) {
 return OMX_ErrorBadParameter;
 }

 if (strncmp((const char *)roleParams->cRole,
 (mEncodeMode == H263_MODE)
 ? "video_encoder.h263": "video_encoder.mpeg4",
                        OMX_MAX_STRINGNAME_SIZE - 1)) {
 return OMX_ErrorUndefined;
 }

 return OMX_ErrorNone;
 }

 case OMX_IndexParamVideoPortFormat:
 {
 const OMX_VIDEO_PARAM_PORTFORMATTYPE *formatParams =
 (const OMX_VIDEO_PARAM_PORTFORMATTYPE *)params;

 if (!isValidOMXParam(formatParams)) {
 return OMX_ErrorBadParameter;
 }

 if (formatParams->nPortIndex > 1) {
 return OMX_ErrorUndefined;
 }

 if (formatParams->nIndex > 2) {
 return OMX_ErrorNoMore;
 }

 if (formatParams->nPortIndex == 0) {
 if (formatParams->eCompressionFormat != OMX_VIDEO_CodingUnused ||
 ((formatParams->nIndex == 0 &&
                      formatParams->eColorFormat != OMX_COLOR_FormatYUV420Planar) ||
 (formatParams->nIndex == 1 &&
                     formatParams->eColorFormat != OMX_COLOR_FormatYUV420SemiPlanar) ||
 (formatParams->nIndex == 2 &&
                     formatParams->eColorFormat != OMX_COLOR_FormatAndroidOpaque) )) {
 return OMX_ErrorUndefined;
 }
                mVideoColorFormat = formatParams->eColorFormat;
 } else {
 if ((mEncodeMode == H263_MODE &&
                        formatParams->eCompressionFormat != OMX_VIDEO_CodingH263) ||
 (mEncodeMode == COMBINE_MODE_WITH_ERR_RES &&
                        formatParams->eCompressionFormat != OMX_VIDEO_CodingMPEG4) ||
                    formatParams->eColorFormat != OMX_COLOR_FormatUnused) {
 return OMX_ErrorUndefined;
 }
 }

 return OMX_ErrorNone;
 }

 case OMX_IndexParamVideoH263:
 {
            OMX_VIDEO_PARAM_H263TYPE *h263type =
 (OMX_VIDEO_PARAM_H263TYPE *)params;

 if (!isValidOMXParam(h263type)) {
 return OMX_ErrorBadParameter;
 }

 if (h263type->nPortIndex != 1) {
 return OMX_ErrorUndefined;
 }

 if (h263type->eProfile != OMX_VIDEO_H263ProfileBaseline ||
                h263type->eLevel != OMX_VIDEO_H263Level45 ||
 (h263type->nAllowedPictureTypes & OMX_VIDEO_PictureTypeB) ||
                h263type->bPLUSPTYPEAllowed != OMX_FALSE ||
                h263type->bForceRoundingTypeToZero != OMX_FALSE ||
                h263type->nPictureHeaderRepetition != 0 ||
                h263type->nGOBHeaderInterval != 0) {
 return OMX_ErrorUndefined;
 }

 return OMX_ErrorNone;
 }

 case OMX_IndexParamVideoMpeg4:
 {
            OMX_VIDEO_PARAM_MPEG4TYPE *mpeg4type =
 (OMX_VIDEO_PARAM_MPEG4TYPE *)params;

 if (!isValidOMXParam(mpeg4type)) {
 return OMX_ErrorBadParameter;
 }

 if (mpeg4type->nPortIndex != 1) {
 return OMX_ErrorUndefined;
 }

 if (mpeg4type->eProfile != OMX_VIDEO_MPEG4ProfileCore ||
                mpeg4type->eLevel != OMX_VIDEO_MPEG4Level2 ||
 (mpeg4type->nAllowedPictureTypes & OMX_VIDEO_PictureTypeB) ||
                mpeg4type->nBFrames != 0 ||
                mpeg4type->nIDCVLCThreshold != 0 ||
                mpeg4type->bACPred != OMX_TRUE ||
                mpeg4type->nMaxPacketSize != 256 ||
                mpeg4type->nTimeIncRes != 1000 ||
                mpeg4type->nHeaderExtension != 0 ||
                mpeg4type->bReversibleVLC != OMX_FALSE) {
 return OMX_ErrorUndefined;
 }

 return OMX_ErrorNone;
 }

 case kStoreMetaDataExtensionIndex:
 {
 StoreMetaDataInBuffersParams *storeParams =
 (StoreMetaDataInBuffersParams*)params;

 if (!isValidOMXParam(storeParams)) {
 return OMX_ErrorBadParameter;
 }

 if (storeParams->nPortIndex != 0) {
                ALOGE("%s: StoreMetadataInBuffersParams.nPortIndex not zero!",
                        __FUNCTION__);
 return OMX_ErrorUndefined;
 }

            mStoreMetaDataInBuffers = storeParams->bStoreMetaData;
            ALOGV("StoreMetaDataInBuffers set to: %s",
                    mStoreMetaDataInBuffers ? " true" : "false");

 if (mStoreMetaDataInBuffers) {
                mVideoColorFormat = OMX_COLOR_FormatAndroidOpaque;
 }

 return OMX_ErrorNone;
 }

 default:
 return SimpleSoftOMXComponent::internalSetParameter(index, params);
 }
}

 android::SoftOMXComponent *createSoftOMXComponent(
 const char *name, const OMX_CALLBACKTYPE *callbacks,
        OMX_PTR appData, OMX_COMPONENTTYPE **component) {
 return new android::SoftAACEncoder2(name, callbacks, appData, component);
}

OMX_ERRORTYPE SoftVPXEncoder::internalSetFormatParams(
 const OMX_VIDEO_PARAM_PORTFORMATTYPE* format) {
 if (format->nPortIndex == kInputPortIndex) {
 if (format->eColorFormat == OMX_COLOR_FormatYUV420Planar ||
            format->eColorFormat == OMX_COLOR_FormatYUV420SemiPlanar ||
            format->eColorFormat == OMX_COLOR_FormatAndroidOpaque) {
            mColorFormat = format->eColorFormat;

            OMX_PARAM_PORTDEFINITIONTYPE *def = &editPortInfo(kInputPortIndex)->mDef;
            def->format.video.eColorFormat = mColorFormat;

 return OMX_ErrorNone;
 } else {
            ALOGE("Unsupported color format %i", format->eColorFormat);
 return OMX_ErrorUnsupportedSetting;
 }
 } else if (format->nPortIndex == kOutputPortIndex) {
 if (format->eCompressionFormat == OMX_VIDEO_CodingVP8) {
 return OMX_ErrorNone;
 } else {
 return OMX_ErrorUnsupportedSetting;
 }
 } else {
 return OMX_ErrorBadPortIndex;
 }
}

OMX_ERRORTYPE SoftVPXEncoder::internalSetRoleParams(
 const OMX_PARAM_COMPONENTROLETYPE* role) {
 const char* roleText = (const char*)role->cRole;
 const size_t roleTextMaxSize = OMX_MAX_STRINGNAME_SIZE - 1;

 if (strncmp(roleText, "video_encoder.vp8", roleTextMaxSize)) {
        ALOGE("Unsupported component role");
 return OMX_ErrorBadParameter;
 }

 return OMX_ErrorNone;
}

SoftAACEncoder2::~SoftAACEncoder2() {
aacEncClose(&mAACEncoder);

    delete[] mInputFrame;
    mInputFrame = NULL;
}

OMX_ERRORTYPE SoftVPXEncoder::internalGetParameter(OMX_INDEXTYPE index,
                                                   OMX_PTR param) {
 const int32_t indexFull = index;

 switch (indexFull) {
 case OMX_IndexParamVideoPortFormat: {
            OMX_VIDEO_PARAM_PORTFORMATTYPE *formatParams =
 (OMX_VIDEO_PARAM_PORTFORMATTYPE *)param;

 if (!isValidOMXParam(formatParams)) {
 return OMX_ErrorBadParameter;
 }

 if (formatParams->nPortIndex == kInputPortIndex) {
 if (formatParams->nIndex >= kNumberOfSupportedColorFormats) {
 return OMX_ErrorNoMore;
 }

 if (formatParams->nIndex == 0) {
                    formatParams->eColorFormat = OMX_COLOR_FormatYUV420Planar;
 } else if (formatParams->nIndex == 1) {
                    formatParams->eColorFormat =
                        OMX_COLOR_FormatYUV420SemiPlanar;
 } else {
                    formatParams->eColorFormat = OMX_COLOR_FormatAndroidOpaque;
 }

                formatParams->eCompressionFormat = OMX_VIDEO_CodingUnused;
                formatParams->xFramerate = mFramerate;
 return OMX_ErrorNone;
 } else if (formatParams->nPortIndex == kOutputPortIndex) {
                formatParams->eCompressionFormat = OMX_VIDEO_CodingVP8;
                formatParams->eColorFormat = OMX_COLOR_FormatUnused;
                formatParams->xFramerate = 0;
 return OMX_ErrorNone;
 } else {
 return OMX_ErrorBadPortIndex;
 }
 }

 case OMX_IndexParamVideoBitrate: {
            OMX_VIDEO_PARAM_BITRATETYPE *bitrate =
 (OMX_VIDEO_PARAM_BITRATETYPE *)param;

 if (!isValidOMXParam(bitrate)) {
 return OMX_ErrorBadParameter;
 }

 if (bitrate->nPortIndex != kOutputPortIndex) {
 return OMX_ErrorUnsupportedIndex;
 }

            bitrate->nTargetBitrate = mBitrate;

 if (mBitrateControlMode == VPX_VBR) {
                bitrate->eControlRate = OMX_Video_ControlRateVariable;
 } else if (mBitrateControlMode == VPX_CBR) {
                bitrate->eControlRate = OMX_Video_ControlRateConstant;
 } else {
 return OMX_ErrorUnsupportedSetting;
 }
 return OMX_ErrorNone;
 }

 case OMX_IndexParamVideoVp8: {
            OMX_VIDEO_PARAM_VP8TYPE *vp8Params =
 (OMX_VIDEO_PARAM_VP8TYPE *)param;

 if (!isValidOMXParam(vp8Params)) {
 return OMX_ErrorBadParameter;
 }

 if (vp8Params->nPortIndex != kOutputPortIndex) {
 return OMX_ErrorUnsupportedIndex;
 }

            vp8Params->eProfile = OMX_VIDEO_VP8ProfileMain;
            vp8Params->eLevel = mLevel;
            vp8Params->nDCTPartitions = mDCTPartitions;
            vp8Params->bErrorResilientMode = mErrorResilience;
 return OMX_ErrorNone;
 }

 case OMX_IndexParamVideoAndroidVp8Encoder: {
            OMX_VIDEO_PARAM_ANDROID_VP8ENCODERTYPE *vp8AndroidParams =
 (OMX_VIDEO_PARAM_ANDROID_VP8ENCODERTYPE *)param;

 if (!isValidOMXParam(vp8AndroidParams)) {
 return OMX_ErrorBadParameter;
 }

 if (vp8AndroidParams->nPortIndex != kOutputPortIndex) {
 return OMX_ErrorUnsupportedIndex;
 }

                vp8AndroidParams->nKeyFrameInterval = mKeyFrameInterval;
                vp8AndroidParams->eTemporalPattern = mTemporalPatternType;
                vp8AndroidParams->nTemporalLayerCount = mTemporalLayers;
                vp8AndroidParams->nMinQuantizer = mMinQuantizer;
                vp8AndroidParams->nMaxQuantizer = mMaxQuantizer;
                memcpy(vp8AndroidParams->nTemporalLayerBitrateRatio,
                       mTemporalLayerBitrateRatio, sizeof(mTemporalLayerBitrateRatio));
 return OMX_ErrorNone;
 }

 case OMX_IndexParamVideoProfileLevelQuerySupported: {
            OMX_VIDEO_PARAM_PROFILELEVELTYPE *profileAndLevel =
 (OMX_VIDEO_PARAM_PROFILELEVELTYPE *)param;

 if (!isValidOMXParam(profileAndLevel)) {
 return OMX_ErrorBadParameter;
 }

 if (profileAndLevel->nPortIndex != kOutputPortIndex) {
 return OMX_ErrorUnsupportedIndex;
 }

 switch (profileAndLevel->nProfileIndex) {
 case 0:
                    profileAndLevel->eLevel = OMX_VIDEO_VP8Level_Version0;
 break;

 case 1:
                    profileAndLevel->eLevel = OMX_VIDEO_VP8Level_Version1;
 break;

 case 2:
                    profileAndLevel->eLevel = OMX_VIDEO_VP8Level_Version2;
 break;

 case 3:
                    profileAndLevel->eLevel = OMX_VIDEO_VP8Level_Version3;
 break;

 default:
 return OMX_ErrorNoMore;
 }

            profileAndLevel->eProfile = OMX_VIDEO_VP8ProfileMain;
 return OMX_ErrorNone;
 }

 case OMX_IndexParamVideoProfileLevelCurrent: {
            OMX_VIDEO_PARAM_PROFILELEVELTYPE *profileAndLevel =
 (OMX_VIDEO_PARAM_PROFILELEVELTYPE *)param;

 if (!isValidOMXParam(profileAndLevel)) {
 return OMX_ErrorBadParameter;
 }

 if (profileAndLevel->nPortIndex != kOutputPortIndex) {
 return OMX_ErrorUnsupportedIndex;
 }

            profileAndLevel->eLevel = mLevel;
            profileAndLevel->eProfile = OMX_VIDEO_VP8ProfileMain;
 return OMX_ErrorNone;
 }

 default:
 return SimpleSoftOMXComponent::internalGetParameter(index, param);
 }
}

status_t SoftAACEncoder2::initEncoder() {
 if (AACENC_OK != aacEncOpen(&mAACEncoder, 0, 0)) {
        ALOGE("Failed to init AAC encoder");
 return UNKNOWN_ERROR;
 }
 return OK;
}

static CHANNEL_MODE getChannelMode(OMX_U32 nChannels) {
    CHANNEL_MODE chMode = MODE_INVALID;
 switch (nChannels) {
 case 1: chMode = MODE_1; break;
 case 2: chMode = MODE_2; break;
 case 3: chMode = MODE_1_2; break;
 case 4: chMode = MODE_1_2_1; break;
 case 5: chMode = MODE_1_2_2; break;
 case 6: chMode = MODE_1_2_2_1; break;
 default: chMode = MODE_INVALID;
 }
 return chMode;
}

status_t SoftAACEncoder::setAudioParams() {

    ALOGV("setAudioParams: %lu Hz, %lu channels, %lu bps",
         mSampleRate, mNumChannels, mBitRate);

 status_t err = setAudioSpecificConfigData();

 if (err != OK) {
 return err;
 }

    AACENC_PARAM params;
    memset(&params, 0, sizeof(params));
    params.sampleRate = mSampleRate;
    params.bitRate = mBitRate;
    params.nChannels = mNumChannels;
    params.adtsUsed = 0; // We add adts header in the file writer if needed.
 if (VO_ERR_NONE != mApiHandle->SetParam(
                mEncoderHandle, VO_PID_AAC_ENCPARAM, &params)) {
        ALOGE("Failed to set AAC encoder parameters");
 return UNKNOWN_ERROR;
 }

 return OK;
}

void SoftAACEncoder::initPorts() {
    OMX_PARAM_PORTDEFINITIONTYPE def;
 InitOMXParams(&def);

    def.nPortIndex = 0;
    def.eDir = OMX_DirInput;
    def.nBufferCountMin = kNumBuffers;
    def.nBufferCountActual = def.nBufferCountMin;
    def.nBufferSize = kNumSamplesPerFrame * sizeof(int16_t) * 2;
    def.bEnabled = OMX_TRUE;
    def.bPopulated = OMX_FALSE;
    def.eDomain = OMX_PortDomainAudio;
    def.bBuffersContiguous = OMX_FALSE;
    def.nBufferAlignment = 1;

    def.format.audio.cMIMEType = const_cast<char *>("audio/raw");
    def.format.audio.pNativeRender = NULL;
    def.format.audio.bFlagErrorConcealment = OMX_FALSE;
    def.format.audio.eEncoding = OMX_AUDIO_CodingPCM;

    addPort(def);

    def.nPortIndex = 1;
    def.eDir = OMX_DirOutput;
    def.nBufferCountMin = kNumBuffers;
    def.nBufferCountActual = def.nBufferCountMin;
    def.nBufferSize = 8192;
    def.bEnabled = OMX_TRUE;
    def.bPopulated = OMX_FALSE;
    def.eDomain = OMX_PortDomainAudio;
    def.bBuffersContiguous = OMX_FALSE;
    def.nBufferAlignment = 2;

    def.format.audio.cMIMEType = const_cast<char *>("audio/aac");
    def.format.audio.pNativeRender = NULL;
    def.format.audio.bFlagErrorConcealment = OMX_FALSE;
    def.format.audio.eEncoding = OMX_AUDIO_CodingAAC;

    addPort(def);
}

status_t SoftAACEncoder::setAudioSpecificConfigData() {

 int32_t index;
 status_t err = getSampleRateTableIndex(mSampleRate, index);
 if (err != OK) {
        ALOGE("Unsupported sample rate (%lu Hz)", mSampleRate);
 return err;
 }

 if (mNumChannels > 2 || mNumChannels <= 0) {
        ALOGE("Unsupported number of channels(%lu)", mNumChannels);
 return UNKNOWN_ERROR;
 }

    mAudioSpecificConfigData[0] = ((0x02 << 3) | (index >> 1));
    mAudioSpecificConfigData[1] = ((index & 0x01) << 7) | (mNumChannels << 3);

 return OK;
}

OMX_ERRORTYPE SoftAACEncoder::internalSetParameter(
        OMX_INDEXTYPE index, const OMX_PTR params) {
 switch (index) {
 case OMX_IndexParamStandardComponentRole:
 {
 const OMX_PARAM_COMPONENTROLETYPE *roleParams =
 (const OMX_PARAM_COMPONENTROLETYPE *)params;

 if (!isValidOMXParam(roleParams)) {
 return OMX_ErrorBadParameter;
 }

 if (strncmp((const char *)roleParams->cRole,
 "audio_encoder.aac",
                        OMX_MAX_STRINGNAME_SIZE - 1)) {
 return OMX_ErrorUndefined;
 }

 return OMX_ErrorNone;
 }

 case OMX_IndexParamAudioPortFormat:
 {
 const OMX_AUDIO_PARAM_PORTFORMATTYPE *formatParams =
 (const OMX_AUDIO_PARAM_PORTFORMATTYPE *)params;

 if (!isValidOMXParam(formatParams)) {
 return OMX_ErrorBadParameter;
 }

 if (formatParams->nPortIndex > 1) {
 return OMX_ErrorUndefined;
 }

 if (formatParams->nIndex > 0) {
 return OMX_ErrorNoMore;
 }

 if ((formatParams->nPortIndex == 0
 && formatParams->eEncoding != OMX_AUDIO_CodingPCM)
 || (formatParams->nPortIndex == 1
 && formatParams->eEncoding != OMX_AUDIO_CodingAAC)) {
 return OMX_ErrorUndefined;
 }

 return OMX_ErrorNone;
 }

 case OMX_IndexParamAudioAac:
 {
            OMX_AUDIO_PARAM_AACPROFILETYPE *aacParams =
 (OMX_AUDIO_PARAM_AACPROFILETYPE *)params;

 if (!isValidOMXParam(aacParams)) {
 return OMX_ErrorBadParameter;
 }

 if (aacParams->nPortIndex != 1) {
 return OMX_ErrorUndefined;
 }

            mBitRate = aacParams->nBitRate;
            mNumChannels = aacParams->nChannels;
            mSampleRate = aacParams->nSampleRate;

 if (setAudioParams() != OK) {
 return OMX_ErrorUndefined;
 }

 return OMX_ErrorNone;
 }

 case OMX_IndexParamAudioPcm:
 {
            OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =
 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;

 if (!isValidOMXParam(pcmParams)) {
 return OMX_ErrorBadParameter;
 }

 if (pcmParams->nPortIndex != 0) {
 return OMX_ErrorUndefined;
 }

            mNumChannels = pcmParams->nChannels;
            mSampleRate = pcmParams->nSamplingRate;

 if (setAudioParams() != OK) {
 return OMX_ErrorUndefined;
 }

 return OMX_ErrorNone;
 }


 default:
 return SimpleSoftOMXComponent::internalSetParameter(index, params);
 }
}

OMX_ERRORTYPE SoftVPXEncoder::internalSetProfileLevel(
 const OMX_VIDEO_PARAM_PROFILELEVELTYPE* profileAndLevel) {

 if (!isValidOMXParam(profileAndLevel)) {
 return OMX_ErrorBadParameter;
 }

 if (profileAndLevel->nPortIndex != kOutputPortIndex) {
 return OMX_ErrorUnsupportedIndex;
 }

 if (profileAndLevel->eProfile != OMX_VIDEO_VP8ProfileMain) {
 return OMX_ErrorBadParameter;
 }

 if (profileAndLevel->eLevel == OMX_VIDEO_VP8Level_Version0 ||
        profileAndLevel->eLevel == OMX_VIDEO_VP8Level_Version1 ||
        profileAndLevel->eLevel == OMX_VIDEO_VP8Level_Version2 ||
        profileAndLevel->eLevel == OMX_VIDEO_VP8Level_Version3) {
        mLevel = (OMX_VIDEO_VP8LEVELTYPE)profileAndLevel->eLevel;
 } else {
 return OMX_ErrorBadParameter;
 }

 return OMX_ErrorNone;
}

OMX_ERRORTYPE SoftAACEncoder::internalGetParameter(
        OMX_INDEXTYPE index, OMX_PTR params) {
 switch (index) {
 case OMX_IndexParamAudioPortFormat:
 {
            OMX_AUDIO_PARAM_PORTFORMATTYPE *formatParams =
 (OMX_AUDIO_PARAM_PORTFORMATTYPE *)params;

 if (!isValidOMXParam(formatParams)) {
 return OMX_ErrorBadParameter;
 }

 if (formatParams->nPortIndex > 1) {
 return OMX_ErrorUndefined;
 }

 if (formatParams->nIndex > 0) {
 return OMX_ErrorNoMore;
 }

            formatParams->eEncoding =
 (formatParams->nPortIndex == 0)
 ? OMX_AUDIO_CodingPCM : OMX_AUDIO_CodingAAC;

 return OMX_ErrorNone;
 }

 case OMX_IndexParamAudioAac:
 {
            OMX_AUDIO_PARAM_AACPROFILETYPE *aacParams =
 (OMX_AUDIO_PARAM_AACPROFILETYPE *)params;

 if (!isValidOMXParam(aacParams)) {
 return OMX_ErrorBadParameter;
 }

 if (aacParams->nPortIndex != 1) {
 return OMX_ErrorUndefined;
 }

            aacParams->nBitRate = mBitRate;
            aacParams->nAudioBandWidth = 0;
            aacParams->nAACtools = 0;
            aacParams->nAACERtools = 0;
            aacParams->eAACProfile = OMX_AUDIO_AACObjectMain;
            aacParams->eAACStreamFormat = OMX_AUDIO_AACStreamFormatMP4FF;
            aacParams->eChannelMode = OMX_AUDIO_ChannelModeStereo;

            aacParams->nChannels = mNumChannels;
            aacParams->nSampleRate = mSampleRate;
            aacParams->nFrameLength = 0;

 return OMX_ErrorNone;
 }

 case OMX_IndexParamAudioPcm:
 {
            OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =
 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;

 if (!isValidOMXParam(pcmParams)) {
 return OMX_ErrorBadParameter;
 }

 if (pcmParams->nPortIndex != 0) {
 return OMX_ErrorUndefined;
 }

            pcmParams->eNumData = OMX_NumericalDataSigned;
            pcmParams->eEndian = OMX_EndianBig;
            pcmParams->bInterleaved = OMX_TRUE;
            pcmParams->nBitPerSample = 16;
            pcmParams->ePCMMode = OMX_AUDIO_PCMModeLinear;
            pcmParams->eChannelMapping[0] = OMX_AUDIO_ChannelLF;
            pcmParams->eChannelMapping[1] = OMX_AUDIO_ChannelRF;

            pcmParams->nChannels = mNumChannels;
            pcmParams->nSamplingRate = mSampleRate;

 return OMX_ErrorNone;
 }

 default:
 return SimpleSoftOMXComponent::internalGetParameter(index, params);
 }
}
