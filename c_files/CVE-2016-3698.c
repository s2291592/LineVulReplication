bool ndp_msgna_flag_router(struct ndp_msgna *msgna)
{
	return msgna->na->nd_na_flags_reserved & ND_NA_FLAG_ROUTER;
}

void ndp_msgna_flag_solicited_set(struct ndp_msgna *msgna, bool flag_solicited)
{
	if (flag_solicited)
		msgna->na->nd_na_flags_reserved |= ND_NA_FLAG_SOLICITED;
	else
		msgna->na->nd_na_flags_reserved &= ~ND_NA_FLAG_SOLICITED;
}

void ndp_msgra_route_preference_set(struct ndp_msgra *msgra,
				    enum ndp_route_preference pref)
{
	msgra->ra->nd_ra_flags_reserved &= ~(3 << 3);
	msgra->ra->nd_ra_flags_reserved |= (pref << 3);
}

void ndp_msgna_flag_override_set(struct ndp_msgna *msgna, bool flag_override)
{
	if (flag_override)
		msgna->na->nd_na_flags_reserved |= ND_NA_FLAG_OVERRIDE;
	else
		msgna->na->nd_na_flags_reserved &= ~ND_NA_FLAG_OVERRIDE;
}

 static void ndp_msg_addrto_adjust_all_nodes(struct in6_addr *addr)
{
	struct in6_addr any = IN6ADDR_ANY_INIT;

	if (memcmp(addr, &any, sizeof(any)))
		return;
	addr->s6_addr32[0] = htonl(0xFF020000);
	addr->s6_addr32[1] = 0;
	addr->s6_addr32[2] = 0;
	addr->s6_addr32[3] = htonl(0x1);
}

int ndp_callall_eventfd_handler(struct ndp *ndp)
{
	fd_set rfds;
	int fdmax;
	struct timeval tv;
	int fd = ndp_get_eventfd(ndp);
	int ret;
	int err;

	memset(&tv, 0, sizeof(tv));
	FD_ZERO(&rfds);
	FD_SET(fd, &rfds);
	fdmax = fd + 1;
	while (true) {
		ret = select(fdmax, &rfds, NULL, NULL, &tv);
		if (ret == -1)
			return -errno;
		if (!FD_ISSET(fd, &rfds))
			return 0;
		err = ndp_call_eventfd_handler(ndp);
		if (err)
			return err;
	}
}

unsigned char *ndp_msg_opt_tlladdr(struct ndp_msg *msg, int offset)
{
	unsigned char *opt_data = ndp_msg_payload_opts_offset(msg, offset);

	return &opt_data[2];
}

void ndp_set_log_fn(struct ndp *ndp,
		    void (*log_fn)(struct ndp *ndp, int priority,
				   const char *file, int line, const char *fn,
				   const char *format, va_list args))
{
	ndp->log_fn = log_fn;
	dbg(ndp, "Custom logging function %p registered.", log_fn);
}

static bool ndp_msg_check_valid(struct ndp_msg *msg)
{
size_t len = ndp_msg_payload_len(msg);
enum ndp_msg_type msg_type = ndp_msg_type(msg);

if (len < ndp_msg_type_info(msg_type)->raw_struct_size)
return false;
	return true;
}

bool ndp_msgra_flag_other(struct ndp_msgra *msgra)
{
	return msgra->ra->nd_ra_flags_reserved & ND_RA_FLAG_OTHER;
}

void ndp_msgra_curhoplimit_set(struct ndp_msgra *msgra, uint8_t curhoplimit)
{
	msgra->ra->nd_ra_curhoplimit = curhoplimit;
}

static int log_priority(const char *priority)
{
	char *endptr;
	int prio;

	prio = strtol(priority, &endptr, 10);
	if (endptr[0] == '\0' || isspace(endptr[0]))
		return prio;
	if (strncmp(priority, "err", 3) == 0)
		return LOG_ERR;
	if (strncmp(priority, "info", 4) == 0)
		return LOG_INFO;
	if (strncmp(priority, "debug", 5) == 0)
		return LOG_DEBUG;
	return 0;
}

uint16_t ndp_msgra_router_lifetime(struct ndp_msgra *msgra)
{
	return ntohs(msgra->ra->nd_ra_router_lifetime);
}

uint8_t ndp_msgra_curhoplimit(struct ndp_msgra *msgra)
{
	return msgra->ra->nd_ra_curhoplimit;
}

static bool ndp_msg_opt_route_check_valid(void *opt_data)
{
	struct __nd_opt_route_info *ri = opt_data;

	/* rfc4191 says:
	 * If the Reserved (10) value is received, the Route Information Option
	 * MUST be ignored.
	 */
	if (((ri->nd_opt_ri_prf_reserved >> 3) & 3) == 2)
		return false;
	return true;
}

static void ndp_msg_addrto_adjust_all_routers(struct in6_addr *addr)
{
	struct in6_addr any = IN6ADDR_ANY_INIT;

	if (memcmp(addr, &any, sizeof(any)))
		return;
	addr->s6_addr32[0] = htonl(0xFF020000);
	addr->s6_addr32[1] = 0;
	addr->s6_addr32[2] = 0;
 	addr->s6_addr32[3] = htonl(0x2);
 }

static void ndp_msg_addrto_adjust_all_routers(struct in6_addr *addr)
{
	struct in6_addr any = IN6ADDR_ANY_INIT;

	if (memcmp(addr, &any, sizeof(any)))
		return;
	addr->s6_addr32[0] = htonl(0xFF020000);
	addr->s6_addr32[1] = 0;
	addr->s6_addr32[2] = 0;
	addr->s6_addr32[3] = htonl(0x2);
}

static const char *str_in6_addr(struct in6_addr *addr)
{
	static char buf[INET6_ADDRSTRLEN];

	return inet_ntop(AF_INET6, addr, buf, sizeof(buf));
}

int ndp_msg_new(struct ndp_msg **p_msg, enum ndp_msg_type msg_type)
{
	struct ndp_msg *msg;

	if (msg_type == NDP_MSG_ALL)
		return -EINVAL;
	msg = ndp_msg_alloc();
	if (!msg)
		return -ENOMEM;
	ndp_msg_init(msg, msg_type);
	*p_msg = msg;
	return 0;
}

uint32_t ndp_msg_opt_prefix_preferred_time(struct ndp_msg *msg, int offset)
{
	struct nd_opt_prefix_info *pi =
			ndp_msg_payload_opts_offset(msg, offset);

	return ntohl(pi->nd_opt_pi_preferred_time);
}

bool ndp_msg_opt_prefix_flag_on_link(struct ndp_msg *msg, int offset)
{
	struct nd_opt_prefix_info *pi =
			ndp_msg_payload_opts_offset(msg, offset);

	return pi->nd_opt_pi_flags_reserved & ND_OPT_PI_FLAG_ONLINK;
}

bool ndp_msg_opt_prefix_flag_auto_addr_conf(struct ndp_msg *msg, int offset)
{
	struct nd_opt_prefix_info *pi =
			ndp_msg_payload_opts_offset(msg, offset);

	return pi->nd_opt_pi_flags_reserved & ND_OPT_PI_FLAG_AUTO;
}

uint32_t ndp_msg_opt_dnssl_lifetime(struct ndp_msg *msg, int offset)
{
	struct __nd_opt_dnssl *dnssl =
			ndp_msg_payload_opts_offset(msg, offset);

	return ntohl(dnssl->nd_opt_dnssl_lifetime);
}

static void *myzalloc(size_t size)
{
	return calloc(1, size);
}

uint32_t ndp_msgra_reachable_time(struct ndp_msgra *msgra)
{
	return ntohl(msgra->ra->nd_ra_reachable);
}

static int myrecvfrom6(int sockfd, void *buf, size_t *buflen, int flags,
		       struct in6_addr *addr, uint32_t *ifindex)
{
struct sockaddr_in6 sin6;
	unsigned char cbuf[CMSG_SPACE(sizeof(struct in6_pktinfo))];
struct iovec iovec;
struct msghdr msghdr;
struct cmsghdr *cmsghdr;
ssize_t len;

iovec.iov_len = *buflen;
iovec.iov_base = buf;
memset(&msghdr, 0, sizeof(msghdr));
msghdr.msg_name = &sin6;
msghdr.msg_namelen = sizeof(sin6);
msghdr.msg_iov = &iovec;
msghdr.msg_iovlen = 1;
msghdr.msg_control = cbuf;
msghdr.msg_controllen = sizeof(cbuf);

len = recvmsg(sockfd, &msghdr, flags);
if (len == -1)
return -errno;
*buflen = len;

/* Set ifindex to scope_id now. But since scope_id gets not
* set by kernel for linklocal addresses, use pktinfo to obtain that
* value right after.
*/
*ifindex = sin6.sin6_scope_id;
for (cmsghdr = CMSG_FIRSTHDR(&msghdr); cmsghdr;
cmsghdr = CMSG_NXTHDR(&msghdr, cmsghdr)) {
		if (cmsghdr->cmsg_level == IPPROTO_IPV6 &&
		    cmsghdr->cmsg_type == IPV6_PKTINFO &&
		    cmsghdr->cmsg_len == CMSG_LEN(sizeof(struct in6_pktinfo))) {
			struct in6_pktinfo *pktinfo;

			pktinfo = (struct in6_pktinfo *) CMSG_DATA(cmsghdr);
			*ifindex = pktinfo->ipi6_ifindex;
}
}
*addr = sin6.sin6_addr;

return 0;
}

static void ndp_msg_addrto_adjust_all_nodes(struct in6_addr *addr)
{
	struct in6_addr any = IN6ADDR_ANY_INIT;

	if (memcmp(addr, &any, sizeof(any)))
		return;
	addr->s6_addr32[0] = htonl(0xFF020000);
	addr->s6_addr32[1] = 0;
	addr->s6_addr32[2] = 0;
	addr->s6_addr32[3] = htonl(0x1);
}

uint32_t ndp_msg_opt_prefix_valid_time(struct ndp_msg *msg, int offset)
{
	struct nd_opt_prefix_info *pi =
			ndp_msg_payload_opts_offset(msg, offset);

	return ntohl(pi->nd_opt_pi_valid_time);
}

void ndp_msg_destroy(struct ndp_msg *msg)
{
	free(msg);
}

static void *ndp_msg_payload_opts_offset(struct ndp_msg *msg, int offset)
{
	unsigned char *ptr = ndp_msg_payload_opts(msg);

	return ptr + offset;
}

static void *myzalloc(size_t size)
{
	return calloc(1, size);
 }

static int myrecvfrom6(int sockfd, void *buf, size_t *buflen, int flags,
		       struct in6_addr *addr, uint32_t *ifindex, int *hoplimit)
{
	struct sockaddr_in6 sin6;
	unsigned char cbuf[2 * CMSG_SPACE(sizeof(struct in6_pktinfo))];
	struct iovec iovec;
	struct msghdr msghdr;
	struct cmsghdr *cmsghdr;
	ssize_t len;

	iovec.iov_len = *buflen;
	iovec.iov_base = buf;
	memset(&msghdr, 0, sizeof(msghdr));
	msghdr.msg_name = &sin6;
	msghdr.msg_namelen = sizeof(sin6);
	msghdr.msg_iov = &iovec;
	msghdr.msg_iovlen = 1;
	msghdr.msg_control = cbuf;
	msghdr.msg_controllen = sizeof(cbuf);

	len = recvmsg(sockfd, &msghdr, flags);
	if (len == -1)
		return -errno;
	*buflen = len;

	/* Set ifindex to scope_id now. But since scope_id gets not
	 * set by kernel for linklocal addresses, use pktinfo to obtain that
	 * value right after.
	 */
	*ifindex = sin6.sin6_scope_id;
        for (cmsghdr = CMSG_FIRSTHDR(&msghdr); cmsghdr;
	     cmsghdr = CMSG_NXTHDR(&msghdr, cmsghdr)) {
		if (cmsghdr->cmsg_level != IPPROTO_IPV6)
			continue;

		switch(cmsghdr->cmsg_type) {
		case IPV6_PKTINFO:
			if (cmsghdr->cmsg_len == CMSG_LEN(sizeof(struct in6_pktinfo))) {
				struct in6_pktinfo *pktinfo;

				pktinfo = (struct in6_pktinfo *) CMSG_DATA(cmsghdr);
				*ifindex = pktinfo->ipi6_ifindex;
			}
			break;
		case IPV6_HOPLIMIT:
			if (cmsghdr->cmsg_len == CMSG_LEN(sizeof(int))) {
				int *val;

				val = (int *) CMSG_DATA(cmsghdr);
				*hoplimit = *val;
			}
			break;
		}
	}
	*addr = sin6.sin6_addr;

	return 0;
}

size_t ndp_msg_payload_maxlen(struct ndp_msg *msg)
{
	return sizeof(msg->buf);
}

void ndp_msgra_flag_home_agent_set(struct ndp_msgra *msgra,
				   bool flag_home_agent)
{
	if (flag_home_agent)
		msgra->ra->nd_ra_flags_reserved |= ND_RA_FLAG_HOME_AGENT;
	else
		msgra->ra->nd_ra_flags_reserved &= ~ND_RA_FLAG_HOME_AGENT;
}

void ndp_msgra_router_lifetime_set(struct ndp_msgra *msgra,
				   uint16_t router_lifetime)
{
	msgra->ra->nd_ra_router_lifetime = htons(router_lifetime);
}

uint32_t ndp_msgra_retransmit_time(struct ndp_msgra *msgra)
{
	return ntohl(msgra->ra->nd_ra_retransmit);
}

bool ndp_msg_opt_prefix_flag_router_addr(struct ndp_msg *msg, int offset)
{
	struct nd_opt_prefix_info *pi =
			ndp_msg_payload_opts_offset(msg, offset);

	return pi->nd_opt_pi_flags_reserved & ND_OPT_PI_FLAG_RADDR;
}

int ndp_msg_next_opt_offset(struct ndp_msg *msg, int offset,
			    enum ndp_msg_opt_type opt_type)
{
	unsigned char *opts_start = ndp_msg_payload_opts(msg);
	unsigned char *ptr = opts_start;
	size_t len = ndp_msg_payload_opts_len(msg);
	uint8_t opt_raw_type = ndp_msg_opt_type_info(opt_type)->raw_type;
	bool ignore = true;

	if (offset == -1) {
		offset = 0;
		ignore = false;
	}

	ptr += offset;
	len -= offset;
	while (len > 0) {
		uint8_t cur_opt_raw_type = ptr[0];
		unsigned int cur_opt_len = ptr[1] << 3; /* convert to bytes */

		if (!cur_opt_len || len < cur_opt_len)
			break;
		if (cur_opt_raw_type == opt_raw_type && !ignore)
			return ptr - opts_start;
		ptr += cur_opt_len;
		len -= cur_opt_len;
		ignore = false;
	}
	return -1;
}

char *ndp_msg_opt_dnssl_domain(struct ndp_msg *msg, int offset,
			       int domain_index)
{
	int i;
	static char buf[256];
	struct __nd_opt_dnssl *dnssl =
			ndp_msg_payload_opts_offset(msg, offset);
	size_t len = dnssl->nd_opt_dnssl_len << 3; /* convert to bytes */
	char *ptr;

	len -= in_struct_offset(struct __nd_opt_dnssl, nd_opt_dnssl_domains);
	ptr = dnssl->nd_opt_dnssl_domains;

	i = 0;
	while (len > 0) {
		size_t buf_len = 0;
		while (len > 0) {
			uint8_t dom_len = *ptr;

			ptr++;
			len--;
			if (!dom_len)
				break;

			if (dom_len > len)
				return NULL;

			if (buf_len + dom_len + 1 > sizeof(buf))
				return NULL;

			memcpy(buf + buf_len, ptr, dom_len);
			buf[buf_len + dom_len] = '.';
			ptr += dom_len;
			len -= dom_len;
			buf_len += dom_len + 1;
		}
		if (!buf_len)
			break;
		buf[buf_len - 1] = '\0'; /* overwrite final '.' */
		if (i++ == domain_index)
			return buf;
	}
	return NULL;
}

uint32_t ndp_msg_opt_rdnss_lifetime(struct ndp_msg *msg, int offset)
{
	struct __nd_opt_rdnss *rdnss =
			ndp_msg_payload_opts_offset(msg, offset);

	return ntohl(rdnss->nd_opt_rdnss_lifetime);
}

bool ndp_msgra_flag_managed(struct ndp_msgra *msgra)
{
	return msgra->ra->nd_ra_flags_reserved & ND_RA_FLAG_MANAGED;
}

int ndp_msg_send_with_flags(struct ndp *ndp, struct ndp_msg *msg, uint8_t flags)
{
	enum ndp_msg_type msg_type = ndp_msg_type(msg);

	if (ndp_msg_type_info(msg_type)->addrto_adjust)
		ndp_msg_type_info(msg_type)->addrto_adjust(&msg->addrto);

	switch (msg_type) {
		case NDP_MSG_NA:
			if (flags & ND_OPT_NA_UNSOL) {
				ndp_msgna_flag_override_set((struct ndp_msgna*)&msg->nd_msg, true);
				ndp_msgna_flag_solicited_set((struct ndp_msgna*)&msg->nd_msg, false);
				ndp_msg_addrto_adjust_all_nodes(&msg->addrto);
			} else {
				ndp_msgna_flag_solicited_set((struct ndp_msgna*)&msg->nd_msg, true);
			}
			break;
		default:
			break;
	}

	return mysendto6(ndp->sock, msg->buf, msg->len, 0,
			 &msg->addrto, msg->ifindex);
}

enum ndp_msg_type ndp_msg_type(struct ndp_msg *msg)
{
	enum ndp_msg_type msg_type;
	int err;

	err = ndp_msg_type_by_raw_type(&msg_type, msg->icmp6_hdr->icmp6_type);
	/* Type should be always set correctly (ensured by ndp_msg_init) */
	BUG_ON(err);
	return msg_type;
}

bool ndp_msgna_flag_override(struct ndp_msgna *msgna)
{
	return msgna->na->nd_na_flags_reserved & ND_NA_FLAG_OVERRIDE;
}

static void log_stderr(struct ndp *ndp, int priority,
		       const char *file, int line, const char *fn,
		       const char *format, va_list args)
{
	fprintf(stderr, "libndp: %s: ", fn);
	vfprintf(stderr, format, args);
	fprintf(stderr, "\n");
}

struct in6_addr *ndp_msg_opt_prefix(struct ndp_msg *msg, int offset)
{
	struct nd_opt_prefix_info *pi =
			ndp_msg_payload_opts_offset(msg, offset);

	return &pi->nd_opt_pi_prefix;
}

struct ndp_msgna *ndp_msgna(struct ndp_msg *msg)
{
	if (ndp_msg_type(msg) != NDP_MSG_NA)
		return NULL;
	return &msg->nd_msg.na;
}

int ndp_open(struct ndp **p_ndp)
{
	struct ndp *ndp;
	const char *env;
	int err;

	ndp = myzalloc(sizeof(*ndp));
	if (!ndp)
		return -ENOMEM;
	ndp->log_fn = log_stderr;
	ndp->log_priority = LOG_ERR;
	/* environment overwrites config */
	env = getenv("NDP_LOG");
	if (env != NULL)
		ndp_set_log_priority(ndp, log_priority(env));

	dbg(ndp, "ndp context %p created.", ndp);
	dbg(ndp, "log_priority=%d", ndp->log_priority);

	list_init(&ndp->msgrcv_handler_list);
	err = ndp_sock_open(ndp);
	if (err)
		goto free_ndp;

	*p_ndp = ndp;
	return 0;
free_ndp:
	free(ndp);
	return err;
}

uint8_t ndp_msg_opt_route_prefix_len(struct ndp_msg *msg, int offset)
{
	struct __nd_opt_route_info *ri =
			ndp_msg_payload_opts_offset(msg, offset);

	return ri->nd_opt_ri_prefix_len;
}

void ndp_msgra_retransmit_time_set(struct ndp_msgra *msgra,
				   uint32_t retransmit_time)
{
	msgra->ra->nd_ra_retransmit = htonl(retransmit_time);
}

void ndp_msgra_reachable_time_set(struct ndp_msgra *msgra,
				  uint32_t reachable_time)
{
	msgra->ra->nd_ra_reachable = htonl(reachable_time);
}

struct ndp_msg_opt_type_info *ndp_msg_opt_type_info_by_raw_type(uint8_t raw_type)
{
	struct ndp_msg_opt_type_info *info;
	int i;

	for (i = 0; i < NDP_MSG_OPT_TYPE_LIST_SIZE; i++) {
		info = &ndp_msg_opt_type_info_list[i];
		if (info->raw_type == raw_type)
			return info;
	}
	return NULL;
}

 static struct ndp_msg *ndp_msg_alloc(void)
{
	struct ndp_msg *msg;

	msg = myzalloc(sizeof(*msg));
	if (!msg)
		return NULL;
	msg->icmp6_hdr = (struct icmp6_hdr *) msg->buf;
	return msg;
}

bool ndp_msgna_flag_solicited(struct ndp_msgna *msgna)
{
	return msgna->na->nd_na_flags_reserved & ND_NA_FLAG_SOLICITED;
}

static void ndp_sock_close(struct ndp *ndp)
{
	close(ndp->sock);
}

static int ndp_msg_type_by_raw_type(enum ndp_msg_type *p_msg_type,
				    uint8_t raw_type)
{
	int i;

	for (i = 0; i < NDP_MSG_TYPE_LIST_SIZE; i++) {
		if (ndp_msg_type_info(i)->raw_type == raw_type) {
			*p_msg_type = i;
			return 0;
		}
	}
	return -ENOENT;
}

struct ndp_msgra *ndp_msgra(struct ndp_msg *msg)
{
	if (ndp_msg_type(msg) != NDP_MSG_RA)
		return NULL;
	return &msg->nd_msg.ra;
}

static void ndp_msg_type_set(struct ndp_msg *msg, enum ndp_msg_type msg_type)
{
	msg->icmp6_hdr->icmp6_type = ndp_msg_type_info(msg_type)->raw_type;
}

void ndp_msgna_flag_router_set(struct ndp_msgna *msgna, bool flag_router)
{
	if (flag_router)
		msgna->na->nd_na_flags_reserved |= ND_NA_FLAG_ROUTER;
	else
		msgna->na->nd_na_flags_reserved &= ~ND_NA_FLAG_ROUTER;
}

uint8_t ndp_msg_opt_prefix_len(struct ndp_msg *msg, int offset)
{
	struct nd_opt_prefix_info *pi =
			ndp_msg_payload_opts_offset(msg, offset);

	return pi->nd_opt_pi_prefix_len;
}

int ndp_get_eventfd(struct ndp *ndp)
{
	return ndp->sock;
}

static bool ndp_msg_check_valid(struct ndp_msg *msg)
{
	size_t len = ndp_msg_payload_len(msg);
	enum ndp_msg_type msg_type = ndp_msg_type(msg);

	if (len < ndp_msg_type_info(msg_type)->raw_struct_size)
		return false;
	return true;
}

void ndp_close(struct ndp *ndp)
{
	ndp_sock_close(ndp);
	free(ndp);
}

struct in6_addr *ndp_msg_opt_rdnss_addr(struct ndp_msg *msg, int offset,
					int addr_index)
{
	static struct in6_addr addr;
	struct __nd_opt_rdnss *rdnss =
			ndp_msg_payload_opts_offset(msg, offset);
	size_t len = rdnss->nd_opt_rdnss_len << 3; /* convert to bytes */

	len -= in_struct_offset(struct __nd_opt_rdnss, nd_opt_rdnss_addresses);
	if ((addr_index + 1) * sizeof(addr) > len)
		return NULL;
	memcpy(&addr, &rdnss->nd_opt_rdnss_addresses[addr_index * sizeof(addr)],
	       sizeof(addr));
	return &addr;
}

unsigned char *ndp_msg_opt_slladdr(struct ndp_msg *msg, int offset)
{
	unsigned char *opt_data = ndp_msg_payload_opts_offset(msg, offset);

	return &opt_data[2];
}

ndp_msg_opt_route_preference(struct ndp_msg *msg, int offset)
{
	struct __nd_opt_route_info *ri =
			ndp_msg_payload_opts_offset(msg, offset);

	return (ri->nd_opt_ri_prf_reserved >> 3) & 3;
}

int ndp_msgrcv_handler_register(struct ndp *ndp, ndp_msgrcv_handler_func_t func,
				enum ndp_msg_type msg_type, uint32_t ifindex,
				void *priv)
{
	struct ndp_msgrcv_handler_item *handler_item;

	if (ndp_find_msgrcv_handler_item(ndp, func, msg_type,
					 ifindex, priv))
		return -EEXIST;
	if (!func)
		return -EINVAL;
	handler_item = malloc(sizeof(*handler_item));
	if (!handler_item)
		return -ENOMEM;
	handler_item->func = func;
	handler_item->msg_type = msg_type;
	handler_item->ifindex = ifindex;
	handler_item->priv = priv;
	list_add_tail(&ndp->msgrcv_handler_list, &handler_item->list);
	return 0;
}

size_t ndp_msg_payload_opts_len(struct ndp_msg *msg)
{
	return msg->len - (msg->opts_start - msg->buf);
}

int ndp_msg_send(struct ndp *ndp, struct ndp_msg *msg)
{
	return ndp_msg_send_with_flags(ndp, msg, ND_OPT_NORMAL);
}

struct ndp_msg_opt_type_info *ndp_msg_opt_type_info(enum ndp_msg_opt_type msg_opt_type)
{
	return &ndp_msg_opt_type_info_list[msg_opt_type];
}

static int ndp_call_handlers(struct ndp *ndp, struct ndp_msg *msg)
{
	struct ndp_msgrcv_handler_item *handler_item;
	int err;

	list_for_each_node_entry(handler_item,
				 &ndp->msgrcv_handler_list, list) {
		if (handler_item->msg_type != NDP_MSG_ALL &&
		    handler_item->msg_type != ndp_msg_type(msg))
			continue;
		if (handler_item->ifindex &&
		    handler_item->ifindex != msg->ifindex)
			continue;
		err = handler_item->func(ndp, msg, handler_item->priv);
		if (err)
			return err;
	}
	return 0;
}

uint32_t ndp_msg_opt_mtu(struct ndp_msg *msg, int offset)
{
	struct nd_opt_mtu *mtu = ndp_msg_payload_opts_offset(msg, offset);

	return ntohl(mtu->nd_opt_mtu_mtu);
}

static int ndp_sock_open(struct ndp *ndp)
{
	int sock;
	int ret;
	int err;
	int val;

	sock = socket(PF_INET6, SOCK_RAW, IPPROTO_ICMPV6);
	if (sock == -1) {
		err(ndp, "Failed to create ICMP6 socket.");
		return -errno;
	}

	val = 1;
	ret = setsockopt(sock, IPPROTO_IPV6, IPV6_RECVPKTINFO,
			 &val, sizeof(val));
	if (ret == -1) {
		err(ndp, "Failed to setsockopt IPV6_RECVPKTINFO.");
		err = -errno;
		goto close_sock;
	}

	val = 255;
	ret = setsockopt(sock, IPPROTO_IPV6, IPV6_MULTICAST_HOPS,
			 &val, sizeof(val));
	if (ret == -1) {
		err(ndp, "Failed to setsockopt IPV6_MULTICAST_HOPS.");
		err = -errno;
		goto close_sock;
	}

	val = 1;
	ret = setsockopt(sock, IPPROTO_IPV6, IPV6_RECVHOPLIMIT,
			 &val, sizeof(val));
	if (ret == -1) {
		err(ndp, "Failed to setsockopt IPV6_RECVHOPLIMIT,.");
		err = -errno;
		goto close_sock;
	}

	ndp->sock = sock;
	return 0;
close_sock:
	close(sock);
	return err;
}

void ndp_log(struct ndp *ndp, int priority,
	     const char *file, int line, const char *fn,
	     const char *format, ...)
{
	va_list args;

	va_start(args, format);
	ndp->log_fn(ndp, priority, file, line, fn, format, args);
	va_end(args);
}

static struct ndp_msg *ndp_msg_alloc(void)
{
	struct ndp_msg *msg;

	msg = myzalloc(sizeof(*msg));
	if (!msg)
		return NULL;
	msg->icmp6_hdr = (struct icmp6_hdr *) msg->buf;
	return msg;
}

void ndp_msgrcv_handler_unregister(struct ndp *ndp, ndp_msgrcv_handler_func_t func,
				   enum ndp_msg_type msg_type, uint32_t ifindex,
				   void *priv)
{
	struct ndp_msgrcv_handler_item *handler_item;

	handler_item = ndp_find_msgrcv_handler_item(ndp, func, msg_type,
						    ifindex, priv);
	if (!handler_item)
		return;
	list_del(&handler_item->list);
	free(handler_item);
}

static void ndp_msg_init(struct ndp_msg *msg, enum ndp_msg_type msg_type)
{
	size_t raw_struct_size = ndp_msg_type_info(msg_type)->raw_struct_size;

	ndp_msg_type_set(msg, msg_type);
	msg->len = raw_struct_size;
	msg->opts_start = msg->buf + raw_struct_size;

	/* Set-up "first pointers" in all ndp_msgrs, ndp_msgra, ndp_msgns,
	 * ndp_msgna, ndp_msgr structures.
	 */
	msg->nd_msg.generic.dataptr = ndp_msg_payload(msg);
}

void ndp_msgra_flag_other_set(struct ndp_msgra *msgra, bool flag_other)
{
	if (flag_other)
		msgra->ra->nd_ra_flags_reserved |= ND_RA_FLAG_OTHER;
	else
		msgra->ra->nd_ra_flags_reserved &= ~ND_RA_FLAG_OTHER;
}
