bool IsYoutubeDomainUrl(const GURL& url,
                        SubdomainPermission subdomain_permission,
                        PortPermission port_permission) {
  return IsValidURL(url, port_permission) &&
         IsValidHostName(url.host_piece(), "youtube", subdomain_permission,
                         nullptr);
}

  TestDispatcherHostDelegate() : should_add_data_reduction_proxy_data_(false) {}

bool IsGoogleSearchUrl(const GURL& url) {
  if (!IsGoogleDomainUrl(url, DISALLOW_SUBDOMAIN,
                         DISALLOW_NON_STANDARD_PORTS) &&
      !IsGoogleSearchSubdomainUrl(url)) {
    return false;
  }

  base::StringPiece path(url.path_piece());
  bool is_home_page_base = IsPathHomePageBase(path);
  if (!is_home_page_base && (path != "/search"))
    return false;

  return HasGoogleSearchQueryParam(url.ref_piece()) ||
         (!is_home_page_base && HasGoogleSearchQueryParam(url.query_piece()));
}

std::string GetGoogleCountryCode(const GURL& google_homepage_url) {
  base::StringPiece google_hostname = google_homepage_url.host_piece();
  const size_t last_dot = google_hostname.find_last_of('.');
  if (last_dot == std::string::npos)
    return std::string();
  base::StringPiece country_code = google_hostname.substr(last_dot + 1);
  if (country_code == "com")
    return "us";
  if (country_code == "uk")
    return "gb";
  if (country_code == "cat")
    return "es";
  return country_code.as_string();
}

void StripTrailingDot(base::StringPiece* host) {
  if (host->ends_with("."))
    host->remove_suffix(1);
}

void GetFilePathWithReplacements(const std::string& original_file_path,
                                 const base::StringPairs& text_to_replace,
                                 std::string* replacement_path) {
  std::string new_file_path = original_file_path;
  for (const auto& replacement : text_to_replace) {
    const std::string& old_text = replacement.first;
    const std::string& new_text = replacement.second;
    std::string base64_old;
    std::string base64_new;
    base::Base64Encode(old_text, &base64_old);
    base::Base64Encode(new_text, &base64_new);
    if (new_file_path == original_file_path)
      new_file_path += "?";
    else
      new_file_path += "&";
    new_file_path += "replace_text=";
    new_file_path += base64_old;
    new_file_path += ":";
    new_file_path += base64_new;
  }

   *replacement_path = new_file_path;
 }

const std::vector<std::string>& GetGoogleRegistrableDomains() {
  static base::NoDestructor<std::vector<std::string>>
      kGoogleRegisterableDomains([]() {
        std::vector<std::string> domains;

        std::vector<std::string> tlds{GOOGLE_TLD_LIST};
        for (const std::string& tld : tlds) {
          std::string domain = "google." + tld;

          if (GetDomainAndRegistry(domain,
                                   net::registry_controlled_domains::
                                       INCLUDE_PRIVATE_REGISTRIES) != domain) {
            continue;
          }

          domains.push_back(domain);
        }

        return domains;
      }());

   return *kGoogleRegisterableDomains;
 }

  explicit HeaderTestDispatcherHostDelegate(const GURL& watch_url)
       : watch_url_(watch_url) {}

std::unique_ptr<HttpResponse> HandlePrefixedRequest(
    const std::string& prefix,
    const EmbeddedTestServer::HandleRequestCallback& handler,
    const HttpRequest& request) {
  if (ShouldHandle(request, prefix))
    return handler.Run(request);
  return nullptr;
}

bool ShouldHandle(const HttpRequest& request, const std::string& path_prefix) {
  GURL url = request.GetURL();
  return url.path() == path_prefix ||
         base::StartsWith(url.path(), path_prefix + "/",
                          base::CompareCase::SENSITIVE);
}

 bool IsCanonicalHostGoogleHostname(base::StringPiece canonical_host,
                                   SubdomainPermission subdomain_permission) {
  const GURL& base_url(CommandLineGoogleBaseURL());
  if (base_url.is_valid() && (canonical_host == base_url.host_piece()))
    return true;

  base::StringPiece tld;
  if (!IsValidHostName(canonical_host, "google", subdomain_permission, &tld))
    return false;

  StripTrailingDot(&tld);

  static const base::NoDestructor<base::flat_set<base::StringPiece>>
      google_tlds(std::initializer_list<base::StringPiece>({GOOGLE_TLD_LIST}));
  return google_tlds->contains(tld);
}

bool IsValidURL(const GURL& url, PortPermission port_permission) {
return url.is_valid() && url.SchemeIsHTTPOrHTTPS() &&
         (url.port().empty() || (port_permission == ALLOW_NON_STANDARD_PORTS));
}

  void set_should_add_data_reduction_proxy_data(
      bool should_add_data_reduction_proxy_data) {
    should_add_data_reduction_proxy_data_ =
         should_add_data_reduction_proxy_data;
   }

MirrorMockURLRequestJob(net::URLRequest* request,
                          net::NetworkDelegate* network_delegate,
                          const base::FilePath& file_path,
                          ReportResponseHeadersOnUI report_on_ui)
      : net::URLRequestMockHTTPJob(request, network_delegate, file_path),
        report_on_ui_(report_on_ui) {}

bool IsGoogleHomePageUrl(const GURL& url) {
  if (!IsGoogleDomainUrl(url, DISALLOW_SUBDOMAIN,
                         DISALLOW_NON_STANDARD_PORTS) &&
      !IsGoogleSearchSubdomainUrl(url)) {
    return false;
  }

  base::StringPiece path(url.path_piece());
  return IsPathHomePageBase(path) ||
         base::StartsWith(path, "/ig", base::CompareCase::INSENSITIVE_ASCII);
}

MirrorMockJobInterceptor(const base::FilePath& root_http,
                           ReportResponseHeadersOnUI report_on_ui)
      : root_http_(root_http), report_on_ui_(report_on_ui) {}

std::unique_ptr<net::test_server::HttpResponse> HandleTestRequest(
    const net::test_server::HttpRequest& request) {
  if (request.relative_url == "/") {
    std::unique_ptr<net::test_server::BasicHttpResponse> http_response(
        new net::test_server::BasicHttpResponse);
    http_response->set_code(net::HTTP_OK);
    http_response->set_content("Success");
    return std::move(http_response);
  }
  return nullptr;
}

GURL AppendGoogleLocaleParam(const GURL& url,
                             const std::string& application_locale) {
  return net::AppendQueryParameter(url, "hl",
                                   GetGoogleLocale(application_locale));
}

void SetMockLinkDoctorBaseURLForTesting() {
  gUseMockLinkDoctorBaseURLForTesting = true;
}

GURL GetGoogleSearchURL(const GURL& google_homepage_url) {
  GURL::Replacements replacements;
  replacements.SetPathStr("search");
  replacements.SetQueryStr("q=");
  return google_homepage_url.ReplaceComponents(replacements);
}

   void GetTimesStandardThrottlesAddedForURL(const GURL& url, int* count) {
    DCHECK_CURRENTLY_ON(content::BrowserThread::IO);
    *count = times_stardard_throttles_added_for_url_[url];
  }

bool IsGoogleSearchSubdomainUrl(const GURL& url) {
  if (!IsValidURL(url, PortPermission::DISALLOW_NON_STANDARD_PORTS))
    return false;

  base::StringPiece host(url.host_piece());
  StripTrailingDot(&host);

  static const base::NoDestructor<base::flat_set<base::StringPiece>>
      google_subdomains(std::initializer_list<base::StringPiece>(
          {"ipv4.google.com", "ipv6.google.com"}));

  return google_subdomains->contains(host);
}

void SetDelegateOnIO(content::ResourceDispatcherHostDelegate* new_delegate) {
  content::ResourceDispatcherHost::Get()->SetDelegate(new_delegate);
}

std::string GetGoogleLocale(const std::string& application_locale) {
  return (application_locale == "nb") ? "no" : application_locale;
}

static void Unregister(const GURL& url) {
    EXPECT_TRUE(
        content::BrowserThread::CurrentlyOn(content::BrowserThread::IO));
    net::URLRequestFilter::GetInstance()->RemoveUrlHandler(url);
}

  ChromeResourceDispatcherHostDelegateBrowserTest() {}

bool IsValidHostName(base::StringPiece host,
                     base::StringPiece domain_in_lower_case,
                     SubdomainPermission subdomain_permission,
                     base::StringPiece* tld) {
  if (host.find(domain_in_lower_case) == base::StringPiece::npos)
    return false;

  size_t tld_length =
      net::registry_controlled_domains::GetCanonicalHostRegistryLength(
          host, net::registry_controlled_domains::EXCLUDE_UNKNOWN_REGISTRIES,
          net::registry_controlled_domains::EXCLUDE_PRIVATE_REGISTRIES);
  if ((tld_length == 0) || (tld_length == std::string::npos))
    return false;

  base::StringPiece host_minus_tld =
      host.substr(0, host.length() - tld_length - 1);

  if (tld)
    *tld = host.substr(host.length() - tld_length);

  if (base::LowerCaseEqualsASCII(host_minus_tld, domain_in_lower_case))
    return true;

  if (subdomain_permission == ALLOW_SUBDOMAIN) {
    std::string dot_domain(".");
    domain_in_lower_case.AppendToString(&dot_domain);
    return base::EndsWith(host_minus_tld, dot_domain,
                          base::CompareCase::INSENSITIVE_ASCII);
  }

  std::string www_domain("www.");
  domain_in_lower_case.AppendToString(&www_domain);
  return base::LowerCaseEqualsASCII(host_minus_tld, www_domain);
}

  void SetShouldAddDataReductionProxyData(bool add_data) {
    dispatcher_host_delegate_->set_should_add_data_reduction_proxy_data(
        add_data);
  }

std::unique_ptr<HttpResponse> HandleFileRequest(
const base::FilePath& server_root,
const HttpRequest& request) {
// This is a test-only server. Ignore I/O thread restrictions.
// TODO(svaldez): Figure out why thread is I/O restricted in the first place.
base::ScopedAllowBlockingForTesting allow_blocking;

// A proxy request will have an absolute path. Simulate the proxy by stripping
// the scheme, host, and port.
GURL request_url = request.GetURL();
std::string relative_path(request_url.path());

std::string post_prefix("/post/");
if (base::StartsWith(relative_path, post_prefix,
base::CompareCase::SENSITIVE)) {
if (request.method != METHOD_POST)
return nullptr;
relative_path = relative_path.substr(post_prefix.size() - 1);
}

RequestQuery query = ParseQuery(request_url);

std::unique_ptr<BasicHttpResponse> failed_response(new BasicHttpResponse);
failed_response->set_code(HTTP_NOT_FOUND);

if (query.find("expected_body") != query.end()) {
if (request.content.find(query["expected_body"].front()) ==
std::string::npos) {
return std::move(failed_response);
}
}

if (query.find("expected_headers") != query.end()) {
for (const auto& header : query["expected_headers"]) {
if (header.find(":") == std::string::npos)
return std::move(failed_response);
std::string key = header.substr(0, header.find(":"));
std::string value = header.substr(header.find(":") + 1);
if (request.headers.find(key) == request.headers.end() ||
request.headers.at(key) != value) {
return std::move(failed_response);
}
}
}

// Trim the first byte ('/').
DCHECK(base::StartsWith(relative_path, "/", base::CompareCase::SENSITIVE));
std::string request_path = relative_path.substr(1);
base::FilePath file_path(server_root.AppendASCII(request_path));
std::string file_contents;
if (!base::ReadFileToString(file_path, &file_contents)) {
file_path = file_path.AppendASCII("index.html");
if (!base::ReadFileToString(file_path, &file_contents))
return nullptr;
}

if (request.method == METHOD_HEAD)
file_contents = "";

  if (query.find("replace_text") != query.end()) {
    for (const auto& replacement : query["replace_text"]) {
      if (replacement.find(":") == std::string::npos)
        return std::move(failed_response);
      std::string find;
      std::string with;
      base::Base64Decode(replacement.substr(0, replacement.find(":")), &find);
      base::Base64Decode(replacement.substr(replacement.find(":") + 1), &with);
      base::ReplaceSubstringsAfterOffset(&file_contents, 0, find, with);
    }
  }

base::FilePath::StringPieceType mock_headers_extension;
#if defined(OS_WIN)
base::string16 temp = base::ASCIIToUTF16(kMockHttpHeadersExtension);
mock_headers_extension = temp;
#else
mock_headers_extension = kMockHttpHeadersExtension;
#endif

base::FilePath headers_path(file_path.AddExtension(mock_headers_extension));

if (base::PathExists(headers_path)) {
std::string headers_contents;

    if (!base::ReadFileToString(headers_path, &headers_contents))
return nullptr;

return std::make_unique<RawHttpResponse>(headers_contents, file_contents);
}

std::unique_ptr<BasicHttpResponse> http_response(new BasicHttpResponse);
http_response->set_code(HTTP_OK);

if (request.headers.find("Range") != request.headers.end()) {
std::vector<HttpByteRange> ranges;

if (HttpUtil::ParseRangeHeader(request.headers.at("Range"), &ranges) &&
ranges.size() == 1) {
ranges[0].ComputeBounds(file_contents.size());
size_t start = ranges[0].first_byte_position();
size_t end = ranges[0].last_byte_position();

http_response->set_code(HTTP_PARTIAL_CONTENT);
http_response->AddCustomHeader(
"Content-Range",
base::StringPrintf("bytes %" PRIuS "-%" PRIuS "/%" PRIuS, start, end,
file_contents.size()));

file_contents = file_contents.substr(start, end - start + 1);
}
}

http_response->set_content_type(GetContentType(file_path));
http_response->AddCustomHeader("Accept-Ranges", "bytes");
http_response->AddCustomHeader("ETag", "'" + file_path.MaybeAsASCII() + "'");
http_response->set_content(file_contents);
return std::move(http_response);
}

static void Register(const GURL& url,
                       const base::FilePath& root_http,
                       ReportResponseHeadersOnUI report_on_ui) {
    EXPECT_TRUE(
        content::BrowserThread::CurrentlyOn(content::BrowserThread::IO));
    base::FilePath file_path(root_http);
    file_path =
        file_path.AppendASCII(url.scheme() + "." + url.host() + ".html");
    net::URLRequestFilter::GetInstance()->AddUrlInterceptor(
        url, base::WrapUnique(
                 new MirrorMockJobInterceptor(file_path, report_on_ui)));
  }

const net::HttpRequestHeaders& request_headers() const {
    return request_headers_;
  }

bool HasGoogleSearchQueryParam(base::StringPiece str) {
  url::Component query(0, static_cast<int>(str.length())), key, value;
  while (url::ExtractQueryKeyValue(str.data(), &query, &key, &value)) {
    base::StringPiece key_str = str.substr(key.begin, key.len);
    if (key_str == "q" || key_str == "as_q")
      return true;
  }
  return false;
}

bool IsGoogleHostname(base::StringPiece host,
                      SubdomainPermission subdomain_permission) {
  url::CanonHostInfo host_info;
  return IsCanonicalHostGoogleHostname(net::CanonicalizeHost(host, &host_info),
                                       subdomain_permission);
}

void ReportRequestHeaders(std::map<std::string, std::string>* request_headers,
                          const std::string& url,
                          const std::string& headers) {
  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
  // Ensure that a previous value is not overwritten.
  EXPECT_FALSE(base::ContainsKey(*request_headers, url));
  (*request_headers)[url] = headers;
}

 bool IsPathHomePageBase(base::StringPiece path) {
   return (path == "/") || (path == "/webhp");
 }

std::string GetContentType(const base::FilePath& path) {
  if (path.MatchesExtension(FILE_PATH_LITERAL(".crx")))
    return "application/x-chrome-extension";
  if (path.MatchesExtension(FILE_PATH_LITERAL(".css")))
    return "text/css";
  if (path.MatchesExtension(FILE_PATH_LITERAL(".exe")))
    return "application/octet-stream";
  if (path.MatchesExtension(FILE_PATH_LITERAL(".gif")))
    return "image/gif";
  if (path.MatchesExtension(FILE_PATH_LITERAL(".gzip")) ||
      path.MatchesExtension(FILE_PATH_LITERAL(".gz"))) {
    return "application/x-gzip";
  }
  if (path.MatchesExtension(FILE_PATH_LITERAL(".jpeg")) ||
      path.MatchesExtension(FILE_PATH_LITERAL(".jpg"))) {
    return "image/jpeg";
  }
  if (path.MatchesExtension(FILE_PATH_LITERAL(".js")))
    return "application/javascript";
  if (path.MatchesExtension(FILE_PATH_LITERAL(".json")))
    return "application/json";
  if (path.MatchesExtension(FILE_PATH_LITERAL(".pdf")))
    return "application/pdf";
  if (path.MatchesExtension(FILE_PATH_LITERAL(".txt")))
    return "text/plain";
  if (path.MatchesExtension(FILE_PATH_LITERAL(".wav")))
    return "audio/wav";
  if (path.MatchesExtension(FILE_PATH_LITERAL(".xml")))
    return "text/xml";
  if (path.MatchesExtension(FILE_PATH_LITERAL(".mhtml")))
    return "multipart/related";
  if (path.MatchesExtension(FILE_PATH_LITERAL(".mht")))
    return "message/rfc822";
  if (path.MatchesExtension(FILE_PATH_LITERAL(".html")) ||
      path.MatchesExtension(FILE_PATH_LITERAL(".htm"))) {
    return "text/html";
  }
  return "";
}
