gfx::Size ConstrainedWidthView::CalculatePreferredSize() const {
  gfx::Size size = View::CalculatePreferredSize();
  if (size.width() <= max_width_)
    return size;
  return gfx::Size(max_width_, GetHeightForWidth(max_width_));
}

void AutofillPopupItemView::RefreshStyle() {
  SetBackground(CreateBackground());
  SchedulePaint();
}

void AutofillPopupBaseView::DoUpdateBoundsAndRedrawPopup() {
  gfx::Size size = GetPreferredSize();
  gfx::Rect element_bounds = gfx::ToEnclosingRect(delegate()->element_bounds());
  element_bounds.Inset(/*horizontal=*/0, /*vertical=*/-kElementBorderPadding);

  gfx::Rect popup_bounds = PopupViewCommon().CalculatePopupBounds(
      size.width(), size.height(), element_bounds, delegate()->container_view(),
      delegate()->IsRTL());
  popup_bounds.Inset(-GetWidget()->GetRootView()->border()->GetInsets());
  GetWidget()->SetBounds(popup_bounds);

  Layout();
  SetClipPath();
   SchedulePaint();
 }

void AutofillExternalDelegate::ApplyAutofillOptions(
    std::vector<Suggestion>* suggestions,
    bool is_all_server_suggestions) {
  if (query_field_.is_autofilled) {
    base::string16 value =
        l10n_util::GetStringUTF16(IDS_AUTOFILL_CLEAR_FORM_MENU_ITEM);
#if defined(OS_ANDROID)
    if (IsKeyboardAccessoryEnabled())
      value = base::i18n::ToUpper(value);
#endif

    suggestions->push_back(Suggestion(value));
    suggestions->back().frontend_id = POPUP_ITEM_ID_CLEAR_FORM;
  }

  suggestions->push_back(Suggestion(GetSettingsSuggestionValue()));
  suggestions->back().frontend_id = POPUP_ITEM_ID_AUTOFILL_OPTIONS;
  if (is_all_server_suggestions)
    suggestions->back().icon = base::ASCIIToUTF16("googlePay");

#if defined(OS_IOS)
  if (base::FeatureList::IsEnabled(
          features::kAutofillDownstreamUseGooglePayBrandingOniOS) &&
      is_all_server_suggestions) {
    Suggestion googlepay_icon;
    googlepay_icon.icon = base::ASCIIToUTF16("googlePay");
    googlepay_icon.frontend_id = POPUP_ITEM_ID_GOOGLE_PAY_BRANDING;
    suggestions->insert(suggestions->begin(), googlepay_icon);
  }
#endif

#if defined(OS_ANDROID)
  if (IsKeyboardAccessoryEnabled()) {
    suggestions->back().icon = base::ASCIIToUTF16("settings");
    if (IsHintEnabledInKeyboardAccessory() && !query_field_.is_autofilled) {
      Suggestion create_icon;
      create_icon.icon = base::ASCIIToUTF16("create");
      create_icon.frontend_id = POPUP_ITEM_ID_CREATE_HINT;
      suggestions->push_back(create_icon);
    }
  }
#endif
}

const FeatureEntry* GetFeatureEntries(size_t* count) {
  *count = base::size(kFeatureEntries);
  return kFeatureEntries;
}

void AutofillPopupViewNativeViews::DoUpdateBoundsAndRedrawPopup() {
  gfx::Size size = CalculatePreferredSize();
  gfx::Rect popup_bounds;

  gfx::Rect element_bounds =
      gfx::ToEnclosingRect(controller_->element_bounds());
  element_bounds.Inset(/*horizontal=*/0, /*vertical=*/-kElementBorderPadding);

  PopupViewCommon().CalculatePopupVerticalBounds(size.height(), element_bounds,
                                                 controller_->container_view(),
                                                 &popup_bounds);

  int scroll_width = 0;
  if (size.height() > popup_bounds.height()) {
    size.set_height(popup_bounds.height());

    scroll_width = scroll_view_->GetScrollBarLayoutWidth();
  }
  size.set_width(AdjustWidth(size.width() + scroll_width));

  PopupViewCommon().CalculatePopupHorizontalBounds(
      size.width(), element_bounds, controller_->container_view(),
      controller_->IsRTL(), &popup_bounds);

  SetSize(size);

  popup_bounds.Inset(-GetWidget()->GetRootView()->border()->GetInsets());
  GetWidget()->SetBounds(popup_bounds);
  SetClipPath();

   SchedulePaint();
 }

base::string16 AutofillExternalDelegate::GetSettingsSuggestionValue()
    const {
  switch (GetPopupType()) {
    case PopupType::kAddresses:
      return l10n_util::GetStringUTF16(IDS_AUTOFILL_MANAGE_ADDRESSES);

    case PopupType::kCreditCards:
      return l10n_util::GetStringUTF16(IDS_AUTOFILL_MANAGE_PAYMENT_METHODS);

    case PopupType::kPersonalInformation:
    case PopupType::kUnspecified:
      return l10n_util::GetStringUTF16(IDS_AUTOFILL_MANAGE);

    case PopupType::kPasswords:
      NOTREACHED();
      return base::string16();
  }
}

std::unique_ptr<views::Border> AutofillPopupViewViews::CreateBorder() {
  return views::CreateSolidBorder(
      kPopupBorderThicknessDp,
      GetNativeTheme()->GetSystemColor(
          ui::NativeTheme::kColorId_UnfocusedBorderColor));
}

void AutofillPopupViewViews::DoUpdateBoundsAndRedrawPopup() {
  gfx::Rect bounds = delegate()->popup_bounds();

  SetSize(bounds.size());

  gfx::Rect clipping_bounds = CalculateClippingBounds();

  int available_vertical_space = clipping_bounds.height() -
                                 (bounds.y() - clipping_bounds.y()) -
                                 kPopupBottomMargin;

  if (available_vertical_space < bounds.height()) {
    const int extra_width =
        scroll_view_ ? scroll_view_->GetScrollBarLayoutWidth() : 0;
    bounds.set_width(bounds.width() + extra_width);
    bounds.set_height(available_vertical_space);
  }

  bounds.Inset(-GetWidget()->GetRootView()->border()->GetInsets());
  GetWidget()->SetBounds(bounds);

  SchedulePaint();
}

void AutofillPopupBaseView::AcceptSelection(const gfx::Point& point) {
  if (!delegate_)
    return;

  delegate_->SetSelectionAtPoint(point);
  delegate_->AcceptSelectedLine();
}

void AutofillExternalDelegate::DidEndTextFieldEditing() {
  manager_->client()->HideAutofillPopup();
}

 gfx::NativeView AutofillPopupBaseView::container_view() {
   return delegate_->container_view();
 }

void AutofillPopupBaseView::DoShow() {
const bool initialize_widget = !GetWidget();
if (initialize_widget) {
// On Mac Cocoa browser, |parent_widget_| is null (the parent is not a
// views::Widget).
// TODO(crbug.com/826862): Remove |parent_widget_|.
if (parent_widget_)
parent_widget_->AddObserver(this);

// The widget is destroyed by the corresponding NativeWidget, so we use
// a weak pointer to hold the reference and don't have to worry about
// deletion.
views::Widget* widget = new views::Widget;
views::Widget::InitParams params(views::Widget::InitParams::TYPE_POPUP);
params.delegate = this;
params.parent = parent_widget_ ? parent_widget_->GetNativeView()
: delegate_->container_view();
    AddExtraInitParams(&params);
widget->Init(params);
    std::unique_ptr<views::View> wrapper = CreateWrapperView();
    if (wrapper)
      widget->SetContentsView(wrapper.release());
widget->AddObserver(this);

// No animation for popup appearance (too distracting).
widget->SetVisibilityAnimationTransition(views::Widget::ANIMATE_HIDE);

show_time_ = base::Time::Now();
}

GetWidget()->GetRootView()->SetBorder(CreateBorder());
DoUpdateBoundsAndRedrawPopup();
GetWidget()->Show();

// Showing the widget can change native focus (which would result in an
// immediate hiding of the popup). Only start observing after shown.
if (initialize_widget)
views::WidgetFocusManager::GetInstance()->AddFocusChangeListener(this);
}

  AutofillPopupWarningView(AutofillPopupViewNativeViews* popup_view,
                           int line_number)
      : AutofillPopupRowView(popup_view, line_number) {}

bool IsAutofillUpstreamBlankCardholderNameFieldExperimentEnabled() {
  return base::FeatureList::IsEnabled(
      features::kAutofillUpstreamBlankCardholderNameField);
}

bool AutofillExternalDelegate::RemoveSuggestion(const base::string16& value,
                                                int identifier) {
  if (identifier > 0)
    return manager_->RemoveAutofillProfileOrCreditCard(identifier);

  if (identifier == POPUP_ITEM_ID_AUTOCOMPLETE_ENTRY) {
    manager_->RemoveAutocompleteEntry(query_field_.name, value);
    return true;
  }

  return false;
}

views::View* PasswordPopupSuggestionView::CreateValueLabel() {
  views::View* label = AutofillPopupSuggestionView::CreateValueLabel();
  return new ConstrainedWidthView(label, kAutofillPopupUsernameMaxWidth);
}

PopupType AutofillExternalDelegate::GetPopupType() const {
  return popup_type_;
}

bool ShouldUseNativeViews() {
#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX)
  return base::FeatureList::IsEnabled(kAutofillExpandedPopupViews) ||
         base::FeatureList::IsEnabled(::features::kExperimentalUi);
#else
  return false;
#endif
}

int AutofillPopupBaseView::GetCornerRadius() {
  return ChromeLayoutProvider::Get()->GetCornerRadiusMetric(
      views::EMPHASIS_MEDIUM);
}

void AutofillExternalDelegate::DidSelectSuggestion(
    const base::string16& value,
    int identifier) {
  ClearPreviewedForm();

  if (identifier > 0)
    FillAutofillFormData(identifier, true);
  else if (identifier == POPUP_ITEM_ID_AUTOCOMPLETE_ENTRY)
    driver_->RendererShouldPreviewFieldWithValue(value);
}

AutofillPopupSuggestionView::CreateBackground() {
  return views::CreateSolidBackground(
      is_selected_ ? popup_view_->GetSelectedBackgroundColor()
                   : popup_view_->GetBackgroundColor());
}

void AutofillPopupViewNativeViews::OnSelectedRowChanged(
    base::Optional<int> previous_row_selection,
    base::Optional<int> current_row_selection) {
  if (previous_row_selection) {
    rows_[*previous_row_selection]->SetSelected(false);
  }

  if (current_row_selection)
    rows_[*current_row_selection]->SetSelected(true);
}

views::Label* AutofillPopupItemView::CreateSecondaryLabel(
    const base::string16& text) const {
  return CreateLabelWithStyleAndContext(
      text, ChromeTextContext::CONTEXT_BODY_TEXT_LARGE,
      ChromeTextStyle::STYLE_SECONDARY);
}

MATCHER_P(CreditCardMatches, card, "") {
  return !arg.Compare(card);
}

void AutofillPopupViewViews::DrawAutofillEntry(gfx::Canvas* canvas,
                                               int index,
                                               const gfx::Rect& entry_rect) {
  canvas->FillRect(
      entry_rect,
      GetNativeTheme()->GetSystemColor(
          controller_->GetBackgroundColorIDForRow(index)));

  const bool is_rtl = controller_->IsRTL();
  const int text_align =
      is_rtl ? gfx::Canvas::TEXT_ALIGN_RIGHT : gfx::Canvas::TEXT_ALIGN_LEFT;
  gfx::Rect value_rect = entry_rect;
  value_rect.Inset(AutofillPopupLayoutModel::kEndPadding, 0);

  bool icon_on_the_right = !is_rtl;
  int x_align_left = icon_on_the_right ? value_rect.right() : value_rect.x();

  int row_height = controller_->layout_model().GetRowBounds(index).height();
  const gfx::ImageSkia image = controller_->layout_model().GetIconImage(index);
  if (!image.isNull()) {
    int icon_y = entry_rect.y() + (row_height - image.height()) / 2;

    int icon_x_align_left =
        icon_on_the_right ? x_align_left - image.width() : x_align_left;

    canvas->DrawImageInt(image, icon_x_align_left, icon_y);

      x_align_left =
          icon_x_align_left +
          (is_rtl ? image.width() + AutofillPopupLayoutModel::kIconPadding
                  : -AutofillPopupLayoutModel::kIconPadding);
  }

  const int value_width = gfx::GetStringWidth(
      controller_->GetElidedValueAt(index),
      controller_->layout_model().GetValueFontListForRow(index));
  int value_x_align_left =
      is_rtl ? value_rect.right() - value_width : value_rect.x();

  canvas->DrawStringRectWithFlags(
      controller_->GetElidedValueAt(index),
      controller_->layout_model().GetValueFontListForRow(index),
      GetNativeTheme()->GetSystemColor(
          controller_->layout_model().GetValueFontColorIDForRow(index)),
      gfx::Rect(value_x_align_left, value_rect.y(), value_width,
                value_rect.height()),
      text_align);

  if (!controller_->GetSuggestionAt(index).label.empty()) {
    const int label_width = gfx::GetStringWidth(
        controller_->GetElidedLabelAt(index),
        controller_->layout_model().GetLabelFontListForRow(index));
    int label_x_align_left = x_align_left + (is_rtl ? 0 : -label_width);

    canvas->DrawStringRectWithFlags(
        controller_->GetElidedLabelAt(index),
        controller_->layout_model().GetLabelFontListForRow(index),
        GetNativeTheme()->GetSystemColor(
            ui::NativeTheme::kColorId_ResultsTableDimmedText),
        gfx::Rect(label_x_align_left, entry_rect.y(), label_width,
                  entry_rect.height()),
        text_align);
  }
}

void AutofillPopupBaseView::DoHide() {
  delegate_ = NULL;

  RemoveWidgetObservers();

  if (GetWidget()) {
    GetWidget()->Close();
  } else {
    delete this;
  }
}

  explicit AutofillPopupChildView(const Suggestion& suggestion,
                                  int32_t set_size,
                                  int32_t pos_in_set)
      : suggestion_(suggestion),
        is_selected_(false),
        set_size_(set_size),
        pos_in_set_(pos_in_set) {
    SetFocusBehavior(suggestion.frontend_id == POPUP_ITEM_ID_SEPARATOR
                         ? FocusBehavior::NEVER
                         : FocusBehavior::ALWAYS);
  }

int GetHorizontalMargin() {
  return views::MenuConfig::instance().item_horizontal_padding +
         autofill::AutofillPopupBaseView::GetCornerRadius();
}

  int frontend_id() const { return frontend_id_; }

AutofillPopupViewNativeViews::~AutofillPopupViewNativeViews() {}

AutofillPopupWarningView::CreateBackground() {
  return views::CreateSolidBackground(popup_view_->GetBackgroundColor());
}

int AutofillPopupViewNativeViews::AdjustWidth(int width) const {
  if (width >= kAutofillPopupMaxWidth)
    return kAutofillPopupMaxWidth;

  int elem_width = gfx::ToEnclosingRect(controller_->element_bounds()).width();

  int min_width = (kAutofillPopupMinWidth <= elem_width &&
                   elem_width < kAutofillPopupMaxWidth)
                      ? elem_width
                      : kAutofillPopupMinWidth;

  if (width <= min_width)
    return min_width;

  if (width % kAutofillPopupWidthMultiple) {
    width +=
        (kAutofillPopupWidthMultiple - (width % kAutofillPopupWidthMultiple));
  }

  return width;
}

  FlagsStateSingleton()
      : flags_state_(kFeatureEntries, base::size(kFeatureEntries)) {}

PasswordPopupSuggestionView::PasswordPopupSuggestionView(
    AutofillPopupViewNativeViews* popup_view,
    int line_number,
    int frontend_id)
    : AutofillPopupSuggestionView(popup_view, line_number, frontend_id) {
  origin_ = popup_view_->controller()->GetElidedLabelAt(line_number_);
  masked_password_ =
      popup_view_->controller()->GetSuggestionAt(line_number_).additional_label;
}

void AutofillExternalDelegate::OnQuery(int query_id,
                                       const FormData& form,
                                       const FormFieldData& field,
                                       const gfx::RectF& element_bounds) {
  query_form_ = form;
  query_field_ = field;
  query_id_ = query_id;
  element_bounds_ = element_bounds;
  should_show_scan_credit_card_ =
      manager_->ShouldShowScanCreditCard(query_form_, query_field_);
  popup_type_ = manager_->GetPopupType(query_form_, query_field_);
  should_show_cc_signin_promo_ =
      manager_->ShouldShowCreditCardSigninPromo(query_form_, query_field_);
  should_show_cards_from_account_option_ =
      manager_->ShouldShowCardsFromAccountOption(query_form_, query_field_);
}

  MockAutofillDriver() {}

bool AutofillExternalDelegate::GetDeletionConfirmationText(
    const base::string16& value,
    int identifier,
    base::string16* title,
    base::string16* body) {
  return manager_->GetDeletionConfirmationText(value, identifier, title, body);
}

void AutofillPopupBaseView::OnMouseCaptureLost() {
  ClearSelection();
}

ConstrainedWidthView::ConstrainedWidthView(views::View* child, int max_width)
    : max_width_(max_width) {
  SetLayoutManager(std::make_unique<views::FillLayout>());
  AddChildView(child);
}

  AutofillPopupItemView(AutofillPopupViewNativeViews* popup_view,
                        int line_number,
                        int frontend_id,
                        int extra_height = 0)
      : AutofillPopupRowView(popup_view, line_number),
        frontend_id_(frontend_id),
        extra_height_(extra_height) {}

void AutofillPopupItemView::GetAccessibleNodeData(ui::AXNodeData* node_data) {
  AutofillPopupController* controller = popup_view_->controller();
  auto suggestion = controller->GetSuggestionAt(line_number_);
  std::vector<base::string16> text;
  text.push_back(suggestion.value);
  text.push_back(suggestion.label);
  text.push_back(suggestion.additional_label);

  base::string16 icon_description;
  if (!suggestion.icon.empty()) {
    const int id = controller->layout_model().GetIconAccessibleNameResourceId(
        suggestion.icon);
    if (id > 0)
      text.push_back(l10n_util::GetStringUTF16(id));
  }
  node_data->SetName(base::JoinString(text, base::ASCIIToUTF16(" ")));

  node_data->role = ax::mojom::Role::kMenuItem;
  node_data->AddBoolAttribute(ax::mojom::BoolAttribute::kSelected,
                              is_selected_);

  int set_size = 0;
  int pos_in_set = line_number_ + 1;
  for (int i = 0; i < controller->GetLineCount(); ++i) {
    if (controller->GetSuggestionAt(i).frontend_id ==
        autofill::POPUP_ITEM_ID_SEPARATOR) {
      if (i < line_number_)
        --pos_in_set;
    } else {
      ++set_size;
    }
  }
  node_data->AddIntAttribute(ax::mojom::IntAttribute::kSetSize, set_size);
  node_data->AddIntAttribute(ax::mojom::IntAttribute::kPosInSet, pos_in_set);
}

void AutofillExternalDelegate::OnPopupSuppressed() {
  manager_->DidSuppressPopup(query_form_, query_field_);
}

bool AutofillPopupFooterView::ShouldUseCustomFontWeightForPrimaryInfo(
    gfx::Font::Weight* font_weight) const {
  return false;
}

std::unique_ptr<views::Background> AutofillPopupFooterView::CreateBackground() {
  return views::CreateSolidBackground(
      is_selected_ ? popup_view_->GetSelectedBackgroundColor()
                   : popup_view_->GetFooterBackgroundColor());
}

void AutofillExternalDelegate::OnPopupHidden() {
  driver_->PopupHidden();
}

AutofillExternalDelegate::AutofillExternalDelegate(AutofillManager* manager,
                                                   AutofillDriver* driver)
    : manager_(manager), driver_(driver) {
  DCHECK(manager);
}

 void AutofillPopupBaseView::OnNativeFocusChanged(gfx::NativeView focused_now) {
   if (GetWidget() && GetWidget()->GetNativeView() != focused_now)
     HideController();
}

void AutofillPopupItemView::AddIcon(gfx::ImageSkia icon) {
  auto* image_view = new views::ImageView();
  image_view->SetImage(icon);
  AddChildView(image_view);
}

  bool ShouldShowCardsFromAccountOption(const FormData& form,
                                        const FormFieldData& field) {
    return should_show_cards_from_account_option_;
  }

void AutofillPopupBaseView::OnMouseExited(const ui::MouseEvent& event) {
  if (!delegate_ || !delegate_->HasSelection())
    return;

  base::ThreadTaskRunnerHandle::Get()->PostTask(
      FROM_HERE, base::BindOnce(&AutofillPopupBaseView::ClearSelection,
                                weak_ptr_factory_.GetWeakPtr()));
}

AutofillExternalDelegate::~AutofillExternalDelegate() {
  if (deletion_callback_)
    std::move(deletion_callback_).Run();
}

 bool IsAutofillSaveCardDialogUnlabeledExpirationDateEnabled() {
   return base::FeatureList::IsEnabled(
       kAutofillSaveCardDialogUnlabeledExpirationDate);
}

void AutofillPopupBaseView::GetAccessibleNodeData(ui::AXNodeData* node_data) {
  node_data->role = ax::mojom::Role::kPane;
  node_data->SetName(
      l10n_util::GetStringUTF16(IDS_AUTOFILL_POPUP_ACCESSIBLE_NODE_DATA));
}

void AutofillPopupViewViews::CreateChildViews() {
  RemoveAllChildViews(true /* delete_children */);

  int set_size = controller_->GetLineCount();
  for (int i = 0; i < set_size; ++i) {
    AddChildView(new AutofillPopupChildView(controller_->GetSuggestionAt(i),
                                            set_size, i + 1));
  }
}

void AutofillPopupItemView::CreateContent() {
  AutofillPopupController* controller = popup_view_->controller();

  auto* layout_manager = SetLayoutManager(std::make_unique<views::BoxLayout>(
      views::BoxLayout::kHorizontal, gfx::Insets(0, GetHorizontalMargin())));

  layout_manager->set_cross_axis_alignment(
      views::BoxLayout::CrossAxisAlignment::CROSS_AXIS_ALIGNMENT_STRETCH);

  const gfx::ImageSkia icon =
      controller->layout_model().GetIconImage(line_number_);

  if (!icon.isNull() &&
      (GetLayoutType() == PopupItemLayoutType::kLeadingIcon ||
       GetLayoutType() == PopupItemLayoutType::kTwoLinesLeadingIcon)) {
    AddIcon(icon);
    AddSpacerWithSize(views::MenuConfig::instance().item_horizontal_padding,
                      /*resize=*/false, layout_manager);
  }

  views::View* lower_value_label = CreateSubtextLabel();
  views::View* value_label = CreateValueLabel();

  const int kStandardRowHeight =
      views::MenuConfig::instance().touchable_menu_height + extra_height_;
  if (!lower_value_label) {
    layout_manager->set_minimum_cross_axis_size(kStandardRowHeight);
    AddChildView(value_label);
  } else {
    layout_manager->set_minimum_cross_axis_size(
        kStandardRowHeight + kAutofillPopupAdditionalDoubleRowHeight);
    views::View* values_container = new views::View();
    auto* vertical_layout =
        values_container->SetLayoutManager(std::make_unique<views::BoxLayout>(
            views::BoxLayout::kVertical, gfx::Insets(),
            kAdjacentLabelsVerticalSpacing));
    vertical_layout->set_main_axis_alignment(
        views::BoxLayout::MAIN_AXIS_ALIGNMENT_CENTER);
    vertical_layout->set_cross_axis_alignment(
        views::BoxLayout::CROSS_AXIS_ALIGNMENT_START);
    values_container->AddChildView(value_label);
    values_container->AddChildView(lower_value_label);
    AddChildView(values_container);
  }

  AddSpacerWithSize(AutofillPopupBaseView::kValueLabelPadding,
                    /*resize=*/true, layout_manager);

  views::View* description_label = CreateDescriptionLabel();
  if (description_label)
    AddChildView(description_label);

  if (!icon.isNull() && GetLayoutType() == PopupItemLayoutType::kTrailingIcon) {
    AddSpacerWithSize(views::MenuConfig::instance().item_horizontal_padding,
                      /*resize=*/false, layout_manager);
    AddIcon(icon);
  }
}

void RecordUMAStatistics(flags_ui::FlagsStorage* flags_storage) {
  std::set<std::string> switches;
  std::set<std::string> features;
  FlagsStateSingleton::GetFlagsState()->GetSwitchesAndFeaturesFromFlags(
      flags_storage, &switches, &features);
  ReportAboutFlagsHistogram("Launch.FlagsAtStartup", switches, features);
}

views::View* PasswordPopupSuggestionView::CreateSubtextLabel() {
  base::string16 text_to_use;
  if (!origin_.empty()) {
    text_to_use = origin_;
  } else if (GetLayoutType() == PopupItemLayoutType::kTwoLinesLeadingIcon) {
    text_to_use = masked_password_;
  }

  if (text_to_use.empty())
    return nullptr;

  views::Label* label = CreateSecondaryLabel(text_to_use);
  label->SetElideBehavior(gfx::ELIDE_HEAD);
  return new ConstrainedWidthView(label, kAutofillPopupUsernameMaxWidth);
}

  AutofillPopupViewViewsTest() {}

void AutofillPopupViewViews::Hide() {
  controller_ = NULL;
  ui::AXPlatformNode::OnInputSuggestionsUnavailable();
  DoHide();
  NotifyAccessibilityEvent(ax::mojom::Event::kMenuEnd, true);
}

bool IsAutofillCreditCardAssistEnabled() {
#if !defined(OS_ANDROID) && !defined(OS_IOS)
  return false;
#else
  return base::FeatureList::IsEnabled(kAutofillCreditCardAssist);
#endif
}

void AutofillPopupViewViews::SetClipPath() {}

void AutofillPopupBaseView::SetSelection(const gfx::Point& point) {
  if (delegate_)
    delegate_->SetSelectionAtPoint(point);
}

AutofillPopupView* AutofillPopupView::Create(
    AutofillPopupController* controller) {
#if defined(OS_MACOSX)
  if (!platform_util::GetTopLevel(controller->container_view()))
    return nullptr;
#endif

  views::Widget* observing_widget =
      views::Widget::GetTopLevelWidgetForNativeView(
          controller->container_view());

#if !defined(OS_MACOSX)
  if (!observing_widget)
    return nullptr;
#endif

  if (features::ShouldUseNativeViews())
    return new AutofillPopupViewNativeViews(controller, observing_widget);

  return new AutofillPopupViewViews(controller, observing_widget);
}

bool AutofillPopupRowView::OnMouseDragged(const ui::MouseEvent& event) {
  return true;
}

AutofillPopupSuggestionView* AutofillPopupSuggestionView::Create(
    AutofillPopupViewNativeViews* popup_view,
    int line_number,
    int frontend_id) {
  AutofillPopupSuggestionView* result =
      new AutofillPopupSuggestionView(popup_view, line_number, frontend_id);
  result->Init();
  return result;
}

void AutofillExternalDelegate::DidAcceptSuggestion(const base::string16& value,
                                                   int identifier,
                                                   int position) {
  if (identifier == POPUP_ITEM_ID_AUTOFILL_OPTIONS) {
    manager_->ShowAutofillSettings(popup_type_ == PopupType::kCreditCards);
  } else if (identifier == POPUP_ITEM_ID_CLEAR_FORM) {
    driver_->RendererShouldClearFilledSection();
  } else if (identifier == POPUP_ITEM_ID_PASSWORD_ENTRY ||
             identifier == POPUP_ITEM_ID_USERNAME_ENTRY) {
    NOTREACHED();  // Should be handled elsewhere.
  } else if (identifier == POPUP_ITEM_ID_DATALIST_ENTRY) {
    driver_->RendererShouldAcceptDataListSuggestion(value);
  } else if (identifier == POPUP_ITEM_ID_AUTOCOMPLETE_ENTRY) {
    driver_->RendererShouldFillFieldWithValue(value);
    AutofillMetrics::LogAutocompleteSuggestionAcceptedIndex(position);
  } else if (identifier == POPUP_ITEM_ID_SCAN_CREDIT_CARD) {
    manager_->client()->ScanCreditCard(base::Bind(
        &AutofillExternalDelegate::OnCreditCardScanned, GetWeakPtr()));
  } else if (identifier == POPUP_ITEM_ID_CREDIT_CARD_SIGNIN_PROMO) {
    manager_->client()->ExecuteCommand(identifier);
  } else if (identifier == POPUP_ITEM_ID_SHOW_ACCOUNT_CARDS) {
    manager_->OnUserAcceptedCardsFromAccountOption();
  } else {
    if (identifier > 0)  // Denotes an Autofill suggestion.
      AutofillMetrics::LogAutofillSuggestionAcceptedIndex(position);

    FillAutofillFormData(identifier, false);
  }

  if (should_show_scan_credit_card_) {
    AutofillMetrics::LogScanCreditCardPromptMetric(
        identifier == POPUP_ITEM_ID_SCAN_CREDIT_CARD
            ? AutofillMetrics::SCAN_CARD_ITEM_SELECTED
            : AutofillMetrics::SCAN_CARD_OTHER_ITEM_SELECTED);
  }

  if (identifier == POPUP_ITEM_ID_SHOW_ACCOUNT_CARDS) {
    should_show_cards_from_account_option_ = false;
    manager_->RefetchCardsAndUpdatePopup(query_id_, query_form_, query_field_);
  } else {
    manager_->client()->HideAutofillPopup();
  }
}

void SetOriginListFlag(const std::string& internal_name,
                       const std::string& value,
                       flags_ui::FlagsStorage* flags_storage) {
  FlagsStateSingleton::GetFlagsState()->SetOriginListFlag(internal_name, value,
                                                          flags_storage);
}

void AutofillPopupViewViews::OnPaint(gfx::Canvas* canvas) {
  if (!controller_)
    return;

  canvas->DrawColor(GetNativeTheme()->GetSystemColor(
      ui::NativeTheme::kColorId_ResultsTableNormalBackground));
  OnPaintBorder(canvas);

  DCHECK_EQ(controller_->GetLineCount(), child_count());
  for (int i = 0; i < controller_->GetLineCount(); ++i) {
    gfx::Rect line_rect = controller_->layout_model().GetRowBounds(i);

    if (controller_->GetSuggestionAt(i).frontend_id ==
        POPUP_ITEM_ID_SEPARATOR) {
      canvas->FillRect(line_rect,
                       GetNativeTheme()->GetSystemColor(
                           ui::NativeTheme::kColorId_ResultsTableDimmedText));
    } else {
      DrawAutofillEntry(canvas, i, line_rect);
    }
  }
}

views::View* AutofillPopupItemView::CreateDescriptionLabel() {
  base::string16 text =
      popup_view_->controller()->GetElidedLabelAt(line_number_);
  return text.empty() ? nullptr : CreateSecondaryLabel(text);
}

void AutofillPopupViewViews::OnSelectedRowChanged(
    base::Optional<int> previous_row_selection,
    base::Optional<int> current_row_selection) {
  SchedulePaint();

  if (previous_row_selection) {
    GetChildRow(*previous_row_selection)->OnUnselected();
  }
  if (current_row_selection) {
    AutofillPopupChildView* current_row = GetChildRow(*current_row_selection);
    current_row->OnSelected();
    current_row->NotifyAccessibilityEvent(ax::mojom::Event::kSelection, true);
  }
}

void AutofillPopupWarningView::CreateContent() {
  AutofillPopupController* controller = popup_view_->controller();

  int horizontal_margin = GetHorizontalMargin();
  int vertical_margin = AutofillPopupBaseView::GetCornerRadius();

  SetLayoutManager(std::make_unique<views::FillLayout>());
  SetBorder(views::CreateEmptyBorder(
      gfx::Insets(vertical_margin, horizontal_margin)));

  views::Label* text_label = CreateLabelWithColorReadabilityDisabled(
      controller->GetElidedValueAt(line_number_),
      ChromeTextContext::CONTEXT_BODY_TEXT_LARGE, ChromeTextStyle::STYLE_RED);
  text_label->SetEnabledColor(popup_view_->GetWarningColor());
  text_label->SetMultiLine(true);
  int max_width =
      std::min(kAutofillPopupMaxWidth,
               PopupViewCommon().CalculateMaxWidth(
                   gfx::ToEnclosingRect(controller->element_bounds()),
                   controller->container_view()));
  max_width -= 2 * horizontal_margin;
  text_label->SetMaximumWidth(max_width);
  text_label->SetHorizontalAlignment(gfx::HorizontalAlignment::ALIGN_LEFT);

  AddChildView(text_label);
}

PopupItemLayoutType AutofillPopupSuggestionView::GetLayoutType() const {
  switch (GetForcedPopupLayoutState()) {
    case ForcedPopupLayoutState::kLeadingIcon:
      return PopupItemLayoutType::kLeadingIcon;
    case ForcedPopupLayoutState::kTrailingIcon:
      return PopupItemLayoutType::kTrailingIcon;
    case ForcedPopupLayoutState::kTwoLinesLeadingIcon:
      return PopupItemLayoutType::kTwoLinesLeadingIcon;
    case ForcedPopupLayoutState::kDefault:
      switch (frontend_id()) {
        case autofill::PopupItemId::POPUP_ITEM_ID_USERNAME_ENTRY:
        case autofill::PopupItemId::POPUP_ITEM_ID_PASSWORD_ENTRY:
        case autofill::PopupItemId::POPUP_ITEM_ID_GENERATE_PASSWORD_ENTRY:
          return PopupItemLayoutType::kLeadingIcon;
        default:
          return PopupItemLayoutType::kTrailingIcon;
      }
  }
}

void AutofillPopupBaseView::OnWidgetDestroying(views::Widget* widget) {
  DCHECK(widget == parent_widget_ || widget == GetWidget());

  RemoveWidgetObservers();

  parent_widget_ = nullptr;

  HideController();
}

views::View* AutofillPopupSuggestionView::CreateDescriptionLabel() {
  if (GetLayoutType() == PopupItemLayoutType::kTwoLinesLeadingIcon)
    return nullptr;
  return AutofillPopupItemView::CreateDescriptionLabel();
}

void AutofillPopupWarningView::GetAccessibleNodeData(
    ui::AXNodeData* node_data) {
  AutofillPopupController* controller = popup_view_->controller();
  if (!controller)
    return;

  node_data->SetName(controller->GetSuggestionAt(line_number_).value);
  node_data->role = ax::mojom::Role::kStaticText;
}

views::View* AutofillPopupSuggestionView::CreateSubtextLabel() {
  if (GetLayoutType() != PopupItemLayoutType::kTwoLinesLeadingIcon)
    return AutofillPopupItemView::CreateSubtextLabel();

  base::string16 label_text =
      popup_view_->controller()->GetSuggestionAt(line_number_).additional_label;
  if (label_text.empty())
    return nullptr;

  views::Label* label = CreateLabelWithStyleAndContext(
      label_text, ChromeTextContext::CONTEXT_BODY_TEXT_SMALL,
      ChromeTextStyle::STYLE_SECONDARY);
  return label;
}

bool PasswordPopupSuggestionView::ShouldUseCustomFontWeightForPrimaryInfo(
    gfx::Font::Weight* font_weight) const {
  return false;
}

void AutofillPopupBaseView::AddExtraInitParams(
    views::Widget::InitParams* params) {
  // Ensure the bubble border is not painted on an opaque background.
  params->opacity = views::Widget::InitParams::TRANSLUCENT_WINDOW;
  params->shadow_type = views::Widget::InitParams::SHADOW_TYPE_NONE;
}

AutofillPopupViewViews::~AutofillPopupViewViews() {}

  MockAutofillManager(AutofillDriver* driver, MockAutofillClient* client)
      : AutofillManager(driver,
                        client,
                        client->GetPersonalDataManager(),
                        client->GetAutocompleteHistoryManager()) {}

AutofillPopupViewViews::AutofillPopupViewViews(
    AutofillPopupController* controller,
    views::Widget* parent_widget)
    : AutofillPopupBaseView(controller, parent_widget),
      controller_(controller) {
  CreateChildViews();
  SetFocusBehavior(FocusBehavior::ALWAYS);
}

bool AutofillPopupSuggestionView::ShouldUseCustomFontWeightForPrimaryInfo(
    gfx::Font::Weight* font_weight) const {
  switch (autofill::GetForcedFontWeight()) {
    case ForcedFontWeight::kDefault:
      return false;

    case ForcedFontWeight::kMedium:
      *font_weight = views::TypographyProvider::MediumWeightForUI();
      return true;

    case ForcedFontWeight::kBold:
      *font_weight = gfx::Font::Weight::BOLD;
      return true;
  }
}

AutofillPopupWarningView* AutofillPopupWarningView::Create(
    AutofillPopupViewNativeViews* popup_view,
    int line_number) {
  AutofillPopupWarningView* result =
      new AutofillPopupWarningView(popup_view, line_number);
  result->Init();
  return result;
}

bool AutofillPopupBaseView::OnMousePressed(const ui::MouseEvent& event) {
  return event.GetClickCount() == 1;
}

void AutofillExternalDelegate::Reset() {
  manager_->client()->HideAutofillPopup();
}

bool IsPasswordManualFallbackEnabled() {
  return base::FeatureList::IsEnabled(kAutofillManualFallback);
}

void AutofillPopupViewViews::OnSuggestionsChanged() {
  CreateChildViews();
  DoUpdateBoundsAndRedrawPopup();
}

bool SkipConditionalFeatureEntry(const FeatureEntry& entry) {
  version_info::Channel channel = chrome::GetChannel();
#if defined(OS_CHROMEOS)
  if (!strcmp("mash", entry.internal_name) &&
      channel == version_info::Channel::STABLE) {
    return true;
  }

  if (!strcmp(ui_devtools::switches::kEnableUiDevTools, entry.internal_name) &&
      channel == version_info::Channel::STABLE) {
    return true;
  }

  if (!strcmp("enable-experimental-crostini-ui", entry.internal_name) &&
      !base::FeatureList::IsEnabled(features::kCrostini)) {
    return true;
  }
#endif  // defined(OS_CHROMEOS)

  if ((!strcmp("data-reduction-proxy-lo-fi", entry.internal_name) ||
       !strcmp("enable-data-reduction-proxy-lite-page", entry.internal_name)) &&
      channel != version_info::Channel::BETA &&
      channel != version_info::Channel::DEV &&
      channel != version_info::Channel::CANARY &&
      channel != version_info::Channel::UNKNOWN) {
    return true;
  }

#if defined(OS_WIN)
  if (!strcmp("enable-hdr", entry.internal_name) &&
      base::win::GetVersion() < base::win::Version::VERSION_WIN10) {
    return true;
  }
#endif  // OS_WIN

  return false;
}

AutofillPopupFooterView* AutofillPopupFooterView::Create(
    AutofillPopupViewNativeViews* popup_view,
    int line_number,
    int frontend_id) {
  AutofillPopupFooterView* result =
      new AutofillPopupFooterView(popup_view, line_number, frontend_id);
  result->Init();
  return result;
}

void AutofillExternalDelegate::ClearPreviewedForm() {
  driver_->RendererShouldClearPreviewedForm();
}

views::View* PasswordPopupSuggestionView::CreateDescriptionLabel() {
  if ((origin_.empty() &&
       GetLayoutType() == PopupItemLayoutType::kTwoLinesLeadingIcon) ||
      masked_password_.empty()) {
    return nullptr;
  }

  views::Label* label = CreateSecondaryLabel(masked_password_);
  label->SetElideBehavior(gfx::TRUNCATE);
  return new ConstrainedWidthView(label, kAutofillPopupPasswordMaxWidth);
}

std::unique_ptr<views::View> AutofillPopupBaseView::CreateWrapperView() {
  return nullptr;
}

  void OnUnselected() { is_selected_ = false; }

int GetContentsVerticalPadding() {
  return ChromeLayoutProvider::Get()->GetDistanceMetric(
      DISTANCE_CONTENT_LIST_VERTICAL_MULTI);
}

void AutofillPopupItemView::OnMouseExited(const ui::MouseEvent& event) {
  AutofillPopupController* controller = popup_view_->controller();
  if (controller)
    controller->SelectionCleared();
}

 void AutofillPopupBaseView::SetClipPath() {
   SkRect local_bounds = gfx::RectToSkRect(GetLocalBounds());
   SkScalar radius = SkIntToScalar(GetCornerRadius());
  SkPath clip_path;
  clip_path.addRoundRect(local_bounds, radius, radius);
  set_clip_path(clip_path);
}

void AutofillExternalDelegate::OnPopupShown() {
  manager_->DidShowSuggestions(has_autofill_suggestions_, query_form_,
                               query_field_);

  if (should_show_scan_credit_card_) {
    AutofillMetrics::LogScanCreditCardPromptMetric(
        AutofillMetrics::SCAN_CARD_ITEM_SHOWN);
  }
}

std::unique_ptr<views::View> AutofillPopupViewViews::CreateWrapperView() {
  auto wrapper_view = std::make_unique<views::ScrollView>();
  scroll_view_ = wrapper_view.get();
  scroll_view_->set_hide_horizontal_scrollbar(true);
  scroll_view_->SetContents(this);
  return wrapper_view;
}

AutofillPopupChildView* AutofillPopupViewViews::GetChildRow(
    size_t child_index) const {
  DCHECK_LT(child_index, static_cast<size_t>(child_count()));
  return static_cast<AutofillPopupChildView*>(
      const_cast<views::View*>(child_at(child_index)));
}

void AutofillPopupSeparatorView::GetAccessibleNodeData(
    ui::AXNodeData* node_data) {
  node_data->role = ax::mojom::Role::kSplitter;
}

int AutofillPopupFooterView::GetPrimaryTextStyle() {
  return ChromeTextStyle::STYLE_SECONDARY;
}

SkColor AutofillPopupBaseView::GetSelectedBackgroundColor() {
  return GetNativeTheme()->GetSystemColor(
      ui::NativeTheme::kColorId_FocusedHighlightedMenuItemBackgroundColor);
}

AutofillPopupFooterView::AutofillPopupFooterView(
    AutofillPopupViewNativeViews* popup_view,
    int line_number,
    int frontend_id)
    : AutofillPopupItemView(popup_view,
                            line_number,
                            frontend_id,
                            AutofillPopupBaseView::GetCornerRadius()) {
  SetFocusBehavior(FocusBehavior::ALWAYS);
}

  void IssueOnQuery(int query_id) {
    const FormData form;
    FormFieldData field;
    field.is_focusable = true;
    field.should_autocomplete = true;

    external_delegate_->OnQuery(query_id, form, field, gfx::RectF());
  }

void AutofillPopupBaseView::VisibilityChanged(View* starting_from,
                                              bool is_visible) {
  if (is_visible) {
    ui::AXPlatformNode::OnInputSuggestionsAvailable();
    NotifyAccessibilityEvent(ax::mojom::Event::kMenuStart, true);
  } else {
    ui::AXPlatformNode::OnInputSuggestionsUnavailable();
    NotifyAccessibilityEvent(ax::mojom::Event::kMenuEnd, true);
  }
}

int AutofillPopupSuggestionView::GetPrimaryTextStyle() {
  return views::style::TextStyle::STYLE_PRIMARY;
}

gfx::Rect AutofillPopupBaseView::CalculateClippingBounds() const {
  if (parent_widget_)
    return parent_widget_->GetClientAreaBoundsInScreen();
  return PopupViewCommon().GetWindowBounds(delegate_->container_view());
}

void AutofillPopupSeparatorView::RefreshStyle() {
  SchedulePaint();
}

SkColor AutofillPopupBaseView::GetFooterBackgroundColor() {
  return GetNativeTheme()->GetSystemColor(
      ui::NativeTheme::kColorId_HighlightedMenuItemBackgroundColor);
}

void AutofillExternalDelegate::RegisterDeletionCallback(
    base::OnceClosure deletion_callback) {
  deletion_callback_ = std::move(deletion_callback);
}

void AutofillExternalDelegate::InsertDataListValues(
    std::vector<Suggestion>* suggestions) {
  if (data_list_values_.empty())
    return;

  std::set<base::string16> data_list_set(data_list_values_.begin(),
                                         data_list_values_.end());
  base::EraseIf(*suggestions, [&data_list_set](const Suggestion& suggestion) {
    return suggestion.frontend_id == POPUP_ITEM_ID_AUTOCOMPLETE_ENTRY &&
           base::ContainsKey(data_list_set, suggestion.value);
  });

#if !defined(OS_ANDROID)
  if (!suggestions->empty()) {
    suggestions->insert(suggestions->begin(), Suggestion());
    (*suggestions)[0].frontend_id = POPUP_ITEM_ID_SEPARATOR;
  }
#endif

  suggestions->insert(suggestions->begin(), data_list_values_.size(),
                      Suggestion());
  for (size_t i = 0; i < data_list_values_.size(); i++) {
    (*suggestions)[i].value = data_list_values_[i];
    (*suggestions)[i].label = data_list_labels_[i];
    (*suggestions)[i].frontend_id = POPUP_ITEM_ID_DATALIST_ENTRY;
  }
}

bool IsAutofillUpstreamAlwaysRequestCardholderNameExperimentEnabled() {
  return base::FeatureList::IsEnabled(
      features::kAutofillUpstreamAlwaysRequestCardholderName);
}

  void IssueOnSuggestionsReturned() {
    std::vector<Suggestion> suggestions;
    suggestions.push_back(Suggestion());
    suggestions[0].frontend_id = kAutofillProfileId;
    external_delegate_->OnSuggestionsReturned(
        kQueryId, suggestions, /*autoselect_first_suggestion=*/false);
  }

void AutofillPopupBaseView::ClearSelection() {
  if (delegate_)
    delegate_->SelectionCleared();
}

bool AutofillExternalDelegate::HasActiveScreenReader() const {
  return ui::AXPlatformNode::GetAccessibilityMode().has_mode(
      ui::AXMode::kScreenReader);
}

LocalCardMigrationExperimentalFlag GetLocalCardMigrationExperimentalFlag() {
  if (!base::FeatureList::IsEnabled(kAutofillCreditCardLocalCardMigration))
    return LocalCardMigrationExperimentalFlag::kMigrationDisabled;

  std::string param = base::GetFieldTrialParamValueByFeature(
      kAutofillCreditCardLocalCardMigration,
      kAutofillCreditCardLocalCardMigrationParameterName);

  if (param ==
      kAutofillCreditCardLocalCardMigrationParameterWithoutSettingsPage) {
    return LocalCardMigrationExperimentalFlag::kMigrationWithoutSettingsPage;
  }
  return LocalCardMigrationExperimentalFlag::kMigrationIncludeSettingsPage;
}

void AutofillPopupRowView::Init() {
  CreateContent();
  RefreshStyle();
}

bool IsAutofillUpstreamEditableCardholderNameExperimentEnabled() {
  return base::FeatureList::IsEnabled(kAutofillUpstreamEditableCardholderName);
}

bool AutofillPopupRowView::OnMousePressed(const ui::MouseEvent& event) {
  return true;
}

AutofillPopupRowView::AutofillPopupRowView(
    AutofillPopupViewNativeViews* popup_view,
    int line_number)
    : popup_view_(popup_view), line_number_(line_number) {
  set_notify_enter_exit_on_child(true);
}

void AutofillPopupItemView::OnMouseReleased(const ui::MouseEvent& event) {
  AutofillPopupController* controller = popup_view_->controller();
  if (controller && event.IsOnlyLeftMouseButton() &&
      HitTestPoint(event.location())) {
    controller->AcceptSuggestion(line_number_);
  }
}

views::Label* AutofillPopupItemView::CreateLabelWithStyleAndContext(
    const base::string16& text,
    int text_context,
    int text_style) const {
  views::Label* label =
      CreateLabelWithColorReadabilityDisabled(text, text_context, text_style);
  label->SetHorizontalAlignment(gfx::ALIGN_LEFT);

  return label;
}

  void OnSelected() { is_selected_ = true; }

AutofillPopupSuggestionView::AutofillPopupSuggestionView(
    AutofillPopupViewNativeViews* popup_view,
    int line_number,
    int frontend_id)
    : AutofillPopupItemView(popup_view, line_number, frontend_id) {
  SetFocusBehavior(FocusBehavior::ALWAYS);
}

void AutofillExternalDelegate::FillAutofillFormData(int unique_id,
                                                    bool is_preview) {
  if (IsAutofillWarningEntry(unique_id))
    return;

  AutofillDriver::RendererFormDataAction renderer_action = is_preview ?
      AutofillDriver::FORM_DATA_ACTION_PREVIEW :
      AutofillDriver::FORM_DATA_ACTION_FILL;

  DCHECK(driver_->RendererIsAvailable());
  manager_->FillOrPreviewForm(renderer_action,
                              query_id_,
                              query_form_,
                              query_field_,
                              unique_id);
}

  void ShowCardsFromAccountOption() {
    should_show_cards_from_account_option_ = true;
  }

void AutofillPopupBaseView::HideController() {
  if (delegate_)
    delegate_->Hide();
 }

SkColor AutofillPopupBaseView::GetSeparatorColor() {
  return GetNativeTheme()->GetSystemColor(
      ui::NativeTheme::kColorId_MenuSeparatorColor);
}

bool IsAutofillWarningEntry(int frontend_id) {
  return frontend_id == POPUP_ITEM_ID_INSECURE_CONTEXT_PAYMENT_DISABLED_MESSAGE;
}

void AutofillPopupViewNativeViews::Show() {
  DoShow();
}

views::View* AutofillPopupItemView::CreateValueLabel() {
  base::string16 text =
      popup_view_->controller()->GetElidedValueAt(line_number_);
  if (popup_view_->controller()
          ->GetSuggestionAt(line_number_)
          .is_value_secondary) {
    return CreateSecondaryLabel(text);
  }

  views::Label* text_label = CreateLabelWithStyleAndContext(
      popup_view_->controller()->GetElidedValueAt(line_number_),
      ChromeTextContext::CONTEXT_BODY_TEXT_LARGE, GetPrimaryTextStyle());

  gfx::Font::Weight font_weight;
  if (ShouldUseCustomFontWeightForPrimaryInfo(&font_weight)) {
    text_label->SetFontList(
        text_label->font_list().DeriveWithWeight(font_weight));
  }

  return text_label;
}

void AutofillPopupViewNativeViews::CreateChildViews() {
  RemoveAllChildViews(true /* delete_children */);
  rows_.clear();

  int line_number = 0;
  bool has_footer = false;

  while (line_number < controller_->GetLineCount()) {
    int frontend_id = controller_->GetSuggestionAt(line_number).frontend_id;
    switch (frontend_id) {
      case autofill::PopupItemId::POPUP_ITEM_ID_CLEAR_FORM:
      case autofill::PopupItemId::POPUP_ITEM_ID_AUTOFILL_OPTIONS:
      case autofill::PopupItemId::POPUP_ITEM_ID_SCAN_CREDIT_CARD:
      case autofill::PopupItemId::POPUP_ITEM_ID_CREDIT_CARD_SIGNIN_PROMO:
      case autofill::PopupItemId::POPUP_ITEM_ID_ALL_SAVED_PASSWORDS_ENTRY:
      case autofill::PopupItemId::POPUP_ITEM_ID_SHOW_ACCOUNT_CARDS:
        has_footer = true;
        break;

      case autofill::PopupItemId::POPUP_ITEM_ID_SEPARATOR:
        rows_.push_back(AutofillPopupSeparatorView::Create(this, line_number));
        break;

      case autofill::PopupItemId::
          POPUP_ITEM_ID_INSECURE_CONTEXT_PAYMENT_DISABLED_MESSAGE:
        rows_.push_back(AutofillPopupWarningView::Create(this, line_number));
        break;

      case autofill::PopupItemId::POPUP_ITEM_ID_USERNAME_ENTRY:
      case autofill::PopupItemId::POPUP_ITEM_ID_PASSWORD_ENTRY:
        rows_.push_back(PasswordPopupSuggestionView::Create(this, line_number,
                                                            frontend_id));
        break;

      default:
        rows_.push_back(AutofillPopupSuggestionView::Create(this, line_number,
                                                            frontend_id));
    }

    if (has_footer)
      break;
    line_number++;
  }

  if (rows_.size()) {
    views::View* body_container = new views::View();
    views::BoxLayout* body_layout = body_container->SetLayoutManager(
        std::make_unique<views::BoxLayout>(views::BoxLayout::kVertical));
    body_layout->set_main_axis_alignment(
        views::BoxLayout::MAIN_AXIS_ALIGNMENT_START);
    for (auto* row : rows_) {
      body_container->AddChildView(row);
    }

    scroll_view_ = new views::ScrollView();
    scroll_view_->set_hide_horizontal_scrollbar(true);
    scroll_view_->SetContents(body_container);
    scroll_view_->set_draw_overflow_indicator(false);
    scroll_view_->ClipHeightTo(0, body_container->GetPreferredSize().height());

    views::View* padding_wrapper = new views::View();
    padding_wrapper->SetBorder(
        views::CreateEmptyBorder(gfx::Insets(GetContentsVerticalPadding(), 0)));
    padding_wrapper->SetLayoutManager(std::make_unique<views::FillLayout>());
    padding_wrapper->AddChildView(scroll_view_);
    AddChildView(padding_wrapper);
    layout_->SetFlexForView(padding_wrapper, 1);
  }

  if (has_footer) {
    views::View* footer_container = new views::View();
    footer_container->SetBackground(
        views::CreateSolidBackground(GetFooterBackgroundColor()));

    views::BoxLayout* footer_layout = footer_container->SetLayoutManager(
        std::make_unique<views::BoxLayout>(views::BoxLayout::kVertical));
    footer_layout->set_main_axis_alignment(
        views::BoxLayout::MAIN_AXIS_ALIGNMENT_START);

    while (line_number < controller_->GetLineCount()) {
      rows_.push_back(AutofillPopupFooterView::Create(
          this, line_number,
          controller_->GetSuggestionAt(line_number).frontend_id));
      footer_container->AddChildView(rows_.back());
      line_number++;
    }

    AddChildView(footer_container);
    layout_->SetFlexForView(footer_container, 0);
  }
}

  MockAutofillClient() {}

PopupItemLayoutType AutofillPopupFooterView::GetLayoutType() const {
  return frontend_id() ==
                 autofill::PopupItemId::POPUP_ITEM_ID_SHOW_ACCOUNT_CARDS
             ? PopupItemLayoutType::kLeadingIcon
             : PopupItemLayoutType::kTrailingIcon;
}

AutofillPopupBaseView::AutofillPopupBaseView(
    AutofillPopupViewDelegate* delegate,
    views::Widget* parent_widget)
    : delegate_(delegate),
      parent_widget_(parent_widget),
      weak_ptr_factory_(this) {}
